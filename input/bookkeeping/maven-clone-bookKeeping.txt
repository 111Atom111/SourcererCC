0#public void testValidGlobalSettings()
        throws Exception
    {
        String basedir = System.getProperty( "basedir", System.getProperty( "user.dir" ) );

        File globalSettingsFile = new File( basedir, "src/conf/settings.xml" );
        assertTrue( globalSettingsFile.getAbsolutePath(), globalSettingsFile.isFile() );

        Reader reader = new InputStreamReader( new FileInputStream( globalSettingsFile ), "UTF-8" );
        try
        {
            new SettingsXpp3Reader().read( reader );
        }
        finally
        {
            reader.close();
        }
    }
1#public void initService( ServiceLocator locator )
    {
        setLogger( locator.getService( Logger.class ) );
        setMetadataResolver( locator.getService( MetadataResolver.class ) );
        setSyncContextFactory( locator.getService( SyncContextFactory.class ) );
        setRepositoryEventDispatcher( locator.getService( RepositoryEventDispatcher.class ) );
    }
2#public DefaultVersionResolver setLogger( Logger logger )
    {
        this.logger = ( logger != null ) ? logger : NullLogger.INSTANCE;
        return this;
    }
3#public DefaultVersionResolver setMetadataResolver( MetadataResolver metadataResolver )
    {
        if ( metadataResolver == null )
        {
            throw new IllegalArgumentException( "metadata resolver has not been specified" );
        }
        this.metadataResolver = metadataResolver;
        return this;
    }
4#public DefaultVersionResolver setSyncContextFactory( SyncContextFactory syncContextFactory )
    {
        if ( syncContextFactory == null )
        {
            throw new IllegalArgumentException( "sync context factory has not been specified" );
        }
        this.syncContextFactory = syncContextFactory;
        return this;
    }
5#public DefaultVersionResolver setRepositoryEventDispatcher( RepositoryEventDispatcher repositoryEventDispatcher )
    {
        if ( repositoryEventDispatcher == null )
        {
            throw new IllegalArgumentException( "repository event dispatcher has not been specified" );
        }
        this.repositoryEventDispatcher = repositoryEventDispatcher;
        return this;
    }
6#public VersionResult resolveVersion( RepositorySystemSession session, VersionRequest request )
        throws VersionResolutionException
    {
        RequestTrace trace = DefaultRequestTrace.newChild( request.getTrace(), request );

        Artifact artifact = request.getArtifact();

        String version = artifact.getVersion();

        VersionResult result = new VersionResult( request );

        Key cacheKey = null;
        RepositoryCache cache = session.getCache();
        if ( cache != null && !ConfigurationProperties.get( session, "aether.versionResolver.noCache", false ) )
        {
            cacheKey = new Key( session, request );

            Object obj = cache.get( session, cacheKey );
            if ( obj instanceof Record )
            {
                Record record = (Record) obj;
                result.setVersion( record.version );
                result.setRepository( CacheUtils.getRepository( session, request.getRepositories(), record.repoClass,
                                                                record.repoId ) );
                return result;
            }
        }

        Metadata metadata;

        if ( RELEASE.equals( version ) )
        {
            metadata =
                new DefaultMetadata( artifact.getGroupId(), artifact.getArtifactId(), MAVEN_METADATA_XML,
                                     Metadata.Nature.RELEASE );
        }
        else if ( LATEST.equals( version ) )
        {
            metadata =
                new DefaultMetadata( artifact.getGroupId(), artifact.getArtifactId(), MAVEN_METADATA_XML,
                                     Metadata.Nature.RELEASE_OR_SNAPSHOT );
        }
        else if ( version.endsWith( SNAPSHOT ) )
        {
            WorkspaceReader workspace = session.getWorkspaceReader();
            if ( workspace != null && workspace.findVersions( artifact ).contains( version ) )
            {
                metadata = null;
                result.setRepository( workspace.getRepository() );
            }
            else
            {
                metadata =
                    new DefaultMetadata( artifact.getGroupId(), artifact.getArtifactId(), version, MAVEN_METADATA_XML,
                                         Metadata.Nature.SNAPSHOT );
            }
        }
        else
        {
            metadata = null;
        }

        if ( metadata == null )
        {
            result.setVersion( version );
        }
        else
        {
            List<MetadataRequest> metadataRequests = new ArrayList<MetadataRequest>( request.getRepositories().size() );

            metadataRequests.add( new MetadataRequest( metadata, null, request.getRequestContext() ) );

            for ( RemoteRepository repository : request.getRepositories() )
            {
                MetadataRequest metadataRequest =
                    new MetadataRequest( metadata, repository, request.getRequestContext() );
                metadataRequest.setDeleteLocalCopyIfMissing( true );
                metadataRequest.setFavorLocalRepository( true );
                metadataRequest.setTrace( trace );
                metadataRequests.add( metadataRequest );
            }

            List<MetadataResult> metadataResults = metadataResolver.resolveMetadata( session, metadataRequests );

            Map<String, VersionInfo> infos = new HashMap<String, VersionInfo>();

            for ( MetadataResult metadataResult : metadataResults )
            {
                result.addException( metadataResult.getException() );

                ArtifactRepository repository = metadataResult.getRequest().getRepository();
                if ( repository == null )
                {
                    repository = session.getLocalRepository();
                }

                Versioning versioning = readVersions( session, trace, metadataResult.getMetadata(), repository, result );
                merge( artifact, infos, versioning, repository );
            }

            if ( RELEASE.equals( version ) )
            {
                resolve( result, infos, RELEASE );
            }
            else if ( LATEST.equals( version ) )
            {
                if ( !resolve( result, infos, LATEST ) )
                {
                    resolve( result, infos, RELEASE );
                }

                if ( result.getVersion() != null && result.getVersion().endsWith( SNAPSHOT ) )
                {
                    VersionRequest subRequest = new VersionRequest();
                    subRequest.setArtifact( artifact.setVersion( result.getVersion() ) );
                    if ( result.getRepository() instanceof RemoteRepository )
                    {
                        subRequest.setRepositories( Collections.singletonList( (RemoteRepository) result.getRepository() ) );
                    }
                    else
                    {
                        subRequest.setRepositories( request.getRepositories() );
                    }
                    VersionResult subResult = resolveVersion( session, subRequest );
                    result.setVersion( subResult.getVersion() );
                    result.setRepository( subResult.getRepository() );
                    for ( Exception exception : subResult.getExceptions() )
                    {
                        result.addException( exception );
                    }
                }
            }
            else
            {
                String key = SNAPSHOT + getKey( artifact.getClassifier(), artifact.getExtension() );
                merge( infos, SNAPSHOT, key );
                if ( !resolve( result, infos, key ) )
                {
                    result.setVersion( version );
                }
            }

            if ( StringUtils.isEmpty( result.getVersion() ) )
            {
                throw new VersionResolutionException( result );
            }
        }

        if ( cacheKey != null && metadata != null && isSafelyCacheable( session, artifact ) )
        {
            cache.put( session, cacheKey, new Record( result.getVersion(), result.getRepository() ) );
        }

        return result;
    }
7#private boolean resolve( VersionResult result, Map<String, VersionInfo> infos, String key )
    {
        VersionInfo info = infos.get( key );
        if ( info != null )
        {
            result.setVersion( info.version );
            result.setRepository( info.repository );
        }
        return info != null;
    }
8#private Versioning readVersions( RepositorySystemSession session, RequestTrace trace, Metadata metadata,
                                     ArtifactRepository repository, VersionResult result )
    {
        Versioning versioning = null;

        FileInputStream fis = null;
        try
        {
            if ( metadata != null )
            {
                SyncContext syncContext = syncContextFactory.newInstance( session, true );

                try
                {
                    syncContext.acquire( null, Collections.singleton( metadata ) );

                    if ( metadata.getFile() != null && metadata.getFile().exists() )
                    {
                        fis = new FileInputStream( metadata.getFile() );
                        org.apache.maven.artifact.repository.metadata.Metadata m =
                            new MetadataXpp3Reader().read( fis, false );
                        versioning = m.getVersioning();

                        /*
                         * NOTE: Users occasionally misuse the id "local" for remote repos which screws up the metadata
                         * of the local repository. This is especially troublesome during snapshot resolution so we try
                         * to handle that gracefully.
                         */
                        if ( versioning != null && repository instanceof LocalRepository )
                        {
                            if ( versioning.getSnapshot() != null && versioning.getSnapshot().getBuildNumber() > 0 )
                            {
                                Versioning repaired = new Versioning();
                                repaired.setLastUpdated( versioning.getLastUpdated() );
                                Snapshot snapshot = new Snapshot();
                                snapshot.setLocalCopy( true );
                                repaired.setSnapshot( snapshot );
                                versioning = repaired;

                                throw new IOException( "Snapshot information corrupted with remote repository data"
                                    + ", please verify that no remote repository uses the id '" + repository.getId()
                                    + "'" );
                            }
                        }
                    }
                }
                finally
                {
                    syncContext.release();
                }
            }
        }
        catch ( Exception e )
        {
            invalidMetadata( session, trace, metadata, repository, e );
            result.addException( e );
        }
        finally
        {
            IOUtil.close( fis );
        }

        return ( versioning != null ) ? versioning : new Versioning();
    }
9#private void invalidMetadata( RepositorySystemSession session, RequestTrace trace, Metadata metadata,
                                  ArtifactRepository repository, Exception exception )
    {
        DefaultRepositoryEvent event = new DefaultRepositoryEvent( EventType.METADATA_INVALID, session, trace );
        event.setMetadata( metadata );
        event.setException( exception );
        event.setRepository( repository );

        repositoryEventDispatcher.dispatch( event );
    }
10#private void merge( Artifact artifact, Map<String, VersionInfo> infos, Versioning versioning,
                        ArtifactRepository repository )
    {
        if ( StringUtils.isNotEmpty( versioning.getRelease() ) )
        {
            merge( RELEASE, infos, versioning.getLastUpdated(), versioning.getRelease(), repository );
        }

        if ( StringUtils.isNotEmpty( versioning.getLatest() ) )
        {
            merge( LATEST, infos, versioning.getLastUpdated(), versioning.getLatest(), repository );
        }

        for ( SnapshotVersion sv : versioning.getSnapshotVersions() )
        {
            if ( StringUtils.isNotEmpty( sv.getVersion() ) )
            {
                String key = getKey( sv.getClassifier(), sv.getExtension() );
                merge( SNAPSHOT + key, infos, sv.getUpdated(), sv.getVersion(), repository );
            }
        }

        Snapshot snapshot = versioning.getSnapshot();
        if ( snapshot != null && versioning.getSnapshotVersions().isEmpty() )
        {
            String version = artifact.getVersion();
            if ( snapshot.getTimestamp() != null && snapshot.getBuildNumber() > 0 )
            {
                String qualifier = snapshot.getTimestamp() + '-' + snapshot.getBuildNumber();
                version = version.substring( 0, version.length() - SNAPSHOT.length() ) + qualifier;
            }
            merge( SNAPSHOT, infos, versioning.getLastUpdated(), version, repository );
        }
    }
11#private void merge( String key, Map<String, VersionInfo> infos, String timestamp, String version,
                        ArtifactRepository repository )
    {
        VersionInfo info = infos.get( key );
        if ( info == null )
        {
            info = new VersionInfo( timestamp, version, repository );
            infos.put( key, info );
        }
        else if ( info.isOutdated( timestamp ) )
        {
            info.version = version;
            info.repository = repository;
            info.timestamp = timestamp;
        }
    }
12#private void merge( Map<String, VersionInfo> infos, String srcKey, String dstKey )
    {
        VersionInfo srcInfo = infos.get( srcKey );
        VersionInfo dstInfo = infos.get( dstKey );

        if ( dstInfo == null
            || ( srcInfo != null && dstInfo.isOutdated( srcInfo.timestamp ) && srcInfo.repository != dstInfo.repository ) )
        {
            infos.put( dstKey, srcInfo );
        }
    }
13#private String getKey( String classifier, String extension )
    {
        return StringUtils.clean( classifier ) + ':' + StringUtils.clean( extension );
    }
14#private boolean isSafelyCacheable( RepositorySystemSession session, Artifact artifact )
    {
        /*
         * The workspace/reactor is in flux so we better not assume definitive information for any of its
         * artifacts/projects.
         */

        WorkspaceReader workspace = session.getWorkspaceReader();
        if ( workspace == null )
        {
            return true;
        }

        Artifact pomArtifact = ArtifactDescriptorUtils.toPomArtifact( artifact );

        return workspace.findArtifact( pomArtifact ) == null;
    }
15#public VersionInfo( String timestamp, String version, ArtifactRepository repository )
        {
            this.timestamp = ( timestamp != null ) ? timestamp : "";
            this.version = version;
            this.repository = repository;
        }
16#public boolean isOutdated( String timestamp )
        {
            return timestamp != null && timestamp.compareTo( this.timestamp ) > 0;
        }
17#public Key( RepositorySystemSession session, VersionRequest request )
        {
            Artifact artifact = request.getArtifact();
            groupId = artifact.getGroupId();
            artifactId = artifact.getArtifactId();
            classifier = artifact.getClassifier();
            extension = artifact.getExtension();
            version = artifact.getVersion();
            localRepo = session.getLocalRepository().getBasedir();
            workspace = CacheUtils.getWorkspace( session );
            repositories = new ArrayList<RemoteRepository>( request.getRepositories().size() );
            boolean repoMan = false;
            for ( RemoteRepository repository : request.getRepositories() )
            {
                if ( repository.isRepositoryManager() )
                {
                    repoMan = true;
                    repositories.addAll( repository.getMirroredRepositories() );
                }
                else
                {
                    repositories.add( repository );
                }
            }
            context = repoMan ? request.getRequestContext() : "";

            int hash = 17;
            hash = hash * 31 + groupId.hashCode();
            hash = hash * 31 + artifactId.hashCode();
            hash = hash * 31 + classifier.hashCode();
            hash = hash * 31 + extension.hashCode();
            hash = hash * 31 + version.hashCode();
            hash = hash * 31 + localRepo.hashCode();
            hash = hash * 31 + CacheUtils.repositoriesHashCode( repositories );
            hashCode = hash;
        }
18#@Override
        public boolean equals( Object obj )
        {
            if ( obj == this )
            {
                return true;
            }
            else if ( obj == null || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && classifier.equals( that.classifier ) && extension.equals( that.extension )
                && version.equals( that.version ) && context.equals( that.context )
                && localRepo.equals( that.localRepo ) && CacheUtils.eq( workspace, that.workspace )
                && CacheUtils.repositoriesEquals( repositories, that.repositories );
        }
19#@Override
        public int hashCode()
        {
            return hashCode;
        }
20#public Record( String version, ArtifactRepository repository )
        {
            this.version = version;
            if ( repository != null )
            {
                repoId = repository.getId();
                repoClass = repository.getClass();
            }
            else
            {
                repoId = null;
                repoClass = null;
            }
        }
21#public static Artifact toPomArtifact( Artifact artifact )
    {
        Artifact pomArtifact = artifact;

        if ( pomArtifact.getClassifier().length() > 0 || !"pom".equals( pomArtifact.getExtension() ) )
        {
            pomArtifact =
                new DefaultArtifact( artifact.getGroupId(), artifact.getArtifactId(), "pom", artifact.getVersion() );
        }

        return pomArtifact;
    }
22#public static RemoteRepository toRemoteRepository( Repository repository )
    {
        RemoteRepository result =
            new RemoteRepository( repository.getId(), repository.getLayout(), repository.getUrl() );
        result.setPolicy( true, toRepositoryPolicy( repository.getSnapshots() ) );
        result.setPolicy( false, toRepositoryPolicy( repository.getReleases() ) );
        return result;
    }
23#public static RepositoryPolicy toRepositoryPolicy( org.apache.maven.model.RepositoryPolicy policy )
    {
        boolean enabled = true;
        String checksums = RepositoryPolicy.CHECKSUM_POLICY_WARN;
        String updates = RepositoryPolicy.UPDATE_POLICY_DAILY;

        if ( policy != null )
        {
            enabled = policy.isEnabled();
            if ( policy.getUpdatePolicy() != null )
            {
                updates = policy.getUpdatePolicy();
            }
            if ( policy.getChecksumPolicy() != null )
            {
                checksums = policy.getChecksumPolicy();
            }
        }

        return new RepositoryPolicy( enabled, updates, checksums );
    }
24#public MetadataGenerator newInstance( RepositorySystemSession session, InstallRequest request )
    {
        return new VersionsMetadataGenerator( session, request );
    }
25#public MetadataGenerator newInstance( RepositorySystemSession session, DeployRequest request )
    {
        return new VersionsMetadataGenerator( session, request );
    }
26#public int getPriority()
    {
        return 5;
    }
27#public void initService( ServiceLocator locator )
    {
        setLogger( locator.getService( Logger.class ) );
        setRemoteRepositoryManager( locator.getService( RemoteRepositoryManager.class ) );
        setVersionResolver( locator.getService( VersionResolver.class ) );
        setArtifactResolver( locator.getService( ArtifactResolver.class ) );
        setRepositoryEventDispatcher( locator.getService( RepositoryEventDispatcher.class ) );
        modelBuilder = locator.getService( ModelBuilder.class );
        if ( modelBuilder == null )
        {
            setModelBuilder( new DefaultModelBuilderFactory().newInstance() );
        }
    }
28#public DefaultArtifactDescriptorReader setLogger( Logger logger )
    {
        this.logger = ( logger != null ) ? logger : NullLogger.INSTANCE;
        return this;
    }
29#public DefaultArtifactDescriptorReader setRemoteRepositoryManager( RemoteRepositoryManager remoteRepositoryManager )
    {
        if ( remoteRepositoryManager == null )
        {
            throw new IllegalArgumentException( "remote repository manager has not been specified" );
        }
        this.remoteRepositoryManager = remoteRepositoryManager;
        return this;
    }
30#public DefaultArtifactDescriptorReader setVersionResolver( VersionResolver versionResolver )
    {
        if ( versionResolver == null )
        {
            throw new IllegalArgumentException( "version resolver has not been specified" );
        }
        this.versionResolver = versionResolver;
        return this;
    }
31#public DefaultArtifactDescriptorReader setArtifactResolver( ArtifactResolver artifactResolver )
    {
        if ( artifactResolver == null )
        {
            throw new IllegalArgumentException( "artifact resolver has not been specified" );
        }
        this.artifactResolver = artifactResolver;
        return this;
    }
32#public DefaultArtifactDescriptorReader setRepositoryEventDispatcher( RepositoryEventDispatcher repositoryEventDispatcher )
    {
        if ( repositoryEventDispatcher == null )
        {
            throw new IllegalArgumentException( "repository event dispatcher has not been specified" );
        }
        this.repositoryEventDispatcher = repositoryEventDispatcher;
        return this;
    }
33#public DefaultArtifactDescriptorReader setModelBuilder( ModelBuilder modelBuilder )
    {
        if ( modelBuilder == null )
        {
            throw new IllegalArgumentException( "model builder has not been specified" );
        }
        this.modelBuilder = modelBuilder;
        return this;
    }
34#public ArtifactDescriptorResult readArtifactDescriptor( RepositorySystemSession session,
                                                            ArtifactDescriptorRequest request )
        throws ArtifactDescriptorException
    {
        ArtifactDescriptorResult result = new ArtifactDescriptorResult( request );

        Model model = loadPom( session, request, result );

        if ( model != null )
        {
            ArtifactTypeRegistry stereotypes = session.getArtifactTypeRegistry();

            for ( Repository r : model.getRepositories() )
            {
                result.addRepository( ArtifactDescriptorUtils.toRemoteRepository( r ) );
            }

            for ( org.apache.maven.model.Dependency dependency : model.getDependencies() )
            {
                result.addDependency( convert( dependency, stereotypes ) );
            }

            DependencyManagement mngt = model.getDependencyManagement();
            if ( mngt != null )
            {
                for ( org.apache.maven.model.Dependency dependency : mngt.getDependencies() )
                {
                    result.addManagedDependency( convert( dependency, stereotypes ) );
                }
            }

            Map<String, Object> properties = new LinkedHashMap<String, Object>();

            Prerequisites prerequisites = model.getPrerequisites();
            if ( prerequisites != null )
            {
                properties.put( "prerequisites.maven", prerequisites.getMaven() );
            }

            List<License> licenses = model.getLicenses();
            properties.put( "license.count", Integer.valueOf( licenses.size() ) );
            for ( int i = 0; i < licenses.size(); i++ )
            {
                License license = licenses.get( i );
                properties.put( "license." + i + ".name", license.getName() );
                properties.put( "license." + i + ".url", license.getUrl() );
                properties.put( "license." + i + ".comments", license.getComments() );
                properties.put( "license." + i + ".distribution", license.getDistribution() );
            }

            result.setProperties( properties );
        }

        return result;
    }
35#private Model loadPom( RepositorySystemSession session, ArtifactDescriptorRequest request,
                           ArtifactDescriptorResult result )
        throws ArtifactDescriptorException
    {
        RequestTrace trace = DefaultRequestTrace.newChild( request.getTrace(), request );

        Set<String> visited = new LinkedHashSet<String>();
        for ( Artifact artifact = request.getArtifact();; )
        {
            try
            {
                VersionRequest versionRequest =
                    new VersionRequest( artifact, request.getRepositories(), request.getRequestContext() );
                versionRequest.setTrace( trace );
                VersionResult versionResult = versionResolver.resolveVersion( session, versionRequest );

                artifact = artifact.setVersion( versionResult.getVersion() );
            }
            catch ( VersionResolutionException e )
            {
                result.addException( e );
                throw new ArtifactDescriptorException( result );
            }

            if ( !visited.add( artifact.getGroupId() + ':' + artifact.getArtifactId() + ':' + artifact.getBaseVersion() ) )
            {
                RepositoryException exception =
                    new RepositoryException( "Artifact relocations form a cycle: " + visited );
                invalidDescriptor( session, trace, artifact, exception );
                if ( session.isIgnoreInvalidArtifactDescriptor() )
                {
                    return null;
                }
                result.addException( exception );
                throw new ArtifactDescriptorException( result );
            }

            Artifact pomArtifact = ArtifactDescriptorUtils.toPomArtifact( artifact );

            ArtifactResult resolveResult;
            try
            {
                ArtifactRequest resolveRequest =
                    new ArtifactRequest( pomArtifact, request.getRepositories(), request.getRequestContext() );
                resolveRequest.setTrace( trace );
                resolveResult = artifactResolver.resolveArtifact( session, resolveRequest );
                pomArtifact = resolveResult.getArtifact();
                result.setRepository( resolveResult.getRepository() );
            }
            catch ( ArtifactResolutionException e )
            {
                if ( e.getCause() instanceof ArtifactNotFoundException )
                {
                    missingDescriptor( session, trace, artifact, (Exception) e.getCause() );
                    if ( session.isIgnoreMissingArtifactDescriptor() )
                    {
                        return null;
                    }
                }
                result.addException( e );
                throw new ArtifactDescriptorException( result );
            }

            Model model;
            try
            {
                ModelBuildingRequest modelRequest = new DefaultModelBuildingRequest();
                modelRequest.setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL );
                modelRequest.setProcessPlugins( false );
                modelRequest.setTwoPhaseBuilding( false );
                modelRequest.setSystemProperties( toProperties( session.getUserProperties(),
                                                                session.getSystemProperties() ) );
                modelRequest.setModelCache( DefaultModelCache.newInstance( session ) );
                modelRequest.setModelResolver( new DefaultModelResolver( session, trace.newChild( modelRequest ),
                                                                         request.getRequestContext(), artifactResolver,
                                                                         remoteRepositoryManager,
                                                                         request.getRepositories() ) );
                if ( resolveResult.getRepository() instanceof WorkspaceRepository )
                {
                    modelRequest.setPomFile( pomArtifact.getFile() );
                }
                else
                {
                    modelRequest.setModelSource( new FileModelSource( pomArtifact.getFile() ) );
                }

                model = modelBuilder.build( modelRequest ).getEffectiveModel();
            }
            catch ( ModelBuildingException e )
            {
                for ( ModelProblem problem : e.getProblems() )
                {
                    if ( problem.getException() instanceof UnresolvableModelException )
                    {
                        result.addException( problem.getException() );
                        throw new ArtifactDescriptorException( result );
                    }
                }
                invalidDescriptor( session, trace, artifact, e );
                if ( session.isIgnoreInvalidArtifactDescriptor() )
                {
                    return null;
                }
                result.addException( e );
                throw new ArtifactDescriptorException( result );
            }

            Relocation relocation = getRelocation( model );

            if ( relocation != null )
            {
                result.addRelocation( artifact );
                artifact =
                    new RelocatedArtifact( artifact, relocation.getGroupId(), relocation.getArtifactId(),
                                           relocation.getVersion() );
                result.setArtifact( artifact );
            }
            else
            {
                return model;
            }
        }
    }
36#private Properties toProperties( Map<String, String> dominant, Map<String, String> recessive )
    {
        Properties props = new Properties();
        if ( recessive != null )
        {
            props.putAll( recessive );
        }
        if ( dominant != null )
        {
            props.putAll( dominant );
        }
        return props;
    }
37#private Relocation getRelocation( Model model )
    {
        Relocation relocation = null;
        DistributionManagement distMngt = model.getDistributionManagement();
        if ( distMngt != null )
        {
            relocation = distMngt.getRelocation();
        }
        return relocation;
    }
38#private Dependency convert( org.apache.maven.model.Dependency dependency, ArtifactTypeRegistry stereotypes )
    {
        ArtifactType stereotype = stereotypes.get( dependency.getType() );
        if ( stereotype == null )
        {
            stereotype = new DefaultArtifactType( dependency.getType() );
        }

        boolean system = dependency.getSystemPath() != null && dependency.getSystemPath().length() > 0;

        Map<String, String> props = null;
        if ( system )
        {
            props = Collections.singletonMap( ArtifactProperties.LOCAL_PATH, dependency.getSystemPath() );
        }

        Artifact artifact =
            new DefaultArtifact( dependency.getGroupId(), dependency.getArtifactId(), dependency.getClassifier(), null,
                                 dependency.getVersion(), props, stereotype );

        List<Exclusion> exclusions = new ArrayList<Exclusion>( dependency.getExclusions().size() );
        for ( org.apache.maven.model.Exclusion exclusion : dependency.getExclusions() )
        {
            exclusions.add( convert( exclusion ) );
        }

        Dependency result = new Dependency( artifact, dependency.getScope(), dependency.isOptional(), exclusions );

        return result;
    }
39#private Exclusion convert( org.apache.maven.model.Exclusion exclusion )
    {
        return new Exclusion( exclusion.getGroupId(), exclusion.getArtifactId(), "*", "*" );
    }
40#private void missingDescriptor( RepositorySystemSession session, RequestTrace trace, Artifact artifact,
                                    Exception exception )
    {
        DefaultRepositoryEvent event =
            new DefaultRepositoryEvent( EventType.ARTIFACT_DESCRIPTOR_MISSING, session, trace );
        event.setArtifact( artifact );
        event.setException( exception );

        repositoryEventDispatcher.dispatch( event );
    }
41#private void invalidDescriptor( RepositorySystemSession session, RequestTrace trace, Artifact artifact,
                                    Exception exception )
    {
        DefaultRepositoryEvent event =
            new DefaultRepositoryEvent( EventType.ARTIFACT_DESCRIPTOR_INVALID, session, trace );
        event.setArtifact( artifact );
        event.setException( exception );

        repositoryEventDispatcher.dispatch( event );
    }
42#public LocalSnapshotMetadata( Artifact artifact, boolean legacyFormat )
    {
        super( createMetadata( artifact, legacyFormat ), null );
        this.legacyFormat = legacyFormat;
    }
43#public LocalSnapshotMetadata( Metadata metadata, File file, boolean legacyFormat )
    {
        super( metadata, file );
        this.legacyFormat = legacyFormat;
    }
44#private static Metadata createMetadata( Artifact artifact, boolean legacyFormat )
    {
        Snapshot snapshot = new Snapshot();
        snapshot.setLocalCopy( true );
        Versioning versioning = new Versioning();
        versioning.setSnapshot( snapshot );

        Metadata metadata = new Metadata();
        metadata.setVersioning( versioning );
        metadata.setGroupId( artifact.getGroupId() );
        metadata.setArtifactId( artifact.getArtifactId() );
        metadata.setVersion( artifact.getBaseVersion() );

        if ( !legacyFormat )
        {
            metadata.setModelVersion( "1.1.0" );
        }

        return metadata;
    }
45#public void bind( Artifact artifact )
    {
        artifacts.add( artifact );
    }
46#public MavenMetadata setFile( File file )
    {
        return new LocalSnapshotMetadata( metadata, file, legacyFormat );
    }
47#public Object getKey()
    {
        return getGroupId() + ':' + getArtifactId() + ':' + getVersion();
    }
48#public static Object getKey( Artifact artifact )
    {
        return artifact.getGroupId() + ':' + artifact.getArtifactId() + ':' + artifact.getBaseVersion();
    }
49#@Override
    protected void merge( Metadata recessive )
    {
        metadata.getVersioning().updateTimestamp();

        if ( !legacyFormat )
        {
            String lastUpdated = metadata.getVersioning().getLastUpdated();

            Map<String, SnapshotVersion> versions = new LinkedHashMap<String, SnapshotVersion>();

            for ( Artifact artifact : artifacts )
            {
                SnapshotVersion sv = new SnapshotVersion();
                sv.setClassifier( artifact.getClassifier() );
                sv.setExtension( artifact.getExtension() );
                sv.setVersion( getVersion() );
                sv.setUpdated( lastUpdated );
                versions.put( getKey( sv.getClassifier(), sv.getExtension() ), sv );
            }

            Versioning versioning = recessive.getVersioning();
            if ( versioning != null )
            {
                for ( SnapshotVersion sv : versioning.getSnapshotVersions() )
                {
                    String key = getKey( sv.getClassifier(), sv.getExtension() );
                    if ( !versions.containsKey( key ) )
                    {
                        versions.put( key, sv );
                    }
                }
            }

            metadata.getVersioning().setSnapshotVersions( new ArrayList<SnapshotVersion>( versions.values() ) );
        }

        artifacts.clear();
    }
50#private String getKey( String classifier, String extension )
    {
        return classifier + ':' + extension;
    }
51#public String getGroupId()
    {
        return metadata.getGroupId();
    }
52#public String getArtifactId()
    {
        return metadata.getArtifactId();
    }
53#public String getVersion()
    {
        return metadata.getVersion();
    }
54#public Nature getNature()
    {
        return Nature.SNAPSHOT;
    }
55#protected MavenMetadata( Metadata metadata, File file )
    {
        this.metadata = metadata;
        this.file = file;
    }
56#public String getType()
    {
        return "maven-metadata.xml";
    }
57#public File getFile()
    {
        return file;
    }
58#public void merge( File existing, File result )
        throws RepositoryException
    {
        Metadata recessive = read( existing );

        merge( recessive );

        write( result, metadata );

        merged = true;
    }
59#public boolean isMerged()
    {
        return merged;
    }
60#protected abstract void merge( Metadata recessive );
61#private Metadata read( File metadataFile )
        throws RepositoryException
    {
        if ( metadataFile.length() <= 0 )
        {
            return new Metadata();
        }

        Reader reader = null;
        try
        {
            reader = ReaderFactory.newXmlReader( metadataFile );
            return new MetadataXpp3Reader().read( reader, false );
        }
        catch ( IOException e )
        {
            throw new RepositoryException( "Could not read metadata " + metadataFile + ": " + e.getMessage(), e );
        }
        catch ( XmlPullParserException e )
        {
            throw new RepositoryException( "Could not parse metadata " + metadataFile + ": " + e.getMessage(), e );
        }
        finally
        {
            IOUtil.close( reader );
        }
    }
62#private void write( File metadataFile, Metadata metadata )
        throws RepositoryException
    {
        Writer writer = null;
        try
        {
            metadataFile.getParentFile().mkdirs();
            writer = WriterFactory.newXmlWriter( metadataFile );
            new MetadataXpp3Writer().write( writer, metadata );
        }
        catch ( IOException e )
        {
            throw new RepositoryException( "Could not write metadata " + metadataFile + ": " + e.getMessage(), e );
        }
        finally
        {
            IOUtil.close( writer );
        }
    }
63#@Override
    public String toString()
    {
        StringBuilder buffer = new StringBuilder( 128 );
        if ( getGroupId().length() > 0 )
        {
            buffer.append( getGroupId() );
        }
        if ( getArtifactId().length() > 0 )
        {
            buffer.append( ':' ).append( getArtifactId() );
        }
        if ( getVersion().length() > 0 )
        {
            buffer.append( ':' ).append( getVersion() );
        }
        buffer.append( '/' ).append( getType() );
        return buffer.toString();
    }
64#public DefaultModelResolver( RepositorySystemSession session, RequestTrace trace, String context,
                                 ArtifactResolver resolver, RemoteRepositoryManager remoteRepositoryManager,
                                 List<RemoteRepository> repositories )
    {
        this.session = session;
        this.trace = trace;
        this.context = context;
        this.resolver = resolver;
        this.remoteRepositoryManager = remoteRepositoryManager;
        this.repositories = repositories;
        this.repositoryIds = new HashSet<String>();
    }
65#private DefaultModelResolver( DefaultModelResolver original )
    {
        this.session = original.session;
        this.trace = original.trace;
        this.context = original.context;
        this.resolver = original.resolver;
        this.remoteRepositoryManager = original.remoteRepositoryManager;
        this.repositories = original.repositories;
        this.repositoryIds = new HashSet<String>( original.repositoryIds );
    }
66#public void addRepository( Repository repository )
        throws InvalidRepositoryException
    {
        if ( !repositoryIds.add( repository.getId() ) )
        {
            return;
        }

        List<RemoteRepository> newRepositories =
            Collections.singletonList( ArtifactDescriptorUtils.toRemoteRepository( repository ) );

        this.repositories =
            remoteRepositoryManager.aggregateRepositories( session, repositories, newRepositories, true );
    }
67#public ModelResolver newCopy()
    {
        return new DefaultModelResolver( this );
    }
68#public ModelSource resolveModel( String groupId, String artifactId, String version )
        throws UnresolvableModelException
    {
        Artifact pomArtifact = new DefaultArtifact( groupId, artifactId, "", "pom", version );

        try
        {
            ArtifactRequest request = new ArtifactRequest( pomArtifact, repositories, context );
            request.setTrace( trace );
            pomArtifact = resolver.resolveArtifact( session, request ).getArtifact();
        }
        catch ( ArtifactResolutionException e )
        {
            throw new UnresolvableModelException( e.getMessage(), groupId, artifactId, version, e );
        }

        File pomFile = pomArtifact.getFile();

        return new FileModelSource( pomFile );
    }
69#public void initService( ServiceLocator locator )
    {
        setLogger( locator.getService( Logger.class ) );
        setMetadataResolver( locator.getService( MetadataResolver.class ) );
        setSyncContextFactory( locator.getService( SyncContextFactory.class ) );
        setRepositoryEventDispatcher( locator.getService( RepositoryEventDispatcher.class ) );
    }
70#public DefaultVersionRangeResolver setLogger( Logger logger )
    {
        this.logger = ( logger != null ) ? logger : NullLogger.INSTANCE;
        return this;
    }
71#public DefaultVersionRangeResolver setMetadataResolver( MetadataResolver metadataResolver )
    {
        if ( metadataResolver == null )
        {
            throw new IllegalArgumentException( "metadata resolver has not been specified" );
        }
        this.metadataResolver = metadataResolver;
        return this;
    }
72#public DefaultVersionRangeResolver setSyncContextFactory( SyncContextFactory syncContextFactory )
    {
        if ( syncContextFactory == null )
        {
            throw new IllegalArgumentException( "sync context factory has not been specified" );
        }
        this.syncContextFactory = syncContextFactory;
        return this;
    }
73#public DefaultVersionRangeResolver setRepositoryEventDispatcher( RepositoryEventDispatcher repositoryEventDispatcher )
    {
        if ( repositoryEventDispatcher == null )
        {
            throw new IllegalArgumentException( "repository event dispatcher has not been specified" );
        }
        this.repositoryEventDispatcher = repositoryEventDispatcher;
        return this;
    }
74#public VersionRangeResult resolveVersionRange( RepositorySystemSession session, VersionRangeRequest request )
        throws VersionRangeResolutionException
    {
        VersionRangeResult result = new VersionRangeResult( request );

        VersionScheme versionScheme = new GenericVersionScheme();

        VersionConstraint versionConstraint;
        try
        {
            versionConstraint = versionScheme.parseVersionConstraint( request.getArtifact().getVersion() );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            result.addException( e );
            throw new VersionRangeResolutionException( result );
        }

        result.setVersionConstraint( versionConstraint );

        if ( versionConstraint.getRanges().isEmpty() )
        {
            result.addVersion( versionConstraint.getVersion() );
        }
        else
        {
            Map<String, ArtifactRepository> versionIndex = getVersions( session, result, request );

            List<Version> versions = new ArrayList<Version>();
            for ( Map.Entry<String, ArtifactRepository> v : versionIndex.entrySet() )
            {
                try
                {
                    Version ver = versionScheme.parseVersion( v.getKey() );
                    if ( versionConstraint.containsVersion( ver ) )
                    {
                        versions.add( ver );
                        result.setRepository( ver, v.getValue() );
                    }
                }
                catch ( InvalidVersionSpecificationException e )
                {
                    result.addException( e );
                }
            }

            Collections.sort( versions );
            result.setVersions( versions );
        }

        return result;
    }
75#private Map<String, ArtifactRepository> getVersions( RepositorySystemSession session, VersionRangeResult result,
                                                         VersionRangeRequest request )
    {
        RequestTrace trace = DefaultRequestTrace.newChild( request.getTrace(), request );

        Map<String, ArtifactRepository> versionIndex = new HashMap<String, ArtifactRepository>();

        Metadata metadata =
            new DefaultMetadata( request.getArtifact().getGroupId(), request.getArtifact().getArtifactId(),
                                 MAVEN_METADATA_XML, Metadata.Nature.RELEASE_OR_SNAPSHOT );

        List<MetadataRequest> metadataRequests = new ArrayList<MetadataRequest>( request.getRepositories().size() );

        metadataRequests.add( new MetadataRequest( metadata, null, request.getRequestContext() ) );

        for ( RemoteRepository repository : request.getRepositories() )
        {
            MetadataRequest metadataRequest = new MetadataRequest( metadata, repository, request.getRequestContext() );
            metadataRequest.setDeleteLocalCopyIfMissing( true );
            metadataRequest.setTrace( trace );
            metadataRequests.add( metadataRequest );
        }

        List<MetadataResult> metadataResults = metadataResolver.resolveMetadata( session, metadataRequests );

        WorkspaceReader workspace = session.getWorkspaceReader();
        if ( workspace != null )
        {
            List<String> versions = workspace.findVersions( request.getArtifact() );
            for ( String version : versions )
            {
                versionIndex.put( version, workspace.getRepository() );
            }
        }

        for ( MetadataResult metadataResult : metadataResults )
        {
            result.addException( metadataResult.getException() );

            ArtifactRepository repository = metadataResult.getRequest().getRepository();
            if ( repository == null )
            {
                repository = session.getLocalRepository();
            }

            Versioning versioning = readVersions( session, trace, metadataResult.getMetadata(), repository, result );
            for ( String version : versioning.getVersions() )
            {
                if ( !versionIndex.containsKey( version ) )
                {
                    versionIndex.put( version, repository );
                }
            }
        }

        return versionIndex;
    }
76#private Versioning readVersions( RepositorySystemSession session, RequestTrace trace, Metadata metadata,
                                     ArtifactRepository repository, VersionRangeResult result )
    {
        Versioning versioning = null;

        FileInputStream fis = null;
        try
        {
            if ( metadata != null )
            {
                SyncContext syncContext = syncContextFactory.newInstance( session, true );

                try
                {
                    syncContext.acquire( null, Collections.singleton( metadata ) );

                    if ( metadata.getFile() != null && metadata.getFile().exists() )
                    {
                        fis = new FileInputStream( metadata.getFile() );
                        org.apache.maven.artifact.repository.metadata.Metadata m =
                            new MetadataXpp3Reader().read( fis, false );
                        versioning = m.getVersioning();
                    }
                }
                finally
                {
                    syncContext.release();
                }
            }
        }
        catch ( Exception e )
        {
            invalidMetadata( session, trace, metadata, repository, e );
            result.addException( e );
        }
        finally
        {
            IOUtil.close( fis );
        }

        return ( versioning != null ) ? versioning : new Versioning();
    }
77#private void invalidMetadata( RepositorySystemSession session, RequestTrace trace, Metadata metadata,
                                  ArtifactRepository repository, Exception exception )
    {
        DefaultRepositoryEvent event = new DefaultRepositoryEvent( EventType.METADATA_INVALID, session, trace );
        event.setMetadata( metadata );
        event.setException( exception );
        event.setRepository( repository );

        repositoryEventDispatcher.dispatch( event );
    }
78#/**
     * Creates a new Maven-like repository system session by initializing the session with values typical for
     * Maven-based resolution. In more detail, this constructor configures settings relevant for the processing of
     * dependency graphs, most other settings remain at their generic default value. Use the various setters to further
     * configure the session with authentication, mirror, proxy and other information required for your environment.
     */
    public MavenRepositorySystemSession()
    {
        setMirrorSelector( new DefaultMirrorSelector() );
        setAuthenticationSelector( new DefaultAuthenticationSelector() );
        setProxySelector( new DefaultProxySelector() );

        DependencyTraverser depTraverser = new FatArtifactTraverser();
        setDependencyTraverser( depTraverser );

        DependencyManager depManager = new ClassicDependencyManager();
        setDependencyManager( depManager );

        DependencySelector depFilter =
            new AndDependencySelector( new ScopeDependencySelector( "test", "provided" ),
                                       new OptionalDependencySelector(), new ExclusionDependencySelector() );
        setDependencySelector( depFilter );

        DependencyGraphTransformer transformer =
            new ChainedDependencyGraphTransformer( new ConflictMarker(), new JavaEffectiveScopeCalculator(),
                                                   new NearestVersionConflictResolver(),
                                                   new JavaDependencyContextRefiner() );
        setDependencyGraphTransformer( transformer );

        DefaultArtifactTypeRegistry stereotypes = new DefaultArtifactTypeRegistry();
        stereotypes.add( new DefaultArtifactType( "pom" ) );
        stereotypes.add( new DefaultArtifactType( "maven-plugin", "jar", "", "java" ) );
        stereotypes.add( new DefaultArtifactType( "jar", "jar", "", "java" ) );
        stereotypes.add( new DefaultArtifactType( "ejb", "jar", "", "java" ) );
        stereotypes.add( new DefaultArtifactType( "ejb-client", "jar", "client", "java" ) );
        stereotypes.add( new DefaultArtifactType( "test-jar", "jar", "tests", "java" ) );
        stereotypes.add( new DefaultArtifactType( "javadoc", "jar", "javadoc", "java" ) );
        stereotypes.add( new DefaultArtifactType( "java-source", "jar", "sources", "java", false, false ) );
        stereotypes.add( new DefaultArtifactType( "war", "war", "", "java", false, true ) );
        stereotypes.add( new DefaultArtifactType( "ear", "ear", "", "java", false, true ) );
        stereotypes.add( new DefaultArtifactType( "rar", "rar", "", "java", false, true ) );
        stereotypes.add( new DefaultArtifactType( "par", "par", "", "java", false, true ) );
        setArtifactTypeRegistry( stereotypes );

        setIgnoreInvalidArtifactDescriptor( true );
        setIgnoreMissingArtifactDescriptor( true );

        setSystemProps( System.getProperties() );
        setConfigProps( System.getProperties() );
    }
79#public MetadataGenerator newInstance( RepositorySystemSession session, InstallRequest request )
    {
        return new LocalSnapshotMetadataGenerator( session, request );
    }
80#public MetadataGenerator newInstance( RepositorySystemSession session, DeployRequest request )
    {
        return new RemoteSnapshotMetadataGenerator( session, request );
    }
81#public int getPriority()
    {
        return 10;
    }
82#public VersionsMetadataGenerator( RepositorySystemSession session, InstallRequest request )
    {
        this( session, request.getMetadata() );
    }
83#public VersionsMetadataGenerator( RepositorySystemSession session, DeployRequest request )
    {
        this( session, request.getMetadata() );
    }
84#private VersionsMetadataGenerator( RepositorySystemSession session, Collection<? extends Metadata> metadatas )
    {
        versions = new LinkedHashMap<Object, VersionsMetadata>();
        processedVersions = new LinkedHashMap<Object, VersionsMetadata>();

        /*
         * NOTE: This should be considered a quirk to support interop with Maven's legacy ArtifactDeployer which
         * processes one artifact at a time and hence cannot associate the artifacts from the same project to use the
         * same version index. Allowing the caller to pass in metadata from a previous deployment allows to re-establish
         * the association between the artifacts of the same project.
         */
        for ( Iterator<? extends Metadata> it = metadatas.iterator(); it.hasNext(); )
        {
            Metadata metadata = it.next();
            if ( metadata instanceof VersionsMetadata )
            {
                it.remove();
                VersionsMetadata versionsMetadata = (VersionsMetadata) metadata;
                processedVersions.put( versionsMetadata.getKey(), versionsMetadata );
            }
        }
    }
85#public Collection<? extends Metadata> prepare( Collection<? extends Artifact> artifacts )
    {
        return Collections.emptyList();
    }
86#public Artifact transformArtifact( Artifact artifact )
    {
        return artifact;
    }
87#public Collection<? extends Metadata> finish( Collection<? extends Artifact> artifacts )
    {
        for ( Artifact artifact : artifacts )
        {
            Object key = VersionsMetadata.getKey( artifact );
            if ( processedVersions.get( key ) == null )
            {
                VersionsMetadata versionsMetadata = versions.get( key );
                if ( versionsMetadata == null )
                {
                    versionsMetadata = new VersionsMetadata( artifact );
                    versions.put( key, versionsMetadata );
                }
            }
        }

        return versions.values();
    }
88#public RelocatedArtifact( Artifact artifact, String groupId, String artifactId, String version )
    {
        if ( artifact == null )
        {
            throw new IllegalArgumentException( "no artifact specified" );
        }
        this.artifact = artifact;
        this.groupId = ( groupId != null && groupId.length() > 0 ) ? groupId : null;
        this.artifactId = ( artifactId != null && artifactId.length() > 0 ) ? artifactId : null;
        this.version = ( version != null && version.length() > 0 ) ? version : null;
    }
89#public String getGroupId()
    {
        if ( groupId != null )
        {
            return groupId;
        }
        else
        {
            return artifact.getGroupId();
        }
    }
90#public String getArtifactId()
    {
        if ( artifactId != null )
        {
            return artifactId;
        }
        else
        {
            return artifact.getArtifactId();
        }
    }
91#public String getVersion()
    {
        if ( version != null )
        {
            return version;
        }
        else
        {
            return artifact.getVersion();
        }
    }
92#public String getBaseVersion()
    {
        return toBaseVersion( getVersion() );
    }
93#public boolean isSnapshot()
    {
        return isSnapshot( getVersion() );
    }
94#public String getClassifier()
    {
        return artifact.getClassifier();
    }
95#public String getExtension()
    {
        return artifact.getExtension();
    }
96#public File getFile()
    {
        return artifact.getFile();
    }
97#public String getProperty( String key, String defaultValue )
    {
        return artifact.getProperty( key, defaultValue );
    }
98#public Map<String, String> getProperties()
    {
        return artifact.getProperties();
    }
99#public RemoteSnapshotMetadataGenerator( RepositorySystemSession session, DeployRequest request )
    {
        legacyFormat = ConfigurationProperties.get( session.getConfigProperties(), "maven.metadata.legacy", false );

        snapshots = new LinkedHashMap<Object, RemoteSnapshotMetadata>();

        /*
         * NOTE: This should be considered a quirk to support interop with Maven's legacy ArtifactDeployer which
         * processes one artifact at a time and hence cannot associate the artifacts from the same project to use the
         * same timestamp+buildno for the snapshot versions. Allowing the caller to pass in metadata from a previous
         * deployment allows to re-establish the association between the artifacts of the same project.
         */
        for ( Metadata metadata : request.getMetadata() )
        {
            if ( metadata instanceof RemoteSnapshotMetadata )
            {
                RemoteSnapshotMetadata snapshotMetadata = (RemoteSnapshotMetadata) metadata;
                snapshots.put( snapshotMetadata.getKey(), snapshotMetadata );
            }
        }
    }
100#public Collection<? extends Metadata> prepare( Collection<? extends Artifact> artifacts )
    {
        for ( Artifact artifact : artifacts )
        {
            if ( artifact.isSnapshot() )
            {
                Object key = RemoteSnapshotMetadata.getKey( artifact );
                RemoteSnapshotMetadata snapshotMetadata = snapshots.get( key );
                if ( snapshotMetadata == null )
                {
                    snapshotMetadata = new RemoteSnapshotMetadata( artifact, legacyFormat );
                    snapshots.put( key, snapshotMetadata );
                }
                snapshotMetadata.bind( artifact );
            }
        }

        return snapshots.values();
    }
101#public Artifact transformArtifact( Artifact artifact )
    {
        if ( artifact.isSnapshot() && artifact.getVersion().equals( artifact.getBaseVersion() ) )
        {
            Object key = RemoteSnapshotMetadata.getKey( artifact );
            RemoteSnapshotMetadata snapshotMetadata = snapshots.get( key );
            if ( snapshotMetadata != null )
            {
                artifact = artifact.setVersion( snapshotMetadata.getExpandedVersion( artifact ) );
            }
        }

        return artifact;
    }
102#public Collection<? extends Metadata> finish( Collection<? extends Artifact> artifacts )
    {
        return Collections.emptyList();
    }
103#public static ModelCache newInstance( RepositorySystemSession session )
    {
        if ( session.getCache() == null )
        {
            return null;
        }
        else
        {
            return new DefaultModelCache( session );
        }
    }
104#private DefaultModelCache( RepositorySystemSession session )
    {
        this.session = session;
        this.cache = session.getCache();
    }
105#public Object get( String groupId, String artifactId, String version, String tag )
    {
        return cache.get( session, new Key( groupId, artifactId, version, tag ) );
    }
106#public void put( String groupId, String artifactId, String version, String tag, Object data )
    {
        cache.put( session, new Key( groupId, artifactId, version, tag ), data );
    }
107#public Key( String groupId, String artifactId, String version, String tag )
        {
            this.groupId = groupId;
            this.artifactId = artifactId;
            this.version = version;
            this.tag = tag;

            int h = 17;
            h = h * 31 + this.groupId.hashCode();
            h = h * 31 + this.artifactId.hashCode();
            h = h * 31 + this.version.hashCode();
            h = h * 31 + this.tag.hashCode();
            hash = h;
        }
108#@Override
        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( null == obj || !getClass().equals( obj.getClass() ) )
            {
                return false;
            }

            Key that = (Key) obj;
            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }
109#@Override
        public int hashCode()
        {
            return hash;
        }
110#/**
     * Creates a new service locator that already knows about all service implementations included this library.
     */
    public DefaultServiceLocator()
    {
        addService( ArtifactDescriptorReader.class, DefaultArtifactDescriptorReader.class );
        addService( VersionResolver.class, DefaultVersionResolver.class );
        addService( VersionRangeResolver.class, DefaultVersionRangeResolver.class );
        addService( MetadataGeneratorFactory.class, SnapshotMetadataGeneratorFactory.class );
        addService( MetadataGeneratorFactory.class, VersionsMetadataGeneratorFactory.class );
    }
111#public RemoteSnapshotMetadata( Artifact artifact, boolean legacyFormat )
    {
        super( createMetadata( artifact, legacyFormat ), null );
        this.legacyFormat = legacyFormat;
    }
112#private RemoteSnapshotMetadata( Metadata metadata, File file, boolean legacyFormat )
    {
        super( metadata, file );
        this.legacyFormat = legacyFormat;
    }
113#private static Metadata createMetadata( Artifact artifact, boolean legacyFormat )
    {
        Metadata metadata = new Metadata();
        if ( !legacyFormat )
        {
            metadata.setModelVersion( "1.1.0" );
        }
        metadata.setGroupId( artifact.getGroupId() );
        metadata.setArtifactId( artifact.getArtifactId() );
        metadata.setVersion( artifact.getBaseVersion() );

        return metadata;
    }
114#public void bind( Artifact artifact )
    {
        artifacts.add( artifact );
    }
115#public MavenMetadata setFile( File file )
    {
        return new RemoteSnapshotMetadata( metadata, file, legacyFormat );
    }
116#public Object getKey()
    {
        return getGroupId() + ':' + getArtifactId() + ':' + getVersion();
    }
117#public static Object getKey( Artifact artifact )
    {
        return artifact.getGroupId() + ':' + artifact.getArtifactId() + ':' + artifact.getBaseVersion();
    }
118#public String getExpandedVersion( Artifact artifact )
    {
        String key = getKey( artifact.getClassifier(), artifact.getExtension() );
        return versions.get( key ).getVersion();
    }
119#@Override
    protected void merge( Metadata recessive )
    {
        Snapshot snapshot;
        String lastUpdated = "";

        if ( metadata.getVersioning() == null )
        {
            DateFormat utcDateFormatter = new SimpleDateFormat( "yyyyMMdd.HHmmss" );
            utcDateFormatter.setTimeZone( TimeZone.getTimeZone( "UTC" ) );

            snapshot = new Snapshot();
            snapshot.setBuildNumber( getBuildNumber( recessive ) + 1 );
            snapshot.setTimestamp( utcDateFormatter.format( new Date() ) );

            Versioning versioning = new Versioning();
            versioning.setSnapshot( snapshot );
            versioning.setLastUpdated( snapshot.getTimestamp().replace( ".", "" ) );
            lastUpdated = versioning.getLastUpdated();

            metadata.setVersioning( versioning );
        }
        else
        {
            snapshot = metadata.getVersioning().getSnapshot();
            lastUpdated = metadata.getVersioning().getLastUpdated();
        }

        for ( Artifact artifact : artifacts )
        {
            String version = artifact.getVersion();

            if ( version.endsWith( SNAPSHOT ) )
            {
                String qualifier = snapshot.getTimestamp() + "-" + snapshot.getBuildNumber();
                version = version.substring( 0, version.length() - SNAPSHOT.length() ) + qualifier;
            }

            SnapshotVersion sv = new SnapshotVersion();
            sv.setClassifier( artifact.getClassifier() );
            sv.setExtension( artifact.getExtension() );
            sv.setVersion( version );
            sv.setUpdated( lastUpdated );
            versions.put( getKey( sv.getClassifier(), sv.getExtension() ), sv );
        }

        artifacts.clear();

        Versioning versioning = recessive.getVersioning();
        if ( versioning != null )
        {
            for ( SnapshotVersion sv : versioning.getSnapshotVersions() )
            {
                String key = getKey( sv.getClassifier(), sv.getExtension() );
                if ( !versions.containsKey( key ) )
                {
                    versions.put( key, sv );
                }
            }
        }

        if ( !legacyFormat )
        {
            metadata.getVersioning().setSnapshotVersions( new ArrayList<SnapshotVersion>( versions.values() ) );
        }
    }
120#private String getKey( String classifier, String extension )
    {
        return classifier + ':' + extension;
    }
121#private static int getBuildNumber( Metadata metadata )
    {
        int number = 0;

        Versioning versioning = metadata.getVersioning();
        if ( versioning != null )
        {
            Snapshot snapshot = versioning.getSnapshot();
            if ( snapshot != null && snapshot.getBuildNumber() > 0 )
            {
                number = snapshot.getBuildNumber();
            }
        }

        return number;
    }
122#public String getGroupId()
    {
        return metadata.getGroupId();
    }
123#public String getArtifactId()
    {
        return metadata.getArtifactId();
    }
124#public String getVersion()
    {
        return metadata.getVersion();
    }
125#public Nature getNature()
    {
        return Nature.SNAPSHOT;
    }
126#public LocalSnapshotMetadataGenerator( RepositorySystemSession session, InstallRequest request )
    {
        legacyFormat = ConfigurationProperties.get( session.getConfigProperties(), "maven.metadata.legacy", false );

        snapshots = new LinkedHashMap<Object, LocalSnapshotMetadata>();
    }
127#public Collection<? extends Metadata> prepare( Collection<? extends Artifact> artifacts )
    {
        for ( Artifact artifact : artifacts )
        {
            if ( artifact.isSnapshot() )
            {
                Object key = LocalSnapshotMetadata.getKey( artifact );
                LocalSnapshotMetadata snapshotMetadata = snapshots.get( key );
                if ( snapshotMetadata == null )
                {
                    snapshotMetadata = new LocalSnapshotMetadata( artifact, legacyFormat );
                    snapshots.put( key, snapshotMetadata );
                }
                snapshotMetadata.bind( artifact );
            }
        }

        return Collections.emptyList();
    }
128#public Artifact transformArtifact( Artifact artifact )
    {
        return artifact;
    }
129#public Collection<? extends Metadata> finish( Collection<? extends Artifact> artifacts )
    {
        return snapshots.values();
    }
130#/**
     * Creates a new service locator that already knows about all service implementations included in this library.
     */
    public MavenServiceLocator()
    {
        addService( ArtifactDescriptorReader.class, DefaultArtifactDescriptorReader.class );
        addService( VersionResolver.class, DefaultVersionResolver.class );
        addService( VersionRangeResolver.class, DefaultVersionRangeResolver.class );
        addService( MetadataGeneratorFactory.class, SnapshotMetadataGeneratorFactory.class );
        addService( MetadataGeneratorFactory.class, VersionsMetadataGeneratorFactory.class );
    }
131#public VersionsMetadata( Artifact artifact )
    {
        super( createMetadata( artifact ), null );
        this.artifact = artifact;
    }
132#public VersionsMetadata( Artifact artifact, File file )
    {
        super( createMetadata( artifact ), file );
        this.artifact = artifact;
    }
133#private static Metadata createMetadata( Artifact artifact )
    {
        Versioning versioning = new Versioning();
        versioning.addVersion( artifact.getBaseVersion() );
        if ( !artifact.isSnapshot() )
        {
            versioning.setRelease( artifact.getBaseVersion() );
        }
        if ( "maven-plugin".equals( artifact.getProperty( ArtifactProperties.TYPE, "" ) ) )
        {
            versioning.setLatest( artifact.getBaseVersion() );
        }

        Metadata metadata = new Metadata();
        metadata.setVersioning( versioning );
        metadata.setGroupId( artifact.getGroupId() );
        metadata.setArtifactId( artifact.getArtifactId() );

        return metadata;
    }
134#@Override
    protected void merge( Metadata recessive )
    {
        Versioning versioning = metadata.getVersioning();
        versioning.updateTimestamp();

        if ( recessive.getVersioning() != null )
        {
            if ( versioning.getLatest() == null )
            {
                versioning.setLatest( recessive.getVersioning().getLatest() );
            }
            if ( versioning.getRelease() == null )
            {
                versioning.setRelease( recessive.getVersioning().getRelease() );
            }

            Collection<String> versions = new LinkedHashSet<String>( recessive.getVersioning().getVersions() );
            versions.addAll( versioning.getVersions() );
            versioning.setVersions( new ArrayList<String>( versions ) );
        }
    }
135#public Object getKey()
    {
        return getGroupId() + ':' + getArtifactId();
    }
136#public static Object getKey( Artifact artifact )
    {
        return artifact.getGroupId() + ':' + artifact.getArtifactId();
    }
137#public MavenMetadata setFile( File file )
    {
        return new VersionsMetadata( artifact, file );
    }
138#public String getGroupId()
    {
        return artifact.getGroupId();
    }
139#public String getArtifactId()
    {
        return artifact.getArtifactId();
    }
140#public String getVersion()
    {
        return "";
    }
141#public Nature getNature()
    {
        return artifact.isSnapshot() ? Nature.RELEASE_OR_SNAPSHOT : Nature.RELEASE;
    }
142#public void testGetRepositorySystem()
    {
        ServiceLocator locator = new MavenServiceLocator();
        RepositorySystem repoSys = locator.getService( RepositorySystem.class );
        assertNotNull( repoSys );
    }
143#public void testGetMetadataGeneratorFactories()
    {
        ServiceLocator locator = new MavenServiceLocator();
        assertEquals( 2, locator.getServices( MetadataGeneratorFactory.class ).size() );
    }
144#String getGroupId();
145#String getArtifactId();
146#String getVersion();
147#void setVersion( String version );
148#String getScope();
149#String getType();
150#String getClassifier();
151#boolean hasClassifier();
152#File getFile();
153#void setFile( File destination );
154#String getBaseVersion();
155#void setBaseVersion( String baseVersion );
156#String getId();
157#String getDependencyConflictId();
158#void addMetadata( ArtifactMetadata metadata );
159#Collection<ArtifactMetadata> getMetadataList();
160#void setRepository( ArtifactRepository remoteRepository );
161#ArtifactRepository getRepository();
162#void updateVersion( String version, ArtifactRepository localRepository );
163#String getDownloadUrl();
164#void setDownloadUrl( String downloadUrl );
165#ArtifactFilter getDependencyFilter();
166#void setDependencyFilter( ArtifactFilter artifactFilter );
167#ArtifactHandler getArtifactHandler();
168#List<String> getDependencyTrail();
169#void setDependencyTrail( List<String> dependencyTrail );
170#void setScope( String scope );
171#VersionRange getVersionRange();
172#void setVersionRange( VersionRange newRange );
173#void selectVersion( String version );
174#void setGroupId( String groupId );
175#void setArtifactId( String artifactId );
176#boolean isSnapshot();
177#void setResolved( boolean resolved );
178#boolean isResolved();
179#void setResolvedVersion( String version );
180#void setArtifactHandler( ArtifactHandler handler );
181#boolean isRelease();
182#void setRelease( boolean release );
183#List<ArtifactVersion> getAvailableVersions();
184#void setAvailableVersions( List<ArtifactVersion> versions );
185#boolean isOptional();
186#void setOptional( boolean optional );
187#ArtifactVersion getSelectedVersion()
        throws OverConstrainedVersionException;
188#boolean isSelectedVersionKnown()
        throws OverConstrainedVersionException;
189#public InvalidArtifactRTException( String groupId,
                                       String artifactId,
                                       String version,
                                       String type,
                                       String message )
    {
        this.groupId = groupId;
        this.artifactId = artifactId;
        this.version = version;
        this.type = type;
        this.baseMessage = message;
    }
190#public InvalidArtifactRTException( String groupId,
                                       String artifactId,
                                       String version,
                                       String type,
                                       String message,
                                       Throwable cause )
    {
        super( cause );

        this.groupId = groupId;
        this.artifactId = artifactId;
        this.version = version;
        this.type = type;
        this.baseMessage = message;
    }
191#public String getMessage()
    {
        return "For artifact {" + getArtifactKey() + "}: " + getBaseMessage();
    }
192#public String getBaseMessage()
    {
        return baseMessage;
    }
193#public String getArtifactId()
    {
        return artifactId;
    }
194#public String getGroupId()
    {
        return groupId;
    }
195#public String getType()
    {
        return type;
    }
196#public String getVersion()
    {
        return version;
    }
197#public String getArtifactKey()
    {
        return groupId + ":" + artifactId + ":" + version + ":" + type;
    }
198#public static boolean isSnapshot( String version )
    {
        if ( version != null )
        {
            if ( version.regionMatches( true, version.length() - Artifact.SNAPSHOT_VERSION.length(),
                                        Artifact.SNAPSHOT_VERSION, 0, Artifact.SNAPSHOT_VERSION.length() ) )
            {
                return true;
            }
            else if ( Artifact.VERSION_FILE_PATTERN.matcher( version ).matches() )
            {
                return true;
            }
        }
        return false;
    }
199#public static String toSnapshotVersion( String version )
    {
        if ( version == null )
        {
            throw new IllegalArgumentException( "version: null" );
        }

        Matcher m = Artifact.VERSION_FILE_PATTERN.matcher( version );
        if ( m.matches() )
        {
            return m.group( 1 ) + "-" + Artifact.SNAPSHOT_VERSION;
        }
        else
        {
            return version;
        }
    }
200#public static String versionlessKey( Artifact artifact )
    {
        return versionlessKey( artifact.getGroupId(), artifact.getArtifactId() );
    }
201#public static String versionlessKey( String groupId, String artifactId )
    {
        if ( groupId == null )
        {
            throw new NullPointerException( "groupId is null" );
        }
        if ( artifactId == null )
        {
            throw new NullPointerException( "artifactId is null" );
        }
        return groupId + ":" + artifactId;
    }
202#public static String key( Artifact artifact )
    {
        return key( artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion() );
    }
203#public static String key( String groupId, String artifactId, String version )
    {
        if ( groupId == null )
        {
            throw new NullPointerException( "groupId is null" );
        }
        if ( artifactId == null )
        {
            throw new NullPointerException( "artifactId is null" );
        }
        if ( version == null )
        {
            throw new NullPointerException( "version is null" );
        }

        return groupId + ":" + artifactId + ":" + version;
    }
204#public static Map<String, Artifact> artifactMapByVersionlessId( Collection<Artifact> artifacts )
    {
        Map<String, Artifact> artifactMap = new LinkedHashMap<String, Artifact>();

        if ( artifacts != null )
        {
            for ( Artifact artifact : artifacts )
            {
                artifactMap.put( versionlessKey( artifact ), artifact );
            }
        }

        return artifactMap;
    }
205#public static Artifact copyArtifactSafe( Artifact artifact )
    {
        return ( artifact != null ) ? copyArtifact( artifact ) : null;
    }
206#public static Artifact copyArtifact( Artifact artifact )
    {
        VersionRange range = artifact.getVersionRange();

        // For some reason with the introduction of MNG-1577 we have the case in Yoko where a depMan section has
        // something like the following:
        //
        // <dependencyManagement>
        //     <dependencies>
        //         <!--  Yoko modules -->
        //         <dependency>
        //             <groupId>org.apache.yoko</groupId>
        //             <artifactId>yoko-core</artifactId>
        //             <version>${version}</version>
        //         </dependency>
        // ...
        //
        // And the range is not set so we'll check here and set it. jvz.

        if ( range == null )
        {
            range = VersionRange.createFromVersion( artifact.getVersion() );
        }

        DefaultArtifact clone = new DefaultArtifact( artifact.getGroupId(), artifact.getArtifactId(), range.cloneOf(),
            artifact.getScope(), artifact.getType(), artifact.getClassifier(),
            artifact.getArtifactHandler(), artifact.isOptional() );
        clone.setRelease( artifact.isRelease() );
        clone.setResolvedVersion( artifact.getVersion() );
        clone.setResolved( artifact.isResolved() );
        clone.setFile( artifact.getFile() );

        clone.setAvailableVersions( copyList( artifact.getAvailableVersions() ) );
        if ( artifact.getVersion() != null )
        {
            clone.setBaseVersion( artifact.getBaseVersion() );
        }
        clone.setDependencyFilter( artifact.getDependencyFilter() );
        clone.setDependencyTrail( copyList( artifact.getDependencyTrail() ) );
        clone.setDownloadUrl( artifact.getDownloadUrl() );
        clone.setRepository( artifact.getRepository() );

        return clone;
    }
207#/** Returns <code>to</code> collection */
    public static <T extends Collection<Artifact>> T copyArtifacts( Collection<Artifact> from, T to )
    {
        for ( Artifact artifact : from )
        {
            to.add( ArtifactUtils.copyArtifact( artifact ) );
        }
        return to;
    }
208#public static <K, T extends Map<K, Artifact>> T copyArtifacts( Map<K, ? extends Artifact> from, T to )
    {
        if ( from != null )
        {
            for ( Map.Entry<K, ? extends Artifact> entry : from.entrySet() )
            {
                to.put( entry.getKey(), ArtifactUtils.copyArtifact( entry.getValue() ) );
            }
        }

        return to;
    }
209#private static <T> List<T> copyList( List<T> original )
    {
        List<T> copy = null;

        if ( original != null )
        {
            copy = new ArrayList<T>();

            if ( !original.isEmpty() )
            {
                copy.addAll( original );
            }
        }

        return copy;
    }
210#public DefaultArtifact( String groupId, String artifactId, String version, String scope, String type,
                            String classifier, ArtifactHandler artifactHandler )
    {
        this( groupId, artifactId, VersionRange.createFromVersion( version ), scope, type, classifier, artifactHandler,
              false );
    }
211#public DefaultArtifact( String groupId, String artifactId, VersionRange versionRange, String scope, String type,
                            String classifier, ArtifactHandler artifactHandler )
    {
        this( groupId, artifactId, versionRange, scope, type, classifier, artifactHandler, false );
    }
212#public DefaultArtifact( String groupId, String artifactId, VersionRange versionRange, String scope, String type,
                            String classifier, ArtifactHandler artifactHandler, boolean optional )
    {
        this.groupId = groupId;

        this.artifactId = artifactId;

        this.versionRange = versionRange;

        selectVersionFromNewRangeIfAvailable();

        this.artifactHandler = artifactHandler;

        this.scope = scope;

        this.type = type;

        if ( classifier == null )
        {
            classifier = artifactHandler.getClassifier();
        }

        this.classifier = classifier;

        this.optional = optional;

        validateIdentity();
    }
213#private void validateIdentity()
    {
        if ( empty( groupId ) )
        {
            throw new InvalidArtifactRTException( groupId, artifactId, getVersion(), type,
                "The groupId cannot be empty." );
        }

        if ( artifactId == null )
        {
            throw new InvalidArtifactRTException( groupId, artifactId, getVersion(), type,
                "The artifactId cannot be empty." );
        }

        if ( type == null )
        {
            throw new InvalidArtifactRTException( groupId, artifactId, getVersion(), type,
                "The type cannot be empty." );
        }

        if ( ( version == null ) && ( versionRange == null ) )
        {
            throw new InvalidArtifactRTException( groupId, artifactId, getVersion(), type,
                "The version cannot be empty." );
        }
    }
214#private boolean empty( String value )
    {
        return ( value == null ) || ( value.trim().length() < 1 );
    }
215#public String getClassifier()
    {
        return classifier;
    }
216#public boolean hasClassifier()
    {
        return StringUtils.isNotEmpty( classifier );
    }
217#public String getScope()
    {
        return scope;
    }
218#public String getGroupId()
    {
        return groupId;
    }
219#public String getArtifactId()
    {
        return artifactId;
    }
220#public String getVersion()
    {
        return version;
    }
221#public void setVersion( String version )
    {
        this.version = version;
        setBaseVersionInternal( version );
        versionRange = null;
    }
222#public String getType()
    {
        return type;
    }
223#public void setFile( File file )
    {
        this.file = file;
    }
224#public File getFile()
    {
        return file;
    }
225#public ArtifactRepository getRepository()
    {
        return repository;
    }
226#public void setRepository( ArtifactRepository repository )
    {
        this.repository = repository;
    }
227#// ----------------------------------------------------------------------
    //
    // ----------------------------------------------------------------------

    public String getId()
    {
        return getDependencyConflictId() + ":" + getBaseVersion();
    }
228#public String getDependencyConflictId()
    {
        StringBuilder sb = new StringBuilder( 128 );
        sb.append( getGroupId() );
        sb.append( ":" );
        appendArtifactTypeClassifierString( sb );
        return sb.toString();
    }
229#private void appendArtifactTypeClassifierString( StringBuilder sb )
    {
        sb.append( getArtifactId() );
        sb.append( ":" );
        sb.append( getType() );
        if ( hasClassifier() )
        {
            sb.append( ":" );
            sb.append( getClassifier() );
        }
    }
230#public void addMetadata( ArtifactMetadata metadata )
    {
        if ( metadataMap == null )
        {
            metadataMap = new HashMap<Object, ArtifactMetadata>();
        }

        ArtifactMetadata m = metadataMap.get( metadata.getKey() );
        if ( m != null )
        {
            m.merge( metadata );
        }
        else
        {
            metadataMap.put( metadata.getKey(), metadata );
        }
    }
231#public Collection<ArtifactMetadata> getMetadataList()
    {
        if ( metadataMap == null )
        {
            return Collections.emptyList();
        }

        return metadataMap.values();
    }
232#// ----------------------------------------------------------------------
    // Object overrides
    // ----------------------------------------------------------------------

    public String toString()
    {
        StringBuilder sb = new StringBuilder();
        if ( getGroupId() != null )
        {
            sb.append( getGroupId() );
            sb.append( ":" );
        }
        appendArtifactTypeClassifierString( sb );
        sb.append( ":" );
        if ( getBaseVersionInternal() != null )
        {
            sb.append( getBaseVersionInternal() );
        }
        else
        {
            sb.append( versionRange.toString() );
        }
        if ( scope != null )
        {
            sb.append( ":" );
            sb.append( scope );
        }
        return sb.toString();
    }
233#public int hashCode()
    {
        int result = 17;
        result = 37 * result + groupId.hashCode();
        result = 37 * result + artifactId.hashCode();
        result = 37 * result + type.hashCode();
        if ( version != null )
        {
            result = 37 * result + version.hashCode();
        }
        result = 37 * result + ( classifier != null ? classifier.hashCode() : 0 );
        return result;
    }
234#public boolean equals( Object o )
    {
        if ( o == this )
        {
            return true;
        }

        if ( !( o instanceof Artifact ) )
        {
            return false;
        }

        Artifact a = (Artifact) o;

        if ( !a.getGroupId().equals( groupId ) )
        {
            return false;
        }
        else if ( !a.getArtifactId().equals( artifactId ) )
        {
            return false;
        }
        else if ( !a.getVersion().equals( version ) )
        {
            return false;
        }
        else if ( !a.getType().equals( type ) )
        {
            return false;
        }
        else if ( a.getClassifier() == null ? classifier != null : !a.getClassifier().equals( classifier ) )
        {
            return false;
        }

        // We don't consider the version range in the comparison, just the resolved version

        return true;
    }
235#public String getBaseVersion()
    {
        if ( baseVersion == null && version != null )
        {
            setBaseVersionInternal( version );
        }

        return baseVersion;
    }
236#protected String getBaseVersionInternal()
    {
        if ( ( baseVersion == null ) && ( version != null ) )
        {
            setBaseVersionInternal( version );
        }

        return baseVersion;
    }
237#public void setBaseVersion( String baseVersion )
    {
        setBaseVersionInternal( baseVersion );
    }
238#protected void setBaseVersionInternal( String baseVersion )
    {
        Matcher m = VERSION_FILE_PATTERN.matcher( baseVersion );

        if ( m.matches() )
        {
            this.baseVersion = m.group( 1 ) + "-" + SNAPSHOT_VERSION;
        }
        else
        {
            this.baseVersion = baseVersion;
        }
    }
239#public int compareTo( Artifact a )
    {
        int result = groupId.compareTo( a.getGroupId() );
        if ( result == 0 )
        {
            result = artifactId.compareTo( a.getArtifactId() );
            if ( result == 0 )
            {
                result = type.compareTo( a.getType() );
                if ( result == 0 )
                {
                    if ( classifier == null )
                    {
                        if ( a.getClassifier() != null )
                        {
                            result = 1;
                        }
                    }
                    else
                    {
                        if ( a.getClassifier() != null )
                        {
                            result = classifier.compareTo( a.getClassifier() );
                        }
                        else
                        {
                            result = -1;
                        }
                    }
                    if ( result == 0 )
                    {
                        // We don't consider the version range in the comparison, just the resolved version
                        result = new DefaultArtifactVersion( version ).compareTo(
                            new DefaultArtifactVersion( a.getVersion() ) );
                    }
                }
            }
        }
        return result;
    }
240#public void updateVersion( String version, ArtifactRepository localRepository )
    {
        setResolvedVersion( version );
        setFile( new File( localRepository.getBasedir(), localRepository.pathOf( this ) ) );
    }
241#public String getDownloadUrl()
    {
        return downloadUrl;
    }
242#public void setDownloadUrl( String downloadUrl )
    {
        this.downloadUrl = downloadUrl;
    }
243#public ArtifactFilter getDependencyFilter()
    {
        return dependencyFilter;
    }
244#public void setDependencyFilter( ArtifactFilter artifactFilter )
    {
        dependencyFilter = artifactFilter;
    }
245#public ArtifactHandler getArtifactHandler()
    {
        return artifactHandler;
    }
246#public List<String> getDependencyTrail()
    {
        return dependencyTrail;
    }
247#public void setDependencyTrail( List<String> dependencyTrail )
    {
        this.dependencyTrail = dependencyTrail;
    }
248#public void setScope( String scope )
    {
        this.scope = scope;
    }
249#public VersionRange getVersionRange()
    {
        return versionRange;
    }
250#public void setVersionRange( VersionRange versionRange )
    {
        this.versionRange = versionRange;
        selectVersionFromNewRangeIfAvailable();
    }
251#private void selectVersionFromNewRangeIfAvailable()
    {
        if ( ( versionRange != null ) && ( versionRange.getRecommendedVersion() != null ) )
        {
            selectVersion( versionRange.getRecommendedVersion().toString() );
        }
        else
        {
            version = null;
            baseVersion = null;
        }
    }
252#public void selectVersion( String version )
    {
        this.version = version;
        setBaseVersionInternal( version );
    }
253#public void setGroupId( String groupId )
    {
        this.groupId = groupId;
    }
254#public void setArtifactId( String artifactId )
    {
        this.artifactId = artifactId;
    }
255#public boolean isSnapshot()
    {
        return getBaseVersion() != null
            && ( getBaseVersion().endsWith( SNAPSHOT_VERSION ) || getBaseVersion().equals( LATEST_VERSION ) );
    }
256#public void setResolved( boolean resolved )
    {
        this.resolved = resolved;
    }
257#public boolean isResolved()
    {
        return resolved;
    }
258#public void setResolvedVersion( String version )
    {
        this.version = version;
        // retain baseVersion
    }
259#public void setArtifactHandler( ArtifactHandler artifactHandler )
    {
        this.artifactHandler = artifactHandler;
    }
260#public void setRelease( boolean release )
    {
        this.release = release;
    }
261#public boolean isRelease()
    {
        return release;
    }
262#public List<ArtifactVersion> getAvailableVersions()
    {
        return availableVersions;
    }
263#public void setAvailableVersions( List<ArtifactVersion> availableVersions )
    {
        this.availableVersions = availableVersions;
    }
264#public boolean isOptional()
    {
        return optional;
    }
265#public ArtifactVersion getSelectedVersion()
        throws OverConstrainedVersionException
    {
        return versionRange.getSelectedVersion( this );
    }
266#public boolean isSelectedVersionKnown()
        throws OverConstrainedVersionException
    {
        return versionRange.isSelectedVersionKnown( this );
    }
267#public void setOptional( boolean optional )
    {
        this.optional = optional;
    }
268#String getExtension();
269#String getDirectory();
270#String getClassifier();
271#String getPackaging();
272#boolean isIncludesDependencies();
273#String getLanguage();
274#boolean isAddedToClasspath();
275#void merge( ArtifactMetadata metadata );
276#public ArtifactRepositoryPolicy()
    {
        this( true, null, null );
    }
277#public ArtifactRepositoryPolicy( ArtifactRepositoryPolicy policy )
    {
        this( policy.isEnabled(), policy.getUpdatePolicy(), policy.getChecksumPolicy() );
    }
278#public ArtifactRepositoryPolicy( boolean enabled, String updatePolicy, String checksumPolicy )
    {
        this.enabled = enabled;

        if ( updatePolicy == null )
        {
            updatePolicy = UPDATE_POLICY_DAILY;
        }
        this.updatePolicy = updatePolicy;

        if ( checksumPolicy == null )
        {
            checksumPolicy = CHECKSUM_POLICY_WARN;
        }
        this.checksumPolicy = checksumPolicy;
    }
279#public void setEnabled( boolean enabled )
    {
        this.enabled = enabled;
    }
280#public void setUpdatePolicy( String updatePolicy )
    {
        if ( updatePolicy != null )
        {
            this.updatePolicy = updatePolicy;
        }
    }
281#public void setChecksumPolicy( String checksumPolicy )
    {
        if ( checksumPolicy != null )
        {
            this.checksumPolicy = checksumPolicy;
        }
    }
282#public boolean isEnabled()
    {
        return enabled;
    }
283#public String getUpdatePolicy()
    {
        return updatePolicy;
    }
284#public String getChecksumPolicy()
    {
        return checksumPolicy;
    }
285#public boolean checkOutOfDate( Date lastModified )
    {
        boolean checkForUpdates = false;

        if ( UPDATE_POLICY_ALWAYS.equals( updatePolicy ) )
        {
            checkForUpdates = true;
        }
        else if ( UPDATE_POLICY_DAILY.equals( updatePolicy ) )
        {
            // Get local midnight boundary
            Calendar cal = Calendar.getInstance();

            cal.set( Calendar.HOUR_OF_DAY, 0 );
            cal.set( Calendar.MINUTE, 0 );
            cal.set( Calendar.SECOND, 0 );
            cal.set( Calendar.MILLISECOND, 0 );

            if ( cal.getTime().after( lastModified ) )
            {
                checkForUpdates = true;
            }
        }
        else if ( updatePolicy.startsWith( UPDATE_POLICY_INTERVAL ) )
        {
            String s = updatePolicy.substring( UPDATE_POLICY_INTERVAL.length() + 1 );
            int minutes = Integer.valueOf( s );
            Calendar cal = Calendar.getInstance();
            cal.add( Calendar.MINUTE, -minutes );
            if ( cal.getTime().after( lastModified ) )
            {
                checkForUpdates = true;
            }
        }
        // else assume "never"
        return checkForUpdates;
    }
286#@Override
    public String toString()
    {
        StringBuilder buffer = new StringBuilder( 64 );
        buffer.append( "{enabled=" );
        buffer.append( enabled );
        buffer.append( ", checksums=" );
        buffer.append( checksumPolicy );
        buffer.append( ", updates=" );
        buffer.append( updatePolicy );
        buffer.append( "}" );
        return buffer.toString();
    }
287#public void merge( ArtifactRepositoryPolicy policy )
    {
        if ( policy != null && policy.isEnabled() )
        {
            setEnabled( true );

            if ( ordinalOfChecksumPolicy( policy.getChecksumPolicy() ) < ordinalOfChecksumPolicy( getChecksumPolicy() ) )
            {
                setChecksumPolicy( policy.getChecksumPolicy() );
            }

            if ( ordinalOfUpdatePolicy( policy.getUpdatePolicy() ) < ordinalOfUpdatePolicy( getUpdatePolicy() ) )
            {
                setUpdatePolicy( policy.getUpdatePolicy() );
            }
        }
    }
288#private int ordinalOfChecksumPolicy( String policy )
    {
        if ( ArtifactRepositoryPolicy.CHECKSUM_POLICY_FAIL.equals( policy ) )
        {
            return 2;
        }
        else if ( ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE.equals( policy ) )
        {
            return 0;
        }
        else
        {
            return 1;
        }
    }
289#private int ordinalOfUpdatePolicy( String policy )
    {
        if ( ArtifactRepositoryPolicy.UPDATE_POLICY_DAILY.equals( policy ) )
        {
            return 1440;
        }
        else if ( ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS.equals( policy ) )
        {
            return 0;
        }
        else if ( policy != null && policy.startsWith( ArtifactRepositoryPolicy.UPDATE_POLICY_INTERVAL ) )
        {
            String s = policy.substring( UPDATE_POLICY_INTERVAL.length() + 1 );
            return Integer.valueOf( s );
        }
        else
        {
            return Integer.MAX_VALUE;
        }
    }
290#String pathOf( Artifact artifact );
291#String pathOfRemoteRepositoryMetadata( ArtifactMetadata artifactMetadata );
292#String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository );
293#String getUrl();
294#void setUrl( String url );
295#String getBasedir();
296#String getProtocol();
297#String getId();
298#void setId( String id );
299#ArtifactRepositoryPolicy getSnapshots();
300#void setSnapshotUpdatePolicy( ArtifactRepositoryPolicy policy );
301#ArtifactRepositoryPolicy getReleases();
302#void setReleaseUpdatePolicy( ArtifactRepositoryPolicy policy );
303#ArtifactRepositoryLayout getLayout();
304#void setLayout( ArtifactRepositoryLayout layout );
305#String getKey();
306#@Deprecated
    boolean isUniqueVersion();
307#@Deprecated
    boolean isBlacklisted();
308#@Deprecated
    void setBlacklisted( boolean blackListed );
309#//
    // New interface methods for the repository system.
    //
    Artifact find( Artifact artifact );
310#/**
     * Finds the versions of the specified artifact that are available in this repository.
     *
     * @param artifact The artifact whose available versions should be determined, must not be {@code null}.
     * @return The available versions of the artifact or an empty list if none, never {@code null}.
     */
    List<String> findVersions( Artifact artifact );
311#/**
     * Indicates whether this repository is backed by actual projects. For instance, the build reactor or IDE workspace
     * are examples of such repositories.
     *
     * @return {@code true} if the repository is backed by actual projects, {@code false} otherwise.
     */
    boolean isProjectAware();
312#void setAuthentication( Authentication authentication );
313#Authentication getAuthentication();
314#void setProxy( Proxy proxy );
315#Proxy getProxy();
316#List<ArtifactRepository> getMirroredRepositories();
317#void setMirroredRepositories( List<ArtifactRepository> mirroredRepositories );
318#public Authentication( String userName, String password )
    {
        this.username = userName;
        this.password = password;
    }
319#/**
     * Get the user's password which is used when connecting to the repository.
     * 
     * @return password of user
     */
    public String getPassword()
    {
        return password;
    }
320#/**
     * Set the user's password which is used when connecting to the repository.
     * 
     * @param password password of the user
     */
    public void setPassword( String password )
    {
        this.password = password;
    }
321#/**
     * Get the username used to access the repository.
     * 
     * @return username at repository
     */
    public String getUsername()
    {
        return username;
    }
322#/**
     * Set username used to access the repository.
     * 
     * @param userName the username used to access repository
     */
    public void setUsername( final String userName )
    {
        this.username = userName;
    }
323#/**
     * Get the passphrase of the private key file. The passphrase is used only when host/protocol supports
     * authentication via exchange of private/public keys and private key was used for authentication.
     * 
     * @return passphrase of the private key file
     */
    public String getPassphrase()
    {
        return passphrase;
    }
324#/**
     * Set the passphrase of the private key file.
     * 
     * @param passphrase passphrase of the private key file
     */
    public void setPassphrase( final String passphrase )
    {
        this.passphrase = passphrase;
    }
325#/**
     * Get the absolute path to the private key file.
     * 
     * @return absolute path to private key
     */
    public String getPrivateKey()
    {
        return privateKey;
    }
326#/**
     * Set the absolute path to private key file.
     * 
     * @param privateKey path to private key in local file system
     */
    public void setPrivateKey( final String privateKey )
    {
        this.privateKey = privateKey;
    }
327#ArtifactRepository newMavenArtifactRepository( String id, String url, ArtifactRepositoryPolicy snapshots,
                                                   ArtifactRepositoryPolicy releases );
328#String getId();
329#String pathOf( Artifact artifact );
330#String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository );
331#String pathOfRemoteRepositoryMetadata( ArtifactMetadata metadata );
332#public RepositoryMetadataStoreException( String message )
    {
        super( message );
    }
333#public RepositoryMetadataStoreException( String message,
                                             Exception e )
    {
        super( message, e );
    }
334#/** @deprecated use {@link #MultipleArtifactsNotFoundException(Artifact, List, List, List)} */
    @Deprecated
    public MultipleArtifactsNotFoundException( Artifact originatingArtifact,
                                               List<Artifact> missingArtifacts,
                                               List<ArtifactRepository> remoteRepositories )
    {
        this( originatingArtifact, new ArrayList<Artifact>(), missingArtifacts, remoteRepositories );
    }
335#/**
     * Create an instance of the exception with allrequired information.
     *
     * @param originatingArtifact the artifact that was being resolved
     * @param resolvedArtifacts   artifacts that could be resolved
     * @param missingArtifacts    artifacts that could not be resolved
     * @param remoteRepositories  remote repositories where the missing artifacts were not found
     */
    public MultipleArtifactsNotFoundException( Artifact originatingArtifact,
                                               List<Artifact> resolvedArtifacts,
                                               List<Artifact> missingArtifacts,
                                               List<ArtifactRepository> remoteRepositories )
    {
        super( constructMessage( missingArtifacts ), originatingArtifact, remoteRepositories );
        this.resolvedArtifacts = resolvedArtifacts;
        this.missingArtifacts = missingArtifacts;
    }
336#/**
     * artifacts that could be resolved
     *
     * @return {@link List} of {@link Artifact}
     */
    public List<Artifact> getResolvedArtifacts()
    {
        return resolvedArtifacts;
    }
337#/**
     * artifacts that could NOT be resolved
     *
     * @return {@link List} of {@link Artifact}
     */
    public List<Artifact> getMissingArtifacts()
    {
        return missingArtifacts;
    }
338#private static String constructMessage( List<Artifact> artifacts )
    {
        StringBuilder buffer = new StringBuilder( "Missing:\n" );

        buffer.append( "----------\n" );

        int counter = 0;

        for ( Artifact artifact : artifacts )
        {
            String message = ( ++counter ) + ") " + artifact.getId();

            buffer.append( constructMissingArtifactMessage( message, "  ", artifact.getGroupId(),
                    artifact.getArtifactId(), artifact.getVersion(), artifact.getType(), artifact.getClassifier(),
                    artifact.getDownloadUrl(), artifact.getDependencyTrail() ) );
        }

        buffer.append( "----------\n" );

        int size = artifacts.size();

        buffer.append( size ).append( " required artifact" );

        if ( size > 1 )
        {
            buffer.append( "s are" );
        }
        else
        {
            buffer.append( " is" );
        }

        buffer.append( " missing.\n\nfor artifact: " );

        return buffer.toString();
    }
339#public ArtifactResolutionException( String message, String groupId, String artifactId, String version, String type,
                                        String classifier, List<ArtifactRepository> remoteRepositories,
                                        List<String> path, Throwable t )
    {
        super( message, groupId, artifactId, version, type, classifier, remoteRepositories, path, t );
    }
340#public ArtifactResolutionException( String message, String groupId, String artifactId, String version, String type,
                                        String classifier, Throwable t )
    {
        super( message, groupId, artifactId, version, type, classifier, null, null, t );
    }
341#public ArtifactResolutionException( String message, Artifact artifact )
    {
        super( message, artifact );
    }
342#public ArtifactResolutionException( String message, Artifact artifact, List<ArtifactRepository> remoteRepositories )
    {
        super( message, artifact, remoteRepositories );
    }
343#public ArtifactResolutionException( String message, Artifact artifact, Throwable cause )
    {
        super( message, artifact, null, cause );
    }
344#public ArtifactResolutionException( String message, Artifact artifact, List<ArtifactRepository> remoteRepositories,
                                        Throwable cause )
    {
        super( message, artifact, remoteRepositories, cause );
    }
345#public CyclicDependencyException( String message,
                                      Artifact artifact )
    {
        super( message, artifact );
        this.artifact = artifact;
    }
346#public Artifact getArtifact()
    {
        return artifact;
    }
347#protected AbstractArtifactResolutionException( String message,
                                                   String groupId,
                                                   String artifactId,
                                                   String version,
                                                   String type,
                                                   String classifier,
                                                   List<ArtifactRepository> remoteRepositories,
                                                   List<String> path )
    {
        this( message, groupId, artifactId, version, type, classifier, remoteRepositories, path, null );
    }
348#protected AbstractArtifactResolutionException( String message,
                                                   String groupId,
                                                   String artifactId,
                                                   String version,
                                                   String type,
                                                   String classifier,
                                                   List<ArtifactRepository> remoteRepositories,
                                                   List<String> path,
                                                   Throwable t )
    {
        super( constructMessageBase( message, groupId, artifactId, version, type, remoteRepositories, path ), t );

        this.originalMessage = message;
        this.groupId = groupId;
        this.artifactId = artifactId;
        this.type = type;
        this.classifier = classifier;
        this.version = version;
        this.remoteRepositories = remoteRepositories;
        this.path = constructArtifactPath( path, "" );
    }
349#protected AbstractArtifactResolutionException( String message,
                                                   Artifact artifact )
    {
        this( message, artifact, null );
    }
350#protected AbstractArtifactResolutionException( String message,
                                                   Artifact artifact,
                                                   List<ArtifactRepository> remoteRepositories )
    {
        this( message, artifact, remoteRepositories, null );
    }
351#protected AbstractArtifactResolutionException( String message,
                                                   Artifact artifact,
                                                   List<ArtifactRepository> remoteRepositories,
                                                   Throwable t )
    {
        this( message, artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), artifact.getType(),
            artifact.getClassifier(), remoteRepositories, artifact.getDependencyTrail(), t );
        this.artifact = artifact;
    }
352#public Artifact getArtifact()
    {
        return artifact;
    }
353#public String getGroupId()
    {
        return groupId;
    }
354#public String getArtifactId()
    {
        return artifactId;
    }
355#public String getVersion()
    {
        return version;
    }
356#public String getType()
    {
        return type;
    }
357#/** @return the classifier */
    public String getClassifier()
    {
        return this.classifier;
    }
358#/** @return the path */
    public String getPath()
    {
        return this.path;
    }
359#public List<ArtifactRepository> getRemoteRepositories()
    {
        return remoteRepositories;
    }
360#public String getOriginalMessage()
    {
        return originalMessage;
    }
361#protected static String constructArtifactPath( List<String> path,
                                                   String indentation )
    {
        StringBuilder sb = new StringBuilder();

        if ( path != null )
        {
            sb.append( LS );
            sb.append( indentation );
            sb.append( "Path to dependency: " );
            sb.append( LS );
            int num = 1;
            for ( Iterator<String> i = path.iterator(); i.hasNext(); num++ )
            {
                sb.append( indentation );
                sb.append( "\t" );
                sb.append( num );
                sb.append( ") " );
                sb.append( i.next() );
                sb.append( LS );
            }
        }

        return sb.toString();
    }
362#private static String constructMessageBase( String message,
                                                String groupId,
                                                String artifactId,
                                                String version,
                                                String type,
                                                List<ArtifactRepository> remoteRepositories,
                                                List<String> path )
    {
        StringBuilder sb = new StringBuilder();

        sb.append( message );

        if ( message == null || !message.contains( "from the specified remote repositories:" ) )
        {
            sb.append( LS );
            sb.append( "  " + groupId + ":" + artifactId + ":" + type + ":" + version );
            sb.append( LS );
            if ( remoteRepositories != null )
            {
                sb.append( LS );
                sb.append( "from the specified remote repositories:" );
                sb.append( LS + "  " );

                if ( remoteRepositories.isEmpty() )
                {
                    sb.append( "(none)" );
                }

                for ( Iterator<ArtifactRepository> i = remoteRepositories.iterator(); i.hasNext(); )
                {
                    ArtifactRepository remoteRepository = i.next();

                    sb.append( remoteRepository.getId() );
                    sb.append( " (" );
                    sb.append( remoteRepository.getUrl() );

                    ArtifactRepositoryPolicy releases = remoteRepository.getReleases();
                    if ( releases != null )
                    {
                        sb.append( ", releases=" ).append( releases.isEnabled() );
                    }

                    ArtifactRepositoryPolicy snapshots = remoteRepository.getSnapshots();
                    if ( snapshots != null )
                    {
                        sb.append( ", snapshots=" ).append( snapshots.isEnabled() );
                    }

                    sb.append( ")" );
                    if ( i.hasNext() )
                    {
                        sb.append( "," ).append( LS ).append( "  " );
                    }
                }
            }

            sb.append( constructArtifactPath( path, "" ) );
            sb.append( LS );
        }

        return sb.toString();
    }
363#protected static String constructMissingArtifactMessage( String message,
                                                             String indentation,
                                                             String groupId,
                                                             String artifactId,
                                                             String version,
                                                             String type,
                                                             String classifier,
                                                             String downloadUrl,
                                                             List<String> path )
    {
        StringBuilder sb = new StringBuilder( message );

        if ( !"pom".equals( type ) )
        {
            if ( downloadUrl != null )
            {
                sb.append( LS );
                sb.append( LS );
                sb.append( indentation );
                sb.append( "Try downloading the file manually from: " );
                sb.append( LS );
                sb.append( indentation );
                sb.append( "    " );
                sb.append( downloadUrl );
            }
            else
            {
                sb.append( LS );
                sb.append( LS );
                sb.append( indentation );
                sb.append( "Try downloading the file manually from the project website." );
            }

            sb.append( LS );
            sb.append( LS );
            sb.append( indentation );
            sb.append( "Then, install it using the command: " );
            sb.append( LS );
            sb.append( indentation );
            sb.append( "    mvn install:install-file -DgroupId=" );
            sb.append( groupId );
            sb.append( " -DartifactId=" );
            sb.append( artifactId );
            sb.append( " -Dversion=" );
            sb.append( version );

            //insert classifier only if it was used in the artifact
            if ( classifier != null && !classifier.equals( "" ) )
            {
                sb.append( " -Dclassifier=" );
                sb.append( classifier );
            }
            sb.append( " -Dpackaging=" );
            sb.append( type );
            sb.append( " -Dfile=/path/to/file" );
            sb.append( LS );

            // If people want to deploy it
            sb.append( LS );
            sb.append( indentation );
            sb.append( "Alternatively, if you host your own repository you can deploy the file there: " );
            sb.append( LS );
            sb.append( indentation );
            sb.append( "    mvn deploy:deploy-file -DgroupId=" );
            sb.append( groupId );
            sb.append( " -DartifactId=" );
            sb.append( artifactId );
            sb.append( " -Dversion=" );
            sb.append( version );

            //insert classifier only if it was used in the artifact
            if ( classifier != null && !classifier.equals( "" ) )
            {
                sb.append( " -Dclassifier=" );
                sb.append( classifier );
            }
            sb.append( " -Dpackaging=" );
            sb.append( type );
            sb.append( " -Dfile=/path/to/file" );
            sb.append( " -Durl=[url] -DrepositoryId=[id]" );
            sb.append( LS );
        }

        sb.append( constructArtifactPath( path, indentation ) );
        sb.append( LS );

        return sb.toString();
    }
364#public String getArtifactPath()
    {
        return path;
    }
365#protected ArtifactNotFoundException( String message, Artifact artifact, List<ArtifactRepository> remoteRepositories )
    {
        super( message, artifact, remoteRepositories );
    }
366#public ArtifactNotFoundException( String message, Artifact artifact )
    {
        this( message, artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), artifact.getType(),
              artifact.getClassifier(), null, artifact.getDownloadUrl(), artifact.getDependencyTrail() );
    }
367#protected ArtifactNotFoundException( String message, Artifact artifact,
                                         List<ArtifactRepository> remoteRepositories, Throwable cause )
    {
        this( message, artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), artifact.getType(),
              artifact.getClassifier(), remoteRepositories, artifact.getDownloadUrl(), artifact.getDependencyTrail(),
              cause );
    }
368#public ArtifactNotFoundException( String message, String groupId, String artifactId, String version, String type,
                                      String classifier, List<ArtifactRepository> remoteRepositories,
                                      String downloadUrl, List<String> path, Throwable cause )
    {
        super( constructMissingArtifactMessage( message, "", groupId, artifactId, version, type, classifier,
                                                downloadUrl, path ), groupId, artifactId, version, type, classifier,
               remoteRepositories, null, cause );

        this.downloadUrl = downloadUrl;
    }
369#private ArtifactNotFoundException( String message, String groupId, String artifactId, String version, String type,
                                       String classifier, List<ArtifactRepository> remoteRepositories,
                                       String downloadUrl, List<String> path )
    {
        super( constructMissingArtifactMessage( message, "", groupId, artifactId, version, type, classifier,
                                                downloadUrl, path ), groupId, artifactId, version, type, classifier,
               remoteRepositories, null );

        this.downloadUrl = downloadUrl;
    }
370#public String getDownloadUrl()
    {
        return downloadUrl;
    }
371#boolean include( Artifact artifact );
372#public Restriction( ArtifactVersion lowerBound, boolean lowerBoundInclusive, ArtifactVersion upperBound,
                        boolean upperBoundInclusive )
    {
        this.lowerBound = lowerBound;
        this.lowerBoundInclusive = lowerBoundInclusive;
        this.upperBound = upperBound;
        this.upperBoundInclusive = upperBoundInclusive;
    }
373#public ArtifactVersion getLowerBound()
    {
        return lowerBound;
    }
374#public boolean isLowerBoundInclusive()
    {
        return lowerBoundInclusive;
    }
375#public ArtifactVersion getUpperBound()
    {
        return upperBound;
    }
376#public boolean isUpperBoundInclusive()
    {
        return upperBoundInclusive;
    }
377#public boolean containsVersion( ArtifactVersion version )
    {
        if ( lowerBound != null )
        {
            int comparison = lowerBound.compareTo( version );

            if ( ( comparison == 0 ) && !lowerBoundInclusive )
            {
                return false;
            }
            if ( comparison > 0 )
            {
                return false;
            }
        }
        if ( upperBound != null )
        {
            int comparison = upperBound.compareTo( version );

            if ( ( comparison == 0 ) && !upperBoundInclusive )
            {
                return false;
            }
            if ( comparison < 0 )
            {
                return false;
            }
        }

        return true;
    }
378#@Override
    public int hashCode()
    {
        int result = 13;

        if ( lowerBound == null )
        {
            result += 1;
        }
        else
        {
            result += lowerBound.hashCode();
        }

        result *= lowerBoundInclusive ? 1 : 2;

        if ( upperBound == null )
        {
            result -= 3;
        }
        else
        {
            result -= upperBound.hashCode();
        }

        result *= upperBoundInclusive ? 2 : 3;

        return result;
    }
379#@Override
    public boolean equals( Object other )
    {
        if ( this == other )
        {
            return true;
        }

        if ( !( other instanceof Restriction ) )
        {
            return false;
        }

        Restriction restriction = (Restriction) other;
        if ( lowerBound != null )
        {
            if ( !lowerBound.equals( restriction.lowerBound ) )
            {
                return false;
            }
        }
        else if ( restriction.lowerBound != null )
        {
            return false;
        }

        if ( lowerBoundInclusive != restriction.lowerBoundInclusive )
        {
            return false;
        }

        if ( upperBound != null )
        {
            if ( !upperBound.equals( restriction.upperBound ) )
            {
                return false;
            }
        }
        else if ( restriction.upperBound != null )
        {
            return false;
        }

        if ( upperBoundInclusive != restriction.upperBoundInclusive )
        {
            return false;
        }

        return true;
    }
380#public String toString()
    {
        StringBuilder buf = new StringBuilder();

        buf.append( isLowerBoundInclusive() ? "[" : "(" );
        if ( getLowerBound() != null )
        {
            buf.append( getLowerBound().toString() );
        }
        buf.append( "," );
        if ( getUpperBound() != null )
        {
            buf.append( getUpperBound().toString() );
        }
        buf.append( isUpperBoundInclusive() ? "]" : ")" );

        return buf.toString();
    }
381#public ComparableVersion( String version )
    {
        parseVersion( version );
    }
382#public final void parseVersion( String version )
    {
        this.value = version;

        items = new ListItem();

        version = version.toLowerCase( Locale.ENGLISH );

        ListItem list = items;

        Stack<Item> stack = new Stack<Item>();
        stack.push( list );

        boolean isDigit = false;

        int startIndex = 0;

        for ( int i = 0; i < version.length(); i++ )
        {
            char c = version.charAt( i );

            if ( c == '.' )
            {
                if ( i == startIndex )
                {
                    list.add( IntegerItem.ZERO );
                }
                else
                {
                    list.add( parseItem( isDigit, version.substring( startIndex, i ) ) );
                }
                startIndex = i + 1;
            }
            else if ( c == '-' )
            {
                if ( i == startIndex )
                {
                    list.add( IntegerItem.ZERO );
                }
                else
                {
                    list.add( parseItem( isDigit, version.substring( startIndex, i ) ) );
                }
                startIndex = i + 1;

                if ( isDigit )
                {
                    list.normalize(); // 1.0-* = 1-*

                    if ( ( i + 1 < version.length() ) && Character.isDigit( version.charAt( i + 1 ) ) )
                    {
                        // new ListItem only if previous were digits and new char is a digit,
                        // ie need to differentiate only 1.1 from 1-1
                        list.add( list = new ListItem() );

                        stack.push( list );
                    }
                }
            }
            else if ( Character.isDigit( c ) )
            {
                if ( !isDigit && i > startIndex )
                {
                    list.add( new StringItem( version.substring( startIndex, i ), true ) );
                    startIndex = i;
                }

                isDigit = true;
            }
            else
            {
                if ( isDigit && i > startIndex )
                {
                    list.add( parseItem( true, version.substring( startIndex, i ) ) );
                    startIndex = i;
                }

                isDigit = false;
            }
        }

        if ( version.length() > startIndex )
        {
            list.add( parseItem( isDigit, version.substring( startIndex ) ) );
        }

        while ( !stack.isEmpty() )
        {
            list = (ListItem) stack.pop();
            list.normalize();
        }

        canonical = items.toString();
    }
383#private static Item parseItem( boolean isDigit, String buf )
    {
        return isDigit ? new IntegerItem( buf ) : new StringItem( buf, false );
    }
384#public int compareTo( ComparableVersion o )
    {
        return items.compareTo( o.items );
    }
385#public String toString()
    {
        return value;
    }
386#public boolean equals( Object o )
    {
        return ( o instanceof ComparableVersion ) && canonical.equals( ( (ComparableVersion) o ).canonical );
    }
387#public int hashCode()
    {
        return canonical.hashCode();
    }
388#int compareTo( Item item );
389#int getType();
390#boolean isNull();
391#private IntegerItem()
        {
            this.value = BigInteger_ZERO;
        }
392#public IntegerItem( String str )
        {
            this.value = new BigInteger( str );
        }
393#public int getType()
        {
            return INTEGER_ITEM;
        }
394#public boolean isNull()
        {
            return BigInteger_ZERO.equals( value );
        }
395#public int compareTo( Item item )
        {
            if ( item == null )
            {
                return BigInteger_ZERO.equals( value ) ? 0 : 1; // 1.0 == 1, 1.1 > 1
            }

            switch ( item.getType() )
            {
                case INTEGER_ITEM:
                    return value.compareTo( ( (IntegerItem) item ).value );

                case STRING_ITEM:
                    return 1; // 1.1 > 1-sp

                case LIST_ITEM:
                    return 1; // 1.1 > 1-1

                default:
                    throw new RuntimeException( "invalid item: " + item.getClass() );
            }
        }
396#public String toString()
        {
            return value.toString();
        }
397#public StringItem( String value, boolean followedByDigit )
        {
            if ( followedByDigit && value.length() == 1 )
            {
                // a1 = alpha-1, b1 = beta-1, m1 = milestone-1
                switch ( value.charAt( 0 ) )
                {
                    case 'a':
                        value = "alpha";
                        break;
                    case 'b':
                        value = "beta";
                        break;
                    case 'm':
                        value = "milestone";
                        break;
                }
            }
            this.value = ALIASES.getProperty( value , value );
        }
398#public int getType()
        {
            return STRING_ITEM;
        }
399#public boolean isNull()
        {
            return ( comparableQualifier( value ).compareTo( RELEASE_VERSION_INDEX ) == 0 );
        }
400#/**
         * Returns a comparable value for a qualifier.
         *
         * This method takes into account the ordering of known qualifiers then unknown qualifiers with lexical ordering.
         *
         * just returning an Integer with the index here is faster, but requires a lot of if/then/else to check for -1
         * or QUALIFIERS.size and then resort to lexical ordering. Most comparisons are decided by the first character,
         * so this is still fast. If more characters are needed then it requires a lexical sort anyway.
         *
         * @param qualifier
         * @return an equivalent value that can be used with lexical comparison
         */
        public static String comparableQualifier( String qualifier )
        {
            int i = _QUALIFIERS.indexOf( qualifier );

            return i == -1 ? ( _QUALIFIERS.size() + "-" + qualifier ) : String.valueOf( i );
        }
401#public int compareTo( Item item )
        {
            if ( item == null )
            {
                // 1-rc < 1, 1-ga > 1
                return comparableQualifier( value ).compareTo( RELEASE_VERSION_INDEX );
            }
            switch ( item.getType() )
            {
                case INTEGER_ITEM:
                    return -1; // 1.any < 1.1 ?

                case STRING_ITEM:
                    return comparableQualifier( value ).compareTo( comparableQualifier( ( (StringItem) item ).value ) );

                case LIST_ITEM:
                    return -1; // 1.any < 1-1

                default:
                    throw new RuntimeException( "invalid item: " + item.getClass() );
            }
        }
402#public String toString()
        {
            return value;
        }
403#public int getType()
        {
            return LIST_ITEM;
        }
404#public boolean isNull()
        {
            return ( size() == 0 );
        }
405#void normalize()
        {
            for( ListIterator<Item> iterator = listIterator( size() ); iterator.hasPrevious(); )
            {
                Item item = iterator.previous();
                if ( item.isNull() )
                {
                    iterator.remove(); // remove null trailing items: 0, "", empty list
                }
                else
                {
                    break;
                }
            }
        }
406#public int compareTo( Item item )
        {
            if ( item == null )
            {
                if ( size() == 0 )
                {
                    return 0; // 1-0 = 1- (normalize) = 1
                }
                Item first = get( 0 );
                return first.compareTo( null );
            }
            switch ( item.getType() )
            {
                case INTEGER_ITEM:
                    return -1; // 1-1 < 1.0.x

                case STRING_ITEM:
                    return 1; // 1-1 > 1-sp

                case LIST_ITEM:
                    Iterator<Item> left = iterator();
                    Iterator<Item> right = ( (ListItem) item ).iterator();

                    while ( left.hasNext() || right.hasNext() )
                    {
                        Item l = left.hasNext() ? left.next() : null;
                        Item r = right.hasNext() ? right.next() : null;

                        // if this is shorter, then invert the compare and mul with -1
                        int result = l == null ? -1 * r.compareTo( l ) : l.compareTo( r );

                        if ( result != 0 )
                        {
                            return result;
                        }
                    }

                    return 0;

                default:
                    throw new RuntimeException( "invalid item: " + item.getClass() );
            }
        }
407#public String toString()
        {
            StringBuilder buffer = new StringBuilder( "(" );
            for( Iterator<Item> iter = iterator(); iter.hasNext(); )
            {
                buffer.append( iter.next() );
                if ( iter.hasNext() )
                {
                    buffer.append( ',' );
                }
            }
            buffer.append( ')' );
            return buffer.toString();
        }
408#public InvalidVersionSpecificationException( String message )
    {
        super( message );
    }
409#public DefaultArtifactVersion( String version )
    {
        parseVersion( version );
    }
410#@Override
    public int hashCode()
    {
        return 11 + comparable.hashCode();
    }
411#@Override
    public boolean equals( Object other )
    {
        if ( this == other )
        {
            return true;
        }

        if ( !( other instanceof ArtifactVersion ) )
        {
            return false;
        }

        return compareTo( (ArtifactVersion) other ) == 0;
    }
412#public int compareTo( ArtifactVersion otherVersion )
    {
        if ( otherVersion instanceof DefaultArtifactVersion )
        {
            return this.comparable.compareTo( ( (DefaultArtifactVersion) otherVersion).comparable );
        }
        else
        {
            return compareTo( new DefaultArtifactVersion( otherVersion.toString() ) );
        }
    }
413#public int getMajorVersion()
    {
        return majorVersion != null ? majorVersion : 0;
    }
414#public int getMinorVersion()
    {
        return minorVersion != null ? minorVersion : 0;
    }
415#public int getIncrementalVersion()
    {
        return incrementalVersion != null ? incrementalVersion : 0;
    }
416#public int getBuildNumber()
    {
        return buildNumber != null ? buildNumber : 0;
    }
417#public String getQualifier()
    {
        return qualifier;
    }
418#public final void parseVersion( String version )
    {
        comparable = new ComparableVersion( version );

        int index = version.indexOf( "-" );

        String part1;
        String part2 = null;

        if ( index < 0 )
        {
            part1 = version;
        }
        else
        {
            part1 = version.substring( 0, index );
            part2 = version.substring( index + 1 );
        }

        if ( part2 != null )
        {
            try
            {
                if ( ( part2.length() == 1 ) || !part2.startsWith( "0" ) )
                {
                    buildNumber = Integer.valueOf( part2 );
                }
                else
                {
                    qualifier = part2;
                }
            }
            catch ( NumberFormatException e )
            {
                qualifier = part2;
            }
        }

        if ( ( part1.indexOf( "." ) < 0 ) && !part1.startsWith( "0" ) )
        {
            try
            {
                majorVersion = Integer.valueOf( part1 );
            }
            catch ( NumberFormatException e )
            {
                // qualifier is the whole version, including "-"
                qualifier = version;
                buildNumber = null;
            }
        }
        else
        {
            boolean fallback = false;

            StringTokenizer tok = new StringTokenizer( part1, "." );
            try
            {
                majorVersion = getNextIntegerToken( tok );
                if ( tok.hasMoreTokens() )
                {
                    minorVersion = getNextIntegerToken( tok );
                }
                if ( tok.hasMoreTokens() )
                {
                    incrementalVersion = getNextIntegerToken( tok );
                }
                if ( tok.hasMoreTokens() )
                {
                    fallback = true;
                }

                // string tokenzier won't detect these and ignores them
                if ( part1.indexOf( ".." ) >= 0 || part1.startsWith( "." ) || part1.endsWith( "." ) )
                {
                    fallback = true;
                }
            }
            catch ( NumberFormatException e )
            {
                fallback = true;
            }

            if ( fallback )
            {
                // qualifier is the whole version, including "-"
                qualifier = version;
                majorVersion = null;
                minorVersion = null;
                incrementalVersion = null;
                buildNumber = null;
            }
        }
    }
419#private static Integer getNextIntegerToken( StringTokenizer tok )
    {
        String s = tok.nextToken();
        if ( ( s.length() > 1 ) && s.startsWith( "0" ) )
        {
            throw new NumberFormatException( "Number part has a leading 0: '" + s + "'" );
        }
        return Integer.valueOf( s );
    }
420#@Override
    public String toString()
    {
        StringBuilder buf = new StringBuilder();
        if ( majorVersion != null )
        {
            buf.append( majorVersion );
        }
        if ( minorVersion != null )
        {
            buf.append( "." );
            buf.append( minorVersion );
        }
        if ( incrementalVersion != null )
        {
            buf.append( "." );
            buf.append( incrementalVersion );
        }
        if ( buildNumber != null )
        {
            buf.append( "-" );
            buf.append( buildNumber );
        }
        else if ( qualifier != null )
        {
            if ( buf.length() > 0 )
            {
                buf.append( "-" );
            }
            buf.append( qualifier );
        }
        return buf.toString();
    }
421#public OverConstrainedVersionException( String msg,
                                            Artifact artifact )
    {
        super( msg, artifact );
    }
422#public OverConstrainedVersionException( String msg,
                                            Artifact artifact,
                                            List<ArtifactRepository> remoteRepositories )
    {
        super( msg, artifact, remoteRepositories );
    }
423#int getMajorVersion();
424#int getMinorVersion();
425#int getIncrementalVersion();
426#int getBuildNumber();
427#String getQualifier();
428#void parseVersion( String version );
429#private VersionRange( ArtifactVersion recommendedVersion,
                          List<Restriction> restrictions )
    {
        this.recommendedVersion = recommendedVersion;
        this.restrictions = restrictions;
    }
430#public ArtifactVersion getRecommendedVersion()
    {
        return recommendedVersion;
    }
431#public List<Restriction> getRestrictions()
    {
        return restrictions;
    }
432#public VersionRange cloneOf()
    {
        List<Restriction> copiedRestrictions = null;

        if ( restrictions != null )
        {
            copiedRestrictions = new ArrayList<Restriction>();

            if ( !restrictions.isEmpty() )
            {
                copiedRestrictions.addAll( restrictions );
            }
        }

        return new VersionRange( recommendedVersion, copiedRestrictions );
    }
433#/**
     * Create a version range from a string representation
     * <p/>
     * Some spec examples are
     * <ul>
     * <li><code>1.0</code> Version 1.0</li>
     * <li><code>[1.0,2.0)</code> Versions 1.0 (included) to 2.0 (not included)</li>
     * <li><code>[1.0,2.0]</code> Versions 1.0 to 2.0 (both included)</li>
     * <li><code>[1.5,)</code> Versions 1.5 and higher</li>
     * <li><code>(,1.0],[1.2,)</code> Versions up to 1.0 (included) and 1.2 or higher</li>
     * </ul>
     *
     * @param spec string representation of a version or version range
     * @return a new {@link VersionRange} object that represents the spec
     * @throws InvalidVersionSpecificationException
     *
     */
    public static VersionRange createFromVersionSpec( String spec )
        throws InvalidVersionSpecificationException
    {
        if ( spec == null )
        {
            return null;
        }

        List<Restriction> restrictions = new ArrayList<Restriction>();
        String process = spec;
        ArtifactVersion version = null;
        ArtifactVersion upperBound = null;
        ArtifactVersion lowerBound = null;

        while ( process.startsWith( "[" ) || process.startsWith( "(" ) )
        {
            int index1 = process.indexOf( ")" );
            int index2 = process.indexOf( "]" );

            int index = index2;
            if ( index2 < 0 || index1 < index2 )
            {
                if ( index1 >= 0 )
                {
                    index = index1;
                }
            }

            if ( index < 0 )
            {
                throw new InvalidVersionSpecificationException( "Unbounded range: " + spec );
            }

            Restriction restriction = parseRestriction( process.substring( 0, index + 1 ) );
            if ( lowerBound == null )
            {
                lowerBound = restriction.getLowerBound();
            }
            if ( upperBound != null )
            {
                if ( restriction.getLowerBound() == null || restriction.getLowerBound().compareTo( upperBound ) < 0 )
                {
                    throw new InvalidVersionSpecificationException( "Ranges overlap: " + spec );
                }
            }
            restrictions.add( restriction );
            upperBound = restriction.getUpperBound();

            process = process.substring( index + 1 ).trim();

            if ( process.length() > 0 && process.startsWith( "," ) )
            {
                process = process.substring( 1 ).trim();
            }
        }

        if ( process.length() > 0 )
        {
            if ( restrictions.size() > 0 )
            {
                throw new InvalidVersionSpecificationException(
                    "Only fully-qualified sets allowed in multiple set scenario: " + spec );
            }
            else
            {
                version = new DefaultArtifactVersion( process );
                restrictions.add( Restriction.EVERYTHING );
            }
        }

        return new VersionRange( version, restrictions );
    }
434#private static Restriction parseRestriction( String spec )
        throws InvalidVersionSpecificationException
    {
        boolean lowerBoundInclusive = spec.startsWith( "[" );
        boolean upperBoundInclusive = spec.endsWith( "]" );

        String process = spec.substring( 1, spec.length() - 1 ).trim();

        Restriction restriction;

        int index = process.indexOf( "," );

        if ( index < 0 )
        {
            if ( !lowerBoundInclusive || !upperBoundInclusive )
            {
                throw new InvalidVersionSpecificationException( "Single version must be surrounded by []: " + spec );
            }

            ArtifactVersion version = new DefaultArtifactVersion( process );

            restriction = new Restriction( version, lowerBoundInclusive, version, upperBoundInclusive );
        }
        else
        {
            String lowerBound = process.substring( 0, index ).trim();
            String upperBound = process.substring( index + 1 ).trim();
            if ( lowerBound.equals( upperBound ) )
            {
                throw new InvalidVersionSpecificationException( "Range cannot have identical boundaries: " + spec );
            }

            ArtifactVersion lowerVersion = null;
            if ( lowerBound.length() > 0 )
            {
                lowerVersion = new DefaultArtifactVersion( lowerBound );
            }
            ArtifactVersion upperVersion = null;
            if ( upperBound.length() > 0 )
            {
                upperVersion = new DefaultArtifactVersion( upperBound );
            }

            if ( upperVersion != null && lowerVersion != null && upperVersion.compareTo( lowerVersion ) < 0 )
            {
                throw new InvalidVersionSpecificationException( "Range defies version ordering: " + spec );
            }

            restriction = new Restriction( lowerVersion, lowerBoundInclusive, upperVersion, upperBoundInclusive );
        }

        return restriction;
    }
435#public static VersionRange createFromVersion( String version )
    {
        List<Restriction> restrictions = Collections.emptyList();
        return new VersionRange( new DefaultArtifactVersion( version ), restrictions );
    }
436#/**
     * Creates and returns a new <code>VersionRange</code> that is a restriction of this
     * version range and the specified version range.
     * <p>
     * Note: Precedence is given to the recommended version from this version range over the
     * recommended version from the specified version range.
     * </p>
     *
     * @param restriction the <code>VersionRange</code> that will be used to restrict this version
     *                    range.
     * @return the <code>VersionRange</code> that is a restriction of this version range and the
     *         specified version range.
     *         <p>
     *         The restrictions of the returned version range will be an intersection of the restrictions
     *         of this version range and the specified version range if both version ranges have
     *         restrictions. Otherwise, the restrictions on the returned range will be empty.
     *         </p>
     *         <p>
     *         The recommended version of the returned version range will be the recommended version of
     *         this version range, provided that ranges falls within the intersected restrictions. If
     *         the restrictions are empty, this version range's recommended version is used if it is not
     *         <code>null</code>. If it is <code>null</code>, the specified version range's recommended
     *         version is used (provided it is non-<code>null</code>). If no recommended version can be
     *         obtained, the returned version range's recommended version is set to <code>null</code>.
     *         </p>
     * @throws NullPointerException if the specified <code>VersionRange</code> is
     *                              <code>null</code>.
     */
    public VersionRange restrict( VersionRange restriction )
    {
        List<Restriction> r1 = this.restrictions;
        List<Restriction> r2 = restriction.restrictions;
        List<Restriction> restrictions;

        if ( r1.isEmpty() || r2.isEmpty() )
        {
            restrictions = Collections.emptyList();
        }
        else
        {
            restrictions = intersection( r1, r2 );
        }

        ArtifactVersion version = null;
        if ( restrictions.size() > 0 )
        {
            for ( Restriction r : restrictions )
            {
                if ( recommendedVersion != null && r.containsVersion( recommendedVersion ) )
                {
                    // if we find the original, use that
                    version = recommendedVersion;
                    break;
                }
                else if ( version == null && restriction.getRecommendedVersion() != null
                    && r.containsVersion( restriction.getRecommendedVersion() ) )
                {
                    // use this if we can, but prefer the original if possible
                    version = restriction.getRecommendedVersion();
                }
            }
        }
        // Either the original or the specified version ranges have no restrictions
        else if ( recommendedVersion != null )
        {
            // Use the original recommended version since it exists
            version = recommendedVersion;
        }
        else if ( restriction.recommendedVersion != null )
        {
            // Use the recommended version from the specified VersionRange since there is no
            // original recommended version
            version = restriction.recommendedVersion;
        }
/* TODO: should throw this immediately, but need artifact
        else
        {
            throw new OverConstrainedVersionException( "Restricting incompatible version ranges" );
        }
*/

        return new VersionRange( version, restrictions );
    }
437#private List<Restriction> intersection( List<Restriction> r1, List<Restriction> r2 )
    {
        List<Restriction> restrictions = new ArrayList<Restriction>( r1.size() + r2.size() );
        Iterator<Restriction> i1 = r1.iterator();
        Iterator<Restriction> i2 = r2.iterator();
        Restriction res1 = i1.next();
        Restriction res2 = i2.next();

        boolean done = false;
        while ( !done )
        {
            if ( res1.getLowerBound() == null || res2.getUpperBound() == null
                || res1.getLowerBound().compareTo( res2.getUpperBound() ) <= 0 )
            {
                if ( res1.getUpperBound() == null || res2.getLowerBound() == null
                    || res1.getUpperBound().compareTo( res2.getLowerBound() ) >= 0 )
                {
                    ArtifactVersion lower;
                    ArtifactVersion upper;
                    boolean lowerInclusive;
                    boolean upperInclusive;

                    // overlaps
                    if ( res1.getLowerBound() == null )
                    {
                        lower = res2.getLowerBound();
                        lowerInclusive = res2.isLowerBoundInclusive();
                    }
                    else if ( res2.getLowerBound() == null )
                    {
                        lower = res1.getLowerBound();
                        lowerInclusive = res1.isLowerBoundInclusive();
                    }
                    else
                    {
                        int comparison = res1.getLowerBound().compareTo( res2.getLowerBound() );
                        if ( comparison < 0 )
                        {
                            lower = res2.getLowerBound();
                            lowerInclusive = res2.isLowerBoundInclusive();
                        }
                        else if ( comparison == 0 )
                        {
                            lower = res1.getLowerBound();
                            lowerInclusive = res1.isLowerBoundInclusive() && res2.isLowerBoundInclusive();
                        }
                        else
                        {
                            lower = res1.getLowerBound();
                            lowerInclusive = res1.isLowerBoundInclusive();
                        }
                    }

                    if ( res1.getUpperBound() == null )
                    {
                        upper = res2.getUpperBound();
                        upperInclusive = res2.isUpperBoundInclusive();
                    }
                    else if ( res2.getUpperBound() == null )
                    {
                        upper = res1.getUpperBound();
                        upperInclusive = res1.isUpperBoundInclusive();
                    }
                    else
                    {
                        int comparison = res1.getUpperBound().compareTo( res2.getUpperBound() );
                        if ( comparison < 0 )
                        {
                            upper = res1.getUpperBound();
                            upperInclusive = res1.isUpperBoundInclusive();
                        }
                        else if ( comparison == 0 )
                        {
                            upper = res1.getUpperBound();
                            upperInclusive = res1.isUpperBoundInclusive() && res2.isUpperBoundInclusive();
                        }
                        else
                        {
                            upper = res2.getUpperBound();
                            upperInclusive = res2.isUpperBoundInclusive();
                        }
                    }

                    // don't add if they are equal and one is not inclusive
                    if ( lower == null || upper == null || lower.compareTo( upper ) != 0 )
                    {
                        restrictions.add( new Restriction( lower, lowerInclusive, upper, upperInclusive ) );
                    }
                    else if ( lowerInclusive && upperInclusive )
                    {
                        restrictions.add( new Restriction( lower, lowerInclusive, upper, upperInclusive ) );
                    }

                    //noinspection ObjectEquality
                    if ( upper == res2.getUpperBound() )
                    {
                        // advance res2
                        if ( i2.hasNext() )
                        {
                            res2 = i2.next();
                        }
                        else
                        {
                            done = true;
                        }
                    }
                    else
                    {
                        // advance res1
                        if ( i1.hasNext() )
                        {
                            res1 = i1.next();
                        }
                        else
                        {
                            done = true;
                        }
                    }
                }
                else
                {
                    // move on to next in r1
                    if ( i1.hasNext() )
                    {
                        res1 = i1.next();
                    }
                    else
                    {
                        done = true;
                    }
                }
            }
            else
            {
                // move on to next in r2
                if ( i2.hasNext() )
                {
                    res2 = i2.next();
                }
                else
                {
                    done = true;
                }
            }
        }

        return restrictions;
    }
438#public ArtifactVersion getSelectedVersion( Artifact artifact )
        throws OverConstrainedVersionException
    {
        ArtifactVersion version;
        if ( recommendedVersion != null )
        {
            version = recommendedVersion;
        }
        else
        {
            if ( restrictions.size() == 0 )
            {
                throw new OverConstrainedVersionException( "The artifact has no valid ranges", artifact );
            }

            version = null;
        }
        return version;
    }
439#public boolean isSelectedVersionKnown( Artifact artifact )
        throws OverConstrainedVersionException
    {
        boolean value = false;
        if ( recommendedVersion != null )
        {
            value = true;
        }
        else
        {
            if ( restrictions.size() == 0 )
            {
                throw new OverConstrainedVersionException( "The artifact has no valid ranges", artifact );
            }
        }
        return value;
    }
440#public String toString()
    {
        if ( recommendedVersion != null )
        {
            return recommendedVersion.toString();
        }
        else
        {
            StringBuilder buf = new StringBuilder();
            for ( Iterator<Restriction> i = restrictions.iterator(); i.hasNext(); )
            {
                Restriction r = i.next();

                buf.append( r.toString() );

                if ( i.hasNext() )
                {
                    buf.append( ',' );
                }
            }
            return buf.toString();
        }
    }
441#public ArtifactVersion matchVersion( List<ArtifactVersion> versions )
    {
        // TODO: could be more efficient by sorting the list and then moving along the restrictions in order?

        ArtifactVersion matched = null;
        for ( ArtifactVersion version : versions )
        {
            if ( containsVersion( version ) )
            {
                // valid - check if it is greater than the currently matched version
                if ( matched == null || version.compareTo( matched ) > 0 )
                {
                    matched = version;
                }
            }
        }
        return matched;
    }
442#public boolean containsVersion( ArtifactVersion version )
    {
        for ( Restriction restriction : restrictions )
        {
            if ( restriction.containsVersion( version ) )
            {
                return true;
            }
        }
        return false;
    }
443#public boolean hasRestrictions()
    {
        return !restrictions.isEmpty() && recommendedVersion == null;
    }
444#public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( !( obj instanceof VersionRange ) )
        {
            return false;
        }
        VersionRange other = (VersionRange) obj;

        boolean equals =
            recommendedVersion == other.recommendedVersion
                || ( ( recommendedVersion != null ) && recommendedVersion.equals( other.recommendedVersion ) );
        equals &=
            restrictions == other.restrictions
                || ( ( restrictions != null ) && restrictions.equals( other.restrictions ) );
        return equals;
    }
445#public int hashCode()
    {
        int hash = 7;
        hash = 31 * hash + ( recommendedVersion == null ? 0 : recommendedVersion.hashCode() );
        hash = 31 * hash + ( restrictions == null ? 0 : restrictions.hashCode() );
        return hash;
    }
446#/**
     * Return proxy server host name.
     *
     * @return proxy server host name
     */
    public String getHost()
    {
        return host;
    }
447#/**
     * Set proxy host name.
     *
     * @param host proxy server host name
     */
    public void setHost( String host )
    {
        this.host = host;
    }
448#/**
     * Get user's password used to login to proxy server.
     *
     * @return user's password at proxy host
     */
    public String getPassword()
    {
        return password;
    }
449#/**
     * Set the user's password for the proxy server.
     *
     * @param password password to use to login to a proxy server
     */
    public void setPassword( String password )
    {
        this.password = password;
    }
450#/**
     * Get the proxy port.
     *
     * @return proxy server port
     */
    public int getPort()
    {
        return port;
    }
451#/**
     * Set the proxy port.
     *
     * @param port proxy server port
     */
    public void setPort( int port )
    {
        this.port = port;
    }
452#/**
     * Get the proxy username.
     *
     * @return username for the proxy server
     */
    public String getUserName()
    {
        return userName;
    }
453#/**
     * Set the proxy username.
     *
     * @param userName username for the proxy server
     */
    public void setUserName( String userName )
    {
        this.userName = userName;
    }
454#/**
     * Get the type of the proxy server.
     *
     * @return the type of the proxy server
     */
    public String getProtocol()
    {
        return protocol;
    }
455#/**
     * @param type the type of the proxy server like <i>SOCKSv4</i>
     */
    public void setProtocol( String protocol )
    {
        this.protocol = protocol;
    }
456#public String getNonProxyHosts()
    {
        return nonProxyHosts;
    }
457#public void setNonProxyHosts( String nonProxyHosts )
    {
        this.nonProxyHosts = nonProxyHosts;
    }
458#public String getNtlmHost()
    {
        return ntlmHost;
    }
459#public void setNtlmHost( String ntlmHost )
    {
        this.ntlmHost = ntlmHost;
    }
460#public void setNtlmDomain( String ntlmDomain )
    {
        this.ntlmDomain = ntlmDomain;
    }
461#public String getNtlmDomain()
    {
        return ntlmDomain;
    }
462#/** Whether this metadata should be stored alongside the artifact. */
    boolean storedInArtifactVersionDirectory();
463#/** Whether this metadata should be stored alongside the group. */
    boolean storedInGroupDirectory();
464#String getGroupId();
465#String getArtifactId();
466#String getBaseVersion();
467#Object getKey();
468#/**
     * Get the filename of this metadata on the local repository.
     *
     * @param repository the remote repository it came from
     * @return the filename
     */
    String getLocalFilename( ArtifactRepository repository );
469#/**
     * Get the filename of this metadata on the remote repository.
     *
     * @return the filename
     */
    String getRemoteFilename();
470#/**
     * Merge a new metadata set into this piece of metadata.
     *
     * @param metadata the new metadata
     * @todo this should only be needed on the repository metadata
     */
    void merge( ArtifactMetadata metadata );
471#/**
     * Store the metadata in the local repository.
     *
     * @param localRepository  the local repository
     * @param remoteRepository the remote repository it came from
     * @todo this should only be needed on the repository metadata
     */
    void storeInLocalRepository( ArtifactRepository localRepository,
                                 ArtifactRepository remoteRepository )
        throws RepositoryMetadataStoreException;
472#String extendedToString();
473#private ArtifactVersion newArtifactVersion( String version )
    {
        return new DefaultArtifactVersion( version );
    }
474#private void checkVersionParsing( String version, int major, int minor, int incremental, int buildnumber,
                                      String qualifier )
    {
        ArtifactVersion artifactVersion = newArtifactVersion( version );
        String parsed = "'" + version + "' parsed as ('" + artifactVersion.getMajorVersion() + "', '"
            + artifactVersion.getMinorVersion() + "', '" + artifactVersion.getIncrementalVersion() + "', '"
            + artifactVersion.getBuildNumber() + "', '" + artifactVersion.getQualifier() + "'), ";
        assertEquals( parsed + "check major version", major, artifactVersion.getMajorVersion() );
        assertEquals( parsed + "check minor version", minor, artifactVersion.getMinorVersion() );
        assertEquals( parsed + "check incremental version", incremental, artifactVersion.getIncrementalVersion() );
        assertEquals( parsed + "check build number", buildnumber, artifactVersion.getBuildNumber() );
        assertEquals( parsed + "check qualifier", qualifier, artifactVersion.getQualifier() );
        assertEquals( "check " + version + " string value", version, artifactVersion.toString() );
    }
475#public void testVersionParsing()
    {
        checkVersionParsing( "1" , 1, 0, 0, 0, null );
        checkVersionParsing( "1.2" , 1, 2, 0, 0, null );
        checkVersionParsing( "1.2.3" , 1, 2, 3, 0, null );
        checkVersionParsing( "1.2.3-1" , 1, 2, 3, 1, null );
        checkVersionParsing( "1.2.3-alpha-1" , 1, 2, 3, 0, "alpha-1" );
        checkVersionParsing( "1.2-alpha-1" , 1, 2, 0, 0, "alpha-1" );
        checkVersionParsing( "1.2-alpha-1-20050205.060708-1" , 1, 2, 0, 0, "alpha-1-20050205.060708-1" );
        checkVersionParsing( "RELEASE" , 0, 0, 0, 0, "RELEASE" );
        checkVersionParsing( "2.0-1" , 2, 0, 0, 1, null );

        // 0 at the beginning of a number has a special handling
        checkVersionParsing( "02" , 0, 0, 0, 0, "02" );
        checkVersionParsing( "0.09" , 0, 0, 0, 0, "0.09" );
        checkVersionParsing( "0.2.09" , 0, 0, 0, 0, "0.2.09" );
        checkVersionParsing( "2.0-01" , 2, 0, 0, 0, "01" );

        // version schemes not really supported: fully transformed as qualifier
        checkVersionParsing( "1.0.1b" , 0, 0, 0, 0, "1.0.1b" );
        checkVersionParsing( "1.0M2" , 0, 0, 0, 0, "1.0M2" );
        checkVersionParsing( "1.0RC2" , 0, 0, 0, 0, "1.0RC2" );
        checkVersionParsing( "1.7.3.0" , 0, 0, 0, 0, "1.7.3.0" );
        checkVersionParsing( "1.7.3.0-1" , 0, 0, 0, 0, "1.7.3.0-1" );
        checkVersionParsing( "PATCH-1193602" , 0, 0, 0, 0, "PATCH-1193602" );
        checkVersionParsing( "5.0.0alpha-2006020117" , 0, 0, 0, 0, "5.0.0alpha-2006020117" );
        checkVersionParsing( "1.0.0.-SNAPSHOT", 0, 0, 0, 0, "1.0.0.-SNAPSHOT" );
        checkVersionParsing( "1..0-SNAPSHOT", 0, 0, 0, 0, "1..0-SNAPSHOT" );
        checkVersionParsing( "1.0.-SNAPSHOT", 0, 0, 0, 0, "1.0.-SNAPSHOT" );
        checkVersionParsing( ".1.0-SNAPSHOT", 0, 0, 0, 0, ".1.0-SNAPSHOT" );

        checkVersionParsing( "1.2.3.200705301630" , 0, 0, 0, 0, "1.2.3.200705301630" );
        checkVersionParsing( "1.2.3-200705301630" , 1, 2, 3, 0, "200705301630" );
    }
476#public void testVersionComparing()
    {
        assertVersionEqual( "1", "1" );
        assertVersionOlder( "1", "2" );
        assertVersionOlder( "1.5", "2" );
        assertVersionOlder( "1", "2.5" );
        assertVersionEqual( "1", "1.0" );
        assertVersionEqual( "1", "1.0.0" );
        assertVersionOlder( "1.0", "1.1" );
        assertVersionOlder( "1.1", "1.2" );
        assertVersionOlder( "1.0.0", "1.1" );
        assertVersionOlder( "1.1", "1.2.0" );

        assertVersionOlder( "1.0-alpha-1", "1.0" );
        assertVersionOlder( "1.0-alpha-1", "1.0-alpha-2" );
        assertVersionOlder( "1.0-alpha-2", "1.0-alpha-15" );
        assertVersionOlder( "1.0-alpha-1", "1.0-beta-1" );

        assertVersionOlder( "1.0-beta-1", "1.0-SNAPSHOT" );
        assertVersionOlder( "1.0-SNAPSHOT", "1.0" );
        assertVersionOlder( "1.0-alpha-1-SNAPSHOT", "1.0-alpha-1" );

        assertVersionOlder( "1.0", "1.0-1" );
        assertVersionOlder( "1.0-1", "1.0-2" );
        assertVersionEqual( "2.0-0", "2.0" );
        assertVersionOlder( "2.0", "2.0-1" );
        assertVersionOlder( "2.0.0", "2.0-1" );
        assertVersionOlder( "2.0-1", "2.0.1" );

        assertVersionOlder( "2.0.1-klm", "2.0.1-lmn" );
        assertVersionOlder( "2.0.1", "2.0.1-xyz" );
        assertVersionOlder( "2.0.1-xyz-1", "2.0.1-1-xyz" );

        assertVersionOlder( "2.0.1", "2.0.1-123" );
        assertVersionOlder( "2.0.1-xyz", "2.0.1-123" );

        assertVersionOlder( "1.2.3-10000000000", "1.2.3-10000000001" );
        assertVersionOlder( "1.2.3-1", "1.2.3-10000000001" );
        assertVersionOlder( "2.3.0-v200706262000", "2.3.0-v200706262130" ); // org.eclipse:emf:2.3.0-v200706262000
        // org.eclipse.wst.common_core.feature_2.0.0.v200706041905-7C78EK9E_EkMNfNOd2d8qq
        assertVersionOlder( "2.0.0.v200706041905-7C78EK9E_EkMNfNOd2d8qq", "2.0.0.v200706041906-7C78EK9E_EkMNfNOd2d8qq" );
    }
477#public void testVersionSnapshotComparing()
    {
        assertVersionEqual( "1-SNAPSHOT", "1-SNAPSHOT" );
        assertVersionOlder( "1-SNAPSHOT", "2-SNAPSHOT" );
        assertVersionOlder( "1.5-SNAPSHOT", "2-SNAPSHOT" );
        assertVersionOlder( "1-SNAPSHOT", "2.5-SNAPSHOT" );
        assertVersionEqual( "1-SNAPSHOT", "1.0-SNAPSHOT" );
        assertVersionEqual( "1-SNAPSHOT", "1.0.0-SNAPSHOT" );
        assertVersionOlder( "1.0-SNAPSHOT", "1.1-SNAPSHOT" );
        assertVersionOlder( "1.1-SNAPSHOT", "1.2-SNAPSHOT" );
        assertVersionOlder( "1.0.0-SNAPSHOT", "1.1-SNAPSHOT" );
        assertVersionOlder( "1.1-SNAPSHOT", "1.2.0-SNAPSHOT" );

        //assertVersionOlder( "1.0-alpha-1-SNAPSHOT", "1.0-SNAPSHOT" );
        assertVersionOlder( "1.0-alpha-1-SNAPSHOT", "1.0-alpha-2-SNAPSHOT" );
        assertVersionOlder( "1.0-alpha-1-SNAPSHOT", "1.0-beta-1-SNAPSHOT" );

        assertVersionOlder( "1.0-beta-1-SNAPSHOT", "1.0-SNAPSHOT-SNAPSHOT" );
        assertVersionOlder( "1.0-SNAPSHOT-SNAPSHOT", "1.0-SNAPSHOT" );
        assertVersionOlder( "1.0-alpha-1-SNAPSHOT-SNAPSHOT", "1.0-alpha-1-SNAPSHOT" );

        assertVersionOlder( "1.0-SNAPSHOT", "1.0-1-SNAPSHOT" );
        assertVersionOlder( "1.0-1-SNAPSHOT", "1.0-2-SNAPSHOT" );
        //assertVersionEqual( "2.0-0-SNAPSHOT", "2.0-SNAPSHOT" );
        assertVersionOlder( "2.0-SNAPSHOT", "2.0-1-SNAPSHOT" );
        assertVersionOlder( "2.0.0-SNAPSHOT", "2.0-1-SNAPSHOT" );
        assertVersionOlder( "2.0-1-SNAPSHOT", "2.0.1-SNAPSHOT" );

        assertVersionOlder( "2.0.1-klm-SNAPSHOT", "2.0.1-lmn-SNAPSHOT" );
        // assertVersionOlder( "2.0.1-xyz-SNAPSHOT", "2.0.1-SNAPSHOT" );
        assertVersionOlder( "2.0.1-SNAPSHOT", "2.0.1-123-SNAPSHOT" );
        assertVersionOlder( "2.0.1-xyz-SNAPSHOT", "2.0.1-123-SNAPSHOT" );
    }
478#public void testSnapshotVsReleases()
    {
        assertVersionOlder( "1.0-RC1", "1.0-SNAPSHOT" );
        assertVersionOlder( "1.0-rc1", "1.0-SNAPSHOT" );
        assertVersionOlder( "1.0-rc-1", "1.0-SNAPSHOT" );
    }
479#public void testHashCode()
    {
        ArtifactVersion v1 = newArtifactVersion( "1" );
        ArtifactVersion v2 = newArtifactVersion( "1.0" );
        assertEquals( true, v1.equals( v2 ) );
        assertEquals( v1.hashCode(), v2.hashCode() );
    }
480#public void testEqualsNullSafe()
    {
        assertFalse( newArtifactVersion( "1" ).equals( null ) );
    }
481#public void testEqualsTypeSafe()
    {
        assertFalse( newArtifactVersion( "1" ).equals( "non-an-artifact-version-instance" ) );
    }
482#private void assertVersionOlder( String left, String right )
    {
        assertTrue( left + " should be older than " + right,
                    newArtifactVersion( left ).compareTo( newArtifactVersion( right ) ) < 0 );
        assertTrue( right + " should be newer than " + left,
                    newArtifactVersion( right ).compareTo( newArtifactVersion( left ) ) > 0 );
    }
483#private void assertVersionEqual( String left, String right )
    {
        assertTrue( left + " should be equal to " + right,
                    newArtifactVersion( left ).compareTo( newArtifactVersion( right ) ) == 0 );
        assertTrue( right + " should be equal to " + left,
                    newArtifactVersion( right ).compareTo( newArtifactVersion( left ) ) == 0 );
    }
484#public void testRange()
        throws InvalidVersionSpecificationException, OverConstrainedVersionException
    {
        Artifact artifact = null;
        
        VersionRange range = VersionRange.createFromVersionSpec( "(,1.0]" );
        List<Restriction> restrictions = range.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        Restriction restriction = (Restriction) restrictions.get( 0 );
        assertNull( CHECK_LOWER_BOUND, restriction.getLowerBound() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.0", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        assertNull( CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion() );
        assertFalse( CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown( artifact ) );
        assertNull( CHECK_SELECTED_VERSION, range.getSelectedVersion( artifact ) );

        range = VersionRange.createFromVersionSpec( "1.0" );
        assertEquals( CHECK_VERSION_RECOMMENDATION, "1.0", range.getRecommendedVersion().toString() );
        restrictions = range.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertNull( CHECK_LOWER_BOUND, restriction.getLowerBound() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertNull( CHECK_UPPER_BOUND, restriction.getUpperBound() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        assertTrue( CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown( artifact ) );
        assertEquals( CHECK_SELECTED_VERSION, "1.0", range.getSelectedVersion( artifact ).toString() );

        range = VersionRange.createFromVersionSpec( "[1.0]" );
        restrictions = range.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.0", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.0", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        assertNull( CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion() );
        assertFalse( CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown( artifact ) );
        assertNull( CHECK_SELECTED_VERSION, range.getSelectedVersion( artifact ) );

        range = VersionRange.createFromVersionSpec( "[1.2,1.3]" );
        restrictions = range.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        assertNull( CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion() );
        assertFalse( CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown( artifact ) );
        assertNull( CHECK_SELECTED_VERSION, range.getSelectedVersion( artifact ) );

        range = VersionRange.createFromVersionSpec( "[1.0,2.0)" );
        restrictions = range.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.0", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "2.0", restriction.getUpperBound().toString() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        assertNull( CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion() );
        assertFalse( CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown( artifact ) );
        assertNull( CHECK_SELECTED_VERSION, range.getSelectedVersion( artifact ) );

        range = VersionRange.createFromVersionSpec( "[1.5,)" );
        restrictions = range.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.5", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertNull( CHECK_UPPER_BOUND, restriction.getUpperBound() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        assertNull( CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion() );
        assertFalse( CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown( artifact ) );
        assertNull( CHECK_SELECTED_VERSION, range.getSelectedVersion( artifact ) );

        range = VersionRange.createFromVersionSpec( "(,1.0],[1.2,)" );
        restrictions = range.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 2, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertNull( CHECK_LOWER_BOUND, restriction.getLowerBound() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.0", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        assertNull( CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion() );
        restriction = (Restriction) restrictions.get( 1 );
        assertEquals( CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertNull( CHECK_UPPER_BOUND, restriction.getUpperBound() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        assertNull( CHECK_VERSION_RECOMMENDATION, range.getRecommendedVersion() );
        assertFalse( CHECK_SELECTED_VERSION_KNOWN, range.isSelectedVersionKnown( artifact ) );
        assertNull( CHECK_SELECTED_VERSION, range.getSelectedVersion( artifact ) );

        range = VersionRange.createFromVersionSpec( "[1.0,)" );
        assertFalse( range.containsVersion( new DefaultArtifactVersion( "1.0-SNAPSHOT" ) ) );

        range = VersionRange.createFromVersionSpec( "[1.0,1.1-SNAPSHOT]" );
        assertTrue( range.containsVersion( new DefaultArtifactVersion( "1.1-SNAPSHOT" ) ) );

        range = VersionRange.createFromVersionSpec( "[5.0.9.0,5.0.10.0)" );
        assertTrue( range.containsVersion( new DefaultArtifactVersion( "5.0.9.0" ) ) );
    }
485#public void testInvalidRanges()
    {
        checkInvalidRange( "(1.0)" );
        checkInvalidRange( "[1.0)" );
        checkInvalidRange( "(1.0]" );
        checkInvalidRange( "(1.0,1.0]" );
        checkInvalidRange( "[1.0,1.0)" );
        checkInvalidRange( "(1.0,1.0)" );
        checkInvalidRange( "[1.1,1.0]" );
        checkInvalidRange( "[1.0,1.2),1.3" );
        // overlap
        checkInvalidRange( "[1.0,1.2),(1.1,1.3]" );
        // overlap
        checkInvalidRange( "[1.1,1.3),(1.0,1.2]" );
        // ordering
        checkInvalidRange( "(1.1,1.2],[1.0,1.1)" );
    }
486#public void testIntersections()
        throws InvalidVersionSpecificationException
    {
        VersionRange range1 = VersionRange.createFromVersionSpec( "1.0" );
        VersionRange range2 = VersionRange.createFromVersionSpec( "1.1" );
        VersionRange mergedRange = range1.restrict( range2 );
        // TODO: current policy is to retain the original version - is this correct, do we need strategies or is that handled elsewhere?
//        assertEquals( CHECK_VERSION_RECOMMENDATION, "1.1", mergedRange.getRecommendedVersion().toString() );
        assertEquals( CHECK_VERSION_RECOMMENDATION, "1.0", mergedRange.getRecommendedVersion().toString() );
        List<Restriction> restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        Restriction restriction = (Restriction) restrictions.get( 0 );
        assertNull( CHECK_LOWER_BOUND, restriction.getLowerBound() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertNull( CHECK_UPPER_BOUND, restriction.getUpperBound() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        mergedRange = range2.restrict( range1 );
        assertEquals( CHECK_VERSION_RECOMMENDATION, "1.1", mergedRange.getRecommendedVersion().toString() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertNull( CHECK_LOWER_BOUND, restriction.getLowerBound() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertNull( CHECK_UPPER_BOUND, restriction.getUpperBound() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        // TODO: test reversed restrictions on all below
        range1 = VersionRange.createFromVersionSpec( "[1.0,)" );
        range2 = VersionRange.createFromVersionSpec( "1.1" );
        mergedRange = range1.restrict( range2 );
        assertEquals( CHECK_VERSION_RECOMMENDATION, "1.1", mergedRange.getRecommendedVersion().toString() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.0", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertNull( CHECK_UPPER_BOUND, restriction.getUpperBound() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.1,)" );
        range2 = VersionRange.createFromVersionSpec( "1.1" );
        mergedRange = range1.restrict( range2 );
        assertEquals( CHECK_VERSION_RECOMMENDATION, "1.1", mergedRange.getRecommendedVersion().toString() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertNull( CHECK_UPPER_BOUND, restriction.getUpperBound() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.1]" );
        range2 = VersionRange.createFromVersionSpec( "1.1" );
        mergedRange = range1.restrict( range2 );
        assertEquals( CHECK_VERSION_RECOMMENDATION, "1.1", mergedRange.getRecommendedVersion().toString() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "(1.1,)" );
        range2 = VersionRange.createFromVersionSpec( "1.1" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertNull( CHECK_UPPER_BOUND, restriction.getUpperBound() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.2,)" );
        range2 = VersionRange.createFromVersionSpec( "1.1" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertNull( CHECK_UPPER_BOUND, restriction.getUpperBound() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "(,1.2]" );
        range2 = VersionRange.createFromVersionSpec( "1.1" );
        mergedRange = range1.restrict( range2 );
        assertEquals( CHECK_VERSION_RECOMMENDATION, "1.1", mergedRange.getRecommendedVersion().toString() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertNull( CHECK_LOWER_BOUND, restriction.getLowerBound() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "(,1.1]" );
        range2 = VersionRange.createFromVersionSpec( "1.1" );
        mergedRange = range1.restrict( range2 );
        assertEquals( CHECK_VERSION_RECOMMENDATION, "1.1", mergedRange.getRecommendedVersion().toString() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertNull( CHECK_LOWER_BOUND, restriction.getLowerBound() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.1", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "(,1.1)" );
        range2 = VersionRange.createFromVersionSpec( "1.1" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertNull( CHECK_LOWER_BOUND, restriction.getLowerBound() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.1", restriction.getUpperBound().toString() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "(,1.0]" );
        range2 = VersionRange.createFromVersionSpec( "1.1" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertNull( CHECK_LOWER_BOUND, restriction.getLowerBound() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.0", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "(,1.0], [1.1,)" );
        range2 = VersionRange.createFromVersionSpec( "1.2" );
        mergedRange = range1.restrict( range2 );
        assertEquals( CHECK_VERSION_RECOMMENDATION, "1.2", mergedRange.getRecommendedVersion().toString() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 2, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertNull( CHECK_LOWER_BOUND, restriction.getLowerBound() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.0", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        restriction = (Restriction) restrictions.get( 1 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertNull( CHECK_UPPER_BOUND, restriction.getUpperBound() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "(,1.0], [1.1,)" );
        range2 = VersionRange.createFromVersionSpec( "1.0.5" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 2, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertNull( CHECK_LOWER_BOUND, restriction.getLowerBound() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.0", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        restriction = (Restriction) restrictions.get( 1 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertNull( CHECK_UPPER_BOUND, restriction.getUpperBound() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "(,1.1), (1.1,)" );
        range2 = VersionRange.createFromVersionSpec( "1.1" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 2, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertNull( CHECK_LOWER_BOUND, restriction.getLowerBound() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.1", restriction.getUpperBound().toString() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        restriction = (Restriction) restrictions.get( 1 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertNull( CHECK_UPPER_BOUND, restriction.getUpperBound() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.1,1.3]" );
        range2 = VersionRange.createFromVersionSpec( "(1.1,)" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "(,1.3)" );
        range2 = VersionRange.createFromVersionSpec( "[1.2,1.3]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.1,1.3]" );
        range2 = VersionRange.createFromVersionSpec( "[1.2,)" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "(,1.3]" );
        range2 = VersionRange.createFromVersionSpec( "[1.2,1.4]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "(1.2,1.3]" );
        range2 = VersionRange.createFromVersionSpec( "[1.1,1.4]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "(1.2,1.3)" );
        range2 = VersionRange.createFromVersionSpec( "[1.1,1.4]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.2,1.3)" );
        range2 = VersionRange.createFromVersionSpec( "[1.1,1.4]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.2", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.3", restriction.getUpperBound().toString() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.0,1.1]" );
        range2 = VersionRange.createFromVersionSpec( "[1.1,1.4]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.1", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.0,1.1)" );
        range2 = VersionRange.createFromVersionSpec( "[1.1,1.4]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 0, restrictions.size() );

        range1 = VersionRange.createFromVersionSpec( "[1.0,1.2],[1.3,1.5]" );
        range2 = VersionRange.createFromVersionSpec( "[1.1]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.1", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.0,1.2],[1.3,1.5]" );
        range2 = VersionRange.createFromVersionSpec( "[1.4]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 1, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.4", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.0,1.2],[1.3,1.5]" );
        range2 = VersionRange.createFromVersionSpec( "[1.1,1.4]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 2, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        restriction = (Restriction) restrictions.get( 1 );
        assertEquals( CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.0,1.2),(1.3,1.5]" );
        range2 = VersionRange.createFromVersionSpec( "[1.1,1.4]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 2, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        restriction = (Restriction) restrictions.get( 1 );
        assertEquals( CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.0,1.2],[1.3,1.5]" );
        range2 = VersionRange.createFromVersionSpec( "(1.1,1.4)" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 2, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        restriction = (Restriction) restrictions.get( 1 );
        assertEquals( CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.0,1.2),(1.3,1.5]" );
        range2 = VersionRange.createFromVersionSpec( "(1.1,1.4)" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 2, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        restriction = (Restriction) restrictions.get( 1 );
        assertEquals( CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString() );
        assertFalse( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString() );
        assertFalse( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "(,1.1),(1.4,)" );
        range2 = VersionRange.createFromVersionSpec( "[1.1,1.4]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 0, restrictions.size() );

        range1 = VersionRange.createFromVersionSpec( "(,1.1],[1.4,)" );
        range2 = VersionRange.createFromVersionSpec( "(1.1,1.4)" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 0, restrictions.size() );

        range1 = VersionRange.createFromVersionSpec( "[,1.1],[1.4,]" );
        range2 = VersionRange.createFromVersionSpec( "[1.2,1.3]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 0, restrictions.size() );

        range1 = VersionRange.createFromVersionSpec( "[1.0,1.2],[1.3,1.5]" );
        range2 = VersionRange.createFromVersionSpec( "[1.1,1.4],[1.6,]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 2, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        restriction = (Restriction) restrictions.get( 1 );
        assertEquals( CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.0,1.2],[1.3,1.5]" );
        range2 = VersionRange.createFromVersionSpec( "[1.1,1.4],[1.5,]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 3, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        restriction = (Restriction) restrictions.get( 1 );
        assertEquals( CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        restriction = (Restriction) restrictions.get( 2 );
        assertEquals( CHECK_LOWER_BOUND, "1.5", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.5", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        range1 = VersionRange.createFromVersionSpec( "[1.0,1.2],[1.3,1.7]" );
        range2 = VersionRange.createFromVersionSpec( "[1.1,1.4],[1.5,1.6]" );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 3, restrictions.size() );
        restriction = (Restriction) restrictions.get( 0 );
        assertEquals( CHECK_LOWER_BOUND, "1.1", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.2", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        restriction = (Restriction) restrictions.get( 1 );
        assertEquals( CHECK_LOWER_BOUND, "1.3", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.4", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );
        restriction = (Restriction) restrictions.get( 2 );
        assertEquals( CHECK_LOWER_BOUND, "1.5", restriction.getLowerBound().toString() );
        assertTrue( CHECK_LOWER_BOUND_INCLUSIVE, restriction.isLowerBoundInclusive() );
        assertEquals( CHECK_UPPER_BOUND, "1.6", restriction.getUpperBound().toString() );
        assertTrue( CHECK_UPPER_BOUND_INCLUSIVE, restriction.isUpperBoundInclusive() );

        // test restricting empty sets
        range1 = VersionRange.createFromVersionSpec( "[,1.1],[1.4,]" );
        range2 = VersionRange.createFromVersionSpec( "[1.2,1.3]" );
        range1 = range1.restrict( range2 );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 0, restrictions.size() );

        range1 = VersionRange.createFromVersionSpec( "[,1.1],[1.4,]" );
        range2 = VersionRange.createFromVersionSpec( "[1.2,1.3]" );
        range2 = range1.restrict( range2 );
        mergedRange = range1.restrict( range2 );
        assertNull( CHECK_VERSION_RECOMMENDATION, mergedRange.getRecommendedVersion() );
        restrictions = mergedRange.getRestrictions();
        assertEquals( CHECK_NUM_RESTRICTIONS, 0, restrictions.size() );
    }
487#public void testReleaseRangeBoundsContainsSnapshots()
        throws InvalidVersionSpecificationException
    {
        VersionRange range = VersionRange.createFromVersionSpec( "[1.0,1.2]" );

        assertTrue( range.containsVersion( new DefaultArtifactVersion( "1.1-SNAPSHOT" ) ) );
        assertTrue( range.containsVersion( new DefaultArtifactVersion( "1.2-SNAPSHOT" ) ) );
    }
488#public void testSnapshotRangeBoundsCanContainSnapshots()
        throws InvalidVersionSpecificationException
    {
        VersionRange range = VersionRange.createFromVersionSpec( "[1.0,1.2-SNAPSHOT]" );

        assertTrue( range.containsVersion( new DefaultArtifactVersion( "1.1-SNAPSHOT" ) ) );
        assertTrue( range.containsVersion( new DefaultArtifactVersion( "1.2-SNAPSHOT" ) ) );

        range = VersionRange.createFromVersionSpec( "[1.0-SNAPSHOT,1.2]" );

        assertTrue( range.containsVersion( new DefaultArtifactVersion( "1.0-SNAPSHOT" ) ) );
        assertTrue( range.containsVersion( new DefaultArtifactVersion( "1.1-SNAPSHOT" ) ) );
    }
489#public void testSnapshotSoftVersionCanContainSnapshot()
        throws InvalidVersionSpecificationException
    {
        VersionRange range = VersionRange.createFromVersionSpec( "1.0-SNAPSHOT" );

        assertTrue( range.containsVersion( new DefaultArtifactVersion( "1.0-SNAPSHOT" ) ) );
    }
490#private void checkInvalidRange( String version )
    {
        try
        {
            VersionRange.createFromVersionSpec( version );
            fail( "Version " + version + " should have failed to construct" );
        }
        catch ( InvalidVersionSpecificationException expected )
        {
            // expected
        }
    }
491#public void testContains() throws InvalidVersionSpecificationException
    {
        ArtifactVersion actualVersion = new DefaultArtifactVersion( "2.0.5" );
        assertTrue( enforceVersion( "2.0.5", actualVersion ) );
        assertTrue( enforceVersion( "2.0.4", actualVersion ) );
        assertTrue( enforceVersion( "[2.0.5]", actualVersion ) );
        assertFalse( enforceVersion( "[2.0.6,)", actualVersion ) );
        assertFalse( enforceVersion( "[2.0.6]", actualVersion ) );
        assertTrue( enforceVersion( "[2.0,2.1]", actualVersion ) );
        assertFalse( enforceVersion( "[2.0,2.0.3]", actualVersion ) );
        assertTrue( enforceVersion( "[2.0,2.0.5]", actualVersion ) );
        assertFalse( enforceVersion( "[2.0,2.0.5)", actualVersion ) );
    }
492#public boolean enforceVersion( String requiredVersionRange, ArtifactVersion actualVersion )
        throws InvalidVersionSpecificationException
    {
        VersionRange vr = null;

        vr = VersionRange.createFromVersionSpec( requiredVersionRange );

        return vr.containsVersion( actualVersion );
    }
493#public void testOrder0()
    {
        // assertTrue( new DefaultArtifactVersion( "1.0-alpha10" ).compareTo( new DefaultArtifactVersion( "1.0-alpha1" ) ) > 0 );
    }
494#private Comparable newComparable( String version )
    {
        return new ComparableVersion( version );
    }
495#private void checkVersionsOrder( String[] versions )
    {
        Comparable[] c = new Comparable[versions.length];
        for ( int i = 0; i < versions.length; i++ )
        {
            c[i] = newComparable( versions[i] );
        }

        for ( int i = 1; i < versions.length; i++ )
        {
            Comparable low = c[i - 1];
            for ( int j = i; j < versions.length; j++ )
            {
                Comparable high = c[j];
                assertTrue( "expected " + low + " < " + high, low.compareTo( high ) < 0 );
                assertTrue( "expected " + high + " > " + low, high.compareTo( low ) > 0 );
            }
        }
    }
496#private void checkVersionsEqual( String v1, String v2 )
    {
        Comparable c1 = newComparable( v1 );
        Comparable c2 = newComparable( v2 );
        assertTrue( "expected " + v1 + " == " + v2, c1.compareTo( c2 ) == 0 );
        assertTrue( "expected " + v2 + " == " + v1, c2.compareTo( c1 ) == 0 );
        assertTrue( "expected same hashcode for " + v1 + " and " + v2, c1.hashCode() == c2.hashCode() );
        assertTrue( "expected " + v1 + ".equals( " + v2 + " )", c1.equals( c2 ) );
        assertTrue( "expected " + v2 + ".equals( " + v1 + " )", c2.equals( c1 ) );
    }
497#private void checkVersionsOrder( String v1, String v2 )
    {
        Comparable c1 = newComparable( v1 );
        Comparable c2 = newComparable( v2 );
        assertTrue( "expected " + v1 + " < " + v2, c1.compareTo( c2 ) < 0 );
        assertTrue( "expected " + v2 + " > " + v1, c2.compareTo( c1 ) > 0 );
    }
498#public void testVersionsQualifier()
    {
        checkVersionsOrder( VERSIONS_QUALIFIER );
    }
499#public void testVersionsNumber()
    {
        checkVersionsOrder( VERSIONS_NUMBER );
    }
500#public void testVersionsEqual()
    {
        checkVersionsEqual( "1", "1" );
        checkVersionsEqual( "1", "1.0" );
        checkVersionsEqual( "1", "1.0.0" );
        checkVersionsEqual( "1.0", "1.0.0" );
        checkVersionsEqual( "1", "1-0" );
        checkVersionsEqual( "1", "1.0-0" );
        checkVersionsEqual( "1.0", "1.0-0" );
        // no separator between number and character
        checkVersionsEqual( "1a", "1.a" );
        checkVersionsEqual( "1a", "1-a" );
        checkVersionsEqual( "1a", "1.0-a" );
        checkVersionsEqual( "1a", "1.0.0-a" );
        checkVersionsEqual( "1.0a", "1.0.a" );
        checkVersionsEqual( "1.0.0a", "1.0.0.a" );
        checkVersionsEqual( "1x", "1.x" );
        checkVersionsEqual( "1x", "1-x" );
        checkVersionsEqual( "1x", "1.0-x" );
        checkVersionsEqual( "1x", "1.0.0-x" );
        checkVersionsEqual( "1.0x", "1.0.x" );
        checkVersionsEqual( "1.0.0x", "1.0.0.x" );

        // aliases
        checkVersionsEqual( "1ga", "1" );
        checkVersionsEqual( "1final", "1" );
        checkVersionsEqual( "1cr", "1rc" );

        // special "aliases" a, b and m for alpha, beta and milestone
        checkVersionsEqual( "1a1", "1alpha1" );
        checkVersionsEqual( "1b2", "1beta2" );
        checkVersionsEqual( "1m3", "1milestone3" );

        // case insensitive
        checkVersionsEqual( "1X", "1x" );
        checkVersionsEqual( "1A", "1a" );
        checkVersionsEqual( "1B", "1b" );
        checkVersionsEqual( "1M", "1m" );
        checkVersionsEqual( "1Ga", "1" );
        checkVersionsEqual( "1GA", "1" );
        checkVersionsEqual( "1Final", "1" );
        checkVersionsEqual( "1FinaL", "1" );
        checkVersionsEqual( "1FINAL", "1" );
        checkVersionsEqual( "1Cr", "1Rc" );
        checkVersionsEqual( "1cR", "1rC" );
        checkVersionsEqual( "1m3", "1Milestone3" );
        checkVersionsEqual( "1m3", "1MileStone3" );
        checkVersionsEqual( "1m3", "1MILESTONE3" );
    }
501#public void testVersionComparing()
    {
        checkVersionsOrder( "1", "2" );
        checkVersionsOrder( "1.5", "2" );
        checkVersionsOrder( "1", "2.5" );
        checkVersionsOrder( "1.0", "1.1" );
        checkVersionsOrder( "1.1", "1.2" );
        checkVersionsOrder( "1.0.0", "1.1" );
        checkVersionsOrder( "1.0.1", "1.1" );
        checkVersionsOrder( "1.1", "1.2.0" );

        checkVersionsOrder( "1.0-alpha-1", "1.0" );
        checkVersionsOrder( "1.0-alpha-1", "1.0-alpha-2" );
        checkVersionsOrder( "1.0-alpha-1", "1.0-beta-1" );

        checkVersionsOrder( "1.0-beta-1", "1.0-SNAPSHOT" );
        checkVersionsOrder( "1.0-SNAPSHOT", "1.0" );
        checkVersionsOrder( "1.0-alpha-1-SNAPSHOT", "1.0-alpha-1" );

        checkVersionsOrder( "1.0", "1.0-1" );
        checkVersionsOrder( "1.0-1", "1.0-2" );
        checkVersionsOrder( "1.0.0", "1.0-1" );

        checkVersionsOrder( "2.0-1", "2.0.1" );
        checkVersionsOrder( "2.0.1-klm", "2.0.1-lmn" );
        checkVersionsOrder( "2.0.1", "2.0.1-xyz" );

        checkVersionsOrder( "2.0.1", "2.0.1-123" );
        checkVersionsOrder( "2.0.1-xyz", "2.0.1-123" );
    }
502#public void testLocaleIndependent()
    {
        Locale orig = Locale.getDefault();
        Locale[] locales = { Locale.ENGLISH, new Locale( "tr" ), Locale.getDefault() };
        try
        {
            for ( Locale locale : locales )
            {
                Locale.setDefault( locale );
                checkVersionsEqual( "1-abcdefghijklmnopqrstuvwxyz", "1-ABCDEFGHIJKLMNOPQRSTUVWXYZ" );
            }
        }
        finally
        {
            Locale.setDefault( orig );
        }
    }
503#public void testReuse()
    {
        ComparableVersion c1 = new ComparableVersion( "1" );
        c1.parseVersion( "2" );

        Comparable c2 = newComparable( "2" );

        assertEquals( "reused instance should be equivalent to new instance", c1, c2 );
    }
504#public UnknownRepositoryLayoutException( String repositoryId, String layoutId )
    {
        super( "Cannot find ArtifactRepositoryLayout instance for: " + layoutId, repositoryId );
        this.layoutId = layoutId;
    }
505#public UnknownRepositoryLayoutException( String repositoryId, String layoutId, ComponentLookupException e )
    {
        super( "Cannot find ArtifactRepositoryLayout instance for: " + layoutId, repositoryId, e );
        this.layoutId = layoutId;
    }
506#public String getLayoutId()
    {
        return layoutId;
    }
507#// Constructor
    ArtifactScopeEnum( int id )
    {
        this.id = id;
    }
508#int getId()
    {
        return id;
    }
509#/**
     * Helper method to simplify null processing
     *
     * @return
     */
    public static final ArtifactScopeEnum checkScope( ArtifactScopeEnum scope )
    {
        return scope == null ? DEFAULT_SCOPE : scope;
    }
510#/**
     *
     * @return unsafe String representation of this scope.
     */
    public String getScope()
    {
        if ( id == 1 )
        {
            return Artifact.SCOPE_COMPILE;
        }
        else if ( id == 2 )
        {
            return Artifact.SCOPE_TEST;

        }
        else if ( id == 3 )
        {
            return Artifact.SCOPE_RUNTIME;

        }
        else if ( id == 4 )
        {
            return Artifact.SCOPE_PROVIDED;
        }
        else if ( id == 5 )
        {
            return Artifact.SCOPE_SYSTEM;
        }
        else
        {
            return Artifact.SCOPE_RUNTIME_PLUS_SYSTEM;
        }
    }
511#/**
     * scope relationship function. Used by the graph conflict resolution policies
     *
     * @param scope
     * @return true is supplied scope is an inclusive sub-scope of current one.
     */
    public boolean encloses( ArtifactScopeEnum scope )
    {
        final ArtifactScopeEnum s = checkScope( scope );

    	// system scope is historic only - and simple
        if ( id == system.id )
        {
            return scope.id == system.id;
        }

        for ( ArtifactScopeEnum[][] set : _compliancySets )
        {
            if ( id == set[0][0].id )
            {
                for ( ArtifactScopeEnum ase : set[1] )
                {
                    if ( s.id == ase.id )
                    {
                        return true;
                    }
                }
                break;
            }
        }
        return false;
    }
512#private ArtifactStatus( String key, int rank )
    {
        this.rank = rank;
        this.key = key;

        if ( map == null )
        {
            map = new HashMap<String, ArtifactStatus>();
        }
        map.put( key, this );
    }
513#public static ArtifactStatus valueOf( String status )
    {
        ArtifactStatus retVal = null;

        if ( status != null )
        {
            retVal = map.get( status );
        }

        return retVal != null ? retVal : NONE;
    }
514#public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        final ArtifactStatus that = (ArtifactStatus) o;

        return rank == that.rank;

    }
515#public int hashCode()
    {
        return rank;
    }
516#public String toString()
    {
        return key;
    }
517#public int compareTo( ArtifactStatus s )
    {
        return rank - s.rank;
    }
518#/**
     * @deprecated we want to use the artifact method only, and ensure artifact.file is set
     *             correctly.
     */
    @Deprecated
    public void deploy( String basedir, String finalName, Artifact artifact, ArtifactRepository deploymentRepository,
                        ArtifactRepository localRepository )
        throws ArtifactDeploymentException
    {
        String extension = artifact.getArtifactHandler().getExtension();
        File source = new File( basedir, finalName + "." + extension );
        deploy( source, artifact, deploymentRepository, localRepository );
    }
519#public void deploy( File source, Artifact artifact, ArtifactRepository deploymentRepository,
                        ArtifactRepository localRepository )
        throws ArtifactDeploymentException
    {
        RepositorySystemSession session =
            LegacyLocalRepositoryManager.overlay( localRepository, legacySupport.getRepositorySession(), repoSystem );

        DeployRequest request = new DeployRequest();

        request.setTrace( DefaultRequestTrace.newChild( null, legacySupport.getSession().getCurrentProject() ) );

        org.sonatype.aether.artifact.Artifact mainArtifact = RepositoryUtils.toArtifact( artifact );
        mainArtifact = mainArtifact.setFile( source );
        request.addArtifact( mainArtifact );

        String versionKey = artifact.getGroupId() + ':' + artifact.getArtifactId();
        String snapshotKey = null;
        if ( artifact.isSnapshot() )
        {
            snapshotKey = versionKey + ':' + artifact.getBaseVersion();
            request.addMetadata( relatedMetadata.get( snapshotKey ) );
        }
        request.addMetadata( relatedMetadata.get( versionKey ) );

        for ( ArtifactMetadata metadata : artifact.getMetadataList() )
        {
            if ( metadata instanceof ProjectArtifactMetadata )
            {
                org.sonatype.aether.artifact.Artifact pomArtifact = new SubArtifact( mainArtifact, "", "pom" );
                pomArtifact = pomArtifact.setFile( ( (ProjectArtifactMetadata) metadata ).getFile() );
                request.addArtifact( pomArtifact );
            }
            else if ( metadata instanceof SnapshotArtifactRepositoryMetadata
                || metadata instanceof ArtifactRepositoryMetadata )
            {
                // eaten, handled by repo system
            }
            else
            {
                request.addMetadata( new MetadataBridge( metadata ) );
            }
        }

        RemoteRepository remoteRepo = RepositoryUtils.toRepo( deploymentRepository );
        /*
         * NOTE: This provides backward-compat with maven-deploy-plugin:2.4 which bypasses the repository factory when
         * using an alternative deployment location.
         */
        if ( deploymentRepository instanceof DefaultArtifactRepository
            && deploymentRepository.getAuthentication() == null )
        {
            remoteRepo.setAuthentication( session.getAuthenticationSelector().getAuthentication( remoteRepo ) );
            remoteRepo.setProxy( session.getProxySelector().getProxy( remoteRepo ) );
        }
        request.setRepository( remoteRepo );

        DeployResult result;
        try
        {
            result = repoSystem.deploy( session, request );
        }
        catch ( DeploymentException e )
        {
            throw new ArtifactDeploymentException( e.getMessage(), e );
        }

        for ( Object metadata : result.getMetadata() )
        {
            if ( metadata.getClass().getName().endsWith( ".internal.VersionsMetadata" ) )
            {
                relatedMetadata.put( versionKey, (MergeableMetadata) metadata );
            }
            if ( snapshotKey != null && metadata.getClass().getName().endsWith( ".internal.RemoteSnapshotMetadata" ) )
            {
                relatedMetadata.put( snapshotKey, (MergeableMetadata) metadata );
            }
        }

        artifact.setResolvedVersion( result.getArtifacts().iterator().next().getVersion() );
    }
520#/**
     * Deploy an artifact from a particular directory. The artifact handler is used to determine the
     * filename of the source file.
     *
     * @param basedir the directory where the artifact is stored
     * @param finalName the name of the artifact without extension
     * @param artifact the artifact definition
     * @param deploymentRepository the repository to deploy to
     * @param localRepository the local repository to install into
     * @throws ArtifactDeploymentException if an error occurred deploying the artifact
     * @deprecated to be removed before 2.0 after the install/deploy plugins use the alternate
     *             method
     */
    @Deprecated
    void deploy( String basedir, String finalName, Artifact artifact, ArtifactRepository deploymentRepository,
                 ArtifactRepository localRepository )
        throws ArtifactDeploymentException;
521#/**
     * Deploy an artifact from a particular file.
     *
     * @param source the file to deploy
     * @param artifact the artifact definition
     * @param deploymentRepository the repository to deploy to
     * @param localRepository the local repository to install into
     * @throws ArtifactDeploymentException if an error occurred deploying the artifact
     */
    void deploy( File source, Artifact artifact, ArtifactRepository deploymentRepository,
                 ArtifactRepository localRepository )
        throws ArtifactDeploymentException;
522#public ArtifactDeploymentException( String message )
    {
        super( message );
    }
523#public ArtifactDeploymentException( Throwable cause )
    {
        super( cause );
    }
524#public ArtifactDeploymentException( String message,
                                        Throwable cause )
    {
        super( message, cause );
    }
525#public ArtifactInstallationException( String message )
    {
        super( message );
    }
526#public ArtifactInstallationException( Throwable cause )
    {
        super( cause );
    }
527#public ArtifactInstallationException( String message,
                                          Throwable cause )
    {
        super( message, cause );
    }
528#/** @deprecated we want to use the artifact method only, and ensure artifact.file is set correctly. */
    @Deprecated
    public void install( String basedir, String finalName, Artifact artifact, ArtifactRepository localRepository )
        throws ArtifactInstallationException
    {
        String extension = artifact.getArtifactHandler().getExtension();
        File source = new File( basedir, finalName + "." + extension );

        install( source, artifact, localRepository );
    }
529#public void install( File source, Artifact artifact, ArtifactRepository localRepository )
        throws ArtifactInstallationException
    {
        RepositorySystemSession session =
            LegacyLocalRepositoryManager.overlay( localRepository, legacySupport.getRepositorySession(), repoSystem );

        InstallRequest request = new InstallRequest();

        request.setTrace( DefaultRequestTrace.newChild( null, legacySupport.getSession().getCurrentProject() ) );

        org.sonatype.aether.artifact.Artifact mainArtifact = RepositoryUtils.toArtifact( artifact );
        mainArtifact = mainArtifact.setFile( source );
        request.addArtifact( mainArtifact );

        for ( ArtifactMetadata metadata : artifact.getMetadataList() )
        {
            if ( metadata instanceof ProjectArtifactMetadata )
            {
                org.sonatype.aether.artifact.Artifact pomArtifact = new SubArtifact( mainArtifact, "", "pom" );
                pomArtifact = pomArtifact.setFile( ( (ProjectArtifactMetadata) metadata ).getFile() );
                request.addArtifact( pomArtifact );
            }
            else if ( metadata instanceof SnapshotArtifactRepositoryMetadata
                || metadata instanceof ArtifactRepositoryMetadata )
            {
                // eaten, handled by repo system
            }
            else
            {
                request.addMetadata( new MetadataBridge( metadata ) );
            }
        }

        try
        {
            repoSystem.install( session, request );
        }
        catch ( InstallationException e )
        {
            throw new ArtifactInstallationException( e.getMessage(), e );
        }

        /*
         * NOTE: Not used by Maven core, only here to provide backward-compat with plugins like the Install Plugin.
         */

        if ( artifact.isSnapshot() )
        {
            Snapshot snapshot = new Snapshot();
            snapshot.setLocalCopy( true );
            artifact.addMetadata( new SnapshotArtifactRepositoryMetadata( artifact, snapshot ) );
        }

        Versioning versioning = new Versioning();
        versioning.updateTimestamp();
        versioning.addVersion( artifact.getBaseVersion() );
        if ( artifact.isRelease() )
        {
            versioning.setRelease( artifact.getBaseVersion() );
        }
        artifact.addMetadata( new ArtifactRepositoryMetadata( artifact, versioning ) );
    }
530#/**
     * Install an artifact from a particular directory. The artifact handler is used to determine
     * the filename of the source file.
     *
     * @param basedir the directory where the artifact is stored
     * @param finalName the name of the artifact sans extension
     * @param artifact the artifact definition
     * @param localRepository the local repository to install into
     * @throws ArtifactInstallationException if an error occurred installing the artifact
     * @deprecated to be removed before 2.0 after the instlal/deploy plugins use the alternate
     *             method
     */
    @Deprecated
    void install( String basedir, String finalName, Artifact artifact, ArtifactRepository localRepository )
        throws ArtifactInstallationException;
531#/**
     * Install an artifact from a particular file.
     *
     * @param source the file to install
     * @param artifact the artifact definition
     * @param localRepository the local repository to install into
     * @throws ArtifactInstallationException if an error occurred installing the artifact
     */
    void install( File source, Artifact artifact, ArtifactRepository localRepository )
        throws ArtifactInstallationException;
532#public AuthenticationInfo getAuthenticationInfo( String id )
    {
        MavenSession session = legacySupport.getSession();

        if ( session != null && id != null )
        {
            MavenExecutionRequest request = session.getRequest();

            if ( request != null )
            {
                List<Server> servers = request.getServers();

                if ( servers != null )
                {
                    for ( Server server : servers )
                    {
                        if ( id.equalsIgnoreCase( server.getId() ) )
                        {
                            SettingsDecryptionResult result =
                                settingsDecrypter.decrypt( new DefaultSettingsDecryptionRequest( server ) );
                            server = result.getServer();

                            AuthenticationInfo authInfo = new AuthenticationInfo();
                            authInfo.setUserName( server.getUsername() );
                            authInfo.setPassword( server.getPassword() );
                            authInfo.setPrivateKey( server.getPrivateKey() );
                            authInfo.setPassphrase( server.getPassphrase() );

                            return authInfo;
                        }
                    }
                }
            }
        }

        // empty one to prevent NPE
       return new AuthenticationInfo();
    }
533#public ProxyInfo getProxy( String protocol )
    {
        MavenSession session = legacySupport.getSession();

        if ( session != null && protocol != null )
        {
            MavenExecutionRequest request = session.getRequest();

            if ( request != null )
            {
                List<Proxy> proxies = request.getProxies();

                if ( proxies != null )
                {
                    for ( Proxy proxy : proxies )
                    {
                        if ( proxy.isActive() && protocol.equalsIgnoreCase( proxy.getProtocol() ) )
                        {
                            SettingsDecryptionResult result =
                                settingsDecrypter.decrypt( new DefaultSettingsDecryptionRequest( proxy ) );
                            proxy = result.getProxy();

                            ProxyInfo proxyInfo = new ProxyInfo();
                            proxyInfo.setHost( proxy.getHost() );
                            proxyInfo.setType( proxy.getProtocol() );
                            proxyInfo.setPort( proxy.getPort() );
                            proxyInfo.setNonProxyHosts( proxy.getNonProxyHosts() );
                            proxyInfo.setUserName( proxy.getUsername() );
                            proxyInfo.setPassword( proxy.getPassword() );

                            return proxyInfo;
                        }
                    }
                }
            }
        }

        return null;
    }
534#public void getArtifact( Artifact artifact, ArtifactRepository repository )
        throws TransferFailedException, ResourceDoesNotExistException
    {
        getArtifact( artifact, repository, null, false );
    }
535#public void getArtifact( Artifact artifact, List<ArtifactRepository> remoteRepositories )
        throws TransferFailedException, ResourceDoesNotExistException
    {
        getArtifact( artifact, remoteRepositories, null, false );
    }
536#@Deprecated
    public ArtifactRepository getMirrorRepository( ArtifactRepository repository )
    {

        Mirror mirror = mirrorSelector.getMirror( repository, legacySupport.getSession().getSettings().getMirrors() );

        if ( mirror != null )
        {
            String id = mirror.getId();
            if ( id == null )
            {
                // TODO: this should be illegal in settings.xml
                id = repository.getId();
            }

            log.debug( "Using mirror: " + mirror.getUrl() + " (id: " + id + ")" );

            repository = artifactRepositoryFactory.createArtifactRepository( id, mirror.getUrl(),
                                                                     repository.getLayout(), repository.getSnapshots(),
                                                                     repository.getReleases() );
        }
        return repository;
    }
537#public WagonConfigurationException( String repositoryId, String message, Throwable cause )
    {
        super( repositoryId, message, cause );
    }
538#public WagonConfigurationException( String repositoryId, String message )
    {
        super( repositoryId, message );
    }
539#/**
     * this method is only here for backward compat (project-info-reports:dependencies)
     * the default implementation will return an empty AuthenticationInfo
     */
    AuthenticationInfo getAuthenticationInfo( String id );
540#ProxyInfo getProxy( String protocol );
541#void getArtifact( Artifact artifact, ArtifactRepository repository )
        throws TransferFailedException, ResourceDoesNotExistException;
542#void getArtifact( Artifact artifact, List<ArtifactRepository> remoteRepositories )
        throws TransferFailedException, ResourceDoesNotExistException;
543#ArtifactRepository getMirrorRepository( ArtifactRepository repository );
544#/**
     * Create a local repository or a test repository.
     *
     * @param id     the unique identifier of the repository
     * @param url    the URL of the repository
     * @param layout the layout of the repository
     */
    public DefaultArtifactRepository( String id, String url, ArtifactRepositoryLayout layout )
    {
        this( id, url, layout, null, null );
    }
545#/**
     * Create a remote deployment repository.
     *
     * @param id            the unique identifier of the repository
     * @param url           the URL of the repository
     * @param layout        the layout of the repository
     * @param uniqueVersion whether to assign each snapshot a unique version
     */
    public DefaultArtifactRepository( String id, String url, ArtifactRepositoryLayout layout, boolean uniqueVersion )
    {
        super( id, url );
        this.layout = layout;
    }
546#/**
     * Create a remote download repository.
     *
     * @param id        the unique identifier of the repository
     * @param url       the URL of the repository
     * @param layout    the layout of the repository
     * @param snapshots the policies to use for snapshots
     * @param releases  the policies to use for releases
     */
    public DefaultArtifactRepository( String id, String url, ArtifactRepositoryLayout layout,
                                      ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases )
    {
        super( id, url );

        this.layout = layout;

        if ( snapshots == null )
        {
            snapshots = new ArtifactRepositoryPolicy( true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS,
                ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE );
        }

        this.snapshots = snapshots;

        if ( releases == null )
        {
            releases = new ArtifactRepositoryPolicy( true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS,
                ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE );
        }

        this.releases = releases;
    }
547#public String pathOf( Artifact artifact )
    {
        return layout.pathOf( artifact );
    }
548#public String pathOfRemoteRepositoryMetadata( ArtifactMetadata artifactMetadata )
    {
        return layout.pathOfRemoteRepositoryMetadata( artifactMetadata );
    }
549#public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository )
    {
        return layout.pathOfLocalRepositoryMetadata( metadata, repository );
    }
550#public void setLayout( ArtifactRepositoryLayout layout )
    {
        this.layout = layout;
    }
551#public ArtifactRepositoryLayout getLayout()
    {
        return layout;
    }
552#public void setSnapshotUpdatePolicy( ArtifactRepositoryPolicy snapshots )
    {
        this.snapshots = snapshots;
    }
553#public ArtifactRepositoryPolicy getSnapshots()
    {
        return snapshots;
    }
554#public void setReleaseUpdatePolicy( ArtifactRepositoryPolicy releases )
    {
        this.releases = releases;
    }
555#public ArtifactRepositoryPolicy getReleases()
    {
        return releases;
    }
556#public String getKey()
    {
        return getId();
    }
557#public boolean isBlacklisted()
    {
        return blacklisted;
    }
558#public void setBlacklisted( boolean blacklisted )
    {
        this.blacklisted = blacklisted;
    }
559#public String toString()
    {
        StringBuilder sb = new StringBuilder();

        sb.append( "       id: " ).append( getId() ).append( "\n" );
        sb.append( "      url: " ).append( getUrl() ).append( "\n" );
        sb.append( "   layout: " ).append( layout != null ? layout : "none" ).append( "\n" );

        if ( snapshots != null )
        {
            sb.append( "snapshots: [enabled => " ).append( snapshots.isEnabled() );
            sb.append( ", update => " ).append( snapshots.getUpdatePolicy() ).append( "]\n" );
        }

        if ( releases != null )
        {
            sb.append( " releases: [enabled => " ).append( releases.isEnabled() );
            sb.append( ", update => " ).append( releases.getUpdatePolicy() ).append( "]\n" );
        }

        return sb.toString();
    }
560#public Artifact find( Artifact artifact )
    {
        File artifactFile = new File( getBasedir(), pathOf( artifact ) );

        // We need to set the file here or the resolver will fail with an NPE, not fully equipped to deal
        // with multiple local repository implementations yet.
        artifact.setFile( artifactFile );

        if ( artifactFile.exists() )
        {
            artifact.setResolved( true );
        }

        return artifact;
    }
561#public List<String> findVersions( Artifact artifact )
    {
        return Collections.emptyList();
    }
562#public boolean isProjectAware()
    {
        return false;
    }
563#public Authentication getAuthentication()
    {
        return authentication;
    }
564#public void setAuthentication( Authentication authentication )
    {
        this.authentication = authentication;
    }
565#public Proxy getProxy()
    {
        return proxy;
    }
566#public void setProxy( Proxy proxy )
    {
        this.proxy = proxy;
    }
567#public boolean isUniqueVersion()
    {
        return true;
    }
568#public List<ArtifactRepository> getMirroredRepositories()
    {
        return mirroredRepositories;
    }
569#public void setMirroredRepositories( List<ArtifactRepository> mirroredRepositories )
    {
        if ( mirroredRepositories != null )
        {
            this.mirroredRepositories = mirroredRepositories;
        }
        else
        {
            this.mirroredRepositories = Collections.emptyList();
        }
    }
570#@Deprecated
    ArtifactRepositoryLayout getLayout( String layoutId )
        throws UnknownRepositoryLayoutException;
571#@Deprecated
    ArtifactRepository createDeploymentArtifactRepository( String id, String url, String layoutId, boolean uniqueVersion )
        throws UnknownRepositoryLayoutException;
572#ArtifactRepository createDeploymentArtifactRepository( String id, String url, ArtifactRepositoryLayout layout,
                                                           boolean uniqueVersion );
573#ArtifactRepository createArtifactRepository( String id, String url, String layoutId,
                                                 ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases )
        throws UnknownRepositoryLayoutException;
574#ArtifactRepository createArtifactRepository( String id, String url, ArtifactRepositoryLayout repositoryLayout,
                                                 ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases );
575#void setGlobalUpdatePolicy( String snapshotPolicy );
576#void setGlobalChecksumPolicy( String checksumPolicy );
577#public ArtifactRepositoryLayout getLayout( String layoutId )
        throws UnknownRepositoryLayoutException
    {
        return factory.getLayout( layoutId );
    }
578#public ArtifactRepository createDeploymentArtifactRepository( String id, String url, String layoutId,
                                                                  boolean uniqueVersion )
        throws UnknownRepositoryLayoutException
    {
        return injectSession( factory.createDeploymentArtifactRepository( id, url, layoutId, uniqueVersion ), false );
    }
579#public ArtifactRepository createDeploymentArtifactRepository( String id, String url,
                                                                  ArtifactRepositoryLayout repositoryLayout,
                                                                  boolean uniqueVersion )
    {
        return injectSession( factory.createDeploymentArtifactRepository( id, url, repositoryLayout, uniqueVersion ),
                              false );
    }
580#public ArtifactRepository createArtifactRepository( String id, String url, String layoutId,
                                                        ArtifactRepositoryPolicy snapshots,
                                                        ArtifactRepositoryPolicy releases )
        throws UnknownRepositoryLayoutException
    {
        return injectSession( factory.createArtifactRepository( id, url, layoutId, snapshots, releases ), true );
    }
581#public ArtifactRepository createArtifactRepository( String id, String url,
                                                        ArtifactRepositoryLayout repositoryLayout,
                                                        ArtifactRepositoryPolicy snapshots,
                                                        ArtifactRepositoryPolicy releases )
    {
        return injectSession( factory.createArtifactRepository( id, url, repositoryLayout, snapshots, releases ), true );
    }
582#public void setGlobalUpdatePolicy( String updatePolicy )
    {
        factory.setGlobalUpdatePolicy( updatePolicy );
    }
583#public void setGlobalChecksumPolicy( String checksumPolicy )
    {
        factory.setGlobalChecksumPolicy( checksumPolicy );
    }
584#private ArtifactRepository injectSession( ArtifactRepository repository, boolean mirrors )
    {
        RepositorySystemSession session = legacySupport.getRepositorySession();

        if ( session != null && repository != null && !isLocalRepository( repository ) )
        {
            List<ArtifactRepository> repositories = Arrays.asList( repository );

            if ( mirrors )
            {
                repositorySystem.injectMirror( session, repositories );
            }

            repositorySystem.injectProxy( session, repositories );

            repositorySystem.injectAuthentication( session, repositories );
        }

        return repository;
    }
585#private boolean isLocalRepository( ArtifactRepository repository )
    {
        // unfortunately, the API doesn't allow to tell a remote repo and the local repo apart...
        return "local".equals( repository.getId() );
    }
586#public String getId()
    {
        return "flat";
    }
587#public String pathOf( Artifact artifact )
    {
        ArtifactHandler artifactHandler = artifact.getArtifactHandler();

        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getArtifactId() ).append( ARTIFACT_SEPARATOR ).append( artifact.getVersion() );

        if ( artifact.hasClassifier() )
        {
            path.append( ARTIFACT_SEPARATOR ).append( artifact.getClassifier() );
        }

        if ( artifactHandler.getExtension() != null && artifactHandler.getExtension().length() > 0 )
        {
            path.append( GROUP_SEPARATOR ).append( artifactHandler.getExtension() );
        }

        return path.toString();
    }
588#public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository )
    {
        return pathOfRepositoryMetadata( metadata.getLocalFilename( repository ) );
    }
589#private String pathOfRepositoryMetadata( String filename )
    {
        StringBuilder path = new StringBuilder( 128 );

        path.append( filename );

        return path.toString();
    }
590#public String pathOfRemoteRepositoryMetadata( ArtifactMetadata metadata )
    {
        return pathOfRepositoryMetadata( metadata.getRemoteFilename() );
    }
591#@Override
    public String toString()
    {
        return getId();
    }
592#public MetadataBridge( ArtifactMetadata metadata )
    {
        this.metadata = metadata;
    }
593#public void merge( File current, File result )
        throws RepositoryException
    {
        try
        {
            if ( current.exists() )
            {
                FileUtils.copyFile( current, result );
            }
            ArtifactRepository localRepo = new MetadataRepository( result );
            metadata.storeInLocalRepository( localRepo, localRepo );
            merged = true;
        }
        catch ( Exception e )
        {
            throw new RepositoryException( e.getMessage(), e );
        }
    }
594#public boolean isMerged()
    {
        return merged;
    }
595#public String getGroupId()
    {
        return emptify( metadata.getGroupId() );
    }
596#public String getArtifactId()
    {
        return metadata.storedInGroupDirectory() ? "" : emptify( metadata.getArtifactId() );
    }
597#public String getVersion()
    {
        return metadata.storedInArtifactVersionDirectory() ? emptify( metadata.getBaseVersion() ) : "";
    }
598#public String getType()
    {
        return metadata.getRemoteFilename();
    }
599#private String emptify( String string )
    {
        return ( string != null ) ? string : "";
    }
600#public File getFile()
    {
        return null;
    }
601#public MetadataBridge setFile( File file )
    {
        return this;
    }
602#public Nature getNature()
    {
        if ( metadata instanceof RepositoryMetadata )
        {
            switch ( ( (RepositoryMetadata) metadata ).getNature() )
            {
                case RepositoryMetadata.RELEASE_OR_SNAPSHOT:
                    return Nature.RELEASE_OR_SNAPSHOT;
                case RepositoryMetadata.SNAPSHOT:
                    return Nature.SNAPSHOT;
                default:
                    return Nature.RELEASE;
            }
        }
        else
        {
            return Nature.RELEASE;
        }
    }
603#public MetadataRepository( File metadataFile )
        {
            super( "local", "", null );
            this.metadataFile = metadataFile;
        }
604#@Override
        public String getBasedir()
        {
            return metadataFile.getParent();
        }
605#@Override
        public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository )
        {
            return metadataFile.getName();
        }
606#public void resolve( RepositoryMetadata metadata, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository )
        throws RepositoryMetadataResolutionException
    {
        RepositoryRequest request = new DefaultRepositoryRequest();
        request.setLocalRepository( localRepository );
        request.setRemoteRepositories( remoteRepositories );
        resolve( metadata, request );
    }
607#public void resolve( RepositoryMetadata metadata, RepositoryRequest request )
        throws RepositoryMetadataResolutionException
    {
        ArtifactRepository localRepository = request.getLocalRepository();
        List<ArtifactRepository> remoteRepositories = request.getRemoteRepositories();

        if ( !request.isOffline() )
        {
            Date localCopyLastModified = null;
            if ( metadata.getBaseVersion() != null )
            {
                localCopyLastModified = getLocalCopyLastModified( localRepository, metadata );
            }

            for ( ArtifactRepository repository : remoteRepositories )
            {
                ArtifactRepositoryPolicy policy = metadata.getPolicy( repository );

                File file =
                    new File( localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata( metadata,
                                                                                                           repository ) );
                boolean update;

                if ( !policy.isEnabled() )
                {
                    update = false;

                    if ( getLogger().isDebugEnabled() )
                    {
                        getLogger().debug(
                                           "Skipping update check for " + metadata.getKey() + " (" + file
                                               + ") from disabled repository " + repository.getId() + " ("
                                               + repository.getUrl() + ")" );
                    }
                }
                else if ( request.isForceUpdate() )
                {
                    update = true;
                }
                else if ( localCopyLastModified != null && !policy.checkOutOfDate( localCopyLastModified ) )
                {
                    update = false;

                    if ( getLogger().isDebugEnabled() )
                    {
                        getLogger().debug(
                                           "Skipping update check for " + metadata.getKey() + " (" + file
                                               + ") from repository " + repository.getId() + " (" + repository.getUrl()
                                               + ") in favor of local copy" );
                    }
                }
                else if ( updateCheckManager.isUpdateRequired( metadata, repository, file ) )
                {
                    update = true;
                }
                else
                {
                    update = false;
                }

                if ( update )
                {
                    getLogger().info( metadata.getKey() + ": checking for updates from " + repository.getId() );
                    try
                    {
                        wagonManager.getArtifactMetadata( metadata, repository, file, policy.getChecksumPolicy() );
                    }
                    catch ( ResourceDoesNotExistException e )
                    {
                        getLogger().debug( metadata + " could not be found on repository: " + repository.getId() );

                        // delete the local copy so the old details aren't used.
                        if ( file.exists() )
                        {
                            file.delete();
                        }
                    }
                    catch ( TransferFailedException e )
                    {
                        getLogger().warn( metadata + " could not be retrieved from repository: " + repository.getId()
                                              + " due to an error: " + e.getMessage() );
                        getLogger().debug( "Exception", e );
                    }
                    finally
                    {
                        updateCheckManager.touch( metadata, repository, file );
                    }
                }

                // TODO: should this be inside the above check?
                // touch file so that this is not checked again until interval has passed
                if ( file.exists() )
                {
                    file.setLastModified( System.currentTimeMillis() );
                }
            }
        }

        try
        {
            mergeMetadata( metadata, remoteRepositories, localRepository );
        }
        catch ( RepositoryMetadataStoreException e )
        {
            throw new RepositoryMetadataResolutionException( "Unable to store local copy of metadata: " + e.getMessage(), e );
        }
    }
608#private Date getLocalCopyLastModified( ArtifactRepository localRepository, RepositoryMetadata metadata )
    {
        String metadataPath = localRepository.pathOfLocalRepositoryMetadata( metadata, localRepository );
        File metadataFile = new File( localRepository.getBasedir(), metadataPath );
        return metadataFile.isFile() ? new Date( metadataFile.lastModified() ) : null;
    }
609#private void mergeMetadata( RepositoryMetadata metadata, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository )
        throws RepositoryMetadataStoreException
    {
        // TODO: currently this is first wins, but really we should take the latest by comparing either the
        // snapshot timestamp, or some other timestamp later encoded into the metadata.
        // TODO: this needs to be repeated here so the merging doesn't interfere with the written metadata
        //  - we'd be much better having a pristine input, and an ongoing metadata for merging instead

        Map<ArtifactRepository, Metadata> previousMetadata = new HashMap<ArtifactRepository, Metadata>();
        ArtifactRepository selected = null;
        for ( ArtifactRepository repository : remoteRepositories )
        {
            ArtifactRepositoryPolicy policy = metadata.getPolicy( repository );

            if ( policy.isEnabled() && loadMetadata( metadata, repository, localRepository, previousMetadata ) )
            {
                metadata.setRepository( repository );
                selected = repository;
            }
        }
        if ( loadMetadata( metadata, localRepository, localRepository, previousMetadata ) )
        {
            metadata.setRepository( null );
            selected = localRepository;
        }

        updateSnapshotMetadata( metadata, previousMetadata, selected, localRepository );
    }
610#private void updateSnapshotMetadata( RepositoryMetadata metadata, Map<ArtifactRepository, Metadata> previousMetadata, ArtifactRepository selected, ArtifactRepository localRepository )
        throws RepositoryMetadataStoreException
    {
        // TODO: this could be a lot nicer... should really be in the snapshot transformation?
        if ( metadata.isSnapshot() )
        {
            Metadata prevMetadata = metadata.getMetadata();

            for ( ArtifactRepository repository : previousMetadata.keySet() )
            {
                Metadata m = previousMetadata.get( repository );
                if ( repository.equals( selected ) )
                {
                    if ( m.getVersioning() == null )
                    {
                        m.setVersioning( new Versioning() );
                    }

                    if ( m.getVersioning().getSnapshot() == null )
                    {
                        m.getVersioning().setSnapshot( new Snapshot() );
                    }
                }
                else
                {
                    if ( ( m.getVersioning() != null ) && ( m.getVersioning().getSnapshot() != null ) && m.getVersioning().getSnapshot().isLocalCopy() )
                    {
                        m.getVersioning().getSnapshot().setLocalCopy( false );
                        metadata.setMetadata( m );
                        metadata.storeInLocalRepository( localRepository, repository );
                    }
                }
            }

            metadata.setMetadata( prevMetadata );
        }
    }
611#private boolean loadMetadata( RepositoryMetadata repoMetadata, ArtifactRepository remoteRepository, ArtifactRepository localRepository, Map<ArtifactRepository, Metadata> previousMetadata )
    {
        boolean setRepository = false;

        File metadataFile = new File( localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata( repoMetadata, remoteRepository ) );

        if ( metadataFile.exists() )
        {
            Metadata metadata;

            try
            {
                metadata = readMetadata( metadataFile );
            }
            catch ( RepositoryMetadataReadException e )
            {
                if ( getLogger().isDebugEnabled() )
                {
                    getLogger().warn( e.getMessage(), e );
                }
                else
                {
                    getLogger().warn( e.getMessage() );
                }
                return setRepository;
            }

            if ( repoMetadata.isSnapshot() && ( previousMetadata != null ) )
            {
                previousMetadata.put( remoteRepository, metadata );
            }

            if ( repoMetadata.getMetadata() != null )
            {
                setRepository = repoMetadata.getMetadata().merge( metadata );
            }
            else
            {
                repoMetadata.setMetadata( metadata );
                setRepository = true;
            }
        }
        return setRepository;
    }
612#/** @todo share with DefaultPluginMappingManager. */
    protected Metadata readMetadata( File mappingFile )
        throws RepositoryMetadataReadException
    {
        Metadata result;

        Reader reader = null;
        try
        {
            reader = ReaderFactory.newXmlReader( mappingFile );

            MetadataXpp3Reader mappingReader = new MetadataXpp3Reader();

            result = mappingReader.read( reader, false );
        }
        catch ( FileNotFoundException e )
        {
            throw new RepositoryMetadataReadException( "Cannot read metadata from '" + mappingFile + "'", e );
        }
        catch ( IOException e )
        {
            throw new RepositoryMetadataReadException( "Cannot read metadata from '" + mappingFile + "': " + e.getMessage(), e );
        }
        catch ( XmlPullParserException e )
        {
            throw new RepositoryMetadataReadException( "Cannot read metadata from '" + mappingFile + "': " + e.getMessage(), e );
        }
        finally
        {
            IOUtil.close( reader );
        }

        return result;
    }
613#/**
     * Ensures the last updated timestamp of the specified metadata does not refer to the future and fixes the local metadata if necessary to allow
     * proper merging/updating of metadata during deployment.
     */
    private void fixTimestamp( File metadataFile, Metadata metadata, Metadata reference )
    {
        boolean changed = false;

        if ( metadata != null && reference != null )
        {
            Versioning versioning = metadata.getVersioning();
            Versioning versioningRef = reference.getVersioning();
            if ( versioning != null && versioningRef != null )
            {
                String lastUpdated = versioning.getLastUpdated();
                String now = versioningRef.getLastUpdated();
                if ( lastUpdated != null && now != null && now.compareTo( lastUpdated ) < 0 )
                {
                    getLogger().warn(
                                      "The last updated timestamp in " + metadataFile + " refers to the future (now = "
                                          + now + ", lastUpdated = " + lastUpdated
                                          + "). Please verify that the clocks of all"
                                          + " deploying machines are reasonably synchronized." );
                    versioning.setLastUpdated( now );
                    changed = true;
                }
            }
        }

        if ( changed )
        {
            getLogger().debug( "Repairing metadata in " + metadataFile );

            Writer writer = null;
            try
            {
                writer = WriterFactory.newXmlWriter( metadataFile );
                new MetadataXpp3Writer().write( writer, metadata );
            }
            catch ( IOException e )
            {
                String msg = "Could not write fixed metadata to " + metadataFile + ": " + e.getMessage();
                if ( getLogger().isDebugEnabled() )
                {
                    getLogger().warn( msg, e );
                }
                else
                {
                    getLogger().warn( msg );
                }
            }
            finally
            {
                IOUtil.close( writer );
            }
        }
    }
614#public void resolveAlways( RepositoryMetadata metadata, ArtifactRepository localRepository, ArtifactRepository remoteRepository )
        throws RepositoryMetadataResolutionException
    {
        File file;
        try
        {
            file = getArtifactMetadataFromDeploymentRepository( metadata, localRepository, remoteRepository );
        }
        catch ( TransferFailedException e )
        {
            throw new RepositoryMetadataResolutionException( metadata + " could not be retrieved from repository: " + remoteRepository.getId() + " due to an error: " + e.getMessage(), e );
        }

        try
        {
            if ( file.exists() )
            {
                Metadata prevMetadata = readMetadata( file );
                metadata.setMetadata( prevMetadata );
            }
        }
        catch ( RepositoryMetadataReadException e )
        {
            throw new RepositoryMetadataResolutionException( e.getMessage(), e );
        }
    }
615#private File getArtifactMetadataFromDeploymentRepository( ArtifactMetadata metadata, ArtifactRepository localRepository, ArtifactRepository remoteRepository )
        throws TransferFailedException
    {
        File file = new File( localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata( metadata, remoteRepository ) );

        try
        {
            wagonManager.getArtifactMetadataFromDeploymentRepository( metadata, remoteRepository, file, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN );
        }
        catch ( ResourceDoesNotExistException e )
        {
            getLogger().info( metadata + " could not be found on repository: " + remoteRepository.getId() + ", so will be created" );

            // delete the local copy so the old details aren't used.
            if ( file.exists() )
            {
                file.delete();
            }
        }
        finally
        {
            if ( metadata instanceof RepositoryMetadata )
            {
                updateCheckManager.touch( (RepositoryMetadata) metadata, remoteRepository, file );
            }
        }
        return file;
    }
616#public void deploy( ArtifactMetadata metadata, ArtifactRepository localRepository, ArtifactRepository deploymentRepository )
        throws RepositoryMetadataDeploymentException
    {
        File file;
        if ( metadata instanceof RepositoryMetadata )
        {
            getLogger().info( "Retrieving previous metadata from " + deploymentRepository.getId() );
            try
            {
                file = getArtifactMetadataFromDeploymentRepository( metadata, localRepository, deploymentRepository );
            }
            catch ( TransferFailedException e )
            {
                throw new RepositoryMetadataDeploymentException( metadata + " could not be retrieved from repository: " + deploymentRepository.getId() + " due to an error: " + e.getMessage(), e );
            }

            if ( file.isFile() )
            {
                try
                {
                    fixTimestamp( file, readMetadata( file ), ( (RepositoryMetadata) metadata ).getMetadata() );
                }
                catch ( RepositoryMetadataReadException e )
                {
                    // will be reported via storeInlocalRepository
                }
            }
        }
        else
        {
            // It's a POM - we don't need to retrieve it first
            file = new File( localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata( metadata, deploymentRepository ) );
        }

        try
        {
            metadata.storeInLocalRepository( localRepository, deploymentRepository );
        }
        catch ( RepositoryMetadataStoreException e )
        {
            throw new RepositoryMetadataDeploymentException( "Error installing metadata: " + e.getMessage(), e );
        }

        try
        {
            wagonManager.putArtifactMetadata( file, metadata, deploymentRepository );
        }
        catch ( TransferFailedException e )
        {
            throw new RepositoryMetadataDeploymentException( "Error while deploying metadata: " + e.getMessage(), e );
        }
    }
617#public void install( ArtifactMetadata metadata, ArtifactRepository localRepository )
        throws RepositoryMetadataInstallationException
    {
        try
        {
            metadata.storeInLocalRepository( localRepository, localRepository );
        }
        catch ( RepositoryMetadataStoreException e )
        {
            throw new RepositoryMetadataInstallationException( "Error installing metadata: " + e.getMessage(), e );
        }
    }
618#public RepositoryMetadataReadException( String message )
    {
        super( message );
    }
619#public RepositoryMetadataReadException( String message,
                                            Exception e )
    {
        super( message, e );
    }
620#public GroupRepositoryMetadata( String groupId )
    {
        super( new Metadata() );
        this.groupId = groupId;
    }
621#public boolean storedInGroupDirectory()
    {
        return true;
    }
622#public boolean storedInArtifactVersionDirectory()
    {
        return false;
    }
623#public String getGroupId()
    {
        return groupId;
    }
624#public String getArtifactId()
    {
        return null;
    }
625#public String getBaseVersion()
    {
        return null;
    }
626#public void addPluginMapping( String goalPrefix,
                                  String artifactId )
    {
        addPluginMapping( goalPrefix, artifactId, artifactId );
    }
627#public void addPluginMapping( String goalPrefix,
                                  String artifactId,
                                  String name )
    {
        List plugins = getMetadata().getPlugins();
        boolean found = false;
        for ( Iterator i = plugins.iterator(); i.hasNext() && !found; )
        {
            Plugin plugin = (Plugin) i.next();
            if ( plugin.getPrefix().equals( goalPrefix ) )
            {
                found = true;
            }
        }
        if ( !found )
        {
            Plugin plugin = new Plugin();
            plugin.setPrefix( goalPrefix );
            plugin.setArtifactId( artifactId );
            plugin.setName( name );


            getMetadata().addPlugin( plugin );
        }
    }
628#public Object getKey()
    {
        return groupId;
    }
629#public boolean isSnapshot()
    {
        return false;
    }
630#public ArtifactRepository getRepository()
    {
        return null;
    }
631#public void setRepository( ArtifactRepository remoteRepository )
    {
        // intentionally blank
    }
632#public SnapshotArtifactRepositoryMetadata( Artifact artifact )
    {
        super( createMetadata( artifact, null ) );
        this.artifact = artifact;
    }
633#public SnapshotArtifactRepositoryMetadata( Artifact artifact,
                                               Snapshot snapshot )
    {
        super( createMetadata( artifact, createVersioning( snapshot ) ) );
        this.artifact = artifact;
    }
634#public boolean storedInGroupDirectory()
    {
        return false;
    }
635#public boolean storedInArtifactVersionDirectory()
    {
        return true;
    }
636#public String getGroupId()
    {
        return artifact.getGroupId();
    }
637#public String getArtifactId()
    {
        return artifact.getArtifactId();
    }
638#public String getBaseVersion()
    {
        return artifact.getBaseVersion();
    }
639#public Object getKey()
    {
        return "snapshot " + artifact.getGroupId() + ":" + artifact.getArtifactId() + ":" + artifact.getBaseVersion();
    }
640#public boolean isSnapshot()
    {
        return artifact.isSnapshot();
    }
641#public int getNature()
    {
        return isSnapshot() ? SNAPSHOT : RELEASE;
    }
642#public ArtifactRepository getRepository()
    {
        return artifact.getRepository();
    }
643#public void setRepository( ArtifactRepository remoteRepository )
    {
        artifact.setRepository( remoteRepository );
    }
644#public static Metadata cloneMetadata( Metadata src )
    {
        if ( src == null )
        {
            return null;
        }
        return src.clone();
    }
645#void manageArtifactVersion( Artifact artifact,
                                Artifact replacement );
646#void manageArtifactScope( Artifact artifact,
                              Artifact replacement );
647#void manageArtifactSystemPath( Artifact artifact,
                                   Artifact replacement );
648#public DefaultArtifactResolver()
    {
        int threads = Integer.getInteger( "maven.artifact.threads", 5 ).intValue();
        if ( threads <= 1 )
        {
            executor = new Executor()
            {
                public void execute( Runnable command )
                {
                    command.run();
                }
            };
        }
        else
        {
            executor =
                new ThreadPoolExecutor( threads, threads, 3, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new DaemonThreadCreator());
        }
    }
649#@Override
    protected void finalize()
        throws Throwable
    {
        if ( executor instanceof ExecutorService )
        {
            ( (ExecutorService) executor ).shutdown();
        }
    }
650#private RepositorySystemSession getSession( ArtifactRepository localRepository )
    {
        return LegacyLocalRepositoryManager.overlay( localRepository, legacySupport.getRepositorySession(), repoSystem );
    }
651#private void injectSession1( RepositoryRequest request, MavenSession session )
    {
        if ( session != null )
        {
            request.setOffline( session.isOffline() );
            request.setForceUpdate( session.getRequest().isUpdateSnapshots() );
        }
    }
652#private void injectSession2( ArtifactResolutionRequest request, MavenSession session )
    {
        injectSession1( request, session );

        if ( session != null )
        {
            request.setServers( session.getRequest().getServers() );
            request.setMirrors( session.getRequest().getMirrors() );
            request.setProxies( session.getRequest().getProxies() );
        }
    }
653#public void resolve( Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository, TransferListener resolutionListener )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        resolve( artifact, remoteRepositories, getSession( localRepository ) );
    }
654#public void resolveAlways( Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        resolve( artifact, remoteRepositories, getSession( localRepository ) );
    }
655#private void resolve( Artifact artifact, List<ArtifactRepository> remoteRepositories, RepositorySystemSession session )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        if ( artifact == null )
        {
            return;
        }
        
        if ( Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )
        {
            File systemFile = artifact.getFile();

            if ( systemFile == null )
            {
                throw new ArtifactNotFoundException( "System artifact: " + artifact + " has no file attached", artifact );
            }

            if ( !systemFile.exists() )
            {
                throw new ArtifactNotFoundException( "System artifact: " + artifact + " not found in path: " + systemFile, artifact );
            }

            if ( !systemFile.isFile() )
            {
                throw new ArtifactNotFoundException( "System artifact: " + artifact + " is not a file: " + systemFile, artifact );
            }

            artifact.setResolved( true );
            
            return;
        }

        if ( !artifact.isResolved() )
        {
            ArtifactResult result;

            try
            {
                ArtifactRequest artifactRequest = new ArtifactRequest();
                artifactRequest.setArtifact( RepositoryUtils.toArtifact( artifact ) );
                artifactRequest.setRepositories( RepositoryUtils.toRepos( remoteRepositories ) );

                // Maven 2.x quirk: an artifact always points at the local repo, regardless whether resolved or not
                LocalRepositoryManager lrm = session.getLocalRepositoryManager();
                String path = lrm.getPathForLocalArtifact( artifactRequest.getArtifact() );
                artifact.setFile( new File( lrm.getRepository().getBasedir(), path ) );

                result = repoSystem.resolveArtifact( session, artifactRequest );
            }
            catch ( org.sonatype.aether.resolution.ArtifactResolutionException e )
            {
                if ( e.getCause() instanceof org.sonatype.aether.transfer.ArtifactNotFoundException )
                {
                    throw new ArtifactNotFoundException( e.getMessage(), artifact, remoteRepositories, e );
                }
                else
                {
                    throw new ArtifactResolutionException( e.getMessage(), artifact, remoteRepositories, e );
                }
            }

            artifact.selectVersion( result.getArtifact().getVersion() );
            artifact.setFile( result.getArtifact().getFile() );
            artifact.setResolved( true );

            if ( artifact.isSnapshot() )
            {
                Matcher matcher = Artifact.VERSION_FILE_PATTERN.matcher( artifact.getVersion() );
                if ( matcher.matches() )
                {
                    Snapshot snapshot = new Snapshot();
                    snapshot.setTimestamp( matcher.group( 2 ) );
                    try
                    {
                        snapshot.setBuildNumber( Integer.parseInt( matcher.group( 3 ) ) );
                        artifact.addMetadata( new SnapshotArtifactRepositoryMetadata( artifact, snapshot ) );
                    }
                    catch ( NumberFormatException e )
                    {
                        logger.warn( "Invalid artifact version " + artifact.getVersion() + ": " + e.getMessage() );
                    }
                }
            }
        }
    }
656#public ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories,
                                                         ArtifactMetadataSource source, ArtifactFilter filter )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        return resolveTransitively( artifacts, originatingArtifact, Collections.EMPTY_MAP, localRepository, remoteRepositories, source, filter );

    }
657#public ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository,
                                                         List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        return resolveTransitively( artifacts, originatingArtifact, managedVersions, localRepository, remoteRepositories, source, null );
    }
658#public ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository,
                                                         List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        return resolveTransitively( artifacts, originatingArtifact, managedVersions, localRepository, remoteRepositories, source, filter, null );
    }
659#public ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository,
                                                         ArtifactMetadataSource source )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        return resolveTransitively( artifacts, originatingArtifact, localRepository, remoteRepositories, source, null );
    }
660#public ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository,
                                                         ArtifactMetadataSource source, List<ResolutionListener> listeners )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        return resolveTransitively( artifacts, originatingArtifact, Collections.EMPTY_MAP, localRepository,
                                    remoteRepositories, source, null, listeners );
    }
661#public ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository,
                                                         List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List<ResolutionListener> listeners )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        return resolveTransitively( artifacts, originatingArtifact, managedVersions, localRepository, remoteRepositories, source, filter, listeners, null );
    }
662#public ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository,
                                                         List<ArtifactRepository> remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List<ResolutionListener> listeners,
                                                         List<ConflictResolver> conflictResolvers )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        ArtifactResolutionRequest request = new ArtifactResolutionRequest()
            .setArtifact( originatingArtifact )
            .setResolveRoot( false )
            // This is required by the surefire plugin
            .setArtifactDependencies( artifacts )            
            .setManagedVersionMap( managedVersions )
            .setLocalRepository( localRepository )
            .setRemoteRepositories( remoteRepositories )
            .setCollectionFilter( filter )
            .setListeners( listeners );

        injectSession2( request, legacySupport.getSession() );

        return resolveWithExceptions( request );
    }
663#public ArtifactResolutionResult resolveWithExceptions( ArtifactResolutionRequest request )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        ArtifactResolutionResult result = resolve( request );

        // We have collected all the problems so let's mimic the way the old code worked and just blow up right here.
        // That's right lets just let it rip right here and send a big incomprehensible blob of text at unsuspecting
        // users. Bad dog!

        resolutionErrorHandler.throwErrors( request, result );

        return result;
    }
664#// ------------------------------------------------------------------------
    //
    // ------------------------------------------------------------------------

    public ArtifactResolutionResult resolve( ArtifactResolutionRequest request )
    {
        Artifact rootArtifact = request.getArtifact();
        Set<Artifact> artifacts = request.getArtifactDependencies();
        Map managedVersions = request.getManagedVersionMap();
        List<ResolutionListener> listeners = request.getListeners();
        ArtifactFilter collectionFilter = request.getCollectionFilter();                       
        ArtifactFilter resolutionFilter = request.getResolutionFilter();
        RepositorySystemSession session = getSession( request.getLocalRepository() );
        
        //TODO: hack because metadata isn't generated in m2e correctly and i want to run the maven i have in the workspace
        if ( source == null )
        {
            try
            {
                source = container.lookup( ArtifactMetadataSource.class );
            }
            catch ( ComponentLookupException e )
            {
                // won't happen
            }
        }

        if ( listeners == null )
        {
            listeners = new ArrayList<ResolutionListener>();

            if ( logger.isDebugEnabled() )
            {
                listeners.add( new DebugResolutionListener( logger ) );
            }

            listeners.add( new WarningResolutionListener( logger ) );
        }

        ArtifactResolutionResult result = new ArtifactResolutionResult();

        // The root artifact may, or may not be resolved so we need to check before we attempt to resolve.
        // This is often an artifact like a POM that is taken from disk and we already have hold of the
        // file reference. But this may be a Maven Plugin that we need to resolve from a remote repository
        // as well as its dependencies.
                        
        if ( request.isResolveRoot() /* && rootArtifact.getFile() == null */ )
        {            
            try
            {
                resolve( rootArtifact, request.getRemoteRepositories(), session );
            }
            catch ( ArtifactResolutionException e )
            {
                result.addErrorArtifactException( e );
                return result;
            }
            catch ( ArtifactNotFoundException e )
            {
                result.addMissingArtifact( request.getArtifact() );
                return result;
            }
        }

        ArtifactResolutionRequest collectionRequest = request;

        if ( request.isResolveTransitively() )
        {
            MetadataResolutionRequest metadataRequest = new DefaultMetadataResolutionRequest( request );

            metadataRequest.setArtifact( rootArtifact );
            metadataRequest.setResolveManagedVersions( managedVersions == null );

            try
            {
                ResolutionGroup resolutionGroup = source.retrieve( metadataRequest );

                if ( managedVersions == null )
                {
                    managedVersions = resolutionGroup.getManagedVersions();
                }

                Set<Artifact> directArtifacts = resolutionGroup.getArtifacts();

                if ( artifacts == null || artifacts.isEmpty() )
                {
                    artifacts = directArtifacts;
                }
                else
                {
                    List<Artifact> allArtifacts = new ArrayList<Artifact>();
                    allArtifacts.addAll( artifacts );
                    allArtifacts.addAll( directArtifacts );

                    Map<String, Artifact> mergedArtifacts = new LinkedHashMap<String, Artifact>();
                    for ( Artifact artifact : allArtifacts )
                    {
                        String conflictId = artifact.getDependencyConflictId();
                        if ( !mergedArtifacts.containsKey( conflictId ) )
                        {
                            mergedArtifacts.put( conflictId, artifact );
                        }
                    }

                    artifacts = new LinkedHashSet<Artifact>( mergedArtifacts.values() );
                }

                collectionRequest = new ArtifactResolutionRequest( request );
                collectionRequest.setServers( request.getServers() );
                collectionRequest.setMirrors( request.getMirrors() );
                collectionRequest.setProxies( request.getProxies() );
                collectionRequest.setRemoteRepositories( resolutionGroup.getResolutionRepositories() );
            }
            catch ( ArtifactMetadataRetrievalException e )
            {
                ArtifactResolutionException are =
                    new ArtifactResolutionException( "Unable to get dependency information for " + rootArtifact.getId()
                        + ": " + e.getMessage(), rootArtifact, metadataRequest.getRemoteRepositories(), e );
                result.addMetadataResolutionException( are );
                return result;
            }
        }
        
        if ( artifacts == null || artifacts.isEmpty() )
        {
            if ( request.isResolveRoot() )
            {
                result.addArtifact( rootArtifact );
            }
            return result;
        } 

        // After the collection we will have the artifact object in the result but they will not be resolved yet.
        result =
            artifactCollector.collect( artifacts, rootArtifact, managedVersions, collectionRequest, source,
                                       collectionFilter, listeners, null );
                        
        // We have metadata retrieval problems, or there are cycles that have been detected
        // so we give this back to the calling code and let them deal with this information
        // appropriately.

        if ( result.hasMetadataResolutionExceptions() || result.hasVersionRangeViolations() || result.hasCircularDependencyExceptions() )
        {
            return result;
        }

        if ( result.getArtifactResolutionNodes() != null )
        {
            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();

            CountDownLatch latch = new CountDownLatch( result.getArtifactResolutionNodes().size() );

            for ( ResolutionNode node : result.getArtifactResolutionNodes() )
            {
                Artifact artifact = node.getArtifact();

                if ( resolutionFilter == null || resolutionFilter.include( artifact ) )
                {
                    executor.execute( new ResolveTask( classLoader, latch, artifact, session,
                                                       node.getRemoteRepositories(), result ) );
                }
                else
                {
                    latch.countDown();
                }
            }
            try
            {
                latch.await();
            }
            catch ( InterruptedException e )
            {
                result.addErrorArtifactException( new ArtifactResolutionException( "Resolution interrupted",
                                                                                   rootArtifact, e ) );
            }
        }

        // We want to send the root artifact back in the result but we need to do this after the other dependencies
        // have been resolved.
        if ( request.isResolveRoot() )
        {            
            // Add the root artifact (as the first artifact to retain logical order of class path!)
            Set<Artifact> allArtifacts = new LinkedHashSet<Artifact>();
            allArtifacts.add( rootArtifact );
            allArtifacts.addAll( result.getArtifacts() );
            result.setArtifacts( allArtifacts );
        }                        
                 
        return result;
    }
665#public void resolve( Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        resolve( artifact, remoteRepositories, localRepository, null );
    }
666#public Thread newThread( Runnable r )
        {
            Thread newThread = new Thread( group, r, "resolver-" + threadNumber.getAndIncrement() );
            newThread.setDaemon( true );
            return newThread;
        }
667#public ResolveTask( ClassLoader classLoader, CountDownLatch latch, Artifact artifact, RepositorySystemSession session,
                            List<ArtifactRepository> remoteRepositories, ArtifactResolutionResult result )
        {
            this.classLoader = classLoader;
            this.latch = latch;
            this.artifact = artifact;
            this.session = session;
            this.remoteRepositories = remoteRepositories;
            this.result = result;
        }
668#public void run()
        {
            try
            {
                Thread.currentThread().setContextClassLoader( classLoader );
                resolve( artifact, remoteRepositories, session );
            }
            catch ( ArtifactNotFoundException anfe )
            {
                // These are cases where the artifact just isn't present in any of the remote repositories
                // because it wasn't deployed, or it was deployed in the wrong place.

                synchronized ( result )
                {
                    result.addMissingArtifact( artifact );
                }
            }
            catch ( ArtifactResolutionException e )
            {
                // This is really a wagon TransferFailedException so something went wrong after we successfully
                // retrieved the metadata.

                synchronized ( result )
                {
                    result.addErrorArtifactException( e );
                }
            }
            finally
            {
                latch.countDown();
            }
        }
669#public DebugResolutionListener( Logger logger )
    {
        this.logger = logger;
    }
670#public void testArtifact( Artifact node )
    {
    }
671#public void startProcessChildren( Artifact artifact )
    {
        indent += "  ";
    }
672#public void endProcessChildren( Artifact artifact )
    {
        indent = indent.substring( 2 );
    }
673#public void includeArtifact( Artifact artifact )
    {
        logger.debug( indent + artifact + " (selected for " + artifact.getScope() + ")" );
    }
674#public void omitForNearer( Artifact omitted, Artifact kept )
    {
        String omittedVersion = omitted.getVersion();
        String keptVersion = kept.getVersion();

        if ( omittedVersion != null ? !omittedVersion.equals( keptVersion ) : keptVersion != null )
        {
            logger.debug( indent + omitted + " (removed - nearer found: " + kept.getVersion() + ")" );
        }
    }
675#public void omitForCycle( Artifact omitted )
    {
        logger.debug( indent + omitted + " (removed - causes a cycle in the graph)" );
    }
676#public void updateScopeCurrentPom( Artifact artifact, String ignoredScope )
    {
        logger.debug( indent + artifact + " (not setting artifactScope to: " + ignoredScope + "; local artifactScope "
            + artifact.getScope() + " wins)" );

        // TODO: better way than static? this might hide messages in a reactor
        if ( !ignoredArtifacts.contains( artifact ) )
        {
            logger.warn( "\n\tArtifact " + artifact + " retains local artifactScope '" + artifact.getScope()
                + "' overriding broader artifactScope '" + ignoredScope + "'\n"
                + "\tgiven by a dependency. If this is not intended, modify or remove the local artifactScope.\n" );
            ignoredArtifacts.add( artifact );
        }
    }
677#public void updateScope( Artifact artifact, String scope )
    {
        logger.debug( indent + artifact + " (setting artifactScope to: " + scope + ")" );
    }
678#public void selectVersionFromRange( Artifact artifact )
    {
        logger.debug( indent + artifact + " (setting version to: " + artifact.getVersion() + " from range: "
            + artifact.getVersionRange() + ")" );
    }
679#public void restrictRange( Artifact artifact, Artifact replacement, VersionRange newRange )
    {
        logger.debug( indent + artifact + " (range restricted from: " + artifact.getVersionRange() + " and: "
            + replacement.getVersionRange() + " to: " + newRange + " )" );
    }
680#/**
     * The logic used here used to be a copy of the logic used in the DefaultArtifactCollector, and this method was
     * called right before the actual version/artifactScope changes were done. However, a different set of conditionals (and
     * more information) is needed to be able to determine when and if the version and/or artifactScope changes. See the two
     * added methods, manageArtifactVersion and manageArtifactScope.
     */
    public void manageArtifact( Artifact artifact, Artifact replacement )
    {
        String msg = indent + artifact;
        msg += " (";
        if ( replacement.getVersion() != null )
        {
            msg += "applying version: " + replacement.getVersion() + ";";
        }
        if ( replacement.getScope() != null )
        {
            msg += "applying artifactScope: " + replacement.getScope();
        }
        msg += ")";
        logger.debug( msg );
    }
681#public void manageArtifactVersion( Artifact artifact, Artifact replacement )
    {
        // only show msg if a change is actually taking place
        if ( !replacement.getVersion().equals( artifact.getVersion() ) )
        {
            String msg = indent + artifact + " (applying version: " + replacement.getVersion() + ")";
            logger.debug( msg );
        }
    }
682#public void manageArtifactScope( Artifact artifact, Artifact replacement )
    {
        // only show msg if a change is actually taking place
        if ( !replacement.getScope().equals( artifact.getScope() ) )
        {
            String msg = indent + artifact + " (applying artifactScope: " + replacement.getScope() + ")";
            logger.debug( msg );
        }
    }
683#public void manageArtifactSystemPath( Artifact artifact, Artifact replacement )
    {
        // only show msg if a change is actually taking place
        if ( !replacement.getScope().equals( artifact.getScope() ) )
        {
            String msg = indent + artifact + " (applying system path: " + replacement.getFile() + ")";
            logger.debug( msg );
        }
    }
684#public UnresolvedArtifacts( Artifact originatingArtifact,
                                List<Artifact> artifacts,
                                List<ArtifactRepository> remoteRepositories )
    {
        this.originatingArtifact = originatingArtifact;

        this.artifacts = artifacts;

        this.remoteRepositories = remoteRepositories;
    }
685#public Artifact getOriginatingArtifact()
    {
        return originatingArtifact;
    }
686#public List<Artifact> getArtifacts()
    {
        return artifacts;
    }
687#public List<ArtifactRepository> getRemoteRepositories()
    {
        return remoteRepositories;
    }
688#public WarningResolutionListener( Logger logger )
    {
        this.logger = logger;
    }
689#public void testArtifact( Artifact node )
    {
    }
690#public void startProcessChildren( Artifact artifact )
    {
    }
691#public void endProcessChildren( Artifact artifact )
    {
    }
692#public void includeArtifact( Artifact artifact )
    {
    }
693#public void omitForNearer( Artifact omitted,
                               Artifact kept )
    {
    }
694#public void omitForCycle( Artifact omitted )
    {
    }
695#public void updateScopeCurrentPom( Artifact artifact,
                                       String scope )
    {
    }
696#public void updateScope( Artifact artifact,
                             String scope )
    {
    }
697#public void manageArtifact( Artifact artifact,
                                Artifact replacement )
    {
    }
698#public void selectVersionFromRange( Artifact artifact )
    {
    }
699#public void restrictRange( Artifact artifact,
                               Artifact replacement,
                               VersionRange newRange )
    {
    }
700#ArtifactResolutionResult resolve( ArtifactResolutionRequest request );
701#// USED BY SUREFIRE
    @Deprecated
    ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact,
                                                  ArtifactRepository localRepository,
                                                  List<ArtifactRepository> remoteRepositories,
                                                  ArtifactMetadataSource source, ArtifactFilter filter )
        throws ArtifactResolutionException, ArtifactNotFoundException;
702#// USED BY MAVEN ASSEMBLY PLUGIN
    @Deprecated
    ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact,
                                                  Map managedVersions, ArtifactRepository localRepository,
                                                  List<ArtifactRepository> remoteRepositories,
                                                  ArtifactMetadataSource source )
        throws ArtifactResolutionException, ArtifactNotFoundException;
703#// USED BY MAVEN ASSEMBLY PLUGIN
    @Deprecated
    ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact,
                                                  Map managedVersions, ArtifactRepository localRepository,
                                                  List<ArtifactRepository> remoteRepositories,
                                                  ArtifactMetadataSource source, ArtifactFilter filter )
        throws ArtifactResolutionException, ArtifactNotFoundException;
704#@Deprecated
    ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact,
                                                  List<ArtifactRepository> remoteRepositories,
                                                  ArtifactRepository localRepository, ArtifactMetadataSource source )
        throws ArtifactResolutionException, ArtifactNotFoundException;
705#@Deprecated
    ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact,
                                                  Map managedVersions, ArtifactRepository localRepository,
                                                  List<ArtifactRepository> remoteRepositories,
                                                  ArtifactMetadataSource source, ArtifactFilter filter,
                                                  List<ResolutionListener> listeners )
        throws ArtifactResolutionException, ArtifactNotFoundException;
706#@Deprecated
    ArtifactResolutionResult resolveTransitively( Set<Artifact> artifacts, Artifact originatingArtifact,
                                                  List<ArtifactRepository> remoteRepositories,
                                                  ArtifactRepository localRepository, ArtifactMetadataSource source,
                                                  List<ResolutionListener> listeners )
        throws ArtifactResolutionException, ArtifactNotFoundException;
707#// USED BY REMOTE RESOURCES PLUGIN
    @Deprecated
    void resolve( Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository )
        throws ArtifactResolutionException, ArtifactNotFoundException;
708#// USED BY REMOTE RESOURCES PLUGIN
    @Deprecated
    void resolve( Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository,
                  TransferListener downloadMonitor )
        throws ArtifactResolutionException, ArtifactNotFoundException;
709#// USED BY ARCHETYPE DOWNLOADER
    @Deprecated
    void resolveAlways( Artifact artifact, List<ArtifactRepository> remoteRepositories,
                        ArtifactRepository localRepository )
        throws ArtifactResolutionException, ArtifactNotFoundException;
710#@Deprecated
    ArtifactResolutionResult collect( Set<Artifact> artifacts, Artifact originatingArtifact,
                                      ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories,
                                      ArtifactMetadataSource source, ArtifactFilter filter,
                                      List<ResolutionListener> listeners )
        throws ArtifactResolutionException;
711#public InversionArtifactFilter( ArtifactFilter toInvert )
    {
        this.toInvert = toInvert;
    }
712#public boolean include( Artifact artifact )
    {
        return !toInvert.include( artifact );
    }
713#@Override
    public int hashCode()
    {
        int hash = 17;
        hash = hash * 31 + toInvert.hashCode();
        return hash;
    }
714#@Override
    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        
        if ( !( obj instanceof InversionArtifactFilter ) )
        {
            return false;
        }
        
        InversionArtifactFilter other = (InversionArtifactFilter) obj;
        
        return toInvert.equals( other.toInvert );
    }
715#public TypeArtifactFilter( String type )
    {
        this.type = type;
    }
716#public boolean include( Artifact artifact )
    {
        return type.equals( artifact.getType() );
    }
717#@Override
    public int hashCode()
    {
        int hash = 17;
        hash = hash * 31 + type.hashCode();
        return hash;
    }
718#@Override
    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        
        if ( !( obj instanceof TypeArtifactFilter ) )
        {
            return false;
        }
        
        TypeArtifactFilter other = (TypeArtifactFilter) obj;
        
        return type.equals( other.type );
    }
719#public OrArtifactFilter()
    {
        this.filters = new LinkedHashSet<ArtifactFilter>();
    }
720#public OrArtifactFilter( Collection<ArtifactFilter> filters )
    {
        this.filters = new LinkedHashSet<ArtifactFilter>( filters );
    }
721#public boolean include( Artifact artifact )
    {
        for ( ArtifactFilter filter : filters )
        {
            if ( filter.include( artifact ) )
            {
                return true;
            }
        }

        return false;
    }
722#public void add( ArtifactFilter artifactFilter )
    {
        filters.add( artifactFilter );
    }
723#@Override
    public int hashCode()
    {
        int hash = 17;
        hash = hash * 31 + filters.hashCode();
        return hash;
    }
724#@Override
    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        
        if ( !( obj instanceof OrArtifactFilter ) )
        {
            return false;
        }
        
        OrArtifactFilter other = (OrArtifactFilter) obj;
        
        return filters.equals( other.filters );
    }
725#public ManagedVersionMap( Map<String, Artifact> map )
    {
        super();
        if ( map != null )
        {
            putAll( map );
        }
    }
726#public String toString()
    {
        StringBuilder buffer = new StringBuilder( "ManagedVersionMap (" + size() + " entries)\n" );
        Iterator<String> iter = keySet().iterator();
        while ( iter.hasNext() )
        {
            String key = iter.next();
            buffer.append( key ).append( "=" ).append( get( key ) );
            if ( iter.hasNext() )
            {
                buffer.append( "\n" );
            }
        }
        return buffer.toString();
    }
727#public ArtifactVersion getApplicationVersion()
    {
        return applicationVersion;
    }
728#public void initialize()
        throws InitializationException
    {
        String mavenVersion = rtInfo.getMavenVersion();

        if ( StringUtils.isEmpty( mavenVersion ) )
        {
            throw new InitializationException( "Unable to read Maven version from maven-core" );
        }

        applicationVersion = new DefaultArtifactVersion( mavenVersion );
    }
729#ArtifactVersion getApplicationVersion();
730#private ProfilesConversionUtils()
    {
    }
731#public static Profile convertFromProfileXmlProfile( org.apache.maven.profiles.Profile profileXmlProfile )
    {
        Profile profile = new Profile();

        profile.setId( profileXmlProfile.getId() );

        profile.setSource( "profiles.xml" );

        org.apache.maven.profiles.Activation profileActivation = profileXmlProfile.getActivation();

        if ( profileActivation != null )
        {
            Activation activation = new Activation();

            activation.setActiveByDefault( profileActivation.isActiveByDefault() );

            activation.setJdk( profileActivation.getJdk() );

            org.apache.maven.profiles.ActivationProperty profileProp = profileActivation.getProperty();

            if ( profileProp != null )
            {
                ActivationProperty prop = new ActivationProperty();

                prop.setName( profileProp.getName() );
                prop.setValue( profileProp.getValue() );

                activation.setProperty( prop );
            }

            
            ActivationOS profileOs = profileActivation.getOs();
            
            if ( profileOs != null )
            {
                org.apache.maven.model.ActivationOS os = new org.apache.maven.model.ActivationOS();

                os.setArch( profileOs.getArch() );
                os.setFamily( profileOs.getFamily() );
                os.setName( profileOs.getName() );
                os.setVersion( profileOs.getVersion() );

                activation.setOs( os );
            }
            
            org.apache.maven.profiles.ActivationFile profileFile = profileActivation.getFile();

            if ( profileFile != null )
            {
                ActivationFile file = new ActivationFile();

                file.setExists( profileFile.getExists() );
                file.setMissing( profileFile.getMissing() );

                activation.setFile( file );
            }

            profile.setActivation( activation );
        }

        profile.setProperties( profileXmlProfile.getProperties() );

        List repos = profileXmlProfile.getRepositories();
        if ( repos != null )
        {
            for ( Iterator it = repos.iterator(); it.hasNext(); )
            {
                profile
                    .addRepository(
                        convertFromProfileXmlRepository( (org.apache.maven.profiles.Repository) it.next() ) );
            }
        }

        List pluginRepos = profileXmlProfile.getPluginRepositories();
        if ( pluginRepos != null )
        {
            for ( Iterator it = pluginRepos.iterator(); it.hasNext(); )
            {
                profile.addPluginRepository( convertFromProfileXmlRepository( (org.apache.maven.profiles.Repository) it
                    .next() ) );
            }
        }

        return profile;
    }
732#private static Repository convertFromProfileXmlRepository( org.apache.maven.profiles.Repository profileXmlRepo )
    {
        Repository repo = new Repository();

        repo.setId( profileXmlRepo.getId() );
        repo.setLayout( profileXmlRepo.getLayout() );
        repo.setName( profileXmlRepo.getName() );
        repo.setUrl( profileXmlRepo.getUrl() );

        if ( profileXmlRepo.getSnapshots() != null )
        {
            repo.setSnapshots( convertRepositoryPolicy( profileXmlRepo.getSnapshots() ) );
        }
        if ( profileXmlRepo.getReleases() != null )
        {
            repo.setReleases( convertRepositoryPolicy( profileXmlRepo.getReleases() ) );
        }

        return repo;
    }
733#private static org.apache.maven.model.RepositoryPolicy convertRepositoryPolicy( RepositoryPolicy profileXmlRepo )
    {
        org.apache.maven.model.RepositoryPolicy policy = new org.apache.maven.model.RepositoryPolicy();
        policy.setEnabled( profileXmlRepo.isEnabled() );
        policy.setUpdatePolicy( profileXmlRepo.getUpdatePolicy() );
        policy.setChecksumPolicy( profileXmlRepo.getChecksumPolicy() );
        return policy;
    }
734#public ProfilesRoot buildProfiles( File basedir )
        throws IOException, XmlPullParserException
    {
        File profilesXml = new File( basedir, PROFILES_XML_FILE );

        ProfilesRoot profilesRoot = null;

        if ( profilesXml.exists() )
        {
            ProfilesXpp3Reader reader = new ProfilesXpp3Reader();
            Reader profileReader = null;
            try
            {
                profileReader = ReaderFactory.newXmlReader( profilesXml );

                StringWriter sWriter = new StringWriter();

                IOUtil.copy( profileReader, sWriter );

                String rawInput = sWriter.toString();

                try
                {
                    RegexBasedInterpolator interpolator = new RegexBasedInterpolator();
                    interpolator.addValueSource( new EnvarBasedValueSource() );

                    rawInput = interpolator.interpolate( rawInput, "settings" );
                }
                catch ( Exception e )
                {
                    getLogger().warn( "Failed to initialize environment variable resolver. Skipping environment "
                                          + "substitution in " + PROFILES_XML_FILE + "." );
                    getLogger().debug( "Failed to initialize envar resolver. Skipping resolution.", e );
                }

                StringReader sReader = new StringReader( rawInput );

                profilesRoot = reader.read( sReader );
            }
            finally
            {
                IOUtil.close( profileReader );
            }
        }

        return profilesRoot;
    }
735#void addProfile( Profile profile );
736#void explicitlyActivate( String profileId );
737#void explicitlyActivate( List profileIds );
738#void explicitlyDeactivate( String profileId );
739#void explicitlyDeactivate( List profileIds );
740#List getActiveProfiles()
        throws ProfileActivationException;
741#void addProfiles( List profiles );
742#Map getProfilesById();
743#List getExplicitlyActivatedIds();
744#List getExplicitlyDeactivatedIds();
745#List getIdsActivatedByDefault();
746#Properties getRequestProperties();
747#/**
     * @deprecated without passing in the system properties, the SystemPropertiesProfileActivator will not work
     *             correctly in embedded envirnments.
     */
    public DefaultProfileManager( PlexusContainer container )
    {
        this( container, null );
    }
748#/**
     * the properties passed to the profile manager are the props that
     * are passed to maven, possibly containing profile activator properties
     *
     */
    public DefaultProfileManager( PlexusContainer container, Properties props )
    {
        try
        {
            this.profileSelector = container.lookup( ProfileSelector.class );
            this.logger = ( (MutablePlexusContainer) container ).getLogger();
        }
        catch ( ComponentLookupException e )
        {
            throw new IllegalStateException( e );
        }
        this.requestProperties = props;
    }
749#public Properties getRequestProperties()
    {
        return requestProperties;
    }
750#public Map getProfilesById()
    {
        return profilesById;
    }
751#/* (non-Javadoc)
    * @see org.apache.maven.profiles.ProfileManager#addProfile(org.apache.maven.model.Profile)
    */
    public void addProfile( Profile profile )
    {
        String profileId = profile.getId();

        Profile existing = (Profile) profilesById.get( profileId );
        if ( existing != null )
        {
            logger.warn( "Overriding profile: \'" + profileId + "\' (source: " + existing.getSource()
                + ") with new instance from source: " + profile.getSource() );
        }

        profilesById.put( profile.getId(), profile );

        Activation activation = profile.getActivation();

        if ( activation != null && activation.isActiveByDefault() )
        {
            activateAsDefault( profileId );
        }
    }
752#/* (non-Javadoc)
    * @see org.apache.maven.profiles.ProfileManager#explicitlyActivate(java.lang.String)
    */
    public void explicitlyActivate( String profileId )
    {
        if ( !activatedIds.contains( profileId ) )
        {
            logger.debug( "Profile with id: \'" + profileId + "\' has been explicitly activated." );

            activatedIds.add( profileId );
        }
    }
753#/* (non-Javadoc)
    * @see org.apache.maven.profiles.ProfileManager#explicitlyActivate(java.util.List)
    */
    public void explicitlyActivate( List profileIds )
    {
        for ( Iterator it = profileIds.iterator(); it.hasNext(); )
        {
            String profileId = (String) it.next();

            explicitlyActivate( profileId );
        }
    }
754#/* (non-Javadoc)
    * @see org.apache.maven.profiles.ProfileManager#explicitlyDeactivate(java.lang.String)
    */
    public void explicitlyDeactivate( String profileId )
    {
        if ( !deactivatedIds.contains( profileId ) )
        {
            logger.debug( "Profile with id: \'" + profileId + "\' has been explicitly deactivated." );

            deactivatedIds.add( profileId );
        }
    }
755#/* (non-Javadoc)
    * @see org.apache.maven.profiles.ProfileManager#explicitlyDeactivate(java.util.List)
    */
    public void explicitlyDeactivate( List profileIds )
    {
        for ( Iterator it = profileIds.iterator(); it.hasNext(); )
        {
            String profileId = (String) it.next();

            explicitlyDeactivate( profileId );
        }
    }
756#/* (non-Javadoc)
    * @see org.apache.maven.profiles.ProfileManager#getActiveProfiles()
    */
    public List getActiveProfiles()
        throws ProfileActivationException
    {
        DefaultProfileActivationContext context = new DefaultProfileActivationContext();
        context.setActiveProfileIds( activatedIds );
        context.setInactiveProfileIds( deactivatedIds );
        context.setSystemProperties( System.getProperties() );
        context.setUserProperties( requestProperties );

        final List<ProfileActivationException> errors = new ArrayList<ProfileActivationException>();

        List<Profile> profiles =
            profileSelector.getActiveProfiles( profilesById.values(), context, new ModelProblemCollector()
            {

                public void add( Severity severity, String message, InputLocation location, Exception cause )
                {
                    if ( !ModelProblem.Severity.WARNING.equals( severity ) )
                    {
                        errors.add( new ProfileActivationException( message, cause ) );
                    }
                }

            } );

        if ( !errors.isEmpty() )
        {
            throw errors.get( 0 );
        }

        return profiles;
    }
757#/* (non-Javadoc)
     * @see org.apache.maven.profiles.ProfileManager#addProfiles(java.util.List)
     */
    public void addProfiles( List profiles )
    {
        for ( Iterator it = profiles.iterator(); it.hasNext(); )
        {
            Profile profile = (Profile) it.next();

            addProfile( profile );
        }
    }
758#public void activateAsDefault( String profileId )
    {
        if ( !defaultIds.contains( profileId ) )
        {
            defaultIds.add( profileId );
        }
    }
759#public List getExplicitlyActivatedIds()
    {
        return activatedIds;
    }
760#public List getExplicitlyDeactivatedIds()
    {
        return deactivatedIds;
    }
761#public List getIdsActivatedByDefault()
    {
        return defaultIds;
    }
762#ProfilesRoot buildProfiles( File basedir )
        throws IOException, XmlPullParserException;
763#public ProfileActivationException( String message, Throwable cause )
    {
        super( message, cause );
    }
764#public ProfileActivationException( String message )
    {
        super( message );
    }
765#boolean canDetermineActivation( Profile profile );
766#boolean isActive( Profile profile )
        throws ProfileActivationException;
767#public boolean canDetermineActivation( Profile profile )
    {
        Activation activation = profile.getActivation();
        return activation != null && activation.getOs() != null;
    }
768#public boolean isActive( Profile profile )
    {
        Activation activation = profile.getActivation();
        ActivationOS os = activation.getOs();

        boolean result = ensureAtLeastOneNonNull( os );

        if ( result && os.getFamily() != null )
        {
            result = determineFamilyMatch( os.getFamily() );
        }
        if ( result && os.getName() != null )
        {
            result = determineNameMatch( os.getName() );
        }
        if ( result && os.getArch() != null )
        {
            result = determineArchMatch( os.getArch() );
        }
        if ( result && os.getVersion() != null )
        {
            result = determineVersionMatch( os.getVersion() );
        }
        return result;
    }
769#private boolean ensureAtLeastOneNonNull( ActivationOS os )
    {
        return os.getArch() != null || os.getFamily() != null || os.getName() != null || os.getVersion() != null;
    }
770#private boolean determineVersionMatch( String version )
    {
        String test = version;
        boolean reverse = false;
        
        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }
        
        boolean result = Os.isVersion( test );
        
        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }
771#private boolean determineArchMatch( String arch )
    {
        String test = arch;
        boolean reverse = false;
        
        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }
        
        boolean result = Os.isArch( test );
        
        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }
772#private boolean determineNameMatch( String name )
    {
        String test = name;
        boolean reverse = false;
        
        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isName( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }
773#private boolean determineFamilyMatch( String family )
    {
        String test = family;
        boolean reverse = false;
        
        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }
        
        boolean result = Os.isFamily( test );
        
        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }
774#protected boolean canDetectActivation( Profile profile )
    {
        return profile.getActivation() != null && profile.getActivation().getFile() != null;
    }
775#public boolean isActive( Profile profile )
    {
        Activation activation = profile.getActivation();

        ActivationFile actFile = activation.getFile();

        if ( actFile != null )
        {
            // check if the file exists, if it does then the profile will be active
            String fileString = actFile.getExists();

            RegexBasedInterpolator interpolator = new RegexBasedInterpolator();
            try
            {
                interpolator.addValueSource( new EnvarBasedValueSource() );
            }
            catch ( IOException e )
            {
                // ignored
            }
            interpolator.addValueSource( new MapBasedValueSource( System.getProperties() ) );

            try
            {
                if ( StringUtils.isNotEmpty( fileString ) )
                {
                    fileString = StringUtils.replace( interpolator.interpolate( fileString, "" ), "\\", "/" );
                    return FileUtils.fileExists( fileString );
                }

                // check if the file is missing, if it is then the profile will be active
                fileString = actFile.getMissing();

                if ( StringUtils.isNotEmpty( fileString ) )
                {
                    fileString = StringUtils.replace( interpolator.interpolate( fileString, "" ), "\\", "/" );
                    return !FileUtils.fileExists( fileString );
                }
            }
            catch ( InterpolationException e )
            {
                if ( logger.isDebugEnabled() )
                {
                    logger.debug( "Failed to interpolate missing file location for profile activator: " + fileString,
                                  e );
                }
                else
                {
                    logger.warn( "Failed to interpolate missing file location for profile activator: " + fileString
                        + ". Run in debug mode (-X) for more information." );
                }
            }
        }

        return false;
    }
776#public void enableLogging( Logger logger )
    {
        this.logger = logger;
    }
777#public boolean canDetermineActivation( Profile profile )
    {
        return canDetectActivation( profile );
    }
778#protected abstract boolean canDetectActivation( Profile profile );
779#public void contextualize( Context context )
        throws ContextException
    {
        properties = (Properties) context.get( "SystemProperties" );
    }
780#protected boolean canDetectActivation( Profile profile )
    {
        return profile.getActivation() != null && profile.getActivation().getProperty() != null;
    }
781#public boolean isActive( Profile profile )
        throws ProfileActivationException
    {
        Activation activation = profile.getActivation();

        ActivationProperty property = activation.getProperty();

        if ( property != null )
        {
            String name = property.getName();
            boolean reverseName = false;

            if ( name == null )
            {
                throw new ProfileActivationException( "The property name is required to activate the profile '"
                    + profile.getId() + "'" );
            }

            if ( name.startsWith("!") )
            {
                reverseName = true;
                name = name.substring( 1 );
            }

            String sysValue = properties.getProperty( name );

            String propValue = property.getValue();
            if ( StringUtils.isNotEmpty( propValue ) )
            {
                boolean reverseValue = false;
                if ( propValue.startsWith( "!" ) )
                {
                    reverseValue = true;
                    propValue = propValue.substring( 1 );
                }

                // we have a value, so it has to match the system value...
                boolean result = propValue.equals( sysValue );

                if ( reverseValue )
                {
                    return !result;
                }
                else
                {
                    return result;
                }
            }
            else
            {
                boolean result = StringUtils.isNotEmpty( sysValue );

                if ( reverseName )
                {
                    return !result;
                }
                else
                {
                    return result;
                }
            }
        }

        return false;
    }
782#public boolean isActive( Profile profile )
        throws ProfileActivationException
    {
        Activation activation = profile.getActivation();

        String jdk = activation.getJdk();

        // null case is covered by canDetermineActivation(), so we can do a straight startsWith() here.
        if ( jdk.startsWith( "[" ) || jdk.startsWith( "(" ) )
        {
            try
            {
                return matchJdkVersionRange( jdk );
            }
            catch ( InvalidVersionSpecificationException e )
            {
                throw new ProfileActivationException( "Invalid JDK version in profile '" + profile.getId() + "': "
                    + e.getMessage() );
            }
        }

        boolean reverse = false;

        if ( jdk.startsWith( "!" ) )
        {
            reverse = true;
            jdk = jdk.substring( 1 );
        }

        if ( getJdkVersion().startsWith( jdk ) )
        {
            return !reverse;
        }
        else
        {
            return reverse;
        }
    }
783#private boolean matchJdkVersionRange( String jdk )
        throws InvalidVersionSpecificationException
    {
        VersionRange jdkVersionRange = VersionRange.createFromVersionSpec( convertJdkToMavenVersion( jdk ) );
        DefaultArtifactVersion jdkVersion = new DefaultArtifactVersion( convertJdkToMavenVersion( getJdkVersion() ) );
        return jdkVersionRange.containsVersion( jdkVersion );
    }
784#private String convertJdkToMavenVersion( String jdk )
    {
        return jdk.replaceAll( "_", "-" );
    }
785#protected String getJdkVersion()
    {
        return JDK_VERSION;
    }
786#protected boolean canDetectActivation( Profile profile )
    {
        return profile.getActivation() != null && StringUtils.isNotEmpty( profile.getActivation().getJdk() );
    }
787#ArtifactRepository getLocalRepository();
788#ProfileManager getGlobalProfileManager();
789#Properties getUserProperties();
790#Properties getExecutionProperties();
791#ProjectBuilderConfiguration setGlobalProfileManager( ProfileManager globalProfileManager );
792#ProjectBuilderConfiguration setLocalRepository( ArtifactRepository localRepository );
793#ProjectBuilderConfiguration setUserProperties( Properties userProperties );
794#ProjectBuilderConfiguration setExecutionProperties( Properties executionProperties );
795#Date getBuildStartTime();
796#ProjectBuilderConfiguration setBuildStartTime( Date buildStartTime );
797#// ----------------------------------------------------------------------
    // MavenProjectBuilder Implementation
    // ----------------------------------------------------------------------

    private ProjectBuildingRequest toRequest( ProjectBuilderConfiguration configuration )
    {
        DefaultProjectBuildingRequest request = new DefaultProjectBuildingRequest();

        request.setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 );
        request.setResolveDependencies( false );

        request.setLocalRepository( configuration.getLocalRepository() );
        request.setBuildStartTime( configuration.getBuildStartTime() );
        request.setUserProperties( configuration.getUserProperties() );
        request.setSystemProperties( configuration.getExecutionProperties() );

        ProfileManager profileManager = configuration.getGlobalProfileManager();
        if ( profileManager != null )
        {
            request.setActiveProfileIds( profileManager.getExplicitlyActivatedIds() );
            request.setInactiveProfileIds( profileManager.getExplicitlyDeactivatedIds() );
        }
        else
        {
            /*
             * MNG-4900: Hack to workaround deficiency of legacy API which makes it impossible for plugins to access the
             * global profile manager which is required to build a POM like a CLI invocation does. Failure to consider
             * the activated profiles can cause repo declarations to be lost which in turn will result in artifact
             * resolution failures, in particular when using the enhanced local repo which guards access to local files
             * based on the configured remote repos.
             */
            MavenSession session = legacySupport.getSession();
            if ( session != null )
            {
                MavenExecutionRequest req = session.getRequest();
                if ( req != null )
                {
                    request.setActiveProfileIds( req.getActiveProfiles() );
                    request.setInactiveProfileIds( req.getInactiveProfiles() );
                }
            }
        }

        return request;
    }
798#private ProjectBuildingRequest injectSession( ProjectBuildingRequest request )
    {
        MavenSession session = legacySupport.getSession();
        if ( session != null )
        {
            request.setRepositorySession( session.getRepositorySession() );
            request.setSystemProperties( session.getSystemProperties() );
            if ( request.getUserProperties().isEmpty() )
            {
                request.setUserProperties( session.getUserProperties() );
            }

            MavenExecutionRequest req = session.getRequest();
            if ( req != null )
            {
                request.setRemoteRepositories( req.getRemoteRepositories() );
            }
        }
        else
        {
            Properties props = new Properties();
            EnvironmentUtils.addEnvVars( props );
            props.putAll( System.getProperties() );
            request.setSystemProperties( props );
        }

        return request;
    }
799#@SuppressWarnings( "unchecked" )
    private List<ArtifactRepository> normalizeToArtifactRepositories( List<?> repositories,
                                                                      ProjectBuildingRequest request )
        throws ProjectBuildingException
    {
        /*
         * This provides backward-compat with 2.x that allowed plugins like the maven-remote-resources-plugin:1.0 to
         * populate the builder configuration with model repositories instead of artifact repositories.
         */

        if ( repositories != null )
        {
            boolean normalized = false;

            List<ArtifactRepository> repos = new ArrayList<ArtifactRepository>( repositories.size() );

            for ( Object repository : repositories )
            {
                if ( repository instanceof Repository )
                {
                    try
                    {
                        ArtifactRepository repo = repositorySystem.buildArtifactRepository( (Repository) repository );
                        repositorySystem.injectMirror( request.getRepositorySession(), Arrays.asList( repo ) );
                        repositorySystem.injectProxy( request.getRepositorySession(), Arrays.asList( repo ) );
                        repositorySystem.injectAuthentication( request.getRepositorySession(), Arrays.asList( repo ) );
                        repos.add( repo );
                    }
                    catch ( InvalidRepositoryException e )
                    {
                        throw new ProjectBuildingException( "", "Invalid remote repository " + repository, e );
                    }
                    normalized = true;
                }
                else
                {
                    repos.add( (ArtifactRepository) repository );
                }
            }

            if ( normalized )
            {
                return repos;
            }
        }

        return (List<ArtifactRepository>) repositories;
    }
800#private ProjectBuildingException transformError( ProjectBuildingException e )
    {
        if ( e.getCause() instanceof ModelBuildingException )
        {
            return new InvalidProjectModelException( e.getProjectId(), e.getMessage(), e.getPomFile() );
        }

        return e;
    }
801#public MavenProject build( File pom, ProjectBuilderConfiguration configuration )
        throws ProjectBuildingException
    {
        ProjectBuildingRequest request = injectSession( toRequest( configuration ) );

        try
        {
            return projectBuilder.build( pom, request ).getProject();
        }
        catch ( ProjectBuildingException e )
        {
            throw transformError( e );
        }
    }
802#// This is used by the SITE plugin.
    public MavenProject build( File pom, ArtifactRepository localRepository, ProfileManager profileManager )
        throws ProjectBuildingException
    {
        ProjectBuilderConfiguration configuration = new DefaultProjectBuilderConfiguration();
        configuration.setLocalRepository( localRepository );
        configuration.setGlobalProfileManager( profileManager );

        return build( pom, configuration );
    }
803#public MavenProject buildFromRepository( Artifact artifact, List<ArtifactRepository> remoteRepositories,
                                             ProjectBuilderConfiguration configuration, boolean allowStubModel )
        throws ProjectBuildingException
    {
        ProjectBuildingRequest request = injectSession( toRequest( configuration ) );
        request.setRemoteRepositories( normalizeToArtifactRepositories( remoteRepositories, request ) );
        request.setProcessPlugins( false );
        request.setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL );

        try
        {
            return projectBuilder.build( artifact, allowStubModel, request ).getProject();
        }
        catch ( ProjectBuildingException e )
        {
            throw transformError( e );
        }
    }
804#public MavenProject buildFromRepository( Artifact artifact, List<ArtifactRepository> remoteRepositories,
                                             ArtifactRepository localRepository, boolean allowStubModel )
        throws ProjectBuildingException
    {
        ProjectBuilderConfiguration configuration = new DefaultProjectBuilderConfiguration();
        configuration.setLocalRepository( localRepository );

        return buildFromRepository( artifact, remoteRepositories, configuration, allowStubModel );
    }
805#public MavenProject buildFromRepository( Artifact artifact, List<ArtifactRepository> remoteRepositories,
                                             ArtifactRepository localRepository )
        throws ProjectBuildingException
    {
        return buildFromRepository( artifact, remoteRepositories, localRepository, true );
    }
806#/**
     * This is used for pom-less execution like running archetype:generate. I am taking out the profile handling and the
     * interpolation of the base directory until we spec this out properly.
     */
    public MavenProject buildStandaloneSuperProject( ProjectBuilderConfiguration configuration )
        throws ProjectBuildingException
    {
        ProjectBuildingRequest request = injectSession( toRequest( configuration ) );
        request.setProcessPlugins( false );
        request.setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL );

        ModelSource modelSource = new UrlModelSource( getClass().getResource( "standalone.xml" ) );

        MavenProject project = projectBuilder.build( modelSource, request ).getProject();
        project.setExecutionRoot( true );
        return project;
    }
807#public MavenProject buildStandaloneSuperProject( ArtifactRepository localRepository )
        throws ProjectBuildingException
    {
        return buildStandaloneSuperProject( localRepository, null );
    }
808#public MavenProject buildStandaloneSuperProject( ArtifactRepository localRepository, ProfileManager profileManager )
        throws ProjectBuildingException
    {
        ProjectBuilderConfiguration configuration = new DefaultProjectBuilderConfiguration();
        configuration.setLocalRepository( localRepository );
        configuration.setGlobalProfileManager( profileManager );

        return buildStandaloneSuperProject( configuration );
    }
809#public MavenProject buildWithDependencies( File pom, ArtifactRepository localRepository,
                                               ProfileManager profileManager, TransferListener transferListener )
        throws ProjectBuildingException, ArtifactResolutionException, ArtifactNotFoundException
    {
        ProjectBuilderConfiguration configuration = new DefaultProjectBuilderConfiguration();
        configuration.setLocalRepository( localRepository );
        configuration.setGlobalProfileManager( profileManager );

        ProjectBuildingRequest request = injectSession( toRequest( configuration ) );

        request.setResolveDependencies( true );

        try
        {
            return projectBuilder.build( pom, request ).getProject();
        }
        catch ( ProjectBuildingException e )
        {
            throw transformError( e );
        }
    }
810#public MavenProject buildWithDependencies( File pom, ArtifactRepository localRepository,
                                               ProfileManager profileManager )
        throws ProjectBuildingException, ArtifactResolutionException, ArtifactNotFoundException
    {
        return buildWithDependencies( pom, localRepository, profileManager, null );
    }
811#public DefaultProjectBuilderConfiguration()
    {
    }
812#public ProjectBuilderConfiguration setGlobalProfileManager( ProfileManager globalProfileManager )
    {
        this.globalProfileManager = globalProfileManager;
        return this;
    }
813#public ProfileManager getGlobalProfileManager()
    {
        return globalProfileManager;
    }
814#public ProjectBuilderConfiguration setLocalRepository( ArtifactRepository localRepository )
    {
        this.localRepository = localRepository;
        return this;
    }
815#public ArtifactRepository getLocalRepository()
    {
        return localRepository;
    }
816#public ProjectBuilderConfiguration setUserProperties( Properties userProperties )
    {
        this.userProperties = userProperties;
        return this;
    }
817#public Properties getUserProperties()
    {
        if ( userProperties == null )
        {
            userProperties = new Properties();
        }

        return userProperties;
    }
818#public Properties getExecutionProperties()
    {
        return executionProperties;
    }
819#public ProjectBuilderConfiguration setExecutionProperties( Properties executionProperties )
    {
        this.executionProperties = executionProperties;
        return this;
    }
820#public Date getBuildStartTime()
    {
        return buildStartTime;
    }
821#public ProjectBuilderConfiguration setBuildStartTime( Date buildStartTime )
    {
        this.buildStartTime = buildStartTime;
        return this;
    }
822#/**
     * This should be the resulting ordering of plugins after merging:
     * <p/>
     * Given:
     * <p/>
     * parent: X -> A -> B -> D -> E
     * child: Y -> A -> C -> D -> F
     * <p/>
     * Result:
     * <p/>
     * X -> Y -> A -> B -> C -> D -> E -> F
     */
    public static void mergePluginLists( PluginContainer childContainer, PluginContainer parentContainer,
                                         boolean handleAsInheritance )
    {
        if ( ( childContainer == null ) || ( parentContainer == null ) )
        {
            // nothing to do.
            return;
        }

        List parentPlugins = parentContainer.getPlugins();

        if ( ( parentPlugins != null ) && !parentPlugins.isEmpty() )
        {
            parentPlugins = new ArrayList( parentPlugins );

            // If we're processing this merge as an inheritance, we have to build up a list of
            // plugins that were considered for inheritance.
            if ( handleAsInheritance )
            {
                for ( Iterator it = parentPlugins.iterator(); it.hasNext(); )
                {
                    Plugin plugin = (Plugin) it.next();

                    String inherited = plugin.getInherited();

                    if ( ( inherited != null ) && !Boolean.valueOf( inherited ).booleanValue() )
                    {
                        it.remove();
                    }
                }
            }

            List assembledPlugins = new ArrayList();

            Map childPlugins = childContainer.getPluginsAsMap();

            for ( Iterator it = parentPlugins.iterator(); it.hasNext(); )
            {
                Plugin parentPlugin = (Plugin) it.next();

                String parentInherited = parentPlugin.getInherited();

                // only merge plugin definition from the parent if at least one
                // of these is true:
                // 1. we're not processing the plugins in an inheritance-based merge
                // 2. the parent's <inherited/> flag is not set
                // 3. the parent's <inherited/> flag is set to true
                if ( !handleAsInheritance || ( parentInherited == null )
                    || Boolean.valueOf( parentInherited ).booleanValue() )
                {
                    Plugin childPlugin = (Plugin) childPlugins.get( parentPlugin.getKey() );

                    if ( ( childPlugin != null ) && !assembledPlugins.contains( childPlugin ) )
                    {
                        Plugin assembledPlugin = childPlugin;

                        mergePluginDefinitions( childPlugin, parentPlugin, handleAsInheritance );

                        // fix for MNG-2221 (assembly cache was not being populated for later reference):
                        assembledPlugins.add( assembledPlugin );
                    }

                    // if we're processing this as an inheritance-based merge, and
                    // the parent's <inherited/> flag is not set, then we need to
                    // clear the inherited flag in the merge result.
                    if ( handleAsInheritance && ( parentInherited == null ) )
                    {
                        parentPlugin.unsetInheritanceApplied();
                    }
                }

                // very important to use the parentPlugins List, rather than parentContainer.getPlugins()
                // since this list is a local one, and may have been modified during processing.
                List results =
                    ModelUtils.orderAfterMerge( assembledPlugins, parentPlugins, childContainer.getPlugins() );

                childContainer.setPlugins( results );

                childContainer.flushPluginMap();
            }
        }
    }
823#public static List orderAfterMerge( List merged, List highPrioritySource, List lowPrioritySource )
    {
        List results = new ArrayList();

        if ( !merged.isEmpty() )
        {
            results.addAll( merged );
        }

        List missingFromResults = new ArrayList();

        List sources = new ArrayList();

        sources.add( highPrioritySource );
        sources.add( lowPrioritySource );

        for ( Iterator sourceIterator = sources.iterator(); sourceIterator.hasNext(); )
        {
            List source = (List) sourceIterator.next();

            for ( Iterator it = source.iterator(); it.hasNext(); )
            {
                Object item = it.next();

                if ( results.contains( item ) )
                {
                    if ( !missingFromResults.isEmpty() )
                    {
                        int idx = results.indexOf( item );

                        if ( idx < 0 )
                        {
                            idx = 0;
                        }

                        results.addAll( idx, missingFromResults );

                        missingFromResults.clear();
                    }
                }
                else
                {
                    missingFromResults.add( item );
                }
            }

            if ( !missingFromResults.isEmpty() )
            {
                results.addAll( missingFromResults );

                missingFromResults.clear();
            }
        }

        return results;
    }
824#public static void mergePluginDefinitions( Plugin child, Plugin parent, boolean handleAsInheritance )
    {
        if ( ( child == null ) || ( parent == null ) )
        {
            // nothing to do.
            return;
        }

        if ( parent.isExtensions() )
        {
            child.setExtensions( true );
        }

        if ( ( child.getVersion() == null ) && ( parent.getVersion() != null ) )
        {
            child.setVersion( parent.getVersion() );
        }

        Xpp3Dom childConfiguration = (Xpp3Dom) child.getConfiguration();
        Xpp3Dom parentConfiguration = (Xpp3Dom) parent.getConfiguration();

        childConfiguration = Xpp3Dom.mergeXpp3Dom( childConfiguration, parentConfiguration );

        child.setConfiguration( childConfiguration );

        child.setDependencies( mergeDependencyList( child.getDependencies(), parent.getDependencies() ) );

        // from here to the end of the method is dealing with merging of the <executions/> section.
        String parentInherited = parent.getInherited();

        boolean parentIsInherited = ( parentInherited == null ) || Boolean.valueOf( parentInherited ).booleanValue();

        List parentExecutions = parent.getExecutions();

        if ( ( parentExecutions != null ) && !parentExecutions.isEmpty() )
        {
            List mergedExecutions = new ArrayList();

            Map assembledExecutions = new TreeMap();

            Map childExecutions = child.getExecutionsAsMap();

            for ( Iterator it = parentExecutions.iterator(); it.hasNext(); )
            {
                PluginExecution parentExecution = (PluginExecution) it.next();

                String inherited = parentExecution.getInherited();

                boolean parentExecInherited =
                    parentIsInherited && ( ( inherited == null ) || Boolean.valueOf( inherited ).booleanValue() );

                if ( !handleAsInheritance || parentExecInherited )
                {
                    PluginExecution assembled = parentExecution;

                    PluginExecution childExecution = (PluginExecution) childExecutions.get( parentExecution.getId() );

                    if ( childExecution != null )
                    {
                        mergePluginExecutionDefinitions( childExecution, parentExecution );

                        assembled = childExecution;
                    }
                    else if ( handleAsInheritance && ( parentInherited == null ) )
                    {
                        parentExecution.unsetInheritanceApplied();
                    }

                    assembledExecutions.put( assembled.getId(), assembled );
                    mergedExecutions.add( assembled );
                }
            }

            for ( Iterator it = child.getExecutions().iterator(); it.hasNext(); )
            {
                PluginExecution childExecution = (PluginExecution) it.next();

                if ( !assembledExecutions.containsKey( childExecution.getId() ) )
                {
                    mergedExecutions.add( childExecution );
                }
            }

            child.setExecutions( mergedExecutions );

            child.flushExecutionMap();
        }

    }
825#private static void mergePluginExecutionDefinitions( PluginExecution child, PluginExecution parent )
    {
        if ( child.getPhase() == null )
        {
            child.setPhase( parent.getPhase() );
        }

        List parentGoals = parent.getGoals();
        List childGoals = child.getGoals();

        List goals = new ArrayList();

        if ( ( childGoals != null ) && !childGoals.isEmpty() )
        {
            goals.addAll( childGoals );
        }

        if ( parentGoals != null )
        {
            for ( Iterator goalIterator = parentGoals.iterator(); goalIterator.hasNext(); )
            {
                String goal = (String) goalIterator.next();

                if ( !goals.contains( goal ) )
                {
                    goals.add( goal );
                }
            }
        }

        child.setGoals( goals );

        Xpp3Dom childConfiguration = (Xpp3Dom) child.getConfiguration();
        Xpp3Dom parentConfiguration = (Xpp3Dom) parent.getConfiguration();

        childConfiguration = Xpp3Dom.mergeXpp3Dom( childConfiguration, parentConfiguration );

        child.setConfiguration( childConfiguration );
    }
826#public static List mergeRepositoryLists( List dominant, List recessive )
    {
        List repositories = new ArrayList();

        for ( Iterator it = dominant.iterator(); it.hasNext(); )
        {
            Repository repository = (Repository) it.next();

            repositories.add( repository );
        }

        for ( Iterator it = recessive.iterator(); it.hasNext(); )
        {
            Repository repository = (Repository) it.next();

            if ( !repositories.contains( repository ) )
            {
                repositories.add( repository );
            }
        }

        return repositories;
    }
827#public static void mergeFilterLists( List childFilters, List parentFilters )
    {
        for ( Iterator i = parentFilters.iterator(); i.hasNext(); )
        {
            String f = (String) i.next();
            if ( !childFilters.contains( f ) )
            {
                childFilters.add( f );
            }
        }
    }
828#private static List mergeDependencyList( List child, List parent )
    {
        Map depsMap = new LinkedHashMap();

        if ( parent != null )
        {
            for ( Iterator it = parent.iterator(); it.hasNext(); )
            {
                Dependency dependency = (Dependency) it.next();
                depsMap.put( dependency.getManagementKey(), dependency );
            }
        }

        if ( child != null )
        {
            for ( Iterator it = child.iterator(); it.hasNext(); )
            {
                Dependency dependency = (Dependency) it.next();
                depsMap.put( dependency.getManagementKey(), dependency );
            }
        }

        return new ArrayList( depsMap.values() );
    }
829#MavenProject build( File pom, ProjectBuilderConfiguration configuration )
        throws ProjectBuildingException;
830#//TODO maven-site-plugin -- Vincent, Dennis and Lukas are checking but this doesn't appear to be required anymore.
    MavenProject build( File pom, ArtifactRepository localRepository, ProfileManager profileManager )
        throws ProjectBuildingException;
831#//TODO remote-resources-plugin
    MavenProject buildFromRepository( Artifact artifact, List<ArtifactRepository> remoteRepositories,
                                      ArtifactRepository localRepository )
        throws ProjectBuildingException;
832#//TODO remote-resources-plugin
    MavenProject buildFromRepository( Artifact artifact, List<ArtifactRepository> remoteRepositories,
                                      ArtifactRepository localRepository, boolean allowStubModel )
        throws ProjectBuildingException;
833#// TODO: this is only to provide a project for plugins that don't need a project to execute but need some
    // of the values from a MavenProject. Ideally this should be something internal and nothing outside Maven
    // would ever need this so it should not be exposed in a public API
    MavenProject buildStandaloneSuperProject( ProjectBuilderConfiguration configuration )
        throws ProjectBuildingException;
834#MavenProject buildStandaloneSuperProject( ArtifactRepository localRepository )
        throws ProjectBuildingException;
835#MavenProject buildStandaloneSuperProject( ArtifactRepository localRepository, ProfileManager profileManager )
        throws ProjectBuildingException;
836#MavenProject buildWithDependencies( File pom, ArtifactRepository localRepository,
                                        ProfileManager globalProfileManager, TransferListener transferListener )
        throws ProjectBuildingException, ArtifactResolutionException, ArtifactNotFoundException;
837#MavenProject buildWithDependencies( File pom, ArtifactRepository localRepository,
                                        ProfileManager globalProfileManager )
        throws ProjectBuildingException, ArtifactResolutionException, ArtifactNotFoundException;
838#private ProjectUtils()
    {
    }
839#public static List<ArtifactRepository> buildArtifactRepositories( List<Repository> repositories,
                                                                      ArtifactRepositoryFactory artifactRepositoryFactory,
                                                                      PlexusContainer c )
        throws InvalidRepositoryException
    {

        List<ArtifactRepository> remoteRepositories = new ArrayList<ArtifactRepository>();

        for ( Repository r : repositories )
        {
            remoteRepositories.add( buildArtifactRepository( r, artifactRepositoryFactory, c ) );
        }

        return remoteRepositories;
    }
840#public static ArtifactRepository buildDeploymentArtifactRepository( DeploymentRepository repo,
                                                                        ArtifactRepositoryFactory artifactRepositoryFactory,
                                                                        PlexusContainer c )
        throws InvalidRepositoryException
    {
        return buildArtifactRepository( repo, artifactRepositoryFactory, c );
    }
841#public static ArtifactRepository buildArtifactRepository( Repository repo,
                                                              ArtifactRepositoryFactory artifactRepositoryFactory,
                                                              PlexusContainer c )
        throws InvalidRepositoryException
    {
        RepositorySystem repositorySystem = rs( c );
        RepositorySystemSession session = rss( c );

        ArtifactRepository repository = repositorySystem.buildArtifactRepository( repo );

        if ( session != null )
        {
            repositorySystem.injectMirror( session, Arrays.asList( repository ) );
            repositorySystem.injectProxy( session, Arrays.asList( repository ) );
            repositorySystem.injectAuthentication( session, Arrays.asList( repository ) );
        }

        return repository;
    }
842#private static RepositorySystem rs( PlexusContainer c )
    {
        try
        {
            return c.lookup( RepositorySystem.class );
        }
        catch ( ComponentLookupException e )
        {
            throw new IllegalStateException( e );
        }
    }
843#private static RepositorySystemSession rss( PlexusContainer c )
    {
        try
        {
            LegacySupport legacySupport = c.lookup( LegacySupport.class );

            return legacySupport.getRepositorySession();
        }
        catch ( ComponentLookupException e )
        {
            throw new IllegalStateException( e );
        }
    }
844#public MissingRepositoryElementException( String message, String repositoryId )
    {
        super( message, repositoryId );
    }
845#public MissingRepositoryElementException( String message )
    {
        super( message, "-unknown-" );
    }
846#public InvalidProjectModelException( String projectId, String message, File pomLocation )
    {
        super( projectId, message, pomLocation );
    }
847#/**
     * @param projectId
     * @param pomLocation      absolute path of the pom file
     * @param message
     * @param validationResult
     * @deprecated use {@link File} constructor for pomLocation
     */
    public InvalidProjectModelException( String projectId, String pomLocation, String message,
                                         ModelValidationResult validationResult )
    {
        this( projectId, message, new File( pomLocation ), validationResult );
    }
848#public InvalidProjectModelException( String projectId, String message, File pomFile,
                                         ModelValidationResult validationResult )
    {
        super( projectId, message, pomFile );

        this.validationResult = validationResult;
    }
849#/**
     * @param projectId
     * @param pomLocation absolute path of the pom file
     * @param message
     * @deprecated use {@link File} constructor for pomLocation
     */
    public InvalidProjectModelException( String projectId, String pomLocation, String message )
    {
        this( projectId, message, new File( pomLocation ) );
    }
850#public final ModelValidationResult getValidationResult()
    {
        return validationResult;
    }
851#// TODO: Remove this!
    @SuppressWarnings( "unchecked" )
    public void assembleBuildInheritance( Build childBuild, Build parentBuild, boolean handleAsInheritance )
    {
        // The build has been set but we want to step in here and fill in
        // values that have not been set by the child.

        if ( childBuild.getSourceDirectory() == null )
        {
            childBuild.setSourceDirectory( parentBuild.getSourceDirectory() );
        }

        if ( childBuild.getScriptSourceDirectory() == null )
        {
            childBuild.setScriptSourceDirectory( parentBuild.getScriptSourceDirectory() );
        }

        if ( childBuild.getTestSourceDirectory() == null )
        {
            childBuild.setTestSourceDirectory( parentBuild.getTestSourceDirectory() );
        }

        if ( childBuild.getOutputDirectory() == null )
        {
            childBuild.setOutputDirectory( parentBuild.getOutputDirectory() );
        }

        if ( childBuild.getTestOutputDirectory() == null )
        {
            childBuild.setTestOutputDirectory( parentBuild.getTestOutputDirectory() );
        }

        // Extensions are accumulated
        mergeExtensionLists( childBuild, parentBuild );

        if ( childBuild.getDirectory() == null )
        {
            childBuild.setDirectory( parentBuild.getDirectory() );
        }

        if ( childBuild.getDefaultGoal() == null )
        {
            childBuild.setDefaultGoal( parentBuild.getDefaultGoal() );
        }

        if ( childBuild.getFinalName() == null )
        {
            childBuild.setFinalName( parentBuild.getFinalName() );
        }

        ModelUtils.mergeFilterLists( childBuild.getFilters(), parentBuild.getFilters() );

        List<Resource> resources = childBuild.getResources();
        if ( ( resources == null ) || resources.isEmpty() )
        {
            childBuild.setResources( parentBuild.getResources() );
        }

        resources = childBuild.getTestResources();
        if ( ( resources == null ) || resources.isEmpty() )
        {
            childBuild.setTestResources( parentBuild.getTestResources() );
        }

        // Plugins are aggregated if Plugin.inherit != false
        ModelUtils.mergePluginLists( childBuild, parentBuild, handleAsInheritance );

        // Plugin management :: aggregate
        PluginManagement dominantPM = childBuild.getPluginManagement();
        PluginManagement recessivePM = parentBuild.getPluginManagement();

        if ( ( dominantPM == null ) && ( recessivePM != null ) )
        {
            // FIXME: Filter out the inherited == false stuff!
            childBuild.setPluginManagement( recessivePM );
        }
        else
        {
            ModelUtils.mergePluginLists( childBuild.getPluginManagement(), parentBuild.getPluginManagement(), false );
        }
    }
852#private void assembleScmInheritance( Model child, Model parent, String childPathAdjustment, boolean appendPaths )
    {
        if ( parent.getScm() != null )
        {
            Scm parentScm = parent.getScm();

            Scm childScm = child.getScm();

            if ( childScm == null )
            {
                childScm = new Scm();

                child.setScm( childScm );
            }

            if ( StringUtils.isEmpty( childScm.getConnection() ) && !StringUtils.isEmpty( parentScm.getConnection() ) )
            {
                childScm.setConnection(
                    appendPath( parentScm.getConnection(), child.getArtifactId(), childPathAdjustment, appendPaths ) );
            }

            if ( StringUtils.isEmpty( childScm.getDeveloperConnection() )
                && !StringUtils.isEmpty( parentScm.getDeveloperConnection() ) )
            {
                childScm
                    .setDeveloperConnection( appendPath( parentScm.getDeveloperConnection(), child.getArtifactId(),
                                                         childPathAdjustment, appendPaths ) );
            }

            if ( StringUtils.isEmpty( childScm.getUrl() ) && !StringUtils.isEmpty( parentScm.getUrl() ) )
            {
                childScm.setUrl(
                    appendPath( parentScm.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths ) );
            }
        }
    }
853#public void copyModel( Model dest, Model source )
    {
        assembleModelInheritance( dest, source, null, false );
    }
854#public void assembleModelInheritance( Model child, Model parent, String childPathAdjustment )
    {
        assembleModelInheritance( child, parent, childPathAdjustment, true );
    }
855#public void assembleModelInheritance( Model child, Model parent )
    {
        assembleModelInheritance( child, parent, null, true );
    }
856#private void assembleModelInheritance( Model child, Model parent, String childPathAdjustment, boolean appendPaths )
    {
        // cannot inherit from null parent.
        if ( parent == null )
        {
            return;
        }

        // Group id
        if ( child.getGroupId() == null )
        {
            child.setGroupId( parent.getGroupId() );
        }

        // version
        if ( child.getVersion() == null )
        {
            // The parent version may have resolved to something different, so we take what we asked for...
            // instead of - child.setVersion( parent.getVersion() );

            if ( child.getParent() != null )
            {
                child.setVersion( child.getParent().getVersion() );
            }
        }

        // inceptionYear
        if ( child.getInceptionYear() == null )
        {
            child.setInceptionYear( parent.getInceptionYear() );
        }

        // url
        if ( child.getUrl() == null )
        {
            if ( parent.getUrl() != null )
            {
                child.setUrl( appendPath( parent.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths ) );
            }
            else
            {
                child.setUrl( parent.getUrl() );
            }
        }

        assembleDistributionInheritence( child, parent, childPathAdjustment, appendPaths );

        // issueManagement
        if ( child.getIssueManagement() == null )
        {
            child.setIssueManagement( parent.getIssueManagement() );
        }

        // description
        if ( child.getDescription() == null )
        {
            child.setDescription( parent.getDescription() );
        }

        // Organization
        if ( child.getOrganization() == null )
        {
            child.setOrganization( parent.getOrganization() );
        }

        // Scm
        assembleScmInheritance( child, parent, childPathAdjustment, appendPaths );

        // ciManagement
        if ( child.getCiManagement() == null )
        {
            child.setCiManagement( parent.getCiManagement() );
        }

        // developers
        if ( child.getDevelopers().size() == 0 )
        {
            child.setDevelopers( parent.getDevelopers() );
        }

        // licenses
        if ( child.getLicenses().size() == 0 )
        {
            child.setLicenses( parent.getLicenses() );
        }

        // developers
        if ( child.getContributors().size() == 0 )
        {
            child.setContributors( parent.getContributors() );
        }

        // mailingLists
        if ( child.getMailingLists().size() == 0 )
        {
            child.setMailingLists( parent.getMailingLists() );
        }

        // Build
        assembleBuildInheritance( child, parent );

        assembleDependencyInheritance( child, parent );

        child.setRepositories( ModelUtils.mergeRepositoryLists( child.getRepositories(), parent.getRepositories() ) );
//        child.setPluginRepositories(
//            ModelUtils.mergeRepositoryLists( child.getPluginRepositories(), parent.getPluginRepositories() ) );

        assembleReportingInheritance( child, parent );

        assembleDependencyManagementInheritance( child, parent );

        Properties props = new Properties();
        props.putAll( parent.getProperties() );
        props.putAll( child.getProperties() );

        child.setProperties( props );
    }
857#// TODO: Remove this!
    @SuppressWarnings( "unchecked" )
    private void assembleDependencyManagementInheritance( Model child, Model parent )
    {
        DependencyManagement parentDepMgmt = parent.getDependencyManagement();

        DependencyManagement childDepMgmt = child.getDependencyManagement();

        if ( parentDepMgmt != null )
        {
            if ( childDepMgmt == null )
            {
                child.setDependencyManagement( parentDepMgmt );
            }
            else
            {
                List<Dependency> childDeps = childDepMgmt.getDependencies();

                Map<String, Dependency> mappedChildDeps = new TreeMap<String, Dependency>();
                for ( Iterator<Dependency> it = childDeps.iterator(); it.hasNext(); )
                {
                    Dependency dep = it.next();
                    mappedChildDeps.put( dep.getManagementKey(), dep );
                }

                for ( Iterator<Dependency> it = parentDepMgmt.getDependencies().iterator(); it.hasNext(); )
                {
                    Dependency dep = it.next();
                    if ( !mappedChildDeps.containsKey( dep.getManagementKey() ) )
                    {
                        childDepMgmt.addDependency( dep );
                    }
                }
            }
        }
    }
858#private void assembleReportingInheritance( Model child, Model parent )
    {
        // Reports :: aggregate
        Reporting childReporting = child.getReporting();
        Reporting parentReporting = parent.getReporting();

        if ( parentReporting != null )
        {
            if ( childReporting == null )
            {
                childReporting = new Reporting();
                child.setReporting( childReporting );
            }

            childReporting.setExcludeDefaults( parentReporting.isExcludeDefaults() );

            if ( StringUtils.isEmpty( childReporting.getOutputDirectory() ) )
            {
                childReporting.setOutputDirectory( parentReporting.getOutputDirectory() );
            }

            mergeReportPluginLists( childReporting, parentReporting, true );
        }
    }
859#private static void mergeReportPluginLists( Reporting child, Reporting parent, boolean handleAsInheritance )
    {
        if ( ( child == null ) || ( parent == null ) )
        {
            // nothing to do.
            return;
        }

        List parentPlugins = parent.getPlugins();

        if ( ( parentPlugins != null ) && !parentPlugins.isEmpty() )
        {
            Map assembledPlugins = new TreeMap();

            Map childPlugins = child.getReportPluginsAsMap();

            for ( Iterator it = parentPlugins.iterator(); it.hasNext(); )
            {
                ReportPlugin parentPlugin = (ReportPlugin) it.next();

                String parentInherited = parentPlugin.getInherited();

                if ( !handleAsInheritance || ( parentInherited == null )
                    || Boolean.valueOf( parentInherited ).booleanValue() )
                {

                    ReportPlugin assembledPlugin = parentPlugin;

                    ReportPlugin childPlugin = (ReportPlugin) childPlugins.get( parentPlugin.getKey() );

                    if ( childPlugin != null )
                    {
                        assembledPlugin = childPlugin;

                        mergeReportPluginDefinitions( childPlugin, parentPlugin, handleAsInheritance );
                    }

                    if ( handleAsInheritance && ( parentInherited == null ) )
                    {
                        assembledPlugin.unsetInheritanceApplied();
                    }

                    assembledPlugins.put( assembledPlugin.getKey(), assembledPlugin );
                }
            }

            for ( Iterator it = childPlugins.values().iterator(); it.hasNext(); )
            {
                ReportPlugin childPlugin = (ReportPlugin) it.next();

                if ( !assembledPlugins.containsKey( childPlugin.getKey() ) )
                {
                    assembledPlugins.put( childPlugin.getKey(), childPlugin );
                }
            }

            child.setPlugins( new ArrayList( assembledPlugins.values() ) );

            child.flushReportPluginMap();
        }
    }
860#private static void mergeReportSetDefinitions( ReportSet child, ReportSet parent )
    {
        List parentReports = parent.getReports();
        List childReports = child.getReports();

        List reports = new ArrayList();

        if ( ( childReports != null ) && !childReports.isEmpty() )
        {
            reports.addAll( childReports );
        }

        if ( parentReports != null )
        {
            for ( Iterator i = parentReports.iterator(); i.hasNext(); )
            {
                String report = (String) i.next();

                if ( !reports.contains( report ) )
                {
                    reports.add( report );
                }
            }
        }

        child.setReports( reports );

        Xpp3Dom childConfiguration = (Xpp3Dom) child.getConfiguration();
        Xpp3Dom parentConfiguration = (Xpp3Dom) parent.getConfiguration();

        childConfiguration = Xpp3Dom.mergeXpp3Dom( childConfiguration, parentConfiguration );

        child.setConfiguration( childConfiguration );
    }
861#public static void mergeReportPluginDefinitions( ReportPlugin child, ReportPlugin parent,
                                                     boolean handleAsInheritance )
    {
        if ( ( child == null ) || ( parent == null ) )
        {
            // nothing to do.
            return;
        }

        if ( ( child.getVersion() == null ) && ( parent.getVersion() != null ) )
        {
            child.setVersion( parent.getVersion() );
        }

        // from here to the end of the method is dealing with merging of the <executions/> section.
        String parentInherited = parent.getInherited();

        boolean parentIsInherited = ( parentInherited == null ) || Boolean.valueOf( parentInherited ).booleanValue();

        List parentReportSets = parent.getReportSets();

        if ( ( parentReportSets != null ) && !parentReportSets.isEmpty() )
        {
            Map assembledReportSets = new TreeMap();

            Map childReportSets = child.getReportSetsAsMap();

            for ( Iterator it = parentReportSets.iterator(); it.hasNext(); )
            {
                ReportSet parentReportSet = (ReportSet) it.next();

                if ( !handleAsInheritance || parentIsInherited )
                {
                    ReportSet assembledReportSet = parentReportSet;

                    ReportSet childReportSet = (ReportSet) childReportSets.get( parentReportSet.getId() );

                    if ( childReportSet != null )
                    {
                        mergeReportSetDefinitions( childReportSet, parentReportSet );

                        assembledReportSet = childReportSet;
                    }
                    else if ( handleAsInheritance && ( parentInherited == null ) )
                    {
                        parentReportSet.unsetInheritanceApplied();
                    }

                    assembledReportSets.put( assembledReportSet.getId(), assembledReportSet );
                }
            }

            for ( Iterator it = childReportSets.entrySet().iterator(); it.hasNext(); )
            {
                Map.Entry entry = (Map.Entry) it.next();

                String id = (String) entry.getKey();

                if ( !assembledReportSets.containsKey( id ) )
                {
                    assembledReportSets.put( id, entry.getValue() );
                }
            }

            child.setReportSets( new ArrayList( assembledReportSets.values() ) );

            child.flushReportSetMap();
        }

    }
862#// TODO: Remove this!
    @SuppressWarnings( "unchecked" )
    private void assembleDependencyInheritance( Model child, Model parent )
    {
        Map<String, Dependency> depsMap = new LinkedHashMap<String, Dependency>();

        List<Dependency> deps = parent.getDependencies();

        if ( deps != null )
        {
            for ( Dependency dependency : deps )
            {
                depsMap.put( dependency.getManagementKey(), dependency );
            }
        }

        deps = child.getDependencies();

        if ( deps != null )
        {
            for ( Dependency dependency : deps )
            {
                depsMap.put( dependency.getManagementKey(), dependency );
            }
        }

        child.setDependencies( new ArrayList<Dependency>( depsMap.values() ) );
    }
863#private void assembleBuildInheritance( Model child, Model parent )
    {
        Build childBuild = child.getBuild();
        Build parentBuild = parent.getBuild();

        if ( parentBuild != null )
        {
            if ( childBuild == null )
            {
                childBuild = new Build();
                child.setBuild( childBuild );
            }

            assembleBuildInheritance( childBuild, parentBuild, true );
        }
    }
864#private void assembleDistributionInheritence( Model child, Model parent, String childPathAdjustment,
                                                  boolean appendPaths )
    {
        if ( parent.getDistributionManagement() != null )
        {
            DistributionManagement parentDistMgmt = parent.getDistributionManagement();

            DistributionManagement childDistMgmt = child.getDistributionManagement();

            if ( childDistMgmt == null )
            {
                childDistMgmt = new DistributionManagement();

                child.setDistributionManagement( childDistMgmt );
            }

            if ( childDistMgmt.getSite() == null )
            {
                if ( parentDistMgmt.getSite() != null )
                {
                    Site site = new Site();

                    childDistMgmt.setSite( site );

                    site.setId( parentDistMgmt.getSite().getId() );

                    site.setName( parentDistMgmt.getSite().getName() );

                    site.setUrl( parentDistMgmt.getSite().getUrl() );

                    if ( site.getUrl() != null )
                    {
                        site.setUrl(
                            appendPath( site.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths ) );
                    }
                }
            }

            if ( childDistMgmt.getRepository() == null )
            {
                if ( parentDistMgmt.getRepository() != null )
                {
                    DeploymentRepository repository = copyDistributionRepository( parentDistMgmt.getRepository() );
                    childDistMgmt.setRepository( repository );
                }
            }

            if ( childDistMgmt.getSnapshotRepository() == null )
            {
                if ( parentDistMgmt.getSnapshotRepository() != null )
                {
                    DeploymentRepository repository =
                        copyDistributionRepository( parentDistMgmt.getSnapshotRepository() );
                    childDistMgmt.setSnapshotRepository( repository );
                }
            }

            if ( StringUtils.isEmpty( childDistMgmt.getDownloadUrl() ) )
            {
                childDistMgmt.setDownloadUrl( parentDistMgmt.getDownloadUrl() );
            }

            // NOTE: We SHOULD NOT be inheriting status, since this is an assessment of the POM quality.
            // NOTE: We SHOULD NOT be inheriting relocation, since this relates to a single POM
        }
    }
865#private static DeploymentRepository copyDistributionRepository( DeploymentRepository parentRepository )
    {
        DeploymentRepository repository = new DeploymentRepository();

        repository.setId( parentRepository.getId() );

        repository.setName( parentRepository.getName() );

        repository.setUrl( parentRepository.getUrl() );

        repository.setLayout( parentRepository.getLayout() );

        repository.setUniqueVersion( parentRepository.isUniqueVersion() );

        return repository;
    }
866#// TODO: This should eventually be migrated to DefaultPathTranslator.
    protected String appendPath( String parentPath, String childPath, String pathAdjustment, boolean appendPaths )
    {
        String uncleanPath = parentPath;

        if ( appendPaths )
        {
            if ( pathAdjustment != null )
            {
                uncleanPath += "/" + pathAdjustment;
            }

            if ( childPath != null )
            {
                uncleanPath += "/" + childPath;
            }
        }

        String cleanedPath = "";

        int protocolIdx = uncleanPath.indexOf( "://" );

        if ( protocolIdx > -1 )
        {
            cleanedPath = uncleanPath.substring( 0, protocolIdx + 3 );
            uncleanPath = uncleanPath.substring( protocolIdx + 3 );
        }

        if ( uncleanPath.startsWith( "/" ) )
        {
            cleanedPath += "/";
        }

        return cleanedPath + resolvePath( uncleanPath );
    }
867#// TODO: Move this to plexus-utils' PathTool.
    private static String resolvePath( String uncleanPath )
    {
        LinkedList<String> pathElements = new LinkedList<String>();

        StringTokenizer tokenizer = new StringTokenizer( uncleanPath, "/" );

        while ( tokenizer.hasMoreTokens() )
        {
            String token = tokenizer.nextToken();

            if ( token.equals( "" ) )
            {
                // Empty path entry ("...//.."), remove.
            }
            else if ( token.equals( ".." ) )
            {
                if ( pathElements.isEmpty() )
                {
                    // FIXME: somehow report to the user
                    // that there are too many '..' elements.
                    // For now, ignore the extra '..'.
                }
                else
                {
                    pathElements.removeLast();
                }
            }
            else
            {
                pathElements.addLast( token );
            }
        }

        StringBuilder cleanedPath = new StringBuilder();

        while ( !pathElements.isEmpty() )
        {
            cleanedPath.append( pathElements.removeFirst() );
            if ( !pathElements.isEmpty() )
            {
                cleanedPath.append( '/' );
            }
        }

        return cleanedPath.toString();
    }
868#private static void mergeExtensionLists( Build childBuild, Build parentBuild )
    {
        for ( Extension e : parentBuild.getExtensions() )
        {
            if ( !childBuild.getExtensions().contains( e ) )
            {
                childBuild.addExtension( e );
            }
        }
    }
869#void assembleModelInheritance( Model child, Model parent, String childPathAdjustment );
870#void assembleModelInheritance( Model child, Model parent );
871#void assembleBuildInheritance( Build childBuild, Build parentBuild, boolean handleAsInheriance );
872#void copyModel( Model dest, Model source );
873#public BuildTimestampValueSource( Date startTime, String format )
    {
        super( false );
        this.startTime = startTime;
        this.format = format;
    }
874#public Object getValue( String expression )
    {
        if ( "build.timestamp".equals( expression ) || "maven.build.timestamp".equals( expression ) )
        {
            if ( formattedDate == null && startTime != null )
            {
                formattedDate = new SimpleDateFormat( format ).format( startTime );
            }
            
            return formattedDate;
        }

        return null;
    }
875#public PathTranslatingPostProcessor( List<String> expressionPrefixes, List<String> unprefixedPathKeys,
                                         File projectDir, PathTranslator pathTranslator )
    {
        this.expressionPrefixes = expressionPrefixes;
        this.unprefixedPathKeys = unprefixedPathKeys;
        this.projectDir = projectDir;
        this.pathTranslator = pathTranslator;
    }
876#public Object execute( String expression,
                                      Object value )
    {
        expression = ValueSourceUtils.trimPrefix( expression, expressionPrefixes, true );

        if ( projectDir != null && value != null && unprefixedPathKeys.contains( expression ) )
        {
            return pathTranslator.alignToBaseDirectory( String.valueOf( value ), projectDir );
        }

        return value;
    }
877#// for testing.
    protected AbstractStringBasedModelInterpolator( PathTranslator pathTranslator )
    {
        this.pathTranslator = pathTranslator;
    }
878#/**
     * @todo: Remove the throws clause.
     * @throws IOException This exception is not thrown any more, and needs to be removed.
     */
    protected AbstractStringBasedModelInterpolator()
    {
    }
879#public Model interpolate( Model model, Map<String, ?> context )
        throws ModelInterpolationException
    {
        return interpolate( model, context, true );
    }
880#/**
     * Serialize the inbound Model instance to a StringWriter, perform the regex replacement to resolve
     * POM expressions, then re-parse into the resolved Model instance.
     * <br/>
     * <b>NOTE:</b> This will result in a different instance of Model being returned!!!
     *
     * @param model   The inbound Model instance, to serialize and reference for expression resolution
     * @param context The other context map to be used during resolution
     * @return The resolved instance of the inbound Model. This is a different instance!
     *
     * @deprecated Use {@link ModelInterpolator#interpolate(Model, File, ProjectBuilderConfiguration, boolean)} instead.
     */
    public Model interpolate( Model model, Map<String, ?> context, boolean strict )
        throws ModelInterpolationException
    {
        Properties props = new Properties();
        props.putAll( context );

        return interpolate( model,
                            null,
                            new DefaultProjectBuilderConfiguration().setExecutionProperties( props ),
                            true );
    }
881#public Model interpolate( Model model,
                              File projectDir,
                              ProjectBuilderConfiguration config,
                              boolean debugEnabled )
        throws ModelInterpolationException
    {
        StringWriter sWriter = new StringWriter( 1024 );

        MavenXpp3Writer writer = new MavenXpp3Writer();
        try
        {
            writer.write( sWriter, model );
        }
        catch ( IOException e )
        {
            throw new ModelInterpolationException( "Cannot serialize project model for interpolation.", e );
        }

        String serializedModel = sWriter.toString();
        serializedModel = interpolate( serializedModel, model, projectDir, config, debugEnabled );

        StringReader sReader = new StringReader( serializedModel );

        MavenXpp3Reader modelReader = new MavenXpp3Reader();
        try
        {
            model = modelReader.read( sReader );
        }
        catch ( IOException e )
        {
            throw new ModelInterpolationException(
                "Cannot read project model from interpolating filter of serialized version.", e );
        }
        catch ( XmlPullParserException e )
        {
            throw new ModelInterpolationException(
                "Cannot read project model from interpolating filter of serialized version.", e );
        }

        return model;
    }
882#/**
     * Interpolates all expressions in the src parameter.
     * <p>
     * The algorithm used for each expression is:
     * <ul>
     *   <li>If it starts with either "pom." or "project.", the expression is evaluated against the model.</li>
     *   <li>If the value is null, get the value from the context.</li>
     *   <li>If the value is null, but the context contains the expression, don't replace the expression string
     *       with the value, and continue to find other expressions.</li>
     *   <li>If the value is null, get it from the model properties.</li>
     *   <li>
     * @param overrideContext
     * @param outputDebugMessages
     */
    public String interpolate( String src,
                               Model model,
                               final File projectDir,
                               ProjectBuilderConfiguration config,
                               boolean debug )
        throws ModelInterpolationException
    {
        try
        {
            List<ValueSource> valueSources = createValueSources( model, projectDir, config );
            List<InterpolationPostProcessor> postProcessors = createPostProcessors( model, projectDir, config );

            return interpolateInternal( src, valueSources, postProcessors, debug );
        }
        finally
        {
            interpolator.clearAnswers();
        }
    }
883#protected List<ValueSource> createValueSources( final Model model, final File projectDir,
                                                    final ProjectBuilderConfiguration config )
    {
        String timestampFormat = DEFAULT_BUILD_TIMESTAMP_FORMAT;

        Properties modelProperties = model.getProperties();
        if ( modelProperties != null )
        {
            timestampFormat = modelProperties.getProperty( BUILD_TIMESTAMP_FORMAT_PROPERTY, timestampFormat );
        }

        ValueSource modelValueSource1 = new PrefixedObjectValueSource( PROJECT_PREFIXES, model, false );
        ValueSource modelValueSource2 = new ObjectBasedValueSource( model );

        ValueSource basedirValueSource = new PrefixedValueSourceWrapper( new AbstractValueSource( false )
        {
            public Object getValue( String expression )
            {
                if ( projectDir != null && "basedir".equals( expression ) )
                {
                    return projectDir.getAbsolutePath();
                }
                return null;
            }
        }, PROJECT_PREFIXES, true );
        ValueSource baseUriValueSource = new PrefixedValueSourceWrapper( new AbstractValueSource( false )
        {
            public Object getValue( String expression )
            {
                if ( projectDir != null && "baseUri".equals( expression ) )
                {
                    return projectDir.getAbsoluteFile().toURI().toString();
                }
                return null;
            }
        }, PROJECT_PREFIXES, false );

        List<ValueSource> valueSources = new ArrayList<ValueSource>( 9 );

        // NOTE: Order counts here!
        valueSources.add( basedirValueSource );
        valueSources.add( baseUriValueSource );
        valueSources.add( new BuildTimestampValueSource( config.getBuildStartTime(), timestampFormat ) );
        valueSources.add( modelValueSource1 );
        valueSources.add( new MapBasedValueSource( config.getUserProperties() ) );
        valueSources.add( new MapBasedValueSource( modelProperties ) );
        valueSources.add( new MapBasedValueSource( config.getExecutionProperties() ) );
        valueSources.add( new AbstractValueSource( false )
        {
            public Object getValue( String expression )
            {
                return config.getExecutionProperties().getProperty( "env." + expression );
            }
        } );
        valueSources.add( modelValueSource2 );

        return valueSources;
    }
884#protected List<InterpolationPostProcessor> createPostProcessors( final Model model, final File projectDir,
                                                                     final ProjectBuilderConfiguration config )
    {
        return Collections.singletonList( (InterpolationPostProcessor) new PathTranslatingPostProcessor(
                                                                                                         PROJECT_PREFIXES,
                                                                                                         TRANSLATED_PATH_EXPRESSIONS,
                                                                                                         projectDir,
                                                                                                         pathTranslator ) );
    }
885#@SuppressWarnings("unchecked")
    protected String interpolateInternal( String src, List<ValueSource> valueSources,
                                          List<InterpolationPostProcessor> postProcessors, boolean debug )
        throws ModelInterpolationException
    {
        if ( src.indexOf( "${" ) < 0 )
        {
            return src;
        }

        Logger logger = getLogger();

        String result = src;
        synchronized( this )
        {

            for ( ValueSource vs : valueSources )
            {
                interpolator.addValueSource( vs );
            }

            for ( InterpolationPostProcessor postProcessor : postProcessors )
            {
                interpolator.addPostProcessor( postProcessor );
            }

            try
            {
                try
                {
                    result = interpolator.interpolate( result, recursionInterceptor );
                }
                catch( InterpolationException e )
                {
                    throw new ModelInterpolationException( e.getMessage(), e );
                }

                if ( debug )
                {
                    List<Object> feedback = interpolator.getFeedback();
                    if ( feedback != null && !feedback.isEmpty() )
                    {
                        logger.debug( "Maven encountered the following problems during initial POM interpolation:" );

                        Object last = null;
                        for ( Object next : feedback )
                        {
                            if ( next instanceof Throwable )
                            {
                                if ( last == null )
                                {
                                    logger.debug( "", ( (Throwable) next ) );
                                }
                                else
                                {
                                    logger.debug( String.valueOf( last ), ( (Throwable) next ) );
                                }
                            }
                            else
                            {
                                if ( last != null )
                                {
                                    logger.debug( String.valueOf( last ) );
                                }

                                last = next;
                            }
                        }

                        if ( last != null )
                        {
                            logger.debug( String.valueOf( last ) );
                        }
                    }
                }

                interpolator.clearFeedback();
            }
            finally
            {
                for ( ValueSource vs : valueSources )
                {
                    interpolator.removeValuesSource( vs );
                }

                for ( InterpolationPostProcessor postProcessor : postProcessors )
                {
                    interpolator.removePostProcessor( postProcessor );
                }
            }
        }

        return result;
    }
886#protected RecursionInterceptor getRecursionInterceptor()
    {
        return recursionInterceptor;
    }
887#protected void setRecursionInterceptor( RecursionInterceptor recursionInterceptor )
    {
        this.recursionInterceptor = recursionInterceptor;
    }
888#protected abstract Interpolator createInterpolator();
889#public void initialize()
        throws InitializationException
    {
        interpolator = createInterpolator();
        recursionInterceptor = new PrefixAwareRecursionInterceptor( PROJECT_PREFIXES );
    }
890#protected final Interpolator getInterpolator()
    {
        return interpolator;
    }
891#public StringSearchModelInterpolator()
    {
    }
892#public StringSearchModelInterpolator( PathTranslator pathTranslator )
    {
        super( pathTranslator );
    }
893#public Model interpolate( Model model, File projectDir, ProjectBuilderConfiguration config, boolean debugEnabled )
        throws ModelInterpolationException
    {
        interpolateObject( model, model, projectDir, config, debugEnabled );

        return model;
    }
894#protected void interpolateObject( Object obj, Model model, File projectDir, ProjectBuilderConfiguration config,
                                      boolean debugEnabled )
        throws ModelInterpolationException
    {
        try
        {
            List<ValueSource> valueSources = createValueSources( model, projectDir, config );
            List<InterpolationPostProcessor> postProcessors = createPostProcessors( model, projectDir, config );

            InterpolateObjectAction action =
                new InterpolateObjectAction( obj, valueSources, postProcessors, debugEnabled,
                                             this, getLogger() );

            ModelInterpolationException error = AccessController.doPrivileged( action );

            if ( error != null )
            {
                throw error;
            }
        }
        finally
        {
            getInterpolator().clearAnswers();
        }
    }
895#protected Interpolator createInterpolator()
    {
        StringSearchInterpolator interpolator = new StringSearchInterpolator();
        interpolator.setCacheAnswers( true );

        return interpolator;
    }
896#public InterpolateObjectAction( Object target, List<ValueSource> valueSources,
                                        List<InterpolationPostProcessor> postProcessors, boolean debugEnabled,
                                        StringSearchModelInterpolator modelInterpolator, Logger logger )
        {
            this.valueSources = valueSources;
            this.postProcessors = postProcessors;
            this.debugEnabled = debugEnabled;

            this.interpolationTargets = new LinkedList<Object>();
            interpolationTargets.add( target );

            this.modelInterpolator = modelInterpolator;
            this.logger = logger;
        }
897#public ModelInterpolationException run()
        {
            while ( !interpolationTargets.isEmpty() )
            {
                Object obj = interpolationTargets.removeFirst();

                try
                {
                    traverseObjectWithParents( obj.getClass(), obj );
                }
                catch ( ModelInterpolationException e )
                {
                    return e;
                }
            }

            return null;
        }
898#@SuppressWarnings( "unchecked" )
        private void traverseObjectWithParents( Class<?> cls, Object target )
            throws ModelInterpolationException
        {
            if ( cls == null )
            {
                return;
            }


            if ( cls.isArray() )
            {
                evaluateArray( target );
            }
            else if ( isQualifiedForInterpolation( cls ) )
            {
                Field[] fields = fieldsByClass.get( cls );
                if ( fields == null )
                {
                    fields = cls.getDeclaredFields();
                    fieldsByClass.put( cls, fields );
                }

                for ( int i = 0; i < fields.length; i++ )
                {
                    Class<?> type = fields[i].getType();
                    if ( isQualifiedForInterpolation( fields[i], type ) )
                    {
                        boolean isAccessible = fields[i].isAccessible();
                        fields[i].setAccessible( true );
                        try
                        {
                            try
                            {
                                if ( String.class == type )
                                {
                                    String value = (String) fields[i].get( target );
                                    if ( value != null )
                                    {
                                        String interpolated = modelInterpolator.interpolateInternal( value, valueSources, postProcessors, debugEnabled );

                                        if ( !interpolated.equals( value ) )
                                        {
                                            fields[i].set( target, interpolated );
                                        }
                                    }
                                }
                                else if ( Collection.class.isAssignableFrom( type ) )
                                {
                                    Collection<Object> c = (Collection<Object>) fields[i].get( target );
                                    if ( c != null && !c.isEmpty() )
                                    {
                                        List<Object> originalValues = new ArrayList<Object>( c );
                                        try
                                        {
                                            c.clear();
                                        }
                                        catch ( UnsupportedOperationException e )
                                        {
                                            if ( debugEnabled && logger != null )
                                            {
                                                logger.debug( "Skipping interpolation of field: " + fields[i] + " in: "
                                                    + cls.getName() + "; it is an unmodifiable collection." );
                                            }
                                            continue;
                                        }

                                        for ( Object value : originalValues )
                                        {
                                            if ( value != null )
                                            {
                                                if ( String.class == value.getClass() )
                                                {
                                                    String interpolated =
                                                        modelInterpolator.interpolateInternal( (String) value,
                                                                                               valueSources,
                                                                                               postProcessors,
                                                                                               debugEnabled );

                                                    if ( !interpolated.equals( value ) )
                                                    {
                                                        c.add( interpolated );
                                                    }
                                                    else
                                                    {
                                                        c.add( value );
                                                    }
                                                }
                                                else
                                                {
                                                    c.add( value );
                                                    if ( value.getClass().isArray() )
                                                    {
                                                        evaluateArray( value );
                                                    }
                                                    else
                                                    {
                                                        interpolationTargets.add( value );
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                // add the null back in...not sure what else to do...
                                                c.add( value );
                                            }
                                        }
                                    }
                                }
                                else if ( Map.class.isAssignableFrom( type ) )
                                {
                                    Map<Object, Object> m = (Map<Object, Object>) fields[i].get( target );
                                    if ( m != null && !m.isEmpty() )
                                    {
                                        for ( Map.Entry<Object, Object> entry : m.entrySet() )
                                        {
                                            Object value = entry.getValue();

                                            if ( value != null )
                                            {
                                                if ( String.class == value.getClass() )
                                                {
                                                    String interpolated =
                                                        modelInterpolator.interpolateInternal( (String) value,
                                                                                               valueSources,
                                                                                               postProcessors,
                                                                                               debugEnabled );

                                                    if ( !interpolated.equals( value ) )
                                                    {
                                                        try
                                                        {
                                                            entry.setValue( interpolated );
                                                        }
                                                        catch ( UnsupportedOperationException e )
                                                        {
                                                            if ( debugEnabled && logger != null )
                                                            {
                                                                logger.debug( "Skipping interpolation of field: "
                                                                    + fields[i] + " (key: " + entry.getKey() + ") in: "
                                                                    + cls.getName()
                                                                    + "; it is an unmodifiable collection." );
                                                            }
                                                            continue;
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    if ( value.getClass().isArray() )
                                                    {
                                                        evaluateArray( value );
                                                    }
                                                    else
                                                    {
                                                        interpolationTargets.add( value );
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    Object value = fields[i].get( target );
                                    if ( value != null )
                                    {
                                        if ( fields[i].getType().isArray() )
                                        {
                                            evaluateArray( value );
                                        }
                                        else
                                        {
                                            interpolationTargets.add( value );
                                        }
                                    }
                                }
                            }
                            catch ( IllegalArgumentException e )
                            {
                                throw new ModelInterpolationException( "Failed to interpolate field: " + fields[i]
                                    + " on class: " + cls.getName(), e );
                            }
                            catch ( IllegalAccessException e )
                            {
                                throw new ModelInterpolationException( "Failed to interpolate field: " + fields[i]
                                    + " on class: " + cls.getName(), e );
                            }
                        }
                        finally
                        {
                            fields[i].setAccessible( isAccessible );
                        }
                    }
                }

                traverseObjectWithParents( cls.getSuperclass(), target );
            }
        }
899#private boolean isQualifiedForInterpolation( Class<?> cls )
        {
            return !cls.getPackage().getName().startsWith( "java" );
        }
900#private boolean isQualifiedForInterpolation( Field field, Class<?> fieldType )
        {
            if ( !fieldIsPrimitiveByClass.containsKey( fieldType ) )
            {
                fieldIsPrimitiveByClass.put( fieldType, Boolean.valueOf( fieldType.isPrimitive() ) );
            }

            if ( fieldIsPrimitiveByClass.get( fieldType ).booleanValue() )
            {
                return false;
            }

//            if ( fieldType.isPrimitive() )
//            {
//                return false;
//            }

            if ( "parent".equals( field.getName() ) )
            {
                return false;
            }

            return true;
        }
901#private void evaluateArray( Object target )
            throws ModelInterpolationException
        {
            int len = Array.getLength( target );
            for ( int i = 0; i < len; i++ )
            {
                Object value = Array.get( target, i );
                if ( value != null )
                {
                    if ( String.class == value.getClass() )
                    {
                        String interpolated =
                            modelInterpolator.interpolateInternal( (String) value, valueSources, postProcessors,
                                                                   debugEnabled );

                        if ( !interpolated.equals( value ) )
                        {
                            Array.set( target, i, interpolated );
                        }
                    }
                    else
                    {
                        interpolationTargets.add( value );
                    }
                }
            }
        }
902#public RegexBasedModelInterpolator()
        throws IOException
    {
    }
903#public RegexBasedModelInterpolator( PathTranslator pathTranslator )
    {
        super( pathTranslator );
    }
904#public RegexBasedModelInterpolator( Properties envars )
    {
    }
905#protected Interpolator createInterpolator()
    {
        return new RegexBasedInterpolator( true );
    }
906#/**
     * @deprecated Use {@link ModelInterpolator#interpolate(Model, File, ProjectBuilderConfiguration, boolean)} instead.
     */
    Model interpolate( Model project, Map<String, ?> context )
        throws ModelInterpolationException;
907#/**
     * @deprecated Use {@link ModelInterpolator#interpolate(Model, File, ProjectBuilderConfiguration, boolean)} instead.
     */
    Model interpolate( Model model, Map<String, ?> context, boolean strict )
        throws ModelInterpolationException;
908#Model interpolate( Model model,
                       File projectDir,
                       ProjectBuilderConfiguration config,
                       boolean debugEnabled )
        throws ModelInterpolationException;
909#String interpolate( String src,
                        Model model,
                        File projectDir,
                        ProjectBuilderConfiguration config,
                        boolean debugEnabled )
        throws ModelInterpolationException;
910#public ModelInterpolationException( String message )
    {
        super( message );
    }
911#public ModelInterpolationException( String message, Throwable cause )
    {
        super( message, cause );
    }
912#public ModelInterpolationException( String expression, String message, Throwable cause )
    {
        super( "The POM expression: " + expression + " could not be evaluated. Reason: " + message, cause );

        this.expression = expression;
        this.originalMessage = message;
    }
913#public ModelInterpolationException( String expression, String message )
    {
        super( "The POM expression: " + expression + " could not be evaluated. Reason: " + message );

        this.expression = expression;
        this.originalMessage = message;
    }
914#public String getExpression()
    {
        return expression;
    }
915#public String getOriginalMessage()
    {
        return originalMessage;
    }
916#public void alignToBaseDirectory( Model model, File basedir )
    {
        if ( basedir == null )
        {
            return;
        }

        Build build = model.getBuild();

        if ( build != null )
        {
            build.setDirectory( alignToBaseDirectory( build.getDirectory(), basedir ) );

            build.setSourceDirectory( alignToBaseDirectory( build.getSourceDirectory(), basedir ) );

            build.setTestSourceDirectory( alignToBaseDirectory( build.getTestSourceDirectory(), basedir ) );

            for ( Resource resource : build.getResources() )
            {
                resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) );
            }

            for ( Resource resource : build.getTestResources() )
            {
                resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) );
            }

            if ( build.getFilters() != null )
            {
                List<String> filters = new ArrayList<String>();
                for ( String filter : build.getFilters() )
                {
                    filters.add( alignToBaseDirectory( filter, basedir ) );
                }
                build.setFilters( filters );
            }

            build.setOutputDirectory( alignToBaseDirectory( build.getOutputDirectory(), basedir ) );

            build.setTestOutputDirectory( alignToBaseDirectory( build.getTestOutputDirectory(), basedir ) );
        }

        Reporting reporting = model.getReporting();

        if ( reporting != null )
        {
            reporting.setOutputDirectory( alignToBaseDirectory( reporting.getOutputDirectory(), basedir ) );
        }
    }
917#public String alignToBaseDirectory( String path, File basedir )
    {
        if ( basedir == null )
        {
            return path;
        }

        if ( path == null )
        {
            return null;
        }

        String s = stripBasedirToken( path );

        File file = new File( s );
        if ( file.isAbsolute() )
        {
            // path was already absolute, just normalize file separator and we're done
            s = file.getPath();
        }
        else if ( file.getPath().startsWith( File.separator ) )
        {
            // drive-relative Windows path, don't align with project directory but with drive root
            s = file.getAbsolutePath();
        }
        else
        {
            // an ordinary relative path, align with project directory
            s = new File( new File( basedir, s ).toURI().normalize() ).getAbsolutePath();
        }

        return s;
    }
918#private String stripBasedirToken( String s )
    {
        if ( s != null )
        {
            String basedirExpr = null;
            for ( int i = 0; i < BASEDIR_EXPRESSIONS.length; i++ )
            {
                basedirExpr = BASEDIR_EXPRESSIONS[i];
                if ( s.startsWith( basedirExpr ) )
                {
                    break;
                }
                else
                {
                    basedirExpr = null;
                }
            }

            if ( basedirExpr != null )
            {
                if ( s.length() > basedirExpr.length() )
                {
                    // Take out basedir expression and the leading slash
                    s = chopLeadingFileSeparator( s.substring( basedirExpr.length() ) );
                }
                else
                {
                    s = ".";
                }
            }
        }

        return s;
    }
919#/**
     * Removes the leading directory separator from the specified filesystem path (if any). For platform-independent
     * behavior, this method accepts both the forward slash and the backward slash as separator.
     *
     * @param path The filesystem path, may be <code>null</code>.
     * @return The altered filesystem path or <code>null</code> if the input path was <code>null</code>.
     */
    private String chopLeadingFileSeparator( String path )
    {
        if ( path != null )
        {
            if ( path.startsWith( "/" ) || path.startsWith( "\\" ) )
            {
                path = path.substring( 1 );
            }
        }
        return path;
    }
920#public void unalignFromBaseDirectory( Model model, File basedir )
    {
        if ( basedir == null )
        {
            return;
        }

        Build build = model.getBuild();

        if ( build != null )
        {
            build.setDirectory( unalignFromBaseDirectory( build.getDirectory(), basedir ) );

            build.setSourceDirectory( unalignFromBaseDirectory( build.getSourceDirectory(), basedir ) );

            build.setTestSourceDirectory( unalignFromBaseDirectory( build.getTestSourceDirectory(), basedir ) );

            for ( Resource resource : build.getResources() )
            {
                resource.setDirectory( unalignFromBaseDirectory( resource.getDirectory(), basedir ) );
            }

            for ( Resource resource : build.getTestResources() )
            {
                resource.setDirectory( unalignFromBaseDirectory( resource.getDirectory(), basedir ) );
            }

            if ( build.getFilters() != null )
            {
                List<String> filters = new ArrayList<String>();
                for ( String filter : build.getFilters() )
                {
                    filters.add( unalignFromBaseDirectory( filter, basedir ) );
                }
                build.setFilters( filters );
            }

            build.setOutputDirectory( unalignFromBaseDirectory( build.getOutputDirectory(), basedir ) );

            build.setTestOutputDirectory( unalignFromBaseDirectory( build.getTestOutputDirectory(), basedir ) );
        }

        Reporting reporting = model.getReporting();

        if ( reporting != null )
        {
            reporting.setOutputDirectory( unalignFromBaseDirectory( reporting.getOutputDirectory(), basedir ) );
        }
    }
921#public String unalignFromBaseDirectory( String path, File basedir )
    {
        if ( basedir == null )
        {
            return path;
        }

        if ( path == null )
        {
            return null;
        }

        path = path.trim();

        String base = basedir.getAbsolutePath();
        if ( path.startsWith( base ) )
        {
            path = chopLeadingFileSeparator( path.substring( base.length() ) );
        }

        if ( path.length() <= 0 )
        {
            path = ".";
        }

        if ( !new File( path ).isAbsolute() )
        {
            path = path.replace( '\\', '/' );
        }

        return path;
    }
922#public ModelValidationResult validate( Model model )
    {
        ModelValidationResult result = new ModelValidationResult();

        ModelBuildingRequest request =
            new DefaultModelBuildingRequest().setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 );

        SimpleModelProblemCollector problems = new SimpleModelProblemCollector( result );

        modelValidator.validateEffectiveModel( model, request, problems );

        return result;
    }
923#public SimpleModelProblemCollector( ModelValidationResult result )
        {
            this.result = result;
        }
924#public void add( Severity severity, String message, InputLocation location, Exception cause )
        {
            if ( !ModelProblem.Severity.WARNING.equals( severity ) )
            {
                result.addMessage( message );
            }
        }
925#ModelValidationResult validate( Model model );
926#public ModelValidationResult()
    {
        messages = new ArrayList<String>();
    }
927#public int getMessageCount()
    {
        return messages.size();
    }
928#public String getMessage( int i )
    {
        return messages.get( i );
    }
929#public List<String> getMessages()
    {
        return Collections.unmodifiableList( messages );
    }
930#public void addMessage( String message )
    {
        messages.add( message );
    }
931#public String toString()
    {
        return render( "" );
    }
932#public String render( String indentation )
    {
        if ( messages.size() == 0 )
        {
            return indentation + "There were no validation errors.";
        }

        StringBuilder message = new StringBuilder();

//        if ( messages.size() == 1 )
//        {
//            message.append( "There was 1 validation error: " );
//        }
//        else
//        {
//            message.append( "There was " + messages.size() + " validation errors: " + NEWLINE );
//        }
//
        for ( int i = 0; i < messages.size(); i++ )
        {
            message.append( indentation + "[" + i + "]  " + messages.get( i ).toString() + NEWLINE );
        }

        return message.toString();
    }
933#public MavenReportException( String msg )
    {
        super( msg );
    }
934#public MavenReportException( String msg, Exception e )
    {
        super( msg, e );
    }
935#public Mirror getMirror( ArtifactRepository repository, List<Mirror> mirrors )
    {
        String repoId = repository.getId();

        if ( repoId != null && mirrors != null )
        {
            for ( Mirror mirror : mirrors )
            {
                if ( repoId.equals( mirror.getMirrorOf() ) && matchesLayout( repository, mirror ) )
                {
                    return mirror;
                }
            }

            for ( Mirror mirror : mirrors )
            {
                if ( matchPattern( repository, mirror.getMirrorOf() ) && matchesLayout( repository, mirror ) )
                {
                    return mirror;
                }
            }
        }

        return null;
    }
936#/**
     * This method checks if the pattern matches the originalRepository. Valid patterns: * =
     * everything external:* = everything not on the localhost and not file based. repo,repo1 = repo
     * or repo1 *,!repo1 = everything except repo1
     *
     * @param originalRepository to compare for a match.
     * @param pattern used for match. Currently only '*' is supported.
     * @return true if the repository is a match to this pattern.
     */
    static boolean matchPattern( ArtifactRepository originalRepository, String pattern )
    {
        boolean result = false;
        String originalId = originalRepository.getId();

        // simple checks first to short circuit processing below.
        if ( WILDCARD.equals( pattern ) || pattern.equals( originalId ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] repos = pattern.split( "," );
            for ( String repo : repos )
            {
                // see if this is a negative match
                if ( repo.length() > 1 && repo.startsWith( "!" ) )
                {
                    if ( repo.substring( 1 ).equals( originalId ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( repo.equals( originalId ) )
                {
                    result = true;
                    break;
                }
                // check for external:*
                else if ( EXTERNAL_WILDCARD.equals( repo ) && isExternalRepo( originalRepository ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
                else if ( WILDCARD.equals( repo ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }
        return result;
    }
937#/**
     * Checks the URL to see if this repository refers to an external repository
     *
     * @param originalRepository
     * @return true if external.
     */
    static boolean isExternalRepo( ArtifactRepository originalRepository )
    {
        try
        {
            URL url = new URL( originalRepository.getUrl() );
            return !( url.getHost().equals( "localhost" ) || url.getHost().equals( "127.0.0.1" )
                            || url.getProtocol().equals( "file" ) );
        }
        catch ( MalformedURLException e )
        {
            // bad url just skip it here. It should have been validated already, but the wagon lookup will deal with it
            return false;
        }
    }
938#static boolean matchesLayout( ArtifactRepository repository, Mirror mirror )
    {
        return matchesLayout( RepositoryUtils.getLayout( repository ), mirror.getMirrorOfLayouts() );
    }
939#/**
     * Checks whether the layouts configured for a mirror match with the layout of the repository.
     *
     * @param repoLayout The layout of the repository, may be {@code null}.
     * @param mirrorLayout The layouts supported by the mirror, may be {@code null}.
     * @return {@code true} if the layouts associated with the mirror match the layout of the original repository,
     *         {@code false} otherwise.
     */
    static boolean matchesLayout( String repoLayout, String mirrorLayout )
    {
        boolean result = false;

        // simple checks first to short circuit processing below.
        if ( StringUtils.isEmpty( mirrorLayout ) || WILDCARD.equals( mirrorLayout ) )
        {
            result = true;
        }
        else if ( mirrorLayout.equals( repoLayout ) )
        {
            result = true;
        }
        else
        {
            // process the list
            String[] layouts = mirrorLayout.split( "," );
            for ( String layout : layouts )
            {
                // see if this is a negative match
                if ( layout.length() > 1 && layout.startsWith( "!" ) )
                {
                    if ( layout.substring( 1 ).equals( repoLayout ) )
                    {
                        // explicitly exclude. Set result and stop processing.
                        result = false;
                        break;
                    }
                }
                // check for exact match
                else if ( layout.equals( repoLayout ) )
                {
                    result = true;
                    break;
                }
                else if ( WILDCARD.equals( layout ) )
                {
                    result = true;
                    // don't stop processing in case a future segment explicitly excludes this repo
                }
            }
        }

        return result;
    }
940#public Artifact getOriginatingArtifact()
    {
        return originatingArtifact;
    }
941#public MetadataResolutionResult ListOriginatingArtifact( final Artifact originatingArtifact )
    {
        this.originatingArtifact = originatingArtifact;

        return this;
    }
942#public void addArtifact( Artifact artifact )
    {
        if ( artifacts == null )
        {
            artifacts = new LinkedHashSet<Artifact>();
        }

        artifacts.add( artifact );
    }
943#public Set<Artifact> getArtifacts()
    {
        return artifacts;
    }
944#public void addRequestedArtifact( Artifact artifact )
    {
        if ( requestedArtifacts == null )
        {
            requestedArtifacts = new LinkedHashSet<Artifact>();
        }

        requestedArtifacts.add( artifact );
    }
945#public Set<Artifact> getRequestedArtifacts()
    {
        return requestedArtifacts;
    }
946#public boolean hasMissingArtifacts()
    {
        return missingArtifacts != null && !missingArtifacts.isEmpty();
    }
947#public List<Artifact> getMissingArtifacts()
    {
        return missingArtifacts == null ? Collections.<Artifact> emptyList() : missingArtifacts;
    }
948#public MetadataResolutionResult addMissingArtifact( Artifact artifact )
    {
        missingArtifacts = initList( missingArtifacts );

        missingArtifacts.add( artifact );

        return this;
    }
949#public MetadataResolutionResult setUnresolvedArtifacts( final List<Artifact> unresolvedArtifacts )
    {
        this.missingArtifacts = unresolvedArtifacts;

        return this;
    }
950#// ------------------------------------------------------------------------
    // Exceptions
    // ------------------------------------------------------------------------

    public boolean hasExceptions()
    {
        return exceptions != null && !exceptions.isEmpty();
    }
951#public List<Exception> getExceptions()
    {
        return exceptions == null ? Collections.<Exception> emptyList() : exceptions;
    }
952#// ------------------------------------------------------------------------
    // Version Range Violations
    // ------------------------------------------------------------------------

    public boolean hasVersionRangeViolations()
    {
        return versionRangeViolations != null;
    }
953#/**
     * @TODO this needs to accept a {@link OverConstrainedVersionException} as returned by
     *       {@link #getVersionRangeViolation(int)} but it's not used like that in
     *       {@link DefaultLegacyArtifactCollector}
     */
    public MetadataResolutionResult addVersionRangeViolation( Exception e )
    {
        versionRangeViolations = initList( versionRangeViolations );

        versionRangeViolations.add( e );

        exceptions = initList( exceptions );

        exceptions.add( e );

        return this;
    }
954#public OverConstrainedVersionException getVersionRangeViolation( int i )
    {
        return (OverConstrainedVersionException) versionRangeViolations.get( i );
    }
955#public List<Exception> getVersionRangeViolations()
    {
        return versionRangeViolations == null ? Collections.<Exception> emptyList() : versionRangeViolations;
    }
956#// ------------------------------------------------------------------------
    // Metadata Resolution Exceptions: ArtifactResolutionExceptions
    // ------------------------------------------------------------------------

    public boolean hasMetadataResolutionExceptions()
    {
        return metadataResolutionExceptions != null;
    }
957#public MetadataResolutionResult addMetadataResolutionException( ArtifactResolutionException e )
    {
        metadataResolutionExceptions = initList( metadataResolutionExceptions );

        metadataResolutionExceptions.add( e );

        exceptions = initList( exceptions );

        exceptions.add( e );

        return this;
    }
958#public ArtifactResolutionException getMetadataResolutionException( int i )
    {
        return metadataResolutionExceptions.get( i );
    }
959#public List<ArtifactResolutionException> getMetadataResolutionExceptions()
    {
        return metadataResolutionExceptions == null ? Collections.<ArtifactResolutionException> emptyList()
                        : metadataResolutionExceptions;
    }
960#// ------------------------------------------------------------------------
    // ErrorArtifactExceptions: ArtifactResolutionExceptions
    // ------------------------------------------------------------------------

    public boolean hasErrorArtifactExceptions()
    {
        return errorArtifactExceptions != null;
    }
961#public MetadataResolutionResult addError( Exception e )
    {
        if ( exceptions == null )
        {
            initList( exceptions );
        }

        exceptions.add( e );

        return this;
    }
962#public List<ArtifactResolutionException> getErrorArtifactExceptions()
    {
        if ( errorArtifactExceptions == null )
        {
            return Collections.emptyList();
        }

        return errorArtifactExceptions;
    }
963#// ------------------------------------------------------------------------
    // Circular Dependency Exceptions
    // ------------------------------------------------------------------------

    public boolean hasCircularDependencyExceptions()
    {
        return circularDependencyExceptions != null;
    }
964#public MetadataResolutionResult addCircularDependencyException( CyclicDependencyException e )
    {
        circularDependencyExceptions = initList( circularDependencyExceptions );

        circularDependencyExceptions.add( e );

        exceptions = initList( exceptions );

        exceptions.add( e );

        return this;
    }
965#public CyclicDependencyException getCircularDependencyException( int i )
    {
        return circularDependencyExceptions.get( i );
    }
966#public List<CyclicDependencyException> getCircularDependencyExceptions()
    {
        if ( circularDependencyExceptions == null )
        {
            return Collections.emptyList();
        }

        return circularDependencyExceptions;
    }
967#// ------------------------------------------------------------------------
    // Repositories
    // ------------------------------------------------------------------------

    public List<ArtifactRepository> getRepositories()
    {
        if ( repositories == null )
        {
            return Collections.emptyList();
        }

        return repositories;
    }
968#public MetadataResolutionResult setRepositories( final List<ArtifactRepository> repositories )
    {
        this.repositories = repositories;

        return this;
    }
969#//
    // Internal
    //

    private <T> List<T> initList( final List<T> l )
    {
        if ( l == null )
        {
            return new ArrayList<T>();
        }
        return l;
    }
970#public String toString()
    {
        StringBuilder sb = new StringBuilder();

        if ( artifacts != null )
        {
            int i = 1;
            sb.append( "---------" ).append( "\n" );
            sb.append( artifacts.size() ).append( "\n" );
            for ( Artifact a : artifacts )
            {
                sb.append( i ).append( " " ).append( a ).append( "\n" );
                i++;
            }
            sb.append( "---------" ).append( "\n" );
        }

        return sb.toString();
    }
971#public MetadataGraph getResolvedTree()
    {
        return resolvedTree;
    }
972#public void setResolvedTree( MetadataGraph resolvedTree )
    {
        this.resolvedTree = resolvedTree;
    }
973#public MetadataGraphNode()
    {
        inNodes = new ArrayList<MetadataGraphNode>(4);
        exNodes = new ArrayList<MetadataGraphNode>(8);
    }
974#public MetadataGraphNode( MavenArtifactMetadata metadata )
    {
        this();
        this.metadata = metadata;
    }
975#public MetadataGraphNode addIncident( MetadataGraphNode node )
    {
        inNodes.add( node );
        return this;
    }
976#public MetadataGraphNode addExident( MetadataGraphNode node )
    {
        exNodes.add( node );
        return this;
    }
977#@Override
    public boolean equals( Object obj )
    {
        if ( obj == null )
        {
            return false;
        }

        if ( MetadataGraphNode.class.isAssignableFrom( obj.getClass() ) )
        {
            MetadataGraphNode node2 = (MetadataGraphNode) obj;

            if ( node2.metadata == null )
            {
                return metadata == null;
            }

            return metadata == null ? false : metadata.toString().equals( node2.metadata.toString() );
        }
        else
        {
            return super.equals( obj );
        }
    }
978#@Override
    public int hashCode()
    {
        if ( metadata == null )
        {
            return super.hashCode();
        }

        return metadata.toString().hashCode();
    }
979#public String getGroupId()
    {
        return groupId;
    }
980#public void setGroupId( String groupId )
    {
        this.groupId = groupId;
    }
981#public String getArtifactId()
    {
        return artifactId;
    }
982#public void setArtifactId( String artifactId )
    {
        this.artifactId = artifactId;
    }
983#public String getVersion()
    {
        return version;
    }
984#public void setVersion( String version )
    {
        this.version = version;
    }
985#public String getClassifier()
    {
        return classifier;
    }
986#public void setClassifier( String classifier )
    {
        this.classifier = classifier;
    }
987#public String getType()
    {
        return type;
    }
988#public void setType( String type )
    {
        this.type = type;
    }
989#public Object getDatum()
    {
        return datum;
    }
990#public void setDatum( Object datum )
    {
        this.datum = datum;
    }
991#public String getScope()
    {
        return scope;
    }
992#public void setScope( String scope )
    {
        this.scope = scope;
    }
993#@Override
    public String toString()
    {
        return getGroupId() + ":" + getArtifactId() + ":" + getVersion() + ":"
            + ( getClassifier() == null ? "" : getClassifier() ) + ":"
            + ( getType() == null ? DEFAULT_TYPE : getType() );
    }
994#public MetadataResolutionRequest()
    {
    }
995#public MetadataResolutionRequest( MavenArtifactMetadata md, ArtifactRepository localRepository,
                                      List<ArtifactRepository> remoteRepositories )
    {
        this.mad = md;
        this.localRepository = localRepository;
        this.remoteRepositories = remoteRepositories;
    }
996#public MavenArtifactMetadata getArtifactMetadata()
    {
        return mad;
    }
997#public MetadataResolutionRequest setArtifactMetadata( MavenArtifactMetadata md )
    {
        this.mad = md;

        return this;
    }
998#public MetadataResolutionRequest setArtifactDependencies( Set<Artifact> artifactDependencies )
    {
        this.artifactDependencies = artifactDependencies;

        return this;
    }
999#public Set<Artifact> getArtifactDependencies()
    {
        return artifactDependencies;
    }
1000#public ArtifactRepository getLocalRepository()
    {
        return localRepository;
    }
1001#public MetadataResolutionRequest setLocalRepository( ArtifactRepository localRepository )
    {
        this.localRepository = localRepository;

        return this;
    }
1002#public List<ArtifactRepository> getRemoteRepostories()
    {
        return remoteRepositories;
    }
1003#public MetadataResolutionRequest setRemoteRepostories( List<ArtifactRepository> remoteRepostories )
    {
        this.remoteRepositories = remoteRepostories;

        return this;
    }
1004#public Map getManagedVersionMap()
    {
        return managedVersionMap;
    }
1005#public MetadataResolutionRequest setManagedVersionMap( Map managedVersionMap )
    {
        this.managedVersionMap = managedVersionMap;

        return this;
    }
1006#public String toString()
    {
        StringBuilder sb = new StringBuilder()
                .append( "REQUEST: " ).append(  "\n" )
                .append( "artifact: " ).append( mad ).append(  "\n" )
                .append( artifactDependencies ).append(  "\n" )
                .append( "localRepository: " ).append(  localRepository ).append(  "\n" )
                .append( "remoteRepositories: " ).append(  remoteRepositories ).append(  "\n" )
                ;

        return sb.toString();
    }
1007#public boolean isAsList()
    {
        return asList;
    }
1008#public MetadataResolutionRequest setAsList( boolean asList )
    {
        this.asList = asList;
        return this;
    }
1009#public boolean isAsDirtyTree()
    {
        return asDirtyTree;
    }
1010#public MetadataResolutionRequest setAsDirtyTree( boolean asDirtyTree )
    {
        this.asDirtyTree = asDirtyTree;
        return this;
    }
1011#public boolean isAsResolvedTree()
    {
        return asResolvedTree;
    }
1012#public MetadataResolutionRequest setAsResolvedTree( boolean asResolvedTree )
    {
        this.asResolvedTree = asResolvedTree;
        return this;
    }
1013#public boolean isAsGraph()
    {
        return asGraph;
    }
1014#public MetadataResolutionRequest setAsGraph( boolean asGraph )
    {
        this.asGraph = asGraph;
        return this;
    }
1015#public MetadataResolutionRequest setScope( String scope )
    {
        this.scope = scope;
        return this;
    }
1016#public String getScope()
    {
        return scope;
    }
1017#public VersionNotFoundException( String projectId, Dependency dependency, File pomFile,
                                     InvalidVersionSpecificationException cause )
    {
        super( projectId + ", " + formatLocationInPom( dependency ) + " " + dependency.getVersion() + ", pom file "
            + pomFile, cause );

        this.projectId = projectId;

        this.pomFile = pomFile;

        this.cause = cause;

        this.dependency = dependency;
    }
1018#private static String formatLocationInPom( Dependency dependency )
    {
        return "Dependency: " + ArtifactUtils.versionlessKey( dependency.getGroupId(), dependency.getArtifactId() );
    }
1019#public Dependency getDependency()
    {
        return dependency;
    }
1020#public String getProjectId()
    {
        return projectId;
    }
1021#public File getPomFile()
    {
        return pomFile;
    }
1022#public InvalidVersionSpecificationException getCauseException()
    {
        return cause;
    }
1023#/**
     * Determines the mirror for the specified repository.
     * 
     * @param repository The repository to determine the mirror for, must not be {@code null}.
     * @param mirrors The available mirrors, may be {@code null}.
     * @return The mirror specification for the repository or {@code null} if no mirror matched.
     */
    Mirror getMirror( ArtifactRepository repository, List<Mirror> mirrors );
1024#public MetadataGraph( MetadataGraphNode entry )
    {
        this();

        this.entry = entry;
    }
1025#public MetadataGraph()
    {
        nodes = new ArrayList<MetadataGraphNode>( 64 );
    }
1026#public void addNode( MetadataGraphNode node )
    {
        nodes.add( node );
    }
1027#/**
     * find a node by the GAV (metadata)
     *
     * @param md
     * @return
     */
    public MetadataGraphNode findNode( MavenArtifactMetadata md )
    {
        for ( MetadataGraphNode mgn : nodes )
        {
            if ( mgn.metadata.equals( md ) )
            {
                return mgn;
            }
        }

        MetadataGraphNode node = new MetadataGraphNode( md );
        addNode( node );
        return node;
    }
1028#/**
     * getter
     *
     * @return
     */
    public MetadataGraphNode getEntry()
    {
        return entry;
    }
1029#/**
     * getter
     *
     * @return
     */
    public Collection<MetadataGraphNode> getNodes()
    {
        return nodes;
    }
1030#public UserLocalArtifactRepository( ArtifactRepository localRepository )
    {
        this.localRepository = localRepository;
        setLayout( localRepository.getLayout() );
    }
1031#@Override
    public Artifact find( Artifact artifact )
    {
        File artifactFile = new File( localRepository.getBasedir(), pathOf( artifact ) );
        
        // We need to set the file here or the resolver will fail with an NPE, not fully equipped to deal
        // with multiple local repository implementations yet.
        artifact.setFile( artifactFile );

        return artifact;
    }
1032#@Override
    public String getId()
    {
        return localRepository.getId();
    }
1033#@Override
    public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository )
    {
        return localRepository.pathOfLocalRepositoryMetadata( metadata, repository );
    }
1034#@Override
    public String pathOf( Artifact artifact )
    {
        return localRepository.pathOf( artifact );
    }
1035#@Override
    public boolean hasLocalMetadata()
    {
        return true;
    }
1036#public WagonConfigurationException( String repositoryId,
                                        String message,
                                        Throwable cause )
    {
        super( "While configuring wagon for \'" + repositoryId + "\': " + message, cause );

        this.repositoryId = repositoryId;
        this.originalMessage = message;
    }
1037#public WagonConfigurationException( String repositoryId,
                                        String message )
    {
        super( "While configuring wagon for \'" + repositoryId + "\': " + message );

        this.repositoryId = repositoryId;
        this.originalMessage = message;
    }
1038#public final String getRepositoryId()
    {
        return repositoryId;
    }
1039#public final String getOriginalMessage()
    {
        return originalMessage;
    }
1040#public static TransferListener newAdapter( ArtifactTransferListener listener )
    {
        if ( listener == null )
        {
            return null;
        }
        else
        {
            return new TransferListenerAdapter( listener );
        }
    }
1041#private TransferListenerAdapter( ArtifactTransferListener listener )
    {
        this.listener = listener;
        this.artifacts = new IdentityHashMap<Resource, ArtifactTransferResource>();
        this.transfers = new IdentityHashMap<Resource, Long>();
    }
1042#public void debug( String message )
    {
    }
1043#public void transferCompleted( TransferEvent transferEvent )
    {
        ArtifactTransferEvent event = wrap( transferEvent );

        Long transferred = null;
        synchronized ( transfers )
        {
            transferred = transfers.remove( transferEvent.getResource() );
        }
        if ( transferred != null )
        {
            event.setTransferredBytes( transferred.longValue() );
        }

        synchronized ( artifacts )
        {
            artifacts.remove( transferEvent.getResource() );
        }

        listener.transferCompleted( event );
    }
1044#public void transferError( TransferEvent transferEvent )
    {
        synchronized ( transfers )
        {
            transfers.remove( transferEvent.getResource() );
        }
        synchronized ( artifacts )
        {
            artifacts.remove( transferEvent.getResource() );
        }
    }
1045#public void transferInitiated( TransferEvent transferEvent )
    {
        listener.transferInitiated( wrap( transferEvent ) );
    }
1046#public void transferProgress( TransferEvent transferEvent, byte[] buffer, int length )
    {
        Long transferred;
        synchronized ( transfers )
        {
            transferred = transfers.get( transferEvent.getResource() );
            if ( transferred == null )
            {
                transferred = Long.valueOf( length );
            }
            else
            {
                transferred = Long.valueOf( transferred.longValue() + length );
            }
            transfers.put( transferEvent.getResource(), transferred );
        }

        ArtifactTransferEvent event = wrap( transferEvent );
        event.setDataBuffer( buffer );
        event.setDataOffset( 0 );
        event.setDataLength( length );
        event.setTransferredBytes( transferred.longValue() );

        listener.transferProgress( event );
    }
1047#public void transferStarted( TransferEvent transferEvent )
    {
        listener.transferStarted( wrap( transferEvent ) );
    }
1048#private ArtifactTransferEvent wrap( TransferEvent event )
    {
        if ( event == null )
        {
            return null;
        }
        else
        {
            String wagon = event.getWagon().getClass().getName();

            ArtifactTransferResource artifact = wrap( event.getWagon().getRepository(), event.getResource() );

            ArtifactTransferEvent evt;
            if ( event.getException() != null )
            {
                evt = new ArtifactTransferEvent( wagon, event.getException(), event.getRequestType(), artifact );
            }
            else
            {
                evt = new ArtifactTransferEvent( wagon, event.getEventType(), event.getRequestType(), artifact );
            }

            evt.setLocalFile( event.getLocalFile() );

            return evt;
        }
    }
1049#private ArtifactTransferResource wrap( Repository repository, Resource resource )
    {
        if ( resource == null )
        {
            return null;
        }
        else
        {
            synchronized ( artifacts )
            {
                ArtifactTransferResource artifact = artifacts.get( resource );

                if ( artifact == null )
                {
                    artifact = new MavenArtifact( repository.getUrl(), resource );
                    artifacts.put( resource, artifact );
                }

                return artifact;
            }
        }
    }
1050#public DefaultUpdateCheckManager()
    {

    }
1051#public DefaultUpdateCheckManager( Logger logger )
    {
        enableLogging( logger );
    }
1052#public boolean isUpdateRequired( Artifact artifact, ArtifactRepository repository )
    {
        File file = artifact.getFile();

        ArtifactRepositoryPolicy policy = artifact.isSnapshot() ? repository.getSnapshots() : repository.getReleases();

        if ( !policy.isEnabled() )
        {
            if ( getLogger().isDebugEnabled() )
            {
                getLogger().debug(
                                   "Skipping update check for " + artifact + " (" + file + ") from "
                                       + repository.getId() + " (" + repository.getUrl() + ")" );
            }

            return false;
        }

        if ( getLogger().isDebugEnabled() )
        {
            getLogger().debug(
                               "Determining update check for " + artifact + " (" + file + ") from "
                                   + repository.getId() + " (" + repository.getUrl() + ")" );
        }

        if ( file == null )
        {
            // TODO throw something instead?
            return true;
        }

        Date lastCheckDate;

        if ( file.exists() )
        {
            lastCheckDate = new Date ( file.lastModified() );
        }
        else
        {
            File touchfile = getTouchfile( artifact );
            lastCheckDate = readLastUpdated( touchfile, getRepositoryKey( repository ) );
        }

        return ( lastCheckDate == null ) || policy.checkOutOfDate( lastCheckDate );
    }
1053#public boolean isUpdateRequired( RepositoryMetadata metadata, ArtifactRepository repository, File file )
    {
        // Here, we need to determine which policy to use. Release updateInterval will be used when
        // the metadata refers to a release artifact or meta-version, and snapshot updateInterval will be used when
        // it refers to a snapshot artifact or meta-version.
        // NOTE: Release metadata includes version information about artifacts that have been released, to allow
        // meta-versions like RELEASE and LATEST to resolve, and also to allow retrieval of the range of valid, released
        // artifacts available.
        ArtifactRepositoryPolicy policy = metadata.getPolicy( repository );

        if ( !policy.isEnabled() )
        {
            if ( getLogger().isDebugEnabled() )
            {
                getLogger().debug(
                                   "Skipping update check for " + metadata.getKey() + " (" + file + ") from "
                                       + repository.getId() + " (" + repository.getUrl() + ")" );
            }

            return false;
        }

        if ( getLogger().isDebugEnabled() )
        {
            getLogger().debug(
                               "Determining update check for " + metadata.getKey() + " (" + file + ") from "
                                   + repository.getId() + " (" + repository.getUrl() + ")" );
        }

        if ( file == null )
        {
            // TODO throw something instead?
            return true;
        }

        Date lastCheckDate = readLastUpdated( metadata, repository, file );

        return ( lastCheckDate == null ) || policy.checkOutOfDate( lastCheckDate );
    }
1054#private Date readLastUpdated( RepositoryMetadata metadata, ArtifactRepository repository, File file )
    {
        File touchfile = getTouchfile( metadata, file );

        String key = getMetadataKey( repository, file );

        return readLastUpdated( touchfile, key );
    }
1055#public String getError( Artifact artifact, ArtifactRepository repository )
    {
        File touchFile = getTouchfile( artifact );
        return getError( touchFile, getRepositoryKey( repository ) );
    }
1056#public void touch( Artifact artifact, ArtifactRepository repository, String error )
    {
        File file = artifact.getFile();

        File touchfile = getTouchfile( artifact );

        if ( file.exists() )
        {
            touchfile.delete();
        }
        else
        {
            writeLastUpdated( touchfile, getRepositoryKey( repository ), error );
        }
    }
1057#public void touch( RepositoryMetadata metadata, ArtifactRepository repository, File file )
    {
        File touchfile = getTouchfile( metadata, file );

        String key = getMetadataKey( repository, file );

        writeLastUpdated( touchfile, key, null );
    }
1058#String getMetadataKey( ArtifactRepository repository, File file )
    {
        return repository.getId() + '.' + file.getName() + LAST_UPDATE_TAG;
    }
1059#String getRepositoryKey( ArtifactRepository repository )
    {
        StringBuilder buffer = new StringBuilder( 256 );

        Proxy proxy = repository.getProxy();
        if ( proxy != null )
        {
            if ( proxy.getUserName() != null )
            {
                int hash = ( proxy.getUserName() + proxy.getPassword() ).hashCode();
                buffer.append( hash ).append( '@' );
            }
            buffer.append( proxy.getHost() ).append( ':' ).append( proxy.getPort() ).append( '>' );
        }

        // consider the username&password because a repo manager might block artifacts depending on authorization
        Authentication auth = repository.getAuthentication();
        if ( auth != null )
        {
            int hash = ( auth.getUsername() + auth.getPassword() ).hashCode();
            buffer.append( hash ).append( '@' );
        }

        // consider the URL (instead of the id) as this most closely relates to the contents in the repo
        buffer.append( repository.getUrl() );

        return buffer.toString();
    }
1060#private void writeLastUpdated( File touchfile, String key, String error )
    {
        synchronized ( touchfile.getAbsolutePath().intern() )
        {
            if ( !touchfile.getParentFile().exists() && !touchfile.getParentFile().mkdirs() )
            {
                getLogger().debug( "Failed to create directory: " + touchfile.getParent()
                                       + " for tracking artifact metadata resolution." );
                return;
            }

            FileChannel channel = null;
            FileLock lock = null;
            try
            {
                Properties props = new Properties();

                channel = new RandomAccessFile( touchfile, "rw" ).getChannel();
                lock = channel.lock( 0, channel.size(), false );

                if ( touchfile.canRead() )
                {
                    getLogger().debug( "Reading resolution-state from: " + touchfile );
                    ByteBuffer buffer = ByteBuffer.allocate( (int) channel.size() );

                    channel.read( buffer );
                    buffer.flip();

                    ByteArrayInputStream stream = new ByteArrayInputStream( buffer.array() );
                    props.load( stream );
                }

                props.setProperty( key, Long.toString( System.currentTimeMillis() ) );

                if ( error != null )
                {
                    props.setProperty( key + ERROR_KEY_SUFFIX, error );
                }
                else
                {
                    props.remove( key + ERROR_KEY_SUFFIX );
                }

                ByteArrayOutputStream stream = new ByteArrayOutputStream();

                getLogger().debug( "Writing resolution-state to: " + touchfile );
                props.store( stream, "Last modified on: " + new Date() );

                byte[] data = stream.toByteArray();
                ByteBuffer buffer = ByteBuffer.allocate( data.length );
                buffer.put( data );
                buffer.flip();

                channel.position( 0 );
                channel.write( buffer );
            }
            catch ( IOException e )
            {
                getLogger().debug( "Failed to record lastUpdated information for resolution.\nFile: "
                                       + touchfile.toString() + "; key: " + key, e );
            }
            finally
            {
                if ( lock != null )
                {
                    try
                    {
                        lock.release();
                    }
                    catch ( IOException e )
                    {
                        getLogger().debug( "Error releasing exclusive lock for resolution tracking file: "
                                               + touchfile, e );
                    }
                }

                if ( channel != null )
                {
                    try
                    {
                        channel.close();
                    }
                    catch ( IOException e )
                    {
                        getLogger().debug( "Error closing FileChannel for resolution tracking file: "
                                               + touchfile, e );
                    }
                }
            }
        }
    }
1061#Date readLastUpdated( File touchfile, String key )
    {
        getLogger().debug( "Searching for " + key + " in resolution tracking file." );

        Properties props = read( touchfile );
        if ( props != null )
        {
            String rawVal = props.getProperty( key );
            if ( rawVal != null )
            {
                try
                {
                    return new Date( Long.parseLong( rawVal ) );
                }
                catch ( NumberFormatException e )
                {
                    getLogger().debug( "Cannot parse lastUpdated date: \'" + rawVal + "\'. Ignoring.", e );
                }
            }
        }
        return null;
    }
1062#private String getError( File touchFile, String key )
    {
        Properties props = read( touchFile );
        if ( props != null )
        {
            return props.getProperty( key + ERROR_KEY_SUFFIX );
        }
        return null;
    }
1063#private Properties read( File touchfile )
    {
        if ( !touchfile.canRead() )
        {
            getLogger().debug( "Skipped unreadable resolution tracking file " + touchfile );
            return null;
        }

        synchronized ( touchfile.getAbsolutePath().intern() )
        {
            FileInputStream stream = null;
            FileLock lock = null;
            FileChannel channel = null;
            try
            {
                Properties props = new Properties();

                stream = new FileInputStream( touchfile );
                channel = stream.getChannel();
                lock = channel.lock( 0, channel.size(), true );

                getLogger().debug( "Reading resolution-state from: " + touchfile );
                props.load( stream );

                return props;
            }
            catch ( IOException e )
            {
                getLogger().debug( "Failed to read resolution tracking file " + touchfile, e );

                return null;
            }
            finally
            {
                if ( lock != null )
                {
                    try
                    {
                        lock.release();
                    }
                    catch ( IOException e )
                    {
                        getLogger().debug( "Error releasing shared lock for resolution tracking file: " + touchfile,
                                           e );
                    }
                }

                if ( channel != null )
                {
                    try
                    {
                        channel.close();
                    }
                    catch ( IOException e )
                    {
                        getLogger().debug( "Error closing FileChannel for resolution tracking file: " + touchfile, e );
                    }
                }
            }
        }
    }
1064#File getTouchfile( Artifact artifact )
    {
        StringBuilder sb = new StringBuilder( 128 );
        sb.append( artifact.getArtifactId() );
        sb.append( '-' ).append( artifact.getBaseVersion() );
        if ( artifact.getClassifier() != null )
        {
            sb.append( '-' ).append( artifact.getClassifier() );
        }
        sb.append( '.' ).append( artifact.getType() ).append( LAST_UPDATE_TAG );
        return new File( artifact.getFile().getParentFile(), sb.toString() );
    }
1065#File getTouchfile( RepositoryMetadata metadata, File file )
    {
        return new File( file.getParent(), TOUCHFILE_NAME );
    }
1066#@Deprecated
    Wagon getWagon( String protocol )
        throws UnsupportedProtocolException;
1067#@Deprecated
    Wagon getWagon( Repository repository )
        throws UnsupportedProtocolException, WagonConfigurationException;
1068#//
    // Retriever
    //
    void getArtifact( Artifact artifact, ArtifactRepository repository, TransferListener transferListener, boolean force )
        throws TransferFailedException, ResourceDoesNotExistException;
1069#void getArtifact( Artifact artifact, List<ArtifactRepository> remoteRepositories,
                      TransferListener transferListener, boolean force )
        throws TransferFailedException, ResourceDoesNotExistException;
1070#void getRemoteFile( ArtifactRepository repository, File destination, String remotePath,
                        TransferListener downloadMonitor, String checksumPolicy, boolean force )
        throws TransferFailedException, ResourceDoesNotExistException;
1071#void getArtifactMetadata( ArtifactMetadata metadata, ArtifactRepository remoteRepository, File destination,
                              String checksumPolicy )
        throws TransferFailedException, ResourceDoesNotExistException;
1072#void getArtifactMetadataFromDeploymentRepository( ArtifactMetadata metadata, ArtifactRepository remoteRepository,
                                                      File file, String checksumPolicyWarn )
        throws TransferFailedException, ResourceDoesNotExistException;
1073#//
    // Deployer
    //
    void putArtifact( File source, Artifact artifact, ArtifactRepository deploymentRepository,
                      TransferListener downloadMonitor )
        throws TransferFailedException;
1074#void putRemoteFile( ArtifactRepository repository, File source, String remotePath, TransferListener downloadMonitor )
        throws TransferFailedException;
1075#void putArtifactMetadata( File source, ArtifactMetadata artifactMetadata, ArtifactRepository repository )
        throws TransferFailedException;
1076#public ChecksumFailedException( String s )
    {
        super( s );
    }
1077#public ChecksumFailedException( String message,
                                    Throwable cause )
    {
        super( message, cause );
    }
1078#public MavenArtifact( String repositoryUrl, Resource resource )
    {
        if ( repositoryUrl == null )
        {
            this.repositoryUrl = "";
        }
        else if ( !repositoryUrl.endsWith( "/" ) && repositoryUrl.length() > 0 )
        {
            this.repositoryUrl = repositoryUrl + '/';
        }
        else
        {
            this.repositoryUrl = repositoryUrl;
        }
        this.resource = resource;

        this.transferStartTime = System.currentTimeMillis();
    }
1079#public String getRepositoryUrl()
    {
        return repositoryUrl;
    }
1080#public String getName()
    {
        String name = resource.getName();

        if ( name == null )
        {
            name = "";
        }
        else if ( name.startsWith( "/" ) )
        {
            name = name.substring( 1 );
        }

        return name;
    }
1081#public String getUrl()
    {
        return getRepositoryUrl() + getName();
    }
1082#public long getContentLength()
    {
        return resource.getContentLength();
    }
1083#public long getTransferStartTime()
    {
        return transferStartTime;
    }
1084#@Override
    public String toString()
    {
        return getUrl();
    }
1085#public Artifact createArtifact( String groupId, String artifactId, String version, String scope, String type )
    {
        return artifactFactory.createArtifact( groupId, artifactId, version, scope, type );
    }
1086#public Artifact createArtifact( String groupId, String artifactId, String version, String packaging )
    {
        return artifactFactory.createBuildArtifact( groupId, artifactId, version, packaging );
    }
1087#public Artifact createArtifactWithClassifier( String groupId, String artifactId, String version, String type,
                                                  String classifier )
    {
        return artifactFactory.createArtifactWithClassifier( groupId, artifactId, version, type, classifier );
    }
1088#public Artifact createProjectArtifact( String groupId, String artifactId, String metaVersionId )
    {
        return artifactFactory.createProjectArtifact( groupId, artifactId, metaVersionId );
    }
1089#public Artifact createDependencyArtifact( Dependency d )
    {
        VersionRange versionRange;
        try
        {
            versionRange = VersionRange.createFromVersionSpec( d.getVersion() );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            return null;
        }

        Artifact artifact =
            artifactFactory.createDependencyArtifact( d.getGroupId(), d.getArtifactId(), versionRange, d.getType(),
                                                      d.getClassifier(), d.getScope(), d.isOptional() );

        if ( Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && d.getSystemPath() != null )
        {
            artifact.setFile( new File( d.getSystemPath() ) );
        }

        if ( !d.getExclusions().isEmpty() )
        {
            List<String> exclusions = new ArrayList<String>();

            for ( Exclusion exclusion : d.getExclusions() )
            {
                exclusions.add( exclusion.getGroupId() + ':' + exclusion.getArtifactId() );
            }

            artifact.setDependencyFilter( new ExcludesArtifactFilter( exclusions ) );
        }

        return artifact;
    }
1090#public Artifact createExtensionArtifact( String groupId, String artifactId, String version )
    {
        VersionRange versionRange;
        try
        {
            versionRange = VersionRange.createFromVersionSpec( version );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            return null;
        }

        return artifactFactory.createExtensionArtifact( groupId, artifactId, versionRange );
    }
1091#public Artifact createParentArtifact( String groupId, String artifactId, String version )
    {
        return artifactFactory.createParentArtifact( groupId, artifactId, version );
    }
1092#public Artifact createPluginArtifact( Plugin plugin )
    {
        VersionRange versionRange;
        try
        {
            String version = plugin.getVersion();
            if ( StringUtils.isEmpty( version ) )
            {
                version = "RELEASE";
            }
            versionRange = VersionRange.createFromVersionSpec( version );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            return null;
        }

        return artifactFactory.createPluginArtifact( plugin.getGroupId(), plugin.getArtifactId(), versionRange );
    }
1093#public ArtifactRepositoryPolicy buildArtifactRepositoryPolicy( RepositoryPolicy policy )
    {
        boolean enabled = true;

        String updatePolicy = null;

        String checksumPolicy = null;

        if ( policy != null )
        {
            enabled = policy.isEnabled();

            if ( policy.getUpdatePolicy() != null )
            {
                updatePolicy = policy.getUpdatePolicy();
            }
            if ( policy.getChecksumPolicy() != null )
            {
                checksumPolicy = policy.getChecksumPolicy();
            }
        }

        return new ArtifactRepositoryPolicy( enabled, updatePolicy, checksumPolicy );
    }
1094#public ArtifactRepository createDefaultLocalRepository()
        throws InvalidRepositoryException
    {
        return createLocalRepository( RepositorySystem.defaultUserLocalRepository );
    }
1095#public ArtifactRepository createLocalRepository( File localRepository )
        throws InvalidRepositoryException
    {
        return createRepository( "file://" + localRepository.toURI().getRawPath(),
                                 RepositorySystem.DEFAULT_LOCAL_REPO_ID, true,
                                 ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, true,
                                 ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS,
                                 ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE );
    }
1096#public ArtifactRepository createDefaultRemoteRepository()
        throws InvalidRepositoryException
    {
        return createRepository( RepositorySystem.DEFAULT_REMOTE_REPO_URL, RepositorySystem.DEFAULT_REMOTE_REPO_ID,
                                 true, ArtifactRepositoryPolicy.UPDATE_POLICY_DAILY, false,
                                 ArtifactRepositoryPolicy.UPDATE_POLICY_DAILY,
                                 ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN );
    }
1097#public ArtifactRepository createLocalRepository( String url, String repositoryId )
        throws IOException
    {
        return createRepository( canonicalFileUrl( url ), repositoryId, true,
                                 ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, true,
                                 ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS,
                                 ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE );
    }
1098#private String canonicalFileUrl( String url )
        throws IOException
    {
        if ( !url.startsWith( "file:" ) )
        {
            url = "file://" + url;
        }
        else if ( url.startsWith( "file:" ) && !url.startsWith( "file://" ) )
        {
            url = "file://" + url.substring( "file:".length() );
        }

        // So now we have an url of the form file://<path>

        // We want to eliminate any relative path nonsense and lock down the path so we
        // need to fully resolve it before any sub-modules use the path. This can happen
        // when you are using a custom settings.xml that contains a relative path entry
        // for the local repository setting.

        File localRepository = new File( url.substring( "file://".length() ) );

        if ( !localRepository.isAbsolute() )
        {
            url = "file://" + localRepository.getCanonicalPath();
        }

        return url;
    }
1099#public ArtifactResolutionResult resolve( ArtifactResolutionRequest request )
    {
        /*
         * Probably is not worth it, but here I make sure I restore request
         * to its original state.
         */
        try
        {
            LocalArtifactRepository ideWorkspace =
                plexus.lookup( LocalArtifactRepository.class, LocalArtifactRepository.IDE_WORKSPACE );

            if ( request.getLocalRepository() instanceof DelegatingLocalArtifactRepository )
            {
                DelegatingLocalArtifactRepository delegatingLocalRepository =
                    (DelegatingLocalArtifactRepository) request.getLocalRepository();

                LocalArtifactRepository orig = delegatingLocalRepository.getIdeWorspace();

                delegatingLocalRepository.setIdeWorkspace( ideWorkspace );

                try
                {
                    return artifactResolver.resolve( request );
                }
                finally
                {
                    delegatingLocalRepository.setIdeWorkspace( orig );
                }
            }
            else
            {
                ArtifactRepository localRepository = request.getLocalRepository();
                DelegatingLocalArtifactRepository delegatingLocalRepository =
                    new DelegatingLocalArtifactRepository( localRepository );
                delegatingLocalRepository.setIdeWorkspace( ideWorkspace );
                request.setLocalRepository( delegatingLocalRepository );
                try
                {
                    return artifactResolver.resolve( request );
                }
                finally
                {
                    request.setLocalRepository( localRepository );
                }
            }
        }
        catch ( ComponentLookupException e )
        {
            // no ide workspace artifact resolution
        }

        return artifactResolver.resolve( request );
    }
1100#/*
    public void addProxy( String protocol, String host, int port, String username, String password, String nonProxyHosts )
    {
        ProxyInfo proxyInfo = new ProxyInfo();
        proxyInfo.setHost( host );
        proxyInfo.setType( protocol );
        proxyInfo.setPort( port );
        proxyInfo.setNonProxyHosts( nonProxyHosts );
        proxyInfo.setUserName( username );
        proxyInfo.setPassword( password );

        proxies.put( protocol, proxyInfo );

        wagonManager.addProxy( protocol, host, port, username, password, nonProxyHosts );
    }
    */

    public List<ArtifactRepository> getEffectiveRepositories( List<ArtifactRepository> repositories )
    {
        if ( repositories == null )
        {
            return null;
        }

        Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<String, List<ArtifactRepository>>();

        for ( ArtifactRepository repository : repositories )
        {
            String key = repository.getId();

            List<ArtifactRepository> aliasedRepos = reposByKey.get( key );

            if ( aliasedRepos == null )
            {
                aliasedRepos = new ArrayList<ArtifactRepository>();
                reposByKey.put( key, aliasedRepos );
            }

            aliasedRepos.add( repository );
        }

        List<ArtifactRepository> effectiveRepositories = new ArrayList<ArtifactRepository>();

        for ( List<ArtifactRepository> aliasedRepos : reposByKey.values() )
        {
            List<ArtifactRepository> mirroredRepos = new ArrayList<ArtifactRepository>();

            List<ArtifactRepositoryPolicy> releasePolicies =
                new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() );

            for ( ArtifactRepository aliasedRepo : aliasedRepos )
            {
                releasePolicies.add( aliasedRepo.getReleases() );
                mirroredRepos.addAll( aliasedRepo.getMirroredRepositories() );
            }

            ArtifactRepositoryPolicy releasePolicy = getEffectivePolicy( releasePolicies );

            List<ArtifactRepositoryPolicy> snapshotPolicies =
                new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() );

            for ( ArtifactRepository aliasedRepo : aliasedRepos )
            {
                snapshotPolicies.add( aliasedRepo.getSnapshots() );
            }

            ArtifactRepositoryPolicy snapshotPolicy = getEffectivePolicy( snapshotPolicies );

            ArtifactRepository aliasedRepo = aliasedRepos.get( 0 );

            ArtifactRepository effectiveRepository =
                createArtifactRepository( aliasedRepo.getId(), aliasedRepo.getUrl(), aliasedRepo.getLayout(),
                                          snapshotPolicy, releasePolicy );

            effectiveRepository.setAuthentication( aliasedRepo.getAuthentication() );

            effectiveRepository.setProxy( aliasedRepo.getProxy() );

            effectiveRepository.setMirroredRepositories( mirroredRepos );

            effectiveRepositories.add( effectiveRepository );
        }

        return effectiveRepositories;
    }
1101#private ArtifactRepositoryPolicy getEffectivePolicy( Collection<ArtifactRepositoryPolicy> policies )
    {
        ArtifactRepositoryPolicy effectivePolicy = null;

        for ( ArtifactRepositoryPolicy policy : policies )
        {
            if ( effectivePolicy == null )
            {
                effectivePolicy = new ArtifactRepositoryPolicy( policy );
            }
            else
            {
                effectivePolicy.merge( policy );
            }
        }

        return effectivePolicy;
    }
1102#public Mirror getMirror( ArtifactRepository repository, List<Mirror> mirrors )
    {
        return mirrorSelector.getMirror( repository, mirrors );
    }
1103#public void injectMirror( List<ArtifactRepository> repositories, List<Mirror> mirrors )
    {
        if ( repositories != null && mirrors != null )
        {
            for ( ArtifactRepository repository : repositories )
            {
                Mirror mirror = getMirror( repository, mirrors );
                injectMirror( repository, mirror );
            }
        }
    }
1104#private Mirror getMirror( RepositorySystemSession session, ArtifactRepository repository )
    {
        if ( session != null )
        {
            org.sonatype.aether.repository.MirrorSelector selector = session.getMirrorSelector();
            if ( selector != null )
            {
                RemoteRepository repo = selector.getMirror( RepositoryUtils.toRepo( repository ) );
                if ( repo != null )
                {
                    Mirror mirror = new Mirror();
                    mirror.setId( repo.getId() );
                    mirror.setUrl( repo.getUrl() );
                    mirror.setLayout( repo.getContentType() );
                    return mirror;
                }
            }
        }
        return null;
    }
1105#public void injectMirror( RepositorySystemSession session, List<ArtifactRepository> repositories )
    {
        if ( repositories != null && session != null )
        {
            for ( ArtifactRepository repository : repositories )
            {
                Mirror mirror = getMirror( session, repository );
                injectMirror( repository, mirror );
            }
        }
    }
1106#private void injectMirror( ArtifactRepository repository, Mirror mirror )
    {
        if ( mirror != null )
        {
            ArtifactRepository original =
                createArtifactRepository( repository.getId(), repository.getUrl(), repository.getLayout(),
                                          repository.getSnapshots(), repository.getReleases() );

            repository.setMirroredRepositories( Collections.singletonList( original ) );

            repository.setId( mirror.getId() );
            repository.setUrl( mirror.getUrl() );

            if ( StringUtils.isNotEmpty( mirror.getLayout() ) )
            {
                repository.setLayout( getLayout( mirror.getLayout() ) );
            }
        }
    }
1107#public void injectAuthentication( List<ArtifactRepository> repositories, List<Server> servers )
    {
        if ( repositories != null )
        {
            Map<String, Server> serversById = new HashMap<String, Server>();

            if ( servers != null )
            {
                for ( Server server : servers )
                {
                    if ( !serversById.containsKey( server.getId() ) )
                    {
                        serversById.put( server.getId(), server );
                    }
                }
            }

            for ( ArtifactRepository repository : repositories )
            {
                Server server = serversById.get( repository.getId() );

                if ( server != null )
                {
                    SettingsDecryptionRequest request = new DefaultSettingsDecryptionRequest( server );
                    SettingsDecryptionResult result = settingsDecrypter.decrypt( request );
                    server = result.getServer();

                    if ( logger.isDebugEnabled() )
                    {
                        for ( SettingsProblem problem : result.getProblems() )
                        {
                            logger.debug( problem.getMessage(), problem.getException() );
                        }
                    }

                    Authentication authentication = new Authentication( server.getUsername(), server.getPassword() );
                    authentication.setPrivateKey( server.getPrivateKey() );
                    authentication.setPassphrase( server.getPassphrase() );

                    repository.setAuthentication( authentication );
                }
                else
                {
                    repository.setAuthentication( null );
                }
            }
        }
    }
1108#private Authentication getAuthentication( RepositorySystemSession session, ArtifactRepository repository )
    {
        if ( session != null )
        {
            AuthenticationSelector selector = session.getAuthenticationSelector();
            if ( selector != null )
            {
                org.sonatype.aether.repository.Authentication auth =
                    selector.getAuthentication( RepositoryUtils.toRepo( repository ) );
                if ( auth != null )
                {
                    Authentication result = new Authentication( auth.getUsername(), auth.getPassword() );
                    result.setPrivateKey( auth.getPrivateKeyFile() );
                    result.setPassphrase( auth.getPassphrase() );
                    return result;
                }
            }
        }
        return null;
    }
1109#public void injectAuthentication( RepositorySystemSession session, List<ArtifactRepository> repositories )
    {
        if ( repositories != null && session != null )
        {
            for ( ArtifactRepository repository : repositories )
            {
                repository.setAuthentication( getAuthentication( session, repository ) );
            }
        }
    }
1110#private org.apache.maven.settings.Proxy getProxy( ArtifactRepository repository,
                                                      List<org.apache.maven.settings.Proxy> proxies )
    {
        if ( proxies != null && repository.getProtocol() != null )
        {
            for ( org.apache.maven.settings.Proxy proxy : proxies )
            {
                if ( proxy.isActive() && repository.getProtocol().equalsIgnoreCase( proxy.getProtocol() ) )
                {
                    if ( StringUtils.isNotEmpty( proxy.getNonProxyHosts() ) )
                    {
                        ProxyInfo pi = new ProxyInfo();
                        pi.setNonProxyHosts( proxy.getNonProxyHosts() );

                        org.apache.maven.wagon.repository.Repository repo =
                            new org.apache.maven.wagon.repository.Repository( repository.getId(), repository.getUrl() );

                        if ( !ProxyUtils.validateNonProxyHosts( pi, repo.getHost() ) )
                        {
                            return proxy;
                        }
                    }
                    else
                    {
                        return proxy;
                    }
                }
            }
        }

        return null;
    }
1111#public void injectProxy( List<ArtifactRepository> repositories, List<org.apache.maven.settings.Proxy> proxies )
    {
        if ( repositories != null )
        {
            for ( ArtifactRepository repository : repositories )
            {
                org.apache.maven.settings.Proxy proxy = getProxy( repository, proxies );

                if ( proxy != null )
                {
                    SettingsDecryptionRequest request = new DefaultSettingsDecryptionRequest( proxy );
                    SettingsDecryptionResult result = settingsDecrypter.decrypt( request );
                    proxy = result.getProxy();

                    if ( logger.isDebugEnabled() )
                    {
                        for ( SettingsProblem problem : result.getProblems() )
                        {
                            logger.debug( problem.getMessage(), problem.getException() );
                        }
                    }

                    Proxy p = new Proxy();
                    p.setHost( proxy.getHost() );
                    p.setProtocol( proxy.getProtocol() );
                    p.setPort( proxy.getPort() );
                    p.setNonProxyHosts( proxy.getNonProxyHosts() );
                    p.setUserName( proxy.getUsername() );
                    p.setPassword( proxy.getPassword() );

                    repository.setProxy( p );
                }
                else
                {
                    repository.setProxy( null );
                }
            }
        }
    }
1112#private Proxy getProxy( RepositorySystemSession session, ArtifactRepository repository )
    {
        if ( session != null )
        {
            ProxySelector selector = session.getProxySelector();
            if ( selector != null )
            {
                org.sonatype.aether.repository.Proxy proxy = selector.getProxy( RepositoryUtils.toRepo( repository ) );
                if ( proxy != null )
                {
                    Proxy p = new Proxy();
                    p.setHost( proxy.getHost() );
                    p.setProtocol( proxy.getType() );
                    p.setPort( proxy.getPort() );
                    if ( proxy.getAuthentication() != null )
                    {
                        p.setUserName( proxy.getAuthentication().getUsername() );
                        p.setPassword( proxy.getAuthentication().getPassword() );
                    }
                    return p;
                }
            }
        }
        return null;
    }
1113#public void injectProxy( RepositorySystemSession session, List<ArtifactRepository> repositories )
    {
        if ( repositories != null && session != null )
        {
            for ( ArtifactRepository repository : repositories )
            {
                repository.setProxy( getProxy( session, repository ) );
            }
        }
    }
1114#public void retrieve( ArtifactRepository repository, File destination, String remotePath,
                          ArtifactTransferListener transferListener )
        throws ArtifactTransferFailedException, ArtifactDoesNotExistException
    {
        try
        {
            wagonManager.getRemoteFile( repository, destination, remotePath,
                                        TransferListenerAdapter.newAdapter( transferListener ),
                                        ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN, true );
        }
        catch ( org.apache.maven.wagon.TransferFailedException e )
        {
            throw new ArtifactTransferFailedException( getMessage( e, "Error transferring artifact." ), e );
        }
        catch ( org.apache.maven.wagon.ResourceDoesNotExistException e )
        {
            throw new ArtifactDoesNotExistException( getMessage( e, "Requested artifact does not exist." ), e );
        }
    }
1115#public void publish( ArtifactRepository repository, File source, String remotePath,
                         ArtifactTransferListener transferListener )
        throws ArtifactTransferFailedException
    {
        try
        {
            wagonManager.putRemoteFile( repository, source, remotePath,
                                        TransferListenerAdapter.newAdapter( transferListener ) );
        }
        catch ( org.apache.maven.wagon.TransferFailedException e )
        {
            throw new ArtifactTransferFailedException( getMessage( e, "Error transferring artifact." ), e );
        }
    }
1116#//
    // Artifact Repository Creation
    //
    public ArtifactRepository buildArtifactRepository( Repository repo )
        throws InvalidRepositoryException
    {
        if ( repo != null )
        {
            String id = repo.getId();

            if ( StringUtils.isEmpty( id ) )
            {
                throw new InvalidRepositoryException( "Repository identifier missing", "" );
            }

            String url = repo.getUrl();

            if ( StringUtils.isEmpty( url ) )
            {
                throw new InvalidRepositoryException( "URL missing for repository " + id, id );
            }

            ArtifactRepositoryPolicy snapshots = buildArtifactRepositoryPolicy( repo.getSnapshots() );

            ArtifactRepositoryPolicy releases = buildArtifactRepositoryPolicy( repo.getReleases() );

            return createArtifactRepository( id, url, getLayout( repo.getLayout() ), snapshots, releases );
        }
        else
        {
            return null;
        }
    }
1117#private ArtifactRepository createRepository( String url, String repositoryId, boolean releases,
                                                 String releaseUpdates, boolean snapshots, String snapshotUpdates,
                                                 String checksumPolicy )
    {
        ArtifactRepositoryPolicy snapshotsPolicy =
            new ArtifactRepositoryPolicy( snapshots, snapshotUpdates, checksumPolicy );

        ArtifactRepositoryPolicy releasesPolicy =
            new ArtifactRepositoryPolicy( releases, releaseUpdates, checksumPolicy );

        return createArtifactRepository( repositoryId, url, null, snapshotsPolicy, releasesPolicy );
    }
1118#public ArtifactRepository createArtifactRepository( String repositoryId, String url,
                                                        ArtifactRepositoryLayout repositoryLayout,
                                                        ArtifactRepositoryPolicy snapshots,
                                                        ArtifactRepositoryPolicy releases )
    {
        if ( repositoryLayout == null )
        {
            repositoryLayout = layouts.get( "default" );
        }

        ArtifactRepository artifactRepository =
            artifactRepositoryFactory.createArtifactRepository( repositoryId, url, repositoryLayout, snapshots,
                                                                releases );

        return artifactRepository;
    }
1119#private static String getMessage( Throwable error, String def )
    {
        if ( error == null )
        {
            return def;
        }
        String msg = error.getMessage();
        if ( StringUtils.isNotEmpty( msg ) )
        {
            return msg;
        }
        return getMessage( error.getCause(), def );
    }
1120#private ArtifactRepositoryLayout getLayout( String id )
    {
        ArtifactRepositoryLayout layout = layouts.get( id );

        if ( layout == null )
        {
            layout = new UnknownRepositoryLayout( id, layouts.get( "default" ) );
        }

        return layout;
    }
1121#public UnknownRepositoryLayout( String id, ArtifactRepositoryLayout fallback )
        {
            this.id = id;
            this.fallback = fallback;
        }
1122#public String getId()
        {
            return id;
        }
1123#public String pathOf( Artifact artifact )
        {
            return fallback.pathOf( artifact );
        }
1124#public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository )
        {
            return fallback.pathOfLocalRepositoryMetadata( metadata, repository );
        }
1125#public String pathOfRemoteRepositoryMetadata( ArtifactMetadata metadata )
        {
            return fallback.pathOfRemoteRepositoryMetadata( metadata );
        }
1126#@Override
        public String toString()
        {
            return getId();
        }
1127#boolean isUpdateRequired( Artifact artifact, ArtifactRepository repository );
1128#void touch( Artifact artifact, ArtifactRepository repository, String error );
1129#String getError( Artifact artifact, ArtifactRepository repository );
1130#boolean isUpdateRequired( RepositoryMetadata metadata, ArtifactRepository repository, File file );
1131#void touch( RepositoryMetadata metadata, ArtifactRepository repository, File file );
1132#//
    // Retriever
    //
    public void getArtifact( Artifact artifact, ArtifactRepository repository, TransferListener downloadMonitor,
                             boolean force )
        throws TransferFailedException, ResourceDoesNotExistException
    {
        String remotePath = repository.pathOf( artifact );

        ArtifactRepositoryPolicy policy = artifact.isSnapshot() ? repository.getSnapshots() : repository.getReleases();

        if ( !policy.isEnabled() )
        {
            logger.debug( "Skipping disabled repository " + repository.getId() + " for resolution of "
                + artifact.getId() );
        }
        else if ( artifact.isSnapshot() || !artifact.getFile().exists() )
        {
            if ( force || updateCheckManager.isUpdateRequired( artifact, repository ) )
            {
                logger.debug( "Trying repository " + repository.getId() + " for resolution of " + artifact.getId()
                    + " from " + remotePath );

                try
                {
                    getRemoteFile( repository, artifact.getFile(), remotePath, downloadMonitor,
                                   policy.getChecksumPolicy(), false );

                    updateCheckManager.touch( artifact, repository, null );
                }
                catch ( ResourceDoesNotExistException e )
                {
                    updateCheckManager.touch( artifact, repository, null );
                    throw e;
                }
                catch ( TransferFailedException e )
                {
                    String error = ( e.getMessage() != null ) ? e.getMessage() : e.getClass().getSimpleName();
                    updateCheckManager.touch( artifact, repository, error );
                    throw e;
                }

                logger.debug( "  Artifact " + artifact.getId() + " resolved to " + artifact.getFile() );

                artifact.setResolved( true );
            }
            else if ( !artifact.getFile().exists() )
            {
                String error = updateCheckManager.getError( artifact, repository );
                if ( error != null )
                {
                    throw new TransferFailedException( "Failure to resolve " + remotePath + " from "
                        + repository.getUrl() + " was cached in the local repository. "
                        + "Resolution will not be reattempted until the update interval of " + repository.getId()
                        + " has elapsed or updates are forced. Original error: " + error );
                }
                else
                {
                    throw new ResourceDoesNotExistException( "Failure to resolve " + remotePath + " from "
                        + repository.getUrl() + " was cached in the local repository. "
                        + "Resolution will not be reattempted until the update interval of " + repository.getId()
                        + " has elapsed or updates are forced." );
                }
            }
        }
    }
1133#public void getArtifact( Artifact artifact, List<ArtifactRepository> remoteRepositories,
                             TransferListener downloadMonitor, boolean force )
        throws TransferFailedException, ResourceDoesNotExistException
    {
        TransferFailedException tfe = null;

        for ( ArtifactRepository repository : remoteRepositories )
        {
            try
            {
                getArtifact( artifact, repository, downloadMonitor, force );

                if ( artifact.isResolved() )
                {
                    artifact.setRepository( repository );
                    break;
                }
            }
            catch ( ResourceDoesNotExistException e )
            {
                // This one we will eat when looking through remote repositories
                // because we want to cycle through them all before squawking.

                logger.debug( "Unable to find artifact " + artifact.getId() + " in repository " + repository.getId()
                    + " (" + repository.getUrl() + ")", e );
            }
            catch ( TransferFailedException e )
            {
                tfe = e;

                String msg =
                    "Unable to get artifact " + artifact.getId() + " from repository " + repository.getId() + " ("
                        + repository.getUrl() + "): " + e.getMessage();
                if ( logger.isDebugEnabled() )
                {
                    logger.warn( msg, e );
                }
                else
                {
                    logger.warn( msg );
                }
            }
        }

        // if it already exists locally we were just trying to force it - ignore the update
        if ( !artifact.getFile().exists() )
        {
            if ( tfe != null )
            {
                throw tfe;
            }
            else
            {
                throw new ResourceDoesNotExistException( "Unable to download the artifact from any repository" );
            }
        }
    }
1134#public void getArtifactMetadata( ArtifactMetadata metadata, ArtifactRepository repository, File destination,
                                     String checksumPolicy )
        throws TransferFailedException, ResourceDoesNotExistException
    {
        String remotePath = repository.pathOfRemoteRepositoryMetadata( metadata );

        getRemoteFile( repository, destination, remotePath, null, checksumPolicy, true );
    }
1135#public void getArtifactMetadataFromDeploymentRepository( ArtifactMetadata metadata, ArtifactRepository repository,
                                                             File destination, String checksumPolicy )
        throws TransferFailedException, ResourceDoesNotExistException
    {
        String remotePath = repository.pathOfRemoteRepositoryMetadata( metadata );

        getRemoteFile( repository, destination, remotePath, null, checksumPolicy, true );
    }
1136#/**
     * Deal with connecting to a wagon repository taking into account authentication and proxies.
     *
     * @param wagon
     * @param repository
     * @throws ConnectionException
     * @throws AuthenticationException
     */
    private void connectWagon( Wagon wagon, ArtifactRepository repository )
        throws ConnectionException, AuthenticationException
    {
        if ( repository.getProxy() != null && logger.isDebugEnabled() )
        {
            logger.debug( "Using proxy " + repository.getProxy().getHost() + ":" + repository.getProxy().getPort()
                + " for " + repository.getUrl() );
        }

        if ( repository.getAuthentication() != null && repository.getProxy() != null )
        {
            wagon.connect( new Repository( repository.getId(), repository.getUrl() ), authenticationInfo( repository ),
                           proxyInfo( repository ) );
        }
        else if ( repository.getAuthentication() != null )
        {
            wagon.connect( new Repository( repository.getId(), repository.getUrl() ),
                           authenticationInfo( repository ) );
        }
        else if ( repository.getProxy() != null )
        {
            wagon.connect( new Repository( repository.getId(), repository.getUrl() ), proxyInfo( repository ) );
        }
        else
        {
            wagon.connect( new Repository( repository.getId(), repository.getUrl() ) );
        }
    }
1137#private AuthenticationInfo authenticationInfo( ArtifactRepository repository )
    {
        AuthenticationInfo ai = new AuthenticationInfo();
        ai.setUserName( repository.getAuthentication().getUsername() );
        ai.setPassword( repository.getAuthentication().getPassword() );
        return ai;
    }
1138#private ProxyInfo proxyInfo( ArtifactRepository repository )
    {
        ProxyInfo proxyInfo = new ProxyInfo();
        proxyInfo.setHost( repository.getProxy().getHost() );
        proxyInfo.setType( repository.getProxy().getProtocol() );
        proxyInfo.setPort( repository.getProxy().getPort() );
        proxyInfo.setNonProxyHosts( repository.getProxy().getNonProxyHosts() );
        proxyInfo.setUserName( repository.getProxy().getUserName() );
        proxyInfo.setPassword( repository.getProxy().getPassword() );
        return proxyInfo;
    }
1139#public void getRemoteFile( ArtifactRepository repository, File destination, String remotePath,
                               TransferListener downloadMonitor, String checksumPolicy, boolean force )
        throws TransferFailedException, ResourceDoesNotExistException
    {
        String protocol = repository.getProtocol();

        Wagon wagon;

        try
        {
            wagon = getWagon( protocol );
        }
        catch ( UnsupportedProtocolException e )
        {
            throw new TransferFailedException( "Unsupported Protocol: '" + protocol + "': " + e.getMessage(), e );
        }

        if ( downloadMonitor != null )
        {
            wagon.addTransferListener( downloadMonitor );
        }

        File temp = new File( destination + ".tmp" );

        temp.deleteOnExit();

        boolean downloaded = false;

        try
        {
            connectWagon( wagon, repository );

            boolean firstRun = true;
            boolean retry = true;

            // this will run at most twice. The first time, the firstRun flag is turned off, and if the retry flag
            // is set on the first run, it will be turned off and not re-set on the second try. This is because the
            // only way the retry flag can be set is if ( firstRun == true ).
            while ( firstRun || retry )
            {
                ChecksumObserver md5ChecksumObserver = null;
                ChecksumObserver sha1ChecksumObserver = null;
                try
                {
                    // TODO: configure on repository
                    int i = 0;

                    md5ChecksumObserver = addChecksumObserver( wagon, CHECKSUM_ALGORITHMS[i++] );
                    sha1ChecksumObserver = addChecksumObserver( wagon, CHECKSUM_ALGORITHMS[i++] );

                    // reset the retry flag.
                    retry = false;

                    // This should take care of creating destination directory now on
                    if ( destination.exists() && !force )
                    {
                        try
                        {
                            downloaded = wagon.getIfNewer( remotePath, temp, destination.lastModified() );

                            if ( !downloaded )
                            {
                                // prevent additional checks of this artifact until it expires again
                                destination.setLastModified( System.currentTimeMillis() );
                            }
                        }
                        catch ( UnsupportedOperationException e )
                        {
                            // older wagons throw this. Just get() instead
                            wagon.get( remotePath, temp );

                            downloaded = true;
                        }
                    }
                    else
                    {
                        wagon.get( remotePath, temp );
                        downloaded = true;
                    }
                }
                finally
                {
                    wagon.removeTransferListener( md5ChecksumObserver );
                    wagon.removeTransferListener( sha1ChecksumObserver );
                }

                if ( downloaded )
                {
                    // keep the checksum files from showing up on the download monitor...
                    if ( downloadMonitor != null )
                    {
                        wagon.removeTransferListener( downloadMonitor );
                    }

                    // try to verify the SHA-1 checksum for this file.
                    try
                    {
                        verifyChecksum( sha1ChecksumObserver, destination, temp, remotePath, ".sha1", wagon );
                    }
                    catch ( ChecksumFailedException e )
                    {
                        // if we catch a ChecksumFailedException, it means the transfer/read succeeded, but the checksum
                        // doesn't match. This could be a problem with the server (ibiblio HTTP-200 error page), so we'll
                        // try this up to two times. On the second try, we'll handle it as a bona-fide error, based on the
                        // repository's checksum checking policy.
                        if ( firstRun )
                        {
                            logger.warn( "*** CHECKSUM FAILED - " + e.getMessage() + " - RETRYING" );
                            retry = true;
                        }
                        else
                        {
                            handleChecksumFailure( checksumPolicy, e.getMessage(), e.getCause() );
                        }
                    }
                    catch ( ResourceDoesNotExistException sha1TryException )
                    {
                        logger.debug( "SHA1 not found, trying MD5: " + sha1TryException.getMessage() );

                        // if this IS NOT a ChecksumFailedException, it was a problem with transfer/read of the checksum
                        // file...we'll try again with the MD5 checksum.
                        try
                        {
                            verifyChecksum( md5ChecksumObserver, destination, temp, remotePath, ".md5", wagon );
                        }
                        catch ( ChecksumFailedException e )
                        {
                            // if we also fail to verify based on the MD5 checksum, and the checksum transfer/read
                            // succeeded, then we need to determine whether to retry or handle it as a failure.
                            if ( firstRun )
                            {
                                retry = true;
                            }
                            else
                            {
                                handleChecksumFailure( checksumPolicy, e.getMessage(), e.getCause() );
                            }
                        }
                        catch ( ResourceDoesNotExistException md5TryException )
                        {
                            // this was a failed transfer, and we don't want to retry.
                            handleChecksumFailure( checksumPolicy, "Error retrieving checksum file for " + remotePath,
                                                   md5TryException );
                        }
                    }

                    // reinstate the download monitor...
                    if ( downloadMonitor != null )
                    {
                        wagon.addTransferListener( downloadMonitor );
                    }
                }

                // unset the firstRun flag, so we don't get caught in an infinite loop...
                firstRun = false;
            }
        }
        catch ( ConnectionException e )
        {
            throw new TransferFailedException( "Connection failed: " + e.getMessage(), e );
        }
        catch ( AuthenticationException e )
        {
            throw new TransferFailedException( "Authentication failed: " + e.getMessage(), e );
        }
        catch ( AuthorizationException e )
        {
            throw new TransferFailedException( "Authorization failed: " + e.getMessage(), e );
        }
        finally
        {
            // Remove remaining TransferListener instances (checksum handlers removed in above finally clause)
            if ( downloadMonitor != null )
            {
                wagon.removeTransferListener( downloadMonitor );
            }

            disconnectWagon( wagon );

            releaseWagon( protocol, wagon );
        }

        if ( downloaded )
        {
            if ( !temp.exists() )
            {
                throw new ResourceDoesNotExistException( "Downloaded file does not exist: " + temp );
            }

            // The temporary file is named destination + ".tmp" and is done this way to ensure
            // that the temporary file is in the same file system as the destination because the
            // File.renameTo operation doesn't really work across file systems.
            // So we will attempt to do a File.renameTo for efficiency and atomicity, if this fails
            // then we will use a brute force copy and delete the temporary file.

            if ( !temp.renameTo( destination ) )
            {
                try
                {
                    FileUtils.copyFile( temp, destination );

                    temp.delete();
                }
                catch ( IOException e )
                {
                    throw new TransferFailedException( "Error copying temporary file to the final destination: "
                        + e.getMessage(), e );
                }
            }
        }
    }
1140#//
    // Publisher
    //
    public void putArtifact( File source, Artifact artifact, ArtifactRepository deploymentRepository,
                             TransferListener downloadMonitor )
        throws TransferFailedException
    {
        putRemoteFile( deploymentRepository, source, deploymentRepository.pathOf( artifact ), downloadMonitor );
    }
1141#public void putArtifactMetadata( File source, ArtifactMetadata artifactMetadata, ArtifactRepository repository )
        throws TransferFailedException
    {
        logger.info( "Uploading " + artifactMetadata );
        putRemoteFile( repository, source, repository.pathOfRemoteRepositoryMetadata( artifactMetadata ), null );
    }
1142#public void putRemoteFile( ArtifactRepository repository, File source, String remotePath,
                               TransferListener downloadMonitor )
        throws TransferFailedException
    {
        String protocol = repository.getProtocol();

        Wagon wagon;
        try
        {
            wagon = getWagon( protocol );
        }
        catch ( UnsupportedProtocolException e )
        {
            throw new TransferFailedException( "Unsupported Protocol: '" + protocol + "': " + e.getMessage(), e );
        }

        if ( downloadMonitor != null )
        {
            wagon.addTransferListener( downloadMonitor );
        }

        Map<String, ChecksumObserver> checksums = new HashMap<String, ChecksumObserver>( 2 );

        Map<String, String> sums = new HashMap<String, String>( 2 );

        // TODO: configure these on the repository
        for ( int i = 0; i < CHECKSUM_IDS.length; i++ )
        {
            checksums.put( CHECKSUM_IDS[i], addChecksumObserver( wagon, CHECKSUM_ALGORITHMS[i] ) );
        }

        List<File> temporaryFiles = new ArrayList<File>();

        try
        {
            try
            {
                connectWagon( wagon, repository );

                wagon.put( source, remotePath );
            }
            finally
            {
                if ( downloadMonitor != null )
                {
                    wagon.removeTransferListener( downloadMonitor );
                }
            }

            // Pre-store the checksums as any future puts will overwrite them
            for ( String extension : checksums.keySet() )
            {
                ChecksumObserver observer = checksums.get( extension );
                sums.put( extension, observer.getActualChecksum() );
            }

            // We do this in here so we can checksum the artifact metadata too, otherwise it could be metadata itself
            for ( String extension : checksums.keySet() )
            {
                // TODO: shouldn't need a file intermediatary - improve wagon to take a stream
                File temp = File.createTempFile( "maven-artifact", null );
                temp.deleteOnExit();
                FileUtils.fileWrite( temp.getAbsolutePath(), "UTF-8", sums.get( extension ) );

                temporaryFiles.add( temp );
                wagon.put( temp, remotePath + "." + extension );
            }
        }
        catch ( ConnectionException e )
        {
            throw new TransferFailedException( "Connection failed: " + e.getMessage(), e );
        }
        catch ( AuthenticationException e )
        {
            throw new TransferFailedException( "Authentication failed: " + e.getMessage(), e );
        }
        catch ( AuthorizationException e )
        {
            throw new TransferFailedException( "Authorization failed: " + e.getMessage(), e );
        }
        catch ( ResourceDoesNotExistException e )
        {
            throw new TransferFailedException( "Resource to deploy not found: " + e.getMessage(), e );
        }
        catch ( IOException e )
        {
            throw new TransferFailedException( "Error creating temporary file for deployment: " + e.getMessage(), e );
        }
        finally
        {
            // MNG-4543
            cleanupTemporaryFiles( temporaryFiles );

            // Remove every checksum listener
            for ( String aCHECKSUM_IDS : CHECKSUM_IDS )
            {
                TransferListener checksumListener = checksums.get( aCHECKSUM_IDS );
                if ( checksumListener != null )
                {
                    wagon.removeTransferListener( checksumListener );
                }
            }

            disconnectWagon( wagon );

            releaseWagon( protocol, wagon );
        }
    }
1143#private void cleanupTemporaryFiles( List<File> files )
    {
        for ( File file : files )
        {
            // really don't care if it failed here only log warning
            try
            {
                file.delete();
            }
            catch ( Exception e )
            {
                logger.warn( "skip failed to delete temporary file : " + file.getAbsolutePath() + " , message "
                    + e.getMessage() );
            }
        }

    }
1144#private ChecksumObserver addChecksumObserver( Wagon wagon, String algorithm )
        throws TransferFailedException
    {
        try
        {
            ChecksumObserver checksumObserver = new ChecksumObserver( algorithm );
            wagon.addTransferListener( checksumObserver );
            return checksumObserver;
        }
        catch ( NoSuchAlgorithmException e )
        {
            throw new TransferFailedException( "Unable to add checksum for unsupported algorithm " + algorithm, e );
        }
    }
1145#private void handleChecksumFailure( String checksumPolicy, String message, Throwable cause )
        throws ChecksumFailedException
    {
        if ( ArtifactRepositoryPolicy.CHECKSUM_POLICY_FAIL.equals( checksumPolicy ) )
        {
            throw new ChecksumFailedException( message, cause );
        }
        else if ( !ArtifactRepositoryPolicy.CHECKSUM_POLICY_IGNORE.equals( checksumPolicy ) )
        {
            // warn if it is set to anything other than ignore
            logger.warn( "*** CHECKSUM FAILED - " + message + " - IGNORING" );
        }
        // otherwise it is ignore
    }
1146#private void verifyChecksum( ChecksumObserver checksumObserver, File destination, File tempDestination,
                                 String remotePath, String checksumFileExtension, Wagon wagon )
        throws ResourceDoesNotExistException, TransferFailedException, AuthorizationException
    {
        try
        {
            // grab it first, because it's about to change...
            String actualChecksum = checksumObserver.getActualChecksum();

            File tempChecksumFile = new File( tempDestination + checksumFileExtension + ".tmp" );
            tempChecksumFile.deleteOnExit();
            wagon.get( remotePath + checksumFileExtension, tempChecksumFile );

            String expectedChecksum = FileUtils.fileRead( tempChecksumFile, "UTF-8" );

            // remove whitespaces at the end
            expectedChecksum = expectedChecksum.trim();

            // check for 'ALGO (name) = CHECKSUM' like used by openssl
            if ( expectedChecksum.regionMatches( true, 0, "MD", 0, 2 )
                || expectedChecksum.regionMatches( true, 0, "SHA", 0, 3 ) )
            {
                int lastSpacePos = expectedChecksum.lastIndexOf( ' ' );
                expectedChecksum = expectedChecksum.substring( lastSpacePos + 1 );
            }
            else
            {
                // remove everything after the first space (if available)
                int spacePos = expectedChecksum.indexOf( ' ' );

                if ( spacePos != -1 )
                {
                    expectedChecksum = expectedChecksum.substring( 0, spacePos );
                }
            }
            if ( expectedChecksum.equalsIgnoreCase( actualChecksum ) )
            {
                File checksumFile = new File( destination + checksumFileExtension );
                if ( checksumFile.exists() )
                {
                    checksumFile.delete();
                }
                FileUtils.copyFile( tempChecksumFile, checksumFile );
                tempChecksumFile.delete();
            }
            else
            {
                throw new ChecksumFailedException( "Checksum failed on download: local = '" + actualChecksum
                    + "'; remote = '" + expectedChecksum + "'" );
            }
        }
        catch ( IOException e )
        {
            throw new ChecksumFailedException( "Invalid checksum file", e );
        }
    }
1147#private void disconnectWagon( Wagon wagon )
    {
        try
        {
            wagon.disconnect();
        }
        catch ( ConnectionException e )
        {
            logger.error( "Problem disconnecting from wagon - ignoring: " + e.getMessage() );
        }
    }
1148#private void releaseWagon( String protocol, Wagon wagon )
    {
        try
        {
            container.release( wagon );
        }
        catch ( ComponentLifecycleException e )
        {
            logger.error( "Problem releasing wagon - ignoring: " + e.getMessage() );
            logger.debug( "", e );
        }
    }
1149#@Deprecated
    public Wagon getWagon( Repository repository )
        throws UnsupportedProtocolException
    {
        return getWagon( repository.getProtocol() );
    }
1150#@Deprecated
    public Wagon getWagon( String protocol )
        throws UnsupportedProtocolException
    {
        if ( protocol == null )
        {
            throw new UnsupportedProtocolException( "Unspecified protocol" );
        }

        String hint = protocol.toLowerCase( java.util.Locale.ENGLISH );

        Wagon wagon;
        try
        {
            wagon = container.lookup( Wagon.class, hint );
        }
        catch ( ComponentLookupException e )
        {
            throw new UnsupportedProtocolException( "Cannot find wagon which supports the requested protocol: "
                + protocol, e );
        }

        return wagon;
    }
1151#@Deprecated
    ArtifactRepositoryLayout getLayout( String layoutId )
        throws UnknownRepositoryLayoutException;
1152#@Deprecated
    ArtifactRepository createDeploymentArtifactRepository( String id, String url, String layoutId, boolean uniqueVersion )
        throws UnknownRepositoryLayoutException;
1153#ArtifactRepository createDeploymentArtifactRepository( String id, String url, ArtifactRepositoryLayout layout,
                                                           boolean uniqueVersion );
1154#ArtifactRepository createArtifactRepository( String id, String url, String layoutId,
                                                 ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases )
        throws UnknownRepositoryLayoutException;
1155#ArtifactRepository createArtifactRepository( String id, String url, ArtifactRepositoryLayout repositoryLayout,
                                                 ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases );
1156#void setGlobalUpdatePolicy( String snapshotPolicy );
1157#void setGlobalChecksumPolicy( String checksumPolicy );
1158#public ArtifactRepositoryLayout getLayout( String layoutId )
        throws UnknownRepositoryLayoutException
    {
        return repositoryLayouts.get( layoutId );
    }
1159#public ArtifactRepository createDeploymentArtifactRepository( String id, String url, String layoutId,
                                                                  boolean uniqueVersion )
        throws UnknownRepositoryLayoutException
    {
        ArtifactRepositoryLayout layout = repositoryLayouts.get( layoutId );

        checkLayout( id, layoutId, layout );

        return createDeploymentArtifactRepository( id, url, layout, uniqueVersion );
    }
1160#private void checkLayout( String repositoryId, String layoutId, ArtifactRepositoryLayout layout )
        throws UnknownRepositoryLayoutException
    {
        if ( layout == null )
        {
            throw new UnknownRepositoryLayoutException( repositoryId, layoutId );
        }
    }
1161#public ArtifactRepository createDeploymentArtifactRepository( String id, String url,
                                                                  ArtifactRepositoryLayout repositoryLayout,
                                                                  boolean uniqueVersion )
    {
        return createArtifactRepository( id, url, repositoryLayout, null, null );
    }
1162#public ArtifactRepository createArtifactRepository( String id, String url, String layoutId,
                                                        ArtifactRepositoryPolicy snapshots,
                                                        ArtifactRepositoryPolicy releases )
        throws UnknownRepositoryLayoutException
    {
        ArtifactRepositoryLayout layout = repositoryLayouts.get( layoutId );

        checkLayout( id, layoutId, layout );

        return createArtifactRepository( id, url, layout, snapshots, releases );
    }
1163#public ArtifactRepository createArtifactRepository( String id, String url,
                                                        ArtifactRepositoryLayout repositoryLayout,
                                                        ArtifactRepositoryPolicy snapshots,
                                                        ArtifactRepositoryPolicy releases )
    {
        if ( snapshots == null )
        {
            snapshots = new ArtifactRepositoryPolicy();
        }

        if ( releases == null )
        {
            releases = new ArtifactRepositoryPolicy();
        }

        if ( globalUpdatePolicy != null )
        {
            snapshots.setUpdatePolicy( globalUpdatePolicy );
            releases.setUpdatePolicy( globalUpdatePolicy );
        }

        if ( globalChecksumPolicy != null )
        {
            snapshots.setChecksumPolicy( globalChecksumPolicy );
            releases.setChecksumPolicy( globalChecksumPolicy );
        }

        ArtifactRepository repository;
        if ( repositoryLayout instanceof ArtifactRepositoryLayout2 )
        {
            repository =
                ( (ArtifactRepositoryLayout2) repositoryLayout ).newMavenArtifactRepository( id, url, snapshots,
                                                                                             releases );
        }
        else
        {
            repository = new MavenArtifactRepository( id, url, repositoryLayout, snapshots, releases );
        }

        return repository;
    }
1164#public void setGlobalUpdatePolicy( String updatePolicy )
    {
        globalUpdatePolicy = updatePolicy;
    }
1165#public void setGlobalChecksumPolicy( String checksumPolicy )
    {
        globalChecksumPolicy = checksumPolicy;
    }
1166#private void injectSession( ArtifactResolutionRequest request )
    {
        MavenSession session = legacySupport.getSession();

        if ( session != null )
        {
            request.setOffline( session.isOffline() );
            request.setForceUpdate( session.getRequest().isUpdateSnapshots() );
            request.setServers( session.getRequest().getServers() );
            request.setMirrors( session.getRequest().getMirrors() );
            request.setProxies( session.getRequest().getProxies() );
        }
    }
1167#public ArtifactResolutionResult collect( Set<Artifact> artifacts, Artifact originatingArtifact,
                                             Map managedVersions, ArtifactRepository localRepository,
                                             List<ArtifactRepository> remoteRepositories,
                                             ArtifactMetadataSource source, ArtifactFilter filter,
                                             List<ResolutionListener> listeners,
                                             List<ConflictResolver> conflictResolvers )
    {
        ArtifactResolutionRequest request = new ArtifactResolutionRequest();
        request.setLocalRepository( localRepository );
        request.setRemoteRepositories( remoteRepositories );
        injectSession( request );
        return collect( artifacts, originatingArtifact, managedVersions, request, source, filter, listeners,
                        conflictResolvers );
    }
1168#public ArtifactResolutionResult collect( Set<Artifact> artifacts, Artifact originatingArtifact,
                                             Map managedVersions, ArtifactResolutionRequest repositoryRequest,
                                             ArtifactMetadataSource source, ArtifactFilter filter,
                                             List<ResolutionListener> listeners,
                                             List<ConflictResolver> conflictResolvers )
    {
        ArtifactResolutionResult result = new ArtifactResolutionResult();

        result.setOriginatingArtifact( originatingArtifact );

        if ( conflictResolvers == null )
        {
            conflictResolvers = Collections.singletonList( defaultConflictResolver );
        }

        Map<Object, List<ResolutionNode>> resolvedArtifacts = new LinkedHashMap<Object, List<ResolutionNode>>();

        ResolutionNode root = new ResolutionNode( originatingArtifact, repositoryRequest.getRemoteRepositories() );

        try
        {
            root.addDependencies( artifacts, repositoryRequest.getRemoteRepositories(), filter );
        }
        catch ( CyclicDependencyException e )
        {
            result.addCircularDependencyException( e );

            return result;
        }
        catch ( OverConstrainedVersionException e )
        {
            result.addVersionRangeViolation( e );

            return result;
        }

        ManagedVersionMap versionMap = getManagedVersionsMap( originatingArtifact, managedVersions );

        try
        {
            recurse( result, root, resolvedArtifacts, versionMap, repositoryRequest, source, filter, listeners,
                     conflictResolvers );
        }
        catch ( CyclicDependencyException e )
        {
            logger.debug( "While recursing: " + e.getMessage(), e );
            result.addCircularDependencyException( e );
        }
        catch ( OverConstrainedVersionException e )
        {
            logger.debug( "While recursing: " + e.getMessage(), e );
            result.addVersionRangeViolation( e );
        }
        catch ( ArtifactResolutionException e )
        {
            logger.debug( "While recursing: " + e.getMessage(), e );
            result.addErrorArtifactException( e );
        }

        Set<ResolutionNode> set = new LinkedHashSet<ResolutionNode>();

        for ( List<ResolutionNode> nodes : resolvedArtifacts.values() )
        {
            for ( ResolutionNode node : nodes )
            {
                if ( !node.equals( root ) && node.isActive() )
                {
                    Artifact artifact = node.getArtifact();

                    try
                    {
                        if ( node.filterTrail( filter ) )
                        {
                            // If it was optional and not a direct dependency,
                            // we don't add it or its children, just allow the update of the version and artifactScope
                            if ( node.isChildOfRootNode() || !artifact.isOptional() )
                            {
                                artifact.setDependencyTrail( node.getDependencyTrail() );

                                set.add( node );

                                // This is required right now.
                                result.addArtifact( artifact );
                            }
                        }
                    }
                    catch ( OverConstrainedVersionException e )
                    {
                        result.addVersionRangeViolation( e );
                    }
                }
            }
        }

        result.setArtifactResolutionNodes( set );

        return result;
    }
1169#/**
     * Get the map of managed versions, removing the originating artifact if it is also in managed versions
     *
     * @param originatingArtifact artifact we are processing
     * @param managedVersions original managed versions
     */
    private ManagedVersionMap getManagedVersionsMap( Artifact originatingArtifact, Map managedVersions )
    {
        ManagedVersionMap versionMap;
        if ( ( managedVersions != null ) && ( managedVersions instanceof ManagedVersionMap ) )
        {
            versionMap = (ManagedVersionMap) managedVersions;
        }
        else
        {
            versionMap = new ManagedVersionMap( managedVersions );
        }

        /* remove the originating artifact if it is also in managed versions to avoid being modified during resolution */
        Artifact managedOriginatingArtifact = (Artifact) versionMap.get( originatingArtifact.getDependencyConflictId() );

        if ( managedOriginatingArtifact != null )
        {
            // TODO we probably want to warn the user that he is building an artifact with
            // different values than in dependencyManagement
            if ( managedVersions instanceof ManagedVersionMap )
            {
                /* avoid modifying the managedVersions parameter creating a new map */
                versionMap = new ManagedVersionMap( managedVersions );
            }
            versionMap.remove( originatingArtifact.getDependencyConflictId() );
        }

        return versionMap;
    }
1170#private void recurse( ArtifactResolutionResult result, ResolutionNode node,
                          Map<Object, List<ResolutionNode>> resolvedArtifacts, ManagedVersionMap managedVersions,
                          ArtifactResolutionRequest request, ArtifactMetadataSource source, ArtifactFilter filter,
                          List<ResolutionListener> listeners, List<ConflictResolver> conflictResolvers )
        throws ArtifactResolutionException
    {
        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );

        Object key = node.getKey();

        // TODO: Does this check need to happen here? Had to add the same call
        // below when we iterate on child nodes -- will that suffice?
        if ( managedVersions.containsKey( key ) )
        {
            manageArtifact( node, managedVersions, listeners );
        }

        List<ResolutionNode> previousNodes = resolvedArtifacts.get( key );

        if ( previousNodes != null )
        {
            for ( ResolutionNode previous : previousNodes )
            {
                try
                {
                    if ( previous.isActive() )
                    {
                        // Version mediation
                        VersionRange previousRange = previous.getArtifact().getVersionRange();
                        VersionRange currentRange = node.getArtifact().getVersionRange();

                        if ( ( previousRange != null ) && ( currentRange != null ) )
                        {
                            // TODO: shouldn't need to double up on this work, only done for simplicity of handling
                            // recommended
                            // version but the restriction is identical
                            VersionRange newRange = previousRange.restrict( currentRange );
                            // TODO: ick. this forces the OCE that should have come from the previous call. It is still
                            // correct
                            if ( newRange.isSelectedVersionKnown( previous.getArtifact() ) )
                            {
                                fireEvent( ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(),
                                           newRange );
                            }
                            previous.getArtifact().setVersionRange( newRange );
                            node.getArtifact().setVersionRange( currentRange.restrict( previousRange ) );

                            // Select an appropriate available version from the (now restricted) range
                            // Note this version was selected before to get the appropriate POM
                            // But it was reset by the call to setVersionRange on restricting the version
                            ResolutionNode[] resetNodes = { previous, node };
                            for ( int j = 0; j < 2; j++ )
                            {
                                Artifact resetArtifact = resetNodes[j].getArtifact();

                                // MNG-2123: if the previous node was not a range, then it wouldn't have any available
                                // versions. We just clobbered the selected version above. (why? i have no idea.)
                                // So since we are here and this is ranges we must go figure out the version (for a
                                // third time...)
                                if ( resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null )
                                {

                                    // go find the version. This is a total hack. See previous comment.
                                    List<ArtifactVersion> versions = resetArtifact.getAvailableVersions();
                                    if ( versions == null )
                                    {
                                        try
                                        {
                                            MetadataResolutionRequest metadataRequest =
                                                new DefaultMetadataResolutionRequest( request );
                                            metadataRequest.setArtifact( resetArtifact );
                                            versions = source.retrieveAvailableVersions( metadataRequest );
                                            resetArtifact.setAvailableVersions( versions );
                                        }
                                        catch ( ArtifactMetadataRetrievalException e )
                                        {
                                            resetArtifact.setDependencyTrail( node.getDependencyTrail() );
                                            throw new ArtifactResolutionException(
                                                                                   "Unable to get dependency information: "
                                                                                       + e.getMessage(), resetArtifact,
                                                                                   request.getRemoteRepositories(), e );
                                        }
                                    }
                                    // end hack

                                    // MNG-2861: match version can return null
                                    ArtifactVersion selectedVersion =
                                        resetArtifact.getVersionRange().matchVersion( resetArtifact.getAvailableVersions() );
                                    if ( selectedVersion != null )
                                    {
                                        resetArtifact.selectVersion( selectedVersion.toString() );
                                    }
                                    else
                                    {
                                        throw new OverConstrainedVersionException( " Unable to find a version in "
                                            + resetArtifact.getAvailableVersions() + " to match the range "
                                            + resetArtifact.getVersionRange(), resetArtifact );
                                    }

                                    fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j] );
                                }
                            }
                        }

                        // Conflict Resolution
                        ResolutionNode resolved = null;
                        for ( Iterator j = conflictResolvers.iterator(); ( resolved == null ) && j.hasNext(); )
                        {
                            ConflictResolver conflictResolver = (ConflictResolver) j.next();

                            resolved = conflictResolver.resolveConflict( previous, node );
                        }

                        if ( resolved == null )
                        {
                            // TODO: add better exception that can detail the two conflicting artifacts
                            ArtifactResolutionException are =
                                new ArtifactResolutionException( "Cannot resolve artifact version conflict between "
                                    + previous.getArtifact().getVersion() + " and " + node.getArtifact().getVersion(),
                                                                 previous.getArtifact() );
                            result.addVersionRangeViolation( are );
                        }

                        if ( ( resolved != previous ) && ( resolved != node ) )
                        {
                            // TODO: add better exception
                            result.addVersionRangeViolation( new ArtifactResolutionException(
                                                                                              "Conflict resolver returned unknown resolution node: ",
                                                                                              resolved.getArtifact() ) );
                        }

                        // TODO: should this be part of mediation?
                        // previous one is more dominant
                        ResolutionNode nearest;
                        ResolutionNode farthest;

                        if ( resolved == previous )
                        {
                            nearest = previous;
                            farthest = node;
                        }
                        else
                        {
                            nearest = node;
                            farthest = previous;
                        }

                        if ( checkScopeUpdate( farthest, nearest, listeners ) )
                        {
                            // if we need to update artifactScope of nearest to use farthest artifactScope, use the
                            // nearest version, but farthest artifactScope
                            nearest.disable();
                            farthest.getArtifact().setVersion( nearest.getArtifact().getVersion() );
                            fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, nearest, farthest.getArtifact() );
                        }
                        else
                        {
                            farthest.disable();
                            fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact() );
                        }
                    }
                }
                catch ( OverConstrainedVersionException e )
                {
                    result.addVersionRangeViolation( e );
                }
            }
        }
        else
        {
            previousNodes = new ArrayList<ResolutionNode>();

            resolvedArtifacts.put( key, previousNodes );
        }
        previousNodes.add( node );

        if ( node.isActive() )
        {
            fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );
        }

        // don't pull in the transitive deps of a system-scoped dependency.
        if ( node.isActive() && !Artifact.SCOPE_SYSTEM.equals( node.getArtifact().getScope() ) )
        {
            fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );

            Artifact parentArtifact = node.getArtifact();

            for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )
            {
                ResolutionNode child = (ResolutionNode) i.next();

                try
                {

                    // We leave in optional ones, but don't pick up its dependencies
                    if ( !child.isResolved() && ( !child.getArtifact().isOptional() || child.isChildOfRootNode() ) )
                    {
                        Artifact artifact = child.getArtifact();
                        artifact.setDependencyTrail( node.getDependencyTrail() );
                        List<ArtifactRepository> childRemoteRepositories = child.getRemoteRepositories();

                        MetadataResolutionRequest metadataRequest =
                            new DefaultMetadataResolutionRequest( request );
                        metadataRequest.setArtifact( artifact );
                        metadataRequest.setRemoteRepositories( childRemoteRepositories );

                        try
                        {
                            ResolutionGroup rGroup;

                            Object childKey;
                            do
                            {
                                childKey = child.getKey();

                                if ( managedVersions.containsKey( childKey ) )
                                {
                                    // If this child node is a managed dependency, ensure
                                    // we are using the dependency management version
                                    // of this child if applicable b/c we want to use the
                                    // managed version's POM, *not* any other version's POM.
                                    // We retrieve the POM below in the retrieval step.
                                    manageArtifact( child, managedVersions, listeners );

                                    // Also, we need to ensure that any exclusions it presents are
                                    // added to the artifact before we retrive the metadata
                                    // for the artifact; otherwise we may end up with unwanted
                                    // dependencies.
                                    Artifact ma = (Artifact) managedVersions.get( childKey );
                                    ArtifactFilter managedExclusionFilter = ma.getDependencyFilter();
                                    if ( null != managedExclusionFilter )
                                    {
                                        if ( null != artifact.getDependencyFilter() )
                                        {
                                            AndArtifactFilter aaf = new AndArtifactFilter();
                                            aaf.add( artifact.getDependencyFilter() );
                                            aaf.add( managedExclusionFilter );
                                            artifact.setDependencyFilter( aaf );
                                        }
                                        else
                                        {
                                            artifact.setDependencyFilter( managedExclusionFilter );
                                        }
                                    }
                                }

                                if ( artifact.getVersion() == null )
                                {
                                    // set the recommended version
                                    // TODO: maybe its better to just pass the range through to retrieval and use a
                                    // transformation?
                                    ArtifactVersion version;
                                    if ( !artifact.isSelectedVersionKnown() )
                                    {
                                        List<ArtifactVersion> versions = artifact.getAvailableVersions();
                                        if ( versions == null )
                                        {
                                            versions = source.retrieveAvailableVersions( metadataRequest );
                                            artifact.setAvailableVersions( versions );
                                        }

                                        Collections.sort( versions );

                                        VersionRange versionRange = artifact.getVersionRange();

                                        version = versionRange.matchVersion( versions );

                                        if ( version == null )
                                        {
                                            if ( versions.isEmpty() )
                                            {
                                                throw new OverConstrainedVersionException(
                                                                                           "No versions are present in the repository for the artifact with a range "
                                                                                               + versionRange,
                                                                                           artifact,
                                                                                           childRemoteRepositories );
                                            }

                                            throw new OverConstrainedVersionException( "Couldn't find a version in "
                                                + versions + " to match range " + versionRange, artifact,
                                                childRemoteRepositories );
                                        }
                                    }
                                    else
                                    {
                                        version = artifact.getSelectedVersion();
                                    }

                                    artifact.selectVersion( version.toString() );
                                    fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );
                                }

                                rGroup = source.retrieve( metadataRequest );

                                if ( rGroup == null )
                                {
                                    break;
                                }
                            }
                            while( !childKey.equals( child.getKey() ) );

                            if ( parentArtifact != null && parentArtifact.getDependencyFilter() != null
                                && !parentArtifact.getDependencyFilter().include( artifact ) )
                            {
                                // MNG-3769: the [probably relocated] artifact is excluded.
                                // We could process exclusions on relocated artifact details in the
                                // MavenMetadataSource.createArtifacts(..) step, BUT that would
                                // require resolving the POM from the repository very early on in
                                // the build.
                                continue;
                            }

                            // TODO might be better to have source.retrieve() throw a specific exception for this
                            // situation
                            // and catch here rather than have it return null
                            if ( rGroup == null )
                            {
                                // relocated dependency artifact is declared excluded, no need to add and recurse
                                // further
                                continue;
                            }

                            child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );

                        }
                        catch ( CyclicDependencyException e )
                        {
                            // would like to throw this, but we have crappy stuff in the repo

                            fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,
                                       new ResolutionNode( e.getArtifact(), childRemoteRepositories, child ) );
                        }
                        catch ( ArtifactMetadataRetrievalException e )
                        {
                            artifact.setDependencyTrail( node.getDependencyTrail() );

                            throw new ArtifactResolutionException( "Unable to get dependency information for "
                                + artifact.getId() + ": " + e.getMessage(), artifact, childRemoteRepositories, e );
                        }

                        ArtifactResolutionRequest subRequest = new ArtifactResolutionRequest( metadataRequest );
                        subRequest.setServers( request.getServers() );
                        subRequest.setMirrors( request.getMirrors() );
                        subRequest.setProxies( request.getProxies() );
                        recurse( result, child, resolvedArtifacts, managedVersions, subRequest, source, filter,
                                 listeners, conflictResolvers );
                    }
                }
                catch ( OverConstrainedVersionException e )
                {
                    result.addVersionRangeViolation( e );
                }
                catch ( ArtifactResolutionException e )
                {
                    result.addMetadataResolutionException( e );
                }
            }

            fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );
        }
    }
1171#private void manageArtifact( ResolutionNode node, ManagedVersionMap managedVersions,
                                 List<ResolutionListener> listeners )
    {
        Artifact artifact = (Artifact) managedVersions.get( node.getKey() );

        // Before we update the version of the artifact, we need to know
        // whether we are working on a transitive dependency or not. This
        // allows depMgmt to always override transitive dependencies, while
        // explicit child override depMgmt (viz. depMgmt should only
        // provide defaults to children, but should override transitives).
        // We can do this by calling isChildOfRootNode on the current node.

        if ( ( artifact.getVersion() != null )
            && ( !node.isChildOfRootNode() || node.getArtifact().getVersion() == null ) )
        {
            fireEvent( ResolutionListener.MANAGE_ARTIFACT_VERSION, listeners, node, artifact );
            node.getArtifact().setVersion( artifact.getVersion() );
        }

        if ( ( artifact.getScope() != null ) && ( !node.isChildOfRootNode() || node.getArtifact().getScope() == null ) )
        {
            fireEvent( ResolutionListener.MANAGE_ARTIFACT_SCOPE, listeners, node, artifact );
            node.getArtifact().setScope( artifact.getScope() );
        }

        if ( Artifact.SCOPE_SYSTEM.equals( node.getArtifact().getScope() ) && ( node.getArtifact().getFile() == null )
            && ( artifact.getFile() != null ) )
        {
            fireEvent( ResolutionListener.MANAGE_ARTIFACT_SYSTEM_PATH, listeners, node, artifact );
            node.getArtifact().setFile( artifact.getFile() );
        }
    }
1172#/**
     * Check if the artifactScope needs to be updated. <a
     * href="http://docs.codehaus.org/x/IGU#DependencyMediationandConflictResolution-Scoperesolution">More info</a>.
     *
     * @param farthest farthest resolution node
     * @param nearest nearest resolution node
     * @param listeners
     */
    boolean checkScopeUpdate( ResolutionNode farthest, ResolutionNode nearest, List<ResolutionListener> listeners )
    {
        boolean updateScope = false;
        Artifact farthestArtifact = farthest.getArtifact();
        Artifact nearestArtifact = nearest.getArtifact();

        /* farthest is runtime and nearest has lower priority, change to runtime */
        if ( Artifact.SCOPE_RUNTIME.equals( farthestArtifact.getScope() )
            && ( Artifact.SCOPE_TEST.equals( nearestArtifact.getScope() )
                            || Artifact.SCOPE_PROVIDED.equals( nearestArtifact.getScope() ) ) )
        {
            updateScope = true;
        }

        /* farthest is compile and nearest is not (has lower priority), change to compile */
        if ( Artifact.SCOPE_COMPILE.equals( farthestArtifact.getScope() )
            && !Artifact.SCOPE_COMPILE.equals( nearestArtifact.getScope() ) )
        {
            updateScope = true;
        }

        /* current POM rules all, if nearest is in current pom, do not update its artifactScope */
        if ( ( nearest.getDepth() < 2 ) && updateScope )
        {
            updateScope = false;

            fireEvent( ResolutionListener.UPDATE_SCOPE_CURRENT_POM, listeners, nearest, farthestArtifact );
        }

        if ( updateScope )
        {
            fireEvent( ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthestArtifact );

            // previously we cloned the artifact, but it is more effecient to just update the artifactScope
            // if problems are later discovered that the original object needs its original artifactScope value, cloning
            // may
            // again be appropriate
            nearestArtifact.setScope( farthestArtifact.getScope() );
        }

        return updateScope;
    }
1173#private void fireEvent( int event, List<ResolutionListener> listeners, ResolutionNode node )
    {
        fireEvent( event, listeners, node, null );
    }
1174#private void fireEvent( int event, List<ResolutionListener> listeners, ResolutionNode node, Artifact replacement )
    {
        fireEvent( event, listeners, node, replacement, null );
    }
1175#private void fireEvent( int event, List<ResolutionListener> listeners, ResolutionNode node, Artifact replacement,
                            VersionRange newRange )
    {
        for ( ResolutionListener listener : listeners )
        {
            switch ( event )
            {
                case ResolutionListener.TEST_ARTIFACT:
                    listener.testArtifact( node.getArtifact() );
                    break;
                case ResolutionListener.PROCESS_CHILDREN:
                    listener.startProcessChildren( node.getArtifact() );
                    break;
                case ResolutionListener.FINISH_PROCESSING_CHILDREN:
                    listener.endProcessChildren( node.getArtifact() );
                    break;
                case ResolutionListener.INCLUDE_ARTIFACT:
                    listener.includeArtifact( node.getArtifact() );
                    break;
                case ResolutionListener.OMIT_FOR_NEARER:
                    listener.omitForNearer( node.getArtifact(), replacement );
                    break;
                case ResolutionListener.OMIT_FOR_CYCLE:
                    listener.omitForCycle( node.getArtifact() );
                    break;
                case ResolutionListener.UPDATE_SCOPE:
                    listener.updateScope( node.getArtifact(), replacement.getScope() );
                    break;
                case ResolutionListener.UPDATE_SCOPE_CURRENT_POM:
                    listener.updateScopeCurrentPom( node.getArtifact(), replacement.getScope() );
                    break;
                case ResolutionListener.MANAGE_ARTIFACT_VERSION:
                    if ( listener instanceof ResolutionListenerForDepMgmt )
                    {
                        ResolutionListenerForDepMgmt asImpl = (ResolutionListenerForDepMgmt) listener;
                        asImpl.manageArtifactVersion( node.getArtifact(), replacement );
                    }
                    else
                    {
                        listener.manageArtifact( node.getArtifact(), replacement );
                    }
                    break;
                case ResolutionListener.MANAGE_ARTIFACT_SCOPE:
                    if ( listener instanceof ResolutionListenerForDepMgmt )
                    {
                        ResolutionListenerForDepMgmt asImpl = (ResolutionListenerForDepMgmt) listener;
                        asImpl.manageArtifactScope( node.getArtifact(), replacement );
                    }
                    else
                    {
                        listener.manageArtifact( node.getArtifact(), replacement );
                    }
                    break;
                case ResolutionListener.MANAGE_ARTIFACT_SYSTEM_PATH:
                    if ( listener instanceof ResolutionListenerForDepMgmt )
                    {
                        ResolutionListenerForDepMgmt asImpl = (ResolutionListenerForDepMgmt) listener;
                        asImpl.manageArtifactSystemPath( node.getArtifact(), replacement );
                    }
                    else
                    {
                        listener.manageArtifact( node.getArtifact(), replacement );
                    }
                    break;
                case ResolutionListener.SELECT_VERSION_FROM_RANGE:
                    listener.selectVersionFromRange( node.getArtifact() );
                    break;
                case ResolutionListener.RESTRICT_RANGE:
                    if ( node.getArtifact().getVersionRange().hasRestrictions()
                        || replacement.getVersionRange().hasRestrictions() )
                    {
                        listener.restrictRange( node.getArtifact(), replacement, newRange );
                    }
                    break;
                default:
                    throw new IllegalStateException( "Unknown event: " + event );
            }
        }
    }
1176#public ArtifactResolutionResult collect( Set<Artifact> artifacts, Artifact originatingArtifact,
                                             Map managedVersions, ArtifactRepository localRepository,
                                             List<ArtifactRepository> remoteRepositories,
                                             ArtifactMetadataSource source, ArtifactFilter filter,
                                             List<ResolutionListener> listeners )
    {
        return collect( artifacts, originatingArtifact, managedVersions, localRepository, remoteRepositories, source,
                        filter, listeners, null );
    }
1177#public ArtifactResolutionResult collect( Set<Artifact> artifacts, Artifact originatingArtifact,
                                             ArtifactRepository localRepository,
                                             List<ArtifactRepository> remoteRepositories,
                                             ArtifactMetadataSource source, ArtifactFilter filter,
                                             List<ResolutionListener> listeners )
    {
        return collect( artifacts, originatingArtifact, null, localRepository, remoteRepositories, source, filter,
                        listeners );
    }
1178#ArtifactResolutionResult collect( Set<Artifact> artifacts, Artifact originatingArtifact, Map managedVersions,
                                      ArtifactResolutionRequest repositoryRequest, ArtifactMetadataSource source,
                                      ArtifactFilter filter, List<ResolutionListener> listeners,
                                      List<ConflictResolver> conflictResolvers );
1179#ArtifactResolutionResult collect( Set<Artifact> artifacts, Artifact originatingArtifact, Map managedVersions,
                                      ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories,
                                      ArtifactMetadataSource source, ArtifactFilter filter,
                                      List<ResolutionListener> listeners, List<ConflictResolver> conflictResolvers );
1180#// used by maven-dependency-tree and maven-dependency-plugin
    @Deprecated
    ArtifactResolutionResult collect( Set<Artifact> artifacts, Artifact originatingArtifact, Map managedVersions,
                                      ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories,
                                      ArtifactMetadataSource source, ArtifactFilter filter,
                                      List<ResolutionListener> listeners );
1181#/**
     * Determines which of the specified versions of an artifact to use when there are conflicting declarations.
     *
     * @param node1 the first artifact declaration
     * @param node2 the second artifact declaration
     * @return the artifact declaration to use: <code>node1</code>; <code>node2</code>; or <code>null</code>if
     *         this conflict cannot be resolved
     * @since 3.0
     */
    ResolutionNode resolveConflict( ResolutionNode node1, ResolutionNode node2 );
1182#// constructors -----------------------------------------------------------

    /**
     * Creates a new <code>ConflictResolverNotFoundException</code> with the specified message.
     *
     * @param message the message
     */
    public ConflictResolverNotFoundException( String message )
    {
        super( message );
    }
1183#// ConflictResolverFactory methods ----------------------------------------

    /*
    * @see org.apache.maven.artifact.resolver.conflict.ConflictResolverFactory#getConflictResolver(java.lang.String)
    */

    public ConflictResolver getConflictResolver( String type )
        throws ConflictResolverNotFoundException
    {
        try
        {
            return (ConflictResolver) container.lookup( ConflictResolver.ROLE, type );
        }
        catch ( ComponentLookupException exception )
        {
            throw new ConflictResolverNotFoundException( "Cannot find conflict resolver of type: " + type );
        }
    }
1184#// Contextualizable methods -----------------------------------------------

    /*
     * @see org.codehaus.plexus.personality.plexus.lifecycle.phase.Contextualizable#contextualize(org.codehaus.plexus.context.Context)
     */

    public void contextualize( Context context )
        throws ContextException
    {
        container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
    }
1185#// ConflictResolver methods -----------------------------------------------

    /*
    * @see org.apache.maven.artifact.resolver.conflict.ConflictResolver#resolveConflict(org.apache.maven.artifact.resolver.ResolutionNode,
    *      org.apache.maven.artifact.resolver.ResolutionNode)
    */

    public ResolutionNode resolveConflict( ResolutionNode node1, ResolutionNode node2 )
    {
        return node1.getDepth() >= node2.getDepth() ? node1 : node2;
    }
1186#// ConflictResolver methods -----------------------------------------------

    /*
    * @see org.apache.maven.artifact.resolver.conflict.ConflictResolver#resolveConflict(org.apache.maven.artifact.resolver.ResolutionNode,
    *      org.apache.maven.artifact.resolver.ResolutionNode)
    */

    public ResolutionNode resolveConflict( ResolutionNode node1, ResolutionNode node2 )
    {
        try
        {
            ArtifactVersion version1 = node1.getArtifact().getSelectedVersion();
            ArtifactVersion version2 = node2.getArtifact().getSelectedVersion();

            return version1.compareTo( version2 ) > 0 ? node1 : node2;
        }
        catch ( OverConstrainedVersionException exception )
        {
            // TODO: log message or throw exception?

            return null;
        }
    }
1187#// ConflictResolver methods -----------------------------------------------

    /*
    * @see org.apache.maven.artifact.resolver.conflict.ConflictResolver#resolveConflict(org.apache.maven.artifact.resolver.ResolutionNode,
    *      org.apache.maven.artifact.resolver.ResolutionNode)
    */

    public ResolutionNode resolveConflict( ResolutionNode node1, ResolutionNode node2 )
    {
        try
        {
            ArtifactVersion version1 = node1.getArtifact().getSelectedVersion();
            ArtifactVersion version2 = node2.getArtifact().getSelectedVersion();

            return version1.compareTo( version2 ) <= 0 ? node1 : node2;
        }
        catch ( OverConstrainedVersionException exception )
        {
            // TODO: log message or throw exception?

            return null;
        }
    }
1188#// methods ----------------------------------------------------------------

    /**
     * Gets a conflict resolver of the specified type.
     *
     * @param type the type of conflict resolver to obtain
     * @return the conflict resolver
     * @throws ConflictResolverNotFoundException
     *          if the specified type was not found
     */
    ConflictResolver getConflictResolver( String type )
        throws ConflictResolverNotFoundException;
1189#// ConflictResolver methods -----------------------------------------------

    /*
    * @see org.apache.maven.artifact.resolver.conflict.ConflictResolver#resolveConflict(org.apache.maven.artifact.resolver.ResolutionNode,
    *      org.apache.maven.artifact.resolver.ResolutionNode)
    */

    public ResolutionNode resolveConflict( ResolutionNode node1, ResolutionNode node2 )
    {
        return node1.getDepth() <= node2.getDepth() ? node1 : node2;
    }
1190#public void transformForResolve( Artifact artifact, RepositoryRequest request )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        if ( Artifact.RELEASE_VERSION.equals( artifact.getVersion() ) )
        {
            try
            {
                String version = resolveVersion( artifact, request );

                if ( Artifact.RELEASE_VERSION.equals( version ) )
                {
                    throw new ArtifactNotFoundException( "Unable to determine the release version", artifact );
                }

                artifact.setBaseVersion( version );
                artifact.updateVersion( version, request.getLocalRepository() );
            }
            catch ( RepositoryMetadataResolutionException e )
            {
                throw new ArtifactResolutionException( e.getMessage(), artifact, e );
            }
        }
    }
1191#public void transformForInstall( Artifact artifact, ArtifactRepository localRepository )
    {
        ArtifactMetadata metadata = createMetadata( artifact );

        artifact.addMetadata( metadata );
    }
1192#public void transformForDeployment( Artifact artifact, ArtifactRepository remoteRepository,
                                        ArtifactRepository localRepository )
    {
        ArtifactMetadata metadata = createMetadata( artifact );

        artifact.addMetadata( metadata );
    }
1193#private ArtifactMetadata createMetadata( Artifact artifact )
    {
        Versioning versioning = new Versioning();
        versioning.updateTimestamp();
        versioning.addVersion( artifact.getVersion() );

        if ( artifact.isRelease() )
        {
            versioning.setRelease( artifact.getVersion() );
        }

        return new ArtifactRepositoryMetadata( artifact, versioning );
    }
1194#protected String constructVersion( Versioning versioning, String baseVersion )
    {
        return versioning.getRelease();
    }
1195#public void transformForResolve( Artifact artifact, RepositoryRequest request )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        for ( ArtifactTransformation transform : artifactTransformations )
        {
            transform.transformForResolve( artifact, request );
        }
    }
1196#public void transformForResolve( Artifact artifact, List<ArtifactRepository> remoteRepositories,
                                     ArtifactRepository localRepository )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        for ( ArtifactTransformation transform : artifactTransformations )
        {
            transform.transformForResolve( artifact, remoteRepositories, localRepository );
        }
    }
1197#public void transformForInstall( Artifact artifact, ArtifactRepository localRepository )
        throws ArtifactInstallationException
    {
        for ( ArtifactTransformation transform : artifactTransformations )
        {
            transform.transformForInstall( artifact, localRepository );
        }
    }
1198#public void transformForDeployment( Artifact artifact, ArtifactRepository remoteRepository,
                                        ArtifactRepository localRepository )
        throws ArtifactDeploymentException
    {
        for ( ArtifactTransformation transform : artifactTransformations )
        {
            transform.transformForDeployment( artifact, remoteRepository, localRepository );
        }
    }
1199#public List getArtifactTransformations()
    {
        return artifactTransformations;
    }
1200#/**
     * Take in a artifact and return the transformed artifact for locating in the remote repository. If no
     * transformation has occured the original artifact is returned.
     *
     * @param artifact           Artifact to be transformed.
     * @param request the repositories to check
     * @param localRepository    the local repository
     */
    void transformForResolve( Artifact artifact, RepositoryRequest request )
        throws ArtifactResolutionException, ArtifactNotFoundException;
1201#/**
     * Take in a artifact and return the transformed artifact for locating in the remote repository. If no
     * transformation has occured the original artifact is returned.
     *
     * @param artifact           Artifact to be transformed.
     * @param remoteRepositories the repositories to check
     * @param localRepository    the local repository
     */
    void transformForResolve( Artifact artifact,
                              List<ArtifactRepository> remoteRepositories,
                              ArtifactRepository localRepository )
        throws ArtifactResolutionException, ArtifactNotFoundException;
1202#/**
     * Take in a artifact and return the transformed artifact for locating in the local repository. If no
     * transformation has occured the original artifact is returned.
     *
     * @param artifact        Artifact to be transformed.
     * @param localRepository the local repository it will be stored in
     */
    void transformForInstall( Artifact artifact,
                              ArtifactRepository localRepository )
        throws ArtifactInstallationException;
1203#/**
     * Take in a artifact and return the transformed artifact for distributing toa remote repository. If no
     * transformation has occured the original artifact is returned.
     *
     * @param artifact         Artifact to be transformed.
     * @param remoteRepository the repository to deploy to
     * @param localRepository  the local repository
     */
    void transformForDeployment( Artifact artifact,
                                 ArtifactRepository remoteRepository,
                                 ArtifactRepository localRepository )
        throws ArtifactDeploymentException;
1204#public void transformForResolve( Artifact artifact, RepositoryRequest request )
        throws ArtifactResolutionException
    {
        // Only select snapshots that are unresolved (eg 1.0-SNAPSHOT, not 1.0-20050607.123456)
        if ( artifact.isSnapshot() && artifact.getBaseVersion().equals( artifact.getVersion() ) )
        {
            try
            {
                String version = resolveVersion( artifact, request );
                artifact.updateVersion( version, request.getLocalRepository() );
            }
            catch ( RepositoryMetadataResolutionException e )
            {
                throw new ArtifactResolutionException( e.getMessage(), artifact, e );
            }
        }
    }
1205#public void transformForInstall( Artifact artifact, ArtifactRepository localRepository )
    {
        if ( artifact.isSnapshot() )
        {
            Snapshot snapshot = new Snapshot();
            snapshot.setLocalCopy( true );
            RepositoryMetadata metadata = new SnapshotArtifactRepositoryMetadata( artifact, snapshot );

            artifact.addMetadata( metadata );
        }
    }
1206#public void transformForDeployment( Artifact artifact, ArtifactRepository remoteRepository,
                                        ArtifactRepository localRepository )
        throws ArtifactDeploymentException
    {
        if ( artifact.isSnapshot() )
        {
            Snapshot snapshot = new Snapshot();

            snapshot.setTimestamp( getDeploymentTimestamp() );

            // we update the build number anyway so that it doesn't get lost. It requires the timestamp to take effect
            try
            {
                int buildNumber = resolveLatestSnapshotBuildNumber( artifact, localRepository, remoteRepository );

                snapshot.setBuildNumber( buildNumber + 1 );
            }
            catch ( RepositoryMetadataResolutionException e )
            {
                throw new ArtifactDeploymentException( "Error retrieving previous build number for artifact '"
                    + artifact.getDependencyConflictId() + "': " + e.getMessage(), e );
            }

            RepositoryMetadata metadata = new SnapshotArtifactRepositoryMetadata( artifact, snapshot );

            artifact.setResolvedVersion(
                constructVersion( metadata.getMetadata().getVersioning(), artifact.getBaseVersion() ) );

            artifact.addMetadata( metadata );
        }
    }
1207#public String getDeploymentTimestamp()
    {
        if ( deploymentTimestamp == null )
        {
            deploymentTimestamp = getUtcDateFormatter().format( new Date() );
        }
        return deploymentTimestamp;
    }
1208#protected String constructVersion( Versioning versioning, String baseVersion )
    {
        String version = null;
        Snapshot snapshot = versioning.getSnapshot();
        if ( snapshot != null )
        {
            if ( snapshot.getTimestamp() != null && snapshot.getBuildNumber() > 0 )
            {
                String newVersion = snapshot.getTimestamp() + "-" + snapshot.getBuildNumber();
                version = StringUtils.replace( baseVersion, Artifact.SNAPSHOT_VERSION, newVersion );
            }
            else
            {
                version = baseVersion;
            }
        }
        return version;
    }
1209#private int resolveLatestSnapshotBuildNumber( Artifact artifact, ArtifactRepository localRepository,
                                                  ArtifactRepository remoteRepository )
        throws RepositoryMetadataResolutionException
    {
        RepositoryMetadata metadata = new SnapshotArtifactRepositoryMetadata( artifact );

        getLogger().info( "Retrieving previous build number from " + remoteRepository.getId() );
        repositoryMetadataManager.resolveAlways( metadata, localRepository, remoteRepository );

        int buildNumber = 0;
        Metadata repoMetadata = metadata.getMetadata();
        if ( ( repoMetadata != null )
            && ( repoMetadata.getVersioning() != null && repoMetadata.getVersioning().getSnapshot() != null ) )
        {
            buildNumber = repoMetadata.getVersioning().getSnapshot().getBuildNumber();
        }
        return buildNumber;
    }
1210#public static DateFormat getUtcDateFormatter()
    {
        DateFormat utcDateFormatter = new SimpleDateFormat( UTC_TIMESTAMP_PATTERN );
        utcDateFormatter.setTimeZone( UTC_TIME_ZONE );
        return utcDateFormatter;
    }
1211#/**
     * Take in a artifact and return the transformed artifact for locating in the remote repository. If no
     * transformation has occurred the original artifact is returned.
     *
     * @param artifact           Artifact to be transformed.
     * @param request the repositories to check
     * @param localRepository    the local repository
     */
    void transformForResolve( Artifact artifact, RepositoryRequest request )
        throws ArtifactResolutionException, ArtifactNotFoundException;
1212#/**
     * Take in a artifact and return the transformed artifact for locating in the remote repository. If no
     * transformation has occurred the original artifact is returned.
     *
     * @param artifact           Artifact to be transformed.
     * @param remoteRepositories the repositories to check
     * @param localRepository    the local repository
     */
    void transformForResolve( Artifact artifact, List<ArtifactRepository> remoteRepositories,
                              ArtifactRepository localRepository )
        throws ArtifactResolutionException, ArtifactNotFoundException;
1213#/**
     * Take in a artifact and return the transformed artifact for locating in the local repository. If no
     * transformation has occurred the original artifact is returned.
     *
     * @param artifact        Artifact to be transformed.
     * @param localRepository the local repository it will be stored in
     */
    void transformForInstall( Artifact artifact, ArtifactRepository localRepository )
        throws ArtifactInstallationException;
1214#/**
     * Take in a artifact and return the transformed artifact for distributing to a remote repository. If no
     * transformation has occurred the original artifact is returned.
     *
     * @param artifact         Artifact to be transformed.
     * @param remoteRepository the repository to deploy to
     * @param localRepository  the local repository the metadata is stored in
     */
    void transformForDeployment( Artifact artifact, ArtifactRepository remoteRepository,
                                 ArtifactRepository localRepository )
        throws ArtifactDeploymentException;
1215#List getArtifactTransformations();
1216#public void transformForResolve( Artifact artifact, RepositoryRequest request )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        if ( Artifact.LATEST_VERSION.equals( artifact.getVersion() ) )
        {
            try
            {
                String version = resolveVersion( artifact, request );
                if ( Artifact.LATEST_VERSION.equals( version ) )
                {
                    throw new ArtifactNotFoundException( "Unable to determine the latest version", artifact );
                }

                artifact.setBaseVersion( version );
                artifact.updateVersion( version, request.getLocalRepository() );
            }
            catch ( RepositoryMetadataResolutionException e )
            {
                throw new ArtifactResolutionException( e.getMessage(), artifact, e );
            }
        }
    }
1217#public void transformForInstall( Artifact artifact, ArtifactRepository localRepository )
    {
        // metadata is added via addPluginArtifactMetadata
    }
1218#public void transformForDeployment( Artifact artifact, ArtifactRepository remoteRepository,
                                        ArtifactRepository localRepository )
    {
        // metadata is added via addPluginArtifactMetadata
    }
1219#protected String constructVersion( Versioning versioning, String baseVersion )
    {
        return versioning.getLatest();
    }
1220#public void transformForResolve( Artifact artifact, List<ArtifactRepository> remoteRepositories,
                                     ArtifactRepository localRepository )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        RepositoryRequest request = new DefaultRepositoryRequest();
        request.setLocalRepository( localRepository );
        request.setRemoteRepositories( remoteRepositories );
        transformForResolve( artifact, request );
    }
1221#protected String resolveVersion( Artifact artifact, ArtifactRepository localRepository,
                                     List<ArtifactRepository> remoteRepositories )
        throws RepositoryMetadataResolutionException
    {
        RepositoryRequest request = new DefaultRepositoryRequest();
        request.setLocalRepository( localRepository );
        request.setRemoteRepositories( remoteRepositories );
        return resolveVersion( artifact, request );
    }
1222#protected String resolveVersion( Artifact artifact, RepositoryRequest request )
        throws RepositoryMetadataResolutionException
    {
        RepositoryMetadata metadata;
        // Don't use snapshot metadata for LATEST (which isSnapshot returns true for)
        if ( !artifact.isSnapshot() || Artifact.LATEST_VERSION.equals( artifact.getBaseVersion() ) )
        {
            metadata = new ArtifactRepositoryMetadata( artifact );
        }
        else
        {
            metadata = new SnapshotArtifactRepositoryMetadata( artifact );
        }

        repositoryMetadataManager.resolve( metadata, request );

        artifact.addMetadata( metadata );

        Metadata repoMetadata = metadata.getMetadata();
        String version = null;
        if ( repoMetadata != null && repoMetadata.getVersioning() != null )
        {
            version = constructVersion( repoMetadata.getVersioning(), artifact.getBaseVersion() );
        }

        if ( version == null )
        {
            // use the local copy, or if it doesn't exist - go to the remote repo for it
            version = artifact.getBaseVersion();
        }

        // TODO: also do this logging for other metadata?
        // TODO: figure out way to avoid duplicated message
        if ( getLogger().isDebugEnabled() )
        {
            if ( !version.equals( artifact.getBaseVersion() ) )
            {
                String message = artifact.getArtifactId() + ": resolved to version " + version;
                if ( artifact.getRepository() != null )
                {
                    message += " from repository " + artifact.getRepository().getId();
                }
                else
                {
                    message += " from local repository";
                }
                getLogger().debug( message );
            }
            else
            {
                // Locally installed file is newer, don't use the resolved version
                getLogger().debug( artifact.getArtifactId() + ": using locally installed snapshot" );
            }
        }
        return version;
    }
1223#protected abstract String constructVersion( Versioning versioning, String baseVersion );
1224#//----------------------------------------------------------------------------
    public MetadataResolutionResult( )
    {
    }
1225#//----------------------------------------------------------------------------
    public MetadataResolutionResult( MetadataTreeNode root )
    {
        this.treeRoot = root;
    }
1226#//----------------------------------------------------------------------------
    public MetadataTreeNode getTree()
    {
        return treeRoot;
    }
1227#//----------------------------------------------------------------------------
    public void setTree( MetadataTreeNode root )
    {
        this.treeRoot = root;
    }
1228#public void initTreeProcessing( PlexusContainer plexus )
        throws ComponentLookupException
    {
        classpathTransformation = (ClasspathTransformation) plexus.lookup( ClasspathTransformation.class );
        conflictResolver = (GraphConflictResolver) plexus.lookup( GraphConflictResolver.class );
    }
1229#//----------------------------------------------------------------------------
    public MetadataGraph getGraph()
        throws MetadataResolutionException
    {
        return treeRoot == null ? null : new MetadataGraph( treeRoot );
    }
1230#//----------------------------------------------------------------------------
    public MetadataGraph getGraph( ArtifactScopeEnum scope )
        throws MetadataResolutionException, GraphConflictResolutionException
    {
        if ( treeRoot == null )
        {
            return null;
        }

        if ( conflictResolver == null )
        {
            return null;
        }

        return conflictResolver.resolveConflicts( getGraph(), scope );
    }
1231#//----------------------------------------------------------------------------
    public MetadataGraph getGraph( MetadataResolutionRequestTypeEnum requestType )
        throws MetadataResolutionException, GraphConflictResolutionException
    {
        if ( requestType == null )
        {
            return null;
        }

        if ( treeRoot == null )
        {
            return null;
        }

        if ( conflictResolver == null )
        {
            return null;
        }

        if ( requestType.equals( MetadataResolutionRequestTypeEnum.classpathCompile ) )
        {
            return conflictResolver.resolveConflicts( getGraph(), ArtifactScopeEnum.compile );
        }
        else if ( requestType.equals( MetadataResolutionRequestTypeEnum.classpathRuntime ) )
        {
            return conflictResolver.resolveConflicts( getGraph(), ArtifactScopeEnum.runtime );
        }
        else if ( requestType.equals( MetadataResolutionRequestTypeEnum.classpathRuntime ) )
        {
            return conflictResolver.resolveConflicts( getGraph(), ArtifactScopeEnum.test );
        }
        else if ( requestType.equals( MetadataResolutionRequestTypeEnum.classpathRuntime ) )
        {
            return conflictResolver.resolveConflicts( getGraph(), ArtifactScopeEnum.test );
        }
        else if ( requestType.equals( MetadataResolutionRequestTypeEnum.graph ) )
        {
            return getGraph();
        }
        else if ( requestType.equals( MetadataResolutionRequestTypeEnum.versionedGraph ) )
        {
            return new MetadataGraph( getTree(), true, false );
        }
        else if ( requestType.equals( MetadataResolutionRequestTypeEnum.scopedGraph ) )
        {
            return new MetadataGraph( getTree(), true, true );
        }
        return null;
    }
1232#//----------------------------------------------------------------------------
    public ClasspathContainer getClasspath( ArtifactScopeEnum scope )
        throws MetadataGraphTransformationException, MetadataResolutionException
    {
        if ( classpathTransformation == null )
        {
            return null;
        }

        MetadataGraph dirtyGraph = getGraph();
        if ( dirtyGraph == null )
        {
            return null;
        }

        return classpathTransformation.transform( dirtyGraph, scope, false );
    }
1233#//----------------------------------------------------------------------------
    public MetadataTreeNode getClasspathTree( ArtifactScopeEnum scope )
        throws MetadataGraphTransformationException, MetadataResolutionException
    {
        ClasspathContainer cpc = getClasspath( scope );
        if ( cpc == null )
        {
            return null;
        }

        return cpc.getClasspathAsTree();
    }
1234#public MetadataGraphEdge apply( MetadataGraphEdge e1, MetadataGraphEdge e2 )
    {
        int depth1 = e1.getDepth();
        int depth2 = e2.getDepth();

        if ( depth1 == depth2 )
        {
            ArtifactVersion v1 = new DefaultArtifactVersion( e1.getVersion() );
            ArtifactVersion v2 = new DefaultArtifactVersion( e2.getVersion() );

            if ( newerFirst )
            {
                return v1.compareTo( v2 ) > 0 ? e1 : e2;
            }

            return v1.compareTo( v2 ) > 0 ? e2 : e1;
        }

        if ( closerFirst )
        {
            return depth1 < depth2 ? e1 : e2;
        }

        return depth1 < depth2 ? e2 : e1;
    }
1235#//--------------------------------------------------------------------
    public MetadataResolutionRequest()
    {
    }
1236#//--------------------------------------------------------------------
    public MetadataResolutionRequest( ArtifactMetadata query, ArtifactRepository localRepository,
                                      List<ArtifactRepository> remoteRepositories )
    {
        this.query = query;
        this.localRepository = localRepository;
        this.remoteRepositories = remoteRepositories;
    }
1237#//--------------------------------------------------------------------
    public ArtifactMetadata getQuery()
    {
        return query;
    }
1238#public void setQuery( ArtifactMetadata query )
    {
        this.query = query;
    }
1239#public ArtifactRepository getLocalRepository()
    {
        return localRepository;
    }
1240#public void setLocalRepository( ArtifactRepository localRepository )
    {
        this.localRepository = localRepository;
    }
1241#public List<ArtifactRepository> getRemoteRepositories()
    {
        return remoteRepositories;
    }
1242#public void setRemoteRepositories( List<ArtifactRepository> remoteRepositories )
    {
        this.remoteRepositories = remoteRepositories;
    }
1243#/**
     * Cleanses the supplied graph by leaving only one directed versioned edge\
     * between any two nodes, if multiple exists. Uses scope relationships, defined
     * in <code>ArtifactScopeEnum</code>
     *
     * @param graph the "dirty" graph to be simplified via conflict resolution
     * @param scope scope for which the graph should be resolved
     *
     * @return resulting "clean" graph for the specified scope
     *
     * @since 3.0
     */
    MetadataGraph resolveConflicts( MetadataGraph graph, ArtifactScopeEnum scope )
        throws GraphConflictResolutionException;
1244#public MetadataRetrievalException( String message )
    {
        this( message, null, null );
    }
1245#public MetadataRetrievalException( Throwable cause )
    {
        this( null, cause, null );
    }
1246#public MetadataRetrievalException( String message, Throwable cause )
    {
        this( message, cause, null );
    }
1247#public MetadataRetrievalException( String message, Throwable cause, ArtifactMetadata artifact )
    {
        super( message, cause );

        this.artifact = artifact;
    }
1248#public ArtifactMetadata getArtifactMetadata()
    {
        return artifact;
    }
1249#public MetadataResolutionException()
    {
        // TODO Auto-generated constructor stub
    }
1250#public MetadataResolutionException( String message )
    {
        super( message );
        // TODO Auto-generated constructor stub
    }
1251#public MetadataResolutionException( Throwable cause )
    {
        super( cause );
        // TODO Auto-generated constructor stub
    }
1252#public MetadataResolutionException( String message, Throwable cause )
    {
        super( message, cause );
        // TODO Auto-generated constructor stub
    }
1253#// -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    public MetadataGraph resolveConflicts( MetadataGraph graph, ArtifactScopeEnum scope )
        throws GraphConflictResolutionException
    {
        if ( policy == null )
        {
            throw new GraphConflictResolutionException( "no GraphConflictResolutionPolicy injected" );
        }

        if ( graph == null )
        {
            return null;
        }

        final MetadataGraphVertex entry = graph.getEntry();
        if ( entry == null )
        {
            return null;
        }

        if ( graph.isEmpty() )
        {
            throw new GraphConflictResolutionException( "graph with an entry, but not vertices do not exist" );
        }

        if ( graph.isEmptyEdges() )
        {
            return null; // no edges - nothing to worry about
        }

        final TreeSet<MetadataGraphVertex> vertices = graph.getVertices();

        try
        {
            // edge case - single vertex graph
            if ( vertices.size() == 1 )
            {
                return new MetadataGraph( entry );
            }

            final ArtifactScopeEnum requestedScope = ArtifactScopeEnum.checkScope( scope );

            MetadataGraph res = new MetadataGraph( vertices.size() );
            res.setVersionedVertices( false );
            res.setScopedVertices( false );

            MetadataGraphVertex resEntry = res.addVertex( entry.getMd() );
            res.setEntry( resEntry );

            res.setScope( requestedScope );

            for ( MetadataGraphVertex v : vertices )
            {
                final List<MetadataGraphEdge> ins = graph.getIncidentEdges( v );
                final MetadataGraphEdge edge = cleanEdges( v, ins, requestedScope );

                if ( edge == null )
                { // no edges - don't need this vertex any more
                    if ( entry.equals( v ) )
                    { // unless it's an entry point.
                        // currently processing the entry point - it should not have any entry incident edges
                        res.getEntry().getMd().setWhy( "This is a graph entry point. No links." );
                    }
                    else
                    {
                        // System.out.println("--->"+v.getMd().toDomainString()
                        // +" has been terminated on this entry set\n-------------------\n"
                        // +ins
                        // +"\n-------------------\n"
                        // );
                    }
                }
                else
                {
                    // System.out.println("+++>"+v.getMd().toDomainString()+" still has "+edge.toString() );
                    // fill in domain md with actual version data
                    ArtifactMetadata md = v.getMd();
                    ArtifactMetadata newMd =
                        new ArtifactMetadata( md.getGroupId(), md.getArtifactId(), edge.getVersion(), md.getType(),
                                              md.getScopeAsEnum(), md.getClassifier(), edge.getArtifactUri(),
                                              edge.getSource() == null ? "" : edge.getSource().getMd().toString(),
                                              edge.isResolved(), edge.getTarget() == null ? null
                                                              : edge.getTarget().getMd().getError() );
                    MetadataGraphVertex newV = res.addVertex( newMd );
                    MetadataGraphVertex sourceV = res.addVertex( edge.getSource().getMd() );

                    res.addEdge( sourceV, newV, edge );
                }
            }
            MetadataGraph linkedRes = findLinkedSubgraph( res );
            // System.err.println("Original graph("+graph.getVertices().size()+"):\n"+graph.toString());
            // System.err.println("Cleaned("+requestedScope+") graph("+res.getVertices().size()+"):\n"+res.toString());
            // System.err.println("Linked("+requestedScope+")
            // subgraph("+linkedRes.getVertices().size()+"):\n"+linkedRes.toString());
            return linkedRes;
        }
        catch ( MetadataResolutionException e )
        {
            throw new GraphConflictResolutionException( e );
        }
    }
1254#// -------------------------------------------------------------------------------------
    private MetadataGraph findLinkedSubgraph( MetadataGraph g )
    {
        if ( g.getVertices().size() == 1 )
        {
            return g;
        }

        List<MetadataGraphVertex> visited = new ArrayList<MetadataGraphVertex>( g.getVertices().size() );
        visit( g.getEntry(), visited, g );

        List<MetadataGraphVertex> dropList = new ArrayList<MetadataGraphVertex>( g.getVertices().size() );

        // collect drop list
        for ( MetadataGraphVertex v : g.getVertices() )
        {
            if ( !visited.contains( v ) )
            {
                dropList.add( v );
            }
        }

        if ( dropList.size() < 1 )
        {
            return g;
        }

        // now - drop vertices
        TreeSet<MetadataGraphVertex> vertices = g.getVertices();
        for ( MetadataGraphVertex v : dropList )
        {
            vertices.remove( v );
        }

        return g;
    }
1255#// -------------------------------------------------------------------------------------
    private void visit( MetadataGraphVertex from, List<MetadataGraphVertex> visited, MetadataGraph graph )
    {
        if ( visited.contains( from ) )
        {
            return;
        }

        visited.add( from );

        List<MetadataGraphEdge> exitList = graph.getExcidentEdges( from );
        // String s = "|---> "+from.getMd().toString()+" - "+(exitList == null ? -1 : exitList.size()) + " exit links";
        if ( exitList != null && exitList.size() > 0 )
        {
            for ( MetadataGraphEdge e : graph.getExcidentEdges( from ) )
            {
                visit( e.getTarget(), visited, graph );
            }
        }
    }
1256#// -------------------------------------------------------------------------------------
    private MetadataGraphEdge cleanEdges( MetadataGraphVertex v, List<MetadataGraphEdge> edges,
                                          ArtifactScopeEnum scope )
    {
        if ( edges == null || edges.isEmpty() )
        {
            return null;
        }

        if ( edges.size() == 1 )
        {
            MetadataGraphEdge e = edges.get( 0 );
            if ( scope.encloses( e.getScope() ) )
            {
                return e;
            }

            return null;
        }

        MetadataGraphEdge res = null;

        for ( MetadataGraphEdge e : edges )
        {
            if ( !scope.encloses( e.getScope() ) )
            {
                continue;
            }

            if ( res == null )
            {
                res = e;
            }
            else
            {
                res = policy.apply( e, res );
            }
        }

        return res;
    }
1257#public GraphConflictResolutionException()
    {
    }
1258#public GraphConflictResolutionException( String message )
    {
        super( message );
    }
1259#public GraphConflictResolutionException( Throwable cause )
    {
        super( cause );
    }
1260#public GraphConflictResolutionException( String message, Throwable cause )
    {
        super( message, cause );
    }
1261#MetadataGraphEdge apply( MetadataGraphEdge e1, MetadataGraphEdge e2 );
1262#public MetadataGraphTransformationException()
    {
    }
1263#public MetadataGraphTransformationException( String message )
    {
        super( message );
    }
1264#public MetadataGraphTransformationException( Throwable cause )
    {
        super( cause );
    }
1265#public MetadataGraphTransformationException( String message, Throwable cause )
    {
        super( message, cause );
    }
1266#//------------------------------------------------------------------------
    /**
     * init graph
     */
    public MetadataGraph( int nVertices )
    {
        init( nVertices, 2 * nVertices );
    }
1267#public MetadataGraph( int nVertices, int nEdges )
    {
        init( nVertices, nEdges );
    }
1268#//------------------------------------------------------------------------
    /**
     * construct a single vertex
     */
    public MetadataGraph( MetadataGraphVertex entry )
        throws MetadataResolutionException
    {
        checkVertex( entry );
        checkVertices( 1 );

        entry.setCompareVersion( versionedVertices );
        entry.setCompareScope( scopedVertices );

        vertices.add( entry );
        this.entry = entry;
    }
1269#//------------------------------------------------------------------------
    /**
     * construct graph from a "dirty" tree
     */
    public MetadataGraph( MetadataTreeNode tree )
        throws MetadataResolutionException
    {
        this( tree, false, false );
    }
1270#//------------------------------------------------------------------------
    /**
     * construct graph from a "dirty" tree
     *
     * @param tree "dirty" tree root
     * @param versionedVertices true if graph nodes should be versioned (different versions -> different nodes)
     * @param scopedVertices true if graph nodes should be versioned and scoped (different versions and/or scopes -> different nodes)
     *
     */
    public MetadataGraph( MetadataTreeNode tree, boolean versionedVertices, boolean scopedVertices )
        throws MetadataResolutionException
    {
        if ( tree == null )
        {
            throw new MetadataResolutionException( "tree is null" );
        }

        setVersionedVertices( versionedVertices );
        setScopedVertices( scopedVertices );

        this.versionedVertices = scopedVertices || versionedVertices;
        this.scopedVertices = scopedVertices;

        int count = countNodes( tree );

        init( count, count + ( count / 2 ) );

        processTreeNodes( null, tree, 0, 0 );
    }
1271#//------------------------------------------------------------------------
    private void processTreeNodes( MetadataGraphVertex parentVertex, MetadataTreeNode node, int depth, int pomOrder )
        throws MetadataResolutionException
    {
        if ( node == null )
        {
            return;
        }

        MetadataGraphVertex vertex = new MetadataGraphVertex( node.md, versionedVertices, scopedVertices );
        if ( !vertices.contains( vertex ) )
        {
            vertices.add( vertex );
        }

        if ( parentVertex != null ) // then create the edge
        {
            ArtifactMetadata md = node.getMd();
            MetadataGraphEdge e =
                new MetadataGraphEdge( md.version, md.resolved, md.artifactScope, md.artifactUri, depth, pomOrder );
            addEdge( parentVertex, vertex, e );
        }
        else
        {
            entry = vertex;
        }

        MetadataTreeNode[] kids = node.getChildren();
        if ( kids == null || kids.length < 1 )
        {
            return;
        }

        for ( int i = 0; i < kids.length; i++ )
        {
            MetadataTreeNode n = kids[i];
            processTreeNodes( vertex, n, depth + 1, i );
        }
    }
1272#//------------------------------------------------------------------------
    public MetadataGraphVertex findVertex( ArtifactMetadata md )
    {
        if ( md == null || vertices == null || vertices.size() < 1 )
        {
            return null;
        }

        MetadataGraphVertex v = new MetadataGraphVertex( md );
        v.setCompareVersion( versionedVertices );
        v.setCompareScope( scopedVertices );

        for ( MetadataGraphVertex gv : vertices )
        {
            if ( gv.equals( v ) )
            {
                return gv;
            }
        }

        return null;
    }
1273#//------------------------------------------------------------------------
    public MetadataGraphVertex addVertex( ArtifactMetadata md )
    {
        if ( md == null )
        {
            return null;
        }

        checkVertices();

        MetadataGraphVertex v = findVertex( md );
        if ( v != null )
        {
            return v;
        }

        v = new MetadataGraphVertex( md );

        v.setCompareVersion( versionedVertices );
        v.setCompareScope( scopedVertices );

        vertices.add( v );
        return v;
    }
1274#//------------------------------------------------------------------------
    /**
     * init graph
     */
    private void init( int nVertices, int nEdges )
    {
        int nV = nVertices;
        if ( nVertices < 1 )
        {
            nV = 1;
        }

        checkVertices( nV );

        int nE = nVertices;
        if ( nEdges <= nV )
        {
            nE = 2 * nE;
        }

        checkEdges( nE );
    }
1275#private void checkVertices()
    {
        checkVertices( DEFAULT_VERTICES );
    }
1276#private void checkVertices( int nVertices )
    {
        if ( vertices == null )
        {
            vertices = new TreeSet<MetadataGraphVertex>();
        }
    }
1277#private void checkEdges()
    {
        int count = DEFAULT_EDGES;

        if ( vertices != null )
        {
            count = vertices.size() + vertices.size() / 2;
        }

        checkEdges( count );
    }
1278#private void checkEdges( int nEdges )
    {
        if ( incidentEdges == null )
        {
            incidentEdges = new HashMap<MetadataGraphVertex, List<MetadataGraphEdge>>( nEdges );
        }
        if ( excidentEdges == null )
        {
            excidentEdges = new HashMap<MetadataGraphVertex, List<MetadataGraphEdge>>( nEdges );
        }
    }
1279#//------------------------------------------------------------------------
    private static void checkVertex( MetadataGraphVertex v )
        throws MetadataResolutionException
    {
        if ( v == null )
        {
            throw new MetadataResolutionException( "null vertex" );
        }
        if ( v.getMd() == null )
        {
            throw new MetadataResolutionException( "vertex without metadata" );
        }
    }
1280#//------------------------------------------------------------------------
    private static void checkEdge( MetadataGraphEdge e )
        throws MetadataResolutionException
    {
        if ( e == null )
        {
            throw new MetadataResolutionException( "badly formed edge" );
        }
    }
1281#//------------------------------------------------------------------------
    public List<MetadataGraphEdge> getEdgesBetween( MetadataGraphVertex vFrom, MetadataGraphVertex vTo )
    {
        List<MetadataGraphEdge> edges = getIncidentEdges(vTo);
        if ( edges == null || edges.isEmpty() )
        {
            return null;
        }

        List<MetadataGraphEdge> res = new ArrayList<MetadataGraphEdge>( edges.size() );

        for ( MetadataGraphEdge e : edges )
        {
            if ( e.getSource().equals( vFrom ) )
            {
                res.add( e );
            }
        }

        return res;
    }
1282#//------------------------------------------------------------------------
    public MetadataGraph addEdge( MetadataGraphVertex vFrom, MetadataGraphVertex vTo, MetadataGraphEdge e )
        throws MetadataResolutionException
    {
        checkVertex( vFrom );
        checkVertex( vTo );

        checkVertices();

        checkEdge( e );
        checkEdges();

        e.setSource( vFrom );
        e.setTarget( vTo );

        vFrom.setCompareVersion( versionedVertices );
        vFrom.setCompareScope( scopedVertices );

        List<MetadataGraphEdge> exList = excidentEdges.get( vFrom );
        if ( exList == null )
        {
            exList = new ArrayList<MetadataGraphEdge>();
            excidentEdges.put( vFrom, exList );
        }

        if ( !exList.contains( e ) )
        {
            exList.add( e );
        }

        List<MetadataGraphEdge> inList = incidentEdges.get( vTo );
        if ( inList == null )
        {
            inList = new ArrayList<MetadataGraphEdge>();
            incidentEdges.put( vTo, inList );
        }

        if ( !inList.contains( e ) )
        {
            inList.add( e );
        }

        return this;
    }
1283#//------------------------------------------------------------------------
    public MetadataGraph removeVertex( MetadataGraphVertex v )
    {
        if ( vertices != null && v != null )
        {
            vertices.remove( v );
        }

        if ( incidentEdges != null )
        {
            incidentEdges.remove( v );
        }

        if ( excidentEdges != null )
        {
            excidentEdges.remove( v );
        }

        return this;

    }
1284#//------------------------------------------------------------------------
    private static int countNodes( MetadataTreeNode tree )
    {
        if ( tree == null )
        {
            return 0;
        }

        int count = 1;
        MetadataTreeNode[] kids = tree.getChildren();
        if ( kids == null || kids.length < 1 )
        {
            return count;
        }
        for ( MetadataTreeNode n : kids )
        {
            count += countNodes( n );
        }

        return count;
    }
1285#//------------------------------------------------------------------------
    public MetadataGraphVertex getEntry()
    {
        return entry;
    }
1286#public void setEntry( MetadataGraphVertex entry )
    {
        this.entry = entry;
    }
1287#public TreeSet<MetadataGraphVertex> getVertices()
    {
        return vertices;
    }
1288#public List<MetadataGraphEdge> getIncidentEdges( MetadataGraphVertex vertex )
    {
        checkEdges();
        return incidentEdges.get( vertex );
    }
1289#public List<MetadataGraphEdge> getExcidentEdges( MetadataGraphVertex vertex )
    {
        checkEdges();
        return excidentEdges.get( vertex );
    }
1290#public boolean isVersionedVertices()
    {
        return versionedVertices;
    }
1291#public void setVersionedVertices( boolean versionedVertices )
    {
        this.versionedVertices = versionedVertices;
    }
1292#public boolean isScopedVertices()
    {
        return scopedVertices;
    }
1293#public void setScopedVertices( boolean scopedVertices )
    {
        this.scopedVertices = scopedVertices;

        // scoped graph is versioned by definition
        if ( scopedVertices )
        {
            versionedVertices = true;
        }
    }
1294#public ArtifactScopeEnum getScope()
    {
        return scope;
    }
1295#public void setScope( ArtifactScopeEnum scope )
    {
        this.scope = scope;
    }
1296#// ------------------------------------------------------------------------
    public boolean isEmpty()
    {
        return entry == null || vertices == null || vertices.isEmpty();
    }
1297#//------------------------------------------------------------------------
    public boolean isEmptyEdges()
    {
        return isEmpty() || incidentEdges == null || incidentEdges.isEmpty();
    }
1298#//------------------------------------------------------------------------
    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder( 512 );
        if ( isEmpty() )
        {
            return "empty";
        }
        for ( MetadataGraphVertex v : vertices )
        {
            sb.append( "Vertex:  " + v.getMd().toString() + "\n" );
            List<MetadataGraphEdge> ins = getIncidentEdges( v );
            if ( ins != null )
            {
                for ( MetadataGraphEdge e : ins )
                {
                    sb.append( "       from :  " + e.toString() + "\n" );
                }
            }
            else
            {
                sb.append( "      no entries\n" );
            }

            List<MetadataGraphEdge> outs = getExcidentEdges( v );
            if ( outs != null )
            {
                for ( MetadataGraphEdge e : outs )
                {
                    sb.append( "        to :  " + e.toString() + "\n" );
                }
            }
            else
            {
                sb.append( "      no exit\n" );
            }

            sb.append( "-------------------------------------------------\n" );
        }
        sb.append( "=============================================================\n" );
        return sb.toString();
    }
1299#// -------------------------------------------------------------------------------------------
    public ClasspathContainer( ArtifactScopeEnum scope )
    {
        this.scope = ArtifactScopeEnum.checkScope( scope );
    }
1300#// -------------------------------------------------------------------------------------------
    public ClasspathContainer( List<ArtifactMetadata> classpath, ArtifactScopeEnum scope )
    {
        this( scope );
        this.classpath = classpath;
    }
1301#// -------------------------------------------------------------------------------------------
    public Iterator<ArtifactMetadata> iterator()
    {
        return classpath == null ? null : classpath.iterator();
    }
1302#// -------------------------------------------------------------------------------------------
    public ClasspathContainer add( ArtifactMetadata md )
    {
        if ( classpath == null )
        {
            classpath = new ArrayList<ArtifactMetadata>( 16 );
        }

        classpath.add( md );

        return this;
    }
1303#// -------------------------------------------------------------------------------------------
    public List<ArtifactMetadata> getClasspath()
    {
        return classpath;
    }
1304#// -------------------------------------------------------------------------------------------
    public MetadataTreeNode getClasspathAsTree()
        throws MetadataResolutionException
    {
        if ( classpath == null || classpath.size() < 1 )
        {
            return null;
        }

        MetadataTreeNode tree = null;
        MetadataTreeNode parent = null;
        MetadataTreeNode node = null;

        for ( ArtifactMetadata md : classpath )
        {
            node = new MetadataTreeNode( md, parent, md.isResolved(), md.getArtifactScope() );
            if ( tree == null )
            {
                tree = node;
            }

            if ( parent != null )
            {
                parent.setNChildren( 1 );
                parent.addChild( 0, node );
            }

            parent = node;

        }
        return tree;
    }
1305#public void setClasspath( List<ArtifactMetadata> classpath )
    {
        this.classpath = classpath;
    }
1306#public ArtifactScopeEnum getScope()
    {
        return scope;
    }
1307#public void setScope( ArtifactScopeEnum scope )
    {
        this.scope = scope;
    }
1308#// -------------------------------------------------------------------------------------------
    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder( 256 );
        sb.append( "[scope=" + scope.getScope() );
        if ( classpath != null )
        {
            for ( ArtifactMetadata md : classpath )
            {
                sb.append( ": " + md.toString() + '{' + md.getArtifactUri() + '}' );
            }
        }
        sb.append( ']' );
        return sb.toString();
    }
1309#public MetadataGraphVertex( ArtifactMetadata md )
    {
        super();
        this.md = md;
    }
1310#public MetadataGraphVertex( ArtifactMetadata md, boolean compareVersion, boolean compareScope )
    {
        this( md );
        this.compareVersion = compareVersion;
        this.compareScope = compareScope;
    }
1311#public ArtifactMetadata getMd()
    {
        return md;
    }
1312#public void setMd( ArtifactMetadata md )
    {
        this.md = md;
    }
1313#// ---------------------------------------------------------------------
    public boolean isCompareVersion()
    {
        return compareVersion;
    }
1314#public void setCompareVersion( boolean compareVersion )
    {
        this.compareVersion = compareVersion;
    }
1315#public boolean isCompareScope()
    {
        return compareScope;
    }
1316#public void setCompareScope( boolean compareScope )
    {
        this.compareScope = compareScope;
    }
1317#// ---------------------------------------------------------------------
    @Override
    public String toString()
    {
        return "[" + ( md == null ? "no metadata" : md.toString() ) + "]";
    }
1318#// ---------------------------------------------------------------------
    private static int compareStrings( String s1, String s2 )
    {
        if ( s1 == null && s2 == null )
        {
            return 0;
        }

        if ( s1 == null && s2 != null )
        {
            return -1;
        }

        if ( s1 != null && s2 == null )
        {
            return 1;
        }

        return s1.compareTo( s2 );
    }
1319#// ---------------------------------------------------------------------
    public int compareTo( MetadataGraphVertex vertex )
    {
        if ( vertex == null || vertex.getMd() == null )
        {
            return 1;
        }

        ArtifactMetadata vmd = vertex.getMd();

        if ( vmd == null )
        {
            if ( md == null )
            {
                return 0;
            }
            else
            {
                return 1;
            }
        }

        int g = compareStrings( md.groupId, vmd.groupId );

        if ( g == 0 )
        {
            int a = compareStrings( md.artifactId, vmd.artifactId );
            if ( a == 0 )
            {
                if ( compareVersion )
                {
                    int v = compareStrings( md.version, vmd.version );
                    if ( v == 0 )
                    {
                        if ( compareScope )
                        {
                            String s1 = ArtifactScopeEnum.checkScope( md.artifactScope ).getScope();
                            String s2 = ArtifactScopeEnum.checkScope( vmd.artifactScope ).getScope();
                            return s1.compareTo( s2 );
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    else
                    {
                        return v;
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return a;
            }
        }

        return g;
    }
1320#// ---------------------------------------------------------------------
    @Override
    public boolean equals( Object vo )
    {
        if ( vo == null || !( vo instanceof MetadataGraphVertex ) )
        {
            return false;
        }
        return compareTo( (MetadataGraphVertex) vo ) == 0;
    }
1321#// ---------------------------------------------------------------------

    @Override
    public int hashCode()
    {
        if ( md == null )
        {
            return super.hashCode();
        }
        StringBuilder hashString = new StringBuilder( 128 );
        hashString.append( md.groupId + "|" );
        hashString.append( md.artifactId + "|" );

        if ( compareVersion )
        {
            hashString.append( md.version + "|" );
        }

        if ( compareScope )
        {
            hashString.append( md.getArtifactScope() + "|" );
        }

        return hashString.toString().hashCode();

        // BASE64Encoder b64 = new BASE64Encoder();
        // return b64.encode( hashString.toString().getBytes() ).hashCode();
    }
1322#//----------------------------------------------------------------------------------------------------
    public ClasspathContainer transform( MetadataGraph dirtyGraph, ArtifactScopeEnum scope, boolean resolve )
        throws MetadataGraphTransformationException
    {
        try
        {
            if ( dirtyGraph == null || dirtyGraph.isEmpty() )
            {
                return null;
            }

            MetadataGraph cleanGraph = conflictResolver.resolveConflicts( dirtyGraph, scope );

            if ( cleanGraph == null || cleanGraph.isEmpty() )
            {
                return null;
            }

            ClasspathContainer cpc = new ClasspathContainer( scope );
            if ( cleanGraph.isEmptyEdges() )
            {
                // single entry in the classpath, populated from itself
                ArtifactMetadata amd = cleanGraph.getEntry().getMd();
                cpc.add( amd );
            }
            else
            {
                ClasspathGraphVisitor v = new ClasspathGraphVisitor( cleanGraph, cpc );
                MetadataGraphVertex entry = cleanGraph.getEntry();
                ArtifactMetadata md = entry.getMd();
                // entry point
                v.visit( entry ); // , md.getVersion(), md.getArtifactUri() );
            }

            return cpc;
        }
        catch ( GraphConflictResolutionException e )
        {
            throw new MetadataGraphTransformationException( e );
        }
    }
1323#// -----------------------------------------------------------------------
        protected ClasspathGraphVisitor( MetadataGraph cleanGraph, ClasspathContainer cpc )
        {
            this.cpc = cpc;
            this.graph = cleanGraph;

            visited = new ArrayList<MetadataGraphVertex>( cleanGraph.getVertices().size() );
        }
1324#// -----------------------------------------------------------------------
        protected void visit( MetadataGraphVertex node ) // , String version, String artifactUri )
        {
            ArtifactMetadata md = node.getMd();
            if ( visited.contains( node ) )
            {
                return;
            }

            cpc.add( md );
//
//            TreeSet<MetadataGraphEdge> deps = new TreeSet<MetadataGraphEdge>(
//                        new Comparator<MetadataGraphEdge>()
//                        {
//                            public int compare( MetadataGraphEdge e1
//                                              , MetadataGraphEdge e2
//                                              )
//                            {
//                                if( e1.getDepth() == e2.getDepth() )
//                                {
//                                    if( e2.getPomOrder() == e1.getPomOrder() )
//                                        return e1.getTarget().toString().compareTo(e2.getTarget().toString() );
//
//                                    return e2.getPomOrder() - e1.getPomOrder();
//                                }
//
//                                return e2.getDepth() - e1.getDepth();
//                            }
//                        }
//                    );

            List<MetadataGraphEdge> exits = graph.getExcidentEdges( node );

            if ( exits != null && exits.size() > 0 )
            {
                MetadataGraphEdge[] sortedExits = exits.toArray( new MetadataGraphEdge[exits.size()] );
                Arrays.sort( sortedExits
                        ,
                        new Comparator<MetadataGraphEdge>()
                        {
                            public int compare( MetadataGraphEdge e1
                                            , MetadataGraphEdge e2
                                            )
                            {
                                if ( e1.getDepth() == e2.getDepth() )
                                {
                                    if ( e2.getPomOrder() == e1.getPomOrder() )
                                    {
                                        return e1.getTarget().toString().compareTo( e2.getTarget().toString() );
                                    }
                                    return e2.getPomOrder() - e1.getPomOrder();
                                }

                                return e2.getDepth() - e1.getDepth();
                            }
                        }
                );

                for ( MetadataGraphEdge e : sortedExits )
                {
                    MetadataGraphVertex targetNode = e.getTarget();
                    targetNode.getMd().setArtifactScope( e.getScope() );
                    targetNode.getMd().setWhy( e.getSource().getMd().toString() );
                    visit( targetNode );
                }
            }

        }
1325#//------------------------------------------------------------------
    /**
     *
     */
    public ArtifactMetadata( String name )
    {
        if ( name == null )
        {
            return;
        }
        int ind1 = name.indexOf( ':' );
        int ind2 = name.lastIndexOf( ':' );

        if ( ind1 == -1 || ind2 == -1 )
        {
            return;
        }

        this.groupId = name.substring( 0, ind1 );
        if ( ind1 == ind2 )
        {
            this.artifactId = name.substring( ind1 + 1 );
        }
        else
        {
            this.artifactId = name.substring( ind1 + 1, ind2 );
            this.version = name.substring( ind2 + 1 );
        }
    }
1326#// ------------------------------------------------------------------
    public ArtifactMetadata( String groupId, String name, String version )
    {
        this( groupId, name, version, null );
    }
1327#//------------------------------------------------------------------
    public ArtifactMetadata( String groupId, String name, String version, String type )
    {
        this( groupId, name, version, type, null );
    }
1328#//------------------------------------------------------------------
    public ArtifactMetadata( String groupId, String name, String version, String type, ArtifactScopeEnum artifactScope )
    {
        this( groupId, name, version, type, artifactScope, null );
    }
1329#//------------------------------------------------------------------
    public ArtifactMetadata( String groupId, String name, String version, String type, ArtifactScopeEnum artifactScope,
                             String classifier )
    {
        this( groupId, name, version, type, artifactScope, classifier, null );
    }
1330#//------------------------------------------------------------------
    public ArtifactMetadata( String groupId, String name, String version, String type, ArtifactScopeEnum artifactScope,
                             String classifier, String artifactUri )
    {
        this( groupId, name, version, type, artifactScope, classifier, artifactUri, null, true, null );
    }
1331#//------------------------------------------------------------------
    public ArtifactMetadata( String groupId, String name, String version, String type, ArtifactScopeEnum artifactScope,
                             String classifier, String artifactUri, String why, boolean resolved, String error )
    {
        this.groupId = groupId;
        this.artifactId = name;
        this.version = version;
        this.type = type;
        this.artifactScope = artifactScope;
        this.classifier = classifier;
        this.artifactUri = artifactUri;
        this.why = why;
        this.resolved = resolved;
        this.error = error;
    }
1332#//------------------------------------------------------------------
    public ArtifactMetadata( String groupId, String name, String version, String type, String scopeString,
                             String classifier, String artifactUri, String why, boolean resolved, String error )
    {
        this( groupId, name, version, type,
              scopeString == null ? ArtifactScopeEnum.DEFAULT_SCOPE : ArtifactScopeEnum.valueOf( scopeString ),
              classifier, artifactUri, why, resolved, error );
    }
1333#//------------------------------------------------------------------
    public ArtifactMetadata( Artifact af )
    {
        /*
        if ( af != null )
        {
            init( af );
        }
        */
    }
1334#//------------------------------------------------------------------
//    public void init( ArtifactMetadata af )
//    {
//        setGroupId( af.getGroupId() );
//        setArtifactId( af.getArtifactId() );
//        setVersion( af.getVersion() );
//        setType( af.getType() );
//        setScope( af.getScope() );
//        setClassifier( af.getClassifier() );
//        //setUri( af.getDownloadUrl() );
//
//        this.resolved = af.isResolved();
//    }

    //------------------------------------------------------------------
    @Override
    public String toString()
    {
        return groupId + ":" + artifactId + ":" + version;
    }
1335#//------------------------------------------------------------------
    public String toDomainString()
    {
        return groupId + ":" + artifactId;
    }
1336#//------------------------------------------------------------------
    public String getGroupId()
    {
        return groupId;
    }
1337#public void setGroupId( String groupId )
    {
        this.groupId = groupId;
    }
1338#public String getArtifactId()
    {
        return artifactId;
    }
1339#public void setArtifactId( String name )
    {
        this.artifactId = name;
    }
1340#public String getVersion()
    {
        return version;
    }
1341#public void setVersion( String version )
    {
        this.version = version;
    }
1342#public String getType()
    {
        return type;
    }
1343#public String getCheckedType()
    {
        return type == null ? "jar" : type;
    }
1344#public void setType( String type )
    {
        this.type = type;
    }
1345#public ArtifactScopeEnum getArtifactScope()
    {
        return artifactScope == null ? ArtifactScopeEnum.DEFAULT_SCOPE : artifactScope;
    }
1346#public void setArtifactScope( ArtifactScopeEnum artifactScope )
    {
        this.artifactScope = artifactScope;
    }
1347#public void setScope( String scope )
    {
        this.artifactScope = scope == null ? ArtifactScopeEnum.DEFAULT_SCOPE : ArtifactScopeEnum.valueOf( scope );
    }
1348#public String getClassifier()
    {
        return classifier;
    }
1349#public void setClassifier( String classifier )
    {
        this.classifier = classifier;
    }
1350#public boolean isResolved()
    {
        return resolved;
    }
1351#public void setResolved( boolean resolved )
    {
        this.resolved = resolved;
    }
1352#public String getUri()
    {
        return uri;
    }
1353#public void setUri( String uri )
    {
        this.uri = uri;
    }
1354#public String getScope()
    {
        return getArtifactScope().getScope();
    }
1355#public ArtifactScopeEnum getScopeAsEnum()
    {
        return artifactScope == null ? ArtifactScopeEnum.DEFAULT_SCOPE : artifactScope;
    }
1356#public boolean isArtifactExists()
    {
        return artifactExists;
    }
1357#public void setArtifactExists(boolean artifactExists)
    {
        this.artifactExists = artifactExists;
    }
1358#public Collection<ArtifactMetadata> getDependencies()
    {
        return dependencies;
    }
1359#public void setDependencies(Collection<ArtifactMetadata> dependencies)
    {
        this.dependencies = dependencies;
    }
1360#public String getArtifactUri()
    {
        return artifactUri;
    }
1361#public void setArtifactUri(String artifactUri)
    {
        this.artifactUri = artifactUri;
    }
1362#public String getWhy()
    {
        return why;
    }
1363#public void setWhy(String why)
    {
        this.why = why;
    }
1364#//-------------------------------------------------------------------
    public String getError()
    {
        return error;
    }
1365#public void setError(String error)
    {
        this.error = error;
    }
1366#public boolean isError()
    {
        return error == null;
    }
1367#//------------------------------------------------------------------
    public String getDependencyConflictId()
    {
        return groupId + ":" + artifactId;
    }
1368#//----------------------------------------------------------------------------
    public MetadataGraphEdge( String version, boolean resolved, ArtifactScopeEnum scope, String artifactUri, int depth,
                              int pomOrder )
    {
        super();
        this.version = version;
        this.scope = scope;
        this.artifactUri = artifactUri;
        this.depth = depth;
        this.resolved = resolved;
        this.pomOrder = pomOrder;
    }
1369#//----------------------------------------------------------------------------
    /**
     * helper for equals
     */
    private static boolean objectsEqual( Object o1, Object o2 )
    {
        if ( o1 == null && o2 == null )
        {
            return true;
        }
        if ( ( o1 == null && o2 != null ) || ( o1 != null && o2 == null ) )
        {
            return false;
        }
        return o1.equals( o2 );
    }
1370#//----------------------------------------------------------------------------
    /**
     * used to eliminate exact duplicates in the edge list
     */
    @Override
    public boolean equals( Object o )
    {
        if ( o instanceof MetadataGraphEdge )
        {
            MetadataGraphEdge e = (MetadataGraphEdge) o;

            return objectsEqual( version, e.version )
                && ArtifactScopeEnum.checkScope( scope ).getScope().equals( ArtifactScopeEnum.checkScope( e.scope ).getScope() )
                && depth == e.depth;
        }
        return false;
    }
1371#//----------------------------------------------------------------------------
    public String getVersion()
    {
        return version;
    }
1372#public void setVersion( String version )
    {
        this.version = version;
    }
1373#public ArtifactScopeEnum getScope()
    {
        return scope;
    }
1374#public void setScope( ArtifactScopeEnum scope )
    {
        this.scope = scope;
    }
1375#public int getDepth()
    {
        return depth;
    }
1376#public void setDepth( int depth )
    {
        this.depth = depth;
    }
1377#public boolean isResolved()
	{
		return resolved;
	}
1378#public void setResolved( boolean resolved )
    {
        this.resolved = resolved;
    }
1379#public int getPomOrder()
    {
        return pomOrder;
    }
1380#public void setPomOrder( int pomOrder )
    {
        this.pomOrder = pomOrder;
    }
1381#public String getArtifactUri()
    {
        return artifactUri;
    }
1382#public void setArtifactUri( String artifactUri )
    {
        this.artifactUri = artifactUri;
    }
1383#public MetadataGraphVertex getSource()
    {
        return source;
    }
1384#public void setSource( MetadataGraphVertex source )
    {
        this.source = source;
    }
1385#public MetadataGraphVertex getTarget()
    {
        return target;
    }
1386#public void setTarget( MetadataGraphVertex target )
    {
        this.target = target;
    }
1387#@Override
    public String toString()
    {
        return "[ " + "FROM:("
            + ( source == null ? "no source" : ( source.md == null ? "no source MD" : source.md.toString() ) ) + ") "
            + "TO:(" + ( target == null ? "no target" : ( target.md == null ? "no target MD" : target.md.toString() ) )
            + ") " + "version=" + version + ", scope=" + ( scope == null ? "null" : scope.getScope() ) + ", depth="
            + depth + "]";
    }
1388#/**
     * Transform Graph into a Collection of metadata objects that
     * could serve as a classpath for a particular scope
     *
     * @param dirtyGraph - dependency graph
     * @param scope - which classpath to extract
     * @param resolve - whether to resolve artifacts.
     * @return Collection of metadata objects in the linked subgraph of the graph which
     *             contains the graph.getEntry() vertice
     */
    ClasspathContainer transform( MetadataGraph dirtyGraph, ArtifactScopeEnum scope, boolean resolve )
        throws MetadataGraphTransformationException;
1389#// Constructor
    MetadataResolutionRequestTypeEnum( int id )
    {
        this.id = id;
    }
1390#int getId()
    {
        return id;
    }
1391#MetadataResolution retrieve( ArtifactMetadata artifact, ArtifactRepository localRepository,
                                 List<ArtifactRepository> remoteRepositories )
        throws MetadataRetrievalException;
1392#//-------------------------------------------------------------------
    public MetadataResolution( ArtifactMetadata artifactMetadata )
    {
        this.artifactMetadata = artifactMetadata;
    }
1393#//-------------------------------------------------------------------
    public MetadataResolution( ArtifactMetadata artifactMetadata, Collection<ArtifactRepository> metadataRepositories )
    {
        this( artifactMetadata );
        this.metadataRepositories = metadataRepositories;
    }
1394#//-------------------------------------------------------------------
    public Collection<ArtifactRepository> getMetadataRepositories()
    {
        return metadataRepositories;
    }
1395#public void setMetadataRepositories( Collection<ArtifactRepository> metadataRepositories )
    {
        this.metadataRepositories = metadataRepositories;
    }
1396#//-------------------------------------------------------------------
    public ArtifactMetadata getArtifactMetadata()
    {
        return artifactMetadata;
    }
1397#public void setArtifactMetadata(ArtifactMetadata artifactMetadata)
    {
        this.artifactMetadata = artifactMetadata;
    }
1398#public int getNChildren()
    {
        return nChildren;
    }
1399#public void setNChildren( int children )
    {
        nChildren = children;
    }
1400#//------------------------------------------------------------------------
    public MetadataTreeNode()
    {
    }
1401#//------------------------------------------------------------------------
    public MetadataTreeNode( ArtifactMetadata md, MetadataTreeNode parent, boolean resolved, ArtifactScopeEnum scope )
    {
        if ( md != null )
        {
            md.setArtifactScope( ArtifactScopeEnum.checkScope( scope ) );
            md.setResolved( resolved );
        }

        this.md = md;
        this.parent = parent;
    }
1402#//------------------------------------------------------------------------
    public MetadataTreeNode( Artifact af, MetadataTreeNode parent, boolean resolved, ArtifactScopeEnum scope )
    {
        this( new ArtifactMetadata( af ), parent, resolved, scope );
    }
1403#// ------------------------------------------------------------------------
    public void addChild( int index, MetadataTreeNode kid )
    {
        if ( kid == null )
        {
            return;
        }

        if ( children == null )
        {
            children = new MetadataTreeNode[nChildren];
        }

        children[index % nChildren] = kid;
    }
1404#//------------------------------------------------------------------
    @Override
    public String toString()
    {
        return md == null ? "no metadata" : md.toString();
    }
1405#//------------------------------------------------------------------
    public String graphHash()
        throws MetadataResolutionException
    {
        if ( md == null )
        {
            throw new MetadataResolutionException( "treenode without metadata, parent: "
                + ( parent == null ? "null" : parent.toString() ) );
        }

        return md.groupId + ":" + md.artifactId;
    }
1406#//------------------------------------------------------------------------
    public boolean hasChildren()
    {
        return children != null;
    }
1407#//------------------------------------------------------------------------
    public ArtifactMetadata getMd()
    {
        return md;
    }
1408#public void setMd( ArtifactMetadata md )
    {
        this.md = md;
    }
1409#public MetadataTreeNode getParent()
    {
        return parent;
    }
1410#public void setParent( MetadataTreeNode parent )
    {
        this.parent = parent;
    }
1411#public MetadataTreeNode[] getChildren()
    {
        return children;
    }
1412#public void setChildren( MetadataTreeNode[] children )
    {
        this.children = children;
    }
1413#public static Map load()
        throws ExpressionDocumentationException
    {
        if ( expressionDocumentation == null )
        {
            expressionDocumentation = new HashMap();

            ClassLoader docLoader = initializeDocLoader();

            for ( int i = 0; i < EXPRESSION_ROOTS.length; i++ )
            {
                InputStream docStream = null;
                try
                {
                    docStream = docLoader
                        .getResourceAsStream( EXPRESSION_DOCO_ROOTPATH + EXPRESSION_ROOTS[i] + ".paramdoc.xml" );

                    if ( docStream != null )
                    {
                        Map doco = parseExpressionDocumentation( docStream );

                        expressionDocumentation.putAll( doco );
                    }
                }
                catch ( IOException e )
                {
                    throw new ExpressionDocumentationException( "Failed to read documentation for expression root: "
                        + EXPRESSION_ROOTS[i], e );
                }
                catch ( XmlPullParserException e )
                {
                    throw new ExpressionDocumentationException( "Failed to parse documentation for expression root: "
                        + EXPRESSION_ROOTS[i], e );
                }
                finally
                {
                    IOUtil.close( docStream );
                }
            }
        }

        return expressionDocumentation;
    }
1414#/**
     * <expressions>
     *   <expression>
     *     <syntax>project.distributionManagementArtifactRepository</syntax>
     *     <origin><![CDATA[
     *   <distributionManagement>
     *     <repository>
     *       <id>some-repo</id>
     *       <url>scp://host/path</url>
     *     </repository>
     *     <snapshotRepository>
     *       <id>some-snap-repo</id>
     *       <url>scp://host/snapshot-path</url>
     *     </snapshotRepository>
     *   </distributionManagement>
     *   ]]></origin>
     *     <usage><![CDATA[
     *   The repositories onto which artifacts should be deployed.
     *   One is for releases, the other for snapshots.
     *   ]]></usage>
     *   </expression>
     * <expressions>
     * @throws IOException
     * @throws XmlPullParserException
     */
    private static Map parseExpressionDocumentation( InputStream docStream )
        throws IOException, XmlPullParserException
    {
        Reader reader = new BufferedReader( ReaderFactory.newXmlReader( docStream ) );

        ParamdocXpp3Reader paramdocReader = new ParamdocXpp3Reader();

        ExpressionDocumentation documentation = paramdocReader.read( reader, true );

        List expressions = documentation.getExpressions();

        Map bySyntax = new HashMap();

        if ( expressions != null && !expressions.isEmpty() )
        {
            for ( Iterator it = expressions.iterator(); it.hasNext(); )
            {
                Expression expr = (Expression) it.next();

                bySyntax.put( expr.getSyntax(), expr );
            }
        }

        return bySyntax;
    }
1415#private static ClassLoader initializeDocLoader()
        throws ExpressionDocumentationException
    {
        String myResourcePath = ExpressionDocumenter.class.getName().replace( '.', '/' ) + ".class";

        URL myResource = ExpressionDocumenter.class.getClassLoader().getResource( myResourcePath );

        String myClasspathEntry = myResource.getPath();

        myClasspathEntry = myClasspathEntry.substring( 0, myClasspathEntry.length() - ( myResourcePath.length() + 2 ) );

        if ( myClasspathEntry.startsWith( "file:" ) )
        {
            myClasspathEntry = myClasspathEntry.substring( "file:".length() );
        }

        URL docResource;
        try
        {
            docResource = new File( myClasspathEntry ).toURL();
        }
        catch ( MalformedURLException e )
        {
            throw new ExpressionDocumentationException(
                                                        "Cannot construct expression documentation classpath resource base.",
                                                        e );
        }

        return new URLClassLoader( new URL[] { docResource } );
    }
1416#public ExpressionDocumentationException( String message, Throwable cause )
    {
        super( message, cause );
    }
1417#public ExpressionDocumentationException( String message )
    {
        super( message );
    }
1418#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();
        artifactFactory = lookup( ArtifactFactory.class);        
        artifactRepositoryFactory = lookup( ArtifactRepositoryFactory.class );

        RepositorySystemSession repoSession = initRepoSession();
        MavenSession session =
            new MavenSession( getContainer(), repoSession, new DefaultMavenExecutionRequest(),
                              new DefaultMavenExecutionResult() );

        LegacySupport legacySupport = lookup(LegacySupport.class);
        legacySupport.setSession( session );
    }
1419#@Override
    protected void tearDown()
        throws Exception
    {
        release( artifactFactory );
        
        super.tearDown();
    }
1420#protected abstract String component();
1421#/**
     * Return an existing file, not a directory - causes creation to fail.
     * 
     * @throws Exception
     */
    protected ArtifactRepository badLocalRepository()
        throws Exception
    {
        String path = "target/test-repositories/" + component() + "/bad-local-repository";

        File f = new File( getBasedir(), path );

        f.createNewFile();

        ArtifactRepositoryLayout repoLayout =
            (ArtifactRepositoryLayout) lookup( ArtifactRepositoryLayout.ROLE, "default" );

        return artifactRepositoryFactory.createArtifactRepository( "test", "file://" + f.getPath(), repoLayout, null, null );
    }
1422#protected String getRepositoryLayout()
    {
        return "default";
    }
1423#protected ArtifactRepository localRepository()
        throws Exception
    {
        String path = "target/test-repositories/" + component() + "/local-repository";

        File f = new File( getBasedir(), path );

        ArtifactRepositoryLayout repoLayout =
            (ArtifactRepositoryLayout) lookup( ArtifactRepositoryLayout.ROLE, "default" );

        return artifactRepositoryFactory.createArtifactRepository( "local", "file://" + f.getPath(), repoLayout, null, null );
    }
1424#protected ArtifactRepository remoteRepository()
        throws Exception
    {
        String path = "target/test-repositories/" + component() + "/remote-repository";

        File f = new File( getBasedir(), path );

        ArtifactRepositoryLayout repoLayout =
            (ArtifactRepositoryLayout) lookup( ArtifactRepositoryLayout.ROLE, "default" );

        return artifactRepositoryFactory.createArtifactRepository( "test", "file://" + f.getPath(), repoLayout,
                                              new ArtifactRepositoryPolicy(), new ArtifactRepositoryPolicy() );
    }
1425#protected ArtifactRepository badRemoteRepository()
        throws Exception
    {
        ArtifactRepositoryLayout repoLayout =
            (ArtifactRepositoryLayout) lookup( ArtifactRepositoryLayout.ROLE, "default" );

        return artifactRepositoryFactory.createArtifactRepository( "test", "http://foo.bar/repository", repoLayout, null, null );
    }
1426#protected void assertRemoteArtifactPresent( Artifact artifact )
        throws Exception
    {
        ArtifactRepository remoteRepo = remoteRepository();

        String path = remoteRepo.pathOf( artifact );

        File file = new File( remoteRepo.getBasedir(), path );

        if ( !file.exists() )
        {
            fail( "Remote artifact " + file + " should be present." );
        }
    }
1427#protected void assertLocalArtifactPresent( Artifact artifact )
        throws Exception
    {
        ArtifactRepository localRepo = localRepository();

        String path = localRepo.pathOf( artifact );

        File file = new File( localRepo.getBasedir(), path );

        if ( !file.exists() )
        {
            fail( "Local artifact " + file + " should be present." );
        }
    }
1428#protected void assertRemoteArtifactNotPresent( Artifact artifact )
        throws Exception
    {
        ArtifactRepository remoteRepo = remoteRepository();

        String path = remoteRepo.pathOf( artifact );

        File file = new File( remoteRepo.getBasedir(), path );

        if ( file.exists() )
        {
            fail( "Remote artifact " + file + " should not be present." );
        }
    }
1429#protected void assertLocalArtifactNotPresent( Artifact artifact )
        throws Exception
    {
        ArtifactRepository localRepo = localRepository();

        String path = localRepo.pathOf( artifact );

        File file = new File( localRepo.getBasedir(), path );

        if ( file.exists() )
        {
            fail( "Local artifact " + file + " should not be present." );
        }
    }
1430#// ----------------------------------------------------------------------
    //
    // ----------------------------------------------------------------------

    protected List<ArtifactRepository> remoteRepositories()
        throws Exception
    {
        List<ArtifactRepository> remoteRepositories = new ArrayList<ArtifactRepository>();

        remoteRepositories.add( remoteRepository() );

        return remoteRepositories;
    }
1431#// ----------------------------------------------------------------------
    // Test artifact generation for unit tests
    // ----------------------------------------------------------------------

    protected Artifact createLocalArtifact( String artifactId, String version )
        throws Exception
    {
        Artifact artifact = createArtifact( artifactId, version );

        createArtifact( artifact, localRepository() );

        return artifact;
    }
1432#protected Artifact createRemoteArtifact( String artifactId, String version )
        throws Exception
    {
        Artifact artifact = createArtifact( artifactId, version );

        createArtifact( artifact, remoteRepository() );

        return artifact;
    }
1433#protected void createLocalArtifact( Artifact artifact )
        throws Exception
    {
        createArtifact( artifact, localRepository() );
    }
1434#protected void createRemoteArtifact( Artifact artifact )
        throws Exception
    {
        createArtifact( artifact, remoteRepository() );
    }
1435#protected void createArtifact( Artifact artifact, ArtifactRepository repository )
        throws Exception
    {
        String path = repository.pathOf( artifact );

        File artifactFile = new File( repository.getBasedir(), path );

        if ( !artifactFile.getParentFile().exists() )
        {
            artifactFile.getParentFile().mkdirs();
        }

        Writer writer = new OutputStreamWriter( new FileOutputStream( artifactFile ), "ISO-8859-1" );

        writer.write( artifact.getId() );

        writer.close();
    }
1436#protected Artifact createArtifact( String artifactId, String version )
        throws Exception
    {
        return createArtifact( artifactId, version, "jar" );
    }
1437#protected Artifact createArtifact( String artifactId, String version, String type )
        throws Exception
    {
        return createArtifact( "org.apache.maven", artifactId, version, type );
    }
1438#protected Artifact createArtifact( String groupId, String artifactId, String version, String type )
        throws Exception
    {
        Artifact a = artifactFactory.createBuildArtifact( groupId, artifactId, version, type );
                
        return a;
    }
1439#protected void deleteLocalArtifact( Artifact artifact )
        throws Exception
    {
        deleteArtifact( artifact, localRepository() );
    }
1440#protected void deleteArtifact( Artifact artifact, ArtifactRepository repository )
        throws Exception
    {
        String path = repository.pathOf( artifact );

        File artifactFile = new File( repository.getBasedir(), path );

        if ( artifactFile.exists() )
        {
            if ( !artifactFile.delete() )
            {
                throw new IOException( "Failure while attempting to delete artifact " + artifactFile );
            }
        }
    }
1441#protected RepositorySystemSession initRepoSession()
        throws Exception
    {
        DefaultRepositorySystemSession session = new DefaultRepositorySystemSession();
        session.setIgnoreMissingArtifactDescriptor( true );
        session.setIgnoreInvalidArtifactDescriptor( true );
        DependencyTraverser depTraverser = new FatArtifactTraverser();
        session.setDependencyTraverser( depTraverser );

        DependencyManager depManager = new ClassicDependencyManager();
        session.setDependencyManager( depManager );

        DependencySelector depFilter =
            new AndDependencySelector( new ScopeDependencySelector( "test", "provided" ),
                                       new OptionalDependencySelector(), new ExclusionDependencySelector() );
        session.setDependencySelector( depFilter );

        DependencyGraphTransformer transformer =
            new ChainedDependencyGraphTransformer( new ConflictMarker(), new JavaEffectiveScopeCalculator(),
                                                   new NearestVersionConflictResolver(),
                                                   new JavaDependencyContextRefiner() );
        session.setDependencyGraphTransformer( transformer );

        session.setLocalRepositoryManager( new SimpleLocalRepositoryManager( localRepository().getBasedir() ) );

        return session;
    }
1442#protected void setUp()
        throws Exception
    {
        super.setUp();
        artifactHandler = new ArtifactHandlerMock();
        versionRange = VersionRange.createFromVersion( version );
        artifact = new DefaultArtifact( groupId, artifactId, versionRange, scope, type, classifier, artifactHandler );

        snapshotVersionRange = VersionRange.createFromVersion( snapshotResolvedVersion );
        snapshotArtifact = new DefaultArtifact( groupId, artifactId, snapshotVersionRange, scope, type, classifier, artifactHandler );
    }
1443#public void testGetVersionReturnsResolvedVersionOnSnapshot()
    {
        assertEquals( snapshotResolvedVersion, snapshotArtifact.getVersion() );

        // this is FOUL!
//        snapshotArtifact.isSnapshot();

        assertEquals( snapshotSpecVersion, snapshotArtifact.getBaseVersion() );
    }
1444#public void testGetDependencyConflictId()
    {
        assertEquals( groupId + ":" + artifactId + ":" + type + ":" + classifier, artifact.getDependencyConflictId() );
    }
1445#public void testGetDependencyConflictIdNullGroupId()
    {
        artifact.setGroupId( null );
        assertEquals( null + ":" + artifactId + ":" + type + ":" + classifier, artifact.getDependencyConflictId() );
    }
1446#public void testGetDependencyConflictIdNullClassifier()
    {
        artifact = new DefaultArtifact( groupId, artifactId, versionRange, scope, type, null, artifactHandler );
        assertEquals( groupId + ":" + artifactId + ":" + type, artifact.getDependencyConflictId() );
    }
1447#public void testGetDependencyConflictIdNullScope()
    {
        artifact.setScope( null );
        assertEquals( groupId + ":" + artifactId + ":" + type + ":" + classifier, artifact.getDependencyConflictId() );
    }
1448#public void testToString()
    {
        assertEquals( groupId + ":" + artifactId + ":" + type + ":" + classifier + ":" + version + ":" + scope,
                      artifact.toString() );
    }
1449#public void testToStringNullGroupId()
    {
        artifact.setGroupId( null );
        assertEquals( artifactId + ":" + type + ":" + classifier + ":" + version + ":" + scope, artifact.toString() );
    }
1450#public void testToStringNullClassifier()
    {
        artifact = new DefaultArtifact( groupId, artifactId, versionRange, scope, type, null, artifactHandler );
        assertEquals( groupId + ":" + artifactId + ":" + type + ":" + version + ":" + scope, artifact.toString() );
    }
1451#public void testToStringNullScope()
    {
        artifact.setScope( null );
        assertEquals( groupId + ":" + artifactId + ":" + type + ":" + classifier + ":" + version, artifact.toString() );
    }
1452#public void testComparisonByVersion()
    {
        Artifact artifact1 = new DefaultArtifact( groupId, artifactId, VersionRange.createFromVersion( "5.0" ), scope,
                                                  type, classifier, artifactHandler );
        Artifact artifact2 = new DefaultArtifact( groupId, artifactId, VersionRange.createFromVersion( "12.0" ), scope,
                                                  type, classifier, artifactHandler );

        assertTrue( artifact1.compareTo( artifact2 ) < 0 );
        assertTrue( artifact2.compareTo( artifact1 ) > 0 );

        Artifact artifact = new DefaultArtifact( groupId, artifactId, VersionRange.createFromVersion( "5.0" ), scope,
                                                  type, classifier, artifactHandler );
        assertTrue( artifact.compareTo( artifact1 ) == 0 );
        assertTrue( artifact1.compareTo( artifact ) == 0 );
    }
1453#public void testNonResolvedVersionRangeConsistentlyYieldsNullVersions()
        throws Exception
    {
        VersionRange vr = VersionRange.createFromVersionSpec( "[1.0,2.0)" );
        artifact = new DefaultArtifact( groupId, artifactId, vr, scope, type, null, artifactHandler );
        assertEquals( null, artifact.getVersion() );
        assertEquals( null, artifact.getBaseVersion() );
    }
1454#private Artifact newArtifact( String aid )
    {
        return new DefaultArtifact( "group", aid, VersionRange.createFromVersion( "1.0" ), "test", "jar", "tests", null );
    }
1455#public void testIsSnapshot()
    {
        assertEquals( false, ArtifactUtils.isSnapshot( null ) );
        assertEquals( false, ArtifactUtils.isSnapshot( "" ) );
        assertEquals( false, ArtifactUtils.isSnapshot( "1.2.3" ) );
        assertEquals( true, ArtifactUtils.isSnapshot( "1.2.3-SNAPSHOT" ) );
        assertEquals( true, ArtifactUtils.isSnapshot( "1.2.3-snapshot" ) );
        assertEquals( true, ArtifactUtils.isSnapshot( "1.2.3-20090413.094722-2" ) );
    }
1456#public void testToSnapshotVersion()
    {
        assertEquals( "1.2.3", ArtifactUtils.toSnapshotVersion( "1.2.3" ) );
        assertEquals( "1.2.3-SNAPSHOT", ArtifactUtils.toSnapshotVersion( "1.2.3-SNAPSHOT" ) );
        assertEquals( "1.2.3-SNAPSHOT", ArtifactUtils.toSnapshotVersion( "1.2.3-20090413.094722-2" ) );
    }
1457#/**
     * Tests that the ordering of the map resembles the ordering of the input collection of artifacts.
     */
    public void testArtifactMapByVersionlessIdOrdering()
        throws Exception
    {
        List<Artifact> list = new ArrayList<Artifact>();
        list.add( newArtifact( "b" ) );
        list.add( newArtifact( "a" ) );
        list.add( newArtifact( "c" ) );
        list.add( newArtifact( "e" ) );
        list.add( newArtifact( "d" ) );

        Map<String, Artifact> map = ArtifactUtils.artifactMapByVersionlessId( list );
        assertNotNull( map );
        assertEquals( list, new ArrayList<Artifact>( map.values() ) );
    }
1458#protected void setUp()
        throws Exception
    {
        super.setUp();

        artifactDeployer = (ArtifactDeployer) lookup( ArtifactDeployer.ROLE );
    }
1459#protected String component()
    {
        return "deployer";
    }
1460#public void testArtifactInstallation()
        throws Exception
    {
        String artifactBasedir = new File( getBasedir(), "src/test/resources/artifact-install" ).getAbsolutePath();

        Artifact artifact = createArtifact( "artifact", "1.0" );

        File file = new File( artifactBasedir, "artifact-1.0.jar" );
        assertEquals( "dummy", FileUtils.fileRead( file, "UTF-8" ).trim() );

        artifactDeployer.deploy( file, artifact, remoteRepository(), localRepository() );

        ArtifactRepository remoteRepository = remoteRepository();
        File deployedFile = new File( remoteRepository.getBasedir(), remoteRepository.pathOf( artifact ) );
        assertTrue( deployedFile.exists() );
        assertEquals( "dummy", FileUtils.fileRead( deployedFile, "UTF-8" ).trim() );
    }
1461#public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository,
                                     List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException
    {
        throw new UnsupportedOperationException( "Cannot retrieve metadata in this test case" );
    }
1462#public List<ArtifactVersion> retrieveAvailableVersions( Artifact artifact, ArtifactRepository localRepository,
                                                            List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException
    {
        return Collections.<ArtifactVersion>singletonList( new DefaultArtifactVersion( "10.1.3" ) );
    }
1463#public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository( Artifact artifact,
                                                                                    ArtifactRepository localRepository,
                                                                                    ArtifactRepository remoteRepository )
        throws ArtifactMetadataRetrievalException
    {
        return Collections.<ArtifactVersion>singletonList( new DefaultArtifactVersion( "10.1.3" ) );
    }
1464#public ResolutionGroup retrieve( MetadataResolutionRequest request )
        throws ArtifactMetadataRetrievalException
    {
        return retrieve( request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories() );
    }
1465#public void testPropagationOfSystemScopeRegardlessOfInheritedScope() throws Exception
    {
        ArtifactFactory factory = (ArtifactFactory) lookup( ArtifactFactory.ROLE );
        
        Artifact artifact = factory.createDependencyArtifact( "test-grp", "test-artifact", VersionRange.createFromVersion("1.0"), "type", null, "system", "provided" );
        Artifact artifact2 = factory.createDependencyArtifact( "test-grp", "test-artifact-2", VersionRange.createFromVersion("1.0"), "type", null, "system", "test" );
        Artifact artifact3 = factory.createDependencyArtifact( "test-grp", "test-artifact-3", VersionRange.createFromVersion("1.0"), "type", null, "system", "runtime" );
        Artifact artifact4 = factory.createDependencyArtifact( "test-grp", "test-artifact-4", VersionRange.createFromVersion("1.0"), "type", null, "system", "compile" );
        
        // this one should never happen in practice...
        Artifact artifact5 = factory.createDependencyArtifact( "test-grp", "test-artifact-5", VersionRange.createFromVersion("1.0"), "type", null, "system", "system" );
        
        assertEquals( "system", artifact.getScope() );
        assertEquals( "system", artifact2.getScope() );
        assertEquals( "system", artifact3.getScope() );
        assertEquals( "system", artifact4.getScope() );
        assertEquals( "system", artifact5.getScope() );
    }
1466#public void setExtension( String extension )
    {
        this.extension = extension;
    }
1467#public String getExtension()
    {
        return extension;
    }
1468#public void setDirectory( String directory )
    {
        this.directory = directory;
    }
1469#public String getDirectory()
    {
        return directory;
    }
1470#public void setClassifier( String classifier )
    {
        this.classifier = classifier;
    }
1471#public String getClassifier()
    {
        return classifier;
    }
1472#public void setPackaging( String packaging )
    {
        this.packaging = packaging;
    }
1473#public String getPackaging()
    {
        return packaging;
    }
1474#public void setIncludesDependencies( boolean includesDependencies )
    {
        this.includesDependencies = includesDependencies;
    }
1475#public boolean isIncludesDependencies()
    {
        return includesDependencies;
    }
1476#public void setLanguage( String language )
    {
        this.language = language;
    }
1477#public String getLanguage()
    {
        return language;
    }
1478#public void setAddedToClasspath( boolean addedToClasspath )
    {
        this.addedToClasspath = addedToClasspath;
    }
1479#public boolean isAddedToClasspath()
    {
        return addedToClasspath;
    }
1480#protected void setUp()
        throws Exception
    {
        super.setUp();

        artifactInstaller = (ArtifactInstaller) lookup( ArtifactInstaller.ROLE );
    }
1481#protected String component()
    {
        return "installer";
    }
1482#public void testArtifactInstallation()
        throws Exception
    {
        String artifactBasedir = new File( getBasedir(), "src/test/resources/artifact-install" ).getAbsolutePath();

        Artifact artifact = createArtifact( "artifact", "1.0" );

        File source = new File( artifactBasedir, "artifact-1.0.jar" );

        artifactInstaller.install( source, artifact, localRepository() );

        assertLocalArtifactPresent( artifact );
    }
1483#public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException
    {
        Set dependencies = new HashSet();

        if ( "g".equals( artifact.getArtifactId() ) )
        {
            Artifact a = null;
            try
            {
                a = factory.createBuildArtifact( "org.apache.maven", "h", "1.0", "jar" );
                dependencies.add( a );
            }
            catch ( Exception e )
            {
                throw new ArtifactMetadataRetrievalException( "Error retrieving metadata", e, a );
            }
        }
        
        if ( "i".equals( artifact.getArtifactId() ) )
        {
            Artifact a = null;
            try
            {
                a = factory.createBuildArtifact( "org.apache.maven", "j", "1.0-SNAPSHOT", "jar" );
                dependencies.add( a );
            }
            catch ( Exception e )
            {
                throw new ArtifactMetadataRetrievalException( "Error retrieving metadata", e, a );
            }
        }
        

        return new ResolutionGroup( artifact, dependencies, remoteRepositories );
    }
1484#public List<ArtifactVersion> retrieveAvailableVersions( Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException
    {
        throw new UnsupportedOperationException( "Cannot get available versions in this test case" );
    }
1485#public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository( Artifact artifact, ArtifactRepository localRepository, ArtifactRepository remoteRepository )
        throws ArtifactMetadataRetrievalException
    {
        throw new UnsupportedOperationException( "Cannot get available versions in this test case" );
    }
1486#public ResolutionGroup retrieve( MetadataResolutionRequest request )
        throws ArtifactMetadataRetrievalException
    {
        return retrieve( request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories() );
    }
1487#public List<ArtifactVersion> retrieveAvailableVersions( MetadataResolutionRequest request )
        throws ArtifactMetadataRetrievalException
    {
        return retrieveAvailableVersions( request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories() );
    }
1488#public void testHashCodeEquals()
    {
        MavenArtifactRepositorySubclass r1 = new MavenArtifactRepositorySubclass( "foo" );
        MavenArtifactRepositorySubclass r2 = new MavenArtifactRepositorySubclass( "foo" );
        MavenArtifactRepositorySubclass r3 = new MavenArtifactRepositorySubclass( "bar" );

        assertTrue( r1.hashCode() == r2.hashCode() );
        assertFalse( r1.hashCode() == r3.hashCode() );

        assertTrue( r1.equals( r2 ) );
        assertTrue( r2.equals( r1 ) );

        assertFalse( r1.equals( r3 ) );
        assertFalse( r3.equals( r1 ) );
    }
1489#public MavenArtifactRepositorySubclass(String id)
        {
            this.id = id;
        }
1490#@Override
        public String getId()
        {
            return id;
        }
1491#public List<String> getTransfers()
    {
        return transfers;
    }
1492#public void addTransfer( String name )
    {
        transfers.add( name );
    }
1493#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();

        artifactResolver = (DefaultArtifactResolver) lookup( ArtifactResolver.class );

        projectArtifact = createLocalArtifact( "project", "3.0" );
    }
1494#@Override
    protected void tearDown()
        throws Exception
    {
        artifactFactory = null;
        projectArtifact = null;
        super.tearDown();
    }
1495#@Override
    protected String component()
    {
        return "resolver";
    }
1496#public void testResolutionOfASingleArtifactWhereTheArtifactIsPresentInTheLocalRepository()
        throws Exception
    {
        Artifact a = createLocalArtifact( "a", "1.0" );

        artifactResolver.resolve( a, remoteRepositories(), localRepository() );

        assertLocalArtifactPresent( a );
    }
1497#public void testResolutionOfASingleArtifactWhereTheArtifactIsNotPresentLocallyAndMustBeRetrievedFromTheRemoteRepository()
        throws Exception
    {
        Artifact b = createRemoteArtifact( "b", "1.0-SNAPSHOT" );
        deleteLocalArtifact( b );
        artifactResolver.resolve( b, remoteRepositories(), localRepository() );
        assertLocalArtifactPresent( b );
    }
1498#@Override
    protected Artifact createArtifact( String groupId, String artifactId, String version, String type )
        throws Exception
    {
        // for the anonymous classes
        return super.createArtifact( groupId, artifactId, version, type );
    }
1499#public void testTransitiveResolutionWhereAllArtifactsArePresentInTheLocalRepository()
        throws Exception
    {
        Artifact g = createLocalArtifact( "g", "1.0" );

        Artifact h = createLocalArtifact( "h", "1.0" );

        ArtifactResolutionResult result = artifactResolver.resolveTransitively( Collections.singleton( g ), projectArtifact, remoteRepositories(), localRepository(), null );

        printErrors( result );

        assertEquals( 2, result.getArtifacts().size() );

        assertTrue( result.getArtifacts().contains( g ) );

        assertTrue( result.getArtifacts().contains( h ) );

        assertLocalArtifactPresent( g );

        assertLocalArtifactPresent( h );
    }
1500#public void testTransitiveResolutionWhereAllArtifactsAreNotPresentInTheLocalRepositoryAndMustBeRetrievedFromTheRemoteRepository()
        throws Exception
    {
        Artifact i = createRemoteArtifact( "i", "1.0-SNAPSHOT" );
        deleteLocalArtifact( i );

        Artifact j = createRemoteArtifact( "j", "1.0-SNAPSHOT" );
        deleteLocalArtifact( j );

        ArtifactResolutionResult result = artifactResolver.resolveTransitively( Collections.singleton( i ), projectArtifact, remoteRepositories(), localRepository(), null );

        printErrors( result );

        assertEquals( 2, result.getArtifacts().size() );

        assertTrue( result.getArtifacts().contains( i ) );

        assertTrue( result.getArtifacts().contains( j ) );

        assertLocalArtifactPresent( i );

        assertLocalArtifactPresent( j );
    }
1501#public void testResolutionFailureWhenArtifactNotPresentInRemoteRepository()
        throws Exception
    {
        Artifact k = createArtifact( "k", "1.0" );

        try
        {
            artifactResolver.resolve( k, remoteRepositories(), localRepository() );
            fail( "Resolution succeeded when it should have failed" );
        }
        catch ( ArtifactNotFoundException expected )
        {
            assertTrue( true );
        }
    }
1502#public void testResolutionOfAnArtifactWhereOneRemoteRepositoryIsBadButOneIsGood()
        throws Exception
    {
        Artifact l = createRemoteArtifact( "l", "1.0-SNAPSHOT" );
        deleteLocalArtifact( l );

        List<ArtifactRepository> repositories = new ArrayList<ArtifactRepository>();
        repositories.add( remoteRepository() );
        repositories.add( badRemoteRepository() );

        artifactResolver.resolve( l, repositories, localRepository() );

        assertLocalArtifactPresent( l );
    }
1503#public void testTransitiveResolutionOrder()
        throws Exception
    {
        Artifact m = createLocalArtifact( "m", "1.0" );

        Artifact n = createLocalArtifact( "n", "1.0" );

        ArtifactMetadataSource mds = new ArtifactMetadataSource()
        {
            public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository,
                                             List<ArtifactRepository> remoteRepositories )
                throws ArtifactMetadataRetrievalException
            {
                Set dependencies = new HashSet();

                return new ResolutionGroup( artifact, dependencies, remoteRepositories );
            }

            public List<ArtifactVersion> retrieveAvailableVersions( Artifact artifact,
                                                                    ArtifactRepository localRepository,
                                                                    List<ArtifactRepository> remoteRepositories )
                throws ArtifactMetadataRetrievalException
            {
                throw new UnsupportedOperationException( "Cannot get available versions in this test case" );
            }

            public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository(
                                                                                            Artifact artifact,
                                                                                            ArtifactRepository localRepository,
                                                                                            ArtifactRepository remoteRepository )
                throws ArtifactMetadataRetrievalException
            {
                throw new UnsupportedOperationException( "Cannot get available versions in this test case" );
            }

            public ResolutionGroup retrieve( MetadataResolutionRequest request )
                throws ArtifactMetadataRetrievalException
            {
                return retrieve( request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories() );
            }

            public List<ArtifactVersion> retrieveAvailableVersions( MetadataResolutionRequest request )
                throws ArtifactMetadataRetrievalException
            {
                return retrieveAvailableVersions( request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories() );
            }
        };

        ArtifactResolutionResult result = null;

        Set set = new LinkedHashSet();
        set.add( n );
        set.add( m );

        result =
            artifactResolver.resolveTransitively( set, projectArtifact, remoteRepositories(), localRepository(), mds );

        printErrors( result );

        Iterator i = result.getArtifacts().iterator();
        assertEquals( "n should be first", n, i.next() );
        assertEquals( "m should be second", m, i.next() );

        // inverse order
        set = new LinkedHashSet();
        set.add( m );
        set.add( n );

        result =
            artifactResolver.resolveTransitively( set, projectArtifact, remoteRepositories(), localRepository(), mds );

        printErrors( result );

        i = result.getArtifacts().iterator();
        assertEquals( "m should be first", m, i.next() );
        assertEquals( "n should be second", n, i.next() );
    }
1504#private void printErrors( ArtifactResolutionResult result )
    {
        if ( result.hasMissingArtifacts() )
        {
            for ( Artifact artifact : result.getMissingArtifacts() )
            {
                System.err.println( "Missing: " + artifact );
            }
        }

        if ( result.hasExceptions() )
        {
            for ( Exception e : result.getExceptions() )
            {
                e.printStackTrace();
            }
        }
    }
1505#public void testMissingArtifactMessageFormat()
    {
        String message = "Missing artifact";
        String indentation = "  ";
        String groupId = "aGroupId";
        String artifactId = "anArtifactId";
        String version = "aVersion";
        String type = "jar";
        String classifier = "aClassifier";
        String downloadUrl = "http://somewhere.com/download";
        List path = Arrays.asList( "dependency1", "dependency2" );
        String expected =
            "Missing artifact" + LS + LS + "  Try downloading the file manually from: " + LS
                + "      http://somewhere.com/download" + LS + LS + "  Then, install it using the command: " + LS
                + "      mvn install:install-file -DgroupId=aGroupId -DartifactId=anArtifactId -Dversion=aVersion "
                + "-Dclassifier=aClassifier -Dpackaging=jar -Dfile=/path/to/file" + LS + LS
                + "  Alternatively, if you host your own repository you can deploy the file there: " + LS
                + "      mvn deploy:deploy-file -DgroupId=aGroupId -DartifactId=anArtifactId"
                + " -Dversion=aVersion -Dclassifier=aClassifier -Dpackaging=jar -Dfile=/path/to/file"
                + " -Durl=[url] -DrepositoryId=[id]" + LS + LS + "  Path to dependency: " + LS + "  \t1) dependency1"
                + LS + "  \t2) dependency2" + LS + LS;
        String actual =
            AbstractArtifactResolutionException.constructMissingArtifactMessage( message, indentation, groupId,
                                                                                 artifactId, version, type, classifier,
                                                                                 downloadUrl, path );
        assertEquals( expected, actual );
    }
1506#protected void getTransfer( Resource resource, 
                                File destination, 
                                InputStream input, 
                                boolean closeInput, 
                                int maxSize )
        throws TransferFailedException
    {
        addTransfer( "getTransfer " + resource.getName() );
        super.getTransfer( resource, destination, input, closeInput, maxSize );
    }
1507#public void get( String resourceName, File destination )
        throws TransferFailedException, 
               ResourceDoesNotExistException, 
               AuthorizationException
    {
        addTransfer( "get " + resourceName );
        
        insideGet = true;
        
        super.get( resourceName, destination );
        
        insideGet = false;
    }
1508#private void addTransfer( String resourceName )
    {
        if ( testTransferListener != null )
        {
            testTransferListener.addTransfer( resourceName );
        }
    }
1509#public boolean getIfNewer( String resourceName, File destination, long timestamp )
        throws TransferFailedException, 
               ResourceDoesNotExistException, 
               AuthorizationException
    {
        if ( !insideGet )
        {
            addTransfer( "getIfNewer " + resourceName );
        }
        return super.getIfNewer( resourceName, destination, timestamp );
    }
1510#public void addTransferListener( TransferListener listener )
    {
        if ( listener instanceof TestTransferListener )
        {
            testTransferListener = (TestTransferListener) listener;
        }
        super.addTransferListener( listener );
    }
1511#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();

        artifactResolver = (DefaultArtifactResolver) lookup( ArtifactResolver.class );

        projectArtifact = createLocalArtifact( "project", "3.0" );
    }
1512#@Override
    protected void tearDown()
        throws Exception
    {
        artifactFactory = null;
        projectArtifact = null;
        super.tearDown();
    }
1513#@Override
    protected String component()
    {
        return "resolver";
    }
1514#public void testMNG4738()
        throws Exception
    {
        Artifact g = createLocalArtifact( "g", "1.0" );
        createLocalArtifact( "h", "1.0" );
        artifactResolver.resolveTransitively( Collections.singleton( g ), projectArtifact, remoteRepositories(),
                                              localRepository(), null );

        // we want to see all top-level thread groups
        ThreadGroup tg = Thread.currentThread().getThreadGroup();
        while ( !( tg.getParent() != null ) )
        {
            tg = tg.getParent();
        }

        ThreadGroup[] tgList = new ThreadGroup[tg.activeGroupCount()];
        tg.enumerate( tgList );

        boolean seen = false;

        for ( int i = 0; i < tgList.length; i++ )
        {
            if ( !tgList[i].getName().equals( DaemonThreadCreator.THREADGROUP_NAME ) )
            {
                continue;
            }

            seen = true;

            tg = tgList[i];
            Thread[] ts = new Thread[tg.activeCount()];
            tg.enumerate( ts );

            for ( Thread active : ts )
            {
                String name = active.getName();
                boolean daemon = active.isDaemon();
                assertTrue( name + " is no daemon Thread.", daemon );
            }

        }

        assertTrue( "Could not find ThreadGroup: " + DaemonThreadCreator.THREADGROUP_NAME, seen );
    }
1515#public void testLookup()
        throws Exception
    {
        ArtifactResolver resolver = lookup( ArtifactResolver.class, "default" );
    }
1516#private Artifact newArtifact( String scope )
    {
        return new DefaultArtifact( "g", "a", "1.0", scope, "jar", "", null );
    }
1517#public void testInclude_Compile()
    {
        ScopeArtifactFilter filter = new ScopeArtifactFilter( Artifact.SCOPE_COMPILE );

        assertTrue( filter.include( newArtifact( Artifact.SCOPE_COMPILE ) ) );
        assertTrue( filter.include( newArtifact( Artifact.SCOPE_SYSTEM ) ) );
        assertTrue( filter.include( newArtifact( Artifact.SCOPE_PROVIDED ) ) );
        assertFalse( filter.include( newArtifact( Artifact.SCOPE_RUNTIME ) ) );
        assertFalse( filter.include( newArtifact( Artifact.SCOPE_TEST ) ) );
    }
1518#public void testInclude_CompilePlusRuntime()
    {
        ScopeArtifactFilter filter = new ScopeArtifactFilter( Artifact.SCOPE_COMPILE_PLUS_RUNTIME );

        assertTrue( filter.include( newArtifact( Artifact.SCOPE_COMPILE ) ) );
        assertTrue( filter.include( newArtifact( Artifact.SCOPE_SYSTEM ) ) );
        assertTrue( filter.include( newArtifact( Artifact.SCOPE_PROVIDED ) ) );
        assertTrue( filter.include( newArtifact( Artifact.SCOPE_RUNTIME ) ) );
        assertFalse( filter.include( newArtifact( Artifact.SCOPE_TEST ) ) );
    }
1519#public void testInclude_Runtime()
    {
        ScopeArtifactFilter filter = new ScopeArtifactFilter( Artifact.SCOPE_RUNTIME );

        assertTrue( filter.include( newArtifact( Artifact.SCOPE_COMPILE ) ) );
        assertFalse( filter.include( newArtifact( Artifact.SCOPE_SYSTEM ) ) );
        assertFalse( filter.include( newArtifact( Artifact.SCOPE_PROVIDED ) ) );
        assertTrue( filter.include( newArtifact( Artifact.SCOPE_RUNTIME ) ) );
        assertFalse( filter.include( newArtifact( Artifact.SCOPE_TEST ) ) );
    }
1520#public void testInclude_RuntimePlusSystem()
    {
        ScopeArtifactFilter filter = new ScopeArtifactFilter( Artifact.SCOPE_RUNTIME_PLUS_SYSTEM );

        assertTrue( filter.include( newArtifact( Artifact.SCOPE_COMPILE ) ) );
        assertTrue( filter.include( newArtifact( Artifact.SCOPE_SYSTEM ) ) );
        assertFalse( filter.include( newArtifact( Artifact.SCOPE_PROVIDED ) ) );
        assertTrue( filter.include( newArtifact( Artifact.SCOPE_RUNTIME ) ) );
        assertFalse( filter.include( newArtifact( Artifact.SCOPE_TEST ) ) );
    }
1521#public void testInclude_Test()
    {
        ScopeArtifactFilter filter = new ScopeArtifactFilter( Artifact.SCOPE_TEST );

        assertTrue( filter.include( newArtifact( Artifact.SCOPE_COMPILE ) ) );
        assertTrue( filter.include( newArtifact( Artifact.SCOPE_SYSTEM ) ) );
        assertTrue( filter.include( newArtifact( Artifact.SCOPE_PROVIDED ) ) );
        assertTrue( filter.include( newArtifact( Artifact.SCOPE_RUNTIME ) ) );
        assertTrue( filter.include( newArtifact( Artifact.SCOPE_TEST ) ) );
    }
1522#private ArtifactFilter newSubFilter()
    {
        return new ArtifactFilter()
        {
            public boolean include( Artifact artifact )
            {
                return false;
            }
        };
    }
1523#public void testEquals()
    {
        OrArtifactFilter filter1 = new OrArtifactFilter();

        OrArtifactFilter filter2 = new OrArtifactFilter( Arrays.asList( newSubFilter() ) );

        assertFalse( filter1.equals( null ) );
        assertTrue( filter1.equals( filter1 ) );
        assertEquals( filter1.hashCode(), filter1.hashCode() );

        assertFalse( filter1.equals( filter2 ) );
        assertFalse( filter2.equals( filter1 ) );
    }
1524#public void testIncludesExcludesArtifactFilter()
    {
        List<String> patterns = Arrays.asList( "c", "d", "e" );

        IncludesArtifactFilter f1 = new IncludesArtifactFilter( patterns );

        IncludesArtifactFilter f2 = new IncludesArtifactFilter( patterns );

        assertTrue( f1.equals(f2) );
        assertTrue( f2.equals(f1) );
        assertTrue( f1.hashCode() == f2.hashCode() );
        
        IncludesArtifactFilter f3 = new IncludesArtifactFilter( Arrays.asList( "d", "c", "e" ) );
        assertTrue( f1.equals( f3 ) );
        assertTrue( f1.hashCode() == f3.hashCode() );
    }
1525#private ArtifactFilter newSubFilter()
    {
        return new ArtifactFilter()
        {
            public boolean include( Artifact artifact )
            {
                return false;
            }
        };
    }
1526#public void testEquals()
    {
        AndArtifactFilter filter1 = new AndArtifactFilter();

        AndArtifactFilter filter2 = new AndArtifactFilter( Arrays.asList( newSubFilter() ) );

        assertFalse( filter1.equals( null ) );
        assertTrue( filter1.equals( filter1 ) );
        assertEquals( filter1.hashCode(), filter1.hashCode() );

        assertFalse( filter1.equals( filter2 ) );
        assertFalse( filter2.equals( filter1 ) );
    }
1527#public TestFileManager( String baseFilename, String fileSuffix )
    {
        this.baseFilename = baseFilename;
        this.fileSuffix = fileSuffix;

        initializeCleanupMonitoring();
    }
1528#private void initializeCleanupMonitoring()
    {
        callerInfo = new NullPointerException().getStackTrace()[2];

        Runnable warning = new Runnable()
        {

            public void run()
            {
                maybeWarnAboutCleanUp();
            }

        };

        cleanupWarning = new Thread( warning );

        Runtime.getRuntime().addShutdownHook( cleanupWarning );
    }
1529#private void maybeWarnAboutCleanUp()
    {
        if ( warnAboutCleanup )
        {
            System.out.println( "[WARNING] TestFileManager from: " + callerInfo.getClassName() + " not cleaned up!" );
        }
    }
1530#public void markForDeletion( File toDelete )
    {
        filesToDelete.add( toDelete );
        warnAboutCleanup = true;
    }
1531#public synchronized File createTempDir()
    {
        try
        {
            Thread.sleep( 20 );
        }
        catch ( InterruptedException e )
        {
            // ignore
        }

        File dir = new File( TEMP_DIR_PATH, baseFilename + System.currentTimeMillis() );

        dir.mkdirs();
        markForDeletion( dir );

        return dir;
    }
1532#public synchronized File createTempFile()
        throws IOException
    {
        File tempFile = File.createTempFile( baseFilename, fileSuffix );
        tempFile.deleteOnExit();
        markForDeletion( tempFile );

        return tempFile;
    }
1533#public void cleanUp()
        throws IOException
    {
        for ( Iterator it = filesToDelete.iterator(); it.hasNext(); )
        {
            File file = (File) it.next();

            if ( file.exists() )
            {
                if ( file.isDirectory() )
                {
                    FileUtils.deleteDirectory( file );
                }
                else
                {
                    file.delete();
                }
            }

            it.remove();
        }

        warnAboutCleanup = false;
    }
1534#public void assertFileExistence( File dir, String filename, boolean shouldExist )
    {
        File file = new File( dir, filename );

        if ( shouldExist )
        {
            Assert.assertTrue( file.exists() );
        }
        else
        {
            Assert.assertFalse( file.exists() );
        }
    }
1535#public void assertFileContents( File dir, String filename, String contentsTest, String encoding )
        throws IOException
    {
        assertFileExistence( dir, filename, true );

        File file = new File( dir, filename );

        String contents = FileUtils.fileRead( file, encoding );

        Assert.assertEquals( contentsTest, contents );
    }
1536#public File createFile( File dir, String filename, String contents, String encoding )
        throws IOException
    {
        File file = new File( dir, filename );

        file.getParentFile().mkdirs();

        FileUtils.fileWrite( file.getPath(), encoding, contents );

        markForDeletion( file );

        return file;
    }
1537#public String getFileContents( File file, String encoding )
        throws IOException
    {
        return FileUtils.fileRead( file, encoding );
    }
1538#protected void finalize()
        throws Throwable
    {
        maybeWarnAboutCleanUp();

        super.finalize();
    }
1539#public File createFile( String filename, String content, String encoding )
        throws IOException
    {
        File dir = createTempDir();
        return createFile( dir, filename, content, encoding );
    }
1540#public void add( MockControl control )
    {
        mockControls.add( control );
    }
1541#public void replayAll()
    {
        for ( Iterator it = mockControls.iterator(); it.hasNext(); )
        {
            MockControl control = ( MockControl ) it.next();
            
            control.replay();
        }
    }
1542#public void verifyAll()
    {
        for ( Iterator it = mockControls.iterator(); it.hasNext(); )
        {
            MockControl control = ( MockControl ) it.next();
            
            control.verify();
        }
    }
1543#public void testTransformationManager()
        throws Exception
    {
        ArtifactTransformationManager tm = (ArtifactTransformationManager) lookup( ArtifactTransformationManager.class );

        List tms = tm.getArtifactTransformations();

        assertEquals( 3, tms.size() );

        assertTrue( "We expected the release transformation and got " + tms.get(0), tms.get(0) instanceof ReleaseArtifactTransformation );

        assertTrue( "We expected the latest transformation and got " + tms.get(1), tms.get(1) instanceof LatestArtifactTransformation );

        assertTrue( "We expected the snapshot transformation and got " + tms.get(2), tms.get(2) instanceof SnapshotTransformation );
    }
1544#public void setUp()
        throws Exception
    {
        super.setUp();
    }
1545#public void testShouldActivateDefaultProfile()
        throws Exception
    {
        Profile notActivated = new Profile();
        notActivated.setId( "notActivated" );

        Activation nonActivation = new Activation();

        nonActivation.setJdk( "19.2" );

        notActivated.setActivation( nonActivation );

        Profile defaultActivated = new Profile();
        defaultActivated.setId( "defaultActivated" );

        Activation defaultActivation = new Activation();

        defaultActivation.setActiveByDefault( true );

        defaultActivated.setActivation( defaultActivation );

        Properties props = System.getProperties();

        ProfileManager profileManager = new DefaultProfileManager( getContainer(), props );

        profileManager.addProfile( notActivated );
        profileManager.addProfile( defaultActivated );

        List active = profileManager.getActiveProfiles();

        assertNotNull( active );
        assertEquals( 1, active.size() );
        assertEquals( "defaultActivated", ( (Profile) active.get( 0 ) ).getId() );
    }
1546#public void testShouldNotActivateDefaultProfile()
        throws Exception
    {
        Profile syspropActivated = new Profile();
        syspropActivated.setId( "syspropActivated" );

        Activation syspropActivation = new Activation();

        ActivationProperty syspropProperty = new ActivationProperty();
        syspropProperty.setName( "java.version" );

        syspropActivation.setProperty( syspropProperty );

        syspropActivated.setActivation( syspropActivation );

        Profile defaultActivated = new Profile();
        defaultActivated.setId( "defaultActivated" );

        Activation defaultActivation = new Activation();

        defaultActivation.setActiveByDefault( true );

        defaultActivated.setActivation( defaultActivation );

        Properties props = System.getProperties();

        ProfileManager profileManager = new DefaultProfileManager( getContainer(), props );

        profileManager.addProfile( syspropActivated );
        profileManager.addProfile( defaultActivated );

        List active = profileManager.getActiveProfiles();

        assertNotNull( active );
        assertEquals( 1, active.size() );
        assertEquals( "syspropActivated", ( (Profile) active.get( 0 ) ).getId() );
    }
1547#public void testShouldNotActivateReversalOfPresentSystemProperty()
        throws Exception
    {
        Profile syspropActivated = new Profile();
        syspropActivated.setId( "syspropActivated" );

        Activation syspropActivation = new Activation();

        ActivationProperty syspropProperty = new ActivationProperty();
        syspropProperty.setName( "!java.version" );

        syspropActivation.setProperty( syspropProperty );

        syspropActivated.setActivation( syspropActivation );

        Properties props = System.getProperties();

        ProfileManager profileManager = new DefaultProfileManager( getContainer(), props );

        profileManager.addProfile( syspropActivated );

        List active = profileManager.getActiveProfiles();

        assertNotNull( active );
        assertEquals( 0, active.size() );
    }
1548#public void testShouldOverrideAndActivateInactiveProfile()
        throws Exception
    {
        Profile syspropActivated = new Profile();
        syspropActivated.setId( "syspropActivated" );

        Activation syspropActivation = new Activation();

        ActivationProperty syspropProperty = new ActivationProperty();
        syspropProperty.setName( "!java.version" );

        syspropActivation.setProperty( syspropProperty );

        syspropActivated.setActivation( syspropActivation );

        Properties props = System.getProperties();

        ProfileManager profileManager = new DefaultProfileManager( getContainer(), props );

        profileManager.addProfile( syspropActivated );

        profileManager.explicitlyActivate( "syspropActivated" );

        List active = profileManager.getActiveProfiles();

        assertNotNull( active );
        assertEquals( 1, active.size() );
        assertEquals( "syspropActivated", ( (Profile) active.get( 0 ) ).getId() );
    }
1549#public void testShouldOverrideAndDeactivateActiveProfile()
        throws Exception
    {
        Profile syspropActivated = new Profile();
        syspropActivated.setId( "syspropActivated" );

        Activation syspropActivation = new Activation();

        ActivationProperty syspropProperty = new ActivationProperty();
        syspropProperty.setName( "java.version" );

        syspropActivation.setProperty( syspropProperty );

        syspropActivated.setActivation( syspropActivation );

        Properties props = System.getProperties();

        ProfileManager profileManager = new DefaultProfileManager( getContainer(), props );

        profileManager.addProfile( syspropActivated );

        profileManager.explicitlyDeactivate( "syspropActivated" );

        List active = profileManager.getActiveProfiles();

        assertNotNull( active );
        assertEquals( 0, active.size() );
    }
1550#protected void setUp()
        throws Exception
    {
        super.setUp();
        
        if ( getContainer().hasComponent( ProjectBuilder.class, "test" ) )
        {
            projectBuilder = lookup( ProjectBuilder.class, "test" );
        }
        else
        {
            // default over to the main project builder...
            projectBuilder = lookup( ProjectBuilder.class );
        }
        
        repositorySystem = lookup( RepositorySystem.class );        
    }
1551#@Override
    protected void tearDown()
        throws Exception
    {
        projectBuilder = null;

        super.tearDown();
    }
1552#protected ProjectBuilder getProjectBuilder()
    {
        return projectBuilder;
    }
1553#@Override
    protected String getCustomConfigurationName()
    {
        String name = AbstractMavenProjectTestCase.class.getName().replace( '.', '/' ) + ".xml";
        System.out.println( name );
        return name;
    }
1554#// ----------------------------------------------------------------------
    // Local repository
    // ----------------------------------------------------------------------

    protected File getLocalRepositoryPath()
        throws FileNotFoundException, URISyntaxException
    {
        File markerFile = getFileForClasspathResource( "local-repo/marker.txt" );

        return markerFile.getAbsoluteFile().getParentFile();
    }
1555#protected static File getFileForClasspathResource( String resource )
        throws FileNotFoundException
    {
        ClassLoader cloader = Thread.currentThread().getContextClassLoader();

        URL resourceUrl = cloader.getResource( resource );

        if ( resourceUrl == null )
        {
            throw new FileNotFoundException( "Unable to find: " + resource );
        }

        return new File( URI.create( resourceUrl.toString().replaceAll( " ", "%20" ) ) );
    }
1556#protected ArtifactRepository getLocalRepository()
        throws Exception
    {
        ArtifactRepositoryLayout repoLayout = lookup( ArtifactRepositoryLayout.class, "legacy" );

        ArtifactRepository r = repositorySystem.createArtifactRepository( "local", "file://" + getLocalRepositoryPath().getAbsolutePath(), repoLayout, null, null );

        return r;
    }
1557#// ----------------------------------------------------------------------
    // Project building
    // ----------------------------------------------------------------------

    protected MavenProject getProjectWithDependencies( File pom )
        throws Exception
    {
        ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();
        configuration.setLocalRepository( getLocalRepository() );
        configuration.setRemoteRepositories( Arrays.asList( new ArtifactRepository[] {} ) );
        configuration.setProcessPlugins( false );
        configuration.setResolveDependencies( true );
        initRepoSession( configuration );

        try
        {
            return projectBuilder.build( pom, configuration ).getProject();
        }
        catch ( Exception e )
        {
            Throwable cause = e.getCause();
            if ( cause instanceof ModelBuildingException )
            {
                String message = "In: " + pom + "\n\n";
                for ( ModelProblem problem : ( (ModelBuildingException) cause ).getProblems() )
                {
                    message += problem + "\n";
                }
                System.out.println( message );
                fail( message );
            }

            throw e;
        }
    }
1558#protected MavenProject getProject( File pom )
        throws Exception
    {
        ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();
        configuration.setLocalRepository( getLocalRepository() );
        initRepoSession( configuration );

        return projectBuilder.build( pom, configuration ).getProject();
    }
1559#protected void initRepoSession( ProjectBuildingRequest request )
    {
        File localRepo = new File( request.getLocalRepository().getBasedir() );
        MavenRepositorySystemSession session = new MavenRepositorySystemSession();
        session.setLocalRepositoryManager( new LegacyLocalRepositoryManager( localRepo ) );
        request.setRepositorySession( session );
    }
1560#public void testShouldUseMainPluginDependencyVersionOverManagedDepVersion()
    {
        Plugin mgtPlugin = createPlugin( "group", "artifact", "1", Collections.EMPTY_MAP );
        Dependency mgtDep = createDependency( "g", "a", "2" );
        mgtPlugin.addDependency( mgtDep );

        Plugin plugin = createPlugin( "group", "artifact", "1", Collections.EMPTY_MAP );
        Dependency dep = createDependency( "g", "a", "1" );
        plugin.addDependency( dep );

        ModelUtils.mergePluginDefinitions( plugin, mgtPlugin, false );

        assertEquals( dep.getVersion(), ((Dependency) plugin.getDependencies().get( 0 ) ).getVersion() );
    }
1561#private Dependency createDependency( String gid,
                                         String aid,
                                         String ver )
    {
        Dependency dep = new Dependency();
        dep.setGroupId( gid );
        dep.setArtifactId( aid );
        dep.setVersion( ver );

        return dep;
    }
1562#public void testShouldNotInheritPluginWithInheritanceSetToFalse()
    {
        PluginContainer parent = new PluginContainer();

        Plugin parentPlugin = createPlugin( "group", "artifact", "1.0", Collections.EMPTY_MAP );
        parentPlugin.setInherited( "false" );

        parent.addPlugin( parentPlugin );

        PluginContainer child = new PluginContainer();

        child.addPlugin( createPlugin( "group3", "artifact3", "1.0", Collections.EMPTY_MAP ) );

        ModelUtils.mergePluginLists( child, parent, true );

        List results = child.getPlugins();

        assertEquals( 1, results.size() );

        Plugin result1 = (Plugin) results.get( 0 );
        assertEquals( "group3", result1.getGroupId() );
        assertEquals( "artifact3", result1.getArtifactId() );
    }
1563#/**
     * Test that this is the resulting ordering of plugins after merging:
     *
     * Given:
     *
     *   parent: X -> A -> B -> D -> E
     *   child: Y -> A -> C -> D -> F
     *
     * Result:
     *
     *   X -> Y -> A -> B -> C -> D -> E -> F
     */
    public void testShouldPreserveChildOrderingOfPluginsAfterParentMerge()
    {
        PluginContainer parent = new PluginContainer();

        parent.addPlugin( createPlugin( "group", "artifact", "1.0", Collections.EMPTY_MAP ) );
        parent.addPlugin( createPlugin( "group2", "artifact2", "1.0", Collections.singletonMap( "key", "value" ) ) );

        PluginContainer child = new PluginContainer();

        child.addPlugin( createPlugin( "group3", "artifact3", "1.0", Collections.EMPTY_MAP ) );
        child.addPlugin( createPlugin( "group2", "artifact2", "1.0", Collections.singletonMap( "key2", "value2" ) ) );

        ModelUtils.mergePluginLists( child, parent, true );

        List results = child.getPlugins();

        assertEquals( 3, results.size() );

        Plugin result1 = (Plugin) results.get( 0 );

        assertEquals( "group", result1.getGroupId() );
        assertEquals( "artifact", result1.getArtifactId() );

        Plugin result2 = (Plugin) results.get( 1 );

        assertEquals( "group3", result2.getGroupId() );
        assertEquals( "artifact3", result2.getArtifactId() );

        Plugin result3 = (Plugin) results.get( 2 );

        assertEquals( "group2", result3.getGroupId() );
        assertEquals( "artifact2", result3.getArtifactId() );

        Xpp3Dom result3Config = (Xpp3Dom) result3.getConfiguration();

        assertNotNull( result3Config );

        assertEquals( "value", result3Config.getChild( "key" ).getValue() );
        assertEquals( "value2", result3Config.getChild( "key2" ).getValue() );
    }
1564#private Plugin createPlugin( String groupId, String artifactId, String version, Map configuration )
    {
        Plugin plugin = new Plugin();
        plugin.setGroupId( groupId );
        plugin.setArtifactId( artifactId );
        plugin.setVersion( version );

        Xpp3Dom config = new Xpp3Dom( "configuration" );

        if( configuration != null )
        {
            for ( Iterator it = configuration.entrySet().iterator(); it.hasNext(); )
            {
                Map.Entry entry = (Map.Entry) it.next();

                Xpp3Dom param = new Xpp3Dom( String.valueOf( entry.getKey() ) );
                param.setValue( String.valueOf( entry.getValue() ) );

                config.addChild( param );
            }
        }

        plugin.setConfiguration( config );

        return plugin;
    }
1565#public void testShouldInheritOnePluginWithExecution()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );

        PluginExecution parentExecution = new PluginExecution();
        parentExecution.setId( "testExecution" );

        parent.addExecution( parentExecution );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        ModelUtils.mergePluginDefinitions( child, parent, false );

        assertEquals( 1, child.getExecutions().size() );
    }
1566#public void testShouldMergeInheritedPluginHavingExecutionWithLocalPlugin()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );

        PluginExecution parentExecution = new PluginExecution();
        parentExecution.setId( "testExecution" );

        parent.addExecution( parentExecution );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        PluginExecution childExecution = new PluginExecution();
        childExecution.setId( "testExecution2" );

        child.addExecution( childExecution );

        ModelUtils.mergePluginDefinitions( child, parent, false );

        assertEquals( 2, child.getExecutions().size() );
    }
1567#public void testShouldMergeOnePluginWithInheritExecutionWithoutDuplicatingPluginInList()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );

        PluginExecution parentExecution = new PluginExecution();
        parentExecution.setId( "testExecution" );

        parent.addExecution( parentExecution );

        Build parentContainer = new Build();
        parentContainer.addPlugin( parent );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        Build childContainer = new Build();
        childContainer.addPlugin( child );

        ModelUtils.mergePluginLists( childContainer, parentContainer, true );

        List plugins = childContainer.getPlugins();

        assertEquals( 1, plugins.size() );

        Plugin plugin = (Plugin) plugins.get( 0 );

        assertEquals( 1, plugin.getExecutions().size() );
    }
1568#public void testShouldMergePluginWithDifferentExecutionFromParentWithoutDuplicatingPluginInList()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );

        PluginExecution parentExecution = new PluginExecution();
        parentExecution.setId( "testExecution" );

        parent.addExecution( parentExecution );

        Build parentContainer = new Build();
        parentContainer.addPlugin( parent );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        PluginExecution childExecution = new PluginExecution();
        childExecution.setId( "testExecution2" );

        child.addExecution( childExecution );


        Build childContainer = new Build();
        childContainer.addPlugin( child );

        ModelUtils.mergePluginLists( childContainer, parentContainer, true );

        List plugins = childContainer.getPlugins();

        assertEquals( 1, plugins.size() );

        Plugin plugin = (Plugin) plugins.get( 0 );

        assertEquals( 2, plugin.getExecutions().size() );
    }
1569#public void testShouldNOTMergeInheritedPluginHavingInheritEqualFalse()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );
        parent.setInherited( "false" );

        PluginExecution parentExecution = new PluginExecution();
        parentExecution.setId( "testExecution" );

        parent.addExecution( parentExecution );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        ModelUtils.mergePluginDefinitions( child, parent, true );

        assertEquals( 0, child.getExecutions().size() );
    }
1570#/**
     * Verifies MNG-1499: The order of the merged list should be the plugins specified by the parent followed by the
     * child list.
     */
    public void testShouldKeepOriginalPluginOrdering()
    {
        Plugin parentPlugin1 = new Plugin();
        parentPlugin1.setArtifactId( "testArtifact" );
        parentPlugin1.setGroupId( "zzz" );  // This will put this plugin last in the sorted map
        parentPlugin1.setVersion( "1.0" );

        PluginExecution parentExecution1 = new PluginExecution();
        parentExecution1.setId( "testExecution" );

        parentPlugin1.addExecution( parentExecution1 );

        Plugin parentPlugin2 = new Plugin();
        parentPlugin2.setArtifactId( "testArtifact" );
        parentPlugin2.setGroupId( "yyy" );
        parentPlugin2.setVersion( "1.0" );

        PluginExecution parentExecution2 = new PluginExecution();
        parentExecution2.setId( "testExecution" );

        parentPlugin2.addExecution( parentExecution2 );

        PluginContainer parentContainer = new PluginContainer();
        parentContainer.addPlugin(parentPlugin1);
        parentContainer.addPlugin(parentPlugin2);


        Plugin childPlugin1 = new Plugin();
        childPlugin1.setArtifactId( "testArtifact" );
        childPlugin1.setGroupId( "bbb" );
        childPlugin1.setVersion( "1.0" );

        PluginExecution childExecution1 = new PluginExecution();
        childExecution1.setId( "testExecution" );

        childPlugin1.addExecution( childExecution1 );

        Plugin childPlugin2 = new Plugin();
        childPlugin2.setArtifactId( "testArtifact" );
        childPlugin2.setGroupId( "aaa" );
        childPlugin2.setVersion( "1.0" );

        PluginExecution childExecution2 = new PluginExecution();
        childExecution2.setId( "testExecution" );

        childPlugin2.addExecution( childExecution2 );

        PluginContainer childContainer = new PluginContainer();
        childContainer.addPlugin(childPlugin1);
        childContainer.addPlugin(childPlugin2);


        ModelUtils.mergePluginLists(childContainer, parentContainer, true);

        assertEquals( 4, childContainer.getPlugins().size() );
        assertSame(parentPlugin1, childContainer.getPlugins().get(0));
        assertSame(parentPlugin2, childContainer.getPlugins().get(1));
        assertSame(childPlugin1, childContainer.getPlugins().get(2));
        assertSame(childPlugin2, childContainer.getPlugins().get(3));
    }
1571#/**
     * Verifies MNG-1499: The ordering of plugin executions should also be in the specified order.
     */
    public void testShouldKeepOriginalPluginExecutionOrdering()
    {
        Plugin parent = new Plugin();
        parent.setArtifactId( "testArtifact" );
        parent.setGroupId( "testGroup" );
        parent.setVersion( "1.0" );

        PluginExecution parentExecution1 = new PluginExecution();
        parentExecution1.setId( "zzz" );  // Will show up last in the sorted map
        PluginExecution parentExecution2 = new PluginExecution();
        parentExecution2.setId( "yyy" );  // Will show up last in the sorted map

        parent.addExecution( parentExecution1 );
        parent.addExecution( parentExecution2 );

        // this block verifies MNG-1703
        Dependency dep = new Dependency();
        dep.setGroupId( "depGroupId" );
        dep.setArtifactId( "depArtifactId" );
        dep.setVersion( "depVersion" );
        parent.setDependencies( Collections.singletonList( dep ) );

        Plugin child = new Plugin();
        child.setArtifactId( "testArtifact" );
        child.setGroupId( "testGroup" );
        child.setVersion( "1.0" );

        PluginExecution childExecution1 = new PluginExecution();
        childExecution1.setId( "bbb" );
        PluginExecution childExecution2 = new PluginExecution();
        childExecution2.setId( "aaa" );

        child.addExecution( childExecution1 );
        child.addExecution( childExecution2 );

        ModelUtils.mergePluginDefinitions( child, parent, false );

        assertEquals( 4, child.getExecutions().size() );
        assertSame(parentExecution1, child.getExecutions().get(0));
        assertSame(parentExecution2, child.getExecutions().get(1));
        assertSame(childExecution1, child.getExecutions().get(2));
        assertSame(childExecution2, child.getExecutions().get(3));

        // this block prevents MNG-1703
        assertEquals( 1, child.getDependencies().size() );
        Dependency dep2 = (Dependency) child.getDependencies().get( 0 );
        assertEquals( dep.getManagementKey(), dep2.getManagementKey() );
    }
1572#public void testShouldOverwritePluginConfigurationSubItemsByDefault()
        throws XmlPullParserException, IOException
    {
        String parentConfigStr = "<configuration><items><item>one</item><item>two</item></items></configuration>";
        Xpp3Dom parentConfig = Xpp3DomBuilder.build( new StringReader( parentConfigStr ) );

        Plugin parentPlugin = createPlugin( "group", "artifact", "1", null );
        parentPlugin.setConfiguration( parentConfig );

        String childConfigStr = "<configuration><items><item>three</item></items></configuration>";
        Xpp3Dom childConfig = Xpp3DomBuilder.build( new StringReader( childConfigStr ) );

        Plugin childPlugin = createPlugin( "group", "artifact", "1", null );
        childPlugin.setConfiguration( childConfig );

        ModelUtils.mergePluginDefinitions( childPlugin, parentPlugin, true );

        Xpp3Dom result = (Xpp3Dom) childPlugin.getConfiguration();
        Xpp3Dom items = result.getChild( "items" );

        assertEquals( 1, items.getChildCount() );

        Xpp3Dom item = items.getChild( 0 );
        assertEquals( "three", item.getValue() );
    }
1573#public void testShouldMergePluginConfigurationSubItemsWithMergeAttributeSet()
        throws XmlPullParserException, IOException
    {
        String parentConfigStr = "<configuration><items><item>one</item><item>two</item></items></configuration>";
        Xpp3Dom parentConfig = Xpp3DomBuilder.build( new StringReader( parentConfigStr ) );

        Plugin parentPlugin = createPlugin( "group", "artifact", "1", null );
        parentPlugin.setConfiguration( parentConfig );

        String childConfigStr = "<configuration><items combine.children=\"append\"><item>three</item></items></configuration>";
        Xpp3Dom childConfig = Xpp3DomBuilder.build( new StringReader( childConfigStr ) );

        Plugin childPlugin = createPlugin( "group", "artifact", "1", null );
        childPlugin.setConfiguration( childConfig );

        ModelUtils.mergePluginDefinitions( childPlugin, parentPlugin, true );

        Xpp3Dom result = (Xpp3Dom) childPlugin.getConfiguration();
        Xpp3Dom items = result.getChild( "items" );

        assertEquals( 3, items.getChildCount() );

        Xpp3Dom[] item = items.getChildren();

        List<String> actual = Arrays.asList( item[0].getValue(), item[1].getValue(), item[2].getValue() );
        List<String> expected = Arrays.asList( "one", "two", "three" );
        Collections.sort( actual );
        Collections.sort( expected );
        assertEquals( expected, actual );
    }
1574#public void testShouldNotMergePluginExecutionWhenExecInheritedIsFalseAndTreatAsInheritanceIsTrue()
    {
        String gid = "group";
        String aid = "artifact";
        String ver = "1";

        PluginContainer parent = new PluginContainer();
        Plugin pParent = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );

        pParent.setInherited( Boolean.toString( true ) );

        PluginExecution eParent = new PluginExecution();

        String testId = "test";

        eParent.setId( testId );
        eParent.addGoal( "run" );
        eParent.setPhase( "initialize" );
        eParent.setInherited( Boolean.toString( false ) );

        pParent.addExecution( eParent );
        parent.addPlugin( pParent );

        PluginContainer child = new PluginContainer();
        Plugin pChild = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
        PluginExecution eChild = new PluginExecution();

        eChild.setId( "child-specified" );
        eChild.addGoal( "child" );
        eChild.setPhase( "compile" );

        pChild.addExecution( eChild );
        child.addPlugin( pChild );

        ModelUtils.mergePluginDefinitions( pChild, pParent, true );

        Map executionMap = pChild.getExecutionsAsMap();
        assertNull( "test execution should not be inherited from parent.", executionMap.get( testId ) );
    }
1575#public void testShouldNotMergePluginExecutionWhenPluginInheritedIsFalseAndTreatAsInheritanceIsTrue()
    {
        String gid = "group";
        String aid = "artifact";
        String ver = "1";

        PluginContainer parent = new PluginContainer();
        Plugin pParent = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );

        pParent.setInherited( Boolean.toString( false ) );

        PluginExecution eParent = new PluginExecution();

        String testId = "test";

        eParent.setId( testId );
        eParent.addGoal( "run" );
        eParent.setPhase( "initialize" );
        eParent.setInherited( Boolean.toString( true ) );

        pParent.addExecution( eParent );
        parent.addPlugin( pParent );

        PluginContainer child = new PluginContainer();
        Plugin pChild = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
        PluginExecution eChild = new PluginExecution();

        eChild.setId( "child-specified" );
        eChild.addGoal( "child" );
        eChild.setPhase( "compile" );

        pChild.addExecution( eChild );
        child.addPlugin( pChild );

        ModelUtils.mergePluginDefinitions( pChild, pParent, true );

        Map executionMap = pChild.getExecutionsAsMap();
        assertNull( "test execution should not be inherited from parent.", executionMap.get( testId ) );
    }
1576#public void testShouldMergePluginExecutionWhenExecInheritedIsTrueAndTreatAsInheritanceIsTrue()
    {
        String gid = "group";
        String aid = "artifact";
        String ver = "1";

        PluginContainer parent = new PluginContainer();
        Plugin pParent = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );

        pParent.setInherited( Boolean.toString( true ) );

        PluginExecution eParent = new PluginExecution();

        String testId = "test";

        eParent.setId( testId );
        eParent.addGoal( "run" );
        eParent.setPhase( "initialize" );
        eParent.setInherited( Boolean.toString( true ) );

        pParent.addExecution( eParent );
        parent.addPlugin( pParent );

        PluginContainer child = new PluginContainer();
        Plugin pChild = createPlugin( gid, aid, ver, Collections.EMPTY_MAP );
        PluginExecution eChild = new PluginExecution();

        eChild.setId( "child-specified" );
        eChild.addGoal( "child" );
        eChild.setPhase( "compile" );

        pChild.addExecution( eChild );
        child.addPlugin( pChild );

        ModelUtils.mergePluginDefinitions( pChild, pParent, true );

        Map executionMap = pChild.getExecutionsAsMap();
        assertNotNull( "test execution should be inherited from parent.", executionMap.get( testId ) );
    }
1577#public MavenExecutionPlan calculateExecutionPlan( MavenSession session, String... tasks )
    {
        return new MavenExecutionPlan( null, new DefaultLifecycles() );
    }
1578#public MavenExecutionPlan calculateExecutionPlan( MavenSession session, boolean setup, String... tasks )
    {
        return new MavenExecutionPlan( null, new DefaultLifecycles() );
    }
1579#public void execute( MavenSession session )
    {
    }
1580#public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<Plugin>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }
1581#private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }
1582#public void calculateForkedExecutions( MojoExecution mojoExecution, MavenSession session )
    {
    }
1583#public List<MavenProject> executeForkedExecutions( MojoExecution mojoExecution, MavenSession session )
    {
        return Collections.emptyList();
    }
1584#public List<ArtifactResult> resolveArtifacts( RepositorySystemSession session,
                                                  Collection<? extends ArtifactRequest> requests )
        throws ArtifactResolutionException
    {
        List<ArtifactResult> results = new ArrayList<ArtifactResult>();

        for ( ArtifactRequest request : requests )
        {
            ArtifactResult result = new ArtifactResult( request );
            results.add( result );

            Artifact artifact = request.getArtifact();
            if ( "maven-test".equals( artifact.getGroupId() ) )
            {
                String scope = artifact.getArtifactId().substring( "scope-".length() );

                try
                {
                    artifact =
                        artifact.setFile( ProjectClasspathTest.getFileForClasspathResource( ProjectClasspathTest.dir
                            + "transitive-" + scope + "-dep.xml" ) );
                    result.setArtifact( artifact );
                }
                catch ( FileNotFoundException e )
                {
                    throw new IllegalStateException( "Missing test POM for " + artifact );
                }
            }
            else
            {
                result.addException( new ArtifactNotFoundException( artifact, null ) );
                throw new ArtifactResolutionException( results );
            }
        }

        return results;
    }
1585#public ArtifactResult resolveArtifact( RepositorySystemSession session, ArtifactRequest request )
        throws ArtifactResolutionException
    {
        return resolveArtifacts( session, Collections.singleton( request ) ).get( 0 );
    }
1586#public LegacyLocalRepositoryManager( File basedir )
    {
        super( basedir );
    }
1587#public String getPathForLocalArtifact( Artifact artifact )
    {
        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getGroupId() ).append( '/' );

        path.append( artifact.getExtension() ).append( 's' ).append( '/' );

        path.append( artifact.getArtifactId() ).append( '-' ).append( artifact.getVersion() );

        if ( artifact.getClassifier().length() > 0 )
        {
            path.append( '-' ).append( artifact.getClassifier() );
        }

        path.append( '.' ).append( artifact.getExtension() );

        return path.toString();
    }
1588#public LocalArtifactResult find( RepositorySystemSession session, LocalArtifactRequest request )
    {
 	    String path = getPathForLocalArtifact( request.getArtifact() );
 	    File file = new File( getRepository().getBasedir(), path );
        LocalArtifactResult result = new LocalArtifactResult( request );
 	    if ( file.isFile() )
        {
 	        result.setFile( file );
 	        result.setAvailable( true );
 	    }
 	    return result;
 	}
1589#public void setUp()
        throws Exception
    {
        ArtifactResolver resolver = lookup( ArtifactResolver.class, "classpath" );
        DefaultArtifactDescriptorReader pomReader = (DefaultArtifactDescriptorReader)lookup(ArtifactDescriptorReader.class);
        pomReader.setArtifactResolver( resolver );

        projectBuilder = lookup( ProjectBuilder.class, "classpath" );

        // the metadata source looks up the default impl, so we have to trick it
        getContainer().addComponent( projectBuilder, ProjectBuilder.class, "default" );

        repositorySystem = lookup( RepositorySystem.class );        
    }
1590#@Override
    protected String getCustomConfigurationName()
    {
        return null;
    }
1591#public void testProjectClasspath()
        throws Exception
    {
        File f = getFileForClasspathResource( dir + "project-with-scoped-dependencies.xml" );

        MavenProject project = getProjectWithDependencies( f );

        Artifact artifact;

        assertNotNull( "Test project can't be null!", project );

        checkArtifactIdScope( project, "provided", "provided" );
        checkArtifactIdScope( project, "test", "test" );
        checkArtifactIdScope( project, "compile", "compile" );
        checkArtifactIdScope( project, "runtime", "runtime" );
        checkArtifactIdScope( project, "default", "compile" );

        // check all transitive deps of a test dependency are test, except test and provided which is skipped
        artifact = getArtifact( project, "maven-test-test", "scope-provided" );
        assertNull( "Check no provided dependencies are transitive", artifact );
        artifact = getArtifact( project, "maven-test-test", "scope-test" );
        assertNull( "Check no test dependencies are transitive", artifact );

        artifact = getArtifact( project, "maven-test-test", "scope-compile" );
        assertNotNull( artifact );

        System.out.println( "a = " + artifact );
        System.out.println( "b = " + artifact.getScope() );
        assertEquals( "Check scope", "test", artifact.getScope() );
        artifact = getArtifact( project, "maven-test-test", "scope-default" );
        assertEquals( "Check scope", "test", artifact.getScope() );
        artifact = getArtifact( project, "maven-test-test", "scope-runtime" );
        assertEquals( "Check scope", "test", artifact.getScope() );

        // check all transitive deps of a provided dependency are provided scope, except for test
        checkGroupIdScope( project, "provided", "maven-test-provided" );
        artifact = getArtifact( project, "maven-test-provided", "scope-runtime" );
        assertEquals( "Check scope", "provided", artifact.getScope() );

        // check all transitive deps of a runtime dependency are runtime scope, except for test
        checkGroupIdScope( project, "runtime", "maven-test-runtime" );
        artifact = getArtifact( project, "maven-test-runtime", "scope-runtime" );
        assertEquals( "Check scope", "runtime", artifact.getScope() );

        // check all transitive deps of a compile dependency are compile scope, except for runtime and test
        checkGroupIdScope( project, "compile", "maven-test-compile" );
        artifact = getArtifact( project, "maven-test-compile", "scope-runtime" );
        assertEquals( "Check scope", "runtime", artifact.getScope() );

        // check all transitive deps of a default dependency are compile scope, except for runtime and test
        checkGroupIdScope( project, "compile", "maven-test-default" );
        artifact = getArtifact( project, "maven-test-default", "scope-runtime" );
        assertEquals( "Check scope", "runtime", artifact.getScope() );
    }
1592#private void checkGroupIdScope( MavenProject project, String scopeValue, String groupId )
    {
        Artifact artifact;
        artifact = getArtifact( project, groupId, "scope-compile" );
        assertEquals( "Check scope", scopeValue, artifact.getScope() );
        artifact = getArtifact( project, groupId, "scope-test" );
        assertNull( "Check test dependency is not transitive", artifact );
        artifact = getArtifact( project, groupId, "scope-provided" );
        assertNull( "Check provided dependency is not transitive", artifact );
        artifact = getArtifact( project, groupId, "scope-default" );
        assertEquals( "Check scope", scopeValue, artifact.getScope() );
    }
1593#private void checkArtifactIdScope( MavenProject project, String scope, String scopeValue )
    {
        String artifactId = "scope-" + scope;
        Artifact artifact = getArtifact( project, "maven-test", artifactId );
        assertNotNull( artifact );
        assertEquals( "Check scope", scopeValue, artifact.getScope() );
    }
1594#private Artifact getArtifact( MavenProject project, String groupId, String artifactId )
    {
        System.out.println( "[ Looking for " + groupId + ":" + artifactId + " ]" );
        for ( Iterator<Artifact> i = project.getArtifacts().iterator(); i.hasNext(); )
        {
            Artifact a = i.next();
            System.out.println( a.toString() );
            if ( artifactId.equals( a.getArtifactId() ) && a.getGroupId().equals( groupId ) )
            {
                System.out.println( "RETURN" );
                return a;
            }
        }
        System.out.println( "Return null" );
        return null;
    }
1595#public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<Plugin>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }
1596#private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }
1597#@Override
    public ProjectBuildingResult build( Artifact artifact, ProjectBuildingRequest request )
        throws ProjectBuildingException
    {                       
        if ( "maven-test".equals( artifact.getGroupId() ) )
        {
            String scope = artifact.getArtifactId().substring( "scope-".length() );
            
            try
            {
                artifact.setFile( ProjectClasspathTest.getFileForClasspathResource( ProjectClasspathTest.dir + "transitive-" + scope + "-dep.xml" ) );
            }
            catch ( FileNotFoundException e )
            {
                throw new IllegalStateException( "Missing test POM for " + artifact );
            }
        }
        if ( artifact.getFile() == null )
        {
            MavenProject project = new MavenProject();
            project.setArtifact( artifact );
            return new DefaultProjectBuildingResult( project, null, null );
        }
        return build( artifact.getFile(), request );
    }
1598#@Override
    public ProjectBuildingResult build( File pomFile, ProjectBuildingRequest configuration )
        throws ProjectBuildingException
    {
        ProjectBuildingResult result = super.build( pomFile, configuration );

        result.getProject().setRemoteArtifactRepositories( Collections.<ArtifactRepository> emptyList() );

        return result;
    }
1599#protected String getTestSeries()
    {
        String className = getClass().getPackage().getName();

        return className.substring( className.lastIndexOf( "." ) + 1 );
    }
1600#protected File projectFile( String name )
    {
        return projectFile( "maven", name );
    }
1601#protected File projectFile( String groupId, String artifactId )
    {
        return new File( getLocalRepositoryPath(), "/" + groupId + "/poms/" + artifactId + "-1.0.pom" );
    }
1602#// ----------------------------------------------------------------------
    // The local repository for this category of tests
    // ----------------------------------------------------------------------

    protected File getLocalRepositoryPath()
    {
        return getTestFile("src/test/resources/inheritance-repo/" + getTestSeries() );
    }
1603#// ----------------------------------------------------------------------
    //
    // p4 inherits from p3
    // p3 inherits from p2
    // p2 inherits from p1
    // p1 inherits from p0
    // p0 inhertis from super model
    //
    // or we can show it graphically as:
    //
    // p4 ---> p3 ---> p2 ---> p1 ---> p0 --> super model
    //
    // ----------------------------------------------------------------------

    public void testProjectInheritance()
        throws Exception
    {
        MavenProject p4 = getProject( projectFile( "p4" ) );

        assertEquals( "p4", p4.getName() );

        // ----------------------------------------------------------------------
        // Value inherited from p3
        // ----------------------------------------------------------------------

        assertEquals( "2000", p4.getInceptionYear() );

        // ----------------------------------------------------------------------
        // Value taken from p2
        // ----------------------------------------------------------------------

        assertEquals( "mailing-list", ( (MailingList) p4.getMailingLists().get( 0 ) ).getName() );

        // ----------------------------------------------------------------------
        // Value taken from p1
        // ----------------------------------------------------------------------

        assertEquals( "scm-url/p2/p3/p4", p4.getScm().getUrl() );

        // ----------------------------------------------------------------------
        // Value taken from p4
        // ----------------------------------------------------------------------

        assertEquals( "Codehaus", p4.getOrganization().getName() );

        // ----------------------------------------------------------------------
        // Value taken from super model
        // ----------------------------------------------------------------------

        assertEquals( "4.0.0", p4.getModelVersion() );

        assertEquals( "4.0.0", p4.getModelVersion() );
    }
1604#// ----------------------------------------------------------------------
    //
    // p4 inherits from p3
    // p3 inherits from p2
    // p2 inherits from p1
    // p1 inherits from p0
    // p0 inhertis from super model
    //
    // or we can show it graphically as:
    //
    // p4 ---> p3 ---> p2 ---> p1 ---> p0 --> super model
    //
    // ----------------------------------------------------------------------

    public void testProjectInheritance()
        throws Exception
    {
        // ----------------------------------------------------------------------
        // Check p0 value for org name
        // ----------------------------------------------------------------------

        MavenProject p0 = getProject( projectFile( "maven.t01", "p0" ) );

        assertEquals( "p0-org", p0.getOrganization().getName() );

        // ----------------------------------------------------------------------
        // Check p1 value for org name
        // ----------------------------------------------------------------------

        MavenProject p1 = getProject( projectFile( "maven.t01", "p1" ) );

        assertEquals( "p1-org", p1.getOrganization().getName() );

        // ----------------------------------------------------------------------
        // Check p2 value for org name
        // ----------------------------------------------------------------------

        MavenProject p2 = getProject( projectFile( "maven.t01", "p2" ) );

        assertEquals( "p2-org", p2.getOrganization().getName() );

        // ----------------------------------------------------------------------
        // Check p2 value for org name
        // ----------------------------------------------------------------------

        MavenProject p3 = getProject( projectFile( "maven.t01", "p3" ) );

        assertEquals( "p3-org", p3.getOrganization().getName() );

        // ----------------------------------------------------------------------
        // Check p4 value for org name
        // ----------------------------------------------------------------------

        MavenProject p4 = getProject( projectFile( "maven.t01", "p4" ) );

        assertEquals( "p4-org", p4.getOrganization().getName() );
    }
1605#// ----------------------------------------------------------------------
    //
    // p4 inherits from p3
    // p3 inherits from p2
    // p2 inherits from p1
    // p1 inherits from p0
    // p0 inhertis from super model
    //
    // or we can show it graphically as:
    //
    // p4 ---> p3 ---> p2 ---> p1 ---> p0 --> super model
    //
    // ----------------------------------------------------------------------

    public void testProjectInheritance()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        
        System.out.println( "Local repository is at: " + localRepo.getAbsolutePath() );
        
        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom1 = new File( pom0.getParentFile(), "p1/pom.xml" );
        File pom2 = new File( pom1.getParentFile(), "p2/pom.xml" );
        File pom3 = new File( pom2.getParentFile(), "p3/pom.xml" );
        File pom4 = new File( pom3.getParentFile(), "p4/pom.xml" );
        File pom5 = new File( pom4.getParentFile(), "p5/pom.xml" );
        
        System.out.println( "Location of project-4's POM: " + pom4.getPath() );

        // load everything...
        MavenProject project0 = getProject( pom0 );
        MavenProject project1 = getProject( pom1 );
        MavenProject project2 = getProject( pom2 );
        MavenProject project3 = getProject( pom3 );
        MavenProject project4 = getProject( pom4 );
        MavenProject project5 = getProject( pom5 );

        assertEquals( "p4", project4.getName() );

        // ----------------------------------------------------------------------
        // Value inherited from p3
        // ----------------------------------------------------------------------

        assertEquals( "2000", project4.getInceptionYear() );

        // ----------------------------------------------------------------------
        // Value taken from p2
        // ----------------------------------------------------------------------

        assertEquals( "mailing-list", ( (MailingList) project4.getMailingLists().get( 0 ) ).getName() );

        // ----------------------------------------------------------------------
        // Value taken from p1
        // ----------------------------------------------------------------------

        assertEquals( "scm-url/p2/p3/p4", project4.getScm().getUrl() );

        // ----------------------------------------------------------------------
        // Value taken from p4
        // ----------------------------------------------------------------------

        assertEquals( "Codehaus", project4.getOrganization().getName() );

        // ----------------------------------------------------------------------
        // Value taken from super model
        // ----------------------------------------------------------------------

        assertEquals( "4.0.0", project4.getModelVersion() );
        
        Build build = project4.getBuild();
        List plugins = build.getPlugins();
        
        Map validPluginCounts = new HashMap();
        
        String testPluginArtifactId = "maven-compiler-plugin";
        
        // this is the plugin we're looking for.
        validPluginCounts.put( testPluginArtifactId, new Integer( 0 ) );
        
        // these are injected if -DperformRelease=true
        validPluginCounts.put( "maven-deploy-plugin", new Integer( 0 ) );
        validPluginCounts.put( "maven-javadoc-plugin", new Integer( 0 ) );
        validPluginCounts.put( "maven-source-plugin", new Integer( 0 ) );
        
        Plugin testPlugin = null;
        
        for ( Iterator it = plugins.iterator(); it.hasNext(); )
        {
            Plugin plugin = (Plugin) it.next();
            
            String pluginArtifactId = plugin.getArtifactId();
            
            if ( !validPluginCounts.containsKey( pluginArtifactId ) )
            {
                fail( "Illegal plugin found: " + pluginArtifactId );
            }
            else
            {
                if ( pluginArtifactId.equals( testPluginArtifactId ) )
                {
                    testPlugin = plugin;
                }
                
                Integer count = (Integer) validPluginCounts.get( pluginArtifactId );
                
                if ( count.intValue() > 0 )
                {
                    fail( "Multiple copies of plugin: " + pluginArtifactId + " found in POM." );
                }
                else
                {
                    count = new Integer( count.intValue() + 1 );
                    
                    validPluginCounts.put( pluginArtifactId, count );
                }
            }
        }
        
        List executions = testPlugin.getExecutions();
        
        assertEquals( 1, executions.size() );
    }
1606#// ----------------------------------------------------------------------
    //
    // p1 inherits from p0
    // p0 inhertis from super model
    //
    // or we can show it graphically as:
    //
    // p1 ---> p0 --> super model
    //
    // ----------------------------------------------------------------------

    public void testProjectInheritance()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProject( pom0 );
        MavenProject project1 = getProject( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
    }
1607#// ----------------------------------------------------------------------
    //
    // p1 inherits from p0
    // p0 inhertis from super model
    //
    // or we can show it graphically as:
    //
    // p1 ---> p0 --> super model
    //
    // p1 has a depMgmt section that specifies versions 1.0 of jars "a" & "b"
    // jar "a" has a transitive dependency on 2.0 of jar "b", but maven should
    // prefer to use version 1.0.
    //
    // ----------------------------------------------------------------------

    public void testDependencyManagementOverridesTransitiveDependencyVersion()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        assertTrue( "Set size should be 3, is " + set.size(), set.size() == 3 );

        Iterator iter = set.iterator();
        while ( iter.hasNext() )
        {
            Artifact artifact = (Artifact) iter.next();
            System.out.println( "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion()
              + " Optional=" + ( artifact.isOptional() ? "true" : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }
1608#// ----------------------------------------------------------------------
    //
    // p1 inherits from p0
    // p0 inhertis from super model
    //
    // or we can show it graphically as:
    //
    // p1 ---> p0 --> super model
    //
    // ----------------------------------------------------------------------

    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        Iterator iter = set.iterator();

        while ( iter.hasNext() )
        {
            Artifact artifact = (Artifact) iter.next();
            System.out.println( "Artifact: " + artifact.getDependencyConflictId() + " "
                    + artifact.getVersion() + " Scope: " + artifact.getScope() );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(), artifact.getVersion().equals( "1.0" ) );
        }

    }
1609#// ----------------------------------------------------------------------
    //
    // p1 inherits from p0
    // p0 inhertis from super model
    //
    // or we can show it graphically as:
    //
    // p1 ---> p0 --> super model
    //
    // ----------------------------------------------------------------------

    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        Iterator iter = set.iterator();
        assertTrue( "Set size should be 4, is " + set.size(), set.size() == 4 );

        while ( iter.hasNext() )
        {
            Artifact artifact = (Artifact) iter.next();
            System.out.println( "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion()
              + " Optional=" + ( artifact.isOptional() ? "true" : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }
1610#// ----------------------------------------------------------------------
    //
    // p1 inherits from p0
    // p0 inhertis from super model
    //
    // or we can show it graphically as:
    //
    // p1 ---> p0 --> super model
    //
    // ----------------------------------------------------------------------

    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        System.out.println("Project " + project1.getId() + " " + project1);
        Set set = project1.getArtifacts();
        assertNotNull("No artifacts", set);
        assertTrue("No Artifacts", set.size() > 0);
        assertTrue("Set size should be 3, is " + set.size(), set.size() == 3 );

        Iterator iter = set.iterator();

        while (iter.hasNext())
        {
            Artifact artifact = (Artifact)iter.next();
            assertFalse( "", artifact.getArtifactId().equals( "t07-d" ) );
            System.out.println("Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion() + " Optional=" + (artifact.isOptional() ? "true" : "false"));
            assertTrue("Incorrect version for " + artifact.getDependencyConflictId(), artifact.getVersion().equals("1.0"));
        }
    }
1611#// ----------------------------------------------------------------------
    //
    // p1 inherits from p0
    // p0 inhertis from super model
    //
    // or we can show it graphically as:
    //
    // p1 ---> p0 --> super model
    //
    // ----------------------------------------------------------------------

    public void testDependencyManagement()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();
        File pom0 = new File( localRepo, "p0/pom.xml" );

        File pom0Basedir = pom0.getParentFile();

        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load everything...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        System.out.println( "Project " + project1.getId() + " " + project1 );
        Set set = project1.getArtifacts();
        assertNotNull( "No artifacts", set );
        assertTrue( "No Artifacts", set.size() > 0 );
        Iterator iter = set.iterator();
        assertTrue( "Set size should be 4, is " + set.size(), set.size() == 4 );

        while ( iter.hasNext() )
        {
            Artifact artifact = (Artifact) iter.next();
            System.out.println( "Artifact: " + artifact.getDependencyConflictId() + " " + artifact.getVersion()
              + " Optional=" + ( artifact.isOptional() ? "true" : "false" ) );
            assertTrue( "Incorrect version for " + artifact.getDependencyConflictId(),
                        artifact.getVersion().equals( "1.0" ) );
        }

    }
1612#// ----------------------------------------------------------------------
    //
    // p1 inherits from p0
    // p0 inhertis from super model
    //
    // or we can show it graphically as:
    //
    // p1 ---> p0 --> super model
	//
    // ----------------------------------------------------------------------

    /**
     * How the test project is set up:
     *
     * 1. dependencyManagement lists dependencies on a & b,
     *    with an exclusion on c in b.
     * 2. the child project lists a dependency on project a only
     * 3. a depends on b (which is transitive to the child project),
     *    and b depends on c.
     *
     * We should see that the resulting size of collected artifacts is two:
     * a & b only.
     */
    public void testDependencyManagementExclusionsExcludeTransitively()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();

        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertNotNull("Parent is null", project1.getParent());
        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        Map map = project1.getArtifactMap();

        assertNotNull("No artifacts", map);
        assertTrue("No Artifacts", map.size() > 0);
        assertTrue("Set size should be 2, is " + map.size(), map.size() == 2);

        assertTrue("maven-test:t09-a is not in the project", map.containsKey( "maven-test:t09-a" ));
        assertTrue("maven-test:t09-b is not in the project", map.containsKey( "maven-test:t09-b" ));
        assertFalse("maven-test:t09-c is in the project", map.containsKey( "maven-test:t09-c" ));
    }
1613#/**
     * Setup exactly the same as the above test, except that the child project
     * now depends upon d, which has a transitive dependency on c.  Even though
     * we did list an exclusion on c, it was only from within the context of
     * project b.  We will pick up project c in this case because no
     * restrictions were placed on d.  This demonstrates that a, b, c, & d will
     * all be collected.
     *
     * @throws Exception
     */
    public void testDependencyManagementExclusionDoesNotOverrideGloballyForTransitives()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();

        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom2 = new File( pom0Basedir, "p2/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project2 = getProjectWithDependencies( pom2 );

        assertEquals( pom0Basedir, project2.getParent().getBasedir() );
        Map map = project2.getArtifactMap();
        assertNotNull( "No artifacts", map );
        assertTrue( "No Artifacts", map.size() > 0 );
        assertTrue( "Set size should be 4, is " + map.size(), map.size() == 4 );

        assertTrue( "maven-test:t09-a is not in the project", map.containsKey( "maven-test:t09-a" ) );
        assertTrue( "maven-test:t09-b is not in the project", map.containsKey( "maven-test:t09-b" ) );
        assertTrue( "maven-test:t09-c is not in the project", map.containsKey( "maven-test:t09-c" ) );
        assertTrue( "maven-test:t09-d is not in the project", map.containsKey( "maven-test:t09-d" ) );
    }
1614#// ----------------------------------------------------------------------
    //
    // p1 inherits from p0
    // p0 inhertis from super model
    //
    // or we can show it graphically as:
    //
    // p1 ---> p0 --> super model
	//
    // ----------------------------------------------------------------------

    public void testDependencyManagementOverridesTransitiveDependencyVersion()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();

        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        System.out.println("Project " + project1.getId() + " " + project1);
        Map map = project1.getArtifactMap();
        assertNotNull("No artifacts", map);
        assertTrue("No Artifacts", map.size() > 0);
        assertTrue("Set size should be 3, is " + map.size(), map.size() == 3);

        Artifact a = (Artifact) map.get("maven-test:t10-a");
        Artifact b = (Artifact) map.get("maven-test:t10-b");
        Artifact c = (Artifact) map.get("maven-test:t10-c");

        assertNotNull( a );
        assertNotNull( b );
        assertNotNull( c );

        // inherited from depMgmt
        System.out.println(a.getScope());
        assertTrue("Incorrect scope for " + a.getDependencyConflictId(), a.getScope().equals("test"));

        // transitive dep, overridden b depMgmt
        assertTrue("Incorrect scope for " + b.getDependencyConflictId(), b.getScope().equals("runtime"));

        // direct dep, overrides depMgmt
        assertTrue("Incorrect scope for " + c.getDependencyConflictId(), c.getScope().equals("runtime"));

    }
1615#// ----------------------------------------------------------------------
    //
    // p1 inherits from p0
    // p0 inhertis from super model
    //
    // or we can show it graphically as:
    //
    // p1 ---> p0 --> super model
    //
    // ----------------------------------------------------------------------

    public void testDependencyManagementDoesNotOverrideScopeOfCurrentArtifact()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();

        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project0 = getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        assertEquals( pom0Basedir, project1.getParent().getBasedir() );
        assertNull( "dependencyManagement has overwritten the scope of the currently building child project",
                    project1.getArtifact().getScope() );
    }
1616#// ----------------------------------------------------------------------
    //
    // p1 inherits from p0
    // p0 inherits from super model
    //
    // or we can show it graphically as:
    //
    // p1 ---> p0 --> super model
    //
    // ----------------------------------------------------------------------

    public void testFalsePluginExecutionInheritValue() throws Exception
    {
        File localRepo = getLocalRepositoryPath();

        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom1 = new File( pom0Basedir, "p1/pom.xml" );

        getProjectWithDependencies( pom0 );
        MavenProject project1 = getProjectWithDependencies( pom1 );

        Map pluginMap = project1.getBuild().getPluginsAsMap();
        Plugin compilerPlugin = (Plugin) pluginMap.get( "org.apache.maven.plugins:maven-compiler-plugin" );

        assertNotNull( compilerPlugin );

        Map executionMap = compilerPlugin.getExecutionsAsMap();
        assertNull( "Plugin execution: \'test\' should NOT exist in the compiler plugin specification for the child project!", executionMap.get( "test" ) );
    }
1617#// ----------------------------------------------------------------------
    //
    // p1 inherits from p0
    // p0 inhertis from super model
    //
    // or we can show it graphically as:
    //
    // p1 ---> p0 --> super model
    //
    // ----------------------------------------------------------------------

    public void testScmInfoCalculatedCorrectlyOnParentAndChildRead()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();

        File pom0 = new File( localRepo, "p0/pom.xml" );
        File pom0Basedir = pom0.getParentFile();
        File pom1 = new File( pom0Basedir, "modules/p1/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project0 = getProject( pom0 );
        MavenProject project1 = getProject( pom1 );

        System.out.println( "\n\n" );
        System.out.println( "Parent SCM URL is: " + project0.getScm().getUrl() );
        System.out.println( "Child SCM URL is: " + project1.getScm().getUrl() );
        System.out.println();
        System.out.println( "Parent SCM connection is: " + project0.getScm().getConnection() );
        System.out.println( "Child SCM connection is: " + project1.getScm().getConnection() );
        System.out.println();
        System.out.println( "Parent SCM developer connection is: "
                            + project0.getScm().getDeveloperConnection() );
        System.out.println( "Child SCM developer connection is: "
                            + project1.getScm().getDeveloperConnection() );

        assertEquals( project1.getScm().getUrl(), project0.getScm().getUrl() + "/modules/p1" );
        assertEquals( project1.getScm().getConnection(), project0.getScm().getConnection()
                                                         + "/modules/p1" );
        assertEquals( project1.getScm().getDeveloperConnection(), project0.getScm()
                                                                          .getDeveloperConnection()
                                                                  + "/modules/p1" );
    }
1618#public void testScmInfoCalculatedCorrectlyOnChildOnlyRead()
        throws Exception
    {
        File localRepo = getLocalRepositoryPath();

        File pom1 = new File( localRepo, "p0/modules/p1/pom.xml" );

        // load the child project, which inherits from p0...
        MavenProject project1 = getProject( pom1 );

        System.out.println( "\n\n" );
        System.out.println( "Child SCM URL is: " + project1.getScm().getUrl() );
        System.out.println( "Child SCM connection is: " + project1.getScm().getConnection() );
        System.out.println( "Child SCM developer connection is: "
                            + project1.getScm().getDeveloperConnection() );

        assertEquals( "http://host/viewer?path=/p0/modules/p1", project1.getScm().getUrl() );
        assertEquals( "scm:svn:http://host/p0/modules/p1", project1.getScm().getConnection() );
        assertEquals( "scm:svn:https://host/p0/modules/p1", project1.getScm().getDeveloperConnection() );
    }
1619#public void testAlignToBasedirWhereBasedirExpressionIsTheCompleteValue()
    {
        File basedir = new File( System.getProperty( "java.io.tmpdir" ), "test" ).getAbsoluteFile();

        String aligned = new DefaultPathTranslator().alignToBaseDirectory( "${basedir}", basedir );

        assertEquals( basedir.getAbsolutePath(), aligned );
    }
1620#public void testAlignToBasedirWhereBasedirExpressionIsTheValuePrefix()
    {
        File basedir = new File( System.getProperty( "java.io.tmpdir" ), "test" ).getAbsoluteFile();

        String aligned = new DefaultPathTranslator().alignToBaseDirectory( "${basedir}/dir", basedir );

        assertEquals( new File( basedir, "dir" ).getAbsolutePath(), aligned );
    }
1621#public void testUnalignToBasedirWherePathEqualsBasedir()
    {
        File basedir = new File( System.getProperty( "java.io.tmpdir" ), "test" ).getAbsoluteFile();

        String unaligned = new DefaultPathTranslator().unalignFromBaseDirectory( basedir.getAbsolutePath(), basedir );

        assertEquals( ".", unaligned );
    }
1622#public String getId()
    {
        return "legacy";
    }
1623#public String pathOf( Artifact artifact )
    {
        ArtifactHandler artifactHandler = artifact.getArtifactHandler();

        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getGroupId() ).append( '/' );
        path.append( artifactHandler.getDirectory() ).append( '/' );
        path.append( artifact.getArtifactId() ).append( '-' ).append( artifact.getVersion() );

        if ( artifact.hasClassifier() )
        {
            path.append( '-' ).append( artifact.getClassifier() );
        }

        if ( artifactHandler.getExtension() != null && artifactHandler.getExtension().length() > 0 )
        {
            path.append( '.' ).append( artifactHandler.getExtension() );
        }

        return path.toString();
    }
1624#public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata,
                                                 ArtifactRepository repository )
    {
        return pathOfRepositoryMetadata( metadata, metadata.getLocalFilename( repository ) );
    }
1625#private String pathOfRepositoryMetadata( ArtifactMetadata metadata,
                                             String filename )
    {
        StringBuilder path = new StringBuilder( 128 );

        path.append( metadata.getGroupId() ).append( PATH_SEPARATOR ).append( "poms" ).append( PATH_SEPARATOR );

        path.append( filename );

        return path.toString();
    }
1626#public String pathOfRemoteRepositoryMetadata( ArtifactMetadata metadata )
    {
        return pathOfRepositoryMetadata( metadata, metadata.getRemoteFilename() );
    }
1627#protected void setUp()
        throws Exception
    {
        mirrorSelector = (DefaultMirrorSelector) lookup( MirrorSelector.class );
        repositorySystem = lookup( ArtifactRepositoryFactory.class );
    }
1628#@Override
    protected void tearDown()
        throws Exception
    {
        mirrorSelector = null;
        repositorySystem = null;

        super.tearDown();
    }
1629#public void testExternalURL()
    {
        assertTrue( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "http://somehost" ) ) );
        assertTrue( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "http://somehost:9090/somepath" ) ) );
        assertTrue( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "ftp://somehost" ) ) );
        assertTrue( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "http://192.168.101.1" ) ) );
        assertTrue( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "http://" ) ) );
        // these are local
        assertFalse( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "http://localhost:8080" ) ) );
        assertFalse( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "http://127.0.0.1:9090" ) ) );
        assertFalse( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "file://localhost/somepath" ) ) );
        assertFalse( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "file://localhost/D:/somepath" ) ) );
        assertFalse( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "http://localhost" ) ) );
        assertFalse( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "http://127.0.0.1" ) ) );
        assertFalse( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "file:///somepath" ) ) );
        assertFalse( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "file://D:/somepath" ) ) );

        // not a proper url so returns false;
        assertFalse( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "192.168.101.1" ) ) );
        assertFalse( DefaultMirrorSelector.isExternalRepo( getRepo( "foo", "" ) ) );
    }
1630#public void testMirrorLookup()
    {
        Mirror mirrorA = newMirror( "a", "a", "http://a" );
        Mirror mirrorB = newMirror( "b", "b", "http://b" );

        List<Mirror> mirrors = Arrays.asList( mirrorA, mirrorB );

        assertSame( mirrorA, mirrorSelector.getMirror( getRepo( "a", "http://a.a" ), mirrors ) );

        assertSame( mirrorB, mirrorSelector.getMirror( getRepo( "b", "http://a.a" ), mirrors ) );

        assertNull( mirrorSelector.getMirror( getRepo( "c", "http://c.c" ), mirrors ) );
    }
1631#public void testMirrorWildcardLookup()
    {
        Mirror mirrorA = newMirror( "a", "a", "http://a" );
        Mirror mirrorB = newMirror( "b", "b", "http://b" );
        Mirror mirrorC = newMirror( "c", "*", "http://wildcard" );

        List<Mirror> mirrors = Arrays.asList( mirrorA, mirrorB, mirrorC );

        assertSame( mirrorA, mirrorSelector.getMirror( getRepo( "a", "http://a.a" ), mirrors ) );

        assertSame( mirrorB, mirrorSelector.getMirror( getRepo( "b", "http://a.a" ), mirrors ) );

        assertSame( mirrorC, mirrorSelector.getMirror( getRepo( "c", "http://c.c" ), mirrors ) );
    }
1632#public void testMirrorStopOnFirstMatch()
    {
        // exact matches win first
        Mirror mirrorA2 = newMirror( "a2", "a,b", "http://a2" );
        Mirror mirrorA = newMirror( "a", "a", "http://a" );
        // make sure repeated entries are skipped
        Mirror mirrorA3 = newMirror( "a", "a", "http://a3" );

        Mirror mirrorB = newMirror( "b", "b", "http://b" );
        Mirror mirrorC = newMirror( "c", "d,e", "http://de" );
        Mirror mirrorC2 = newMirror( "c", "*", "http://wildcard" );
        Mirror mirrorC3 = newMirror( "c", "e,f", "http://ef" );

        List<Mirror> mirrors = Arrays.asList( mirrorA2, mirrorA, mirrorA3, mirrorB, mirrorC, mirrorC2, mirrorC3 );

        assertSame( mirrorA, mirrorSelector.getMirror( getRepo( "a", "http://a.a" ), mirrors ) );

        assertSame( mirrorB, mirrorSelector.getMirror( getRepo( "b", "http://a.a" ), mirrors ) );

        assertSame( mirrorC2, mirrorSelector.getMirror( getRepo( "c", "http://c.c" ), mirrors ) );

        assertSame( mirrorC, mirrorSelector.getMirror( getRepo( "d", "http://d" ), mirrors ) );

        assertSame( mirrorC, mirrorSelector.getMirror( getRepo( "e", "http://e" ), mirrors ) );

        assertSame( mirrorC2, mirrorSelector.getMirror( getRepo( "f", "http://f" ), mirrors ) );
    }
1633#public void testPatterns()
    {
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a" ), "*" ) );
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a" ), "*," ) );
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a" ), ",*," ) );
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a" ), "*," ) );

        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a" ), "a" ) );
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a" ), "a," ) );
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a" ), ",a," ) );
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a" ), "a," ) );

        assertFalse( DefaultMirrorSelector.matchPattern( getRepo( "b" ), "a" ) );
        assertFalse( DefaultMirrorSelector.matchPattern( getRepo( "b" ), "a," ) );
        assertFalse( DefaultMirrorSelector.matchPattern( getRepo( "b" ), ",a" ) );
        assertFalse( DefaultMirrorSelector.matchPattern( getRepo( "b" ), ",a," ) );

        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a" ), "a,b" ) );
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "b" ), "a,b" ) );

        assertFalse( DefaultMirrorSelector.matchPattern( getRepo( "c" ), "a,b" ) );

        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a" ), "*" ) );
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a" ), "*,b" ) );
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a" ), "*,!b" ) );

        assertFalse( DefaultMirrorSelector.matchPattern( getRepo( "a" ), "*,!a" ) );
        assertFalse( DefaultMirrorSelector.matchPattern( getRepo( "a" ), "!a,*" ) );

        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "c" ), "*,!a" ) );
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "c" ), "!a,*" ) );

        assertFalse( DefaultMirrorSelector.matchPattern( getRepo( "c" ), "!a,!c" ) );
        assertFalse( DefaultMirrorSelector.matchPattern( getRepo( "d" ), "!a,!c*" ) );
    }
1634#public void testPatternsWithExternal()
    {
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a", "http://localhost" ), "*" ) );
        assertFalse( DefaultMirrorSelector.matchPattern( getRepo( "a", "http://localhost" ), "external:*" ) );

        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a", "http://localhost" ), "external:*,a" ) );
        assertFalse( DefaultMirrorSelector.matchPattern( getRepo( "a", "http://localhost" ), "external:*,!a" ) );
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "a", "http://localhost" ), "a,external:*" ) );
        assertFalse( DefaultMirrorSelector.matchPattern( getRepo( "a", "http://localhost" ), "!a,external:*" ) );

        assertFalse( DefaultMirrorSelector.matchPattern( getRepo( "c", "http://localhost" ), "!a,external:*" ) );
        assertTrue( DefaultMirrorSelector.matchPattern( getRepo( "c", "http://somehost" ), "!a,external:*" ) );
    }
1635#public void testLayoutPattern()
    {
        assertTrue( DefaultMirrorSelector.matchesLayout( "default", null ) );
        assertTrue( DefaultMirrorSelector.matchesLayout( "default", "" ) );
        assertTrue( DefaultMirrorSelector.matchesLayout( "default", "*" ) );

        assertTrue( DefaultMirrorSelector.matchesLayout( "default", "default" ) );
        assertFalse( DefaultMirrorSelector.matchesLayout( "default", "legacy" ) );

        assertTrue( DefaultMirrorSelector.matchesLayout( "default", "legacy,default" ) );
        assertTrue( DefaultMirrorSelector.matchesLayout( "default", "default,legacy" ) );

        assertFalse( DefaultMirrorSelector.matchesLayout( "default", "legacy,!default" ) );
        assertFalse( DefaultMirrorSelector.matchesLayout( "default", "!default,legacy" ) );

        assertFalse( DefaultMirrorSelector.matchesLayout( "default", "*,!default" ) );
        assertFalse( DefaultMirrorSelector.matchesLayout( "default", "!default,*" ) );
    }
1636#public void testMirrorLayoutConsideredForMatching()
    {
        ArtifactRepository repo = getRepo( "a" );

        Mirror mirrorA = newMirror( "a", "a", null, "http://a" );
        Mirror mirrorB = newMirror( "b", "a", "p2", "http://b" );

        Mirror mirrorC = newMirror( "c", "*", null, "http://c" );
        Mirror mirrorD = newMirror( "d", "*", "p2", "http://d" );

        assertSame( mirrorA, mirrorSelector.getMirror( repo, Arrays.asList( mirrorA ) ) );
        assertNull( mirrorSelector.getMirror( repo, Arrays.asList( mirrorB ) ) );

        assertSame( mirrorC, mirrorSelector.getMirror( repo, Arrays.asList( mirrorC ) ) );
        assertNull( mirrorSelector.getMirror( repo, Arrays.asList( mirrorD ) ) );
    }
1637#/**
     * Build an ArtifactRepository object.
     *
     * @param id
     * @param url
     * @return
     */
    private ArtifactRepository getRepo( String id, String url )
    {
        return repositorySystem.createArtifactRepository( id, url, new DefaultRepositoryLayout(), null, null );
    }
1638#/**
     * Build an ArtifactRepository object.
     *
     * @param id
     * @return
     */
    private ArtifactRepository getRepo( String id )
    {
        return getRepo( id, "http://something" );
    }
1639#private Mirror newMirror( String id, String mirrorOf, String url )
    {
        return newMirror( id, mirrorOf, null, url );
    }
1640#private Mirror newMirror( String id, String mirrorOf, String layouts, String url )
    {
        Mirror mirror = new Mirror();

        mirror.setId( id );
        mirror.setMirrorOf( mirrorOf );
        mirror.setMirrorOfLayouts( layouts );
        mirror.setUrl( url );

        return mirror;
    }
1641#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();
        repositorySystem = lookup( RepositorySystem.class, "default" );
        resolutionErrorHandler = lookup( ResolutionErrorHandler.class );
    }
1642#@Override
    protected void tearDown()
        throws Exception
    {
        repositorySystem = null;
        resolutionErrorHandler = null;
        super.tearDown();
    }
1643#protected List<ArtifactRepository> getRemoteRepositories()
        throws Exception
    {
        File repoDir = new File( getBasedir(), "src/test/remote-repo" ).getAbsoluteFile();

        RepositoryPolicy policy = new RepositoryPolicy();
        policy.setEnabled( true );
        policy.setChecksumPolicy( "ignore" );
        policy.setUpdatePolicy( "always" );

        Repository repository = new Repository();
        repository.setId( RepositorySystem.DEFAULT_REMOTE_REPO_ID );
        repository.setUrl( "file://" + repoDir.toURI().getPath() );
        repository.setReleases( policy );
        repository.setSnapshots( policy );

        return Arrays.asList( repositorySystem.buildArtifactRepository( repository ) );
    }
1644#protected ArtifactRepository getLocalRepository()
        throws Exception
    {
        File repoDir = new File( getBasedir(), "target/local-repo" ).getAbsoluteFile();

        return repositorySystem.createLocalRepository( repoDir );
    }
1645#public void testThatASystemScopedDependencyIsNotResolvedFromRepositories()
        throws Exception
    {
        //
        // We should get a whole slew of dependencies resolving this artifact transitively
        //
        Dependency d = new Dependency();
        d.setGroupId( "org.apache.maven.its" );
        d.setArtifactId( "b" );
        d.setVersion( "0.1" );
        d.setScope( Artifact.SCOPE_COMPILE );
        Artifact artifact = repositorySystem.createDependencyArtifact( d );
        
        ArtifactResolutionRequest request = new ArtifactResolutionRequest()
            .setArtifact( artifact )
            .setResolveRoot( true )
            .setResolveTransitively( true )
            .setRemoteRepositories( getRemoteRepositories() )
            .setLocalRepository( getLocalRepository() );            
                            
        DefaultRepositorySystemSession session = new DefaultRepositorySystemSession();
        session.setLocalRepositoryManager( new SimpleLocalRepositoryManager( request.getLocalRepository().getBasedir() ) );
        LegacySupport legacySupport = lookup( LegacySupport.class );
        legacySupport.setSession( new MavenSession( getContainer(), session, new DefaultMavenExecutionRequest(),
                                                    new DefaultMavenExecutionResult() ) );

        ArtifactResolutionResult result = repositorySystem.resolve( request );
        resolutionErrorHandler.throwErrors( request, result );        
        assertEquals( 2, result.getArtifacts().size() );
        
        //
        // System scoped version which should 
        //        
        d.setScope( Artifact.SCOPE_SYSTEM );
        File file = new File( getBasedir(), "src/test/repository-system/maven-core-2.1.0.jar" );
        assertTrue( file.exists() );
        d.setSystemPath( file.getCanonicalPath() );
        
        artifact = repositorySystem.createDependencyArtifact( d );
        
        //
        // The request has not set any local or remote repositories as the system scoped dependency being resolved should only
        // give us the dependency off the disk and nothing more.
        //
        request = new ArtifactResolutionRequest()
            .setArtifact( artifact )
            .setResolveRoot( true )
            .setResolveTransitively( true );
                            
        result = repositorySystem.resolve( request );
        resolutionErrorHandler.throwErrors( request, result );        
        assertEquals( 1, result.getArtifacts().size() );       

        //
        // Put in a bogus file to make sure missing files cause the resolution to fail.
        //        
        file = new File( getBasedir(), "src/test/repository-system/maven-monkey-2.1.0.jar" );
        assertFalse( file.exists() );
        d.setSystemPath( file.getCanonicalPath() );
        artifact = repositorySystem.createDependencyArtifact( d );
        
        //
        // The request has not set any local or remote repositories as the system scoped dependency being resolved should only
        // give us the dependency off the disk and nothing more.
        //
        request = new ArtifactResolutionRequest()
            .setArtifact( artifact )
            .setResolveRoot( true )
            .setResolveTransitively( true );
                     
        try
        {
            result = repositorySystem.resolve( request );
            resolutionErrorHandler.throwErrors( request, result );
        }
        catch( Exception e )
        {
            assertTrue( result.hasMissingArtifacts() );
        }
    }
1646#public void testLocalRepositoryBasedir()
        throws Exception
    {
        File localRepoDir = new File( "" ).getAbsoluteFile();

        ArtifactRepository localRepo = repositorySystem.createLocalRepository( localRepoDir );

        String basedir = localRepo.getBasedir();

        assertFalse( basedir.endsWith( "/" ) );
        assertFalse( basedir.endsWith( "\\" ) );

        assertEquals( localRepoDir, new File( basedir ) );

        assertEquals( localRepoDir.getPath(), basedir );
    }
1647#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();
        repositorySystem = lookup( RepositorySystem.class, "default" );
    }
1648#@Override
    protected void tearDown()
        throws Exception
    {
        repositorySystem = null;
        super.tearDown();
    }
1649#public void testThatLocalRepositoryWithSpacesIsProperlyHandled()
        throws Exception
    {
        File basedir = new File( "target/spacy path" ).getAbsoluteFile();
        ArtifactRepository repo = repositorySystem.createLocalRepository( basedir );
        assertEquals( basedir, new File( repo.getBasedir() ) );
    }
1650#public void testAuthenticationHandling()
        throws Exception
    {
        Server server = new Server();
        server.setId( "repository" );
        server.setUsername( "jason" );
        server.setPassword( "abc123" );

        ArtifactRepository repository =
            repositorySystem.createArtifactRepository( "repository", "http://foo", null, null, null );
        repositorySystem.injectAuthentication( Arrays.asList( repository ), Arrays.asList( server ) );
        Authentication authentication = repository.getAuthentication();
        assertNotNull( authentication );
        assertEquals( "jason", authentication.getUsername() );
        assertEquals( "abc123", authentication.getPassword() );
    }
1651#@Override
    protected String component()
    {
        return "updateCheckManager";
    }
1652#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();

        updateCheckManager = new DefaultUpdateCheckManager( new ConsoleLogger( Logger.LEVEL_DEBUG, "test" ) );
    }
1653#public void testArtifact() throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1-SNAPSHOT" );
        File file = new File( localRepository.getBasedir(), 
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        file.getParentFile().mkdirs();
        file.createNewFile();
        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertNull( updateCheckManager.readLastUpdated( touchFile,
                                                        updateCheckManager.getRepositoryKey( remoteRepository ) ) );
        
        assertFalse( updateCheckManager.getTouchfile( a ).exists() );
    }
1654#public void testMissingArtifact()
        throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1-SNAPSHOT" );
        File file = new File( localRepository.getBasedir(), 
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertFalse( file.exists() );
        assertNotNull( updateCheckManager.readLastUpdated( touchFile,
                                                           updateCheckManager.getRepositoryKey( remoteRepository ) ) );
    }
1655#public void testPom() throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1", "pom" );
        File file = new File( localRepository.getBasedir(), 
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        file.getParentFile().mkdirs();
        file.createNewFile();
        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertNull( updateCheckManager.readLastUpdated( touchFile,
                                                        updateCheckManager.getRepositoryKey( remoteRepository ) ) );
        
        assertFalse( updateCheckManager.getTouchfile( a ).exists() );
    }
1656#public void testMissingPom()
        throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createArtifact( "a", "0.0.1", "pom" );
        File file = new File( localRepository.getBasedir(), 
                              localRepository.pathOf( a ) );
        file.delete();
        a.setFile( file );

        File touchFile = updateCheckManager.getTouchfile( a );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        updateCheckManager.touch( a, remoteRepository, null );

        assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );

        assertFalse( file.exists() );
        assertNotNull( updateCheckManager.readLastUpdated( touchFile,
                                                           updateCheckManager.getRepositoryKey( remoteRepository ) ) );
    }
1657#public void testMetadata() throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createRemoteArtifact( "a", "0.0.1-SNAPSHOT" );
        RepositoryMetadata metadata = new ArtifactRepositoryMetadata( a );

        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOfLocalRepositoryMetadata( metadata, localRepository ) );
        file.delete();

        File touchFile = updateCheckManager.getTouchfile( metadata, file );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( metadata, remoteRepository, file ) );

        file.getParentFile().mkdirs();
        file.createNewFile();
        updateCheckManager.touch( metadata, remoteRepository, file );

        assertFalse( updateCheckManager.isUpdateRequired( metadata, remoteRepository, file ) );

        assertNotNull( updateCheckManager.readLastUpdated( touchFile, updateCheckManager.getMetadataKey( remoteRepository, file ) ) );
    }
1658#public void testMissingMetadata() throws Exception
    {
        ArtifactRepository remoteRepository = remoteRepository();

        ArtifactRepository localRepository = localRepository();

        Artifact a = createRemoteArtifact( "a", "0.0.1-SNAPSHOT" );
        RepositoryMetadata metadata = new ArtifactRepositoryMetadata( a );

        File file = new File( localRepository.getBasedir(),
                              localRepository.pathOfLocalRepositoryMetadata( metadata, localRepository ) );
        file.delete();

        File touchFile = updateCheckManager.getTouchfile( metadata, file );
        touchFile.delete();

        assertTrue( updateCheckManager.isUpdateRequired( metadata, remoteRepository, file ) );

        updateCheckManager.touch( metadata, remoteRepository, file );

        assertFalse( updateCheckManager.isUpdateRequired( metadata, remoteRepository, file ) );

        assertNotNull( updateCheckManager.readLastUpdated( touchFile, updateCheckManager.getMetadataKey( remoteRepository, file ) ) );
    }
1659#public void testArtifactTouchFileName() throws Exception
    {
        ArtifactFactory artifactFactory = (ArtifactFactory) lookup( ArtifactFactory.ROLE );

        ArtifactRepository localRepository = localRepository();

        Artifact a = artifactFactory.createArtifactWithClassifier( "groupdId", "a", "0.0.1-SNAPSHOT", "jar", null );
        File file = new File( localRepository.getBasedir(), 
                              localRepository.pathOf( a ) );
        a.setFile( file );

        assertEquals( "a-0.0.1-SNAPSHOT.jar.lastUpdated", updateCheckManager.getTouchfile( a ).getName() );

        a = artifactFactory.createArtifactWithClassifier( "groupdId", "a", "0.0.1-SNAPSHOT", "jar", "classifier" );
        file = new File( localRepository.getBasedir(), 
                              localRepository.pathOf( a ) );
        a.setFile( file );

        assertEquals( "a-0.0.1-SNAPSHOT-classifier.jar.lastUpdated", updateCheckManager.getTouchfile( a ).getName() );
    }
1660#public void setConfigurableField( String configurableField )
    {
        this.configurableField = configurableField;
    }
1661#public String getConfigurableField()
    {
        return configurableField;
    }
1662#public String[] getSupportedProtocols()
    {
        return new String[]{ "b1", "b2" };
    }
1663#public void addExpectedContent( String resourceName, String expectedContent )
    {
        this.expectedContent.put( resourceName, expectedContent );
    }
1664#public String[] getSupportedProtocols()
    {
        return new String[] { "string" };
    }
1665#@Override
    public void closeConnection()
        throws ConnectionException
    {
    }
1666#@Override
    public void fillInputData( InputData inputData )
        throws TransferFailedException, ResourceDoesNotExistException, AuthorizationException
    {
        Resource resource = inputData.getResource();

        String content = expectedContent.get( resource.getName() );
        
        if ( content != null )
        {
            resource.setContentLength( content.length() );
            resource.setLastModified( System.currentTimeMillis() );

            try
            {
                inputData.setInputStream( new ByteArrayInputStream( content.getBytes( "UTF-8" ) ) );
            }
            catch ( UnsupportedEncodingException e )
            {
                throw new Error( "broken JVM", e );
            }
        }
        else
        {
            throw new ResourceDoesNotExistException( "No content provided for " + resource.getName() );
        }
    }
1667#@Override
    public void fillOutputData( OutputData outputData )
        throws TransferFailedException
    {
        outputData.setOutputStream( new ByteArrayOutputStream() );
    }
1668#@Override
    protected void openConnectionInternal()
        throws ConnectionException, AuthenticationException
    {
    }
1669#public void clearExpectedContent()
    {
        expectedContent.clear();        
    }
1670#public String[] getSupportedProtocols()
    {
        return new String[] { "perlookup" };
    }
1671#protected void setUp()
        throws Exception
    {
        super.setUp();
        wagonManager = (DefaultWagonManager) lookup( WagonManager.class );
        artifactFactory = lookup( ArtifactFactory.class );
        artifactRepositoryFactory = lookup( ArtifactRepositoryFactory.class );
    }
1672#@Override
    protected void tearDown()
        throws Exception
    {
        wagonManager = null;
        artifactFactory = null;
        super.tearDown();
    }
1673#public void testUnnecessaryRepositoryLookup()
        throws Exception
    {
        Artifact artifact = createTestPomArtifact( "target/test-data/get-missing-pom" );

        List<ArtifactRepository> repos = new ArrayList<ArtifactRepository>();
        repos.add( artifactRepositoryFactory.createArtifactRepository( "repo1", "string://url1",
                                                                       new ArtifactRepositoryLayoutStub(), null, null ) );
        repos.add( artifactRepositoryFactory.createArtifactRepository( "repo2", "string://url2",
                                                                       new ArtifactRepositoryLayoutStub(), null, null ) );

        StringWagon wagon = (StringWagon) wagonManager.getWagon( "string" );
        wagon.addExpectedContent( repos.get( 0 ).getLayout().pathOf( artifact ), "expected" );
        wagon.addExpectedContent( repos.get( 1 ).getLayout().pathOf( artifact ), "expected" );

        class TransferListener
            extends AbstractTransferListener
        {
            public List<TransferEvent> events = new ArrayList<TransferEvent>();

            @Override
            public void transferInitiated( TransferEvent transferEvent )
            {
                events.add( transferEvent );
            }
        }

        TransferListener listener = new TransferListener();
        wagonManager.getArtifact( artifact, repos, listener, false );
        assertEquals( 1, listener.events.size() );
    }
1674#public void testGetMissingJar() throws TransferFailedException, UnsupportedProtocolException, IOException
    {
        Artifact artifact = createTestArtifact( "target/test-data/get-missing-jar", "jar" );

        ArtifactRepository repo = createStringRepo();

        try
        {
            wagonManager.getArtifact( artifact, repo, null, false );

            fail();
        }
        catch ( ResourceDoesNotExistException e )
        {
            assertTrue( true );
        }

        assertFalse( artifact.getFile().exists() );
    }
1675#public void testGetMissingJarForced() throws TransferFailedException, UnsupportedProtocolException, IOException
    {
        Artifact artifact = createTestArtifact( "target/test-data/get-missing-jar", "jar" );

        ArtifactRepository repo = createStringRepo();

        try
        {
            wagonManager.getArtifact( artifact, repo, null, false );

            fail();
        }
        catch ( ResourceDoesNotExistException e )
        {
            assertTrue( true );
        }

        assertFalse( artifact.getFile().exists() );
    }
1676#public void testGetRemoteJar()
        throws TransferFailedException, ResourceDoesNotExistException, UnsupportedProtocolException, IOException,
        AuthorizationException
    {
        Artifact artifact = createTestArtifact( "target/test-data/get-remote-jar", "jar" );

        ArtifactRepository repo = createStringRepo();

        StringWagon wagon = (StringWagon) wagonManager.getWagon( "string" );
        wagon.addExpectedContent( repo.getLayout().pathOf( artifact ), "expected" );

        MockControl control = MockControl.createControl( UpdateCheckManager.class );
        control.replay();

        wagonManager.getArtifact( artifact, repo, null, false );

        assertTrue( artifact.getFile().exists() );
        assertEquals( "expected", FileUtils.fileRead( artifact.getFile(), "UTF-8" ) );

        control.verify();
    }
1677#private Artifact createTestPomArtifact( String directory )
        throws IOException
    {
        File testData = getTestFile( directory );
        FileUtils.deleteDirectory( testData );
        testData.mkdirs();

        Artifact artifact = artifactFactory.createProjectArtifact( "test", "test", "1.0" );
        artifact.setFile( new File( testData, "test-1.0.pom" ) );
        assertFalse( artifact.getFile().exists() );
        return artifact;
    }
1678#private Artifact createTestArtifact( String directory, String type )
        throws IOException
    {
        return createTestArtifact( directory, "1.0", type );
    }
1679#private Artifact createTestArtifact( String directory, String version, String type )
        throws IOException
    {
        File testData = getTestFile( directory );
        FileUtils.deleteDirectory( testData );
        testData.mkdirs();

        Artifact artifact = artifactFactory.createBuildArtifact( "test", "test", version, type );
        artifact.setFile( new File( testData, "test-" + version + "." + artifact.getArtifactHandler().getExtension() ) );
        assertFalse( artifact.getFile().exists() );
        return artifact;
    }
1680#private ArtifactRepository createStringRepo()
    {
        return artifactRepositoryFactory.createArtifactRepository( "id", "string://url", new ArtifactRepositoryLayoutStub(), null, null );
    }
1681#/**
     * Build an ArtifactRepository object.
     *
     * @param id
     * @param url
     * @return
     */
    private ArtifactRepository getRepo( String id, String url )
    {
        return artifactRepositoryFactory.createArtifactRepository( id, url, new DefaultRepositoryLayout(), null, null );
    }
1682#/**
     * Build an ArtifactRepository object.
     *
     * @param id
     * @return
     */
    private ArtifactRepository getRepo( String id )
    {
        return getRepo( id, "http://something" );
    }
1683#public void testDefaultWagonManager()
        throws Exception
    {
        assertWagon( "a" );

        assertWagon( "b" );

        assertWagon( "c" );

        assertWagon( "string" );

        try
        {
            assertWagon( "d" );

            fail( "Expected :" + UnsupportedProtocolException.class.getName() );
        }
        catch ( UnsupportedProtocolException e )
        {
            // ok
            assertTrue( true );
        }
    }
1684#/**
     * Check that transfer listeners are properly removed after getArtifact and putArtifact
     */
    public void testWagonTransferListenerRemovedAfterGetArtifactAndPutArtifact()
        throws Exception
    {
        Artifact artifact = createTestArtifact( "target/test-data/transfer-listener", "jar" );
        ArtifactRepository repo = createStringRepo();
        StringWagon wagon = (StringWagon) wagonManager.getWagon( "string" );
        wagon.addExpectedContent( repo.getLayout().pathOf( artifact ), "expected" );

        /* getArtifact */
        assertFalse( "Transfer listener is registered before test",
                     wagon.getTransferEventSupport().hasTransferListener( transferListener ) );
        wagonManager.getArtifact( artifact, repo, transferListener, false );
        assertFalse( "Transfer listener still registered after getArtifact",
                     wagon.getTransferEventSupport().hasTransferListener( transferListener ) );

        /* putArtifact */
        File sampleFile = getTestFile( "target/test-file" );
        FileUtils.fileWrite( sampleFile.getAbsolutePath(), "sample file" );

        assertFalse( "Transfer listener is registered before test", wagon.getTransferEventSupport().hasTransferListener( transferListener ) );
        wagonManager.putArtifact( sampleFile, artifact, repo, transferListener );
        assertFalse( "Transfer listener still registered after putArtifact", wagon.getTransferEventSupport().hasTransferListener( transferListener ) );
    }
1685#/**
     * Checks the verification of checksums.
     */
    public void xtestChecksumVerification()
        throws Exception
    {
        ArtifactRepositoryPolicy policy = new ArtifactRepositoryPolicy( true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_FAIL );

        ArtifactRepository repo = artifactRepositoryFactory.createArtifactRepository( "id", "string://url", new ArtifactRepositoryLayoutStub(), policy, policy );

        Artifact artifact =
            new DefaultArtifact( "sample.group", "sample-art", VersionRange.createFromVersion( "1.0" ), "scope",
                                 "jar", "classifier", null );
        artifact.setFile( getTestFile( "target/sample-art" ) );

        StringWagon wagon = (StringWagon) wagonManager.getWagon( "string" );

        wagon.clearExpectedContent();
        wagon.addExpectedContent( "path", "lower-case-checksum" );
        wagon.addExpectedContent( "path.sha1", "2a25dc564a3b34f68237fc849066cbc7bb7a36a1" );

        try
        {
            wagonManager.getArtifact( artifact, repo, null, false );
        }
        catch ( ChecksumFailedException e )
        {
            fail( "Checksum verification did not pass: " + e.getMessage() );
        }

        wagon.clearExpectedContent();
        wagon.addExpectedContent( "path", "upper-case-checksum" );
        wagon.addExpectedContent( "path.sha1", "B7BB97D7D0B9244398D9B47296907F73313663E6" );

        try
        {
            wagonManager.getArtifact( artifact, repo, null, false );
        }
        catch ( ChecksumFailedException e )
        {
            fail( "Checksum verification did not pass: " + e.getMessage() );
        }

        wagon.clearExpectedContent();
        wagon.addExpectedContent( "path", "expected-failure" );
        wagon.addExpectedContent( "path.sha1", "b7bb97d7d0b9244398d9b47296907f73313663e6" );

        try
        {
            wagonManager.getArtifact( artifact, repo, null, false );
            fail( "Checksum verification did not fail" );
        }
        catch ( ChecksumFailedException e )
        {
            // expected
        }

        wagon.clearExpectedContent();
        wagon.addExpectedContent( "path", "lower-case-checksum" );
        wagon.addExpectedContent( "path.md5", "50b2cf50a103a965efac62b983035cac" );

        try
        {
            wagonManager.getArtifact( artifact, repo, null, false );
        }
        catch ( ChecksumFailedException e )
        {
            fail( "Checksum verification did not pass: " + e.getMessage() );
        }

        wagon.clearExpectedContent();
        wagon.addExpectedContent( "path", "upper-case-checksum" );
        wagon.addExpectedContent( "path.md5", "842F568FCCFEB7E534DC72133D42FFDC" );

        try
        {
            wagonManager.getArtifact( artifact, repo, null, false );
        }
        catch ( ChecksumFailedException e )
        {
            fail( "Checksum verification did not pass: " + e.getMessage() );
        }

        wagon.clearExpectedContent();
        wagon.addExpectedContent( "path", "expected-failure" );
        wagon.addExpectedContent( "path.md5", "b7bb97d7d0b9244398d9b47296907f73313663e6" );

        try
        {
            wagonManager.getArtifact( artifact, repo, null, false );
            fail( "Checksum verification did not fail" );
        }
        catch ( ChecksumFailedException e )
        {
            // expected
        }
    }
1686#public void testPerLookupInstantiation()
        throws Exception
    {
        String protocol = "perlookup";

        Wagon one = wagonManager.getWagon( protocol );
        Wagon two = wagonManager.getWagon( protocol );

        assertNotSame( one, two );
    }
1687#private void assertWagon( String protocol )
        throws Exception
    {
        Wagon wagon = wagonManager.getWagon( protocol );

        assertNotNull( "Check wagon, protocol=" + protocol, wagon );
    }
1688#public String getId()
        {
            return "test";
        }
1689#public String pathOfRemoteRepositoryMetadata( ArtifactMetadata metadata )
        {
            return "path";
        }
1690#public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository )
        {
            return "path";
        }
1691#public String pathOf( Artifact artifact )
        {
            return "path";
        }
1692#public String[] getSupportedProtocols()
    {
        return new String[]{ "c" };
    }
1693#public String[] getSupportedProtocols()
    {
        return new String[]{ "a" };
    }
1694#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();

        source = new Source();
        artifactFactory = (ArtifactFactory) lookup( ArtifactFactory.ROLE );
        artifactCollector = (LegacyArtifactCollector) lookup( LegacyArtifactCollector.class );

        projectArtifact = createArtifactSpec( "project", "1.0", null );
    }
1695#@Override
    protected void tearDown()
        throws Exception
    {
        artifactCollector = null;
        artifactFactory = null;
        super.tearDown();
    }
1696#// works, but we don't fail on cycles presently
    public void disabledtestCircularDependencyNotIncludingCurrentProject()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        b.addDependency( "a", "1.0" );
        try
        {
            collect( a );
            fail( "Should have failed on cyclic dependency not involving project" );
        }
        catch ( CyclicDependencyException expected )
        {
            assertTrue( true );
        }
    }
1697#// works, but we don't fail on cycles presently
    public void disabledtestCircularDependencyIncludingCurrentProject()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        b.addDependency( "project", "1.0" );
        try
        {
            collect( a );
            fail( "Should have failed on cyclic dependency involving project" );
        }
        catch ( CyclicDependencyException expected )
        {
            assertTrue( true );
        }
    }
1698#public void testResolveWithFilter()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        ArtifactSpec c = a.addDependency( "c", "3.0" );

        b.addDependency( "c", "2.0" );
        ArtifactSpec d = b.addDependency( "d", "4.0" );

        ArtifactResolutionResult res = collect( a );
        assertEquals( "Check artifact list",
                      createSet( new Object[] { a.artifact, b.artifact, c.artifact, d.artifact } ), res.getArtifacts() );

        ArtifactFilter filter = new ExclusionSetFilter( new String[] { "b" } );
        res = collect( a, filter );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, c.artifact } ), res.getArtifacts() );
    }
1699#public void testResolveCorrectDependenciesWhenDifferentDependenciesOnNearest()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        ArtifactSpec c2 = b.addDependency( "c", "2.0" );
        c2.addDependency( "d", "1.0" );

        ArtifactSpec e = createArtifactSpec( "e", "1.0" );
        ArtifactSpec c1 = e.addDependency( "c", "1.0" );
        ArtifactSpec f = c1.addDependency( "f", "1.0" );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, e.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact, e.artifact, c1.artifact,
            f.artifact } ), res.getArtifacts() );
        assertEquals( "Check version", "1.0", getArtifact( "c", res.getArtifacts() ).getVersion() );
    }
1700#public void disabledtestResolveCorrectDependenciesWhenDifferentDependenciesOnNewest()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        // TODO: use newest conflict resolver
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        ArtifactSpec c2 = b.addDependency( "c", "2.0" );
        ArtifactSpec d = c2.addDependency( "d", "1.0" );

        ArtifactSpec e = createArtifactSpec( "e", "1.0" );
        ArtifactSpec c1 = e.addDependency( "c", "1.0" );
        c1.addDependency( "f", "1.0" );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, e.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact, e.artifact, c2.artifact,
            d.artifact } ), res.getArtifacts() );
        assertEquals( "Check version", "2.0", getArtifact( "c", res.getArtifacts() ).getVersion() );
    }
1701#public void disabledtestResolveCorrectDependenciesWhenDifferentDependenciesOnNewestVersionReplaced()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        // TODO: use newest conflict resolver
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b1 = a.addDependency( "b", "1.0" );
        ArtifactSpec c = a.addDependency( "c", "1.0" );
        ArtifactSpec d2 = b1.addDependency( "d", "2.0" );
        d2.addDependency( "h", "1.0" );
        ArtifactSpec d1 = c.addDependency( "d", "1.0" );
        ArtifactSpec b2 = c.addDependency( "b", "2.0" );
        ArtifactSpec e = b2.addDependency( "e", "1.0" );
        ArtifactSpec g = d1.addDependency( "g", "1.0" );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact } ) );
        Object[] artifacts = new Object[] { a.artifact, c.artifact, d1.artifact, b2.artifact, e.artifact, g.artifact };
        assertEquals( "Check artifact list", createSet( artifacts ), res.getArtifacts() );
        assertEquals( "Check version", "1.0", getArtifact( "d", res.getArtifacts() ).getVersion() );
        assertEquals( "Check version", "2.0", getArtifact( "b", res.getArtifacts() ).getVersion() );
    }
1702#public void testResolveNearestNewestIsNearest()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        ArtifactSpec c = a.addDependency( "c", "3.0" );

        b.addDependency( "c", "2.0" );

        ArtifactResolutionResult res = collect( a );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact, c.artifact } ),
                      res.getArtifacts() );
        assertEquals( "Check version", "3.0", getArtifact( "c", res.getArtifacts() ).getVersion() );
    }
1703#public void testResolveNearestOldestIsNearest()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        ArtifactSpec c = a.addDependency( "c", "2.0" );

        b.addDependency( "c", "3.0" );

        ArtifactResolutionResult res = collect( a );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact, c.artifact } ),
                      res.getArtifacts() );
        assertEquals( "Check version", "2.0", getArtifact( "c", res.getArtifacts() ).getVersion() );
    }
1704#public void testResolveLocalNewestIsLocal()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        a.addDependency( "b", "2.0" );
        ArtifactSpec b = createArtifactSpec( "b", "3.0" );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );
        assertEquals( "Check version", "3.0", getArtifact( "b", res.getArtifacts() ).getVersion() );
    }
1705#public void testResolveLocalOldestIsLocal()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        a.addDependency( "b", "3.0" );
        ArtifactSpec b = createArtifactSpec( "b", "2.0" );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );
        assertEquals( "Check version", "2.0", getArtifact( "b", res.getArtifacts() ).getVersion() );
    }
1706#public void testResolveLocalWithNewerVersionButLesserScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "commons-logging", "1.0" );
        a.addDependency( "junit", "3.7" );
        ArtifactSpec b = createArtifactSpec( "junit", "3.8.1", Artifact.SCOPE_TEST );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );
        assertEquals( "Check version", "3.8.1", getArtifact( "junit", res.getArtifacts() ).getVersion() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_TEST, getArtifact( "junit", res.getArtifacts() ).getScope() );
    }
1707#public void testResolveLocalWithNewerVersionButLesserScopeResolvedFirst()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec b = createArtifactSpec( "junit", "3.8.1", Artifact.SCOPE_TEST );
        ArtifactSpec a = createArtifactSpec( "commons-logging", "1.0" );
        a.addDependency( "junit", "3.7" );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );
        assertEquals( "Check version", "3.8.1", getArtifact( "junit", res.getArtifacts() ).getVersion() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_TEST, getArtifact( "junit", res.getArtifacts() ).getScope() );
    }
1708#public void testResolveNearestWithRanges()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        ArtifactSpec c = a.addDependency( "c", "2.0" );

        b.addDependency( "c", "[1.0,3.0]" );

        ArtifactResolutionResult res = collect( a );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact, c.artifact } ),
                      res.getArtifacts() );
        assertEquals( "Check version", "2.0", getArtifact( "c", res.getArtifacts() ).getVersion() );
    }
1709#public void testResolveRangeWithManagedVersion()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "[1.0,3.0]" );

        ArtifactSpec managedB = createArtifactSpec( "b", "5.0" );

        ArtifactResolutionResult res = collect( a, managedB.artifact );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, managedB.artifact } ),
                      res.getArtifacts() );
        assertEquals( "Check version", "5.0", getArtifact( "b", res.getArtifacts() ).getVersion() );
    }
1710#public void testCompatibleRanges()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        a.addDependency( "c", "[2.0,2.5]" );
        b.addDependency( "c", "[1.0,3.0]" );
        ArtifactSpec c = createArtifactSpec( "c", "2.5" );

        ArtifactResolutionResult res = collect( a );

        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact, c.artifact } ),
                      res.getArtifacts() );
        assertEquals( "Check version", "2.5", getArtifact( "c", res.getArtifacts() ).getVersion() );
    }
1711#public void testIncompatibleRanges()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        a.addDependency( "c", "[2.4,3.0]" );

        b.addDependency( "c", "[1.0,2.0]" );

        ArtifactResolutionResult res = collect( a );

        assertTrue( res.hasVersionRangeViolations() );
    }
1712#public void testUnboundedRangeWhenVersionUnavailable()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = a.addDependency( "b", "1.0" );
        a.addDependency( "c", "[2.0,]" );
        b.addDependency( "c", "[1.0,]" );

        ArtifactResolutionResult res = collect( a );

        assertTrue( res.hasVersionRangeViolations() );
    }
1713#public void testUnboundedRangeBelowLastRelease()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        createArtifactSpec( "c", "1.5" );
        ArtifactSpec c = createArtifactSpec( "c", "2.0" );
        createArtifactSpec( "c", "1.1" );
        a.addDependency( "c", "[1.0,)" );

        ArtifactResolutionResult res = collect( a );

        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, c.artifact } ), res.getArtifacts() );
        assertEquals( "Check version", "2.0", getArtifact( "c", res.getArtifacts() ).getVersion() );
    }
1714#public void testUnboundedRangeAboveLastRelease()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        createArtifactSpec( "c", "2.0" );
        a.addDependency( "c", "[10.0,)" );

        ArtifactResolutionResult res = collect( a );

        assertTrue( res.hasVersionRangeViolations() );
    }
1715#public void testResolveManagedVersion()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        a.addDependency( "b", "3.0", Artifact.SCOPE_RUNTIME );

        Artifact managedVersion = createArtifactSpec( "b", "5.0" ).artifact;
        Artifact modifiedB = createArtifactSpec( "b", "5.0", Artifact.SCOPE_RUNTIME ).artifact;

        ArtifactResolutionResult res = collect( a, managedVersion );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedB } ), res.getArtifacts() );
    }
1716#public void testCollectChangesVersionOfOriginatingArtifactIfInDependencyManagementHasDifferentVersion()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );

        Artifact artifact = projectArtifact.artifact;
        Artifact managedVersion = createArtifactSpec( artifact.getArtifactId(), "2.0" ).artifact;

        ArtifactResolutionResult result = collect( a, managedVersion );

        assertEquals( "collect has modified version in originating artifact", "1.0", artifact.getVersion() );

        Artifact resolvedArtifact = result.getArtifacts().iterator().next();

        assertEquals( "Resolved version don't match original artifact version", "1.0", resolvedArtifact.getVersion() );
    }
1717#public void testResolveCompileScopeOverTestScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_TEST );

        a.addDependency( "c", "2.0", Artifact.SCOPE_COMPILE );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_COMPILE ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_COMPILE, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_TEST, artifact.getScope() );
    }
1718#public void testResolveRuntimeScopeOverTestScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_TEST );

        a.addDependency( "c", "2.0", Artifact.SCOPE_RUNTIME );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_RUNTIME ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_RUNTIME, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_TEST, artifact.getScope() );
    }
1719#public void testResolveCompileScopeOverRuntimeScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec root = createArtifactSpec( "root", "1.0" );
        ArtifactSpec a = root.addDependency( "a", "1.0" );
        root.addDependency( "c", "3.0", Artifact.SCOPE_RUNTIME );

        a.addDependency( "c", "2.0", Artifact.SCOPE_COMPILE );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_COMPILE ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { root.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, root.artifact, modifiedC } ),
                      res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_COMPILE, artifact.getScope() );
    }
1720#public void testResolveCompileScopeOverProvidedScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_PROVIDED );

        a.addDependency( "c", "2.0", Artifact.SCOPE_COMPILE );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_COMPILE ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_COMPILE, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_PROVIDED, artifact.getScope() );
    }
1721#public void testResolveRuntimeScopeOverProvidedScope()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "3.0", Artifact.SCOPE_PROVIDED );

        a.addDependency( "c", "2.0", Artifact.SCOPE_RUNTIME );

        Artifact modifiedC = createArtifactSpec( "c", "3.0", Artifact.SCOPE_RUNTIME ).artifact;

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        // local wins now, and irrelevant if not local as test/provided aren't transitive
        // assertEquals( "Check artifactScope", Artifact.SCOPE_RUNTIME, artifact.getArtifactScope() );
        assertEquals( "Check artifactScope", Artifact.SCOPE_PROVIDED, artifact.getScope() );
    }
1722#public void testProvidedScopeNotTransitive()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0", Artifact.SCOPE_PROVIDED );
        ArtifactSpec b = createArtifactSpec( "b", "1.0" );
        b.addDependency( "c", "3.0", Artifact.SCOPE_PROVIDED );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );
    }
1723#public void testOptionalNotTransitive()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = createArtifactSpec( "b", "1.0" );
        b.addDependency( "c", "3.0", true );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );
    }
1724#public void testOptionalIncludedAtRoot()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );

        ArtifactSpec b = createArtifactSpec( "b", "1.0", true );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );
    }
1725#public void testScopeUpdate()
        throws InvalidVersionSpecificationException, ArtifactResolutionException
    {
        /* farthest = compile */
        checkScopeUpdate( Artifact.SCOPE_COMPILE, Artifact.SCOPE_COMPILE, Artifact.SCOPE_COMPILE );
        checkScopeUpdate( Artifact.SCOPE_COMPILE, Artifact.SCOPE_PROVIDED, Artifact.SCOPE_COMPILE );
        checkScopeUpdate( Artifact.SCOPE_COMPILE, Artifact.SCOPE_RUNTIME, Artifact.SCOPE_COMPILE );
        checkScopeUpdate( Artifact.SCOPE_COMPILE, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_COMPILE );
        checkScopeUpdate( Artifact.SCOPE_COMPILE, Artifact.SCOPE_TEST, Artifact.SCOPE_COMPILE );

        /* farthest = provided */
        checkScopeUpdate( Artifact.SCOPE_PROVIDED, Artifact.SCOPE_COMPILE, Artifact.SCOPE_COMPILE );
        checkScopeUpdate( Artifact.SCOPE_PROVIDED, Artifact.SCOPE_PROVIDED, Artifact.SCOPE_PROVIDED );
        checkScopeUpdate( Artifact.SCOPE_PROVIDED, Artifact.SCOPE_RUNTIME, Artifact.SCOPE_RUNTIME );
        checkScopeUpdate( Artifact.SCOPE_PROVIDED, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_SYSTEM );
        checkScopeUpdate( Artifact.SCOPE_PROVIDED, Artifact.SCOPE_TEST, Artifact.SCOPE_TEST );

        /* farthest = runtime */
        checkScopeUpdate( Artifact.SCOPE_RUNTIME, Artifact.SCOPE_COMPILE, Artifact.SCOPE_COMPILE );
        checkScopeUpdate( Artifact.SCOPE_RUNTIME, Artifact.SCOPE_PROVIDED, Artifact.SCOPE_RUNTIME );
        checkScopeUpdate( Artifact.SCOPE_RUNTIME, Artifact.SCOPE_RUNTIME, Artifact.SCOPE_RUNTIME );
        checkScopeUpdate( Artifact.SCOPE_RUNTIME, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_SYSTEM );
        checkScopeUpdate( Artifact.SCOPE_RUNTIME, Artifact.SCOPE_TEST, Artifact.SCOPE_RUNTIME );

        /* farthest = system */
        checkScopeUpdate( Artifact.SCOPE_SYSTEM, Artifact.SCOPE_COMPILE, Artifact.SCOPE_COMPILE );
        checkScopeUpdate( Artifact.SCOPE_SYSTEM, Artifact.SCOPE_PROVIDED, Artifact.SCOPE_PROVIDED );
        checkScopeUpdate( Artifact.SCOPE_SYSTEM, Artifact.SCOPE_RUNTIME, Artifact.SCOPE_RUNTIME );
        checkScopeUpdate( Artifact.SCOPE_SYSTEM, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_SYSTEM );
        checkScopeUpdate( Artifact.SCOPE_SYSTEM, Artifact.SCOPE_TEST, Artifact.SCOPE_TEST );

        /* farthest = test */
        checkScopeUpdate( Artifact.SCOPE_TEST, Artifact.SCOPE_COMPILE, Artifact.SCOPE_COMPILE );
        checkScopeUpdate( Artifact.SCOPE_TEST, Artifact.SCOPE_PROVIDED, Artifact.SCOPE_PROVIDED );
        checkScopeUpdate( Artifact.SCOPE_TEST, Artifact.SCOPE_RUNTIME, Artifact.SCOPE_RUNTIME );
        checkScopeUpdate( Artifact.SCOPE_TEST, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_SYSTEM );
        checkScopeUpdate( Artifact.SCOPE_TEST, Artifact.SCOPE_TEST, Artifact.SCOPE_TEST );
    }
1726#private void checkScopeUpdate( String farthestScope, String nearestScope, String expectedScope )
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        checkScopeUpdateDirect( farthestScope, nearestScope, expectedScope );
        checkScopeUpdateTransitively( farthestScope, nearestScope, expectedScope );
    }
1727#private void checkScopeUpdateTransitively( String farthestScope, String nearestScope, String expectedScope )
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = createArtifactSpec( "b", "1.0", nearestScope );
        ArtifactSpec c = createArtifactSpec( "c", "1.0" );
        a.addDependency( c );
        ArtifactSpec dNearest = createArtifactSpec( "d", "2.0" );
        b.addDependency( dNearest );
        ArtifactSpec dFarthest = createArtifactSpec( "d", "3.0", farthestScope );
        c.addDependency( dFarthest );

        /* system and provided dependencies are not transitive */
        if ( !Artifact.SCOPE_SYSTEM.equals( nearestScope ) && !Artifact.SCOPE_PROVIDED.equals( nearestScope ) )
        {
            checkScopeUpdate( a, b, expectedScope, "2.0" );
        }
    }
1728#private void checkScopeUpdateDirect( String farthestScope, String nearestScope, String expectedScope )
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = createArtifactSpec( "b", "1.0" );
        ArtifactSpec c = createArtifactSpec( "c", "1.0" );
        a.addDependency( c );
        ArtifactSpec dNearest = createArtifactSpec( "d", "2.0", nearestScope );
        b.addDependency( dNearest );
        ArtifactSpec dFarthest = createArtifactSpec( "d", "3.0", farthestScope );
        c.addDependency( dFarthest );

        checkScopeUpdate( a, b, expectedScope, "2.0" );
    }
1729#private void checkScopeUpdate( ArtifactSpec a, ArtifactSpec b, String expectedScope, String expectedVersion )
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ScopeArtifactFilter filter;
        if ( Artifact.SCOPE_PROVIDED.equals( expectedScope ) )
        {
            filter = new ScopeArtifactFilter( Artifact.SCOPE_COMPILE );
        }
        else if ( Artifact.SCOPE_SYSTEM.equals( expectedScope ) )
        {
            filter = new ScopeArtifactFilter( Artifact.SCOPE_COMPILE );
        }
        else
        {
            filter = new ScopeArtifactFilter( expectedScope );
        }

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ), filter );
        Artifact artifact = getArtifact( "d", res.getArtifacts() );
        assertNotNull( "MNG-1895 Dependency was not added to resolution", artifact );
        assertEquals( "Check artifactScope", expectedScope, artifact.getScope() );
        assertEquals( "Check version", expectedVersion, artifact.getVersion() );

        ArtifactSpec d = createArtifactSpec( "d", "1.0" );
        res = collect( createSet( new Object[] { a.artifact, b.artifact, d.artifact } ), filter );
        artifact = getArtifact( "d", res.getArtifacts() );
        assertNotNull( "MNG-1895 Dependency was not added to resolution", artifact );
        assertEquals( "Check artifactScope", d.artifact.getScope(), artifact.getScope() );
        assertEquals( "Check version", "1.0", artifact.getVersion() );
    }
1730#public void disabledtestOptionalNotTransitiveButVersionIsInfluential()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        ArtifactSpec b = createArtifactSpec( "b", "1.0" );
        b.addDependency( "c", "3.0", true );
        ArtifactSpec d = a.addDependency( "d", "1.0" );
        ArtifactSpec e = d.addDependency( "e", "1.0" );
        e.addDependency( "c", "2.0" );

        ArtifactSpec c = createArtifactSpec( "c", "3.0" );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact, c.artifact, d.artifact,
            e.artifact } ), res.getArtifacts() );
        Artifact artifact = getArtifact( "c", res.getArtifacts() );
        assertEquals( "Check version", "3.0", artifact.getVersion() );
    }
1731#public void testTestScopeNotTransitive()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0", Artifact.SCOPE_TEST );
        ArtifactSpec b = createArtifactSpec( "b", "1.0" );
        b.addDependency( "c", "3.0", Artifact.SCOPE_TEST );

        ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) );
        assertEquals( "Check artifact list", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );
    }
1732#public void testSnapshotNotIncluded()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        a.addDependency( "b", "[1.0,)" );
        createArtifactSpec( "b", "1.0-SNAPSHOT" );

        ArtifactResolutionResult res = collect( a );

        assertTrue( res.hasVersionRangeViolations() );

        /*
         * try { ArtifactResolutionResult res = collect( a ); fail( "Expected b not to resolve: " + res ); } catch (
         * OverConstrainedVersionException e ) { assertTrue( e.getMessage().indexOf( "[1.0-SNAPSHOT]" ) <
         * e.getMessage().indexOf( "[1.0,)" ) ); }
         */
    }
1733#public void testOverConstrainedVersionException()
        throws ArtifactResolutionException, InvalidVersionSpecificationException
    {
        ArtifactSpec a = createArtifactSpec( "a", "1.0" );
        a.addDependency( "b", "[1.0, 2.0)" );
        a.addDependency( "c", "[3.3.0,4.0.0)" );

        ArtifactSpec b = createArtifactSpec( "b", "1.0.0" );
        b.addDependency( "c", "3.3.0-v3346" );

        ArtifactSpec c = createArtifactSpec( "c", "3.2.1-v3235e" );

        try
        {
            ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact } ) );
        }
        catch ( OverConstrainedVersionException e )
        {
            assertTrue( "Versions unordered", e.getMessage().indexOf( "[3.2.1-v3235e, 3.3.0-v3346]" ) != -1 );
            assertTrue( "DependencyTrail unresolved", e.getMessage().indexOf( "Path to dependency:" ) != -1 );
        }
    }
1734#private Artifact getArtifact( String id, Set artifacts )
    {
        for ( Iterator i = artifacts.iterator(); i.hasNext(); )
        {
            Artifact a = (Artifact) i.next();
            if ( a.getArtifactId().equals( id ) && a.getGroupId().equals( GROUP_ID ) )
            {
                return a;
            }
        }
        return null;
    }
1735#private ArtifactResolutionResult collect( Set artifacts )
        throws ArtifactResolutionException
    {
        return collect( artifacts, null );
    }
1736#private ArtifactResolutionResult collect( Set artifacts, ArtifactFilter filter )
        throws ArtifactResolutionException
    {
        return artifactCollector.collect( artifacts, projectArtifact.artifact, null, null, null, source, filter,
                                          Collections.EMPTY_LIST, null );
    }
1737#private ArtifactResolutionResult collect( ArtifactSpec a )
        throws ArtifactResolutionException
    {
        return artifactCollector.collect( Collections.singleton( a.artifact ), projectArtifact.artifact, null, null,
                                          null, source, null, Collections.EMPTY_LIST, null );
    }
1738#private ArtifactResolutionResult collect( ArtifactSpec a, ArtifactFilter filter )
        throws ArtifactResolutionException
    {
        return artifactCollector.collect( Collections.singleton( a.artifact ), projectArtifact.artifact, null, null,
                                          null, source, filter, Collections.EMPTY_LIST, null );
    }
1739#private ArtifactResolutionResult collect( ArtifactSpec a, Artifact managedVersion )
        throws ArtifactResolutionException
    {
        Map managedVersions = Collections.singletonMap( managedVersion.getDependencyConflictId(), managedVersion );
        return artifactCollector.collect( Collections.singleton( a.artifact ), projectArtifact.artifact,
                                          managedVersions, null, null, source, null, Collections.EMPTY_LIST, null );
    }
1740#private ArtifactSpec createArtifactSpec( String id, String version )
        throws InvalidVersionSpecificationException
    {
        return createArtifactSpec( id, version, Artifact.SCOPE_COMPILE );
    }
1741#private ArtifactSpec createArtifactSpec( String id, String version, boolean optional )
        throws InvalidVersionSpecificationException
    {
        return createArtifactSpec( id, version, Artifact.SCOPE_COMPILE, null, optional );
    }
1742#private ArtifactSpec createArtifactSpec( String id, String version, String scope )
        throws InvalidVersionSpecificationException
    {
        return createArtifactSpec( id, version, scope, null, false );
    }
1743#private ArtifactSpec createArtifactSpec( String id, String version, String scope, String inheritedScope,
                                             boolean optional )
        throws InvalidVersionSpecificationException
    {
        VersionRange versionRange = VersionRange.createFromVersionSpec( version );
        Artifact artifact =
            artifactFactory.createDependencyArtifact( GROUP_ID, id, versionRange, "jar", null, scope, inheritedScope,
                                                      optional );
        ArtifactSpec spec = null;
        if ( artifact != null )
        {
            spec = new ArtifactSpec();
            spec.artifact = artifact;
            source.addArtifact( spec );
        }
        return spec;
    }
1744#private static Set createSet( Object[] x )
    {
        return new LinkedHashSet( Arrays.asList( x ) );
    }
1745#public ArtifactSpec addDependency( String id, String version )
            throws InvalidVersionSpecificationException
        {
            return addDependency( id, version, Artifact.SCOPE_COMPILE );
        }
1746#public ArtifactSpec addDependency( String id, String version, String scope )
            throws InvalidVersionSpecificationException
        {
            return addDependency( id, version, scope, false );
        }
1747#private ArtifactSpec addDependency( ArtifactSpec dep )
            throws InvalidVersionSpecificationException
        {
            if ( dep != null )
            {
                dependencies.add( dep.artifact );
            }
            return dep;
        }
1748#private ArtifactSpec addDependency( String id, String version, String scope, boolean optional )
            throws InvalidVersionSpecificationException
        {
            ArtifactSpec dep = createArtifactSpec( id, version, scope, artifact.getScope(), optional );
            return addDependency( dep );
        }
1749#public ArtifactSpec addDependency( String id, String version, boolean optional )
            throws InvalidVersionSpecificationException
        {
            return addDependency( id, version, Artifact.SCOPE_COMPILE, optional );
        }
1750#public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository,
                                         List<ArtifactRepository> remoteRepositories )
            throws ArtifactMetadataRetrievalException
        {
            String key = getKey( artifact );

            ArtifactSpec a = (ArtifactSpec) artifacts.get( key );
            try
            {
                return new ResolutionGroup( artifact, createArtifacts( artifactFactory, a.dependencies,
                                                                       artifact.getScope(),
                                                                       artifact.getDependencyFilter() ),
                                            Collections.EMPTY_LIST );
            }
            catch ( InvalidVersionSpecificationException e )
            {
                throw new ArtifactMetadataRetrievalException( "Invalid version creating artifacts", e, artifact );
            }
        }
1751#private String getKey( Artifact artifact )
        {
            return artifact.getDependencyConflictId();
        }
1752#private Set createArtifacts( ArtifactFactory artifactFactory, Set dependencies, String inheritedScope,
                                     ArtifactFilter dependencyFilter )
            throws InvalidVersionSpecificationException
        {
            Set projectArtifacts = new HashSet();

            for ( Iterator i = dependencies.iterator(); i.hasNext(); )
            {
                Artifact d = (Artifact) i.next();

                VersionRange versionRange;
                if ( d.getVersionRange() != null )
                {
                    versionRange = d.getVersionRange();
                }
                else
                {
                    versionRange = VersionRange.createFromVersionSpec( d.getVersion() );
                }
                Artifact artifact;
                if ( d.getScope().equals( Artifact.SCOPE_TEST ) || d.getScope().equals( Artifact.SCOPE_PROVIDED ) )
                {
                    /* don't call createDependencyArtifact as it'll ignore test and provided scopes */
                    artifact =
                        artifactFactory.createArtifact( d.getGroupId(), d.getArtifactId(), d.getVersion(),
                                                        d.getScope(), d.getType() );
                }
                else
                {
                    artifact =
                        artifactFactory.createDependencyArtifact( d.getGroupId(), d.getArtifactId(), versionRange,
                                                                  d.getType(), d.getClassifier(), d.getScope(),
                                                                  inheritedScope, d.isOptional() );
                }

                if ( artifact != null && ( dependencyFilter == null || dependencyFilter.include( artifact ) ) )
                {
                    artifact.setDependencyFilter( dependencyFilter );

                    projectArtifacts.add( artifact );
                }
            }

            return projectArtifacts;
        }
1753#public void addArtifact( ArtifactSpec spec )
        {
            artifacts.put( getKey( spec.artifact ), spec );

            String key = spec.artifact.getDependencyConflictId();
            List artifactVersions = (List) versions.get( key );
            if ( artifactVersions == null )
            {
                artifactVersions = new ArrayList();
                versions.put( key, artifactVersions );
            }
            if ( spec.artifact.getVersion() != null )
            {
                artifactVersions.add( new DefaultArtifactVersion( spec.artifact.getVersion() ) );
            }
        }
1754#public List<ArtifactVersion> retrieveAvailableVersions( Artifact artifact, ArtifactRepository localRepository,
                                                                List<ArtifactRepository> remoteRepositories )
            throws ArtifactMetadataRetrievalException
        {
            return retrieveAvailableVersions( artifact );
        }
1755#public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository(
                                                                                        Artifact artifact,
                                                                                        ArtifactRepository localRepository,
                                                                                        ArtifactRepository remoteRepository )
            throws ArtifactMetadataRetrievalException
        {
            return retrieveAvailableVersions( artifact );
        }
1756#private List<ArtifactVersion> retrieveAvailableVersions( Artifact artifact )
        {
            List artifactVersions = (List) versions.get( artifact.getDependencyConflictId() );
            if ( artifactVersions == null )
            {
                artifactVersions = Collections.EMPTY_LIST;
            }
            return artifactVersions;
        }
1757#public ResolutionGroup retrieve( MetadataResolutionRequest request )
            throws ArtifactMetadataRetrievalException
        {
            return retrieve( request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories() );
        }
1758#public List<ArtifactVersion> retrieveAvailableVersions( MetadataResolutionRequest request )
            throws ArtifactMetadataRetrievalException
        {
            return retrieveAvailableVersions( request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories() );
        }
1759#// constructors -----------------------------------------------------------
    
    public OldestConflictResolverTest()
        throws Exception
    {
        super("oldest");
    }
1760#// tests ------------------------------------------------------------------

    /**
     * Tests that <code>a:1.0</code> wins in the scenario:
     * <pre>
     * a:1.0
     * b:1.0 -> a:2.0
     * </pre>
     */
    public void testDepth()
    {
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        ResolutionNode b1n = new ResolutionNode( b1, Collections.EMPTY_LIST );
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST, b1n );
        
        assertResolveConflict( a1n, a1n, a2n );
    }
1761#/**
     * Tests that <code>a:1.0</code> wins in the scenario:
     * <pre>
     * b:1.0 -> a:2.0
     * a:1.0
     * </pre>
     */
    public void testDepthReversed()
    {
        ResolutionNode b1n = new ResolutionNode( b1, Collections.EMPTY_LIST );
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST, b1n );
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        
        assertResolveConflict( a1n, a2n, a1n );
    }
1762#/**
     * Tests that <code>a:1.0</code> wins in the scenario:
     * <pre>
     * a:1.0
     * a:2.0
     * </pre>
     */
    public void testEqual()
    {
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST );
        
        assertResolveConflict( a1n, a1n, a2n );
    }
1763#/**
     * Tests that <code>a:1.0</code> wins in the scenario:
     * <pre>
     * a:2.0
     * a:1.0
     * </pre>
     */
    public void testEqualReversed()
    {
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST );
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        
        assertResolveConflict( a1n, a2n, a1n );
    }
1764#// constructors -----------------------------------------------------------
    
    public NearestConflictResolverTest()
        throws Exception
    {
        super("nearest");
    }
1765#// tests ------------------------------------------------------------------

    /**
     * Tests that <code>a:1.0</code> wins in the scenario:
     * <pre>
     * a:1.0
     * b:1.0 -> a:2.0
     * </pre>
     */
    public void testDepth()
    {
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        ResolutionNode b1n = new ResolutionNode( b1, Collections.EMPTY_LIST );
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST, b1n );
        
        assertResolveConflict( a1n, a1n, a2n );
    }
1766#/**
     * Tests that <code>a:1.0</code> wins in the scenario:
     * <pre>
     * b:1.0 -> a:2.0
     * a:1.0
     * </pre>
     */
    public void testDepthReversed()
    {
        ResolutionNode b1n = new ResolutionNode( b1, Collections.EMPTY_LIST );
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST, b1n );
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        
        assertResolveConflict( a1n, a2n, a1n );
    }
1767#/**
     * Tests that <code>a:1.0</code> wins in the scenario:
     * <pre>
     * a:1.0
     * a:2.0
     * </pre>
     */
    public void testEqual()
    {
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST );
        
        assertResolveConflict( a1n, a1n, a2n );
    }
1768#/**
     * Tests that <code>a:2.0</code> wins in the scenario:
     * <pre>
     * a:2.0
     * a:1.0
     * </pre>
     */
    public void testEqualReversed()
    {
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST );
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        
        assertResolveConflict( a2n, a2n, a1n );
    }
1769#// constructors -----------------------------------------------------------
    
    public FarthestConflictResolverTest()
        throws Exception
    {
        super("farthest");
    }
1770#// tests ------------------------------------------------------------------

    /**
     * Tests that <code>a:2.0</code> wins in the scenario:
     * <pre>
     * a:1.0
     * b:1.0 -> a:2.0
     * </pre>
     */
    public void testDepth()
    {
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        ResolutionNode b1n = new ResolutionNode( b1, Collections.EMPTY_LIST );
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST, b1n );
        
        assertResolveConflict( a2n, a1n, a2n );
    }
1771#/**
     * Tests that <code>a:2.0</code> wins in the scenario:
     * <pre>
     * b:1.0 -> a:2.0
     * a:1.0
     * </pre>
     */
    public void testDepthReversed()
    {
        ResolutionNode b1n = new ResolutionNode( b1, Collections.EMPTY_LIST );
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST, b1n );
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        
        assertResolveConflict( a2n, a2n, a1n );
    }
1772#/**
     * Tests that <code>a:1.0</code> wins in the scenario:
     * <pre>
     * a:1.0
     * a:2.0
     * </pre>
     */
    public void testEqual()
    {
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST );
        
        assertResolveConflict( a1n, a1n, a2n );
    }
1773#/**
     * Tests that <code>a:2.0</code> wins in the scenario:
     * <pre>
     * a:2.0
     * a:1.0
     * </pre>
     */
    public void testEqualReversed()
    {
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST );
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        
        assertResolveConflict( a2n, a2n, a1n );
    }
1774#// constructors -----------------------------------------------------------
    
    public NewestConflictResolverTest()
        throws Exception
    {
        super("newest");
    }
1775#// tests ------------------------------------------------------------------

    /**
     * Tests that <code>a:2.0</code> wins in the scenario:
     * <pre>
     * a:1.0
     * b:1.0 -> a:2.0
     * </pre>
     */
    public void testDepth()
    {
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        ResolutionNode b1n = new ResolutionNode( b1, Collections.EMPTY_LIST );
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST, b1n );
        
        assertResolveConflict( a2n, a1n, a2n );
    }
1776#/**
     * Tests that <code>a:2.0</code> wins in the scenario:
     * <pre>
     * b:1.0 -> a:2.0
     * a:1.0
     * </pre>
     */
    public void testDepthReversed()
    {
        ResolutionNode b1n = new ResolutionNode( b1, Collections.EMPTY_LIST );
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST, b1n );
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        
        assertResolveConflict( a2n, a2n, a1n );
    }
1777#/**
     * Tests that <code>a:2.0</code> wins in the scenario:
     * <pre>
     * a:1.0
     * a:2.0
     * </pre>
     */
    public void testEqual()
    {
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST );
        
        assertResolveConflict( a2n, a1n, a2n );
    }
1778#/**
     * Tests that <code>a:2.0</code> wins in the scenario:
     * <pre>
     * a:2.0
     * a:1.0
     * </pre>
     */
    public void testEqualReversed()
    {
        ResolutionNode a2n = new ResolutionNode( a2, Collections.EMPTY_LIST );
        ResolutionNode a1n = new ResolutionNode( a1, Collections.EMPTY_LIST );
        
        assertResolveConflict( a2n, a2n, a1n );
    }
1779#// constructors -----------------------------------------------------------
    
    public AbstractConflictResolverTest( String roleHint )
        throws Exception
    {
        this.roleHint = roleHint;
    }
1780#// TestCase methods -------------------------------------------------------
    
    /*
     * @see junit.framework.TestCase#setUp()
     */
    protected void setUp() throws Exception
    {
        super.setUp();

        artifactFactory = (ArtifactFactory) lookup( ArtifactFactory.ROLE );
        conflictResolver = (ConflictResolver) lookup( ConflictResolver.ROLE, roleHint );
        
        a1 = createArtifact( "a", "1.0" );
        a2 = createArtifact( "a", "2.0" );
        b1 = createArtifact( "b", "1.0" );
    }
1781#/*
     * @see org.codehaus.plexus.PlexusTestCase#tearDown()
     */
    protected void tearDown() throws Exception
    {
        a1 = null;
        a2 = null;
        b1 = null;
        
        artifactFactory = null;
        conflictResolver = null;
        
        super.tearDown();
    }
1782#// protected methods ------------------------------------------------------
    
    protected ConflictResolver getConflictResolver()
    {
        return conflictResolver;
    }
1783#protected void assertResolveConflict( ResolutionNode expectedNode, ResolutionNode actualNode1, ResolutionNode actualNode2 )
    {
        ResolutionNode resolvedNode = getConflictResolver().resolveConflict( actualNode1, actualNode2 );
        
        assertNotNull( "Expected resolvable", resolvedNode );
        assertEquals( "Resolution node", expectedNode, resolvedNode );
    }
1784#protected void assertUnresolvableConflict( ResolutionNode actualNode1, ResolutionNode actualNode2 )
    {
        ResolutionNode resolvedNode = getConflictResolver().resolveConflict( actualNode1, actualNode2 );
        
        assertNull( "Expected unresolvable", resolvedNode );
    }
1785#protected Artifact createArtifact( String id, String version ) throws InvalidVersionSpecificationException
    {
        return createArtifact( id, version, Artifact.SCOPE_COMPILE );
    }
1786#protected Artifact createArtifact( String id, String version, boolean optional )
        throws InvalidVersionSpecificationException
    {
        return createArtifact( id, version, Artifact.SCOPE_COMPILE, null, optional );
    }
1787#protected Artifact createArtifact( String id, String version, String scope )
        throws InvalidVersionSpecificationException
    {
        return createArtifact( id, version, scope, null, false );
    }
1788#protected Artifact createArtifact( String id, String version, String scope, String inheritedScope, boolean optional )
        throws InvalidVersionSpecificationException
    {
        VersionRange versionRange = VersionRange.createFromVersionSpec( version );
        
        return artifactFactory.createDependencyArtifact( GROUP_ID, id, versionRange, "jar", null, scope,
                                                         inheritedScope, optional );
    }
1789#//------------------------------------------------------------------------------------------
    @Override
	protected void setUp() throws Exception
	{
		super.setUp();
		resolver = (GraphConflictResolver) lookup( GraphConflictResolver.ROLE, "default" );

    	/*
    	 *       v2
    	 *   v1<
    	 *      v3-v4
    	 * 
    	 */
    	graph = new MetadataGraph( 4, 3 );
    	v1 = graph.addVertex(new ArtifactMetadata("g","a1","1.0"));
    	graph.setEntry(v1);
    	v2 = graph.addVertex(new ArtifactMetadata("g","a2","1.0"));
    	v3 = graph.addVertex(new ArtifactMetadata("g","a3","1.0"));
    	v4 = graph.addVertex(new ArtifactMetadata("g","a4","1.0"));

    	// v1-->v2
    	graph.addEdge(v1, v2, new MetadataGraphEdge( "1.1", true, null, null, 2, 1 ) );
    	graph.addEdge(v1, v2, new MetadataGraphEdge( "1.2", true, null, null, 2, 2 ) );
    	
    	// v1-->v3
    	graph.addEdge(v1, v3, new MetadataGraphEdge( "1.1", true, null, null, 2, 1 ) );
    	graph.addEdge(v1, v3, new MetadataGraphEdge( "1.2", true, null, null, 4, 2 ) );
    	
    	// v3-->v4
    	graph.addEdge(v3, v4, new MetadataGraphEdge( "1.1", true, ArtifactScopeEnum.runtime, null, 2, 1 ) );
    	graph.addEdge(v3, v4, new MetadataGraphEdge( "1.2", true, ArtifactScopeEnum.provided, null, 2, 2 ) );
	}
1790#//------------------------------------------------------------------------------------------
    public void testCompileResolution()
    throws Exception
    {
    	MetadataGraph res;
    	
    	res = resolver.resolveConflicts( graph, ArtifactScopeEnum.compile );
    	
    	assertNotNull("null graph after resolver", res );
    	assertNotNull("no vertices in the resulting graph after resolver", res.getVertices() );

    	assertNotNull("no edges in the resulting graph after resolver", res.getExcidentEdges(v1) );

    	assertEquals( "wrong # of vertices in the resulting graph after resolver", 4, res.getVertices().size() );
    	assertEquals( "wrong # of excident edges in the resulting graph entry after resolver", 2, res.getExcidentEdges(v1).size() );

    	assertEquals( "wrong # of v2 incident edges in the resulting graph after resolver", 1, res.getIncidentEdges(v2).size() );
    	assertEquals( "wrong edge v1-v2 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v2).get(0).getVersion() );

    	assertEquals( "wrong # of edges v1-v3 in the resulting graph after resolver", 1, res.getIncidentEdges(v3).size() );
    	assertEquals( "wrong edge v1-v3 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v3).get(0).getVersion() );

    	assertEquals( "wrong # of edges v3-v4 in the resulting graph after resolver", 1, res.getIncidentEdges(v4).size() );
    	assertEquals( "wrong edge v3-v4 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v4).get(0).getVersion() );
    }
1791#//------------------------------------------------------------------------------------------
    public void testRuntimeResolution()
    throws Exception
    {
    	MetadataGraph res;
    	
    	res = resolver.resolveConflicts( graph, ArtifactScopeEnum.runtime );
    	
    	assertNotNull("null graph after resolver", res );
    	assertNotNull("no vertices in the resulting graph after resolver", res.getVertices() );
    	assertNotNull("no edges in the resulting graph after resolver", res.getExcidentEdges(v1) );

    	assertEquals( "wrong # of vertices in the resulting graph after resolver", 4, res.getVertices().size() );
    	assertEquals( "wrong # of excident edges in the resulting graph entry after resolver", 2, res.getExcidentEdges(v1).size() );

    	assertEquals( "wrong # of v2 incident edges in the resulting graph after resolver", 1, res.getIncidentEdges(v2).size() );
    	assertEquals( "wrong edge v1-v2 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v2).get(0).getVersion() );

    	assertEquals( "wrong # of edges v1-v3 in the resulting graph after resolver", 1, res.getIncidentEdges(v3).size() );
    	assertEquals( "wrong edge v1-v3 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v3).get(0).getVersion() );

    	assertEquals( "wrong # of edges v3-v4 in the resulting graph after resolver", 1, res.getIncidentEdges(v4).size() );
    	assertEquals( "wrong edge v3-v4 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v4).get(0).getVersion() );
    }
1792#//------------------------------------------------------------------------------------------
    public void testTestResolution()
    throws Exception
    {
    	MetadataGraph res;
    	
    	res = resolver.resolveConflicts( graph, ArtifactScopeEnum.test );
    	
    	assertNotNull("null graph after resolver", res );
    	assertNotNull("no vertices in the resulting graph after resolver", res.getVertices() );
    	assertNotNull("no edges in the resulting graph after resolver", res.getExcidentEdges(v1) );

    	assertEquals( "wrong # of vertices in the resulting graph after resolver", 4, res.getVertices().size() );
    	assertEquals( "wrong # of excident edges in the resulting graph entry after resolver", 2, res.getExcidentEdges(v1).size() );

    	assertEquals( "wrong # of v2 incident edges in the resulting graph after resolver", 1, res.getIncidentEdges(v2).size() );
    	assertEquals( "wrong edge v1-v2 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v2).get(0).getVersion() );

    	assertEquals( "wrong # of edges v1-v3 in the resulting graph after resolver", 1, res.getIncidentEdges(v3).size() );
    	assertEquals( "wrong edge v1-v3 in the resulting graph after resolver", "1.1", res.getIncidentEdges(v3).get(0).getVersion() );

    	assertEquals( "wrong # of edges v3-v4 in the resulting graph after resolver", 1, res.getIncidentEdges(v4).size() );
    	assertEquals( "wrong edge v3-v4 in the resulting graph after resolver", "1.2", res.getIncidentEdges(v4).get(0).getVersion() );
    }
1793#//------------------------------------------------------------------------------------------
    @Override
	protected void setUp() throws Exception
	{
		super.setUp();
    	policy = (GraphConflictResolutionPolicy) lookup( GraphConflictResolutionPolicy.ROLE, "default" );
    	e1 = new MetadataGraphEdge( "1.1", true, null, null, 2, 1 );
    	e2 = new MetadataGraphEdge( "1.2", true, null, null, 3, 2 );
    	e3 = new MetadataGraphEdge( "1.2", true, null, null, 2, 3 );
	}
1794#//------------------------------------------------------------------------------------------
    public void testDefaultPolicy()
        throws Exception
    {
    	MetadataGraphEdge res;
    	
    	res = policy.apply( e1, e2 );
    	assertEquals( "Wrong depth edge selected", "1.1", res.getVersion() );
    	
    	res = policy.apply( e1, e3 );
    	assertEquals( "Wrong version edge selected", "1.2", res.getVersion() );
    }
1795#//------------------------------------------------------------------------------------------
    @Override
	protected void setUp() throws Exception
	{
		super.setUp();
		transform = (ClasspathTransformation) lookup( ClasspathTransformation.ROLE, "default" );
    	
    	graph = new MetadataGraph( 4, 3 );
    	/*
    	 *       v2
    	 *   v1<
    	 *       v3-v4
    	 * 
    	 */
    	v1 = graph.addVertex(new ArtifactMetadata("g","a1","1.0"));
    	graph.setEntry(v1);
    	v2 = graph.addVertex(new ArtifactMetadata("g","a2","1.0"));
    	v3 = graph.addVertex(new ArtifactMetadata("g","a3","1.0"));
    	v4 = graph.addVertex(new ArtifactMetadata("g","a4","1.0"));
    	
    	// v1-->v2
    	graph.addEdge(v1, v2, new MetadataGraphEdge( "1.1", true, null, null, 2, 1 ) );
    	graph.addEdge(v1, v2, new MetadataGraphEdge( "1.2", true, null, null, 2, 2 ) );
    	
    	// v1-->v3
    	graph.addEdge(v1, v3, new MetadataGraphEdge( "1.1", true, null, null, 2, 1 ) );
    	graph.addEdge(v1, v3, new MetadataGraphEdge( "1.2", true, null, null, 4, 2 ) );
    	
    	// v3-->v4
    	graph.addEdge(v3, v4, new MetadataGraphEdge( "1.1", true, ArtifactScopeEnum.runtime, null, 2, 2 ) );
    	graph.addEdge(v3, v4, new MetadataGraphEdge( "1.2", true, ArtifactScopeEnum.test, null, 2, 2 ) );
	}
1796#//------------------------------------------------------------------------------------------
    public void testCompileClasspathTransform()
    throws Exception
    {
    	ClasspathContainer res;
    	
    	res = transform.transform( graph, ArtifactScopeEnum.compile, false );

       	assertNotNull("null classpath container after compile transform", res );
       	assertNotNull("null classpath after compile transform", res.getClasspath() );
       	assertEquals("compile classpath should have 3 entries", 3, res.getClasspath().size() );
    }
1797#//------------------------------------------------------------------------------------------
    public void testRuntimeClasspathTransform()
    throws Exception
    {
    	ClasspathContainer res;
    	
    	res = transform.transform( graph, ArtifactScopeEnum.runtime, false );

       	assertNotNull("null classpath container after runtime transform", res );
       	assertNotNull("null classpath after runtime transform", res.getClasspath() );
       	assertEquals("runtime classpath should have 4 entries", 4, res.getClasspath().size() );
       	
       	ArtifactMetadata md = res.getClasspath().get(3);
       	assertEquals("runtime artifact version should be 1.1", "1.1", md.getVersion() );
    }
1798#//------------------------------------------------------------------------------------------
    public void testTestClasspathTransform()
    throws Exception
    {
    	ClasspathContainer res;
    	
    	res = transform.transform( graph, ArtifactScopeEnum.test, false );

       	assertNotNull("null classpath container after runtime transform", res );
       	assertNotNull("null classpath after runtime transform", res.getClasspath() );
       	assertEquals("runtime classpath should have 4 entries", 4, res.getClasspath().size() );
       	
       	ArtifactMetadata md = res.getClasspath().get(3);
       	assertEquals("test artifact version should be 1.2", "1.2", md.getVersion() );
    }
1799#public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException
    {
        Set dependencies = new HashSet();

        if ( "g".equals( artifact.getArtifactId() ) )
        {
            Artifact a = null;
            try
            {
                a = factory.createBuildArtifact( "org.apache.maven", "h", "1.0", "jar" );
                dependencies.add( a );
            }
            catch ( Exception e )
            {
                throw new ArtifactMetadataRetrievalException( "Error retrieving metadata", e, a );
            }
        }
        
        if ( "i".equals( artifact.getArtifactId() ) )
        {
            Artifact a = null;
            try
            {
                a = factory.createBuildArtifact( "org.apache.maven", "j", "1.0-SNAPSHOT", "jar" );
                dependencies.add( a );
            }
            catch ( Exception e )
            {
                throw new ArtifactMetadataRetrievalException( "Error retrieving metadata", e, a );
            }
        }
        

        return new ResolutionGroup( artifact, dependencies, remoteRepositories );
    }
1800#public List<ArtifactVersion> retrieveAvailableVersions( Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException
    {
        throw new UnsupportedOperationException( "Cannot get available versions in this test case" );
    }
1801#public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository( Artifact artifact, ArtifactRepository localRepository, ArtifactRepository remoteRepository )
        throws ArtifactMetadataRetrievalException
    {
        throw new UnsupportedOperationException( "Cannot get available versions in this test case" );
    }
1802#public ResolutionGroup retrieve( MetadataResolutionRequest request )
        throws ArtifactMetadataRetrievalException
    {
        return retrieve( request.getArtifact(), request.getLocalRepository(), request.getRemoteRepositories() );
    }
1803#public MavenExecutionResult execute( MavenExecutionRequest request )
    {
        MavenExecutionResult result;

        try
        {
            result = doExecute( populator.populateDefaults( request ) );
        }
        catch ( OutOfMemoryError e )
        {
            result = processResult( new DefaultMavenExecutionResult(), e );
        }
        catch ( MavenExecutionRequestPopulationException e )
        {
            result = processResult( new DefaultMavenExecutionResult(), e );
        }
        catch ( RuntimeException e )
        {
            result =
                processResult( new DefaultMavenExecutionResult(),
                               new InternalErrorException( "Internal error: " + e, e ) );
        }
        finally
        {
            legacySupport.setSession( null );
        }

        return result;
    }
1804#@SuppressWarnings({"ThrowableInstanceNeverThrown", "ThrowableResultOfMethodCallIgnored"})
    private MavenExecutionResult doExecute( MavenExecutionRequest request )
    {
        //TODO: Need a general way to inject standard properties
        if ( request.getStartTime() != null )
        {
            request.getSystemProperties().put( "${build.timestamp}",
                                               new SimpleDateFormat( "yyyyMMdd-hhmm" ).format( request.getStartTime() ) );
        }        
        
        request.setStartTime( new Date() );
        
        MavenExecutionResult result = new DefaultMavenExecutionResult();

        try
        {
            validateLocalRepository( request );
        }
        catch ( LocalRepositoryNotAccessibleException e )
        {
            return processResult( result, e );
        }

        DelegatingLocalArtifactRepository delegatingLocalArtifactRepository =
            new DelegatingLocalArtifactRepository( request.getLocalRepository() );
        
        request.setLocalRepository( delegatingLocalArtifactRepository );        

        DefaultRepositorySystemSession repoSession = (DefaultRepositorySystemSession) newRepositorySession( request );

        MavenSession session = new MavenSession( container, repoSession, request, result );
        legacySupport.setSession( session );

        try
        {
            for ( AbstractMavenLifecycleParticipant listener : getLifecycleParticipants( Collections.<MavenProject> emptyList() ) )
            {
                listener.afterSessionStart( session );
            }
        }
        catch ( MavenExecutionException e )
        {
            return processResult( result, e );
        }

        eventCatapult.fire( ExecutionEvent.Type.ProjectDiscoveryStarted, session, null );

        request.getProjectBuildingRequest().setRepositorySession( session.getRepositorySession() );

        //TODO: optimize for the single project or no project
        
        List<MavenProject> projects;
        try
        {
            projects = getProjectsForMavenReactor( request );                                                
        }
        catch ( ProjectBuildingException e )
        {
            return processResult( result, e );
        }

        session.setProjects( projects );

        result.setTopologicallySortedProjects( session.getProjects() );
        
        result.setProject( session.getTopLevelProject() );

        try
        {
            Map<String, MavenProject> projectMap;
            projectMap = getProjectMap( session.getProjects() );
    
            // Desired order of precedence for local artifact repositories
            //
            // Reactor
            // Workspace
            // User Local Repository
            ReactorReader reactorRepository = new ReactorReader( projectMap );

            repoSession.setWorkspaceReader( ChainedWorkspaceReader.newInstance( reactorRepository,
                                                                                repoSession.getWorkspaceReader() ) );
        }
        catch ( org.apache.maven.DuplicateProjectException e )
        {
            return processResult( result, e );
        }

        ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();
        try
        {
            for ( AbstractMavenLifecycleParticipant listener : getLifecycleParticipants( projects ) )
            {
                Thread.currentThread().setContextClassLoader( listener.getClass().getClassLoader() );

                listener.afterProjectsRead( session );
            }
        }
        catch ( MavenExecutionException e )
        {
            return processResult( result, e );
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( originalClassLoader );
        }

        try
        {
            ProjectSorter projectSorter = new ProjectSorter( session.getProjects() );

            ProjectDependencyGraph projectDependencyGraph = createDependencyGraph( projectSorter, request );

            session.setProjects( projectDependencyGraph.getSortedProjects() );

            session.setProjectDependencyGraph( projectDependencyGraph );
        }
        catch ( CycleDetectedException e )
        {            
            String message = "The projects in the reactor contain a cyclic reference: " + e.getMessage();

            ProjectCycleException error = new ProjectCycleException( message, e );

            return processResult( result, error );
        }
        catch ( DuplicateProjectException e )
        {
            return processResult( result, e );
        }
        catch ( MavenExecutionException e )
        {
            return processResult( result, e );
        }

        result.setTopologicallySortedProjects( session.getProjects() );

        if ( result.hasExceptions() )
        {
            return result;
        }

        lifecycleStarter.execute( session );

        validateActivatedProfiles( session.getProjects(), request.getActiveProfiles() );

        if ( session.getResult().hasExceptions() )
        {
            return processResult( result, session.getResult().getExceptions().get( 0 ) );
        }

        return result;
    }
1805#public RepositorySystemSession newRepositorySession( MavenExecutionRequest request )
    {
        DefaultRepositorySystemSession session = new DefaultRepositorySystemSession();

        session.setCache( request.getRepositoryCache() );

        session.setIgnoreInvalidArtifactDescriptor( true ).setIgnoreMissingArtifactDescriptor( true );

        Map<Object, Object> configProps = new LinkedHashMap<Object, Object>();
        configProps.put( ConfigurationProperties.USER_AGENT, getUserAgent() );
        configProps.put( ConfigurationProperties.INTERACTIVE, Boolean.valueOf( request.isInteractiveMode() ) );
        configProps.putAll( request.getSystemProperties() );
        configProps.putAll( request.getUserProperties() );

        session.setOffline( request.isOffline() );
        session.setChecksumPolicy( request.getGlobalChecksumPolicy() );
        if ( request.isNoSnapshotUpdates() )
        {
            session.setUpdatePolicy( RepositoryPolicy.UPDATE_POLICY_NEVER );
        }
        else if ( request.isUpdateSnapshots() )
        {
            session.setUpdatePolicy( RepositoryPolicy.UPDATE_POLICY_ALWAYS );
        }
        else
        {
            session.setUpdatePolicy( null );
        }

        session.setNotFoundCachingEnabled( request.isCacheNotFound() );
        session.setTransferErrorCachingEnabled( request.isCacheTransferError() );

        session.setArtifactTypeRegistry( RepositoryUtils.newArtifactTypeRegistry( artifactHandlerManager ) );

        LocalRepository localRepo = new LocalRepository( request.getLocalRepository().getBasedir() );
        session.setLocalRepositoryManager( repoSystem.newLocalRepositoryManager( localRepo ) );

        if ( request.getWorkspaceReader() != null )
        {
            session.setWorkspaceReader( request.getWorkspaceReader() );
        }
        else
        {
            session.setWorkspaceReader( workspaceRepository );
        }

        DefaultSettingsDecryptionRequest decrypt = new DefaultSettingsDecryptionRequest();
        decrypt.setProxies( request.getProxies() );
        decrypt.setServers( request.getServers() );
        SettingsDecryptionResult decrypted = settingsDecrypter.decrypt( decrypt );

        if ( logger.isDebugEnabled() )
        {
            for ( SettingsProblem problem : decrypted.getProblems() )
            {
                logger.debug( problem.getMessage(), problem.getException() );
            }
        }

        DefaultMirrorSelector mirrorSelector = new DefaultMirrorSelector();
        for ( Mirror mirror : request.getMirrors() )
        {
            mirrorSelector.add( mirror.getId(), mirror.getUrl(), mirror.getLayout(), false, mirror.getMirrorOf(),
                                mirror.getMirrorOfLayouts() );
        }
        session.setMirrorSelector( mirrorSelector );

        DefaultProxySelector proxySelector = new DefaultProxySelector();
        for ( Proxy proxy : decrypted.getProxies() )
        {
            Authentication proxyAuth = new Authentication( proxy.getUsername(), proxy.getPassword() );
            proxySelector.add( new org.sonatype.aether.repository.Proxy( proxy.getProtocol(), proxy.getHost(), proxy.getPort(),
                                                                proxyAuth ), proxy.getNonProxyHosts() );
        }
        session.setProxySelector( proxySelector );

        DefaultAuthenticationSelector authSelector = new DefaultAuthenticationSelector();
        for ( Server server : decrypted.getServers() )
        {
            Authentication auth =
                new Authentication( server.getUsername(), server.getPassword(), server.getPrivateKey(),
                                    server.getPassphrase() );
            authSelector.add( server.getId(), auth );

            if ( server.getConfiguration() != null )
            {
                Xpp3Dom dom = (Xpp3Dom) server.getConfiguration();
                for ( int i = dom.getChildCount() - 1; i >= 0; i-- )
                {
                    Xpp3Dom child = dom.getChild( i );
                    if ( "wagonProvider".equals( child.getName() ) )
                    {
                        dom.removeChild( i );
                    }
                }

                XmlPlexusConfiguration config = new XmlPlexusConfiguration( dom );
                configProps.put( "aether.connector.wagon.config." + server.getId(), config );
            }

            configProps.put( "aether.connector.perms.fileMode." + server.getId(), server.getFilePermissions() );
            configProps.put( "aether.connector.perms.dirMode." + server.getId(), server.getDirectoryPermissions() );
        }
        session.setAuthenticationSelector( authSelector );

        DependencyTraverser depTraverser = new FatArtifactTraverser();
        session.setDependencyTraverser( depTraverser );

        DependencyManager depManager = new ClassicDependencyManager();
        session.setDependencyManager( depManager );

        DependencySelector depFilter =
            new AndDependencySelector( new ScopeDependencySelector( "test", "provided" ), new OptionalDependencySelector(),
                                     new ExclusionDependencySelector() );
        session.setDependencySelector( depFilter );

        DependencyGraphTransformer transformer =
            new ChainedDependencyGraphTransformer( new ConflictMarker(), new JavaEffectiveScopeCalculator(),
                                                   new NearestVersionConflictResolver(),
                                                   new JavaDependencyContextRefiner() );
        session.setDependencyGraphTransformer( transformer );

        session.setTransferListener( request.getTransferListener() );

        session.setRepositoryListener( eventSpyDispatcher.chainListener( new LoggingRepositoryListener( logger ) ) );

        session.setUserProps( request.getUserProperties() );
        session.setSystemProps( request.getSystemProperties() );
        session.setConfigProps( configProps );

        return session;
    }
1806#private String getUserAgent()
    {
        return "Apache-Maven/" + getMavenVersion()
            + " (Java " + System.getProperty( "java.version" ) + "; "
            + System.getProperty( "os.name" ) + " " + System.getProperty( "os.version" ) + ")";
    }
1807#private String getMavenVersion()
    {
        Properties props = new Properties();

        InputStream is = getClass().getResourceAsStream( "/META-INF/maven/org.apache.maven/maven-core/pom.properties" );
        if ( is != null )
        {
            try
            {
                props.load( is );
            }
            catch ( IOException e )
            {
                logger.debug( "Failed to read Maven version", e );
            }
            IOUtil.close( is );
        }

        return props.getProperty( "version", "unknown-version" );
    }
1808#private void validateLocalRepository( MavenExecutionRequest request )
        throws LocalRepositoryNotAccessibleException
    {
        File localRepoDir = request.getLocalRepositoryPath();

        logger.debug( "Using local repository at " + localRepoDir );

        localRepoDir.mkdirs();

        if ( !localRepoDir.isDirectory() )
        {
            throw new LocalRepositoryNotAccessibleException( "Could not create local repository at " + localRepoDir );
        }
    }
1809#private Collection<AbstractMavenLifecycleParticipant> getLifecycleParticipants( Collection<MavenProject> projects )
    {
        Collection<AbstractMavenLifecycleParticipant> lifecycleListeners =
            new LinkedHashSet<AbstractMavenLifecycleParticipant>();

        ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();
        try
        {
            try
            {
                lifecycleListeners.addAll( container.lookupList( AbstractMavenLifecycleParticipant.class ) );
            }
            catch ( ComponentLookupException e )
            {
                // this is just silly, lookupList should return an empty list!
                logger.warn( "Failed to lookup lifecycle participants: " + e.getMessage() );
            }

            Collection<ClassLoader> scannedRealms = new HashSet<ClassLoader>();

            for ( MavenProject project : projects )
            {
                ClassLoader projectRealm = project.getClassRealm();

                if ( projectRealm != null && scannedRealms.add( projectRealm ) )
                {
                    Thread.currentThread().setContextClassLoader( projectRealm );

                    try
                    {
                        lifecycleListeners.addAll( container.lookupList( AbstractMavenLifecycleParticipant.class ) );
                    }
                    catch ( ComponentLookupException e )
                    {
                        // this is just silly, lookupList should return an empty list!
                        logger.warn( "Failed to lookup lifecycle participants: " + e.getMessage() );
                    }
                }
            }
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( originalClassLoader );
        }

        return lifecycleListeners;
    }
1810#private MavenExecutionResult processResult( MavenExecutionResult result, Throwable e )
    {
        if ( !result.getExceptions().contains( e ) )
        {
            result.addException( e );
        }

        return result;
    }
1811#private List<MavenProject> getProjectsForMavenReactor( MavenExecutionRequest request )
        throws ProjectBuildingException
    {
        List<MavenProject> projects =  new ArrayList<MavenProject>();

        // We have no POM file.
        //
        if ( request.getPom() == null )
        {
            ModelSource modelSource = new UrlModelSource( DefaultMaven.class.getResource( "project/standalone.xml" ) );
            MavenProject project =
                projectBuilder.build( modelSource, request.getProjectBuildingRequest() ).getProject();
            project.setExecutionRoot( true );
            projects.add( project );
            request.setProjectPresent( false );
            return projects;
        }

        List<File> files = Arrays.asList( request.getPom().getAbsoluteFile() );        
        collectProjects( projects, files, request );
        return projects;
    }
1812#private Map<String, MavenProject> getProjectMap( List<MavenProject> projects )
        throws org.apache.maven.DuplicateProjectException
    {
        Map<String, MavenProject> index = new LinkedHashMap<String, MavenProject>();
        Map<String, List<File>> collisions = new LinkedHashMap<String, List<File>>();

        for ( MavenProject project : projects )
        {
            String projectId = ArtifactUtils.key( project.getGroupId(), project.getArtifactId(), project.getVersion() );

            MavenProject collision = index.get( projectId );

            if ( collision == null )
            {
                index.put( projectId, project );
            }
            else
            {
                List<File> pomFiles = collisions.get( projectId );

                if ( pomFiles == null )
                {
                    pomFiles = new ArrayList<File>( Arrays.asList( collision.getFile(), project.getFile() ) );
                    collisions.put( projectId, pomFiles );
                }
                else
                {
                    pomFiles.add( project.getFile() );
                }
            }
        }

        if ( !collisions.isEmpty() )
        {
            throw new org.apache.maven.DuplicateProjectException( "Two or more projects in the reactor"
                + " have the same identifier, please make sure that <groupId>:<artifactId>:<version>"
                + " is unique for each project: " + collisions, collisions );
        }

        return index;
    }
1813#private void collectProjects( List<MavenProject> projects, List<File> files, MavenExecutionRequest request )
        throws ProjectBuildingException
    {
        ProjectBuildingRequest projectBuildingRequest = request.getProjectBuildingRequest();

        List<ProjectBuildingResult> results = projectBuilder.build( files, request.isRecursive(), projectBuildingRequest );

        boolean problems = false;

        for ( ProjectBuildingResult result : results )
        {
            projects.add( result.getProject() );

            if ( !result.getProblems().isEmpty() && logger.isWarnEnabled() )
            {
                logger.warn( "" );
                logger.warn( "Some problems were encountered while building the effective model for "
                    + result.getProject().getId() );

                for ( ModelProblem problem : result.getProblems() )
                {
                    String location = ModelProblemUtils.formatLocation( problem, result.getProjectId() );
                    logger.warn( problem.getMessage() + ( StringUtils.isNotEmpty( location ) ? " @ " + location : "" ) );
                }

                problems = true;
            }
        }

        if ( problems )
        {
            logger.warn( "" );
            logger.warn( "It is highly recommended to fix these problems"
                + " because they threaten the stability of your build." );
            logger.warn( "" );
            logger.warn( "For this reason, future Maven versions might no"
                + " longer support building such malformed projects." );
            logger.warn( "" );
        }
    }
1814#private void validateActivatedProfiles( List<MavenProject> projects, List<String> activeProfileIds )
    {
        Collection<String> notActivatedProfileIds = new LinkedHashSet<String>( activeProfileIds );

        for ( MavenProject project : projects )
        {
            for ( List<String> profileIds : project.getInjectedProfileIds().values() )
            {
                notActivatedProfileIds.removeAll( profileIds );
            }
        }

        for ( String notActivatedProfileId : notActivatedProfileIds )
        {
            logger.warn( "The requested profile \"" + notActivatedProfileId
                + "\" could not be activated because it does not exist." );
        }
    }
1815#protected Logger getLogger()
    {
        return logger;
    }
1816#private ProjectDependencyGraph createDependencyGraph( ProjectSorter sorter, MavenExecutionRequest request )
        throws MavenExecutionException
    {
        ProjectDependencyGraph graph = new DefaultProjectDependencyGraph( sorter );

        List<MavenProject> activeProjects = sorter.getSortedProjects();

        activeProjects = trimSelectedProjects( activeProjects, graph, request );
        activeProjects = trimResumedProjects( activeProjects, request );

        if ( activeProjects.size() != sorter.getSortedProjects().size() )
        {
            graph = new FilteredProjectDependencyGraph( graph, activeProjects );
        }

        return graph;
    }
1817#private List<MavenProject> trimSelectedProjects( List<MavenProject> projects, ProjectDependencyGraph graph,
                                                     MavenExecutionRequest request )
        throws MavenExecutionException
    {
        List<MavenProject> result = projects;

        if ( !request.getSelectedProjects().isEmpty() )
        {
            File reactorDirectory = null;
            if ( request.getBaseDirectory() != null )
            {
                reactorDirectory = new File( request.getBaseDirectory() );
            }

            Collection<MavenProject> selectedProjects = new LinkedHashSet<MavenProject>( projects.size() );

            for ( String selector : request.getSelectedProjects() )
            {
                MavenProject selectedProject = null;

                for ( MavenProject project : projects )
                {
                    if ( isMatchingProject( project, selector, reactorDirectory ) )
                    {
                        selectedProject = project;
                        break;
                    }
                }

                if ( selectedProject != null )
                {
                    selectedProjects.add( selectedProject );
                }
                else
                {
                    throw new MavenExecutionException( "Could not find the selected project in the reactor: "
                        + selector, request.getPom() );
                }
            }

            boolean makeUpstream = false;
            boolean makeDownstream = false;

            if ( MavenExecutionRequest.REACTOR_MAKE_UPSTREAM.equals( request.getMakeBehavior() ) )
            {
                makeUpstream = true;
            }
            else if ( MavenExecutionRequest.REACTOR_MAKE_DOWNSTREAM.equals( request.getMakeBehavior() ) )
            {
                makeDownstream = true;
            }
            else if ( MavenExecutionRequest.REACTOR_MAKE_BOTH.equals( request.getMakeBehavior() ) )
            {
                makeUpstream = true;
                makeDownstream = true;
            }
            else if ( StringUtils.isNotEmpty( request.getMakeBehavior() ) )
            {
                throw new MavenExecutionException( "Invalid reactor make behavior: " + request.getMakeBehavior(),
                                                   request.getPom() );
            }

            if ( makeUpstream || makeDownstream )
            {
                for ( MavenProject selectedProject : new ArrayList<MavenProject>( selectedProjects ) )
                {
                    if ( makeUpstream )
                    {
                        selectedProjects.addAll( graph.getUpstreamProjects( selectedProject, true ) );
                    }
                    if ( makeDownstream )
                    {
                        selectedProjects.addAll( graph.getDownstreamProjects( selectedProject, true ) );
                    }
                }
            }

            result = new ArrayList<MavenProject>( selectedProjects.size() );

            for ( MavenProject project : projects )
            {
                if ( selectedProjects.contains( project ) )
                {
                    result.add( project );
                }
            }
        }

        return result;
    }
1818#private List<MavenProject> trimResumedProjects( List<MavenProject> projects, MavenExecutionRequest request )
        throws MavenExecutionException
    {
        List<MavenProject> result = projects;

        if ( StringUtils.isNotEmpty( request.getResumeFrom() ) )
        {
            File reactorDirectory = null;
            if ( request.getBaseDirectory() != null )
            {
                reactorDirectory = new File( request.getBaseDirectory() );
            }

            String selector = request.getResumeFrom();

            result = new ArrayList<MavenProject>( projects.size() );

            boolean resumed = false;

            for ( MavenProject project : projects )
            {
                if ( !resumed && isMatchingProject( project, selector, reactorDirectory ) )
                {
                    resumed = true;
                }

                if ( resumed )
                {
                    result.add( project );
                }
            }

            if ( !resumed )
            {
                throw new MavenExecutionException( "Could not find project to resume reactor build from: " + selector
                    + " vs " + projects, request.getPom() );
            }
        }

        return result;
    }
1819#private boolean isMatchingProject( MavenProject project, String selector, File reactorDirectory )
    {
        // [groupId]:artifactId
        if ( selector.indexOf( ':' ) >= 0 )
        {
            String id = ':' + project.getArtifactId();

            if ( id.equals( selector ) )
            {
                return true;
            }

            id = project.getGroupId() + id;

            if ( id.equals( selector ) )
            {
                return true;
            }
        }

        // relative path, e.g. "sub", "../sub" or "."
        else if ( reactorDirectory != null )
        {
            File selectedProject = new File( new File( reactorDirectory, selector ).toURI().normalize() );

            if ( selectedProject.isFile() )
            {
                return selectedProject.equals( project.getFile() );
            }
            else if ( selectedProject.isDirectory() )
            {
                return selectedProject.equals( project.getBasedir() );
            }
        }

        return false;
    }
1820#public Set<Artifact> resolve( MavenProject project, Collection<String> scopesToResolve, MavenSession session )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        return resolve( Collections.singleton( project ), scopesToResolve, session );
    }
1821#public Set<Artifact> resolve( MavenProject project, Collection<String> scopesToCollect,
                                  Collection<String> scopesToResolve, MavenSession session )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        Set<MavenProject> mavenProjects = Collections.singleton( project );
        return resolveImpl( mavenProjects, scopesToCollect, scopesToResolve, session,
                            getIgnorableArtifacts( mavenProjects ) );
    }
1822#public Set<Artifact> resolve( Collection<? extends MavenProject> projects, Collection<String> scopesToResolve,
                                  MavenSession session )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        return resolveImpl( projects, null, scopesToResolve, session, getIgnorableArtifacts( projects ) );
    }
1823#public Set<Artifact> resolve( MavenProject project, Collection<String> scopesToCollect,
                                  Collection<String> scopesToResolve, MavenSession session,
                                  Set<Artifact> ignoreableArtifacts )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        return resolveImpl( Collections.singleton( project ), scopesToCollect, scopesToResolve, session,
                            getIgnorableArtifacts( ignoreableArtifacts ) );
    }
1824#private Set<Artifact> resolveImpl( Collection<? extends MavenProject> projects, Collection<String> scopesToCollect,
                                       Collection<String> scopesToResolve, MavenSession session,
                                       Set<String> projectIds )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        Set<Artifact> resolved = new LinkedHashSet<Artifact>();

        if ( projects == null || projects.isEmpty() )
        {
            return resolved;
        }

        if ( ( scopesToCollect == null || scopesToCollect.isEmpty() ) &&
            ( scopesToResolve == null || scopesToResolve.isEmpty() ) )
        {
            return resolved;
        }

        /*

        Logic for transitive global exclusions

        List<String> exclusions = new ArrayList<String>();

        for ( Dependency d : project.getDependencies() )
        {
            if ( d.getExclusions() != null )
            {
                for ( Exclusion e : d.getExclusions() )
                {
                    exclusions.add(  e.getGroupId() + ":" + e.getArtifactId() );
                }
            }
        }

        ArtifactFilter scopeFilter = new ScopeArtifactFilter( scope );

        ArtifactFilter filter;

        if ( ! exclusions.isEmpty() )
        {
            filter = new AndArtifactFilter( Arrays.asList( new ArtifactFilter[]{ new ExcludesArtifactFilter( exclusions ), scopeFilter } ) );
        }
        else
        {
            filter = scopeFilter;
        }
        */

        CumulativeScopeArtifactFilter resolutionScopeFilter = new CumulativeScopeArtifactFilter( scopesToResolve );

        CumulativeScopeArtifactFilter collectionScopeFilter = new CumulativeScopeArtifactFilter( scopesToCollect );
        collectionScopeFilter = new CumulativeScopeArtifactFilter( collectionScopeFilter, resolutionScopeFilter );

        ArtifactResolutionRequest request =
            new ArtifactResolutionRequest().setResolveRoot( false ).setResolveTransitively( true ).setCollectionFilter(
                collectionScopeFilter ).setResolutionFilter( resolutionScopeFilter ).setLocalRepository(
                session.getLocalRepository() ).setOffline( session.isOffline() ).setForceUpdate(
                session.getRequest().isUpdateSnapshots() );
        request.setServers( session.getRequest().getServers() );
        request.setMirrors( session.getRequest().getMirrors() );
        request.setProxies( session.getRequest().getProxies() );

        for ( MavenProject project : projects )
        {
            request.setArtifact( new ProjectArtifact( project ) );
            request.setArtifactDependencies( project.getDependencyArtifacts() );
            request.setManagedVersionMap( project.getManagedVersionMap() );
            request.setRemoteRepositories( project.getRemoteArtifactRepositories() );

            ArtifactResolutionResult result = repositorySystem.resolve( request );

            try
            {
                resolutionErrorHandler.throwErrors( request, result );
            }
            catch ( MultipleArtifactsNotFoundException e )
            {

                Collection<Artifact> missing = new HashSet<Artifact>( e.getMissingArtifacts() );

                for ( Iterator<Artifact> it = missing.iterator(); it.hasNext(); )
                {
                    String key = ArtifactUtils.key( it.next() );
                    if ( projectIds.contains( key ) )
                    {
                        it.remove();
                    }
                }

                if ( !missing.isEmpty() )
                {
                    throw e;
                }
            }

            resolved.addAll( result.getArtifacts() );
        }

        return resolved;
    }
1825#private Set<String> getIgnorableArtifacts( Collection<? extends MavenProject> projects )
    {
        Set<String> projectIds = new HashSet<String>( projects.size() * 2 );

        for ( MavenProject p : projects )
        {
            String key = ArtifactUtils.key( p.getGroupId(), p.getArtifactId(), p.getVersion() );
            projectIds.add( key );
        }
        return projectIds;
    }
1826#private Set<String> getIgnorableArtifacts( Iterable<Artifact> artifactIterable )
    {
        Set<String> projectIds = new HashSet<String>();

        for ( Artifact artifact : artifactIterable )
        {
            String key = ArtifactUtils.key( artifact );
            projectIds.add( key );
        }
        return projectIds;
    }
1827#public LoggingRepositoryListener( Logger logger )
    {
        this.logger = logger;
    }
1828#@Override
    public void artifactInstalling( RepositoryEvent event )
    {
        logger.info( "Installing " + event.getArtifact().getFile() + " to " + event.getFile() );
    }
1829#@Override
    public void metadataInstalling( RepositoryEvent event )
    {
        logger.debug( "Installing " + event.getMetadata() + " to " + event.getFile() );
    }
1830#@Override
    public void metadataResolved( RepositoryEvent event )
    {
        Exception e = event.getException();
        if ( e != null )
        {
            if ( e instanceof MetadataNotFoundException )
            {
                logger.debug( e.getMessage() );
            }
            else if ( logger.isDebugEnabled() )
            {
                logger.warn( e.getMessage(), e );
            }
            else
            {
                logger.warn( e.getMessage() );
            }
        }
    }
1831#@Override
    public void metadataInvalid( RepositoryEvent event )
    {
        Exception exception = event.getException();

        StringBuilder buffer = new StringBuilder( 256 );
        buffer.append( "The metadata " );
        if ( event.getMetadata().getFile() != null )
        {
            buffer.append( event.getMetadata().getFile() );
        }
        else
        {
            buffer.append( event.getMetadata() );
        }

        if ( exception instanceof FileNotFoundException )
        {
            buffer.append( " is inaccessible" );
        }
        else
        {
            buffer.append( " is invalid" );
        }

        if ( exception != null )
        {
            buffer.append( ": " );
            buffer.append( exception.getMessage() );
        }

        if ( logger.isDebugEnabled() )
        {
            logger.warn( buffer.toString(), exception );
        }
        else
        {
            logger.warn( buffer.toString() );
        }
    }
1832#@Override
    public void artifactDescriptorInvalid( RepositoryEvent event )
    {
        StringBuilder buffer = new StringBuilder( 256 );
        buffer.append( "The POM for " );
        buffer.append( event.getArtifact() );
        buffer.append( " is invalid, transitive dependencies (if any) will not be available" );

        if ( logger.isDebugEnabled() )
        {
            logger.warn( buffer + ": " + event.getException().getMessage() );
        }
        else
        {
            logger.warn( buffer + ", enable debug logging for more details" );
        }
    }
1833#@Override
    public void artifactDescriptorMissing( RepositoryEvent event )
    {
        logger.warn( "The POM for " + event.getArtifact() + " is missing, no dependency information available" );
    }
1834#/**
     * Creates a new project dependency graph based on the specified project sorting.
     * 
     * @param sorter The project sorter backing the graph, must not be {@code null}.
     */
    public DefaultProjectDependencyGraph( ProjectSorter sorter )
    {
        if ( sorter == null )
        {
            throw new IllegalArgumentException( "project sorter missing" );
        }

        this.sorter = sorter;
    }
1835#public List<MavenProject> getSortedProjects()
    {
        return new ArrayList<MavenProject>( sorter.getSortedProjects() );
    }
1836#public List<MavenProject> getDownstreamProjects( MavenProject project, boolean transitive )
    {
        if ( project == null )
        {
            throw new IllegalArgumentException( "project missing" );
        }

        Collection<String> projectIds = new HashSet<String>();

        getDownstreamProjects( ProjectSorter.getId( project ), projectIds, transitive );

        return getProjects( projectIds );
    }
1837#private void getDownstreamProjects( String projectId, Collection<String> projectIds, boolean transitive )
    {
        for ( String id : sorter.getDependents( projectId ) )
        {
            if ( projectIds.add( id ) )
            {
                if ( transitive )
                {
                    getDownstreamProjects( id, projectIds, transitive );
                }
            }
        }
    }
1838#public List<MavenProject> getUpstreamProjects( MavenProject project, boolean transitive )
    {
        if ( project == null )
        {
            throw new IllegalArgumentException( "project missing" );
        }

        Collection<String> projectIds = new HashSet<String>();

        getUpstreamProjects( ProjectSorter.getId( project ), projectIds, transitive );

        return getProjects( projectIds );
    }
1839#private void getUpstreamProjects( String projectId, Collection<String> projectIds, boolean transitive )
    {
        for ( String id : sorter.getDependencies( projectId ) )
        {
            if ( projectIds.add( id ) && transitive )
            {
                getUpstreamProjects( id, projectIds, transitive );
            }
        }
    }
1840#private List<MavenProject> getProjects( Collection<String> projectIds )
    {
        List<MavenProject> projects = new ArrayList<MavenProject>();

        for ( MavenProject p : sorter.getSortedProjects() )
        {
            if ( projectIds.contains( ProjectSorter.getId( p ) ) )
            {
                projects.add( p );
            }
        }

        return projects;
    }
1841#@Override
    public String toString()
    {
        return sorter.getSortedProjects().toString();
    }
1842#/**
     * @deprecated Use this class as a component instead, and then use getArtifactFilter().
     */
    public static ArtifactFilter createStandardFilter()
    {
        // TODO: configure this from bootstrap or scan lib
        return new ExclusionSetFilter( DEFAULT_EXCLUSIONS );
    }
1843#/**
     * Returns the artifact filter for the core + extension artifacts.
     *
     * @see org.apache.maven.ArtifactFilterManager#getArtifactFilter()
     */
    public ArtifactFilter getArtifactFilter()
    {
        Set<String> excludes = new LinkedHashSet<String>( excludedArtifacts );

        for ( ArtifactFilterManagerDelegate delegate : getDelegates() )
        {
            delegate.addExcludes( excludes );
        }

        return new ExclusionSetFilter( excludes );
    }
1844#/**
     * Returns the artifact filter for the standard core artifacts.
     *
     * @see org.apache.maven.ArtifactFilterManager#getExtensionDependencyFilter()
     */
    public ArtifactFilter getCoreArtifactFilter()
    {
        return new ExclusionSetFilter( getCoreArtifactExcludes() );
    }
1845#private List<ArtifactFilterManagerDelegate> getDelegates()
    {
        try
        {
            return plexus.lookupList( ArtifactFilterManagerDelegate.class );
        }
        catch ( ComponentLookupException e )
        {
            return new ArrayList<ArtifactFilterManagerDelegate>();
        }
    }
1846#/* (non-Javadoc)
     * @see org.apache.maven.ArtifactFilterManager#excludeArtifact(java.lang.String)
     */
    public void excludeArtifact( String artifactId )
    {
        excludedArtifacts.add( artifactId );
    }
1847#public Set<String> getCoreArtifactExcludes()
    {
        Set<String> excludes = new LinkedHashSet<String>( DEFAULT_EXCLUSIONS );

        for ( ArtifactFilterManagerDelegate delegate : getDelegates() )
        {
            delegate.addCoreExcludes( excludes );
        }

        return excludes;
    }
1848#public BuildAbort( String message )
    {
        super( message );
    }
1849#public BuildAbort( String message, Throwable cause )
    {
        super( message, cause );
    }
1850#/**
     * Returns a filter for core + extension artifacts.
     */
    ArtifactFilter getArtifactFilter();
1851#/**
     * Returns a filter for only the core artifacts.
     */
    ArtifactFilter getCoreArtifactFilter();
1852#/**
     * Exclude an extension artifact (doesn't affect getArtifactFilter's result,
     * only getExtensionArtifactFilter).
     * @param artifactId
     */
    void excludeArtifact( String artifactId );
1853#Set<String> getCoreArtifactExcludes();
1854#/**
     * Invoked after all MavenProject instances have been created.
     *
     * This callback is intended to allow extensions to manipulate MavenProjects
     * before they are sorted and actual build execution starts.
     */
    public void afterProjectsRead( MavenSession session )
        throws MavenExecutionException
    {
        // do nothing
    }
1855#/**
     * Invoked after MavenSession instance has been created.
     *
     * This callback is intended to allow extensions to inject execution properties,
     * activate profiles and perform similar tasks that affect MavenProject
     * instance construction.
     */
    // TODO: This is too early for build extensions, so maybe just remove it?
    public void afterSessionStart( MavenSession session )
        throws MavenExecutionException
    {
        // do nothing
    }
1856#private static String nullify( String string )
    {
        return ( string == null || string.length() <= 0 ) ? null : string;
    }
1857#private static org.apache.maven.artifact.Artifact toArtifact( Dependency dependency )
    {
        if ( dependency == null )
        {
            return null;
        }

        org.apache.maven.artifact.Artifact result = toArtifact( dependency.getArtifact() );
        result.setScope( dependency.getScope() );
        result.setOptional( dependency.isOptional() );

        return result;
    }
1858#public static org.apache.maven.artifact.Artifact toArtifact( Artifact artifact )
    {
        if ( artifact == null )
        {
            return null;
        }

        ArtifactHandler handler = newHandler( artifact );

        /*
         * NOTE: From Artifact.hasClassifier(), an empty string and a null both denote "no classifier". However, some
         * plugins only check for null, so be sure to nullify an empty classifier.
         */
        org.apache.maven.artifact.Artifact result =
            new org.apache.maven.artifact.DefaultArtifact( artifact.getGroupId(), artifact.getArtifactId(),
                                                           artifact.getVersion(), null,
                                                           artifact.getProperty( ArtifactProperties.TYPE,
                                                                                 artifact.getExtension() ),
                                                           nullify( artifact.getClassifier() ), handler );

        result.setFile( artifact.getFile() );
        result.setResolved( artifact.getFile() != null );

        List<String> trail = new ArrayList<String>( 1 );
        trail.add( result.getId() );
        result.setDependencyTrail( trail );

        return result;
    }
1859#public static void toArtifacts( Collection<org.apache.maven.artifact.Artifact> artifacts,
                                    Collection<? extends DependencyNode> nodes, List<String> trail,
                                    DependencyFilter filter )
    {
        for ( DependencyNode node : nodes )
        {
            org.apache.maven.artifact.Artifact artifact = toArtifact( node.getDependency() );

            List<String> nodeTrail = new ArrayList<String>( trail.size() + 1 );
            nodeTrail.addAll( trail );
            nodeTrail.add( artifact.getId() );

            if ( filter == null || filter.accept( node, Collections.<DependencyNode> emptyList() ) )
            {
                artifact.setDependencyTrail( nodeTrail );
                artifacts.add( artifact );
            }

            toArtifacts( artifacts, node.getChildren(), nodeTrail, filter );
        }
    }
1860#public static Artifact toArtifact( org.apache.maven.artifact.Artifact artifact )
    {
        if ( artifact == null )
        {
            return null;
        }

        String version = artifact.getVersion();
        if ( version == null && artifact.getVersionRange() != null )
        {
            version = artifact.getVersionRange().toString();
        }

        Map<String, String> props = null;
        if ( org.apache.maven.artifact.Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )
        {
            String localPath = ( artifact.getFile() != null ) ? artifact.getFile().getPath() : "";
            props = Collections.singletonMap( ArtifactProperties.LOCAL_PATH, localPath );
        }

        Artifact result =
            new DefaultArtifact( artifact.getGroupId(), artifact.getArtifactId(), artifact.getClassifier(),
                                 artifact.getArtifactHandler().getExtension(), version, props,
                                 newArtifactType( artifact.getType(), artifact.getArtifactHandler() ) );
        result = result.setFile( artifact.getFile() );

        return result;
    }
1861#public static Dependency toDependency( org.apache.maven.artifact.Artifact artifact,
                                           Collection<org.apache.maven.model.Exclusion> exclusions )
    {
        if ( artifact == null )
        {
            return null;
        }

        Artifact result = toArtifact( artifact );

        List<Exclusion> excl = null;
        if ( exclusions != null )
        {
            excl = new ArrayList<Exclusion>( exclusions.size() );
            for ( org.apache.maven.model.Exclusion exclusion : exclusions )
            {
                excl.add( toExclusion( exclusion ) );
            }
        }

        return new Dependency( result, artifact.getScope(), artifact.isOptional(), excl );
    }
1862#public static List<RemoteRepository> toRepos( List<ArtifactRepository> repos )
    {
        if ( repos == null )
        {
            return null;
        }

        List<RemoteRepository> results = new ArrayList<RemoteRepository>( repos.size() );
        for ( ArtifactRepository repo : repos )
        {
            results.add( toRepo( repo ) );
        }
        return results;
    }
1863#public static RemoteRepository toRepo( ArtifactRepository repo )
    {
        RemoteRepository result = null;
        if ( repo != null )
        {
            result = new RemoteRepository( repo.getId(), getLayout( repo ), repo.getUrl() );
            result.setPolicy( true, toPolicy( repo.getSnapshots() ) );
            result.setPolicy( false, toPolicy( repo.getReleases() ) );
            result.setAuthentication( toAuthentication( repo.getAuthentication() ) );
            result.setProxy( toProxy( repo.getProxy() ) );
            result.setMirroredRepositories( toRepos( repo.getMirroredRepositories() ) );
        }
        return result;
    }
1864#public static String getLayout( ArtifactRepository repo )
    {
        try
        {
            return repo.getLayout().getId();
        }
        catch ( LinkageError e )
        {
            /*
             * NOTE: getId() was added in 3.x and is as such not implemented by plugins compiled against 2.x APIs.
             */
            String className = repo.getLayout().getClass().getSimpleName();
            if ( className.endsWith( "RepositoryLayout" ) )
            {
                String layout = className.substring( 0, className.length() - "RepositoryLayout".length() );
                if ( layout.length() > 0 )
                {
                    layout = Character.toLowerCase( layout.charAt( 0 ) ) + layout.substring( 1 );
                    return layout;
                }
            }
            return "";
        }
    }
1865#private static RepositoryPolicy toPolicy( ArtifactRepositoryPolicy policy )
    {
        RepositoryPolicy result = null;
        if ( policy != null )
        {
            result = new RepositoryPolicy( policy.isEnabled(), policy.getUpdatePolicy(), policy.getChecksumPolicy() );
        }
        return result;
    }
1866#private static Authentication toAuthentication( org.apache.maven.artifact.repository.Authentication auth )
    {
        Authentication result = null;
        if ( auth != null )
        {
            result =
                new Authentication( auth.getUsername(), auth.getPassword(), auth.getPrivateKey(), auth.getPassphrase() );
        }
        return result;
    }
1867#private static Proxy toProxy( org.apache.maven.repository.Proxy proxy )
    {
        Proxy result = null;
        if ( proxy != null )
        {
            Authentication auth = new Authentication( proxy.getUserName(), proxy.getPassword() );
            result = new Proxy( proxy.getProtocol(), proxy.getHost(), proxy.getPort(), auth );
        }
        return result;
    }
1868#public static ArtifactHandler newHandler( Artifact artifact )
    {
        String type = artifact.getProperty( ArtifactProperties.TYPE, artifact.getExtension() );
        DefaultArtifactHandler handler = new DefaultArtifactHandler( type );
        handler.setExtension( artifact.getExtension() );
        handler.setLanguage( artifact.getProperty( ArtifactProperties.LANGUAGE, null ) );
        handler.setAddedToClasspath( Boolean.parseBoolean( artifact.getProperty( ArtifactProperties.CONSTITUTES_BUILD_PATH,
                                                                                 "" ) ) );
        handler.setIncludesDependencies( Boolean.parseBoolean( artifact.getProperty( ArtifactProperties.INCLUDES_DEPENDENCIES,
                                                                                     "" ) ) );
        return handler;
    }
1869#public static ArtifactType newArtifactType( String id, ArtifactHandler handler )
    {
        return new DefaultArtifactType( id, handler.getExtension(), handler.getClassifier(), handler.getLanguage(),
                                        handler.isAddedToClasspath(), handler.isIncludesDependencies() );
    }
1870#public static Dependency toDependency( org.apache.maven.model.Dependency dependency,
                                           ArtifactTypeRegistry stereotypes )
    {
        ArtifactType stereotype = stereotypes.get( dependency.getType() );
        if ( stereotype == null )
        {
            stereotype = new DefaultArtifactType( dependency.getType() );
        }

        boolean system = dependency.getSystemPath() != null && dependency.getSystemPath().length() > 0;

        Map<String, String> props = null;
        if ( system )
        {
            props = Collections.singletonMap( ArtifactProperties.LOCAL_PATH, dependency.getSystemPath() );
        }

        Artifact artifact =
            new DefaultArtifact( dependency.getGroupId(), dependency.getArtifactId(), dependency.getClassifier(), null,
                                 dependency.getVersion(), props, stereotype );

        List<Exclusion> exclusions = new ArrayList<Exclusion>( dependency.getExclusions().size() );
        for ( org.apache.maven.model.Exclusion exclusion : dependency.getExclusions() )
        {
            exclusions.add( toExclusion( exclusion ) );
        }

        Dependency result = new Dependency( artifact, dependency.getScope(), dependency.isOptional(), exclusions );

        return result;
    }
1871#private static Exclusion toExclusion( org.apache.maven.model.Exclusion exclusion )
    {
        return new Exclusion( exclusion.getGroupId(), exclusion.getArtifactId(), "*", "*" );
    }
1872#public static ArtifactTypeRegistry newArtifactTypeRegistry( ArtifactHandlerManager handlerManager )
    {
        return new MavenArtifactTypeRegistry( handlerManager );
    }
1873#public MavenArtifactTypeRegistry( ArtifactHandlerManager handlerManager )
        {
            this.handlerManager = handlerManager;
        }
1874#public ArtifactType get( String stereotypeId )
        {
            ArtifactHandler handler = handlerManager.getArtifactHandler( stereotypeId );
            return newArtifactType( stereotypeId, handler );
        }
1875#public ReactorReader( Map<String, MavenProject> reactorProjects )
    {
        projectsByGAV = reactorProjects;

        projectsByGA = new HashMap<String, List<MavenProject>>( reactorProjects.size() * 2 );
        for ( MavenProject project : reactorProjects.values() )
        {
            String key = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() );

            List<MavenProject> projects = projectsByGA.get( key );

            if ( projects == null )
            {
                projects = new ArrayList<MavenProject>( 1 );
                projectsByGA.put( key, projects );
            }

            projects.add( project );
        }

        repository = new WorkspaceRepository( "reactor", new HashSet<String>( projectsByGAV.keySet() ) );
    }
1876#private File find( MavenProject project, Artifact artifact )
    {
        if ( "pom".equals( artifact.getExtension() ) )
        {
            return project.getFile();
        }

        org.apache.maven.artifact.Artifact projectArtifact = findMatchingArtifact( project, artifact );

        if ( hasArtifactFileFromPackagePhase( projectArtifact ) )
        {
            return projectArtifact.getFile();
        }
        else if ( !hasBeenPackaged( project ) )
        {
            // fallback to loose class files only if artifacts haven't been packaged yet

            if ( isTestArtifact( artifact ) )
            {
                if ( project.hasLifecyclePhase( "test-compile" ) )
                {
                    return new File( project.getBuild().getTestOutputDirectory() );
                }
            }
            else
            {
                if ( project.hasLifecyclePhase( "compile" ) )
                {
                    return new File( project.getBuild().getOutputDirectory() );
                }
            }
        }

        // The fall-through indicates that the artifact cannot be found;
        // for instance if package produced nothing or classifier problems.
        return null;
    }
1877#private boolean hasArtifactFileFromPackagePhase( org.apache.maven.artifact.Artifact projectArtifact )
    {
        return projectArtifact != null && projectArtifact.getFile() != null && projectArtifact.getFile().exists();
    }
1878#private boolean hasBeenPackaged( MavenProject project )
    {
        return project.hasLifecyclePhase( "package" ) || project.hasLifecyclePhase( "install" )
            || project.hasLifecyclePhase( "deploy" );
    }
1879#/**
     * Tries to resolve the specified artifact from the artifacts of the given project.
     * 
     * @param project The project to try to resolve the artifact from, must not be <code>null</code>.
     * @param requestedArtifact The artifact to resolve, must not be <code>null</code>.
     * @return The matching artifact from the project or <code>null</code> if not found.
     */
    private org.apache.maven.artifact.Artifact findMatchingArtifact( MavenProject project, Artifact requestedArtifact )
    {
        String requestedRepositoryConflictId = getConflictId( requestedArtifact );

        org.apache.maven.artifact.Artifact mainArtifact = project.getArtifact();
        if ( requestedRepositoryConflictId.equals( getConflictId( mainArtifact ) ) )
        {
            return mainArtifact;
        }

        Collection<org.apache.maven.artifact.Artifact> attachedArtifacts = project.getAttachedArtifacts();
        if ( attachedArtifacts != null && !attachedArtifacts.isEmpty() )
        {
            for ( org.apache.maven.artifact.Artifact attachedArtifact : attachedArtifacts )
            {
                if ( requestedRepositoryConflictId.equals( getConflictId( attachedArtifact ) ) )
                {
                    return attachedArtifact;
                }
            }
        }

        return null;
    }
1880#/**
     * Gets the repository conflict id of the specified artifact. Unlike the dependency conflict id, the repository
     * conflict id uses the artifact file extension instead of the artifact type. Hence, the repository conflict id more
     * closely reflects the identity of artifacts as perceived by a repository.
     * 
     * @param artifact The artifact, must not be <code>null</code>.
     * @return The repository conflict id, never <code>null</code>.
     */
    private String getConflictId( org.apache.maven.artifact.Artifact artifact )
    {
        StringBuilder buffer = new StringBuilder( 128 );
        buffer.append( artifact.getGroupId() );
        buffer.append( ':' ).append( artifact.getArtifactId() );
        if ( artifact.getArtifactHandler() != null )
        {
            buffer.append( ':' ).append( artifact.getArtifactHandler().getExtension() );
        }
        else
        {
            buffer.append( ':' ).append( artifact.getType() );
        }
        if ( artifact.hasClassifier() )
        {
            buffer.append( ':' ).append( artifact.getClassifier() );
        }
        return buffer.toString();
    }
1881#private String getConflictId( Artifact artifact )
    {
        StringBuilder buffer = new StringBuilder( 128 );
        buffer.append( artifact.getGroupId() );
        buffer.append( ':' ).append( artifact.getArtifactId() );
        buffer.append( ':' ).append( artifact.getExtension() );
        if ( artifact.getClassifier().length() > 0 )
        {
            buffer.append( ':' ).append( artifact.getClassifier() );
        }
        return buffer.toString();
    }
1882#/**
     * Determines whether the specified artifact refers to test classes.
     * 
     * @param artifact The artifact to check, must not be {@code null}.
     * @return {@code true} if the artifact refers to test classes, {@code false} otherwise.
     */
    private static boolean isTestArtifact( Artifact artifact )
    {
        return ( "test-jar".equals( artifact.getProperty( "type", "" ) ) )
            || ( "jar".equals( artifact.getExtension() ) && "tests".equals( artifact.getClassifier() ) );
    }
1883#public File findArtifact( Artifact artifact )
    {
        String projectKey = ArtifactUtils.key( artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion() );

        MavenProject project = projectsByGAV.get( projectKey );

        if ( project != null )
        {
            File file = find( project, artifact );
            if ( file == null && project != project.getExecutionProject() )
            {
                file = find( project.getExecutionProject(), artifact );
            }
            return file;
        }

        return null;
    }
1884#public List<String> findVersions( Artifact artifact )
    {
        String key = ArtifactUtils.versionlessKey( artifact.getGroupId(), artifact.getArtifactId() );

        List<MavenProject> projects = projectsByGA.get( key );
        if ( projects == null || projects.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<String> versions = new ArrayList<String>();

        for ( MavenProject project : projects )
        {
            if ( find( project, artifact ) != null )
            {
                versions.add( project.getVersion() );
            }
        }

        return Collections.unmodifiableList( versions );
    }
1885#public WorkspaceRepository getRepository()
    {
        return repository;
    }
1886#public ProjectCycleException( String message, CycleDetectedException cause )
    {
        super( message, cause );
    }
1887#public MavenExecutionException( String message, File pomFile )
    {
        super( message );
        this.pomFile = pomFile;
    }
1888#public MavenExecutionException( String message, File pomFile, ProjectBuildingException cause )
    {
        super( message, cause );
        this.pomFile = pomFile;
    }
1889#public MavenExecutionException( String message, Throwable cause )
    {
        super( message, cause );
    }
1890#public File getPomFile()
    {
        return pomFile;
    }
1891#public ProjectBuildFailureException( String projectId, MojoFailureException cause )
    {
        super( "Build for project: " + projectId + " failed during execution of mojo.", cause );

        this.projectId = projectId;
    }
1892#public MojoFailureException getMojoFailureException()
    {
        return (MojoFailureException) getCause();
    }
1893#public String getProjectId()
    {
        return projectId;
    }
1894#public InternalErrorException( String message, Throwable cause )
    {
        super( message, cause );
    }
1895#public BuildFailureException( String message )
    {
        super( message );
    }
1896#public BuildFailureException( String message, Throwable cause )
    {
        super( message, cause );
    }
1897#/**
     * Resolves the transitive dependencies of the specified project.
     *
     * @param project         The project whose dependencies should be resolved, must not be {@code null}.
     * @param scopesToResolve The dependency scopes that should be resolved, may be {@code null}.
     * @param session         The current build session, must not be {@code null}.
     * @return The transitive dependencies of the specified project that match the requested scopes, never {@code null}.
     */
    Set<Artifact> resolve( MavenProject project, Collection<String> scopesToResolve, MavenSession session )
        throws ArtifactResolutionException, ArtifactNotFoundException;
1898#/**
     * Resolves the transitive dependencies of the specified project.
     *
     * @param project         The project whose dependencies should be resolved, must not be {@code null}.
     * @param scopesToCollect The dependency scopes that should be collected, may be {@code null}.
     * @param scopesToResolve The dependency scopes that should be collected and also resolved, may be {@code null}.
     * @param session         The current build session, must not be {@code null}.
     * @return The transitive dependencies of the specified project that match the requested scopes, never {@code null}.
     */
    Set<Artifact> resolve( MavenProject project, Collection<String> scopesToCollect,
                           Collection<String> scopesToResolve, MavenSession session )
        throws ArtifactResolutionException, ArtifactNotFoundException;
1899#/**
     * Resolves the transitive dependencies of the specified project.
     *
     * @param project             The project whose dependencies should be resolved, must not be {@code null}.
     * @param scopesToCollect     The dependency scopes that should be collected, may be {@code null}.
     * @param scopesToResolve     The dependency scopes that should be collected and also resolved, may be {@code null}.
     * @param session             The current build session, must not be {@code null}.
     * @param ignoreableArtifacts Artifacts that need not be resolved
     * @return The transitive dependencies of the specified project that match the requested scopes, never {@code null}.
     */
    Set<Artifact> resolve( MavenProject project, Collection<String> scopesToCollect,
                           Collection<String> scopesToResolve, MavenSession session, Set<Artifact> ignoreableArtifacts )
        throws ArtifactResolutionException, ArtifactNotFoundException;
1900#/**
     * Resolves the transitive dependencies of the specified projects. Note that dependencies which can't be resolved
     * from any repository but are present among the set of specified projects will not cause an exception. Instead,
     * those unresolved artifacts will be returned in the result set, allowing the caller to take special care of
     * artifacts that haven't been build yet.
     *
     * @param projects The projects whose dependencies should be resolved, may be {@code null}.
     * @param scopes   The dependency scopes that should be resolved, may be {@code null}.
     * @param session  The current build session, must not be {@code null}.
     * @return The transitive dependencies of the specified projects that match the requested scopes, never {@code null}
     *         .
     */
    Set<Artifact> resolve( Collection<? extends MavenProject> projects, Collection<String> scopes, MavenSession session )
        throws ArtifactResolutionException, ArtifactNotFoundException;
1901#/**
     * Creates a new exception with specified details.
     * 
     * @param message The message text, may be {@code null}.
     * @param collisions The POM files of the projects that collided, indexed by their g:a:v, may be {@code null}.
     */
    public DuplicateProjectException( String message, Map<String, List<File>> collisions )
    {
        super( message, (File) null );

        this.collisions = ( collisions != null ) ? collisions : new LinkedHashMap<String, List<File>>();
    }
1902#/**
     * Gets the POM files of the projects that collided.
     * 
     * @return The POM files of the projects that collided, indexed by their g:a:v, never {@code null}.
     */
    public Map<String, List<File>> getCollisions()
    {
        return collisions;
    }
1903#/**
     * Creates a new project dependency graph from the specified graph.
     * 
     * @param projectDependencyGraph The project dependency graph to create a sub view from, must not be {@code null}.
     * @param whiteList The projects on which the dependency view should focus, must not be {@code null}.
     */
    public FilteredProjectDependencyGraph( ProjectDependencyGraph projectDependencyGraph,
                                           Collection<? extends MavenProject> whiteList )
    {
        if ( projectDependencyGraph == null )
        {
            throw new IllegalArgumentException( "project dependency graph missing" );
        }

        this.projectDependencyGraph = projectDependencyGraph;

        this.whiteList = new IdentityHashMap<MavenProject, Object>();

        for ( MavenProject project : whiteList )
        {
            this.whiteList.put( project, null );
        }
    }
1904#public List<MavenProject> getSortedProjects()
    {
        if ( sortedProjects == null )
        {
            sortedProjects = applyFilter( projectDependencyGraph.getSortedProjects() );
        }

        return new ArrayList<MavenProject>( sortedProjects );
    }
1905#public List<MavenProject> getDownstreamProjects( MavenProject project, boolean transitive )
    {
        return applyFilter( projectDependencyGraph.getDownstreamProjects( project, transitive ) );
    }
1906#public List<MavenProject> getUpstreamProjects( MavenProject project, boolean transitive )
    {
        return applyFilter( projectDependencyGraph.getUpstreamProjects( project, transitive ) );
    }
1907#private List<MavenProject> applyFilter( Collection<? extends MavenProject> projects )
    {
        List<MavenProject> filtered = new ArrayList<MavenProject>( projects.size() );

        for ( MavenProject project : projects )
        {
            if ( whiteList.containsKey( project ) )
            {
                filtered.add( project );
            }
        }

        return filtered;
    }
1908#@Override
    public String toString()
    {
        return getSortedProjects().toString();
    }
1909#MavenExecutionResult execute( MavenExecutionRequest request );
1910#void addExcludes( Set<String> excludes );
1911#void addCoreExcludes( Set<String> excludes );
1912#public MissingModuleException( String moduleName, File moduleFile, File pomFile )
    {
        super( "The module: " + moduleName + " cannot be found in file: " + moduleFile, pomFile );
        this.moduleName = moduleName;
        this.moduleFile = moduleFile;
    }
1913#public File getModuleFile()
    {
        return moduleFile;
    }
1914#public String getModuleName()
    {
        return moduleName;
    }
1915#public DependencyResolutionRequiredException( Artifact artifact )
    {
        super( "Attempted to access the artifact " + artifact + "; which has not yet been resolved" );
    }
1916#public InvalidRepositoryException( String message, String repositoryId, MalformedURLException cause )
    {
        super( message, cause );
        this.repositoryId = repositoryId;
    }
1917#protected InvalidRepositoryException( String message, String repositoryId, ComponentLookupException cause )
    {
        super( message, cause );
        this.repositoryId = repositoryId;
    }
1918#@Deprecated
    public InvalidRepositoryException( String message, Throwable t )
    {
        super( message );
        this.repositoryId = null;
    }
1919#public InvalidRepositoryException( String message, String repositoryId )
    {
        super( message );
        this.repositoryId = repositoryId;
    }
1920#public String getRepositoryId()
    {
        return repositoryId;
    }
1921#Artifact createArtifact( String groupId, String artifactId, String version, String scope, String type );
1922#Artifact createArtifactWithClassifier( String groupId, String artifactId, String version, String type,
                                           String classifier );
1923#Artifact createDependencyArtifact( String groupId, String artifactId, VersionRange versionRange, String type,
                                       String classifier, String scope );
1924#Artifact createDependencyArtifact( String groupId, String artifactId, VersionRange versionRange, String type,
                                       String classifier, String scope, boolean optional );
1925#Artifact createDependencyArtifact( String groupId, String artifactId, VersionRange versionRange, String type,
                                       String classifier, String scope, String inheritedScope );
1926#Artifact createDependencyArtifact( String groupId, String artifactId, VersionRange versionRange, String type,
                                       String classifier, String scope, String inheritedScope, boolean optional );
1927#Artifact createBuildArtifact( String groupId, String artifactId, String version, String packaging );
1928#Artifact createProjectArtifact( String groupId, String artifactId, String version );
1929#Artifact createParentArtifact( String groupId, String artifactId, String version );
1930#Artifact createPluginArtifact( String groupId, String artifactId, VersionRange versionRange );
1931#Artifact createProjectArtifact( String groupId, String artifactId, String version, String scope );
1932#Artifact createExtensionArtifact( String groupId, String artifactId, VersionRange versionRange );
1933#public Artifact createArtifact( String groupId, String artifactId, String version, String scope, String type )
    {
        return createArtifact( groupId, artifactId, version, scope, type, null, null );
    }
1934#public Artifact createArtifactWithClassifier( String groupId, String artifactId, String version, String type,
                                                  String classifier )
    {
        return createArtifact( groupId, artifactId, version, null, type, classifier, null );
    }
1935#public Artifact createDependencyArtifact( String groupId, String artifactId, VersionRange versionRange,
                                              String type, String classifier, String scope )
    {
        return createArtifact( groupId, artifactId, versionRange, type, classifier, scope, null );
    }
1936#public Artifact createDependencyArtifact( String groupId, String artifactId, VersionRange versionRange,
                                              String type, String classifier, String scope, boolean optional )
    {
        return createArtifact( groupId, artifactId, versionRange, type, classifier, scope, null, optional );
    }
1937#public Artifact createDependencyArtifact( String groupId, String artifactId, VersionRange versionRange,
                                              String type, String classifier, String scope, String inheritedScope )
    {
        return createArtifact( groupId, artifactId, versionRange, type, classifier, scope, inheritedScope );
    }
1938#public Artifact createDependencyArtifact( String groupId, String artifactId, VersionRange versionRange,
                                              String type, String classifier, String scope, String inheritedScope,
                                              boolean optional )
    {
        return createArtifact( groupId, artifactId, versionRange, type, classifier, scope, inheritedScope, optional );
    }
1939#public Artifact createBuildArtifact( String groupId, String artifactId, String version, String packaging )
    {
        return createArtifact( groupId, artifactId, version, null, packaging, null, null );
    }
1940#public Artifact createProjectArtifact( String groupId, String artifactId, String version )
    {
        return createProjectArtifact( groupId, artifactId, version, null );
    }
1941#public Artifact createParentArtifact( String groupId, String artifactId, String version )
    {
        return createProjectArtifact( groupId, artifactId, version );
    }
1942#public Artifact createPluginArtifact( String groupId, String artifactId, VersionRange versionRange )
    {
        return createArtifact( groupId, artifactId, versionRange, "maven-plugin", null, Artifact.SCOPE_RUNTIME, null );
    }
1943#public Artifact createProjectArtifact( String groupId, String artifactId, String version, String scope )
    {
        return createArtifact( groupId, artifactId, version, scope, "pom" );
    }
1944#public Artifact createExtensionArtifact( String groupId, String artifactId, VersionRange versionRange )
    {
        return createArtifact( groupId, artifactId, versionRange, "jar", null, Artifact.SCOPE_RUNTIME, null );
    }
1945#private Artifact createArtifact( String groupId, String artifactId, String version, String scope, String type,
                                     String classifier, String inheritedScope )
    {
        VersionRange versionRange = null;
        if ( version != null )
        {
            versionRange = VersionRange.createFromVersion( version );
        }
        return createArtifact( groupId, artifactId, versionRange, type, classifier, scope, inheritedScope );
    }
1946#private Artifact createArtifact( String groupId, String artifactId, VersionRange versionRange, String type,
                                     String classifier, String scope, String inheritedScope )
    {
        return createArtifact( groupId, artifactId, versionRange, type, classifier, scope, inheritedScope, false );
    }
1947#private Artifact createArtifact( String groupId, String artifactId, VersionRange versionRange, String type,
                                     String classifier, String scope, String inheritedScope, boolean optional )
    {
        String desiredScope = Artifact.SCOPE_RUNTIME;

        if ( inheritedScope == null )
        {
            desiredScope = scope;
        }
        else if ( Artifact.SCOPE_TEST.equals( scope ) || Artifact.SCOPE_PROVIDED.equals( scope ) )
        {
            return null;
        }
        else if ( Artifact.SCOPE_COMPILE.equals( scope ) && Artifact.SCOPE_COMPILE.equals( inheritedScope ) )
        {
            // added to retain compile artifactScope. Remove if you want compile inherited as runtime
            desiredScope = Artifact.SCOPE_COMPILE;
        }

        if ( Artifact.SCOPE_TEST.equals( inheritedScope ) )
        {
            desiredScope = Artifact.SCOPE_TEST;
        }

        if ( Artifact.SCOPE_PROVIDED.equals( inheritedScope ) )
        {
            desiredScope = Artifact.SCOPE_PROVIDED;
        }

        if ( Artifact.SCOPE_SYSTEM.equals( scope ) )
        {
            // system scopes come through unchanged...
            desiredScope = Artifact.SCOPE_SYSTEM;
        }

        ArtifactHandler handler = artifactHandlerManager.getArtifactHandler( type );

        return new DefaultArtifact( groupId, artifactId, versionRange, desiredScope, type, classifier, handler,
                                    optional );
    }
1948#public DefaultArtifactHandler()
    {
    }
1949#public DefaultArtifactHandler( String type )
    {
        this.type = type;
    }
1950#public String getExtension()
    {
        if ( extension == null )
        {
            extension = type;
        }
        return extension;
    }
1951#public void setExtension( String extension )
    {
        this.extension = extension;
    }
1952#public String getType()
    {
        return type;
    }
1953#public String getClassifier()
    {
        return classifier;
    }
1954#public String getDirectory()
    {
        if ( directory == null )
        {
            directory = getPackaging() + "s";
        }
        return directory;
    }
1955#public String getPackaging()
    {
        if ( packaging == null )
        {
            packaging = type;
        }
        return packaging;
    }
1956#public boolean isIncludesDependencies()
    {
        return includesDependencies;
    }
1957#public void setIncludesDependencies( boolean includesDependencies )
    {
        this.includesDependencies = includesDependencies;
    }
1958#public String getLanguage()
    {
        if ( language == null )
        {
            language = "none";
        }

        return language;
    }
1959#public void setLanguage( String language )
    {
        this.language = language;
    }
1960#public boolean isAddedToClasspath()
    {
        return addedToClasspath;
    }
1961#public void setAddedToClasspath( boolean addedToClasspath )
    {
        this.addedToClasspath = addedToClasspath;
    }
1962#ArtifactHandler getArtifactHandler( String type );
1963#@Deprecated
    void addHandlers( Map<String, ArtifactHandler> handlers );
1964#public ArtifactHandler getArtifactHandler( String type )
    {
        ArtifactHandler handler = unmanagedHandlers.get( type );

        if ( handler == null )
        {
            handler = artifactHandlers.get( type );

            if ( handler == null )
            {
                handler = new DefaultArtifactHandler( type );
            }
        }

        return handler;
    }
1965#public void addHandlers( Map<String, ArtifactHandler> handlers )
    {
        // legacy support for maven-gpg-plugin:1.0
        unmanagedHandlers.putAll( handlers );
    }
1966#@Deprecated
    public Set<String> getHandlerTypes()
    {
        return artifactHandlers.keySet();
    }
1967#ResolutionGroup retrieve( MetadataResolutionRequest request )
        throws ArtifactMetadataRetrievalException;
1968#ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository,
                              List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException;
1969#List<ArtifactVersion> retrieveAvailableVersions( MetadataResolutionRequest request )
        throws ArtifactMetadataRetrievalException;
1970#List<ArtifactVersion> retrieveAvailableVersions( Artifact artifact, ArtifactRepository localRepository,
                                                     List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException;
1971#List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository( Artifact artifact,
                                                                             ArtifactRepository localRepository,
                                                                             ArtifactRepository remoteRepository )
        throws ArtifactMetadataRetrievalException;
1972#public ArtifactMetadataRetrievalException( String message, Throwable cause, Artifact artifact )
    {
        super( message, cause, artifact );
    }
1973#protected AbstractArtifactMetadata( Artifact artifact )
    {
        super( artifact );
    }
1974#public ResolutionGroup( Artifact pomArtifact, Set<Artifact> artifacts,
                            List<ArtifactRepository> resolutionRepositories )
    {
        super( pomArtifact, artifacts, resolutionRepositories );
    }
1975#public ResolutionGroup( Artifact pomArtifact, Artifact relocatedArtifact, Set<Artifact> artifacts,
                            Map<String, Artifact> managedVersions, List<ArtifactRepository> resolutionRepositories )
    {
        super( pomArtifact, relocatedArtifact, artifacts, managedVersions, resolutionRepositories );
    }
1976#/**
     * Creates an empty repository request.
     */
    public DefaultRepositoryRequest()
    {
        // enables no-arg constructor
    }
1977#/**
     * Creates a shallow copy of the specified repository request.
     * 
     * @param repositoryRequest The repository request to copy from, must not be {@code null}.
     */
    public DefaultRepositoryRequest( RepositoryRequest repositoryRequest )
    {
        setLocalRepository( repositoryRequest.getLocalRepository() );
        setRemoteRepositories( repositoryRequest.getRemoteRepositories() );
        setOffline( repositoryRequest.isOffline() );
        setForceUpdate( repositoryRequest.isForceUpdate() );
    }
1978#public static RepositoryRequest getRepositoryRequest( MavenSession session, MavenProject project )
    {
        RepositoryRequest request = new DefaultRepositoryRequest();

        request.setLocalRepository( session.getLocalRepository() );
        if ( project != null )
        {
            request.setRemoteRepositories( project.getPluginArtifactRepositories() );
        }
        request.setOffline( session.isOffline() );
        request.setForceUpdate( session.getRequest().isUpdateSnapshots() );

        return request;
    }
1979#public boolean isOffline()
    {
        return offline;
    }
1980#public DefaultRepositoryRequest setOffline( boolean offline )
    {
        this.offline = offline;

        return this;
    }
1981#public boolean isForceUpdate()
    {
        return forceUpdate;
    }
1982#public DefaultRepositoryRequest setForceUpdate( boolean forceUpdate )
    {
        this.forceUpdate = forceUpdate;

        return this;
    }
1983#public ArtifactRepository getLocalRepository()
    {
        return localRepository;
    }
1984#public DefaultRepositoryRequest setLocalRepository( ArtifactRepository localRepository )
    {
        this.localRepository = localRepository;

        return this;
    }
1985#public List<ArtifactRepository> getRemoteRepositories()
    {
        if ( remoteRepositories == null )
        {
            remoteRepositories = new ArrayList<ArtifactRepository>();
        }

        return remoteRepositories;
    }
1986#public DefaultRepositoryRequest setRemoteRepositories( List<ArtifactRepository> remoteRepositories )
    {
        this.remoteRepositories = remoteRepositories;

        return this;
    }
1987#public MavenArtifactRepository()
    {
    }
1988#/**
     * Create a remote download repository.
     *
     * @param id        the unique identifier of the repository
     * @param url       the URL of the repository
     * @param layout    the layout of the repository
     * @param snapshots the policies to use for snapshots
     * @param releases  the policies to use for releases
     */
    public MavenArtifactRepository( String id, String url, ArtifactRepositoryLayout layout,
                                    ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases )
    {
        this.id = id;
        this.url = url;
        this.layout = layout;
        this.snapshots = snapshots;
        this.releases = releases;
        //
        // Derive these from the URL
        //
        this.protocol = protocol( url );
        this.basedir = basedir( url );
    }
1989#public String pathOf( Artifact artifact )
    {
        return layout.pathOf( artifact );
    }
1990#public String pathOfRemoteRepositoryMetadata( ArtifactMetadata artifactMetadata )
    {
        return layout.pathOfRemoteRepositoryMetadata( artifactMetadata );
    }
1991#public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository )
    {
        return layout.pathOfLocalRepositoryMetadata( metadata, repository );
    }
1992#public void setLayout( ArtifactRepositoryLayout layout )
    {
        this.layout = layout;
    }
1993#public ArtifactRepositoryLayout getLayout()
    {
        return layout;
    }
1994#public void setSnapshotUpdatePolicy( ArtifactRepositoryPolicy snapshots )
    {
        this.snapshots = snapshots;
    }
1995#public ArtifactRepositoryPolicy getSnapshots()
    {
        return snapshots;
    }
1996#public void setReleaseUpdatePolicy( ArtifactRepositoryPolicy releases )
    {
        this.releases = releases;
    }
1997#public ArtifactRepositoryPolicy getReleases()
    {
        return releases;
    }
1998#public String getKey()
    {
        return getId();
    }
1999#public String toString()
    {
        StringBuilder sb = new StringBuilder();

        sb.append( "       id: " ).append( getId() ).append( "\n" );
        sb.append( "      url: " ).append( getUrl() ).append( "\n" );
        sb.append( "   layout: " ).append( layout != null ? layout : "none" ).append( "\n" );

        if ( snapshots != null )
        {
            sb.append( "snapshots: [enabled => " ).append( snapshots.isEnabled() );
            sb.append( ", update => " ).append( snapshots.getUpdatePolicy() ).append( "]\n" );
        }

        if ( releases != null )
        {
            sb.append( " releases: [enabled => " ).append( releases.isEnabled() );
            sb.append( ", update => " ).append( releases.getUpdatePolicy() ).append( "]\n" );
        }

        return sb.toString();
    }
2000#public Artifact find( Artifact artifact )
    {
        File artifactFile = new File( getBasedir(), pathOf( artifact ) );

        // We need to set the file here or the resolver will fail with an NPE, not fully equipped to deal
        // with multiple local repository implementations yet.
        artifact.setFile( artifactFile );

        return artifact;
    }
2001#public List<String> findVersions( Artifact artifact )
    {
        return Collections.emptyList();
    }
2002#public String getId()
    {
        return id;
    }
2003#public String getUrl()
    {
        return url;
    }
2004#public String getBasedir()
    {
        return basedir;
    }
2005#public String getProtocol()
    {
        return protocol;
    }
2006#public void setId( String id )
    {
        this.id = id;
    }
2007#public void setUrl( String url )
    {
        this.url = url;

        this.protocol = protocol( url );
        this.basedir = basedir( url );
    }
2008#// Path Utils

    /**
     * /**
     * Return the protocol name.
     * <br/>
     * E.g: for input
     * <code>http://www.codehause.org</code> this method will return <code>http</code>
     *
     * @param url the url
     * @return the host name
     */
    private static String protocol( final String url )
    {
        final int pos = url.indexOf( ":" );

        if ( pos == -1 )
        {
            return "";
        }
        return url.substring( 0, pos ).trim();
    }
2009#/**
     * Derive the path portion of the given URL.
     *
     * @param url the repository URL
     * @return the basedir of the repository
     * @todo need to URL decode for spaces?
     */
    private String basedir( String url )
    {
        String retValue = null;

        if ( protocol.equalsIgnoreCase( "file" ) )
        {
            retValue = url.substring( protocol.length() + 1 );
            retValue = decode( retValue );
            // special case: if omitted // on protocol, keep path as is
            if ( retValue.startsWith( "//" ) )
            {
                retValue = retValue.substring( 2 );

                if ( retValue.length() >= 2 && ( retValue.charAt( 1 ) == '|' || retValue.charAt( 1 ) == ':' ) )
                {
                    // special case: if there is a windows drive letter, then keep the original return value
                    retValue = retValue.charAt( 0 ) + ":" + retValue.substring( 2 );
                }
                else
                {
                    // Now we expect the host
                    int index = retValue.indexOf( "/" );
                    if ( index >= 0 )
                    {
                        retValue = retValue.substring( index + 1 );
                    }

                    // special case: if there is a windows drive letter, then keep the original return value
                    if ( retValue.length() >= 2 && ( retValue.charAt( 1 ) == '|' || retValue.charAt( 1 ) == ':' ) )
                    {
                        retValue = retValue.charAt( 0 ) + ":" + retValue.substring( 2 );
                    }
                    else if ( index >= 0 )
                    {
                        // leading / was previously stripped
                        retValue = "/" + retValue;
                    }
                }
            }

            // special case: if there is a windows drive letter using |, switch to :
            if ( retValue.length() >= 2 && retValue.charAt( 1 ) == '|' )
            {
                retValue = retValue.charAt( 0 ) + ":" + retValue.substring( 2 );
            }

            // normalize separators
            retValue = new File( retValue ).getPath();
        }

        if ( retValue == null )
        {
            retValue = "/";
        }
        return retValue.trim();
    }
2010#/**
     * Decodes the specified (portion of a) URL. <strong>Note:</strong> This decoder assumes that ISO-8859-1 is used to
     * convert URL-encoded octets to characters.
     *
     * @param url The URL to decode, may be <code>null</code>.
     * @return The decoded URL or <code>null</code> if the input was <code>null</code>.
     */
    private static String decode( String url )
    {
        String decoded = url;
        if ( url != null )
        {
            int pos = -1;
            while ( ( pos = decoded.indexOf( '%', pos + 1 ) ) >= 0 )
            {
                if ( pos + 2 < decoded.length() )
                {
                    String hexStr = decoded.substring( pos + 1, pos + 3 );
                    char ch = (char) Integer.parseInt( hexStr, 16 );
                    decoded = decoded.substring( 0, pos ) + ch + decoded.substring( pos + 3 );
                }
            }
        }
        return decoded;
    }
2011#public int hashCode()
    {
        final int prime = 31;
        int result = 1;
        result = prime * result + ( ( getId() == null ) ? 0 : getId().hashCode() );
        return result;
    }
2012#public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( obj == null )
        {
            return false;
        }
        if ( getClass() != obj.getClass() )
        {
            return false;
        }

        ArtifactRepository other = (ArtifactRepository) obj;

        return eq( getId(), other.getId() );
    }
2013#protected static <T> boolean eq( T s1, T s2 )
    {
        return s1 != null ? s1.equals( s2 ) : s2 == null;
    }
2014#public Authentication getAuthentication()
    {
        return authentication;
    }
2015#public void setAuthentication( Authentication authentication )
    {
        this.authentication = authentication;
    }
2016#public Proxy getProxy()
    {
        return proxy;
    }
2017#public void setProxy( Proxy proxy )
    {
        this.proxy = proxy;
    }
2018#public boolean isBlacklisted()
    {
        return false;
    }
2019#public void setBlacklisted( boolean blackListed )
    {
        // no op
    }
2020#public boolean isUniqueVersion()
    {
        return true;
    }
2021#public boolean isProjectAware()
    {
        return false;
    }
2022#public List<ArtifactRepository> getMirroredRepositories()
    {
        return mirroredRepositories;
    }
2023#public void setMirroredRepositories( List<ArtifactRepository> mirroredRepositories )
    {
        if ( mirroredRepositories != null )
        {
            this.mirroredRepositories = mirroredRepositories;
        }
        else
        {
            this.mirroredRepositories = Collections.emptyList();
        }
    }
2024#/**
     * Puts the specified data into the cache. <strong>Warning:</strong> The cache will directly save the provided
     * reference. If the cached data is mutable, i.e. could be modified after being put into the cache, the caller is
     * responsible for creating a copy of the original data and store the copy in the cache.
     * 
     * @param request The repository request from which this cache was retrieved, must not be {@code null}.
     * @param key The key to use associate the data with, must not be {@code null}.
     * @param data The data to store in the cache, may be {@code null}.
     */
    void put( RepositoryRequest request, Object key, Object data );
2025#/**
     * Gets the specified data from the cache. <strong>Warning:</strong> The cache will directly return the saved
     * reference. If the cached data is to be modified after its retrieval, the caller is responsible to create a copy
     * of the returned data and use this instead of the cache record.
     * 
     * @param request The repository request from which this cache was retrieved, must not be {@code null}.
     * @param key The key to use for lookup of the data, must not be {@code null}.
     * @return The requested data or {@code null} if none was present in the cache.
     */
    Object get( RepositoryRequest request, Object key );
2026#/**
     * Indicates whether network access to remote repositories has been disabled.
     * 
     * @return {@code true} if remote access has been disabled, {@code false} otherwise.
     */
    boolean isOffline();
2027#/**
     * Enables/disables network access to remote repositories.
     * 
     * @param offline {@code true} to disable remote access, {@code false} to allow network access.
     * @return This request, never {@code null}.
     */
    RepositoryRequest setOffline( boolean offline );
2028#/**
     * Indicates whether remote repositories should be re-checked for updated artifacts/metadata regardless of their
     * configured update policy.
     * 
     * @return {@code true} if remote repositories should be re-checked for updated artifacts/metadata, {@code false}
     *         otherwise.
     */
    boolean isForceUpdate();
2029#/**
     * Enables/disabled forced checks for updated artifacts/metadata on remote repositories.
     * 
     * @param forceUpdate {@code true} to forcibly check the remote repositories for updated artifacts/metadata, {@code
     *            false} to use the update policy configured on each repository.
     * @return This request, never {@code null}.
     */
    RepositoryRequest setForceUpdate( boolean forceUpdate );
2030#/**
     * Gets the local repository to use.
     * 
     * @return The local repository to use or {@code null} if not set.
     */
    ArtifactRepository getLocalRepository();
2031#/**
     * Sets the local repository to use.
     * 
     * @param localRepository The local repository to use.
     * @return This request, never {@code null}.
     */
    RepositoryRequest setLocalRepository( ArtifactRepository localRepository );
2032#/**
     * Gets the remote repositories to use.
     * 
     * @return The remote repositories to use, never {@code null}.
     */
    List<ArtifactRepository> getRemoteRepositories();
2033#/**
     * Sets the remote repositories to use.
     * 
     * @param remoteRepositories The remote repositories to use.
     * @return This request, never {@code null}.
     */
    RepositoryRequest setRemoteRepositories( List<ArtifactRepository> remoteRepositories );
2034#public static RepositorySystemSession overlay( ArtifactRepository repository, RepositorySystemSession session,
                                                   RepositorySystem system )
    {
        if ( repository == null || repository.getBasedir() == null )
        {
            return session;
        }

        if ( session != null )
        {
            LocalRepositoryManager lrm = session.getLocalRepositoryManager();
            if ( lrm != null && lrm.getRepository().getBasedir().equals( new File( repository.getBasedir() ) ) )
            {
                return session;
            }
        }
        else
        {
            session = new DefaultRepositorySystemSession();
        }

        final LocalRepositoryManager llrm = new LegacyLocalRepositoryManager( repository );

        return new FilterRepositorySystemSession( session )
        {
            @Override
            public LocalRepositoryManager getLocalRepositoryManager()
            {
                return llrm;
            }
        };
    }
2035#private LegacyLocalRepositoryManager( ArtifactRepository delegate )
    {
        if ( delegate == null )
        {
            throw new IllegalArgumentException( "local repository delegate missing" );
        }
        this.delegate = delegate;

        ArtifactRepositoryLayout layout = delegate.getLayout();
        repo =
            new LocalRepository( new File( delegate.getBasedir() ),
                                 ( layout != null ) ? layout.getClass().getSimpleName() : "legacy" );

        /*
         * NOTE: "invoker:install" vs "appassembler:assemble": Both mojos use the artifact installer to put an artifact
         * into a repository. In the first case, the result needs to be a proper local repository that one can use for
         * local artifact resolution. In the second case, the result needs to precisely obey the path information of the
         * repository's layout to allow pointing at artifacts within the repository. Unfortunately,
         * DefaultRepositoryLayout does not correctly describe the layout of a local repository which unlike a remote
         * repository never uses timestamps in the filename of a snapshot artifact. The discrepancy gets notable when a
         * remotely resolved snapshot artifact gets passed into pathOf(). So producing a proper local artifact path
         * using DefaultRepositoryLayout requires us to enforce usage of the artifact's base version. This
         * transformation however contradicts the other use case of precisely obeying the repository's layout. The below
         * flag tries to detect which use case applies to make both plugins happy.
         */
        realLocalRepo = ( layout instanceof DefaultRepositoryLayout ) && "local".equals( delegate.getId() );
    }
2036#public LocalRepository getRepository()
    {
        return repo;
    }
2037#public String getPathForLocalArtifact( Artifact artifact )
    {
        if ( realLocalRepo )
        {
            return delegate.pathOf( RepositoryUtils.toArtifact( artifact.setVersion( artifact.getBaseVersion() ) ) );
        }
        return delegate.pathOf( RepositoryUtils.toArtifact( artifact ) );
    }
2038#public String getPathForRemoteArtifact( Artifact artifact, RemoteRepository repository, String context )
    {
        return delegate.pathOf( RepositoryUtils.toArtifact( artifact ) );
    }
2039#public String getPathForLocalMetadata( Metadata metadata )
    {
        return delegate.pathOfLocalRepositoryMetadata( new ArtifactMetadataAdapter( metadata ), delegate );
    }
2040#public String getPathForRemoteMetadata( Metadata metadata, RemoteRepository repository, String context )
    {
        return delegate.pathOfLocalRepositoryMetadata( new ArtifactMetadataAdapter( metadata ),
                                                       new ArtifactRepositoryAdapter( repository ) );
    }
2041#public LocalArtifactResult find( RepositorySystemSession session, LocalArtifactRequest request )
    {
        String path = getPathForLocalArtifact( request.getArtifact() );
        File file = new File( getRepository().getBasedir(), path );

        LocalArtifactResult result = new LocalArtifactResult( request );
        if ( file.isFile() )
        {
            result.setFile( file );
            result.setAvailable( true );
        }

        return result;
    }
2042#public LocalMetadataResult find( RepositorySystemSession session, LocalMetadataRequest request )
    {
        Metadata metadata = request.getMetadata();

        String path;
        if ( request.getRepository() == null )
        {
            path = getPathForLocalMetadata( metadata );
        }
        else
        {
            path = getPathForRemoteMetadata( metadata, request.getRepository(), request.getContext() );
        }

        File file = new File( getRepository().getBasedir(), path );

        LocalMetadataResult result = new LocalMetadataResult( request );
        if ( file.isFile() )
        {
            result.setFile( file );
        }

        return result;
    }
2043#public void add( RepositorySystemSession session, LocalArtifactRegistration request )
    {
        // noop
    }
2044#public void add( RepositorySystemSession session, LocalMetadataRegistration request )
    {
        // noop
    }
2045#public ArtifactMetadataAdapter( Metadata metadata )
        {
            this.metadata = metadata;
        }
2046#public boolean storedInArtifactVersionDirectory()
        {
            return metadata.getVersion().length() > 0;
        }
2047#public boolean storedInGroupDirectory()
        {
            return metadata.getArtifactId().length() <= 0;
        }
2048#public String getGroupId()
        {
            return nullify( metadata.getGroupId() );
        }
2049#public String getArtifactId()
        {
            return nullify( metadata.getArtifactId() );
        }
2050#public String getBaseVersion()
        {
            return nullify( metadata.getVersion() );
        }
2051#private String nullify( String str )
        {
            return ( str == null || str.length() <= 0 ) ? null : str;
        }
2052#public Object getKey()
        {
            return metadata.toString();
        }
2053#public String getRemoteFilename()
        {
            return metadata.getType();
        }
2054#public String getLocalFilename( ArtifactRepository repository )
        {
            return insertRepositoryKey( getRemoteFilename(), repository.getKey() );
        }
2055#private String insertRepositoryKey( String filename, String repositoryKey )
        {
            String result;
            int idx = filename.indexOf( '.' );
            if ( idx < 0 )
            {
                result = filename + '-' + repositoryKey;
            }
            else
            {
                result = filename.substring( 0, idx ) + '-' + repositoryKey + filename.substring( idx );
            }
            return result;
        }
2056#public void merge( org.apache.maven.repository.legacy.metadata.ArtifactMetadata metadata )
        {
            // not used
        }
2057#public void merge( ArtifactMetadata metadata )
        {
            // not used
        }
2058#public void storeInLocalRepository( ArtifactRepository localRepository, ArtifactRepository remoteRepository )
            throws RepositoryMetadataStoreException
        {
            // not used
        }
2059#public String extendedToString()
        {
            return metadata.toString();
        }
2060#public ArtifactRepositoryAdapter( RemoteRepository repository )
        {
            this.repository = repository;
        }
2061#public String pathOf( org.apache.maven.artifact.Artifact artifact )
        {
            return null;
        }
2062#public String pathOfRemoteRepositoryMetadata( ArtifactMetadata artifactMetadata )
        {
            return null;
        }
2063#public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository )
        {
            return null;
        }
2064#public String getUrl()
        {
            return repository.getUrl();
        }
2065#public void setUrl( String url )
        {
        }
2066#public String getBasedir()
        {
            return null;
        }
2067#public String getProtocol()
        {
            return repository.getProtocol();
        }
2068#public String getId()
        {
            return repository.getId();
        }
2069#public void setId( String id )
        {
        }
2070#public ArtifactRepositoryPolicy getSnapshots()
        {
            return null;
        }
2071#public void setSnapshotUpdatePolicy( ArtifactRepositoryPolicy policy )
        {
        }
2072#public ArtifactRepositoryPolicy getReleases()
        {
            return null;
        }
2073#public void setReleaseUpdatePolicy( ArtifactRepositoryPolicy policy )
        {
        }
2074#public ArtifactRepositoryLayout getLayout()
        {
            return null;
        }
2075#public void setLayout( ArtifactRepositoryLayout layout )
        {
        }
2076#public String getKey()
        {
            return getId();
        }
2077#public boolean isUniqueVersion()
        {
            return true;
        }
2078#public boolean isBlacklisted()
        {
            return false;
        }
2079#public void setBlacklisted( boolean blackListed )
        {
        }
2080#public org.apache.maven.artifact.Artifact find( org.apache.maven.artifact.Artifact artifact )
        {
            return null;
        }
2081#public List<String> findVersions( org.apache.maven.artifact.Artifact artifact )
        {
            return Collections.emptyList();
        }
2082#public boolean isProjectAware()
        {
            return false;
        }
2083#public void setAuthentication( Authentication authentication )
        {
        }
2084#public Authentication getAuthentication()
        {
            return null;
        }
2085#public void setProxy( Proxy proxy )
        {
        }
2086#public Proxy getProxy()
        {
            return null;
        }
2087#public List<ArtifactRepository> getMirroredRepositories()
        {
            return Collections.emptyList();
        }
2088#public void setMirroredRepositories( List<ArtifactRepository> mirroredRepositories )
        {
        }
2089#public String getId()
    {
        return "default";
    }
2090#public String pathOf( Artifact artifact )
    {
        ArtifactHandler artifactHandler = artifact.getArtifactHandler();

        StringBuilder path = new StringBuilder( 128 );

        path.append( formatAsDirectory( artifact.getGroupId() ) ).append( PATH_SEPARATOR );
        path.append( artifact.getArtifactId() ).append( PATH_SEPARATOR );
        path.append( artifact.getBaseVersion() ).append( PATH_SEPARATOR );
        path.append( artifact.getArtifactId() ).append( ARTIFACT_SEPARATOR ).append( artifact.getVersion() );

        if ( artifact.hasClassifier() )
        {
            path.append( ARTIFACT_SEPARATOR ).append( artifact.getClassifier() );
        }

        if ( artifactHandler.getExtension() != null && artifactHandler.getExtension().length() > 0 )
        {
            path.append( GROUP_SEPARATOR ).append( artifactHandler.getExtension() );
        }

        return path.toString();
    }
2091#public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository )
    {
        return pathOfRepositoryMetadata( metadata, metadata.getLocalFilename( repository ) );
    }
2092#private String pathOfRepositoryMetadata( ArtifactMetadata metadata,
                                             String filename )
    {
        StringBuilder path = new StringBuilder( 128 );

        path.append( formatAsDirectory( metadata.getGroupId() ) ).append( PATH_SEPARATOR );
        if ( !metadata.storedInGroupDirectory() )
        {
            path.append( metadata.getArtifactId() ).append( PATH_SEPARATOR );

            if ( metadata.storedInArtifactVersionDirectory() )
            {
                path.append( metadata.getBaseVersion() ).append( PATH_SEPARATOR );
            }
        }

        path.append( filename );

        return path.toString();
    }
2093#public String pathOfRemoteRepositoryMetadata( ArtifactMetadata metadata )
    {
        return pathOfRepositoryMetadata( metadata, metadata.getRemoteFilename() );
    }
2094#private String formatAsDirectory( String directory )
    {
        return directory.replace( GROUP_SEPARATOR, PATH_SEPARATOR );
    }
2095#@Override
    public String toString()
    {
        return getId();
    }
2096#public RepositoryMetadataResolutionException( String message )
    {
        super( message );
    }
2097#public RepositoryMetadataResolutionException( String message,
                                                  Exception e )
    {
        super( message, e );
    }
2098#void resolve( RepositoryMetadata repositoryMetadata, RepositoryRequest repositoryRequest )
        throws RepositoryMetadataResolutionException;
2099#void resolve( RepositoryMetadata repositoryMetadata, List<ArtifactRepository> repositories,
                  ArtifactRepository localRepository )
        throws RepositoryMetadataResolutionException;
2100#void resolveAlways( RepositoryMetadata metadata, ArtifactRepository localRepository,
                        ArtifactRepository remoteRepository )
        throws RepositoryMetadataResolutionException;
2101#/**
     * Deploy metadata to the remote repository.
     *
     * @param metadata             the metadata to deploy
     * @param localRepository      the local repository to install to first
     * @param deploymentRepository the remote repository to deploy to
     */
    void deploy( ArtifactMetadata metadata, ArtifactRepository localRepository,
                 ArtifactRepository deploymentRepository )
        throws RepositoryMetadataDeploymentException;
2102#/**
     * Install the metadata in the local repository.
     *
     * @param metadata        the metadata
     * @param localRepository the local repository
     */
    void install( ArtifactMetadata metadata, ArtifactRepository localRepository )
        throws RepositoryMetadataInstallationException;
2103#public RepositoryMetadataDeploymentException( String message )
    {
        super( message );
    }
2104#public RepositoryMetadataDeploymentException( String message,
                                                  Exception e )
    {
        super( message, e );
    }
2105#public RepositoryMetadataInstallationException( String message )
    {
        super( message );
    }
2106#public RepositoryMetadataInstallationException( String message,
                                                    Exception e )
    {
        super( message, e );
    }
2107#public ArtifactRepositoryMetadata( Artifact artifact )
    {
        this( artifact, null );
    }
2108#public ArtifactRepositoryMetadata( Artifact artifact,
                                       Versioning versioning )
    {
        super( createMetadata( artifact, versioning ) );
        this.artifact = artifact;
    }
2109#public boolean storedInGroupDirectory()
    {
        return false;
    }
2110#public boolean storedInArtifactVersionDirectory()
    {
        return false;
    }
2111#public String getGroupId()
    {
        return artifact.getGroupId();
    }
2112#public String getArtifactId()
    {
        return artifact.getArtifactId();
    }
2113#public String getBaseVersion()
    {
        // Don't want the artifact's version in here, as this is stored in the directory above that
        return null;
    }
2114#public Object getKey()
    {
        return "artifact " + artifact.getGroupId() + ":" + artifact.getArtifactId();
    }
2115#public boolean isSnapshot()
    {
        // Don't consider the artifact's version in here, as this is stored in the directory above that
        return false;
    }
2116#public int getNature()
    {
        if ( artifact.getVersion() != null )
        {
            return artifact.isSnapshot() ? SNAPSHOT : RELEASE;
        }

        VersionRange range = artifact.getVersionRange();
        if ( range != null )
        {
            for ( Restriction restriction : range.getRestrictions() )
            {
                if ( isSnapshot( restriction.getLowerBound() ) || isSnapshot( restriction.getUpperBound() ) )
                {
                    return RELEASE_OR_SNAPSHOT;
                }
            }
        }

        return RELEASE;
    }
2117#private boolean isSnapshot( ArtifactVersion version )
    {
        return version != null && ArtifactUtils.isSnapshot( version.getQualifier() );
    }
2118#public ArtifactRepository getRepository()
    {
        return null;
    }
2119#public void setRepository( ArtifactRepository remoteRepository )
    {
        /*
         * NOTE: Metadata at the g:a level contains a collection of available versions. After merging, we can't tell
         * which repository provides which version so the metadata manager must not restrict the artifact resolution to
         * the repository with the most recent updates.
         */
    }
2120#protected AbstractRepositoryMetadata( Metadata metadata )
    {
        this.metadata = metadata;
    }
2121#public String getRemoteFilename()
    {
        return "maven-metadata.xml";
    }
2122#public String getLocalFilename( ArtifactRepository repository )
    {        
        return "maven-metadata-" + repository.getKey() + ".xml";
    }
2123#public void storeInLocalRepository( ArtifactRepository localRepository,
                                        ArtifactRepository remoteRepository )
        throws RepositoryMetadataStoreException
    {
        try
        {
            updateRepositoryMetadata( localRepository, remoteRepository );
        }
        catch ( IOException e )
        {
            throw new RepositoryMetadataStoreException( "Error updating group repository metadata", e );
        }
        catch ( XmlPullParserException e )
        {
            throw new RepositoryMetadataStoreException( "Error updating group repository metadata", e );
        }
    }
2124#protected void updateRepositoryMetadata( ArtifactRepository localRepository,
                                             ArtifactRepository remoteRepository )
        throws IOException, XmlPullParserException
    {
        MetadataXpp3Reader mappingReader = new MetadataXpp3Reader();

        Metadata metadata = null;

        File metadataFile = new File( localRepository.getBasedir(),
            localRepository.pathOfLocalRepositoryMetadata( this, remoteRepository ) );

        if ( metadataFile.length() == 0 )
        {
            metadataFile.delete();
        }
        else if ( metadataFile.exists() )
        {
            Reader reader = null;

            try
            {
                reader = ReaderFactory.newXmlReader( metadataFile );

                metadata = mappingReader.read( reader, false );
            }
            finally
            {
                IOUtil.close( reader );
            }
        }

        boolean changed;

        // If file could not be found or was not valid, start from scratch
        if ( metadata == null )
        {
            metadata = this.metadata;

            changed = true;
        }
        else
        {
            changed = metadata.merge( this.metadata );
        }

        // beware meta-versions!
        String version = metadata.getVersion();
        if ( version != null && ( Artifact.LATEST_VERSION.equals( version ) || Artifact.RELEASE_VERSION.equals(
            version ) ) )
        {
            // meta-versions are not valid <version/> values...don't write them.
            metadata.setVersion( null );
        }

        if ( changed || !metadataFile.exists() )
        {
            Writer writer = null;
            try
            {
                metadataFile.getParentFile().mkdirs();
                writer = WriterFactory.newXmlWriter( metadataFile );

                MetadataXpp3Writer mappingWriter = new MetadataXpp3Writer();

                mappingWriter.write( writer, metadata );
            }
            finally
            {
                IOUtil.close( writer );
            }
        }
        else
        {
            metadataFile.setLastModified( System.currentTimeMillis() );
        }
    }
2125#public String toString()
    {
        return "repository metadata for: \'" + getKey() + "\'";
    }
2126#protected static Metadata createMetadata( Artifact artifact,
                                              Versioning versioning )
    {
        Metadata metadata = new Metadata();
        metadata.setGroupId( artifact.getGroupId() );
        metadata.setArtifactId( artifact.getArtifactId() );
        metadata.setVersion( artifact.getVersion() );
        metadata.setVersioning( versioning );
        return metadata;
    }
2127#protected static Versioning createVersioning( Snapshot snapshot )
    {
        Versioning versioning = new Versioning();
        versioning.setSnapshot( snapshot );
        versioning.updateTimestamp();
        return versioning;
    }
2128#public void setMetadata( Metadata metadata )
    {
        this.metadata = metadata;
    }
2129#public Metadata getMetadata()
    {
        return metadata;
    }
2130#public void merge( org.apache.maven.repository.legacy.metadata.ArtifactMetadata metadata )
    {
        // TODO: not sure that it should assume this, maybe the calls to addMetadata should pre-merge, then artifact replaces?
        AbstractRepositoryMetadata repoMetadata = (AbstractRepositoryMetadata) metadata;
        this.metadata.merge( repoMetadata.getMetadata() );
    }
2131#public void merge( ArtifactMetadata metadata )
    {
        // TODO: not sure that it should assume this, maybe the calls to addMetadata should pre-merge, then artifact replaces?
        AbstractRepositoryMetadata repoMetadata = (AbstractRepositoryMetadata) metadata;
        this.metadata.merge( repoMetadata.getMetadata() );
    }
2132#public String extendedToString()
    {
        StringBuilder buffer = new StringBuilder();

        buffer.append( "\nRepository Metadata\n--------------------------" );
        buffer.append( "\nGroupId: " ).append( getGroupId() );
        buffer.append( "\nArtifactId: " ).append( getArtifactId() );
        buffer.append( "\nMetadata Type: " ).append( getClass().getName() );

        return buffer.toString();
    }
2133#public int getNature()
    {
        return RELEASE;
    }
2134#public ArtifactRepositoryPolicy getPolicy( ArtifactRepository repository )
    {
        int nature = getNature();
        if ( ( nature & RepositoryMetadata.RELEASE_OR_SNAPSHOT ) == RepositoryMetadata.RELEASE_OR_SNAPSHOT )
        {
            ArtifactRepositoryPolicy policy = new ArtifactRepositoryPolicy( repository.getReleases() );
            policy.merge( repository.getSnapshots() );
            return policy;
        }
        else if ( ( nature & RepositoryMetadata.SNAPSHOT ) != 0 )
        {
            return repository.getSnapshots();
        }
        else
        {
            return repository.getReleases();
        }
    }
2135#/**
     * Get the repository the metadata was located in.
     *
     * @return the repository
     */
    ArtifactRepository getRepository();
2136#/**
     * Set the repository the metadata was located in.
     *
     * @param remoteRepository the repository
     */
    void setRepository( ArtifactRepository remoteRepository );
2137#/**
     * Get the repository metadata associated with this marker.
     *
     * @return the metadata, or <code>null</code> if none loaded
     */
    Metadata getMetadata();
2138#/**
     * Set the metadata contents.
     *
     * @param metadata the metadata
     */
    void setMetadata( Metadata metadata );
2139#/**
     * Whether this represents a snapshot.
     *
     * @return if it is a snapshot
     */
    boolean isSnapshot();
2140#/**
     * Gets the artifact quality this metadata refers to. One of {@link #RELEASE}, {@link #SNAPSHOT} or
     * {@link #RELEASE_OR_SNAPSHOT}.
     *
     * @return The artifact quality this metadata refers to.
     */
    int getNature();
2141#/**
     * Gets the policy that applies to this metadata regarding the specified repository.
     *
     * @param repository The repository for which to determine the policy, must not be {@code null}.
     * @return The policy, never {@code null}.
     */
    ArtifactRepositoryPolicy getPolicy( ArtifactRepository repository );
2142#/**
     * Reads the metadata from the specified file.
     *
     * @param input The file to deserialize the metadata from, must not be {@code null}.
     * @param options The options to use for deserialization, may be {@code null} to use the default values.
     * @return The deserialized metadata, never {@code null}.
     * @throws IOException If the metadata could not be deserialized.
     * @throws MetadataParseException If the input format could not be parsed.
     */
    Metadata read( File input, Map<String, ?> options )
        throws IOException, MetadataParseException;
2143#/**
     * Reads the metadata from the specified character reader. The reader will be automatically closed before the method
     * returns.
     *
     * @param input The reader to deserialize the metadata from, must not be {@code null}.
     * @param options The options to use for deserialization, may be {@code null} to use the default values.
     * @return The deserialized metadata, never {@code null}.
     * @throws IOException If the metadata could not be deserialized.
     * @throws MetadataParseException If the input format could not be parsed.
     */
    Metadata read( Reader input, Map<String, ?> options )
        throws IOException, MetadataParseException;
2144#/**
     * Reads the metadata from the specified byte stream. The stream will be automatically closed before the method
     * returns.
     *
     * @param input The stream to deserialize the metadata from, must not be {@code null}.
     * @param options The options to use for deserialization, may be {@code null} to use the default values.
     * @return The deserialized metadata, never {@code null}.
     * @throws IOException If the metadata could not be deserialized.
     * @throws MetadataParseException If the input format could not be parsed.
     */
    Metadata read( InputStream input, Map<String, ?> options )
        throws IOException, MetadataParseException;
2145#public Metadata read( File input, Map<String, ?> options )
        throws IOException
    {
        if ( input == null )
        {
            throw new IllegalArgumentException( "input file missing" );
        }

        Metadata metadata = read( ReaderFactory.newXmlReader( input ), options );

        return metadata;
    }
2146#public Metadata read( Reader input, Map<String, ?> options )
        throws IOException
    {
        if ( input == null )
        {
            throw new IllegalArgumentException( "input reader missing" );
        }

        try
        {
            MetadataXpp3Reader r = new MetadataXpp3Reader();
            return r.read( input, isStrict( options ) );
        }
        catch ( XmlPullParserException e )
        {
            throw new MetadataParseException( e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e );
        }
        finally
        {
            IOUtil.close( input );
        }
    }
2147#public Metadata read( InputStream input, Map<String, ?> options )
        throws IOException
    {
        if ( input == null )
        {
            throw new IllegalArgumentException( "input stream missing" );
        }

        try
        {
            MetadataXpp3Reader r = new MetadataXpp3Reader();
            return r.read( input, isStrict( options ) );
        }
        catch ( XmlPullParserException e )
        {
            throw new MetadataParseException( e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e );
        }
        finally
        {
            IOUtil.close( input );
        }
    }
2148#private boolean isStrict( Map<String, ?> options )
    {
        Object value = ( options != null ) ? options.get( IS_STRICT ) : null;
        return value == null || Boolean.parseBoolean( value.toString() );
    }
2149#/**
     * Creates a new parser exception with the specified details.
     * 
     * @param message The error message, may be {@code null}.
     * @param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.
     * @param columnNumber The one-based index of the column containing the error or {@code -1} if unknown.
     */
    public MetadataParseException( String message, int lineNumber, int columnNumber )
    {
        super( message );
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }
2150#/**
     * Creates a new parser exception with the specified details.
     * 
     * @param message The error message, may be {@code null}.
     * @param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.
     * @param columnNumber The one-based index of the column containing the error or {@code -1} if unknown.
     * @param cause The nested cause of this error, may be {@code null}.
     */
    public MetadataParseException( String message, int lineNumber, int columnNumber, Throwable cause )
    {
        super( message );
        initCause( cause );
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }
2151#/**
     * Gets the one-based index of the line containing the error.
     * 
     * @return The one-based index of the line containing the error or a non-positive value if unknown.
     */
    public int getLineNumber()
    {
        return lineNumber;
    }
2152#/**
     * Gets the one-based index of the column containing the error.
     * 
     * @return The one-based index of the column containing the error or non-positive value if unknown.
     */
    public int getColumnNumber()
    {
        return columnNumber;
    }
2153#public ResolutionNode( Artifact artifact, List<ArtifactRepository> remoteRepositories )
    {
        this.artifact = artifact;
        this.remoteRepositories = remoteRepositories;
        depth = 0;
        parents = Collections.emptyList();
        parent = null;
    }
2154#public ResolutionNode( Artifact artifact, List<ArtifactRepository> remoteRepositories, ResolutionNode parent )
    {
        this.artifact = artifact;
        this.remoteRepositories = remoteRepositories;
        depth = parent.depth + 1;
        parents = new ArrayList<Object>();
        parents.addAll( parent.parents );
        parents.add( parent.getKey() );
        this.parent = parent;
    }
2155#public Artifact getArtifact()
    {
        return artifact;
    }
2156#public Object getKey()
    {
        return artifact.getDependencyConflictId();
    }
2157#public void addDependencies( Set<Artifact> artifacts, List<ArtifactRepository> remoteRepositories,
                                 ArtifactFilter filter )
        throws CyclicDependencyException, OverConstrainedVersionException
    {
        if ( artifacts != null && !artifacts.isEmpty() )
        {
            children = new ArrayList<ResolutionNode>( artifacts.size() );

            for ( Artifact a : artifacts )
            {
                if ( parents.contains( a.getDependencyConflictId() ) )
                {
                    a.setDependencyTrail( getDependencyTrail() );

                    throw new CyclicDependencyException( "A dependency has introduced a cycle", a );
                }

                children.add( new ResolutionNode( a, remoteRepositories, this ) );
            }
        }
        else
        {
            children = Collections.emptyList();
        }
        trail = null;
    }
2158#/**
     * @return {@link List} &lt; {@link String} > with artifact ids
     * @throws OverConstrainedVersionException
     */
    public List<String> getDependencyTrail()
        throws OverConstrainedVersionException
    {
        List<Artifact> trial = getTrail();

        List<String> ret = new ArrayList<String>( trial.size() );

        for ( Artifact artifact : trial )
        {
            ret.add( artifact.getId() );
        }

        return ret;
    }
2159#private List<Artifact> getTrail()
        throws OverConstrainedVersionException
    {
        if ( trail == null )
        {
            List<Artifact> ids = new LinkedList<Artifact>();
            ResolutionNode node = this;
            while ( node != null )
            {
                Artifact artifact = node.getArtifact();
                if ( artifact.getVersion() == null )
                {
                    // set the recommended version
                    ArtifactVersion selected = artifact.getSelectedVersion();
                    // MNG-2123: null is a valid response to getSelectedVersion, don't
                    // assume it won't ever be.
                    if ( selected != null )
                    {
                        artifact.selectVersion( selected.toString() );
                    }
                    else
                    {
                        throw new OverConstrainedVersionException( "Unable to get a selected Version for "
                            + artifact.getArtifactId(), artifact );
                    }
                }

                ids.add( 0, artifact );
                node = node.parent;
            }
            trail = ids;
        }
        return trail;
    }
2160#public boolean isResolved()
    {
        return children != null;
    }
2161#/**
     * Test whether the node is direct or transitive dependency.
     */
    public boolean isChildOfRootNode()
    {
        return parent != null && parent.parent == null;
    }
2162#public Iterator<ResolutionNode> getChildrenIterator()
    {
        return children.iterator();
    }
2163#public int getDepth()
    {
        return depth;
    }
2164#public List<ArtifactRepository> getRemoteRepositories()
    {
        return remoteRepositories;
    }
2165#public boolean isActive()
    {
        return active;
    }
2166#public void enable()
    {
        active = true;

        // TODO: if it was null, we really need to go find them now... or is this taken care of by the ordering?
        if ( children != null )
        {
            for ( ResolutionNode node : children )
            {
                node.enable();
            }
        }
    }
2167#public void disable()
    {
        active = false;
        if ( children != null )
        {
            for ( ResolutionNode node : children )
            {
                node.disable();
            }
        }
    }
2168#public boolean filterTrail( ArtifactFilter filter )
        throws OverConstrainedVersionException
    {
        boolean success = true;
        if ( filter != null )
        {
            for ( Artifact artifact : getTrail() )
            {
                if ( !filter.include( artifact ) )
                {
                    success = false;
                }
            }
        }
        return success;
    }
2169#@Override
    public String toString()
    {
        return artifact.toString() + " (" + depth + "; " + ( active ? "enabled" : "disabled" ) + ")";
    }
2170#public void setArtifact( Artifact artifact )
    {
        this.artifact = artifact;
    }
2171#void testArtifact( Artifact node );
2172#void startProcessChildren( Artifact artifact );
2173#void endProcessChildren( Artifact artifact );
2174#void includeArtifact( Artifact artifact );
2175#void omitForNearer( Artifact omitted,
                        Artifact kept );
2176#void updateScope( Artifact artifact,
                      String scope );
2177#@Deprecated
    void manageArtifact( Artifact artifact,
                         Artifact replacement );
2178#// TODO Use the following two instead of manageArtifact
    // TODO Remove ResolutionListenerDM interface

    //void manageArtifactVersion( Artifact artifact, Artifact replacement );

    //void manageArtifactScope( Artifact artifact, Artifact replacement );

    void omitForCycle( Artifact artifact );
2179#/**
     * This event means that the artifactScope has NOT been updated to a farther node artifactScope because current
     * node is in the first level pom
     *
     * @param artifact     current node artifact, the one in the first level pom
     * @param ignoredScope artifactScope that was ignored because artifact was in first level pom
     */
    void updateScopeCurrentPom( Artifact artifact,
                                String ignoredScope );
2180#void selectVersionFromRange( Artifact artifact );
2181#void restrictRange( Artifact artifact,
                        Artifact replacement,
                        VersionRange newRange );
2182#void throwErrors( ArtifactResolutionRequest request, ArtifactResolutionResult result )
        throws ArtifactResolutionException;
2183#public Artifact getOriginatingArtifact()
    {
        return originatingArtifact;
    }
2184#public ArtifactResolutionResult setOriginatingArtifact( final Artifact originatingArtifact )
    {
        this.originatingArtifact = originatingArtifact;

        return this;
    }
2185#public void addArtifact( Artifact artifact )
    {
        if ( artifacts == null )
        {
            artifacts = new LinkedHashSet<Artifact>();
        }

        artifacts.add( artifact );
    }
2186#public Set<Artifact> getArtifacts()
    {
        if ( artifacts == null )
        {
            artifacts = new LinkedHashSet<Artifact>();
        }

        return artifacts;
    }
2187#public void setArtifacts( Set<Artifact> artifacts )
    {
        this.artifacts = artifacts;
    }
2188#public Set<ResolutionNode> getArtifactResolutionNodes()
    {
        if ( resolutionNodes == null )
        {
            resolutionNodes = new LinkedHashSet<ResolutionNode>();
        }

        return resolutionNodes;
    }
2189#public void setArtifactResolutionNodes( Set<ResolutionNode> resolutionNodes )
    {
        this.resolutionNodes = resolutionNodes;
    }
2190#public boolean hasMissingArtifacts()
    {
        return missingArtifacts != null && !missingArtifacts.isEmpty();
    }
2191#public List<Artifact> getMissingArtifacts()
    {
        return missingArtifacts == null ? Collections.<Artifact> emptyList() : missingArtifacts;
    }
2192#public ArtifactResolutionResult addMissingArtifact( Artifact artifact )
    {
        missingArtifacts = initList( missingArtifacts );

        missingArtifacts.add( artifact );

        return this;
    }
2193#public ArtifactResolutionResult setUnresolvedArtifacts( final List<Artifact> unresolvedArtifacts )
    {
        this.missingArtifacts = unresolvedArtifacts;

        return this;
    }
2194#public boolean isSuccess()
    {
        return !( hasMissingArtifacts() || hasExceptions() );
    }
2195#// ------------------------------------------------------------------------
    // Exceptions
    // ------------------------------------------------------------------------

    public boolean hasExceptions()
    {
        return exceptions != null && !exceptions.isEmpty();
    }
2196#public List<Exception> getExceptions()
    {
        return exceptions == null ? Collections.<Exception> emptyList() : exceptions;
    }
2197#// ------------------------------------------------------------------------
    // Version Range Violations
    // ------------------------------------------------------------------------

    public boolean hasVersionRangeViolations()
    {
        return versionRangeViolations != null;
    }
2198#/**
     * @TODO this needs to accept a {@link OverConstrainedVersionException} as returned by
     *       {@link #getVersionRangeViolation(int)} but it's not used like that in
     *       {@link DefaultLegacyArtifactCollector}
     */
    public ArtifactResolutionResult addVersionRangeViolation( Exception e )
    {
        versionRangeViolations = initList( versionRangeViolations );

        versionRangeViolations.add( e );

        exceptions = initList( exceptions );

        exceptions.add( e );

        return this;
    }
2199#public OverConstrainedVersionException getVersionRangeViolation( int i )
    {
        return (OverConstrainedVersionException) versionRangeViolations.get( i );
    }
2200#public List<Exception> getVersionRangeViolations()
    {
        return versionRangeViolations == null ? Collections.<Exception> emptyList() : versionRangeViolations;
    }
2201#// ------------------------------------------------------------------------
    // Metadata Resolution Exceptions: ArtifactResolutionExceptions
    // ------------------------------------------------------------------------

    public boolean hasMetadataResolutionExceptions()
    {
        return metadataResolutionExceptions != null;
    }
2202#public ArtifactResolutionResult addMetadataResolutionException( ArtifactResolutionException e )
    {
        metadataResolutionExceptions = initList( metadataResolutionExceptions );

        metadataResolutionExceptions.add( e );

        exceptions = initList( exceptions );

        exceptions.add( e );

        return this;
    }
2203#public ArtifactResolutionException getMetadataResolutionException( int i )
    {
        return metadataResolutionExceptions.get( i );
    }
2204#public List<ArtifactResolutionException> getMetadataResolutionExceptions()
    {
        return metadataResolutionExceptions == null ? Collections.<ArtifactResolutionException> emptyList()
                        : metadataResolutionExceptions;
    }
2205#// ------------------------------------------------------------------------
    // ErrorArtifactExceptions: ArtifactResolutionExceptions
    // ------------------------------------------------------------------------

    public boolean hasErrorArtifactExceptions()
    {
        return errorArtifactExceptions != null;
    }
2206#public ArtifactResolutionResult addErrorArtifactException( ArtifactResolutionException e )
    {
        errorArtifactExceptions = initList( errorArtifactExceptions );

        errorArtifactExceptions.add( e );

        exceptions = initList( exceptions );

        exceptions.add( e );

        return this;
    }
2207#public List<ArtifactResolutionException> getErrorArtifactExceptions()
    {
        if ( errorArtifactExceptions == null )
        {
            return Collections.emptyList();
        }

        return errorArtifactExceptions;
    }
2208#// ------------------------------------------------------------------------
    // Circular Dependency Exceptions
    // ------------------------------------------------------------------------

    public boolean hasCircularDependencyExceptions()
    {
        return circularDependencyExceptions != null;
    }
2209#public ArtifactResolutionResult addCircularDependencyException( CyclicDependencyException e )
    {
        circularDependencyExceptions = initList( circularDependencyExceptions );

        circularDependencyExceptions.add( e );

        exceptions = initList( exceptions );

        exceptions.add( e );

        return this;
    }
2210#public CyclicDependencyException getCircularDependencyException( int i )
    {
        return circularDependencyExceptions.get( i );
    }
2211#public List<CyclicDependencyException> getCircularDependencyExceptions()
    {
        if ( circularDependencyExceptions == null )
        {
            return Collections.emptyList();
        }

        return circularDependencyExceptions;
    }
2212#// ------------------------------------------------------------------------
    // Repositories
    // ------------------------------------------------------------------------

    public List<ArtifactRepository> getRepositories()
    {
        if ( repositories == null )
        {
            return Collections.emptyList();
        }

        return repositories;
    }
2213#public ArtifactResolutionResult setRepositories( final List<ArtifactRepository> repositories )
    {
        this.repositories = repositories;

        return this;
    }
2214#//
    // Internal
    //

    private <T> List<T> initList( final List<T> l )
    {
        if ( l == null )
        {
            return new ArrayList<T>();
        }
        return l;
    }
2215#public String toString()
    {
        StringBuilder sb = new StringBuilder();

        if ( artifacts != null )
        {
            int i = 1;
            sb.append( "---------" ).append( "\n" );
            sb.append( artifacts.size() ).append( "\n" );
            for ( Artifact a : artifacts )
            {
                sb.append( i ).append( " " ).append( a ).append( "\n" );
                i++;
            }
            sb.append( "---------" ).append( "\n" );
        }

        return sb.toString();
    }
2216#public ArtifactResolutionRequest()
    {
        // nothing here
    }
2217#public ArtifactResolutionRequest( RepositoryRequest request )
    {
        setLocalRepository( request.getLocalRepository() );
        setRemoteRepositories( request.getRemoteRepositories() );
        setOffline( request.isOffline() );
        setForceUpdate( request.isForceUpdate() );
    }
2218#public Artifact getArtifact()
    {
        return artifact;
    }
2219#public ArtifactResolutionRequest setArtifact( Artifact artifact )
    {
        this.artifact = artifact;

        return this;
    }
2220#public ArtifactResolutionRequest setArtifactDependencies( Set<Artifact> artifactDependencies )
    {
        this.artifactDependencies = artifactDependencies;

        return this;
    }
2221#public Set<Artifact> getArtifactDependencies()
    {
        return artifactDependencies;
    }
2222#public ArtifactRepository getLocalRepository()
    {
        return localRepository;
    }
2223#public ArtifactResolutionRequest setLocalRepository( ArtifactRepository localRepository )
    {
        this.localRepository = localRepository;

        return this;
    }
2224#public List<ArtifactRepository> getRemoteRepositories()
    {
        return remoteRepositories;
    }
2225#public ArtifactResolutionRequest setRemoteRepositories( List<ArtifactRepository> remoteRepositories )
    {
        this.remoteRepositories = remoteRepositories;

        return this;
    }
2226#/**
     * Gets the artifact filter that controls traversal of the dependency graph.
     * 
     * @return The filter used to determine which of the artifacts in the dependency graph should be traversed or
     *         {@code null} to collect all transitive dependencies.
     */
    public ArtifactFilter getCollectionFilter()
    {
        return collectionFilter;
    }
2227#public ArtifactResolutionRequest setCollectionFilter( ArtifactFilter filter )
    {
        this.collectionFilter = filter;

        return this;
    }
2228#/**
     * Gets the artifact filter that controls downloading of artifact files. This filter operates on those artifacts
     * that have been included by the {@link #getCollectionFilter()}.
     * 
     * @return The filter used to determine which of the artifacts should have their files resolved or {@code null} to
     *         resolve the files for all collected artifacts.
     */
    public ArtifactFilter getResolutionFilter()
    {
        return resolutionFilter;
    }
2229#public ArtifactResolutionRequest setResolutionFilter( ArtifactFilter filter )
    {
        this.resolutionFilter = filter;

        return this;
    }
2230#public List<ResolutionListener> getListeners()
    {
        return listeners;
    }
2231#public ArtifactResolutionRequest setListeners( List<ResolutionListener> listeners )
    {        
        this.listeners = listeners;
        
        return this;
    }
2232#public ArtifactResolutionRequest addListener( ResolutionListener listener )
    {
        listeners.add( listener );

        return this;
    }
2233#public Map getManagedVersionMap()
    {
        return managedVersionMap;
    }
2234#public ArtifactResolutionRequest setManagedVersionMap( Map managedVersionMap )
    {
        this.managedVersionMap = managedVersionMap;

        return this;
    }
2235#public ArtifactResolutionRequest setResolveRoot( boolean resolveRoot )
    {
        this.resolveRoot = resolveRoot;
        
        return this;
    }
2236#public boolean isResolveRoot()
    {
        return resolveRoot;
    }
2237#public ArtifactResolutionRequest setResolveTransitively( boolean resolveDependencies )
    {
        this.resolveTransitively = resolveDependencies;
        
        return this;
    }
2238#public boolean isResolveTransitively()
    {
        return resolveTransitively;
    }
2239#public String toString()
    {
        StringBuilder sb = new StringBuilder()
                .append( "REQUEST: " ).append(  "\n" )
                .append( "artifact: " ).append( artifact ).append(  "\n" )
                .append( artifactDependencies ).append(  "\n" )
                .append( "localRepository: " ).append(  localRepository ).append(  "\n" )
                .append( "remoteRepositories: " ).append(  remoteRepositories ).append(  "\n" );
        
        return sb.toString();
    }
2240#public RepositoryCache getCache()
    {
        return null;
    }
2241#public ArtifactResolutionRequest setCache( RepositoryCache cache )
    {
        return this;
    }
2242#public boolean isOffline()
    {
        return offline;
    }
2243#public ArtifactResolutionRequest setOffline( boolean offline )
    {
        this.offline = offline;

        return this;
    }
2244#public boolean isForceUpdate()
    {
        return forceUpdate;
    }
2245#public ArtifactResolutionRequest setForceUpdate( boolean forceUpdate )
    {
        this.forceUpdate = forceUpdate;

        return this;
    }
2246#public ArtifactResolutionRequest setServers( List<Server> servers )
    {
        this.servers = servers;

        return this;
    }
2247#public List<Server> getServers()
    {
        if ( servers == null )
        {
            servers = new ArrayList<Server>();
        }

        return servers;
    }
2248#public ArtifactResolutionRequest setMirrors( List<Mirror> mirrors )
    {
        this.mirrors = mirrors;

        return this;
    }
2249#public List<Mirror> getMirrors()
    {
        if ( mirrors == null )
        {
            mirrors = new ArrayList<Mirror>();
        }

        return mirrors;
    }
2250#public ArtifactResolutionRequest setProxies( List<Proxy> proxies )
    {
        this.proxies = proxies;

        return this;
    }
2251#public List<Proxy> getProxies()
    {
        if ( proxies == null )
        {
            proxies = new ArrayList<Proxy>();
        }

        return proxies;
    }
2252#public void throwErrors( ArtifactResolutionRequest request, ArtifactResolutionResult result )
        throws ArtifactResolutionException
    {
        // Metadata cannot be found

        if ( result.hasMetadataResolutionExceptions() )
        {
            throw result.getMetadataResolutionException( 0 );
        }

        // Metadata cannot be retrieved

        // Cyclic Dependency Error

        if ( result.hasCircularDependencyExceptions() )
        {
            throw result.getCircularDependencyException( 0 );
        }

        // Version Range Violation

        if ( result.hasVersionRangeViolations() )
        {
            throw result.getVersionRangeViolation( 0 );
        }

        // Transfer Error

        if ( result.hasErrorArtifactExceptions() )
        {
            throw result.getErrorArtifactExceptions().get( 0 );
        }

        if ( result.hasMissingArtifacts() )
        {
            throw new MultipleArtifactsNotFoundException( request.getArtifact(), toList( result.getArtifacts() ),
                                                          result.getMissingArtifacts(),
                                                          request.getRemoteRepositories() );
        }

        // this should never happen since we checked all possible error sources before but better be sure
        if ( result.hasExceptions() )
        {
            throw new ArtifactResolutionException( "Unknown error during artifact resolution, " + request + ", "
                + result.getExceptions(), request.getArtifact(), request.getRemoteRepositories() );
        }
    }
2253#private static <T> List<T> toList( Collection<T> items )
    {
        return ( items != null ) ? new ArrayList<T>( items ) : null;
    }
2254#public ExclusionSetFilter( String[] excludes )
    {
        this.excludes = new LinkedHashSet<String>( Arrays.asList( excludes ) );
    }
2255#public ExclusionSetFilter( Set<String> excludes )
    {
        this.excludes = excludes;
    }
2256#public boolean include( Artifact artifact )
    {
        String id = artifact.getArtifactId();

        if ( excludes.contains( id ) )
        {
            return false;
        }

        id = artifact.getGroupId() + ':' + id;

        if ( excludes.contains( id ) )
        {
            return false;
        }

        return true;
    }
2257#@Override
    public int hashCode()
    {
        int hash = 17;
        hash = hash * 31 + excludes.hashCode();
        return hash;
    }
2258#@Override
    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        
        if ( !( obj instanceof ExclusionSetFilter ) )
        {
            return false;
        }
        
        ExclusionSetFilter other = (ExclusionSetFilter) obj;
        
        return excludes.equals( other.excludes );
    }
2259#/**
     * Create a new filter with the specified scopes and their implied scopes enabled.
     * 
     * @param scopes The scopes to enable, along with all implied scopes, may be {@code null}.
     */
    public CumulativeScopeArtifactFilter( Collection<String> scopes )
    {
        this.scopes = new HashSet<String>();

        addScopes( scopes );
    }
2260#/**
     * Creates a new filter that combines the specified filters.
     * 
     * @param filters The filters to combine, may be {@code null}.
     */
    public CumulativeScopeArtifactFilter( CumulativeScopeArtifactFilter... filters )
    {
        this.scopes = new HashSet<String>();

        if ( filters != null )
        {
            for ( CumulativeScopeArtifactFilter filter : filters )
            {
                addScopes( filter.getScopes() );
            }
        }
    }
2261#private void addScopes( Collection<String> scopes )
    {
        if ( scopes != null )
        {
            for ( String scope : scopes )
            {
                addScope( scope );
            }
        }
    }
2262#private void addScope( String scope )
    {
        this.scopes.add( scope );

        addScopeInternal( scope );
    }
2263#public Set<String> getScopes()
    {
        return scopes;
    }
2264#@Override
    public int hashCode()
    {
        int hash = 17;

        hash = hash * 31 + scopes.hashCode();

        return hash;
    }
2265#@Override
    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof CumulativeScopeArtifactFilter ) )
        {
            return false;
        }

        CumulativeScopeArtifactFilter that = (CumulativeScopeArtifactFilter) obj;

        return scopes.equals( that.scopes );
    }
2266#public ScopeArtifactFilter( String scope )
    {
        this.scope = scope;

        addScopeInternal( scope );
    }
2267#public String getScope()
    {
        return scope;
    }
2268#@Override
    public int hashCode()
    {
        int hash = 17;

        hash = hash * 31 + ( scope != null ? scope.hashCode() : 0 );

        return hash;
    }
2269#@Override
    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }

        if ( !( obj instanceof ScopeArtifactFilter ) )
        {
            return false;
        }

        ScopeArtifactFilter other = (ScopeArtifactFilter) obj;

        return equals( scope, other.scope );
    }
2270#private static <T> boolean equals( T str1, T str2 )
    {
        return str1 != null ? str1.equals( str2 ) : str2 == null;
    }
2271#public AndArtifactFilter()
    {
        this.filters = new LinkedHashSet<ArtifactFilter>();
    }
2272#public AndArtifactFilter( List<ArtifactFilter> filters )
    {
        this.filters = new LinkedHashSet<ArtifactFilter>( filters );
    }
2273#public boolean include( Artifact artifact )
    {
        boolean include = true;
        for ( Iterator<ArtifactFilter> i = filters.iterator(); i.hasNext() && include; )
        {
            ArtifactFilter filter = i.next();
            if ( !filter.include( artifact ) )
            {
                include = false;
            }
        }
        return include;
    }
2274#public void add( ArtifactFilter artifactFilter )
    {
        filters.add( artifactFilter );
    }
2275#public List<ArtifactFilter> getFilters()
    {
        return new ArrayList<ArtifactFilter>( filters );
    }
2276#@Override
    public int hashCode()
    {
        int hash = 17;
        hash = hash * 31 + filters.hashCode();
        return hash;
    }
2277#@Override
    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        
        if ( !( obj instanceof AndArtifactFilter ) )
        {
            return false;
        }
        
        AndArtifactFilter other = (AndArtifactFilter) obj;
        
        return filters.equals( other.filters );
    }
2278#public ExcludesArtifactFilter( List<String> patterns )
    {
        super( patterns );
    }
2279#public boolean include( Artifact artifact )
    {
        return !super.include( artifact );
    }
2280#void addScopeInternal( String scope )
    {
        if ( Artifact.SCOPE_COMPILE.equals( scope ) )
        {
            systemScope = true;
            providedScope = true;
            compileScope = true;
        }
        else if ( Artifact.SCOPE_RUNTIME.equals( scope ) )
        {
            compileScope = true;
            runtimeScope = true;
        }
        else if ( Artifact.SCOPE_COMPILE_PLUS_RUNTIME.equals( scope ) )
        {
            systemScope = true;
            providedScope = true;
            compileScope = true;
            runtimeScope = true;
        }
        else if ( Artifact.SCOPE_RUNTIME_PLUS_SYSTEM.equals( scope ) )
        {
            systemScope = true;
            compileScope = true;
            runtimeScope = true;
        }
        else if ( Artifact.SCOPE_TEST.equals( scope ) )
        {
            systemScope = true;
            providedScope = true;
            compileScope = true;
            runtimeScope = true;
            testScope = true;
        }
    }
2281#public boolean include( Artifact artifact )
    {
        if ( Artifact.SCOPE_COMPILE.equals( artifact.getScope() ) )
        {
            return compileScope;
        }
        else if ( Artifact.SCOPE_RUNTIME.equals( artifact.getScope() ) )
        {
            return runtimeScope;
        }
        else if ( Artifact.SCOPE_TEST.equals( artifact.getScope() ) )
        {
            return testScope;
        }
        else if ( Artifact.SCOPE_PROVIDED.equals( artifact.getScope() ) )
        {
            return providedScope;
        }
        else if ( Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )
        {
            return systemScope;
        }
        else
        {
            return true;
        }
    }
2282#public IncludesArtifactFilter( List<String> patterns )
    {
        this.patterns = new LinkedHashSet<String>( patterns );
    }
2283#public boolean include( Artifact artifact )
    {
        String id = artifact.getGroupId() + ":" + artifact.getArtifactId();

        boolean matched = false;
        for ( Iterator<String> i = patterns.iterator(); i.hasNext() & !matched; )
        {
            // TODO: what about wildcards? Just specifying groups? versions?
            if ( id.equals( i.next() ) )
            {
                matched = true;
            }
        }
        return matched;
    }
2284#public List<String> getPatterns()
    {
        return new ArrayList<String>( patterns );
    }
2285#@Override
    public int hashCode()
    {
        int hash = 17;
        hash = hash * 31 + patterns.hashCode();
        
        return hash;
    }
2286#@Override
    public boolean equals( Object obj )
    {
        if ( this == obj ) 
        {
            return true;
        }

        // make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter! 
        if ( obj == null || getClass() != obj.getClass() )
        {
            return false;
        }

        IncludesArtifactFilter other = (IncludesArtifactFilter) obj;

        return patterns.equals( other.patterns );
    }
2287#private ClassWorld getClassWorld()
    {
        return ( (MutablePlexusContainer) container ).getClassWorld();
    }
2288#private ClassRealm newRealm( String id )
    {
        ClassWorld world = getClassWorld();

        synchronized ( world )
        {
            String realmId = id;

            Random random = new Random();

            while ( true )
            {
                try
                {
                    ClassRealm classRealm = world.newRealm( realmId, null );

                    if ( logger.isDebugEnabled() )
                    {
                        logger.debug( "Created new class realm " + realmId );
                    }

                    return classRealm;
                }
                catch ( DuplicateRealmException e )
                {
                    realmId = id + '-' + random.nextInt();
                }
            }
        }
    }
2289#public synchronized ClassRealm getMavenApiRealm()
    {
        if ( mavenRealm == null )
        {
            mavenRealm = newRealm( "maven.api" );

            List<ClassRealmConstituent> constituents = new ArrayList<ClassRealmConstituent>();

            List<String> parentImports = new ArrayList<String>();

            Map<String, ClassLoader> foreignImports = new HashMap<String, ClassLoader>();
            importMavenApi( foreignImports );

            callDelegates( mavenRealm, RealmType.Core, mavenRealm.getParentClassLoader(), parentImports,
                           foreignImports, constituents );

            wireRealm( mavenRealm, parentImports, foreignImports );

            populateRealm( mavenRealm, constituents );
        }

        return mavenRealm;
    }
2290#private void importMavenApi( Map<String, ClassLoader> imports )
    {
        ClassRealm coreRealm = getCoreRealm();

        // maven-*
        imports.put( "org.apache.maven.*", coreRealm );
        imports.put( "org.apache.maven.artifact", coreRealm );
        imports.put( "org.apache.maven.classrealm", coreRealm );
        imports.put( "org.apache.maven.cli", coreRealm );
        imports.put( "org.apache.maven.configuration", coreRealm );
        imports.put( "org.apache.maven.exception", coreRealm );
        imports.put( "org.apache.maven.execution", coreRealm );
        imports.put( "org.apache.maven.lifecycle", coreRealm );
        imports.put( "org.apache.maven.model", coreRealm );
        imports.put( "org.apache.maven.monitor", coreRealm );
        imports.put( "org.apache.maven.plugin", coreRealm );
        imports.put( "org.apache.maven.profiles", coreRealm );
        imports.put( "org.apache.maven.project", coreRealm );
        imports.put( "org.apache.maven.reporting", coreRealm );
        imports.put( "org.apache.maven.repository", coreRealm );
        imports.put( "org.apache.maven.rtinfo", coreRealm );
        imports.put( "org.apache.maven.settings", coreRealm );
        imports.put( "org.apache.maven.toolchain", coreRealm );
        imports.put( "org.apache.maven.usability", coreRealm );

        // wagon-api
        imports.put( "org.apache.maven.wagon.*", coreRealm );
        imports.put( "org.apache.maven.wagon.authentication", coreRealm );
        imports.put( "org.apache.maven.wagon.authorization", coreRealm );
        imports.put( "org.apache.maven.wagon.events", coreRealm );
        imports.put( "org.apache.maven.wagon.observers", coreRealm );
        imports.put( "org.apache.maven.wagon.proxy", coreRealm );
        imports.put( "org.apache.maven.wagon.repository", coreRealm );
        imports.put( "org.apache.maven.wagon.resource", coreRealm );

        // aether-api, aether-spi, aether-impl
        imports.put( "org.sonatype.aether.*", coreRealm );
        imports.put( "org.sonatype.aether.artifact", coreRealm );
        imports.put( "org.sonatype.aether.collection", coreRealm );
        imports.put( "org.sonatype.aether.deployment", coreRealm );
        imports.put( "org.sonatype.aether.graph", coreRealm );
        imports.put( "org.sonatype.aether.impl", coreRealm );
        imports.put( "org.sonatype.aether.installation", coreRealm );
        imports.put( "org.sonatype.aether.metadata", coreRealm );
        imports.put( "org.sonatype.aether.repository", coreRealm );
        imports.put( "org.sonatype.aether.resolution", coreRealm );
        imports.put( "org.sonatype.aether.spi", coreRealm );
        imports.put( "org.sonatype.aether.transfer", coreRealm );
        imports.put( "org.sonatype.aether.version", coreRealm );

        // plexus-classworlds
        imports.put( "org.codehaus.plexus.classworlds", coreRealm );

        // classworlds (for legacy code)
        imports.put( "org.codehaus.classworlds", coreRealm );

        // plexus-container, plexus-component-annotations
        imports.put( "org.codehaus.plexus.*", coreRealm );
        imports.put( "org.codehaus.plexus.component", coreRealm );
        imports.put( "org.codehaus.plexus.configuration", coreRealm );
        imports.put( "org.codehaus.plexus.container", coreRealm );
        imports.put( "org.codehaus.plexus.context", coreRealm );
        imports.put( "org.codehaus.plexus.lifecycle", coreRealm );
        imports.put( "org.codehaus.plexus.logging", coreRealm );
        imports.put( "org.codehaus.plexus.personality", coreRealm );

        // plexus-utils (for maven-model)
        imports.put( "org.codehaus.plexus.util.xml.Xpp3Dom", coreRealm );
        imports.put( "org.codehaus.plexus.util.xml.pull.XmlPullParser", coreRealm );
        imports.put( "org.codehaus.plexus.util.xml.pull.XmlPullParserException", coreRealm );
        imports.put( "org.codehaus.plexus.util.xml.pull.XmlSerializer", coreRealm );
    }
2291#/**
     * Creates a new class realm with the specified parent and imports.
     * 
     * @param baseRealmId The base id to use for the new realm, must not be {@code null}.
     * @param type The type of the class realm, must not be {@code null}.
     * @param parent The parent realm for the new realm, may be {@code null}.
     * @param parentImports The packages/types to import from the parent realm, may be {@code null}.
     * @param foreignImports The packages/types to import from foreign realms, may be {@code null}.
     * @param artifacts The artifacts to add to the realm, may be {@code null}. Unresolved artifacts (i.e. with a
     *            missing file) will automatically be excluded from the realm.
     * @return The created class realm, never {@code null}.
     */
    private ClassRealm createRealm( String baseRealmId, RealmType type, ClassLoader parent, List<String> parentImports,
                                    Map<String, ClassLoader> foreignImports, List<Artifact> artifacts )
    {
        Set<String> artifactIds = new LinkedHashSet<String>();

        List<ClassRealmConstituent> constituents = new ArrayList<ClassRealmConstituent>();

        if ( artifacts != null )
        {
            for ( Artifact artifact : artifacts )
            {
                artifactIds.add( getId( artifact ) );
                if ( artifact.getFile() != null )
                {
                    constituents.add( new ArtifactClassRealmConstituent( artifact ) );
                }
            }
        }

        if ( parentImports != null )
        {
            parentImports = new ArrayList<String>( parentImports );
        }
        else
        {
            parentImports = new ArrayList<String>();
        }

        if ( foreignImports != null )
        {
            foreignImports = new TreeMap<String, ClassLoader>( foreignImports );
        }
        else
        {
            foreignImports = new TreeMap<String, ClassLoader>();
        }

        ClassRealm classRealm = newRealm( baseRealmId );

        if ( parent != null )
        {
            classRealm.setParentClassLoader( parent );
        }

        callDelegates( classRealm, type, parent, parentImports, foreignImports, constituents );

        wireRealm( classRealm, parentImports, foreignImports );

        Set<String> includedIds = populateRealm( classRealm, constituents );

        if ( logger.isDebugEnabled() )
        {
            artifactIds.removeAll( includedIds );

            for ( String id : artifactIds )
            {
                logger.debug( "  Excluded: " + id );
            }
        }

        return classRealm;
    }
2292#public ClassRealm getCoreRealm()
    {
        return container.getContainerRealm();
    }
2293#public ClassRealm createProjectRealm( Model model, List<Artifact> artifacts )
    {
        if ( model == null )
        {
            throw new IllegalArgumentException( "model missing" );
        }

        ClassLoader parent = getMavenApiRealm();

        return createRealm( getKey( model ), RealmType.Project, parent, null, null, artifacts );
    }
2294#private static String getKey( Model model )
    {
        return "project>" + model.getGroupId() + ":" + model.getArtifactId() + ":" + model.getVersion();
    }
2295#public ClassRealm createExtensionRealm( Plugin plugin, List<Artifact> artifacts )
    {
        if ( plugin == null )
        {
            throw new IllegalArgumentException( "extension plugin missing" );
        }

        ClassLoader parent = ClassLoader.getSystemClassLoader();

        Map<String, ClassLoader> foreignImports =
            Collections.<String, ClassLoader> singletonMap( "", getMavenApiRealm() );

        return createRealm( getKey( plugin, true ), RealmType.Extension, parent, null, foreignImports, artifacts );
    }
2296#public ClassRealm createPluginRealm( Plugin plugin, ClassLoader parent, List<String> parentImports,
                                         Map<String, ClassLoader> foreignImports, List<Artifact> artifacts )
    {
        if ( plugin == null )
        {
            throw new IllegalArgumentException( "plugin missing" );
        }

        if ( parent == null )
        {
            parent = ClassLoader.getSystemClassLoader();
        }

        return createRealm( getKey( plugin, false ), RealmType.Plugin, parent, parentImports, foreignImports, artifacts );
    }
2297#private static String getKey( Plugin plugin, boolean extension )
    {
        String version = ArtifactUtils.toSnapshotVersion( plugin.getVersion() );
        return ( extension ? "extension>" : "plugin>" ) + plugin.getGroupId() + ":" + plugin.getArtifactId() + ":"
            + version;
    }
2298#private static String getId( Artifact artifact )
    {
        return getId( artifact.getGroupId(), artifact.getArtifactId(), artifact.getExtension(),
                      artifact.getClassifier(), artifact.getBaseVersion() );
    }
2299#private static String getId( ClassRealmConstituent constituent )
    {
        return getId( constituent.getGroupId(), constituent.getArtifactId(), constituent.getType(),
                      constituent.getClassifier(), constituent.getVersion() );
    }
2300#private static String getId( String gid, String aid, String type, String cls, String ver )
    {
        return gid + ':' + aid + ':' + type + ( StringUtils.isNotEmpty( cls ) ? ':' + cls : "" ) + ':' + ver;
    }
2301#private List<ClassRealmManagerDelegate> getDelegates()
    {
        try
        {
            return container.lookupList( ClassRealmManagerDelegate.class );
        }
        catch ( ComponentLookupException e )
        {
            logger.error( "Failed to lookup class realm delegates: " + e.getMessage(), e );

            return Collections.emptyList();
        }
    }
2302#private void callDelegates( ClassRealm classRealm, RealmType type, ClassLoader parent, List<String> parentImports,
                                Map<String, ClassLoader> foreignImports, List<ClassRealmConstituent> constituents )
    {
        List<ClassRealmManagerDelegate> delegates = getDelegates();

        if ( !delegates.isEmpty() )
        {
            ClassRealmRequest request =
                new DefaultClassRealmRequest( type, parent, parentImports, foreignImports, constituents );

            for ( ClassRealmManagerDelegate delegate : delegates )
            {
                try
                {
                    delegate.setupRealm( classRealm, request );
                }
                catch ( Exception e )
                {
                    logger.error( delegate.getClass().getName() + " failed to setup class realm " + classRealm + ": "
                        + e.getMessage(), e );
                }
            }
        }
    }
2303#private Set<String> populateRealm( ClassRealm classRealm, List<ClassRealmConstituent> constituents )
    {
        Set<String> includedIds = new LinkedHashSet<String>();

        if ( logger.isDebugEnabled() )
        {
            logger.debug( "Populating class realm " + classRealm.getId() );
        }

        for ( ClassRealmConstituent constituent : constituents )
        {
            File file = constituent.getFile();

            String id = getId( constituent );
            includedIds.add( id );

            if ( logger.isDebugEnabled() )
            {
                logger.debug( "  Included: " + id );
            }

            try
            {
                classRealm.addURL( file.toURI().toURL() );
            }
            catch ( MalformedURLException e )
            {
                // Not going to happen
                logger.error( e.getMessage(), e );
            }
        }

        return includedIds;
    }
2304#private void wireRealm( ClassRealm classRealm, List<String> parentImports, Map<String, ClassLoader> foreignImports )
    {
        if ( foreignImports != null && !foreignImports.isEmpty() )
        {
            if ( logger.isDebugEnabled() )
            {
                logger.debug( "Importing foreign packages into class realm " + classRealm.getId() );
            }

            for ( Map.Entry<String, ClassLoader> entry : foreignImports.entrySet() )
            {
                ClassLoader importedRealm = entry.getValue();
                String imp = entry.getKey();

                if ( logger.isDebugEnabled() )
                {
                    logger.debug( "  Imported: " + imp + " < " + getId( importedRealm ) );
                }

                classRealm.importFrom( importedRealm, imp );
            }
        }

        if ( parentImports != null && !parentImports.isEmpty() )
        {
            if ( logger.isDebugEnabled() )
            {
                logger.debug( "Importing parent packages into class realm " + classRealm.getId() );
            }

            for ( String imp : parentImports )
            {
                if ( logger.isDebugEnabled() )
                {
                    logger.debug( "  Imported: " + imp + " < " + getId( classRealm.getParentClassLoader() ) );
                }

                classRealm.importFromParent( imp );
            }
        }
    }
2305#private String getId( ClassLoader classLoader )
    {
        if ( classLoader instanceof ClassRealm )
        {
            return ( (ClassRealm) classLoader ).getId();
        }
        return String.valueOf( classLoader );
    }
2306#/**
     * Gets the type of the class realm.
     * 
     * @return The type of the class realm, never {@code null}.
     */
    RealmType getType();
2307#/**
     * Gets the parent class realm (if any).
     * 
     * @return The parent class realm or {@code null} if using the default parent.
     */
    ClassLoader getParent();
2308#/**
     * @deprecated Use {@link #getParentImports()} instead.
     */
    @Deprecated
    List<String> getImports();
2309#/**
     * Gets the packages/types to import from the parent realm.
     * 
     * @return The modifiable list of packages/types to import from the parent realm, never {@code null}.
     */
    List<String> getParentImports();
2310#/**
     * Gets the packages/types to import from foreign realms.
     * 
     * @return The modifiable map of packages/types to import from foreign realms, never {@code null}.
     */
    Map<String, ClassLoader> getForeignImports();
2311#/**
     * Gets the constituents for the class realm.
     * 
     * @return The modifiable list of constituents for the class realm, never {@code null}.
     */
    List<ClassRealmConstituent> getConstituents();
2312#/**
     * Gets the group id of the constituent's artifact.
     * 
     * @return The group id, never {@code null}.
     */
    String getGroupId();
2313#/**
     * Gets the artifact id of the constituent's artifact.
     * 
     * @return The artifact id, never {@code null}.
     */
    String getArtifactId();
2314#/**
     * Gets the type of the constituent's artifact.
     * 
     * @return The type, never {@code null}.
     */
    String getType();
2315#/**
     * Gets the classifier of the constituent's artifact.
     * 
     * @return The classifier or an empty string, never {@code null}.
     */
    String getClassifier();
2316#/**
     * Gets the version of the constituent's artifact.
     * 
     * @return The version, never {@code null}.
     */
    String getVersion();
2317#/**
     * Gets the file of the constituent's artifact.
     * 
     * @return The file, never {@code null}.
     */
    File getFile();
2318#/**
     * Gets the class realm hosting the Maven core.
     * 
     * @return The class realm hosting the Maven core, never {@code null}.
     */
    ClassRealm getCoreRealm();
2319#/**
     * Gets the class realm exposing the Maven API. This is basically a restricted view on the Maven core realm.
     * 
     * @return The class realm exposing the Maven API, never {@code null}.
     */
    ClassRealm getMavenApiRealm();
2320#/**
     * Creates a new class realm for the specified project and its build extensions.
     * 
     * @param model The model of the project for which to create a realm, must not be {@code null}.
     * @param artifacts The artifacts to add to the class realm, may be {@code null}. Unresolved artifacts (i.e. with a
     *            missing file) will automatically be excluded from the realm.
     * @return The new project realm, never {@code null}.
     */
    ClassRealm createProjectRealm( Model model, List<Artifact> artifacts );
2321#/**
     * Creates a new class realm for the specified build extension.
     * 
     * @param plugin The extension plugin for which to create a realm, must not be {@code null}.
     * @param artifacts The artifacts to add to the class realm, may be {@code null}. Unresolved artifacts (i.e. with a
     *            missing file) will automatically be excluded from the realm.
     * @return The new extension realm, never {@code null}.
     */
    ClassRealm createExtensionRealm( Plugin extension, List<Artifact> artifacts );
2322#/**
     * Creates a new class realm for the specified plugin.
     * 
     * @param plugin The plugin for which to create a realm, must not be {@code null}.
     * @param parent The parent realm for the new realm, may be {@code null}.
     * @param parentImports The packages/types to import from the parent realm, may be {@code null}.
     * @param foreignImports The packages/types to import from foreign realms, may be {@code null}.
     * @param artifacts The artifacts to add to the class realm, may be {@code null}. Unresolved artifacts (i.e. with a
     *            missing file) will automatically be excluded from the realm.
     * @return The new plugin realm, never {@code null}.
     */
    ClassRealm createPluginRealm( Plugin plugin, ClassLoader parent, List<String> parentImports,
                                  Map<String, ClassLoader> foreignImports, List<Artifact> artifacts );
2323#public ArtifactClassRealmConstituent( Artifact artifact )
    {
        this.artifact = artifact;
    }
2324#public String getGroupId()
    {
        return artifact.getGroupId();
    }
2325#public String getArtifactId()
    {
        return artifact.getArtifactId();
    }
2326#public String getType()
    {
        return artifact.getExtension();
    }
2327#public String getClassifier()
    {
        return artifact.getClassifier();
    }
2328#public String getVersion()
    {
        return artifact.getBaseVersion();
    }
2329#public File getFile()
    {
        return artifact.getFile();
    }
2330#@Override
    public String toString()
    {
        return artifact.toString();
    }
2331#public DefaultClassRealmRequest( RealmType type, ClassLoader parent, List<String> parentImports,
                                     Map<String, ClassLoader> foreignImports, List<ClassRealmConstituent> constituents )
    {
        this.type = type;
        this.parent = parent;
        this.parentImports = parentImports;
        this.foreignImports = foreignImports;
        this.constituents = constituents;
    }
2332#public RealmType getType()
    {
        return type;
    }
2333#public ClassLoader getParent()
    {
        return parent;
    }
2334#public List<String> getImports()
    {
        return getParentImports();
    }
2335#public List<String> getParentImports()
    {
        return parentImports;
    }
2336#public Map<String, ClassLoader> getForeignImports()
    {
        return foreignImports;
    }
2337#public List<ClassRealmConstituent> getConstituents()
    {
        return constituents;
    }
2338#void setupRealm( ClassRealm classRealm, ClassRealmRequest request );
2339#/**
     * Creates a new path translator using the specified base directory.
     * 
     * @param basedir The base directory to resolve relative paths against, may be {@code null} to disable path
     *            translation.
     */
    public BasedirBeanConfigurationPathTranslator( File basedir )
    {
        this.basedir = basedir;
    }
2340#public File translatePath( File path )
    {
        File result = path;

        if ( path != null && basedir != null )
        {
            if ( path.isAbsolute() )
            {
                // path is already absolute, we're done
            }
            else if ( path.getPath().startsWith( File.separator ) )
            {
                // drive-relative Windows path, don't align with base dir but with drive root
                result = path.getAbsoluteFile();
            }
            else
            {
                // an ordinary relative path, align with base dir
                result = new File( new File( basedir, path.getPath() ).toURI().normalize() ).getAbsoluteFile();
            }
        }

        return result;
    }
2341#public BeanConfigurationException( String message )
    {
        super( message );
    }
2342#public BeanConfigurationException( String message, Throwable cause )
    {
        super( message, cause );
    }
2343#/**
     * Preprocesses the specified bean configuration value. The optional type provided to this method is a hint (not a
     * requirement) for the preprocessor to resolve the value to a compatible value or a (string) value than can be
     * unmarshalled into that type. The preprocessor is not required to perform any type conversion but should rather
     * filter out incompatible values from its result.
     * 
     * @param value The configuration value to preprocess, must not be {@code null}.
     * @param type The target type of the value, may be {@code null}.
     * @return The processed configuration value or {@code null} if none.
     * @throws BeanConfigurationException If an error occurred while preprocessing the value.
     */
    Object preprocessValue( String value, Class<?> type )
        throws BeanConfigurationException;
2344#/**
     * Gets the bean to configure. Eventually, a valid request must have a bean set.
     * 
     * @return The bean to configure, or {@code null} if none.
     */
    Object getBean();
2345#/**
     * Sets the bean to configure. Eventually, a valid request must have a bean set.
     * 
     * @param bean The bean to configure, may be {@code null}.
     * @return This request for chaining, never {@code null}.
     */
    BeanConfigurationRequest setBean( Object bean );
2346#/**
     * Gets the configuration to unmarshal into the bean.
     * 
     * @return The configuration to unmarshal into the bean or {@code null} if none.
     */
    Object getConfiguration();
2347#/**
     * Sets the configuration to unmarshal into the bean. The configuration should be taken from
     * {@link org.apache.maven.model.ConfigurationContainer#getConfiguration()} or a similar source.
     * Fully equivalent to {@code setConfiguration(configuration, null)}.
     * 
     * @param configuration The configuration to unmarshal, may be {@code null}.
     * @return This request for chaining, never {@code null}.
     */
    BeanConfigurationRequest setConfiguration( Object configuration );
2348#/**
     * Sets the configuration to unmarshal into the bean. The configuration should be taken from
     * {@link org.apache.maven.model.ConfigurationContainer#getConfiguration()} or a similar source.
     * If {@code element} is not {@code null}, child configuration element with the specified name will 
     * be unmarshaled.
     * 
     * @param configuration The configuration to unmarshal, may be {@code null}.
     * @param element Configuration element name to unmarshal or {@code null} to unmarshal entire configuration.
     * @return This request for chaining, never {@code null}.
     */
    BeanConfigurationRequest setConfiguration( Object configuration, String element );
2349#/**
     * Returns configuration element name or {@code null}. 
     * 
     * @see {@link #setConfiguration(Object, String)}
     * 
     * @return Configuration element name or {@code null}
     */
    String getConfigurationElement();
2350#/**
     * Gets the class loader from which to load any types referenced by the configuration. If unset, the class loader of
     * the bean class will be used.
     * 
     * @return The class loader to load referenced types from or {@code null} if unset.
     */
    ClassLoader getClassLoader();
2351#/**
     * Sets the class loader from which to load any types referenced by the configuration. If unset, the class loader of
     * the bean class will be used.
     * 
     * @param classLoader The class loader to load referenced types from, may be {@code null}.
     * @return This request for chaining, never {@code null}.
     */
    BeanConfigurationRequest setClassLoader( ClassLoader classLoader );
2352#/**
     * Gets the optional preprocessor for configuration values.
     * 
     * @return The preprocessor for configuration values or {@code null} if none.
     */
    BeanConfigurationValuePreprocessor getValuePreprocessor();
2353#/**
     * Sets the optional preprocessor for configuration values.
     * 
     * @param valuePreprocessor The preprocessor for configuration values, may be {@code null} if unneeded.
     * @return This request for chaining, never {@code null}.
     */
    BeanConfigurationRequest setValuePreprocessor( BeanConfigurationValuePreprocessor valuePreprocessor );
2354#/**
     * Gets the optional path translator for configuration values unmarshalled to files.
     * 
     * @return The path translator for files or {@code null} if none.
     */
    BeanConfigurationPathTranslator getPathTranslator();
2355#/**
     * Sets the optional path translator for configuration values unmarshalled to files.
     * 
     * @param pathTranslator The path translator for files, may be {@code null} if unneeded.
     * @return This request for chaining, never {@code null}.
     */
    BeanConfigurationRequest setPathTranslator( BeanConfigurationPathTranslator pathTranslator );
2356#public Object getBean()
    {
        return bean;
    }
2357#public DefaultBeanConfigurationRequest setBean( Object bean )
    {
        this.bean = bean;
        return this;
    }
2358#public Object getConfiguration()
    {
        return configuration;
    }
2359#public String getConfigurationElement()
    {
        return configurationElement;
    }
2360#public DefaultBeanConfigurationRequest setConfiguration( Object configuration )
    {
        return setConfiguration( configuration, null );
    }
2361#public DefaultBeanConfigurationRequest setConfiguration( Object configuration, String element )
    {
        this.configuration = configuration;
        this.configurationElement = element;
        return this;
    }
2362#/**
     * Sets the configuration to the configuration taken from the specified build plugin in the POM. First, the build
     * plugins will be searched for the specified plugin, if that fails, the plugin management section will be searched.
     * 
     * @param model The POM to extract the plugin configuration from, may be {@code null}.
     * @param pluginGroupId The group id of the plugin whose configuration should be used, must not be {@code null} or
     *            empty.
     * @param pluginArtifactId The artifact id of the plugin whose configuration should be used, must not be
     *            {@code null} or empty.
     * @param pluginExecutionId The id of a plugin execution whose configuration should be used, may be {@code null} or
     *            empty to use the general plugin configuration.
     * @return This request for chaining, never {@code null}.
     */
    public DefaultBeanConfigurationRequest setConfiguration( Model model, String pluginGroupId,
                                                             String pluginArtifactId, String pluginExecutionId )
    {
        Plugin plugin = findPlugin( model, pluginGroupId, pluginArtifactId );
        if ( plugin != null )
        {
            if ( StringUtils.isNotEmpty( pluginExecutionId ) )
            {
                for ( PluginExecution execution : plugin.getExecutions() )
                {
                    if ( pluginExecutionId.equals( execution.getId() ) )
                    {
                        setConfiguration( execution.getConfiguration() );
                        break;
                    }
                }
            }
            else
            {
                setConfiguration( plugin.getConfiguration() );
            }
        }
        return this;
    }
2363#private Plugin findPlugin( Model model, String groupId, String artifactId )
    {
        if ( StringUtils.isEmpty( groupId ) )
        {
            throw new IllegalArgumentException( "group id for plugin has not been specified" );
        }
        if ( StringUtils.isEmpty( artifactId ) )
        {
            throw new IllegalArgumentException( "artifact id for plugin has not been specified" );
        }

        if ( model != null )
        {
            Build build = model.getBuild();
            if ( build != null )
            {
                for ( Plugin plugin : build.getPlugins() )
                {
                    if ( groupId.equals( plugin.getGroupId() ) && artifactId.equals( plugin.getArtifactId() ) )
                    {
                        return plugin;
                    }
                }

                PluginManagement mngt = build.getPluginManagement();
                if ( mngt != null )
                {
                    for ( Plugin plugin : mngt.getPlugins() )
                    {
                        if ( groupId.equals( plugin.getGroupId() ) && artifactId.equals( plugin.getArtifactId() ) )
                        {
                            return plugin;
                        }
                    }
                }
            }
        }

        return null;
    }
2364#public ClassLoader getClassLoader()
    {
        return classLoader;
    }
2365#public DefaultBeanConfigurationRequest setClassLoader( ClassLoader classLoader )
    {
        this.classLoader = classLoader;
        return this;
    }
2366#public BeanConfigurationValuePreprocessor getValuePreprocessor()
    {
        return valuePreprocessor;
    }
2367#public DefaultBeanConfigurationRequest setValuePreprocessor( BeanConfigurationValuePreprocessor valuePreprocessor )
    {
        this.valuePreprocessor = valuePreprocessor;
        return this;
    }
2368#public BeanConfigurationPathTranslator getPathTranslator()
    {
        return pathTranslator;
    }
2369#public DefaultBeanConfigurationRequest setPathTranslator( BeanConfigurationPathTranslator pathTranslator )
    {
        this.pathTranslator = pathTranslator;
        return this;
    }
2370#/**
     * Translates the specified path.
     * 
     * @param path The path to translate, may be {@code null}.
     * @return The translated path or {@code null} if none.
     */
    File translatePath( File path );
2371#/**
     * Performs the specified bean configuration.
     * 
     * @param request The configuration request that specifies the bean and the configuration to process, must not be
     *            {@code null}.
     * @throws BeanConfigurationException If the bean configuration could not be successfully processed.
     */
    void configureBean( BeanConfigurationRequest request )
        throws BeanConfigurationException;
2372#public void configureBean( BeanConfigurationRequest request )
        throws BeanConfigurationException
    {
        if ( request == null )
        {
            throw new IllegalArgumentException( "bean configuration request not specified" );
        }

        if ( request.getBean() == null )
        {
            throw new IllegalArgumentException( "bean to be configured not specified" );
        }

        Object configuration = request.getConfiguration();
        if ( configuration == null )
        {
            return;
        }

        PlexusConfiguration plexusConfig = null;
        if ( configuration instanceof PlexusConfiguration )
        {
            plexusConfig = (PlexusConfiguration) configuration;
        }
        else if ( configuration instanceof Xpp3Dom )
        {
            plexusConfig = new XmlPlexusConfiguration( (Xpp3Dom) configuration );
        }
        else
        {
            throw new BeanConfigurationException( "unsupported bean configuration source ("
                + configuration.getClass().getName() + ")" );
        }

        if ( request.getConfigurationElement() != null )
        {
            plexusConfig = plexusConfig.getChild( request.getConfigurationElement() );
        }

        ClassLoader classLoader = request.getClassLoader();
        if ( classLoader == null )
        {
            classLoader = request.getBean().getClass().getClassLoader();
        }

        BeanExpressionEvaluator evaluator = new BeanExpressionEvaluator( request );

        ObjectWithFieldsConverter converter = new ObjectWithFieldsConverter();

        try
        {
            converter.processConfiguration( converterLookup, request.getBean(), classLoader, plexusConfig, evaluator );
        }
        catch ( ComponentConfigurationException e )
        {
            throw new BeanConfigurationException( e.getMessage(), e );
        }
    }
2373#public BeanExpressionEvaluator( BeanConfigurationRequest request )
        {
            preprocessor = request.getValuePreprocessor();
            translator = request.getPathTranslator();
        }
2374#public Object evaluate( String expression, Class<?> type )
            throws ExpressionEvaluationException
        {
            if ( preprocessor != null )
            {
                try
                {
                    return preprocessor.preprocessValue( expression, type );
                }
                catch ( BeanConfigurationException e )
                {
                    throw new ExpressionEvaluationException( e.getMessage(), e );
                }
            }
            return expression;
        }
2375#public Object evaluate( String expression )
            throws ExpressionEvaluationException
        {
            return evaluate( expression, null );
        }
2376#public File alignToBaseDirectory( File file )
        {
            if ( translator != null )
            {
                return translator.translatePath( file );
            }
            return file;
        }
2377#public void init( Context context )
        throws Exception
    {
    }
2378#public void onEvent( Object event )
        throws Exception
    {
    }
2379#public void close()
        throws Exception
    {
    }
2380#/**
     * Initializes the spy.
     * 
     * @param context The event spy context, never {@code null}.
     */
    void init( Context context )
        throws Exception;
2381#/**
     * Notifies the spy of some build event/operation.
     * 
     * @param event The event, never {@@code null}.
     * @see org.apache.maven.settings.building.SettingsBuildingRequest
     * @see org.apache.maven.settings.building.SettingsBuildingResult
     * @see org.apache.maven.execution.MavenExecutionRequest
     * @see org.apache.maven.execution.MavenExecutionResult
     * @see org.apache.maven.project.DependencyResolutionRequest
     * @see org.apache.maven.project.DependencyResolutionResultt
     * @see org.apache.maven.execution.ExecutionEvent
     * @see org.sonatype.aether.RepositoryEvent
     */
    void onEvent( Object event )
        throws Exception;
2382#/**
     * Notifies the spy of Maven's termination, allowing it to free any resources allocated by it.
     */
    void close()
        throws Exception;
2383#/**
         * Gets key-value pairs providing information about the Maven runtime.
         * 
         * @return The key-value pairs, never {@code null}.
         */
        Map<String, Object> getData();
2384#public EventSpyExecutionListener( EventSpyDispatcher dispatcher, ExecutionListener delegate )
    {
        this.dispatcher = dispatcher;
        this.delegate = delegate;
    }
2385#@Override
    public void projectDiscoveryStarted( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.projectDiscoveryStarted( event );
    }
2386#@Override
    public void sessionStarted( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.sessionStarted( event );
    }
2387#@Override
    public void sessionEnded( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.sessionEnded( event );
    }
2388#@Override
    public void projectSkipped( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.projectSkipped( event );
    }
2389#@Override
    public void projectStarted( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.projectStarted( event );
    }
2390#@Override
    public void projectSucceeded( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.projectSucceeded( event );
    }
2391#@Override
    public void projectFailed( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.projectFailed( event );
    }
2392#@Override
    public void forkStarted( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.forkStarted( event );
    }
2393#@Override
    public void forkSucceeded( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.forkSucceeded( event );
    }
2394#@Override
    public void forkFailed( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.forkFailed( event );
    }
2395#@Override
    public void mojoSkipped( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.mojoSkipped( event );
    }
2396#@Override
    public void mojoStarted( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.mojoStarted( event );
    }
2397#@Override
    public void mojoSucceeded( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.mojoSucceeded( event );
    }
2398#@Override
    public void mojoFailed( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.mojoFailed( event );
    }
2399#@Override
    public void forkedProjectStarted( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.forkedProjectStarted( event );
    }
2400#@Override
    public void forkedProjectSucceeded( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.forkedProjectSucceeded( event );
    }
2401#@Override
    public void forkedProjectFailed( ExecutionEvent event )
    {
        dispatcher.onEvent( event );
        delegate.forkedProjectFailed( event );
    }
2402#public void setEventSpies( List<EventSpy> eventSpies )
    {
        // make copy to get rid of needless overhead for dynamic lookups
        this.eventSpies = new ArrayList<EventSpy>( eventSpies );
    }
2403#public List<EventSpy> getEventSpies()
    {
        return eventSpies;
    }
2404#public ExecutionListener chainListener( ExecutionListener listener )
    {
        if ( eventSpies.isEmpty() )
        {
            return listener;
        }
        return new EventSpyExecutionListener( this, listener );
    }
2405#public RepositoryListener chainListener( RepositoryListener listener )
    {
        if ( eventSpies.isEmpty() )
        {
            return listener;
        }
        return new EventSpyRepositoryListener( this, listener );
    }
2406#public void init( EventSpy.Context context )
    {
        if ( eventSpies.isEmpty() )
        {
            return;
        }
        for ( EventSpy eventSpy : eventSpies )
        {
            try
            {
                eventSpy.init( context );
            }
            catch ( Exception e )
            {
                logError( "initialize", e, eventSpy );
            }
            catch ( LinkageError e )
            {
                logError( "initialize", e, eventSpy );
            }
        }
    }
2407#public void onEvent( Object event )
    {
        if ( eventSpies.isEmpty() )
        {
            return;
        }
        for ( EventSpy eventSpy : eventSpies )
        {
            try
            {
                eventSpy.onEvent( event );
            }
            catch ( Exception e )
            {
                logError( "notify", e, eventSpy );
            }
            catch ( LinkageError e )
            {
                logError( "notify", e, eventSpy );
            }
        }
    }
2408#public void close()
    {
        if ( eventSpies.isEmpty() )
        {
            return;
        }
        for ( EventSpy eventSpy : eventSpies )
        {
            try
            {
                eventSpy.close();
            }
            catch ( Exception e )
            {
                logError( "close", e, eventSpy );
            }
            catch ( LinkageError e )
            {
                logError( "close", e, eventSpy );
            }
        }
    }
2409#private void logError( String action, Throwable e, EventSpy spy )
    {
        String msg = "Failed to " + action + " spy " + spy.getClass().getName() + ": " + e.getMessage();

        if ( logger.isDebugEnabled() )
        {
            logger.warn( msg, e );
        }
        else
        {
            logger.warn( msg );
        }
    }
2410#public EventSpyRepositoryListener( EventSpyDispatcher dispatcher, RepositoryListener delegate )
    {
        this.dispatcher = dispatcher;
        this.delegate = delegate;
    }
2411#@Override
    public void artifactDeployed( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.artifactDeployed( event );
    }
2412#@Override
    public void artifactDeploying( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.artifactDeploying( event );
    }
2413#@Override
    public void artifactDescriptorInvalid( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.artifactDescriptorInvalid( event );
    }
2414#@Override
    public void artifactDescriptorMissing( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.artifactDescriptorMissing( event );
    }
2415#@Override
    public void artifactInstalled( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.artifactInstalled( event );
    }
2416#@Override
    public void artifactInstalling( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.artifactInstalling( event );
    }
2417#@Override
    public void artifactResolved( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.artifactResolved( event );
    }
2418#@Override
    public void artifactResolving( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.artifactResolving( event );
    }
2419#@Override
    public void metadataDeployed( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.metadataDeployed( event );
    }
2420#@Override
    public void metadataDeploying( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.metadataDeploying( event );
    }
2421#@Override
    public void metadataInstalled( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.metadataInstalled( event );
    }
2422#@Override
    public void metadataInstalling( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.metadataInstalling( event );
    }
2423#@Override
    public void metadataInvalid( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.metadataInvalid( event );
    }
2424#@Override
    public void metadataResolved( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.metadataResolved( event );
    }
2425#@Override
    public void metadataResolving( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.metadataResolving( event );
    }
2426#@Override
    public void artifactDownloaded( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.artifactDownloaded( event );
    }
2427#@Override
    public void artifactDownloading( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.artifactDownloading( event );
    }
2428#@Override
    public void metadataDownloaded( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.metadataDownloaded( event );
    }
2429#@Override
    public void metadataDownloading( RepositoryEvent event )
    {
        dispatcher.onEvent( event );
        delegate.metadataDownloading( event );
    }
2430#ExceptionSummary handleException( Throwable e );
2431#public ExceptionSummary( Throwable exception, String message, String reference )
    {
        this( exception, message, reference, null );
    }
2432#public ExceptionSummary( Throwable exception, String message, String reference, List<ExceptionSummary> children )
    {
        this.exception = exception;
        this.message = ( message != null ) ? message : "";
        this.reference = ( reference != null ) ? reference : "";
        this.children = ( children != null ) ? children : Collections.<ExceptionSummary> emptyList();
    }
2433#public Throwable getException()
    {
        return exception;
    }
2434#public String getMessage()
    {
        return message;
    }
2435#public String getReference()
    {
        return reference;
    }
2436#public List<ExceptionSummary> getChildren()
    {
        return children;
    }
2437#public ExceptionSummary handleException( Throwable exception )
    {
        return handle( "", exception );
    }
2438#private ExceptionSummary handle( String message, Throwable exception )
    {
        String reference = getReference( exception );

        List<ExceptionSummary> children = null;

        if ( exception instanceof ProjectBuildingException )
        {
            List<ProjectBuildingResult> results = ( (ProjectBuildingException) exception ).getResults();

            children = new ArrayList<ExceptionSummary>();

            for ( ProjectBuildingResult result : results )
            {
                ExceptionSummary child = handle( result );
                if ( child != null )
                {
                    children.add( child );
                }
            }

            message = "The build could not read " + children.size() + " project" + ( children.size() == 1 ? "" : "s" );
        }
        else
        {
            message = getMessage( message, exception );
        }

        return new ExceptionSummary( exception, message, reference, children );
    }
2439#private ExceptionSummary handle( ProjectBuildingResult result )
    {
        List<ExceptionSummary> children = new ArrayList<ExceptionSummary>();

        for ( ModelProblem problem : result.getProblems() )
        {
            ExceptionSummary child = handle( problem, result.getProjectId() );
            if ( child != null )
            {
                children.add( child );
            }
        }

        if ( children.isEmpty() )
        {
            return null;
        }

        String message =
            "\nThe project " + result.getProjectId() + " (" + result.getPomFile() + ") has "
                + children.size() + " error" + ( children.size() == 1 ? "" : "s" );

        return new ExceptionSummary( null, message, null, children );
    }
2440#private ExceptionSummary handle( ModelProblem problem, String projectId )
    {
        if ( ModelProblem.Severity.ERROR.compareTo( problem.getSeverity() ) >= 0 )
        {
            String message = problem.getMessage();

            String location = ModelProblemUtils.formatLocation( problem, projectId );

            if ( StringUtils.isNotEmpty( location ) )
            {
                message += " @ " + location;
            }

            return handle( message, problem.getException() );
        }
        else
        {
            return null;
        }
    }
2441#private String getReference( Throwable exception )
    {
        String reference = "";

        if ( exception != null )
        {
            if ( exception instanceof MojoExecutionException )
            {
                reference = MojoExecutionException.class.getSimpleName();
            }
            else if ( exception instanceof MojoFailureException )
            {
                reference = MojoFailureException.class.getSimpleName();
            }
            else if ( exception instanceof LinkageError )
            {
                reference = LinkageError.class.getSimpleName();
            }
            else if ( exception instanceof PluginExecutionException )
            {
                reference = getReference( exception.getCause() );

                if ( StringUtils.isEmpty( reference ) )
                {
                    reference = exception.getClass().getSimpleName();
                }
            }
            else if ( exception instanceof LifecycleExecutionException )
            {
                reference = getReference( exception.getCause() );
            }
            else if ( isNoteworthyException( exception ) )
            {
                reference = exception.getClass().getSimpleName();
            }
        }

        if ( StringUtils.isNotEmpty( reference ) && !reference.startsWith( "http:" ) )
        {
            reference = "http://cwiki.apache.org/confluence/display/MAVEN/" + reference;
        }

        return reference;
    }
2442#private boolean isNoteworthyException( Throwable exception )
    {
        if ( exception == null )
        {
            return false;
        }
        else if ( exception instanceof Error )
        {
            return true;
        }
        else if ( exception instanceof RuntimeException )
        {
            return false;
        }
        else if ( exception.getClass().getName().startsWith( "java" ) )
        {
            return false;
        }
        return true;
    }
2443#private String getMessage( String message, Throwable exception )
    {
        String fullMessage = ( message != null ) ? message : "";

        for ( Throwable t = exception; t != null; t = t.getCause() )
        {
            String exceptionMessage = t.getMessage();

            if ( t instanceof AbstractMojoExecutionException )
            {
                String longMessage = ( (AbstractMojoExecutionException) t ).getLongMessage();
                if ( StringUtils.isNotEmpty( longMessage ) )
                {
                    if ( StringUtils.isEmpty( exceptionMessage ) || longMessage.contains( exceptionMessage ) )
                    {
                        exceptionMessage = longMessage;
                    }
                    else if ( !exceptionMessage.contains( longMessage ) )
                    {
                        exceptionMessage = join( exceptionMessage, '\n' + longMessage );
                    }
                }
            }

            if ( StringUtils.isEmpty( exceptionMessage ) )
            {
                exceptionMessage = t.getClass().getSimpleName();
            }

            if ( t instanceof UnknownHostException && !fullMessage.contains( "host" ) )
            {
                fullMessage = join( fullMessage, "Unknown host " + exceptionMessage );
            }
            else if ( !fullMessage.contains( exceptionMessage ) )
            {
                fullMessage = join( fullMessage, exceptionMessage );
            }
        }

        return fullMessage.trim();
    }
2444#private String join( String message1, String message2 )
    {
        String message = "";

        if ( StringUtils.isNotEmpty( message1 ) )
        {
            message = message1.trim();
        }

        if ( StringUtils.isNotEmpty( message2 ) )
        {
            if ( StringUtils.isNotEmpty( message ) )
            {
                if ( message.endsWith( "." ) || message.endsWith( "!" ) || message.endsWith( ":" ) )
                {
                    message += " ";
                }
                else
                {
                    message += ": ";
                }
            }

            message += message2;
        }

        return message;
    }
2445#/**
     * Gets all projects in their intended build order, i.e. after topologically sorting the projects according to their
     * inter-dependencies.
     * 
     * @return The projects in the build order, never {@code null}.
     */
    List<MavenProject> getSortedProjects();
2446#/**
     * Gets the downstream projects of the specified project. A downstream project is a project that directly or
     * indirectly depends on the given project.
     * 
     * @param project The project whose downstream projects should be retrieved, must not be {@code null}.
     * @param transitive A flag whether to retrieve all direct and indirect downstream projects or just the immediate
     *            downstream projects.
     * @return The downstream projects in the build order, never {@code null}.
     */
    List<MavenProject> getDownstreamProjects( MavenProject project, boolean transitive );
2447#/**
     * Gets the upstream projects of the specified project. An upstream project is a project that directly or indirectly
     * is a prerequisite of the given project.
     * 
     * @param project The project whose upstream projects should be retrieved, must not be {@code null}.
     * @param transitive A flag whether to retrieve all direct and indirect upstream projects or just the immediate
     *            upstream projects.
     * @return The upstream projects in the build order, never {@code null}.
     */
    List<MavenProject> getUpstreamProjects( MavenProject project, boolean transitive );
2448#@Deprecated
    public MavenSession( PlexusContainer container, MavenExecutionRequest request, MavenExecutionResult result,
                         MavenProject project )
    {
        this( container, request, result, Arrays.asList( new MavenProject[]{project} ) );
    }
2449#@Deprecated
    public MavenSession( PlexusContainer container, Settings settings, ArtifactRepository localRepository,
                         EventDispatcher eventDispatcher, ReactorManager unused, List<String> goals,
                         String executionRootDir, Properties executionProperties, Date startTime )
    {
        this( container, settings, localRepository, eventDispatcher, unused, goals, executionRootDir,
              executionProperties, null, startTime );
    }
2450#@Deprecated
    public MavenSession( PlexusContainer container, Settings settings, ArtifactRepository localRepository,
                         EventDispatcher eventDispatcher, ReactorManager unused, List<String> goals,
                         String executionRootDir, Properties executionProperties, Properties userProperties,
                         Date startTime )
    {
        this.container = container;
        this.settings = settings;
        this.executionProperties = executionProperties;
        this.request = new DefaultMavenExecutionRequest();
        this.request.setUserProperties( userProperties );
        this.request.setLocalRepository( localRepository );
        this.request.setGoals( goals );
        this.request.setBaseDirectory( ( executionRootDir != null ) ? new File( executionRootDir ) : null );
        this.request.setStartTime( startTime );
    }
2451#@Deprecated
    public MavenSession( PlexusContainer container, MavenExecutionRequest request, MavenExecutionResult result,
                         List<MavenProject> projects )
    {
        this.container = container;
        this.request = request;
        this.result = result;
        this.settings = new SettingsAdapter( request );
        setProjects( projects );
    }
2452#public MavenSession( PlexusContainer container, RepositorySystemSession repositorySession, MavenExecutionRequest request,
                         MavenExecutionResult result )
    {
        this.container = container;
        this.request = request;
        this.result = result;
        this.settings = new SettingsAdapter( request );
        this.repositorySession = repositorySession;
    }
2453#public void setProjects( List<MavenProject> projects )
    {
        if ( !projects.isEmpty() )
        {
            this.currentProject = projects.get( 0 );
            this.topLevelProject = currentProject;
            for ( MavenProject project : projects )
            {
                if ( project.isExecutionRoot() )
                {
                    topLevelProject = project;
                    break;
                }
            }
        }
        else
        {
            this.currentProject = null;
            this.topLevelProject = null;
        }
        this.projects = projects;
    }
2454#@Deprecated
    public PlexusContainer getContainer()
    {
        return container;
    }
2455#@Deprecated
    public Object lookup( String role )
        throws ComponentLookupException
    {
        return container.lookup( role );
    }
2456#@Deprecated
    public Object lookup( String role, String roleHint )
        throws ComponentLookupException
    {
        return container.lookup( role, roleHint );
    }
2457#@Deprecated
    public List<Object> lookupList( String role )
        throws ComponentLookupException
    {
        return container.lookupList( role );
    }
2458#@Deprecated
    public Map<String, Object> lookupMap( String role )
        throws ComponentLookupException
    {
        return container.lookupMap( role );
    }
2459#@Deprecated
    public RepositoryCache getRepositoryCache()
    {
        return null;
    }
2460#public ArtifactRepository getLocalRepository()
    {
        return request.getLocalRepository();
    }
2461#public List<String> getGoals()
    {
        return request.getGoals();
    }
2462#/**
     * Gets the user properties to use for interpolation and profile activation. The user properties have been
     * configured directly by the user on his discretion, e.g. via the {@code -Dkey=value} parameter on the command
     * line.
     *
     * @return The user properties, never {@code null}.
     */
    public Properties getUserProperties()
    {
        return request.getUserProperties();
    }
2463#/**
     * Gets the system properties to use for interpolation and profile activation. The system properties are collected
     * from the runtime environment like {@link System#getProperties()} and environment variables.
     *
     * @return The system properties, never {@code null}.
     */
    public Properties getSystemProperties()
    {
        return request.getSystemProperties();
    }
2464#/**
     * @deprecated Use either {@link #getUserProperties()} or {@link #getSystemProperties()}.
     */
    @Deprecated
    public Properties getExecutionProperties()
    {
        if ( executionProperties == null )
        {
            executionProperties = new Properties();
            executionProperties.putAll( request.getSystemProperties() );
            executionProperties.putAll( request.getUserProperties() );
        }

        return executionProperties;
    }
2465#public Settings getSettings()
    {
        return settings;
    }
2466#public List<MavenProject> getProjects()
    {
        return projects;
    }
2467#@Deprecated
    public List<MavenProject> getSortedProjects()
    {
        return getProjects();
    }
2468#public String getExecutionRootDirectory()
    {
        return request.getBaseDirectory();
    }
2469#public boolean isUsingPOMsFromFilesystem()
    {
        return request.isProjectPresent();
    }
2470#public MavenExecutionRequest getRequest()
    {
        return request;
    }
2471#public void setCurrentProject( MavenProject currentProject )
    {
        this.currentProject = currentProject;
    }
2472#public MavenProject getCurrentProject()
    {
        return currentProject;
    }
2473#public ProjectBuildingRequest getProjectBuildingRequest()
    {
        return request.getProjectBuildingRequest().setRepositorySession( getRepositorySession() );
    }
2474#public List<String> getPluginGroups()
    {
        return request.getPluginGroups();
    }
2475#public boolean isOffline()
    {
        return request.isOffline();
    }
2476#public MavenProject getTopLevelProject()
    {
        return topLevelProject;
    }
2477#public MavenExecutionResult getResult()
    {
        return result;
    }
2478#// Backward compat

    public Map<String, Object> getPluginContext( PluginDescriptor plugin, MavenProject project )
    {
        String projectKey = project.getId();

        Map<String, Map<String, Object>> pluginContextsByKey = pluginContextsByProjectAndPluginKey.get( projectKey );

        if ( pluginContextsByKey == null )
        {
            pluginContextsByKey = new ConcurrentHashMap<String, Map<String, Object>>();

            pluginContextsByProjectAndPluginKey.put( projectKey, pluginContextsByKey );
        }

        String pluginKey = plugin.getPluginLookupKey();

        Map<String, Object> pluginContext = pluginContextsByKey.get( pluginKey );

        if ( pluginContext == null )
        {
            pluginContext = new ConcurrentHashMap<String, Object>();

            pluginContextsByKey.put( pluginKey, pluginContext );
        }

        return pluginContext;
    }
2479#public ProjectDependencyGraph getProjectDependencyGraph()
    {
        return projectDependencyGraph;
    }
2480#public void setProjectDependencyGraph( ProjectDependencyGraph projectDependencyGraph )
    {
        this.projectDependencyGraph = projectDependencyGraph;
    }
2481#public String getReactorFailureBehavior()
    {
        return request.getReactorFailureBehavior();
    }
2482#@Override
    public MavenSession clone()
    {
        try
        {
            return (MavenSession) super.clone();
        }
        catch ( CloneNotSupportedException e )
        {
            throw new RuntimeException( "Bug", e );
        }
    }
2483#private String getId( MavenProject project )
    {
        return project.getGroupId() + ':' + project.getArtifactId() + ':' + project.getVersion();
    }
2484#@Deprecated
    public EventDispatcher getEventDispatcher()
    {
        return null;
    }
2485#public Date getStartTime()
    {
        return request.getStartTime();
    }
2486#public boolean isParallel()
    {
        return parallel;
    }
2487#public void setParallel( boolean parallel )
    {
        this.parallel = parallel;
    }
2488#public RepositorySystemSession getRepositorySession()
    {
        return repositorySession;
    }
2489#/**
     * Creates a new build summary for the specified project.
     * 
     * @param project The project being summarized, must not be {@code null}.
     * @param time The build time of the project in milliseconds.
     */
    public BuildSuccess( MavenProject project, long time )
    {
        super( project, time );
    }
2490#/**
     * Creates a new build summary for the specified project.
     * 
     * @param project The project being summarized, must not be {@code null}.
     * @param time The build time of the project in milliseconds.
     * @param cause The cause of the build failure, may be {@code null}.
     */
    public BuildFailure( MavenProject project, long time, Throwable cause )
    {
        super( project, time );
        this.cause = cause;
    }
2491#/**
     * Gets the cause of the build failure.
     * 
     * @return The cause of the build failure or {@code null} if unknown.
     */
    public Throwable getCause()
    {
        return cause;
    }
2492#/**
     * Gets the type of the event.
     * 
     * @return The type of the event, never {@code null}.
     */
    Type getType();
2493#/**
     * Gets the session from which this event originates.
     * 
     * @return The current session, never {@code null}.
     */
    MavenSession getSession();
2494#/**
     * Gets the current project (if any).
     * 
     * @return The current project or {@code null} if not applicable.
     */
    MavenProject getProject();
2495#/**
     * Gets the current mojo execution (if any).
     * 
     * @return The current mojo execution or {@code null} if not applicable.
     */
    MojoExecution getMojoExecution();
2496#/**
     * Gets the exception that caused the event (if any).
     * 
     * @return The exception or {@code null} if none.
     */
    Exception getException();
2497#public MavenExecutionRequestPopulationException( String message )
    {
        super( message );
    }
2498#public MavenExecutionRequestPopulationException( Throwable cause )
    {
        super( cause );
    }
2499#public MavenExecutionRequestPopulationException( String message,
                                   Throwable cause )
    {
        super( message, cause );
    }
2500#public MavenExecutionRequest populateFromSettings( MavenExecutionRequest request, Settings settings )
        throws MavenExecutionRequestPopulationException
    {
        if ( settings == null )
        {
            return request;
        }

        request.setOffline( settings.isOffline() );

        request.setInteractiveMode( settings.isInteractiveMode() );

        request.setPluginGroups( settings.getPluginGroups() );

        request.setLocalRepositoryPath( settings.getLocalRepository() );

        for ( Server server : settings.getServers() )
        {
            server = server.clone();

            request.addServer( server );
        }

        //  <proxies>
        //    <proxy>
        //      <active>true</active>
        //      <protocol>http</protocol>
        //      <host>proxy.somewhere.com</host>
        //      <port>8080</port>
        //      <username>proxyuser</username>
        //      <password>somepassword</password>
        //      <nonProxyHosts>www.google.com|*.somewhere.com</nonProxyHosts>
        //    </proxy>
        //  </proxies>

        for ( Proxy proxy : settings.getProxies() )
        {
            if ( !proxy.isActive() )
            {
                continue;
            }

            proxy = proxy.clone();

            request.addProxy( proxy );
        }

        // <mirrors>
        //   <mirror>
        //     <id>nexus</id>
        //     <mirrorOf>*</mirrorOf>
        //     <url>http://repository.sonatype.org/content/groups/public</url>
        //   </mirror>
        // </mirrors>

        for ( Mirror mirror : settings.getMirrors() )
        {
            mirror = mirror.clone();

            request.addMirror( mirror );
        }

        request.setActiveProfiles( settings.getActiveProfiles() );

        for ( org.apache.maven.settings.Profile rawProfile : settings.getProfiles() )
        {
            request.addProfile( SettingsUtils.convertFromSettingsProfile( rawProfile ) );
        }

        return request;
    }
2501#private void populateDefaultPluginGroups( MavenExecutionRequest request )
    {
        request.addPluginGroup( "org.apache.maven.plugins" );
        request.addPluginGroup( "org.codehaus.mojo" );
    }
2502#private void injectDefaultRepositories( MavenExecutionRequest request )
        throws MavenExecutionRequestPopulationException
    {
        Set<String> definedRepositories = getRepoIds( request.getRemoteRepositories() );

        if ( !definedRepositories.contains( RepositorySystem.DEFAULT_REMOTE_REPO_ID ) )
        {
            try
            {
                request.addRemoteRepository( repositorySystem.createDefaultRemoteRepository() );
            }
            catch ( InvalidRepositoryException e )
            {
                throw new MavenExecutionRequestPopulationException( "Cannot create default remote repository.", e );
            }
        }
    }
2503#private void injectDefaultPluginRepositories( MavenExecutionRequest request )
        throws MavenExecutionRequestPopulationException
    {
        Set<String> definedRepositories = getRepoIds( request.getPluginArtifactRepositories() );

        if ( !definedRepositories.contains( RepositorySystem.DEFAULT_REMOTE_REPO_ID ) )
        {
            try
            {
                request.addPluginArtifactRepository( repositorySystem.createDefaultRemoteRepository() );
            }
            catch ( InvalidRepositoryException e )
            {
                throw new MavenExecutionRequestPopulationException( "Cannot create default remote repository.", e );
            }
        }
    }
2504#private Set<String> getRepoIds( List<ArtifactRepository> repositories )
    {
        Set<String> repoIds = new HashSet<String>();

        if ( repositories != null )
        {
            for ( ArtifactRepository repository : repositories )
            {
                repoIds.add( repository.getId() );
            }
        }

        return repoIds;
    }
2505#private void processRepositoriesInSettings( MavenExecutionRequest request )
        throws MavenExecutionRequestPopulationException
    {
        repositorySystem.injectMirror( request.getRemoteRepositories(), request.getMirrors() );
        repositorySystem.injectProxy( request.getRemoteRepositories(), request.getProxies() );
        repositorySystem.injectAuthentication( request.getRemoteRepositories(), request.getServers() );

        request.setRemoteRepositories( repositorySystem.getEffectiveRepositories( request.getRemoteRepositories() ) );

        repositorySystem.injectMirror( request.getPluginArtifactRepositories(), request.getMirrors() );
        repositorySystem.injectProxy( request.getPluginArtifactRepositories(), request.getProxies() );
        repositorySystem.injectAuthentication( request.getPluginArtifactRepositories(), request.getServers() );

        request.setPluginArtifactRepositories( repositorySystem.getEffectiveRepositories( request.getPluginArtifactRepositories() ) );
    }
2506#private void localRepository( MavenExecutionRequest request )
        throws MavenExecutionRequestPopulationException
    {
        // ------------------------------------------------------------------------
        // Local Repository
        //
        // 1. Use a value has been passed in via the configuration
        // 2. Use value in the resultant settings
        // 3. Use default value
        // ------------------------------------------------------------------------

        if ( request.getLocalRepository() == null )
        {
            request.setLocalRepository( createLocalRepository( request ) );
        }

        if ( request.getLocalRepositoryPath() == null )
        {
            request.setLocalRepositoryPath( new File( request.getLocalRepository().getBasedir() ).getAbsoluteFile() );
        }
    }
2507#// ------------------------------------------------------------------------
    // Artifact Transfer Mechanism
    // ------------------------------------------------------------------------

    public ArtifactRepository createLocalRepository( MavenExecutionRequest request )
        throws MavenExecutionRequestPopulationException
    {
        String localRepositoryPath = null;

        if ( request.getLocalRepositoryPath() != null )
        {
            localRepositoryPath = request.getLocalRepositoryPath().getAbsolutePath();
        }

        if ( StringUtils.isEmpty( localRepositoryPath ) )
        {
            localRepositoryPath = RepositorySystem.defaultUserLocalRepository.getAbsolutePath();
        }

        try
        {
            return repositorySystem.createLocalRepository( new File( localRepositoryPath ) );
        }
        catch ( InvalidRepositoryException e )
        {
            throw new MavenExecutionRequestPopulationException( "Cannot create local repository.", e );
        }
    }
2508#private void baseDirectory( MavenExecutionRequest request )
    {
        if ( request.getBaseDirectory() == null )
        {
            if ( request.getPom() != null )
            {
                request.setBaseDirectory( request.getPom().getAbsoluteFile().getParentFile() );
            }
        }
    }
2509#public MavenExecutionRequest populateDefaults( MavenExecutionRequest request )
        throws MavenExecutionRequestPopulationException
    {
        baseDirectory( request );

        localRepository( request );

        populateDefaultPluginGroups( request );

        injectDefaultRepositories( request );

        injectDefaultPluginRepositories( request );

        processRepositoriesInSettings( request );

        return request;
    }
2510#void projectDiscoveryStarted( ExecutionEvent event );
2511#void sessionStarted( ExecutionEvent event );
2512#void sessionEnded( ExecutionEvent event );
2513#void projectSkipped( ExecutionEvent event );
2514#void projectStarted( ExecutionEvent event );
2515#void projectSucceeded( ExecutionEvent event );
2516#void projectFailed( ExecutionEvent event );
2517#void mojoSkipped( ExecutionEvent event );
2518#void mojoStarted( ExecutionEvent event );
2519#void mojoSucceeded( ExecutionEvent event );
2520#void mojoFailed( ExecutionEvent event );
2521#void forkStarted( ExecutionEvent event );
2522#void forkSucceeded( ExecutionEvent event );
2523#void forkFailed( ExecutionEvent event );
2524#void forkedProjectStarted( ExecutionEvent event );
2525#void forkedProjectSucceeded( ExecutionEvent event );
2526#void forkedProjectFailed( ExecutionEvent event );
2527#/**
     * Creates a new build summary for the specified project.
     * 
     * @param project The project being summarized, must not be {@code null}.
     * @param time The build time of the project in milliseconds.
     */
    protected BuildSummary( MavenProject project, long time )
    {
        if ( project == null )
        {
            throw new IllegalArgumentException( "project missing" );
        }
        this.project = project;
        this.time = time;
    }
2528#/**
     * Gets the project being summarized.
     * 
     * @return The project being summarized, never {@code null}.
     */
    public MavenProject getProject()
    {
        return project;
    }
2529#/**
     * Gets the build time of the project in milliseconds.
     * 
     * @return The build time of the project in milliseconds.
     */
    public long getTime()
    {
        return time;
    }
2530#public MavenExecutionResult setProject( MavenProject project )
    {
        this.project = project;

        return this;
    }
2531#public MavenProject getProject()
    {
        return project;
    }
2532#public MavenExecutionResult setTopologicallySortedProjects( List<MavenProject> topologicallySortedProjects )
    {
        this.topologicallySortedProjects = topologicallySortedProjects;

        return this;
    }
2533#public List<MavenProject> getTopologicallySortedProjects()
    {
        return null == topologicallySortedProjects ? Collections.<MavenProject> emptyList() : topologicallySortedProjects;
    }
2534#public DependencyResolutionResult getDependencyResolutionResult()
    {
        return dependencyResolutionResult;
    }
2535#public MavenExecutionResult setDependencyResolutionResult( DependencyResolutionResult dependencyResolutionResult )
    {
        this.dependencyResolutionResult = dependencyResolutionResult;

        return this;
    }
2536#public List<Throwable> getExceptions()
    {
        return exceptions == null ? Collections.<Throwable> emptyList() : exceptions;
    }
2537#public MavenExecutionResult addException( Throwable t )
    {
        exceptions.add( t );

        return this;
    }
2538#public boolean hasExceptions()
    {
        return !getExceptions().isEmpty();
    }
2539#public BuildSummary getBuildSummary( MavenProject project )
    {
        return ( buildSummaries != null ) ? buildSummaries.get( project ) : null;
    }
2540#public void addBuildSummary( BuildSummary summary )
    {
        if ( buildSummaries == null )
        {
            buildSummaries = new IdentityHashMap<MavenProject, BuildSummary>();
        }
        buildSummaries.put( summary.getProject(), summary );
    }
2541#/**
     * Copies the values from the given settings into the specified execution request. This method will replace any
     * existing values in the execution request that are controlled by the settings. Hence, it is expected that this
     * method is called on a new/empty execution request before the caller mutates it to fit its needs.
     * 
     * @param request The execution request to populate, must not be {@code null}.
     * @param settings The settings to copy into the execution request, may be {@code null}.
     * @return The populated execution request, never {@code null}.
     * @throws MavenExecutionRequestPopulationException If the execution request could not be populated.
     */
    MavenExecutionRequest populateFromSettings( MavenExecutionRequest request, Settings settings )
        throws MavenExecutionRequestPopulationException;
2542#/**
     * Injects default values like plugin groups or repositories into the specified execution request.
     * 
     * @param request The execution request to populate, must not be {@code null}.
     * @return The populated execution request, never {@code null}.
     * @throws MavenExecutionRequestPopulationException If the execution request could not be populated.
     */
    MavenExecutionRequest populateDefaults( MavenExecutionRequest request )
        throws MavenExecutionRequestPopulationException;
2543#public void projectDiscoveryStarted( ExecutionEvent event )
    {
        // default does nothing
    }
2544#public void sessionStarted( ExecutionEvent event )
    {
        // default does nothing
    }
2545#public void sessionEnded( ExecutionEvent event )
    {
        // default does nothing
    }
2546#public void projectSkipped( ExecutionEvent event )
    {
        // default does nothing
    }
2547#public void projectStarted( ExecutionEvent event )
    {
        // default does nothing
    }
2548#public void projectSucceeded( ExecutionEvent event )
    {
        // default does nothing
    }
2549#public void projectFailed( ExecutionEvent event )
    {
        // default does nothing
    }
2550#public void forkStarted( ExecutionEvent event )
    {
        // default does nothing
    }
2551#public void forkSucceeded( ExecutionEvent event )
    {
        // default does nothing
    }
2552#public void forkFailed( ExecutionEvent event )
    {
        // default does nothing
    }
2553#public void mojoSkipped( ExecutionEvent event )
    {
        // default does nothing
    }
2554#public void mojoStarted( ExecutionEvent event )
    {
        // default does nothing
    }
2555#public void mojoSucceeded( ExecutionEvent event )
    {
        // default does nothing
    }
2556#public void mojoFailed( ExecutionEvent event )
    {
        // default does nothing
    }
2557#public void forkedProjectStarted( ExecutionEvent event )
    {
        // default does nothing
    }
2558#public void forkedProjectSucceeded( ExecutionEvent event )
    {
        // default does nothing
    }
2559#public void forkedProjectFailed( ExecutionEvent event )
    {
        // default does nothing
    }
2560#public SettingsAdapter( MavenExecutionRequest request )
    {
        this.request = request;

        /*
         * NOTE: Plugins like maven-release-plugin query the path to the settings.xml to pass it into a forked Maven and
         * the CLI will fail when called with a non-existing settings, so be sure to only point at actual files. Having
         * a null file should be harmless as this case matches general Maven 2.x behavior...
         */
        File userSettings = request.getUserSettingsFile();
        this.runtimeInfo = new RuntimeInfo( ( userSettings != null && userSettings.isFile() ) ? userSettings : null );
    }
2561#@Override
    public String getLocalRepository()
    {
        if ( request.getLocalRepositoryPath() != null )
        {
            return request.getLocalRepositoryPath().getAbsolutePath();
        }

        return null;
    }
2562#@Override
    public boolean isInteractiveMode()
    {
        return request.isInteractiveMode();
    }
2563#@Override
    public boolean isOffline()
    {
        return request.isOffline();
    }
2564#@Override
    public List<Proxy> getProxies()
    {
        return request.getProxies();
    }
2565#@Override
    public List<Server> getServers()
    {
        return request.getServers();
    }
2566#@Override
    public List<Mirror> getMirrors()
    {
        return request.getMirrors();
    }
2567#@Override
    public List<Profile> getProfiles()
    {
        List<Profile> result = new ArrayList<Profile>();
        for ( org.apache.maven.model.Profile profile : request.getProfiles() )
        {
            result.add( SettingsUtils.convertToSettingsProfile( profile ) );
        }
        return result;
    }
2568#@Override
    public List<String> getActiveProfiles()
    {
        return request.getActiveProfiles();
    }
2569#@Override
    public List<String> getPluginGroups()
    {
        return request.getPluginGroups();
    }
2570#@Override
    public RuntimeInfo getRuntimeInfo()
    {
        return runtimeInfo;
    }
2571#// ----------------------------------------------------------------------
    //
    // ----------------------------------------------------------------------

    // Base directory
    MavenExecutionRequest setBaseDirectory( File basedir );
2572#String getBaseDirectory();
2573#// Timing (remove this)
    MavenExecutionRequest setStartTime( Date start );
2574#Date getStartTime();
2575#// Goals
    MavenExecutionRequest setGoals( List<String> goals );
2576#List<String> getGoals();
2577#// Properties

    /**
     * Sets the system properties to use for interpolation and profile activation. The system properties are collected
     * from the runtime environment like {@link System#getProperties()} and environment variables.
     *
     * @param systemProperties The system properties, may be {@code null}.
     * @return This request, never {@code null}.
     */
    MavenExecutionRequest setSystemProperties( Properties systemProperties );
2578#/**
     * Gets the system properties to use for interpolation and profile activation. The system properties are collected
     * from the runtime environment like {@link System#getProperties()} and environment variables.
     *
     * @return The system properties, never {@code null}.
     */
    Properties getSystemProperties();
2579#/**
     * Sets the user properties to use for interpolation and profile activation. The user properties have been
     * configured directly by the user on his discretion, e.g. via the {@code -Dkey=value} parameter on the command
     * line.
     *
     * @param userProperties The user properties, may be {@code null}.
     * @return This request, never {@code null}.
     */
    MavenExecutionRequest setUserProperties( Properties userProperties );
2580#/**
     * Gets the user properties to use for interpolation and profile activation. The user properties have been
     * configured directly by the user on his discretion, e.g. via the {@code -Dkey=value} parameter on the command
     * line.
     *
     * @return The user properties, never {@code null}.
     */
    Properties getUserProperties();
2581#// Reactor
    MavenExecutionRequest setReactorFailureBehavior( String failureBehavior );
2582#String getReactorFailureBehavior();
2583#MavenExecutionRequest setSelectedProjects( List<String> projects );
2584#List<String> getSelectedProjects();
2585#MavenExecutionRequest setResumeFrom( String project );
2586#String getResumeFrom();
2587#MavenExecutionRequest setMakeBehavior( String makeBehavior );
2588#String getMakeBehavior();
2589#void setThreadCount( String threadCount );
2590#String getThreadCount();
2591#boolean isThreadConfigurationPresent();
2592#void setPerCoreThreadCount( boolean perCoreThreadCount );
2593#boolean isPerCoreThreadCount();
2594#// Recursive (really to just process the top-level POM)
    MavenExecutionRequest setRecursive( boolean recursive );
2595#boolean isRecursive();
2596#MavenExecutionRequest setPom( File pom );
2597#File getPom();
2598#// Errors
    MavenExecutionRequest setShowErrors( boolean showErrors );
2599#boolean isShowErrors();
2600#// Transfer listeners
    MavenExecutionRequest setTransferListener( TransferListener transferListener );
2601#TransferListener getTransferListener();
2602#// Logging
    MavenExecutionRequest setLoggingLevel( int loggingLevel );
2603#int getLoggingLevel();
2604#// Update snapshots
    MavenExecutionRequest setUpdateSnapshots( boolean updateSnapshots );
2605#boolean isUpdateSnapshots();
2606#MavenExecutionRequest setNoSnapshotUpdates( boolean noSnapshotUpdates );
2607#boolean isNoSnapshotUpdates();
2608#// Checksum policy
    MavenExecutionRequest setGlobalChecksumPolicy( String globalChecksumPolicy );
2609#String getGlobalChecksumPolicy();
2610#// Local repository
    MavenExecutionRequest setLocalRepositoryPath( String localRepository );
2611#MavenExecutionRequest setLocalRepositoryPath( File localRepository );
2612#File getLocalRepositoryPath();
2613#MavenExecutionRequest setLocalRepository( ArtifactRepository repository );
2614#ArtifactRepository getLocalRepository();
2615#// Interactive
    MavenExecutionRequest setInteractiveMode( boolean interactive );
2616#boolean isInteractiveMode();
2617#// Offline
    MavenExecutionRequest setOffline( boolean offline );
2618#boolean isOffline();
2619#boolean isCacheTransferError();
2620#MavenExecutionRequest setCacheTransferError( boolean cacheTransferError );
2621#boolean isCacheNotFound();
2622#MavenExecutionRequest setCacheNotFound( boolean cacheNotFound );
2623#// Profiles
    List<Profile> getProfiles();
2624#MavenExecutionRequest addProfile( Profile profile );
2625#MavenExecutionRequest setProfiles( List<Profile> profiles );
2626#MavenExecutionRequest addActiveProfile( String profile );
2627#MavenExecutionRequest addActiveProfiles( List<String> profiles );
2628#MavenExecutionRequest setActiveProfiles( List<String> profiles );
2629#List<String> getActiveProfiles();
2630#MavenExecutionRequest addInactiveProfile( String profile );
2631#MavenExecutionRequest addInactiveProfiles( List<String> profiles );
2632#MavenExecutionRequest setInactiveProfiles( List<String> profiles );
2633#List<String> getInactiveProfiles();
2634#// Proxies
    List<Proxy> getProxies();
2635#MavenExecutionRequest setProxies( List<Proxy> proxies );
2636#MavenExecutionRequest addProxy( Proxy proxy );
2637#// Servers
    List<Server> getServers();
2638#MavenExecutionRequest setServers( List<Server> servers );
2639#MavenExecutionRequest addServer( Server server );
2640#// Mirrors
    List<Mirror> getMirrors();
2641#MavenExecutionRequest setMirrors( List<Mirror> mirrors );
2642#MavenExecutionRequest addMirror( Mirror mirror );
2643#// Plugin groups
    List<String> getPluginGroups();
2644#MavenExecutionRequest setPluginGroups( List<String> pluginGroups );
2645#MavenExecutionRequest addPluginGroup( String pluginGroup );
2646#MavenExecutionRequest addPluginGroups( List<String> pluginGroups );
2647#boolean isProjectPresent();
2648#MavenExecutionRequest setProjectPresent( boolean isProjectPresent );
2649#File getUserSettingsFile();
2650#MavenExecutionRequest setUserSettingsFile( File userSettingsFile );
2651#File getGlobalSettingsFile();
2652#MavenExecutionRequest setGlobalSettingsFile( File globalSettingsFile );
2653#MavenExecutionRequest addRemoteRepository( ArtifactRepository repository );
2654#MavenExecutionRequest addPluginArtifactRepository( ArtifactRepository repository );
2655#/**
     * Set a new list of remote repositories to use the execution request. This is necessary if you perform
     * transformations on the remote repositories being used. For example if you replace existing repositories with
     * mirrors then it's easier to just replace the whole list with a new list of transformed repositories.
     *
     * @param repositories
     * @return
     */
    MavenExecutionRequest setRemoteRepositories( List<ArtifactRepository> repositories );
2656#List<ArtifactRepository> getRemoteRepositories();
2657#MavenExecutionRequest setPluginArtifactRepositories( List<ArtifactRepository> repositories );
2658#List<ArtifactRepository> getPluginArtifactRepositories();
2659#MavenExecutionRequest setRepositoryCache( RepositoryCache repositoryCache );
2660#RepositoryCache getRepositoryCache();
2661#WorkspaceReader getWorkspaceReader();
2662#MavenExecutionRequest setWorkspaceReader( WorkspaceReader workspaceReader );
2663#File getUserToolchainsFile();
2664#MavenExecutionRequest setUserToolchainsFile( File userToolchainsFile );
2665#ExecutionListener getExecutionListener();
2666#MavenExecutionRequest setExecutionListener( ExecutionListener executionListener );
2667#ProjectBuildingRequest getProjectBuildingRequest();
2668#public ReactorManager( List projects )
        throws CycleDetectedException, DuplicateProjectException
    {
        this.sorter = new ProjectSorter( projects );
    }
2669#public Map getPluginContext( PluginDescriptor plugin, MavenProject project )
    {
        Map pluginContextsByKey = (Map) pluginContextsByProjectAndPluginKey.get( project.getId() );

        if ( pluginContextsByKey == null )
        {
            pluginContextsByKey = new HashMap();
            pluginContextsByProjectAndPluginKey.put( project.getId(), pluginContextsByKey );
        }

        Map pluginContext = (Map) pluginContextsByKey.get( plugin.getPluginLookupKey() );

        if ( pluginContext == null )
        {
            pluginContext = new HashMap();
            pluginContextsByKey.put( plugin.getPluginLookupKey(), pluginContext );
        }

        return pluginContext;
    }
2670#public void setFailureBehavior( String failureBehavior )
    {
        if ( failureBehavior == null )
        {
            this.failureBehavior = FAIL_FAST; // default
            return;
        }
        if ( FAIL_FAST.equals( failureBehavior ) || FAIL_AT_END.equals( failureBehavior )
            || FAIL_NEVER.equals( failureBehavior ) )
        {
            this.failureBehavior = failureBehavior;
        }
        else
        {
            throw new IllegalArgumentException( "Invalid failure behavior (must be one of: \'" + FAIL_FAST + "\', \'"
                + FAIL_AT_END + "\', \'" + FAIL_NEVER + "\')." );
        }
    }
2671#public String getFailureBehavior()
    {
        return failureBehavior;
    }
2672#public void blackList( MavenProject project )
    {
        blackList( getProjectKey( project ) );
    }
2673#private void blackList( String id )
    {
        if ( !blackList.contains( id ) )
        {
            blackList.add( id );

            List dependents = sorter.getDependents( id );

            if ( dependents != null && !dependents.isEmpty() )
            {
                for ( Iterator it = dependents.iterator(); it.hasNext(); )
                {
                    String dependentId = (String) it.next();

                    if ( !buildSuccessesByProject.containsKey( dependentId )
                        && !buildFailuresByProject.containsKey( dependentId ) )
                    {
                        blackList( dependentId );
                    }
                }
            }
        }
    }
2674#public boolean isBlackListed( MavenProject project )
    {
        return blackList.contains( getProjectKey( project ) );
    }
2675#private static String getProjectKey( MavenProject project )
    {
        return ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() );
    }
2676#public void registerBuildFailure( MavenProject project, Exception error, String task, long time )
    {
        buildFailuresByProject.put( getProjectKey( project ), new BuildFailure( project, time, error ) );
    }
2677#public boolean hasBuildFailures()
    {
        return !buildFailuresByProject.isEmpty();
    }
2678#public boolean hasBuildFailure( MavenProject project )
    {
        return buildFailuresByProject.containsKey( getProjectKey( project ) );
    }
2679#public boolean hasMultipleProjects()
    {
        return sorter.hasMultipleProjects();
    }
2680#public List<MavenProject> getSortedProjects()
    {
        return sorter.getSortedProjects();
    }
2681#public MavenProject getTopLevelProject()
    {
        return sorter.getTopLevelProject();
    }
2682#public boolean hasBuildSuccess( MavenProject project )
    {
        return buildSuccessesByProject.containsKey( getProjectKey( project ) );
    }
2683#public void registerBuildSuccess( MavenProject project, long time )
    {
        buildSuccessesByProject.put( getProjectKey( project ), new BuildSuccess( project, time ) );
    }
2684#public BuildFailure getBuildFailure( MavenProject project )
    {
        return (BuildFailure) buildFailuresByProject.get( getProjectKey( project ) );
    }
2685#public BuildSuccess getBuildSuccess( MavenProject project )
    {
        return (BuildSuccess) buildSuccessesByProject.get( getProjectKey( project ) );
    }
2686#public boolean executedMultipleProjects()
    {
        return buildFailuresByProject.size() + buildSuccessesByProject.size() > 1;
    }
2687#MavenExecutionResult setProject( MavenProject project );
2688#MavenProject getProject();
2689#MavenExecutionResult setTopologicallySortedProjects( List<MavenProject> projects );
2690#/**
     * @return the sorted list, or an empty list if there are no projects.
     */
    List<MavenProject> getTopologicallySortedProjects();
2691#MavenExecutionResult setDependencyResolutionResult( DependencyResolutionResult result );
2692#DependencyResolutionResult getDependencyResolutionResult();
2693#// for each exception
    // - knowing what artifacts are missing
    // - project building exception
    // - invalid project model exception: list of markers
    // - xmlpull parser exception
    List<Throwable> getExceptions();
2694#MavenExecutionResult addException( Throwable e );
2695#boolean hasExceptions();
2696#/**
     * Gets the build summary for the specified project.
     *
     * @param project The project to get the build summary for, must not be {@code null}.
     * @return The build summary for the project or {@code null} if the project has not been built (yet).
     */
    BuildSummary getBuildSummary( MavenProject project );
2697#/**
     * Add the specified build summary.
     *
     * @param summary The build summary to add, must not be {@code null}.
     */
    void addBuildSummary( BuildSummary summary );
2698#public DefaultMavenExecutionRequest()
    {
    }
2699#public static MavenExecutionRequest copy( MavenExecutionRequest original )
    {
        DefaultMavenExecutionRequest copy = new DefaultMavenExecutionRequest();
        copy.setLocalRepository( original.getLocalRepository() );
        copy.setLocalRepositoryPath( original.getLocalRepositoryPath() );
        copy.setOffline( original.isOffline() );
        copy.setInteractiveMode( original.isInteractiveMode() );
        copy.setCacheNotFound( original.isCacheNotFound() );
        copy.setCacheTransferError( original.isCacheTransferError() );
        copy.setProxies( original.getProxies() );
        copy.setServers( original.getServers() );
        copy.setMirrors( original.getMirrors() );
        copy.setProfiles( original.getProfiles() );
        copy.setPluginGroups( original.getPluginGroups() );
        copy.setProjectPresent( original.isProjectPresent() );
        copy.setUserSettingsFile( original.getUserSettingsFile() );
        copy.setGlobalSettingsFile( original.getGlobalSettingsFile() );
        copy.setUserToolchainsFile( original.getUserToolchainsFile() );
        copy.setBaseDirectory( ( original.getBaseDirectory() != null )
                               ? new File( original.getBaseDirectory() ) : null );
        copy.setGoals( original.getGoals() );
        copy.setRecursive( original.isRecursive() );
        copy.setPom( original.getPom() );
        copy.setSystemProperties( original.getSystemProperties() );
        copy.setUserProperties( original.getUserProperties() );
        copy.setShowErrors( original.isShowErrors() );
        copy.setActiveProfiles( original.getActiveProfiles() );
        copy.setInactiveProfiles( original.getInactiveProfiles() );
        copy.setTransferListener( original.getTransferListener() );
        copy.setLoggingLevel( original.getLoggingLevel() );
        copy.setGlobalChecksumPolicy( original.getGlobalChecksumPolicy() );
        copy.setUpdateSnapshots( original.isUpdateSnapshots() );
        copy.setRemoteRepositories( original.getRemoteRepositories() );
        copy.setPluginArtifactRepositories( original.getPluginArtifactRepositories() );
        copy.setRepositoryCache( original.getRepositoryCache() );
        copy.setWorkspaceReader( original.getWorkspaceReader() );
        copy.setNoSnapshotUpdates( original.isNoSnapshotUpdates() );
        copy.setExecutionListener( original.getExecutionListener() );
        return copy;
    }
2700#public String getBaseDirectory()
    {
        if ( basedir == null )
        {
            return null;
        }

        return basedir.getAbsolutePath();
    }
2701#public ArtifactRepository getLocalRepository()
    {
        return localRepository;
    }
2702#public File getLocalRepositoryPath()
    {
        return localRepositoryPath;
    }
2703#public List<String> getGoals()
    {
        if ( goals == null )
        {
            goals = new ArrayList<String>();
        }
        return goals;
    }
2704#public Properties getSystemProperties()
    {
        if ( systemProperties == null )
        {
            systemProperties = new Properties();
        }

        return systemProperties;
    }
2705#public Properties getUserProperties()
    {
        if ( userProperties == null )
        {
            userProperties = new Properties();
        }

        return userProperties;
    }
2706#public File getPom()
    {
        return pom;
    }
2707#public String getReactorFailureBehavior()
    {
        return reactorFailureBehavior;
    }
2708#public List<String> getSelectedProjects()
    {
        if ( selectedProjects == null )
        {
            selectedProjects = new ArrayList<String>();
        }

        return selectedProjects;
    }
2709#public String getResumeFrom()
    {
        return resumeFrom;
    }
2710#public String getMakeBehavior()
    {
        return makeBehavior;
    }
2711#public Date getStartTime()
    {
        return startTime;
    }
2712#public boolean isShowErrors()
    {
        return showErrors;
    }
2713#public boolean isInteractiveMode()
    {
        return interactiveMode;
    }
2714#public MavenExecutionRequest setActiveProfiles( List<String> activeProfiles )
    {
        if ( activeProfiles != null )
        {
            this.activeProfiles = new ArrayList<String>( activeProfiles );
        }
        else
        {
            this.activeProfiles = null;
        }

        return this;
    }
2715#public MavenExecutionRequest setInactiveProfiles( List<String> inactiveProfiles )
    {
        if ( inactiveProfiles != null )
        {
            this.inactiveProfiles = new ArrayList<String>( inactiveProfiles );
        }
        else
        {
            this.inactiveProfiles = null;
        }

        return this;
    }
2716#public MavenExecutionRequest setRemoteRepositories( List<ArtifactRepository> remoteRepositories )
    {
        if ( remoteRepositories != null )
        {
            this.remoteRepositories = new ArrayList<ArtifactRepository>( remoteRepositories );
        }
        else
        {
            this.remoteRepositories = null;
        }

        return this;
    }
2717#public MavenExecutionRequest setPluginArtifactRepositories( List<ArtifactRepository> pluginArtifactRepositories )
    {
        if ( pluginArtifactRepositories != null )
        {
            this.pluginArtifactRepositories = new ArrayList<ArtifactRepository>( pluginArtifactRepositories );
        }
        else
        {
            this.pluginArtifactRepositories = null;
        }

        return this;
    }
2718#public void setProjectBuildingConfiguration( ProjectBuildingRequest projectBuildingConfiguration )
    {
        this.projectBuildingRequest = projectBuildingConfiguration;
    }
2719#public List<String> getActiveProfiles()
    {
        if ( activeProfiles == null )
        {
            activeProfiles = new ArrayList<String>();
        }
        return activeProfiles;
    }
2720#public List<String> getInactiveProfiles()
    {
        if ( inactiveProfiles == null )
        {
            inactiveProfiles = new ArrayList<String>();
        }
        return inactiveProfiles;
    }
2721#public TransferListener getTransferListener()
    {
        return transferListener;
    }
2722#public int getLoggingLevel()
    {
        return loggingLevel;
    }
2723#public boolean isOffline()
    {
        return offline;
    }
2724#public boolean isUpdateSnapshots()
    {
        return updateSnapshots;
    }
2725#public boolean isNoSnapshotUpdates()
    {
        return noSnapshotUpdates;
    }
2726#public String getGlobalChecksumPolicy()
    {
        return globalChecksumPolicy;
    }
2727#public boolean isRecursive()
    {
        return recursive;
    }
2728#// ----------------------------------------------------------------------
    //
    // ----------------------------------------------------------------------

    public MavenExecutionRequest setBaseDirectory( File basedir )
    {
        this.basedir = basedir;

        return this;
    }
2729#public MavenExecutionRequest setStartTime( Date startTime )
    {
        this.startTime = startTime;

        return this;
    }
2730#public MavenExecutionRequest setShowErrors( boolean showErrors )
    {
        this.showErrors = showErrors;

        return this;
    }
2731#public MavenExecutionRequest setGoals( List<String> goals )
    {
        if ( goals != null )
        {
            this.goals = new ArrayList<String>( goals );
        }
        else
        {
            this.goals = null;
        }

        return this;
    }
2732#public MavenExecutionRequest setLocalRepository( ArtifactRepository localRepository )
    {
        this.localRepository = localRepository;

        if ( localRepository != null )
        {
            setLocalRepositoryPath( new File( localRepository.getBasedir() ).getAbsoluteFile() );
        }

        return this;
    }
2733#public MavenExecutionRequest setLocalRepositoryPath( File localRepository )
    {
        localRepositoryPath = localRepository;

        return this;
    }
2734#public MavenExecutionRequest setLocalRepositoryPath( String localRepository )
    {
        localRepositoryPath = ( localRepository != null ) ? new File( localRepository ) : null;

        return this;
    }
2735#public MavenExecutionRequest setSystemProperties( Properties properties )
    {
        if ( properties != null )
        {
            this.systemProperties = new Properties();
            this.systemProperties.putAll( properties );
        }
        else
        {
            this.systemProperties = null;
        }

        return this;
    }
2736#public MavenExecutionRequest setUserProperties( Properties userProperties )
    {
        if ( userProperties != null )
        {
            this.userProperties = new Properties();
            this.userProperties.putAll( userProperties );
        }
        else
        {
            this.userProperties = null;
        }

        return this;
    }
2737#public MavenExecutionRequest setReactorFailureBehavior( String failureBehavior )
    {
        reactorFailureBehavior = failureBehavior;

        return this;
    }
2738#public MavenExecutionRequest setSelectedProjects( List<String> selectedProjects )
    {
        if ( selectedProjects != null )
        {
            this.selectedProjects = new ArrayList<String>( selectedProjects );
        }
        else
        {
            this.selectedProjects = null;
        }

        return this;
    }
2739#public MavenExecutionRequest setResumeFrom( String project )
    {
        this.resumeFrom = project;

        return this;
    }
2740#public MavenExecutionRequest setMakeBehavior( String makeBehavior )
    {
        this.makeBehavior = makeBehavior;

        return this;
    }
2741#public MavenExecutionRequest addActiveProfile( String profile )
    {
        if ( !getActiveProfiles().contains( profile ) )
        {
            getActiveProfiles().add( profile );
        }

        return this;
    }
2742#public MavenExecutionRequest addInactiveProfile( String profile )
    {
        if ( !getInactiveProfiles().contains( profile ) )
        {
            getInactiveProfiles().add( profile );
        }

        return this;
    }
2743#public MavenExecutionRequest addActiveProfiles( List<String> profiles )
    {
        for ( String profile : profiles )
        {
            addActiveProfile( profile );
        }

        return this;
    }
2744#public MavenExecutionRequest addInactiveProfiles( List<String> profiles )
    {
        for ( String profile : profiles )
        {
            addInactiveProfile( profile );
        }

        return this;
    }
2745#public MavenExecutionRequest setUseReactor( boolean reactorActive )
    {
        useReactor = reactorActive;

        return this;
    }
2746#public boolean useReactor()
    {
        return useReactor;
    }
2747#/** @deprecated use {@link #setPom(File)} */
    public MavenExecutionRequest setPomFile( String pomFilename )
    {
        if ( pomFilename != null )
        {
            pom = new File( pomFilename );
        }

        return this;
    }
2748#public MavenExecutionRequest setPom( File pom )
    {
        this.pom = pom;

        return this;
    }
2749#public MavenExecutionRequest setInteractiveMode( boolean interactive )
    {
        interactiveMode = interactive;

        return this;
    }
2750#public MavenExecutionRequest setTransferListener( TransferListener transferListener )
    {
        this.transferListener = transferListener;

        return this;
    }
2751#public MavenExecutionRequest setLoggingLevel( int loggingLevel )
    {
        this.loggingLevel = loggingLevel;

        return this;
    }
2752#public MavenExecutionRequest setOffline( boolean offline )
    {
        this.offline = offline;

        return this;
    }
2753#public MavenExecutionRequest setUpdateSnapshots( boolean updateSnapshots )
    {
        this.updateSnapshots = updateSnapshots;

        return this;
    }
2754#public MavenExecutionRequest setNoSnapshotUpdates( boolean noSnapshotUpdates )
    {
        this.noSnapshotUpdates = noSnapshotUpdates;

        return this;
    }
2755#public MavenExecutionRequest setGlobalChecksumPolicy( String globalChecksumPolicy )
    {
        this.globalChecksumPolicy = globalChecksumPolicy;

        return this;
    }
2756#// ----------------------------------------------------------------------------
    // Settings equivalents
    // ----------------------------------------------------------------------------

    public List<Proxy> getProxies()
    {
        if ( proxies == null )
        {
            proxies = new ArrayList<Proxy>();
        }
        return proxies;
    }
2757#public MavenExecutionRequest setProxies( List<Proxy> proxies )
    {
        if ( proxies != null )
        {
            this.proxies = new ArrayList<Proxy>( proxies );
        }
        else
        {
            this.proxies = null;
        }

        return this;
    }
2758#public MavenExecutionRequest addProxy( Proxy proxy )
    {
        if ( proxy == null )
        {
            throw new IllegalArgumentException( "proxy missing" );
        }

        for ( Proxy p : getProxies() )
        {
            if ( p.getId() != null && p.getId().equals( proxy.getId() ) )
            {
                return this;
            }
        }

        getProxies().add( proxy );

        return this;
    }
2759#public List<Server> getServers()
    {
        if ( servers == null )
        {
            servers = new ArrayList<Server>();
        }
        return servers;
    }
2760#public MavenExecutionRequest setServers( List<Server> servers )
    {
        if ( servers != null )
        {
            this.servers = new ArrayList<Server>( servers );
        }
        else
        {
            this.servers = null;
        }

        return this;
    }
2761#public MavenExecutionRequest addServer( Server server )
    {
        if ( server == null )
        {
            throw new IllegalArgumentException( "server missing" );
        }

        for ( Server p : getServers() )
        {
            if ( p.getId() != null && p.getId().equals( server.getId() ) )
            {
                return this;
            }
        }

        getServers().add( server );

        return this;
    }
2762#public List<Mirror> getMirrors()
    {
        if ( mirrors == null )
        {
            mirrors = new ArrayList<Mirror>();
        }
        return mirrors;
    }
2763#public MavenExecutionRequest setMirrors( List<Mirror> mirrors )
    {
        if ( mirrors != null )
        {
            this.mirrors = new ArrayList<Mirror>( mirrors );
        }
        else
        {
            this.mirrors = null;
        }

        return this;
    }
2764#public MavenExecutionRequest addMirror( Mirror mirror )
    {
        if ( mirror == null )
        {
            throw new IllegalArgumentException( "mirror missing" );
        }

        for ( Mirror p : getMirrors() )
        {
            if ( p.getId() != null && p.getId().equals( mirror.getId() ) )
            {
                return this;
            }
        }

        getMirrors().add( mirror );

        return this;
    }
2765#public List<Profile> getProfiles()
    {
        if ( profiles == null )
        {
            profiles = new ArrayList<Profile>();
        }
        return profiles;
    }
2766#public MavenExecutionRequest setProfiles( List<Profile> profiles )
    {
        if ( profiles != null )
        {
            this.profiles = new ArrayList<Profile>( profiles );
        }
        else
        {
            this.profiles = null;
        }

        return this;
    }
2767#public List<String> getPluginGroups()
    {
        if ( pluginGroups == null )
        {
            pluginGroups = new ArrayList<String>();
        }

        return pluginGroups;
    }
2768#public MavenExecutionRequest setPluginGroups( List<String> pluginGroups )
    {
        if ( pluginGroups != null )
        {
            this.pluginGroups = new ArrayList<String>( pluginGroups );
        }
        else
        {
            this.pluginGroups = null;
        }

        return this;
    }
2769#public MavenExecutionRequest addPluginGroup( String pluginGroup )
    {
        if ( !getPluginGroups().contains( pluginGroup ) )
        {
            getPluginGroups().add( pluginGroup );
        }

        return this;
    }
2770#public MavenExecutionRequest addPluginGroups( List<String> pluginGroups )
    {
        for ( String pluginGroup : pluginGroups )
        {
            addPluginGroup( pluginGroup );
        }

        return this;
    }
2771#public MavenExecutionRequest setRecursive( boolean recursive )
    {
        this.recursive = recursive;

        return this;
    }
2772#public boolean isProjectPresent()
    {
        return isProjectPresent;
    }
2773#public MavenExecutionRequest setProjectPresent( boolean projectPresent )
    {
        isProjectPresent = projectPresent;

        return this;
    }
2774#// Settings files

    public File getUserSettingsFile()
    {
        return userSettingsFile;
    }
2775#public MavenExecutionRequest setUserSettingsFile( File userSettingsFile )
    {
        this.userSettingsFile = userSettingsFile;

        return this;
    }
2776#public File getGlobalSettingsFile()
    {
        return globalSettingsFile;
    }
2777#public MavenExecutionRequest setGlobalSettingsFile( File globalSettingsFile )
    {
        this.globalSettingsFile = globalSettingsFile;

        return this;
    }
2778#public File getUserToolchainsFile()
    {
        return userToolchainsFile;
    }
2779#public MavenExecutionRequest setUserToolchainsFile( File userToolchainsFile )
    {
        this.userToolchainsFile = userToolchainsFile;

        return this;
    }
2780#public MavenExecutionRequest addRemoteRepository( ArtifactRepository repository )
    {
        for ( ArtifactRepository repo : getRemoteRepositories() )
        {
            if ( repo.getId() != null && repo.getId().equals( repository.getId() ) )
            {
                return this;
            }
        }

        getRemoteRepositories().add( repository );

        return this;
    }
2781#public List<ArtifactRepository> getRemoteRepositories()
    {
        if ( remoteRepositories == null )
        {
            remoteRepositories = new ArrayList<ArtifactRepository>();
        }
        return remoteRepositories;
    }
2782#public MavenExecutionRequest addPluginArtifactRepository( ArtifactRepository repository )
    {
        for ( ArtifactRepository repo : getPluginArtifactRepositories() )
        {
            if ( repo.getId() != null && repo.getId().equals( repository.getId() ) )
            {
                return this;
            }
        }

        getPluginArtifactRepositories().add( repository );

        return this;
    }
2783#public List<ArtifactRepository> getPluginArtifactRepositories()
    {
        if ( pluginArtifactRepositories == null )
        {
            pluginArtifactRepositories = new ArrayList<ArtifactRepository>();
        }
        return pluginArtifactRepositories;
    }
2784#//TODO: this does not belong here.
    public ProjectBuildingRequest getProjectBuildingRequest()
    {
        if ( projectBuildingRequest == null )
        {
            projectBuildingRequest = new DefaultProjectBuildingRequest();
            projectBuildingRequest.setLocalRepository( getLocalRepository() );
            projectBuildingRequest.setSystemProperties( getSystemProperties() );
            projectBuildingRequest.setUserProperties( getUserProperties() );
            projectBuildingRequest.setRemoteRepositories( getRemoteRepositories() );
            projectBuildingRequest.setPluginArtifactRepositories( getPluginArtifactRepositories() );
            projectBuildingRequest.setActiveProfileIds( getActiveProfiles() );
            projectBuildingRequest.setInactiveProfileIds( getInactiveProfiles() );
            projectBuildingRequest.setProfiles( getProfiles() );
            projectBuildingRequest.setProcessPlugins( true );
            projectBuildingRequest.setBuildStartTime( getStartTime() );
        }

        return projectBuildingRequest;
    }
2785#public MavenExecutionRequest addProfile( Profile profile )
    {
        if ( profile == null )
        {
            throw new IllegalArgumentException( "profile missing" );
        }

        for ( Profile p : getProfiles() )
        {
            if ( p.getId() != null && p.getId().equals( profile.getId() ) )
            {
                return this;
            }
        }

        getProfiles().add( profile );

        return this;
    }
2786#public RepositoryCache getRepositoryCache()
    {
        return repositoryCache;
    }
2787#public MavenExecutionRequest setRepositoryCache( RepositoryCache repositoryCache )
    {
        this.repositoryCache = repositoryCache;

        return this;
    }
2788#public ExecutionListener getExecutionListener()
    {
        return executionListener;
    }
2789#public MavenExecutionRequest setExecutionListener( ExecutionListener executionListener )
    {
        this.executionListener = executionListener;

        return this;
    }
2790#public String getThreadCount()
    {
        return threadCount;
    }
2791#public void setThreadCount( String threadCount )
    {
        this.threadCount = threadCount;
    }
2792#public boolean isThreadConfigurationPresent()
    {
        return getThreadCount() != null;
    }
2793#public boolean isPerCoreThreadCount()
    {
        return perCoreThreadCount;
    }
2794#public void setPerCoreThreadCount( boolean perCoreThreadCount )
    {
        this.perCoreThreadCount = perCoreThreadCount;
    }
2795#public WorkspaceReader getWorkspaceReader()
    {
        return workspaceReader;
    }
2796#public MavenExecutionRequest setWorkspaceReader( WorkspaceReader workspaceReader )
    {
        this.workspaceReader = workspaceReader;
        return this;
    }
2797#public boolean isCacheTransferError()
    {
        return cacheTransferError;
    }
2798#public MavenExecutionRequest setCacheTransferError( boolean cacheTransferError )
    {
        this.cacheTransferError = cacheTransferError;
        return this;
    }
2799#public boolean isCacheNotFound()
    {
        return cacheNotFound;
    }
2800#public MavenExecutionRequest setCacheNotFound( boolean cacheNotFound )
    {
        this.cacheNotFound = cacheNotFound;
        return this;
    }
2801#public Lifecycle()
    {
    }
2802#public Lifecycle( String id, List<String> phases, Map<String, String> defaultPhases )
    {
        this.id = id;
        this.phases = phases;
        this.defaultPhases = defaultPhases;
    }
2803#public String getId()
    {
        return this.id;
    }
2804#public List<String> getPhases()
    {
        return this.phases;
    }
2805#public Map<String, String> getDefaultPhases()
    {
        return defaultPhases;
    }
2806#@Override
    public String toString()
    {
        return id + " -> " + phases;
    }
2807#/**
     * Creates a new exception to indicate that the specified lifecycle is unknown.
     * 
     * @param lifecycleId The identifier of the lifecycle that could not be located, may be {@code null}.
     */
    public LifecycleNotFoundException( String lifecycleId )
    {
        super( "Unknown lifecycle " + lifecycleId );
        this.lifecycleId = ( lifecycleId != null ) ? lifecycleId : "";
    }
2808#/**
     * Gets the identifier of the lifecycle that was not found.
     * 
     * @return The identifier of the lifecycle that was not found, never {@code null}.
     */
    public String getLifecycleId()
    {
        return lifecycleId;
    }
2809#/**
     * Creates a new exception.
     * 
     * @param message The detail message, may be {@code null}.
     */
    public NoGoalSpecifiedException( String message )
    {
        super( message );
    }
2810#/**
     * Creates a new exception to indicate that the specified lifecycle phase is not defined by any known lifecycle.
     * 
     * @param message The detail message, may be {@code null}.
     * @param lifecyclePhase The name of the lifecycle phase that could not be located, may be {@code null}.
     */
    public LifecyclePhaseNotFoundException( String message, String lifecyclePhase )
    {
        super( message );
        this.lifecyclePhase = ( lifecyclePhase != null ) ? lifecyclePhase : "";
    }
2811#/**
     * Gets the lifecycle phase that was not found.
     * 
     * @return The lifecycle phase that was not found, never {@code null}.
     */
    public String getLifecyclePhase()
    {
        return lifecyclePhase;
    }
2812#public MavenExecutionPlan( List<ExecutionPlanItem> planItem, DefaultLifecycles defaultLifecycles )
    {
        this.planItem = planItem;

        lastMojoExecutionForAllPhases = new LinkedHashMap<String, ExecutionPlanItem>();

        LinkedHashSet<String> totalPhaseSet = new LinkedHashSet<String>();
        if ( defaultLifecycles != null )
        {
            for ( String phase : getDistinctPhasesInOrderOfExecutionPlanAppearance( planItem ) )
            {
                final Lifecycle lifecycle = defaultLifecycles.get( phase );
                if ( lifecycle != null )
                {
                    totalPhaseSet.addAll( lifecycle.getPhases() );
                }
            }
        }
        this.phasesInExecutionPlan = new ArrayList<String>( totalPhaseSet );

        Map<String, ExecutionPlanItem> lastInExistingPhases = new HashMap<String, ExecutionPlanItem>();
        for ( ExecutionPlanItem executionPlanItem : getExecutionPlanItems() )
        {
            lastInExistingPhases.put( executionPlanItem.getLifecyclePhase(), executionPlanItem );
        }

        ExecutionPlanItem lastSeenExecutionPlanItem = null;

        for ( String phase : totalPhaseSet )
        {
            ExecutionPlanItem forThisPhase = lastInExistingPhases.get( phase );
            if ( forThisPhase != null )
            {
                lastSeenExecutionPlanItem = forThisPhase;
            }

            lastMojoExecutionForAllPhases.put( phase, lastSeenExecutionPlanItem );
        }
    }
2813#public Iterator<ExecutionPlanItem> iterator()
    {
        return getExecutionPlanItems().iterator();
    }
2814#/**
     * Returns the last ExecutionPlanItem in the supplied phase. If no items are in the specified phase,
     * the closest executionPlanItem from an earlier phase item will be returned.
     *
     * @param requestedPhase the requested phase
     *                       The execution plan item
     * @return The ExecutionPlanItem or null if none can be found
     */
    public ExecutionPlanItem findLastInPhase( String requestedPhase )
    {
        return lastMojoExecutionForAllPhases.get( requestedPhase );
    }
2815#private List<ExecutionPlanItem> getExecutionPlanItems()
    {
        return planItem;
    }
2816#private static Iterable<String> getDistinctPhasesInOrderOfExecutionPlanAppearance(
        List<ExecutionPlanItem> planItems )
    {
        LinkedHashSet<String> result = new LinkedHashSet<String>();
        for ( ExecutionPlanItem executionPlanItem : planItems )
        {
            final String phase = executionPlanItem.getLifecyclePhase();
            if ( !result.contains( phase ) )
            {
                result.add( phase );
            }
        }
        return result;
    }
2817#public void forceAllComplete()
    {
        for ( ExecutionPlanItem executionPlanItem : getExecutionPlanItems() )
        {
            executionPlanItem.forceComplete();
        }
    }
2818#public void waitUntilAllDone()
        throws InterruptedException
    {
        for ( ExecutionPlanItem executionPlanItem : getExecutionPlanItems() )
        {
            executionPlanItem.waitUntilDone();
        }
    }
2819#public boolean containsPhase( String phase )
    {
        return phasesInExecutionPlan.contains( phase );
    }
2820#public List<MojoExecution> getMojoExecutions()
    {
        List<MojoExecution> result = new ArrayList<MojoExecution>();
        for ( ExecutionPlanItem executionPlanItem : planItem )
        {
            result.add( executionPlanItem.getMojoExecution() );
        }
        return result;
    }
2821#public Set<Plugin> getNonThreadSafePlugins()
    {
        Set<Plugin> plugins = new HashSet<Plugin>();
        for ( ExecutionPlanItem executionPlanItem : planItem )
        {
            final MojoExecution mojoExecution = executionPlanItem.getMojoExecution();
            if ( !mojoExecution.getMojoDescriptor().isThreadSafe() )
            {
                plugins.add( mojoExecution.getPlugin() );
            }
        }
        return plugins;
    }
2822#// Used by m2e but will be removed, really.
    @Deprecated
    public List<MojoExecution> getExecutions()
    {
        return getMojoExecutions();
    }
2823#public int size()
    {
        return planItem.size();
    }
2824#public DefaultLifecycles()
    {
    }
2825#public DefaultLifecycles( Map<String, Lifecycle> lifecycles, Logger logger )
    {
        this.lifecycles = new LinkedHashMap<String, Lifecycle>();
        this.logger = logger;
        this.lifecycles = lifecycles;
    }
2826#public Lifecycle get( String key )
    {
        return getPhaseToLifecycleMap().get( key );
    }
2827#/**
     * We use this to map all phases to the lifecycle that contains it. This is used so that a user can specify the
     * phase they want to execute and we can easily determine what lifecycle we need to run.
     *
     * @return A map of lifecycles, indexed on id
     */
    public Map<String, Lifecycle> getPhaseToLifecycleMap()
    {
        // If people are going to make their own lifecycles then we need to tell people how to namespace them correctly
        // so that they don't interfere with internally defined lifecycles.

        HashMap<String, Lifecycle> phaseToLifecycleMap = new HashMap<String, Lifecycle>();

        for ( Lifecycle lifecycle : getLifeCycles() )
        {
            if ( logger.isDebugEnabled() )
            {
                logger.debug( "Lifecycle " + lifecycle );
            }

            for ( String phase : lifecycle.getPhases() )
            {
                // The first definition wins.
                if ( !phaseToLifecycleMap.containsKey( phase ) )
                {
                    phaseToLifecycleMap.put( phase, lifecycle );
                }
                else
                {
                    Lifecycle original = phaseToLifecycleMap.get( phase );
                    logger.warn( "Duplicated lifecycle phase " + phase + ". Defined in " + original.getId()
                        + " but also in " + lifecycle.getId() );
                }
            }
        }

        return phaseToLifecycleMap;
    }
2828#public List<Lifecycle> getLifeCycles()
    {
        // ensure canonical order of standard lifecycles
        Map<String, Lifecycle> lifecycles = new LinkedHashMap<String, Lifecycle>( this.lifecycles );

        LinkedHashSet<String> lifecycleNames = new LinkedHashSet<String>( Arrays.asList( STANDARD_LIFECYCLES ) );
        lifecycleNames.addAll( lifecycles.keySet() );

        ArrayList<Lifecycle> result = new ArrayList<Lifecycle>();
        for ( String name : lifecycleNames )
        {
            result.add( lifecycles.get( name ) );
        }

        return result;
    }
2829#public String getLifecyclePhaseList()
    {
        Set<String> phases = new LinkedHashSet<String>();

        for ( Lifecycle lifecycle : lifecycles.values() )
        {
            phases.addAll( lifecycle.getPhases() );
        }

        return StringUtils.join( phases.iterator(), ", " );
    }
2830#public LifecycleExecutionException( String message )
    {
        super( message );
    }
2831#public LifecycleExecutionException( Throwable cause )
    {
        super( cause );
    }
2832#public LifecycleExecutionException( String message, Throwable cause )
    {
        super( message, cause );
    }
2833#public LifecycleExecutionException( String message, MavenProject project )
    {
        super( message );
        this.project = project;
    }
2834#public LifecycleExecutionException( String message, MojoExecution execution, MavenProject project )
    {
        super( message );
        this.project = project;
    }
2835#public LifecycleExecutionException( String message, MojoExecution execution, MavenProject project, Throwable cause )
    {
        super( message, cause );
        this.project = project;
    }
2836#public LifecycleExecutionException( MojoExecution execution, MavenProject project, Throwable cause )
    {
        this( createMessage( execution, project, cause ), execution, project, cause );
    }
2837#public MavenProject getProject()
    {
        return project;
    }
2838#private static String createMessage( MojoExecution execution, MavenProject project, Throwable cause )
    {
        StringBuilder buffer = new StringBuilder( 256 );

        buffer.append( "Failed to execute goal" );

        if ( execution != null )
        {
            buffer.append( ' ' );
            buffer.append( execution.getGroupId() );
            buffer.append( ':' );
            buffer.append( execution.getArtifactId() );
            buffer.append( ':' );
            buffer.append( execution.getVersion() );
            buffer.append( ':' );
            buffer.append( execution.getGoal() );
            buffer.append( " (" );
            buffer.append( execution.getExecutionId() );
            buffer.append( ")" );
        }

        if ( project != null )
        {
            buffer.append( " on project " );
            buffer.append( project.getArtifactId() );
        }

        if ( cause != null )
        {
            buffer.append( ": " ).append( cause.getMessage() );
        }

        return buffer.toString();
    }
2839#Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging );
2840#public void execute( MavenSession session )
    {
        lifecycleStarter.execute( session );
    }
2841#// These methods deal with construction intact Plugin object that look like they come from a standard
    // <plugin/> block in a Maven POM. We have to do some wiggling to pull the sources of information
    // together and this really shows the problem of constructing a sensible default configuration but
    // it's all encapsulated here so it appears normalized to the POM builder.

    // We are going to take the project packaging and find all plugin in the default lifecycle and create
    // fully populated Plugin objects, including executions with goals and default configuration taken
    // from the plugin.xml inside a plugin.
    //
    // TODO: This whole method could probably removed by injecting lifeCyclePluginAnalyzer straight into client site.
    // TODO: But for some reason the whole plexus appcontext refuses to start when I try this.

    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        return lifeCyclePluginAnalyzer.getPluginsBoundByDefaultToAllLifecycles( packaging );
    }
2842#// USED BY MAVEN HELP PLUGIN

    @Deprecated
    public Map<String, Lifecycle> getPhaseToLifecycleMap()
    {
        return defaultLifeCycles.getPhaseToLifecycleMap();
    }
2843#// NOTE: Backward-compat with maven-help-plugin:2.1

    @SuppressWarnings( { "UnusedDeclaration" } )
    MojoDescriptor getMojoDescriptor( String task, MavenSession session, MavenProject project, String invokedVia,
                                      boolean canUsePrefix, boolean isOptionalMojo )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginVersionResolutionException
    {
        return mojoDescriptorCreator.getMojoDescriptor( task, session, project );
    }
2844#// Used by m2eclipse

    @SuppressWarnings( { "UnusedDeclaration" } )
    public MavenExecutionPlan calculateExecutionPlan( MavenSession session, boolean setup, String... tasks )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginManagerException, LifecyclePhaseNotFoundException, LifecycleNotFoundException,
        PluginVersionResolutionException
    {
        List<TaskSegment> taskSegments =
            lifecycleTaskSegmentCalculator.calculateTaskSegments( session, Arrays.asList( tasks ) );

        TaskSegment mergedSegment = new TaskSegment( false );

        for ( TaskSegment taskSegment : taskSegments )
        {
            mergedSegment.getTasks().addAll( taskSegment.getTasks() );
        }

        return lifecycleExecutionPlanCalculator.calculateExecutionPlan( session, session.getCurrentProject(),
                                                                        mergedSegment.getTasks(), setup );
    }
2845#public MavenExecutionPlan calculateExecutionPlan( MavenSession session, String... tasks )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginManagerException, LifecyclePhaseNotFoundException, LifecycleNotFoundException,
        PluginVersionResolutionException
    {
        return calculateExecutionPlan( session, true, tasks );
    }
2846#// Site 3.x
    public void calculateForkedExecutions( MojoExecution mojoExecution, MavenSession session )
        throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        lifecycleExecutionPlanCalculator.calculateForkedExecutions( mojoExecution, session );
    }
2847#// Site 3.x
    public List<MavenProject> executeForkedExecutions( MojoExecution mojoExecution, MavenSession session )
        throws LifecycleExecutionException
    {
        return mojoExecutor.executeForkedExecutions( mojoExecution, session, new ProjectIndex( session.getProjects() ) );
    }
2848#public Scheduling()
    {
    }
2849#public Scheduling( String lifecycle, List<Schedule> schedules )
    {
        this.lifecycle = lifecycle;
        this.schedules = schedules;
    }
2850#public String getLifecycle()
    {
        return lifecycle;
    }
2851#public void setLifecycle( String lifecycle )
    {
        this.lifecycle = lifecycle;
    }
2852#public List<Schedule> getSchedules()
    {
        return schedules;
    }
2853#public Schedule getSchedule( String phaseName )
    {
        if ( phaseName != null )
        {
            for ( Schedule schedule : schedules )
            {
                if ( phaseName.equals( schedule.getPhase() ) )
                {
                    return schedule;
                }
            }
        }

        return null;
    }
2854#public Schedule getSchedule( MojoExecution mojoExecution )
    {
        if ( mojoExecution != null )
        {
            for ( Schedule schedule : schedules )
            {
                if ( schedule.appliesTo( mojoExecution ) )
                {
                    return schedule;
                }
            }
        }

        return null;
    }
2855#public void setSchedules( List<Schedule> schedules )
    {
        this.schedules = schedules;
    }
2856#public DefaultSchedules()
    {
    }
2857#public DefaultSchedules( List<Scheduling> schedules )
    {
        this.schedules = schedules;
    }
2858#public List<ExecutionPlanItem> createExecutionPlanItem( MavenProject mavenProject, List<MojoExecution> executions )
    {
        BuilderCommon.attachToThread( mavenProject );

        List<ExecutionPlanItem> result = new ArrayList<ExecutionPlanItem>();
        for ( MojoExecution mojoExecution : executions )
        {
            String lifeCyclePhase = mojoExecution.getLifecyclePhase();
            final Scheduling scheduling = getScheduling( "default" );

            Schedule schedule = null;
            if ( scheduling != null )
            {
                schedule = scheduling.getSchedule( mojoExecution );
                if ( schedule == null )
                {
                    schedule = scheduling.getSchedule( lifeCyclePhase );
                }
            }

            result.add( new ExecutionPlanItem( mojoExecution, schedule ) );
        }
        return result;
    }
2859#/**
     * Gets scheduling associated with a given phase.
     * <p/>
     * This is part of the experimental weave mode and therefore not part of the public api.
     *
     * @param lifecyclePhaseName The name of the lifecycle phase
     * @return Schecduling information related to phase
     */

    Scheduling getScheduling( String lifecyclePhaseName )
    {
        for ( Scheduling schedule : schedules )
        {
            if ( lifecyclePhaseName.equals( schedule.getLifecycle() ) )
            {
                return schedule;
            }
        }
        return null;
    }
2860#public List<Scheduling> getSchedules()
    {
        return schedules;
    }
2861#public Schedule()
    {
    }
2862#public Schedule( String phase, boolean mojoSynchronized, boolean parallel )
    {
        this.phase = phase;
        this.mojoSynchronized = mojoSynchronized;
        this.parallel = parallel;
    }
2863#public String getPhase()
    {
        return phase;
    }
2864#public void setPhase( String phase )
    {
        this.phase = phase;
    }
2865#public String getPluginKey()
    {
        return pluginKey;
    }
2866#public void setPluginKey( String pluginKey )
    {
        this.pluginKey = pluginKey;
    }
2867#public boolean isMojoSynchronized()
    {
        return mojoSynchronized;
    }
2868#public void setMojoSynchronized( boolean mojoSynchronized )
    {
        this.mojoSynchronized = mojoSynchronized;
    }
2869#public boolean isParallel()
    {
        return parallel;
    }
2870#public void setParallel( boolean parallel )
    {
        this.parallel = parallel;
    }
2871#public String getUpstreamPhase()
    {
        return upstreamPhase;
    }
2872#public void setUpstreamPhase( String upstreamPhase )
    {
        this.upstreamPhase = upstreamPhase;
    }
2873#public String getMojoGoal()
    {
        return mojoGoal;
    }
2874#public void setMojoGoal( String mojoGoal )
    {
        this.mojoGoal = mojoGoal;
    }
2875#public boolean hasUpstreamPhaseDefined()
    {
        return getUpstreamPhase() != null;
    }
2876#public boolean appliesTo( MojoExecution mojoExecution )
    {
        if ( pluginKey == null && mojoGoal == null )
        {
            return false;
        }

        boolean pluginKeyMatches = ( pluginKey == null ) || pluginKey.equals( mojoExecution.getPlugin().getKey() );

        boolean pluginGoalMatches = ( mojoGoal == null ) || mojoGoal.equals( mojoExecution.getGoal() );

        return pluginKeyMatches && pluginGoalMatches;
    }
2877#@Override
    public String toString()
    {
        return "Schedule{" + "phase='" + phase + "', upstreamPhase='" + upstreamPhase + "', pluginKey='"
            + pluginKey + "', mojoGoal='" + mojoGoal + "', mojoSynchronized=" + mojoSynchronized
            + ", parallel=" + parallel + '}';
    }
2878#// For a given project packaging find all the plugins that are bound to any registered
    // lifecycles. The project builder needs to now what default plugin information needs to be
    // merged into POM being built. Once the POM builder has this plugin information, versions can be assigned
    // by the POM builder because they will have to be defined in plugin management. Once this is setComplete then it
    // can be passed back so that the default configuration information can be populated.
    //
    // We need to know the specific version so that we can lookup the right version of the plugin descriptor
    // which tells us what the default configuration is.
    //

    /**
     * @return The plugins bound to the lifecycles of the specified packaging or {@code null} if the packaging is
     *         unknown.
     */
    Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging );
2879#MavenExecutionPlan calculateExecutionPlan( MavenSession session, String... tasks )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginManagerException, LifecyclePhaseNotFoundException, LifecycleNotFoundException,
        PluginVersionResolutionException;
2880#MavenExecutionPlan calculateExecutionPlan( MavenSession session, boolean setup, String... tasks )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginManagerException, LifecyclePhaseNotFoundException, LifecycleNotFoundException,
        PluginVersionResolutionException;
2881#void execute( MavenSession session );
2882#// used by the site plugin 3.x
    void calculateForkedExecutions( MojoExecution mojoExecution, MavenSession session )
        throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException;
2883#// used by the site plugin 3.x
    List<MavenProject> executeForkedExecutions( MojoExecution mojoExecution, MavenSession session )
        throws LifecycleExecutionException;
2884#/**
     * Creates a new exception.
     * 
     * @param message The detail message, may be {@code null}.
     */
    public MissingProjectException( String message )
    {
        super( message );
    }
2885#@SuppressWarnings( { "UnusedDeclaration" } )
    public ThreadConfigurationService()
    {
        cpuCores = Runtime.getRuntime().availableProcessors();
    }
2886#public ThreadConfigurationService( Logger logger, int cpuCores )
    {
        this.logger = logger;
        this.cpuCores = cpuCores;
    }
2887#public ExecutorService getExecutorService( String threadCountConfiguration, boolean perCoreThreadCount,
                                               int largestBuildListSize )
    {
        Integer threadCount = getThreadCount( threadCountConfiguration, perCoreThreadCount, largestBuildListSize );
        return getExecutorService( threadCount );


    }
2888#private ExecutorService getExecutorService( Integer threadCount )
    {
        if ( threadCount == null )
        {
            logger.info( "Building with unlimited threads" );
            return Executors.newCachedThreadPool();
        }

        logger.info( "Building with " + threadCount + " threads" );
        return Executors.newFixedThreadPool( threadCount );
    }
2889#/**
     * Returns the thread count to use or null for unlimited threads.
     *
     * @param threadCountConfiguration The property passed from the command line.
     * @param perCoreThreadCount       Indicates if the threa count should be scaled per cpu core.
     * @param largestBuildListSize     the size of the largest module list (the number of modules)
     * @return The number of threads to use or null if unlimited
     */

    Integer getThreadCount( String threadCountConfiguration, boolean perCoreThreadCount, int largestBuildListSize )
    {
        // Default to a value that is not larger than what we can use ;)
        float threadCount = Math.min( cpuCores, largestBuildListSize );
        if ( threadCountConfiguration != null )
        {
            try
            {
                threadCount = Float.parseFloat( threadCountConfiguration );
            }
            catch ( NumberFormatException e )
            {
                logger.warn(
                    "Couldn't parse thread count, will default to " + threadCount + ": " + threadCountConfiguration );
            }
        }
        if ( perCoreThreadCount )
        {
            threadCount = threadCount * cpuCores;
        }

        final int endResult = Math.round( threadCount );
        if ( logger.isDebugEnabled() )
        {
            logger.debug( "Thread pool size: " + endResult );
        }
        return endResult;
    }
2890#public DefaultLifecycleTaskSegmentCalculator()
    {
    }
2891#public List<TaskSegment> calculateTaskSegments( MavenSession session )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginVersionResolutionException, LifecyclePhaseNotFoundException, LifecycleNotFoundException
    {

        MavenProject rootProject = session.getTopLevelProject();

        List<String> tasks = session.getGoals();

        if ( tasks == null || tasks.isEmpty() )
        {
            if ( !StringUtils.isEmpty( rootProject.getDefaultGoal() ) )
            {
                tasks = Arrays.asList( StringUtils.split( rootProject.getDefaultGoal() ) );
            }
        }

        return calculateTaskSegments( session, tasks );
    }
2892#public List<TaskSegment> calculateTaskSegments( MavenSession session, List<String> tasks )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginVersionResolutionException
    {
        List<TaskSegment> taskSegments = new ArrayList<TaskSegment>( tasks.size() );

        TaskSegment currentSegment = null;

        for ( String task : tasks )
        {
            if ( isGoalSpecification( task ) )
            {
                // "pluginPrefix:goal" or "groupId:artifactId[:version]:goal"

                lifecyclePluginResolver.resolveMissingPluginVersions( session.getTopLevelProject(), session );

                MojoDescriptor mojoDescriptor =
                    mojoDescriptorCreator.getMojoDescriptor( task, session, session.getTopLevelProject() );

                boolean aggregating = mojoDescriptor.isAggregator() || !mojoDescriptor.isProjectRequired();

                if ( currentSegment == null || currentSegment.isAggregating() != aggregating )
                {
                    currentSegment = new TaskSegment( aggregating );
                    taskSegments.add( currentSegment );
                }

                currentSegment.getTasks().add( new GoalTask( task ) );
            }
            else
            {
                // lifecycle phase

                if ( currentSegment == null || currentSegment.isAggregating() )
                {
                    currentSegment = new TaskSegment( false );
                    taskSegments.add( currentSegment );
                }

                currentSegment.getTasks().add( new LifecycleTask( task ) );
            }
        }

        return taskSegments;
    }
2893#public boolean requiresProject( MavenSession session )
    {
        List<String> goals = session.getGoals();
        if ( goals != null )
        {
            for ( String goal : goals )
            {
                if ( !isGoalSpecification( goal ) )
                {
                    return true;
                }
            }
        }
        return false;
    }
2894#private boolean isGoalSpecification( String task )
    {
        return task.indexOf( ':' ) >= 0;
    }
2895#MavenExecutionPlan calculateExecutionPlan( MavenSession session, MavenProject project, List<Object> tasks )
        throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException,
        PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException,
        NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException;
2896#MavenExecutionPlan calculateExecutionPlan( MavenSession session, MavenProject project, List<Object> tasks,
                                               boolean setup )
        throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException,
        PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException,
        NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException;
2897#void calculateForkedExecutions( MojoExecution mojoExecution, MavenSession session )
        throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException;
2898#void setupMojoExecution( MavenSession session, MavenProject project, MojoExecution mojoExecution )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, InvalidPluginDescriptorException, NoPluginFoundForPrefixException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException;
2899#public ExecutionPlanItem( MojoExecution mojoExecution, Schedule schedule )
    {
        this.mojoExecution = mojoExecution;
        this.schedule = schedule;
    }
2900#public MojoExecution getMojoExecution()
    {
        return mojoExecution;
    }
2901#public String getLifecyclePhase()
    {
        return mojoExecution.getLifecyclePhase();
    }
2902#public void setComplete()
    {
        done.countDown();
    }
2903#public boolean isDone()
    {
        return done.getCount() < 1;
    }
2904#public void forceComplete()
    {
        setComplete();
    }
2905#public void waitUntilDone()
        throws InterruptedException
    {
        done.await();
    }
2906#public Schedule getSchedule()
    {
        return schedule;
    }
2907#public Plugin getPlugin()
    {
        final MojoDescriptor mojoDescriptor = getMojoExecution().getMojoDescriptor();
        return mojoDescriptor.getPluginDescriptor().getPlugin();
    }
2908#@Override
    public String toString()
    {
        return "ExecutionPlanItem{" + ", mojoExecution=" + mojoExecution + ", schedule=" + schedule + '}' +
            super.toString();
    }
2909#public ConcurrentBuildLogger()
    {
        startTime = System.currentTimeMillis();
    }
2910#public BuildLogItem createBuildLogItem( MavenProject project, ExecutionPlanItem current )
    {
        threadMap.put( project, Thread.currentThread() );
        BuildLogItem result = new BuildLogItem( project, current );
        items.add( result );
        return result;
    }
2911#public String toString()
    {
        StringBuilder result = new StringBuilder();
        for ( Map.Entry<MavenProject, Thread> mavenProjectThreadEntry : threadMap.entrySet() )
        {
            result.append( mavenProjectThreadEntry.getKey().getName() );
            result.append( " ran on " );
            result.append( mavenProjectThreadEntry.getValue().getName() );
            result.append( "\n" );
        }

        for ( BuildLogItem builtLogItem : items )
        {
            result.append( builtLogItem.toString( startTime ) );
            result.append( "\n" );
        }
        return result.toString();
    }
2912#public String toGraph()
    {
        StringBuilder result = new StringBuilder();

        Map<MavenProject, Collection<BuildLogItem>> multiMap = new HashMap<MavenProject, Collection<BuildLogItem>>();
        for ( BuildLogItem builtLogItem : items )
        {
            MavenProject project = builtLogItem.getProject();
            Collection<BuildLogItem> bag = multiMap.get( project );
            if ( bag == null )
            {
                bag = new ArrayList<BuildLogItem>();
                multiMap.put( project, bag );
            }
            bag.add( builtLogItem );
        }

        result.append( "digraph build" );
        result.append( " {\n " );

        for ( MavenProject mavenProject : multiMap.keySet() )
        {
            final Collection<BuildLogItem> builtLogItems = multiMap.get( mavenProject );
            result.append( "   subgraph " );
            result.append( mavenProject.getArtifactId() );
            result.append( "   {\n" );

            for ( BuildLogItem builtLogItem : builtLogItems )
            {
                result.append( builtLogItem.toGraph( startTime ) );
            }

            result.append( "\n   }\n" );
        }

        result.append( "\n}\n " );
        return result.toString();
    }
2913#ThreadLockedArtifact( Artifact real )
    {
        this.real = real;
    }
2914#public boolean hasReal()
    {
        return real != null &&
            ( !( real instanceof ThreadLockedArtifact ) || ( (ThreadLockedArtifact) real ).hasReal() );
    }
2915#public String getGroupId()
    {
        return real.getGroupId();
    }
2916#public String getArtifactId()
    {
        return real.getArtifactId();
    }
2917#public String getVersion()
    {
        return real.getVersion();
    }
2918#public void setVersion( String version )
    {
        real.setVersion( version );
    }
2919#public String getScope()
    {
        return real.getScope();
    }
2920#public String getType()
    {
        return real.getType();
    }
2921#public String getClassifier()
    {
        return real.getClassifier();
    }
2922#public boolean hasClassifier()
    {
        return real.hasClassifier();
    }
2923#public void attachToThread()
    {
        threadArtifact.set( this );
    }
2924#public File getFile()
    {
        final ThreadLockedArtifact lockedArtifact = threadArtifact.get();
        if ( lockedArtifact != null && this != lockedArtifact && mustLock() )
        {
            try
            {
                artifactLocked.await();
            }
            catch ( InterruptedException e )
            {
                // Ignore and go on to real.getFile();
            }
        }
        return real.getFile();
    }
2925#private boolean mustLock()
    {
        boolean dontNeedLock = CurrentPhaseForThread.isPhase( "compile" ) || CurrentPhaseForThread.isPhase( "test" );
        return !dontNeedLock;
    }
2926#public void setFile( File destination )
    {
        if ( destination != null && destination.exists() && destination.isFile() )
        {
            artifactLocked.countDown();
        }
        real.setFile( destination );
    }
2927#public String getBaseVersion()
    {
        return real.getBaseVersion();
    }
2928#public void setBaseVersion( String baseVersion )
    {
        real.setBaseVersion( baseVersion );
    }
2929#public String getId()
    {
        return real.getId();
    }
2930#public String getDependencyConflictId()
    {
        return real.getDependencyConflictId();
    }
2931#public void addMetadata( ArtifactMetadata metadata )
    {
        real.addMetadata( metadata );
    }
2932#public Collection<ArtifactMetadata> getMetadataList()
    {
        return real.getMetadataList();
    }
2933#public void setRepository( ArtifactRepository remoteRepository )
    {
        real.setRepository( remoteRepository );
    }
2934#public ArtifactRepository getRepository()
    {
        return real.getRepository();
    }
2935#public void updateVersion( String version, ArtifactRepository localRepository )
    {
        real.updateVersion( version, localRepository );
    }
2936#public String getDownloadUrl()
    {
        return real.getDownloadUrl();
    }
2937#public void setDownloadUrl( String downloadUrl )
    {
        real.setDownloadUrl( downloadUrl );
    }
2938#public ArtifactFilter getDependencyFilter()
    {
        return real.getDependencyFilter();
    }
2939#public void setDependencyFilter( ArtifactFilter artifactFilter )
    {
        real.setDependencyFilter( artifactFilter );
    }
2940#public ArtifactHandler getArtifactHandler()
    {
        return real.getArtifactHandler();
    }
2941#public List<String> getDependencyTrail()
    {
        return real.getDependencyTrail();
    }
2942#public void setDependencyTrail( List<String> dependencyTrail )
    {
        real.setDependencyTrail( dependencyTrail );
    }
2943#public void setScope( String scope )
    {
        real.setScope( scope );
    }
2944#public VersionRange getVersionRange()
    {
        return real.getVersionRange();
    }
2945#public void setVersionRange( VersionRange newRange )
    {
        real.setVersionRange( newRange );
    }
2946#public void selectVersion( String version )
    {
        real.selectVersion( version );
    }
2947#public void setGroupId( String groupId )
    {
        real.setGroupId( groupId );
    }
2948#public void setArtifactId( String artifactId )
    {
        real.setArtifactId( artifactId );
    }
2949#public boolean isSnapshot()
    {
        return real.isSnapshot();
    }
2950#public void setResolved( boolean resolved )
    {
        real.setResolved( resolved );
    }
2951#public boolean isResolved()
    {
        return real.isResolved();
    }
2952#public void setResolvedVersion( String version )
    {
        real.setResolvedVersion( version );
    }
2953#public void setArtifactHandler( ArtifactHandler handler )
    {
        real.setArtifactHandler( handler );
    }
2954#public boolean isRelease()
    {
        return real.isRelease();
    }
2955#public void setRelease( boolean release )
    {
        real.setRelease( release );
    }
2956#public List<ArtifactVersion> getAvailableVersions()
    {
        return real.getAvailableVersions();
    }
2957#public void setAvailableVersions( List<ArtifactVersion> versions )
    {
        real.setAvailableVersions( versions );
    }
2958#public boolean isOptional()
    {
        return real.isOptional();
    }
2959#public void setOptional( boolean optional )
    {
        real.setOptional( optional );
    }
2960#public ArtifactVersion getSelectedVersion()
        throws OverConstrainedVersionException
    {
        return real.getSelectedVersion();
    }
2961#public boolean isSelectedVersionKnown()
        throws OverConstrainedVersionException
    {
        return real.isSelectedVersionKnown();
    }
2962#public int compareTo( Artifact o )
    {
        return real.compareTo( o );
    }
2963#public PhaseRecorder( MavenProject project )
    {
        this.project = project;
    }
2964#public void observeExecution( MojoExecution mojoExecution )
    {
        String lifecyclePhase = mojoExecution.getLifecyclePhase();

        if ( lifecyclePhase != null )
        {
            if ( lastLifecyclePhase == null )
            {
                lastLifecyclePhase = lifecyclePhase;
            }
            else if ( !lifecyclePhase.equals( lastLifecyclePhase ) )
            {
                project.addLifecyclePhase( lastLifecyclePhase );
                lastLifecyclePhase = lifecyclePhase;
            }
        }

        if ( lastLifecyclePhase != null )
        {
            project.addLifecyclePhase( lastLifecyclePhase );
        }
    }
2965#public boolean isDifferentPhase( MojoExecution nextMojoExecution )
    {
        String lifecyclePhase = nextMojoExecution.getLifecyclePhase();
        if ( lifecyclePhase == null )
        {
            return lastLifecyclePhase != null;
        }
        return !lifecyclePhase.equals( lastLifecyclePhase );

    }
2966#void fire( ExecutionEvent.Type eventType, MavenSession session, MojoExecution mojoExecution );
2967#void fire( ExecutionEvent.Type eventType, MavenSession session, MojoExecution mojoExecution, Exception exception );
2968#public ReactorBuildStatus( ProjectDependencyGraph projectDependencyGraph )
    {
        this.projectDependencyGraph = projectDependencyGraph;
    }
2969#public boolean isBlackListed( MavenProject project )
    {
        return blackListedProjects.contains( BuilderCommon.getKey( project ) );
    }
2970#public void blackList( MavenProject project )
    {
        if ( blackListedProjects.add( BuilderCommon.getKey( project ) ) && projectDependencyGraph != null )
        {
            for ( MavenProject downstreamProject : projectDependencyGraph.getDownstreamProjects( project, true ) )
            {
                blackListedProjects.add( BuilderCommon.getKey( downstreamProject ) );
            }
        }
    }
2971#public void halt()
    {
        halted = true;
    }
2972#public boolean isHalted()
    {
        return halted;
    }
2973#public boolean isHaltedOrBlacklisted( MavenProject mavenProject )
    {
        return isBlackListed( mavenProject ) || isHalted();
    }
2974#@SuppressWarnings( { "UnusedDeclaration" } )
    public LifecycleWeaveBuilder()
    {
    }
2975#public LifecycleWeaveBuilder( MojoExecutor mojoExecutor, BuilderCommon builderCommon, Logger logger,
                                  ExecutionEventCatapult eventCatapult )
    {
        this.mojoExecutor = mojoExecutor;
        this.builderCommon = builderCommon;
        this.logger = logger;
        this.eventCatapult = eventCatapult;
    }
2976#public void build( ProjectBuildList projectBuilds, ReactorContext buildContext, List<TaskSegment> taskSegments,
                       MavenSession session, ExecutorService executor, ReactorBuildStatus reactorBuildStatus )
        throws ExecutionException, InterruptedException
    {
        ConcurrentBuildLogger concurrentBuildLogger = new ConcurrentBuildLogger();
        CompletionService<ProjectSegment> service = new ExecutorCompletionService<ProjectSegment>( executor );

        try
        {
            for ( MavenProject mavenProject : session.getProjects() )
            {
                Artifact mainArtifact = mavenProject.getArtifact();
                if ( mainArtifact != null && !( mainArtifact instanceof ThreadLockedArtifact ) )
                {
                    ThreadLockedArtifact threadLockedArtifact = new ThreadLockedArtifact( mainArtifact );
                    mavenProject.setArtifact( threadLockedArtifact );
                }
            }

            final List<Future<ProjectSegment>> futures = new ArrayList<Future<ProjectSegment>>();
            final Map<ProjectSegment, Future<MavenExecutionPlan>> plans =
                new HashMap<ProjectSegment, Future<MavenExecutionPlan>>();

            for ( TaskSegment taskSegment : taskSegments )
            {
                ProjectBuildList segmentChunks = projectBuilds.getByTaskSegment( taskSegment );
                Set<Artifact> projectArtifacts = new HashSet<Artifact>();
                for ( ProjectSegment segmentChunk : segmentChunks )
                {
                    Artifact artifact = segmentChunk.getProject().getArtifact();
                    if ( artifact != null )
                    {
                        projectArtifacts.add( artifact );
                    }
                }
                for ( ProjectSegment projectBuild : segmentChunks )
                {
                    plans.put( projectBuild, executor.submit( createEPFuture( projectBuild, projectArtifacts ) ) );
                }

                for ( ProjectSegment projectSegment : plans.keySet() )
                {
                    executionPlans.put( projectSegment.getProject(), plans.get( projectSegment ).get() );

                }
                for ( ProjectSegment projectBuild : segmentChunks )
                {
                    try
                    {
                        final MavenExecutionPlan executionPlan = plans.get( projectBuild ).get();

                        DependencyContext dependencyContext =
                            mojoExecutor.newDependencyContext( session, executionPlan.getMojoExecutions() );

                        final Callable<ProjectSegment> projectBuilder =
                            createCallableForBuildingOneFullModule( buildContext, session, reactorBuildStatus,
                                                                    executionPlan, projectBuild, dependencyContext,
                                                                    concurrentBuildLogger );

                        futures.add( service.submit( projectBuilder ) );
                    }
                    catch ( Exception e )
                    {
                        throw new ExecutionException( e );
                    }
                }

                for ( Future<ProjectSegment> buildFuture : futures )
                {
                    buildFuture.get();  // At this point, this build *is* finished.
                    // Do not leak threads past here or evil gremlins will get you!
                }
                futures.clear();
            }
        }
        finally
        {
            projectBuilds.closeAll();
        }
        logger.info( concurrentBuildLogger.toString() );
    }
2977#private Callable<MavenExecutionPlan> createEPFuture( final ProjectSegment projectSegment,
                                                         final Set<Artifact> projectArtifacts )
    {
        return new Callable<MavenExecutionPlan>()
        {
            public MavenExecutionPlan call()
                throws Exception
            {
                return builderCommon.resolveBuildPlan( projectSegment.getSession(), projectSegment.getProject(),
                                                       projectSegment.getTaskSegment(), projectArtifacts );
            }
        };
    }
2978#private Callable<ProjectSegment> createCallableForBuildingOneFullModule( final ReactorContext reactorContext,
                                                                             final MavenSession rootSession,
                                                                             final ReactorBuildStatus reactorBuildStatus,
                                                                             final MavenExecutionPlan executionPlan,
                                                                             final ProjectSegment projectBuild,
                                                                             final DependencyContext dependencyContext,
                                                                             final ConcurrentBuildLogger concurrentBuildLogger )
    {
        return new Callable<ProjectSegment>()
        {
            public ProjectSegment call()
                throws Exception
            {
                Iterator<ExecutionPlanItem> planItems = executionPlan.iterator();
                ExecutionPlanItem current = planItems.hasNext() ? planItems.next() : null;
                ThreadLockedArtifact threadLockedArtifact = (ThreadLockedArtifact)projectBuild.getProject().getArtifact();
                if ( threadLockedArtifact != null )
                {
                    threadLockedArtifact.attachToThread();
                }
                long buildStartTime = System.currentTimeMillis();

                //muxer.associateThreadWithProjectSegment( projectBuild );

                if ( reactorBuildStatus.isHaltedOrBlacklisted( projectBuild.getProject() ) )
                {
                    eventCatapult.fire( ExecutionEvent.Type.ProjectSkipped, projectBuild.getSession(), null );
                    return null;
                }

                eventCatapult.fire( ExecutionEvent.Type.ProjectStarted, projectBuild.getSession(), null );

                Collection<ArtifactLink> dependencyLinks = getUpstreamReactorDependencies( projectBuild );

                try
                {
                    PhaseRecorder phaseRecorder = new PhaseRecorder( projectBuild.getProject() );
                    long totalMojoTime = 0;
                    long mojoStart;
                    while ( current != null && !reactorBuildStatus.isHaltedOrBlacklisted( projectBuild.getProject() ) )
                    {

                        BuildLogItem builtLogItem =
                            concurrentBuildLogger.createBuildLogItem( projectBuild.getProject(), current );
                        final Schedule schedule = current.getSchedule();

                        mojoStart = System.currentTimeMillis();
                        buildExecutionPlanItem( current, phaseRecorder, schedule, reactorContext, projectBuild,
                                                dependencyContext );
                        totalMojoTime += ( System.currentTimeMillis() - mojoStart );

                        current.setComplete();
                        builtLogItem.setComplete();

                        ExecutionPlanItem nextPlanItem = planItems.hasNext() ? planItems.next() : null;
                        if ( nextPlanItem != null && phaseRecorder.isDifferentPhase( nextPlanItem.getMojoExecution() ) )
                        {

                            final Schedule scheduleOfNext = nextPlanItem.getSchedule();
                            if ( scheduleOfNext == null || !scheduleOfNext.isParallel() )
                            {
                                waitForAppropriateUpstreamExecutionsToFinish( builtLogItem, nextPlanItem, projectBuild,
                                                                              scheduleOfNext );
                            }

                            for ( ArtifactLink dependencyLink : dependencyLinks )
                            {
                                dependencyLink.resolveFromUpstream();
                            }
                        }
                        current = nextPlanItem;
                    }

                    final BuildSuccess summary =
                        new BuildSuccess( projectBuild.getProject(), totalMojoTime ); // - waitingTime
                    reactorContext.getResult().addBuildSummary( summary );
                    eventCatapult.fire( ExecutionEvent.Type.ProjectSucceeded, projectBuild.getSession(), null );
                }
                catch ( Exception e )
                {
                    builderCommon.handleBuildError( reactorContext, rootSession, projectBuild.getProject(), e,
                                                    buildStartTime );
                }
                finally
                {
                    if ( current != null )
                    {
                        executionPlan.forceAllComplete();
                    }
                    // muxer.setThisModuleComplete( projectBuild );
                }
                return null;
            }

        };
    }
2979#private void waitForAppropriateUpstreamExecutionsToFinish( BuildLogItem builtLogItem,
                                                               ExecutionPlanItem nextPlanItem,
                                                               ProjectSegment projectBuild, Schedule scheduleOfNext )
        throws InterruptedException
    {
        for ( MavenProject upstreamProject : projectBuild.getImmediateUpstreamProjects() )
        {
            final MavenExecutionPlan upstreamPlan = executionPlans.get( upstreamProject );
            final String nextPhase = scheduleOfNext != null && scheduleOfNext.hasUpstreamPhaseDefined()
                ? scheduleOfNext.getUpstreamPhase()
                : nextPlanItem.getLifecyclePhase();
            final ExecutionPlanItem upstream = upstreamPlan.findLastInPhase( nextPhase );

            if ( upstream != null )
            {
                long startWait = System.currentTimeMillis();
                upstream.waitUntilDone();
                builtLogItem.addWait( upstreamProject, upstream, startWait );
            }
            else if ( !upstreamPlan.containsPhase( nextPhase ) )
            {
                // Still a bit of a kludge; if we cannot connect in a sensible way to
                // the upstream build plan we just revert to waiting for it all to
                // complete. Real problem is per-mojo phase->lifecycle mapping
                builtLogItem.addDependency( upstreamProject, "No phase tracking possible " );
                upstreamPlan.waitUntilAllDone();
            }
            else
            {
                builtLogItem.addDependency( upstreamProject, "No schedule" );
            }
        }
    }
2980#private Collection<ArtifactLink> getUpstreamReactorDependencies( ProjectSegment projectBuild )
    {
        Collection<ArtifactLink> result = new ArrayList<ArtifactLink>();
        for ( MavenProject upstreamProject : projectBuild.getTransitiveUpstreamProjects() )
        {
            Artifact upStreamArtifact = upstreamProject.getArtifact();
            if ( upStreamArtifact != null )
            {
                Artifact dependencyArtifact = findDependency( projectBuild.getProject(), upStreamArtifact );
                if ( dependencyArtifact != null )
                {
                    result.add( new ArtifactLink( dependencyArtifact, upStreamArtifact ) );
                }
            }

            Artifact upStreamTestScopedArtifact = findTestScopedArtifact( upstreamProject );
            if ( upStreamTestScopedArtifact != null )
            {
                Artifact dependencyArtifact = findDependency( projectBuild.getProject(), upStreamArtifact );
                if ( dependencyArtifact != null )
                {
                    result.add( new ArtifactLink( dependencyArtifact, upStreamTestScopedArtifact ) );
                }
            }
        }
        return result;
    }
2981#private Artifact findTestScopedArtifact( MavenProject upstreamProject )
    {
        if ( upstreamProject == null )
        {
            return null;
        }

        List<Artifact> artifactList = upstreamProject.getAttachedArtifacts();
        for ( Artifact artifact : artifactList )
        {
            if ( Artifact.SCOPE_TEST.equals( artifact.getScope() ) )
            {
                return artifact;
            }
        }
        return null;
    }
2982#private static boolean isThreadLockedAndEmpty(Artifact artifact){
        return artifact instanceof  ThreadLockedArtifact && !((ThreadLockedArtifact) artifact).hasReal();
    }
2983#private static Artifact findDependency( MavenProject project, Artifact upStreamArtifact )
    {
        if ( upStreamArtifact == null || isThreadLockedAndEmpty(upStreamArtifact))
        {
            return null;
        }

        String key = ArtifactUtils.key( upStreamArtifact.getGroupId(), upStreamArtifact.getArtifactId(),
                                        upStreamArtifact.getVersion() );
        final Set<Artifact> deps = project.getDependencyArtifacts();
        for ( Artifact dep : deps )
        {
            String depKey = ArtifactUtils.key( dep.getGroupId(), dep.getArtifactId(), dep.getVersion() );
            if ( key.equals( depKey ) )
            {
                return dep;
            }
        }
        return null;

    }
2984#private void buildExecutionPlanItem( ExecutionPlanItem current, PhaseRecorder phaseRecorder, Schedule schedule,
                                         ReactorContext reactorContext, ProjectSegment projectBuild,
                                         DependencyContext dependencyContext )
        throws LifecycleExecutionException
    {
        if ( schedule != null && schedule.isMojoSynchronized() )
        {
            synchronized ( current.getPlugin() )
            {
                buildExecutionPlanItem( reactorContext, current, projectBuild, dependencyContext, phaseRecorder );
            }
        }
        else
        {
            buildExecutionPlanItem( reactorContext, current, projectBuild, dependencyContext, phaseRecorder );
        }
    }
2985#private void buildExecutionPlanItem( ReactorContext reactorContext, ExecutionPlanItem node,
                                         ProjectSegment projectBuild, DependencyContext dependencyContext,
                                         PhaseRecorder phaseRecorder )
        throws LifecycleExecutionException
    {

        MavenProject currentProject = projectBuild.getProject();

        long buildStartTime = System.currentTimeMillis();

        CurrentPhaseForThread.setPhase(  node.getLifecyclePhase() );

        MavenSession sessionForThisModule = projectBuild.getSession();
        try
        {

            if ( reactorContext.getReactorBuildStatus().isHaltedOrBlacklisted( currentProject ) )
            {
                return;
            }

            BuilderCommon.attachToThread( currentProject );

            mojoExecutor.execute( sessionForThisModule, node.getMojoExecution(), reactorContext.getProjectIndex(),
                                  dependencyContext, phaseRecorder );

            final BuildSuccess summary =
                new BuildSuccess( currentProject, System.currentTimeMillis() - buildStartTime );
            reactorContext.getResult().addBuildSummary( summary );
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( reactorContext.getOriginalContextClassLoader() );
        }
    }
2986#public static boolean isWeaveMode( MavenExecutionRequest request )
    {
        return "true".equals( request.getUserProperties().getProperty( "maven3.weaveMode" ) );
    }
2987#public static void setWeaveMode( Properties properties )
    {
        properties.setProperty( "maven3.weaveMode", "true" );
    }
2988#ArtifactLink( Artifact artifactInThis, Artifact upstream )
        {
            this.artifactInThis = artifactInThis;
            this.upstream = upstream;
        }
2989#public void resolveFromUpstream()
        {
            artifactInThis.setFile( upstream.getFile() );
            artifactInThis.setRepository( upstream.getRepository() );
            artifactInThis.setResolved( true ); // Or maybe upstream.isResolved()....

        }
2990#public DependencyContext( MavenProject project, Collection<String> scopesToCollect,
                              Collection<String> scopesToResolve )
    {
        this.project = project;
        scopesToCollectForCurrentProject = scopesToCollect;
        scopesToResolveForCurrentProject = scopesToResolve;
        scopesToCollectForAggregatedProjects = Collections.synchronizedSet( new TreeSet<String>() );
        scopesToResolveForAggregatedProjects = Collections.synchronizedSet( new TreeSet<String>() );
    }
2991#public MavenProject getProject()
    {
        return project;
    }
2992#public Collection<String> getScopesToCollectForCurrentProject()
    {
        return scopesToCollectForCurrentProject;
    }
2993#public Collection<String> getScopesToResolveForCurrentProject()
    {
        return scopesToResolveForCurrentProject;
    }
2994#public Collection<String> getScopesToCollectForAggregatedProjects()
    {
        return scopesToCollectForAggregatedProjects;
    }
2995#public Collection<String> getScopesToResolveForAggregatedProjects()
    {
        return scopesToResolveForAggregatedProjects;
    }
2996#public boolean isResolutionRequiredForCurrentProject()
    {
        if ( lastDependencyArtifacts != project.getDependencyArtifacts()
            || ( lastDependencyArtifacts != null && lastDependencyArtifactCount != lastDependencyArtifacts.size() ) )
        {
            return true;

        }
        return false;
    }
2997#public boolean isResolutionRequiredForAggregatedProjects( Collection<String> scopesToCollect,
                                                              Collection<String> scopesToResolve )
    {
        boolean required =
            scopesToCollectForAggregatedProjects.addAll( scopesToCollect )
                || scopesToResolveForAggregatedProjects.addAll( scopesToResolve );
        return required;
    }
2998#public void synchronizeWithProjectState()
    {
        lastDependencyArtifacts = project.getDependencyArtifacts();
        lastDependencyArtifactCount = ( lastDependencyArtifacts != null ) ? lastDependencyArtifacts.size() : 0;
    }
2999#public LifecycleTask( String lifecyclePhase )
    {
        this.lifecyclePhase = lifecyclePhase;
    }
3000#@Override
    public String toString()
    {
        return getLifecyclePhase();
    }
3001#public String getLifecyclePhase()
    {
        return lifecyclePhase;
    }
3002#public DefaultLifecyclePluginAnalyzer()
    {
    }
3003#// These methods deal with construction intact Plugin object that look like they come from a standard
    // <plugin/> block in a Maven POM. We have to do some wiggling to pull the sources of information
    // together and this really shows the problem of constructing a sensible default configuration but
    // it's all encapsulated here so it appears normalized to the POM builder.

    // We are going to take the project packaging and find all plugin in the default lifecycle and create
    // fully populated Plugin objects, including executions with goals and default configuration taken
    // from the plugin.xml inside a plugin.
    //

    public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        if ( logger.isDebugEnabled() )
        {
            logger.debug( "Looking up lifecyle mappings for packaging " + packaging + " from " +
                Thread.currentThread().getContextClassLoader() );
        }

        LifecycleMapping lifecycleMappingForPackaging = lifecycleMappings.get( packaging );

        if ( lifecycleMappingForPackaging == null )
        {
            return null;
        }

        Map<Plugin, Plugin> plugins = new LinkedHashMap<Plugin, Plugin>();

        for ( Lifecycle lifecycle : getOrderedLifecycles() )
        {
            org.apache.maven.lifecycle.mapping.Lifecycle lifecycleConfiguration =
                lifecycleMappingForPackaging.getLifecycles().get( lifecycle.getId() );

            Map<String, String> phaseToGoalMapping = null;

            if ( lifecycleConfiguration != null )
            {
                phaseToGoalMapping = lifecycleConfiguration.getPhases();
            }
            else if ( lifecycle.getDefaultPhases() != null )
            {
                phaseToGoalMapping = lifecycle.getDefaultPhases();
            }

            if ( phaseToGoalMapping != null )
            {
                // These are of the form:
                //
                // compile -> org.apache.maven.plugins:maven-compiler-plugin:compile[,gid:aid:goal,...]
                //
                for ( Map.Entry<String, String> goalsForLifecyclePhase : phaseToGoalMapping.entrySet() )
                {
                    String phase = goalsForLifecyclePhase.getKey();
                    String goals = goalsForLifecyclePhase.getValue();
                    if ( goals != null )
                    {
                        parseLifecyclePhaseDefinitions( plugins, phase, goals );
                    }
                }
            }
        }

        return plugins.keySet();
    }
3004#private List<Lifecycle> getOrderedLifecycles()
    {
        // NOTE: The lifecycle order can affect implied execution ids so we better be deterministic.

        List<Lifecycle> lifecycles = new ArrayList<Lifecycle>( defaultLifeCycles.getLifeCycles() );

        Collections.sort( lifecycles, new Comparator<Lifecycle>()
        {

            public int compare( Lifecycle l1, Lifecycle l2 )
            {
                return l1.getId().compareTo( l2.getId() );
            }

        } );

        return lifecycles;
    }
3005#private void parseLifecyclePhaseDefinitions( Map<Plugin, Plugin> plugins, String phase, String goals )
    {
        String[] mojos = StringUtils.split( goals, "," );

        for ( int i = 0; i < mojos.length; i++ )
        {
            GoalSpec gs = parseGoalSpec( mojos[i].trim() );

            if ( gs == null )
            {
                logger.warn( "Ignored invalid goal specification '" + mojos[i] + "' from lifecycle mapping for phase "
                    + phase );
                continue;
            }

            Plugin plugin = new Plugin();
            plugin.setGroupId( gs.groupId );
            plugin.setArtifactId( gs.artifactId );
            plugin.setVersion( gs.version );

            Plugin existing = plugins.get( plugin );
            if ( existing != null )
            {
                if ( existing.getVersion() == null )
                {
                    existing.setVersion( plugin.getVersion() );
                }
                plugin = existing;
            }
            else
            {
                plugins.put( plugin, plugin );
            }

            PluginExecution execution = new PluginExecution();
            execution.setId( getExecutionId( plugin, gs.goal ) );
            execution.setPhase( phase );
            execution.setPriority( i - mojos.length );
            execution.getGoals().add( gs.goal );

            plugin.getExecutions().add( execution );
        }
    }
3006#private GoalSpec parseGoalSpec( String goalSpec )
    {
        GoalSpec gs = new GoalSpec();

        String[] p = StringUtils.split( goalSpec.trim(), ":" );

        if ( p.length == 3 )
        {
            // <groupId>:<artifactId>:<goal>
            gs.groupId = p[0];
            gs.artifactId = p[1];
            gs.goal = p[2];
        }
        else if ( p.length == 4 )
        {
            // <groupId>:<artifactId>:<version>:<goal>
            gs.groupId = p[0];
            gs.artifactId = p[1];
            gs.version = p[2];
            gs.goal = p[3];
        }
        else
        {
            // invalid
            gs = null;
        }

        return gs;
    }
3007#private String getExecutionId( Plugin plugin, String goal )
    {
        Set<String> existingIds = new HashSet<String>();
        for ( PluginExecution execution : plugin.getExecutions() )
        {
            existingIds.add( execution.getId() );
        }

        String base = "default-" + goal;
        String id = base;

        for ( int index = 1; existingIds.contains( id ); index++ )
        {
            id = base + '-' + index;
        }

        return id;
    }
3008#public DefaultExecutionEvent( Type type, MavenSession session, MojoExecution mojoExecution, Exception exception )
    {
        this.type = type;
        this.session = session;
        this.mojoExecution = mojoExecution;
        this.exception = exception;
    }
3009#public Type getType()
    {
        return type;
    }
3010#public MavenSession getSession()
    {
        return session;
    }
3011#public MavenProject getProject()
    {
        return session.getCurrentProject();
    }
3012#public MojoExecution getMojoExecution()
    {
        return mojoExecution;
    }
3013#public Exception getException()
    {
        return exception;
    }
3014#public BuildLogItem( MavenProject project, ExecutionPlanItem executionPlanItem )
    {
        this.executionPlanItem = executionPlanItem;
        this.project = project;
        startTime = System.currentTimeMillis();

    }
3015#public MavenProject getProject()
    {
        return project;
    }
3016#public void setComplete()
    {
        endTime = System.currentTimeMillis();
    }
3017#public void addWait( MavenProject upstreamProject, ExecutionPlanItem inSchedule, long startWait )
    {
        long now = System.currentTimeMillis();
        dependencies.add( new DependencyLogEntry( upstreamProject, inSchedule, startWait, now, null ) );
    }
3018#public void addDependency( MavenProject upstreamProject, String message )
    {
        dependencies.add( new DependencyLogEntry( upstreamProject, message ) );
    }
3019#public String toString( long rootStart )
    {
        StringBuilder result = new StringBuilder();
        result.append( String.format( "%1d  %2d ", startTime - rootStart, endTime - rootStart ) );
        result.append( project.getName() );
        result.append( " " );
        result.append( getMojoExecutionDescription( executionPlanItem ) );
        if ( dependencies.size() > 0 )
        {
            result.append( "\n" );
            for ( DependencyLogEntry waitLogEntry : dependencies )
            {
                result.append( "    " );
                result.append( waitLogEntry.toString() );
                result.append( "\n" );
            }
        }
        return result.toString();
    }
3020#public Object toGraph( long rootStart )
    {
        StringBuilder result = new StringBuilder();
        if ( dependencies.size() > 0 )
        {
            for ( DependencyLogEntry waitLogEntry : dependencies )
            {
                result.append( "        " );
                result.append( nodeKey( project, executionPlanItem ) );
                result.append( " ->   " );
                result.append( waitLogEntry.toNodeKey() );
                result.append( waitLogEntry.toNodeDescription( rootStart ) );
                result.append( "\n" );
            }
        }
        else
        {
            result.append( "        " );
            result.append( nodeKey( project, executionPlanItem ) );
            result.append( "\n" );
        }
        return result.toString();
    }
3021#private static String nodeKey( MavenProject mavenProject, ExecutionPlanItem executionPlanItem )
    {
        String key = mavenProject.getArtifactId();
        if ( executionPlanItem != null )
        {
            key += "_" + getMojoExecutionDescription( executionPlanItem );
        }
        return key.replace( ".", "_" ).replace( ":", "_" );
    }
3022#private static String getMojoExecutionDescription( ExecutionPlanItem executionPlanItem )
    {
        if ( executionPlanItem.getMojoExecution() != null )
        {
            return executionPlanItem.getMojoExecution().getArtifactId() + getLifeCyclePhase( executionPlanItem );
        }
        else
        {
            return "";
        }
    }
3023#private static String getLifeCyclePhase( ExecutionPlanItem executionPlanItem )
    {
        return executionPlanItem.getLifecyclePhase() != null ? "[" + executionPlanItem.getLifecyclePhase() + "]" : "";
    }
3024#DependencyLogEntry( MavenProject upstreamProject, ExecutionPlanItem executionPlanItem, Long start, Long stop,
                            String message )
        {
            this.upstreamProject = upstreamProject;
            this.executionPlanItem = executionPlanItem;
            this.start = start;
            this.stop = stop;
            this.message = message;
        }
3025#DependencyLogEntry( MavenProject upstreamProject, String message )
        {
            this( upstreamProject, null, null, null, message );
        }
3026#public String toString()
        {
            return upstreamProject.getName() + ":" + getExecutionPlanItem() + getElapsed() + getMessage();
        }
3027#public String toNodeKey()
        {
            return nodeKey( upstreamProject, executionPlanItem );
        }
3028#public String toNodeDescription( long rootStart )
        {
            return "";
        }
3029#private String getMessage()
        {
            return message != null ? message : "";
        }
3030#private String getExecutionPlanItem()
        {
            if ( executionPlanItem != null )
            {
                return getMojoExecutionDescription( executionPlanItem );
            }
            else
            {
                return "";
            }
        }
3031#private String getElapsed()
        {
            if ( start != null && stop != null )
            {
                long elapsed = stop - start;
                return elapsed > 0 ? ", wait=" + elapsed : "";
            }
            return "";
        }
3032#public ConcurrencyDependencyGraph( ProjectBuildList projectBuilds, ProjectDependencyGraph projectDependencyGraph )
    {
        this.projectDependencyGraph = projectDependencyGraph;
        this.projectBuilds = projectBuilds;
    }
3033#public int getNumberOfBuilds()
    {
        return projectBuilds.size();
    }
3034#/**
     * Gets all the builds that have no reactor-dependencies
     *
     * @return A list of all the initial builds
     */

    public List<MavenProject> getRootSchedulableBuilds()
    {
        List<MavenProject> result = new ArrayList<MavenProject>();
        for ( ProjectSegment projectBuild : projectBuilds )
        {
            if ( projectDependencyGraph.getUpstreamProjects( projectBuild.getProject(), false ).size() == 0 )
            {
                result.add( projectBuild.getProject() );
            }
        }
        return result;
    }
3035#/**
     * Marks the provided project as finished. Returns a list of
     *
     * @param mavenProject The project
     * @return The list of builds that are eligible for starting now that the provided project is done
     */
    public List<MavenProject> markAsFinished( MavenProject mavenProject )
    {
        finishedProjects.add( mavenProject );
        return getSchedulableNewProcesses( mavenProject );
    }
3036#private List<MavenProject> getSchedulableNewProcesses( MavenProject finishedProject )
    {
        List<MavenProject> result = new ArrayList<MavenProject>();
        // schedule dependent projects, if all of their requirements are met
        for ( MavenProject dependentProject : projectDependencyGraph.getDownstreamProjects( finishedProject, false ) )
        {
            final List<MavenProject> upstreamProjects =
                projectDependencyGraph.getUpstreamProjects( dependentProject, false );
            if ( finishedProjects.containsAll( upstreamProjects ) )
            {
                result.add( dependentProject );
            }
        }
        return result;
    }
3037#public ProjectBuildList getProjectBuilds()
    {
        return projectBuilds;
    }
3038#public static void setPhase( String phase )
    {
        threadPhase.set( phase );
    }
3039#public static boolean isPhase( String phase )
    {
        return phase.equals( threadPhase.get() );
    }
3040#public void fire( ExecutionEvent.Type eventType, MavenSession session, MojoExecution mojoExecution )
    {
        fire( eventType, session, mojoExecution, null );
    }
3041#public void fire( ExecutionEvent.Type eventType, MavenSession session, MojoExecution mojoExecution,
                      Exception exception )
    {
        ExecutionListener listener = session.getRequest().getExecutionListener();

        if ( listener != null )
        {
            ExecutionEvent event = new DefaultExecutionEvent( eventType, session, mojoExecution, exception );

            switch ( eventType )
            {
                case ProjectDiscoveryStarted:
                    listener.projectDiscoveryStarted( event );
                    break;

                case SessionStarted:
                    listener.sessionStarted( event );
                    break;
                case SessionEnded:
                    listener.sessionEnded( event );
                    break;

                case ProjectSkipped:
                    listener.projectSkipped( event );
                    break;
                case ProjectStarted:
                    listener.projectStarted( event );
                    break;
                case ProjectSucceeded:
                    listener.projectSucceeded( event );
                    break;
                case ProjectFailed:
                    listener.projectFailed( event );
                    break;

                case MojoSkipped:
                    listener.mojoSkipped( event );
                    break;
                case MojoStarted:
                    listener.mojoStarted( event );
                    break;
                case MojoSucceeded:
                    listener.mojoSucceeded( event );
                    break;
                case MojoFailed:
                    listener.mojoFailed( event );
                    break;

                case ForkStarted:
                    listener.forkStarted( event );
                    break;
                case ForkSucceeded:
                    listener.forkSucceeded( event );
                    break;
                case ForkFailed:
                    listener.forkFailed( event );
                    break;

                case ForkedProjectStarted:
                    listener.forkedProjectStarted( event );
                    break;
                case ForkedProjectSucceeded:
                    listener.forkedProjectSucceeded( event );
                    break;
                case ForkedProjectFailed:
                    listener.forkedProjectFailed( event );
                    break;

                default:
                    throw new IllegalStateException( "Unknown execution event type " + eventType );
            }
        }
    }
3042#@SuppressWarnings( { "UnusedDeclaration" } )
    public LifecycleDebugLogger()
    {
    }
3043#public LifecycleDebugLogger( Logger logger )
    {
        this.logger = logger;
    }
3044#public void debug( String s )
    {
        logger.debug( s );
    }
3045#public void info( String s )
    {
        logger.info( s );
    }
3046#public void debugReactorPlan( ProjectBuildList projectBuilds )
    {
        if ( !logger.isDebugEnabled() )
        {
            return;
        }

        logger.debug( "=== REACTOR BUILD PLAN ================================================" );

        for ( Iterator<ProjectSegment> it = projectBuilds.iterator(); it.hasNext(); )
        {
            ProjectSegment projectBuild = it.next();

            logger.debug( "Project: " + projectBuild.getProject().getId() );
            logger.debug( "Tasks:   " + projectBuild.getTaskSegment().getTasks() );
            logger.debug( "Style:   " + ( projectBuild.getTaskSegment().isAggregating() ? "Aggregating" : "Regular" ) );

            if ( it.hasNext() )
            {
                logger.debug( "-----------------------------------------------------------------------" );
            }
        }

        logger.debug( "=======================================================================" );
    }
3047#public void debugProjectPlan( MavenProject currentProject, MavenExecutionPlan executionPlan )
    {
        if ( !logger.isDebugEnabled() )
        {
            return;
        }

        logger.debug( "=== PROJECT BUILD PLAN ================================================" );
        logger.debug( "Project:       " + BuilderCommon.getKey( currentProject ) );

        debugDependencyRequirements( executionPlan.getMojoExecutions() );

        logger.debug( "Repositories (dependencies): " + currentProject.getRemoteProjectRepositories() );
        logger.debug( "Repositories (plugins)     : " + currentProject.getRemotePluginRepositories() );

        for ( ExecutionPlanItem mojoExecution : executionPlan )
        {
            debugMojoExecution( mojoExecution.getMojoExecution() );
        }

        logger.debug( "=======================================================================" );
    }
3048#private void debugMojoExecution( MojoExecution mojoExecution )
    {
        String mojoExecId =
            mojoExecution.getGroupId() + ':' + mojoExecution.getArtifactId() + ':' + mojoExecution.getVersion() + ':'
                + mojoExecution.getGoal() + " (" + mojoExecution.getExecutionId() + ')';

        Map<String, List<MojoExecution>> forkedExecutions = mojoExecution.getForkedExecutions();
        if ( !forkedExecutions.isEmpty() )
        {
            for ( Map.Entry<String, List<MojoExecution>> fork : forkedExecutions.entrySet() )
            {
                logger.debug( "--- init fork of " + fork.getKey() + " for " + mojoExecId + " ---" );

                debugDependencyRequirements( fork.getValue() );

                for ( MojoExecution forkedExecution : fork.getValue() )
                {
                    debugMojoExecution( forkedExecution );
                }

                logger.debug( "--- exit fork of " + fork.getKey() + " for " + mojoExecId + " ---" );
            }
        }

        logger.debug( "-----------------------------------------------------------------------" );
        logger.debug( "Goal:          " + mojoExecId );
        logger.debug(
            "Style:         " + ( mojoExecution.getMojoDescriptor().isAggregator() ? "Aggregating" : "Regular" ) );
        logger.debug( "Configuration: " + mojoExecution.getConfiguration() );
    }
3049#private void debugDependencyRequirements( List<MojoExecution> mojoExecutions )
    {
        Set<String> scopesToCollect = new TreeSet<String>();
        Set<String> scopesToResolve = new TreeSet<String>();

        for ( MojoExecution mojoExecution : mojoExecutions )
        {
            MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();

            String scopeToCollect = mojoDescriptor.getDependencyCollectionRequired();
            if ( StringUtils.isNotEmpty( scopeToCollect ) )
            {
                scopesToCollect.add( scopeToCollect );
            }

            String scopeToResolve = mojoDescriptor.getDependencyResolutionRequired();
            if ( StringUtils.isNotEmpty( scopeToResolve ) )
            {
                scopesToResolve.add( scopeToResolve );
            }
        }

        logger.debug( "Dependencies (collect): " + scopesToCollect );
        logger.debug( "Dependencies (resolve): " + scopesToResolve );
    }
3050#public void logWeavePlan( MavenSession session )
    {
        if ( !logger.isInfoEnabled() )
        {
            return;
        }

        final ProjectDependencyGraph dependencyGraph = session.getProjectDependencyGraph();
        logger.info( "=== WEAVE CONCURRENCY BUILD PLAN ======================================" );
        for ( MavenProject mavenProject : dependencyGraph.getSortedProjects() )
        {

            StringBuilder item = new StringBuilder();
            item.append( "Project: " );
            item.append( mavenProject.getArtifactId() );
            final List<MavenProject> upstreamProjects = dependencyGraph.getUpstreamProjects( mavenProject, false );
            if ( upstreamProjects.size() > 0 )
            {
                item.append( " ( " );
                for ( Iterator<MavenProject> it = upstreamProjects.iterator(); it.hasNext(); )
                {
                    final MavenProject kid = it.next();
                    item.append( kid.getArtifactId() );
                    if ( it.hasNext() )
                    {
                        item.append( ", " );
                    }
                }
                item.append( ")" );
            }
            logger.info( item.toString() );

        }
        logger.info( "=======================================================================" );
    }
3051#public void execute( MavenSession session )
    {
        eventCatapult.fire( ExecutionEvent.Type.SessionStarted, session, null );

        MavenExecutionResult result = session.getResult();

        try
        {
            if ( !session.isUsingPOMsFromFilesystem() && lifecycleTaskSegmentCalculator.requiresProject( session ) )
            {
                throw new MissingProjectException( "The goal you specified requires a project to execute"
                    + " but there is no POM in this directory (" + session.getExecutionRootDirectory() + ")."
                    + " Please verify you invoked Maven from the correct directory." );
            }

            final MavenExecutionRequest executionRequest = session.getRequest();
            boolean isThreaded = executionRequest.isThreadConfigurationPresent();
            session.setParallel( isThreaded );

            List<TaskSegment> taskSegments = lifecycleTaskSegmentCalculator.calculateTaskSegments( session );

            ProjectBuildList projectBuilds = buildListCalculator.calculateProjectBuilds( session, taskSegments );

            if ( projectBuilds.isEmpty() )
            {
                throw new NoGoalSpecifiedException( "No goals have been specified for this build."
                    + " You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or"
                    + " <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>."
                    + " Available lifecycle phases are: " + defaultLifeCycles.getLifecyclePhaseList() + "." );
            }

            ProjectIndex projectIndex = new ProjectIndex( session.getProjects() );

            if ( logger.isDebugEnabled() )
            {
                lifecycleDebugLogger.debugReactorPlan( projectBuilds );
            }

            ClassLoader oldContextClassLoader = Thread.currentThread().getContextClassLoader();

            ReactorBuildStatus reactorBuildStatus = new ReactorBuildStatus( session.getProjectDependencyGraph() );
            ReactorContext callableContext =
                new ReactorContext( result, projectIndex, oldContextClassLoader, reactorBuildStatus );

            if ( isThreaded )
            {
                ExecutorService executor =
                    threadConfigService.getExecutorService( executionRequest.getThreadCount(),
                                                            executionRequest.isPerCoreThreadCount(),
                                                            session.getProjects().size() );
                try
                {

                    final boolean isWeaveMode = LifecycleWeaveBuilder.isWeaveMode( executionRequest );
                    if ( isWeaveMode )
                    {
                        lifecycleDebugLogger.logWeavePlan( session );
                        lifeCycleWeaveBuilder.build( projectBuilds, callableContext, taskSegments, session, executor,
                                                     reactorBuildStatus );
                    }
                    else
                    {
                        ConcurrencyDependencyGraph analyzer =
                            new ConcurrencyDependencyGraph( projectBuilds, session.getProjectDependencyGraph() );

                        CompletionService<ProjectSegment> service =
                            new ExecutorCompletionService<ProjectSegment>( executor );

                        lifecycleThreadedBuilder.build( session, callableContext, projectBuilds, taskSegments, analyzer,
                                                        service );
                    }
                }
                finally
                {
                    executor.shutdown();
                    // If the builder has terminated with an exception we want to catch any stray threads before going
                    // to System.exit in the mavencli.
                    executor.awaitTermination( 5, TimeUnit.SECONDS ) ;
                }
            }
            else
            {
                singleThreadedBuild( session, callableContext, projectBuilds, taskSegments, reactorBuildStatus );
            }

        }
        catch ( Exception e )
        {
            result.addException( e );
        }

        eventCatapult.fire( ExecutionEvent.Type.SessionEnded, session, null );
    }
3052#private void singleThreadedBuild( MavenSession session, ReactorContext callableContext,
                                      ProjectBuildList projectBuilds, List<TaskSegment> taskSegments,
                                      ReactorBuildStatus reactorBuildStatus )
    {
        for ( TaskSegment taskSegment : taskSegments )
        {
            for ( ProjectSegment projectBuild : projectBuilds.getByTaskSegment( taskSegment ) )
            {
                try
                {
                    lifecycleModuleBuilder.buildProject( session, callableContext, projectBuild.getProject(),
                                                         taskSegment );
                    if ( reactorBuildStatus.isHalted() )
                    {
                        break;
                    }
                }
                catch ( Exception e )
                {
                    break;  // Why are we just ignoring this exception? Are exceptions are being used for flow control
                }

            }
        }
    }
3053#public TaskSegment( boolean aggregating )
    {
        this.aggregating = aggregating;
        tasks = new ArrayList<Object>();
    }
3054#public TaskSegment( boolean aggregating, Object... tasks )
    {
        this.aggregating = aggregating;
        this.tasks = new ArrayList<Object>( Arrays.asList( tasks ) );
    }
3055#@Override
    public String toString()
    {
        return getTasks().toString();
    }
3056#public List<Object> getTasks()
    {
        return tasks;
    }
3057#public boolean isAggregating()
    {
        return aggregating;
    }
3058#public ProjectBuildList calculateProjectBuilds( MavenSession session, List<TaskSegment> taskSegments )
    {
        List<ProjectSegment> projectBuilds = new ArrayList<ProjectSegment>();

        MavenProject rootProject = session.getTopLevelProject();

        for ( TaskSegment taskSegment : taskSegments )
        {
            List<MavenProject> projects;

            if ( taskSegment.isAggregating() )
            {
                projects = Collections.singletonList( rootProject );
            }
            else
            {
                projects = session.getProjects();
            }
            for ( MavenProject project : projects )
            {
                BuilderCommon.attachToThread( project ); // Not totally sure if this is needed for anything
                MavenSession copiedSession = session.clone();
                copiedSession.setCurrentProject( project );
                projectBuilds.add( new ProjectSegment( project, taskSegment, copiedSession ) );
            }
        }
        return new ProjectBuildList( projectBuilds );
    }
3059#public GoalTask( String pluginGoal )
    {
        this.pluginGoal = pluginGoal;
    }
3060#@Override
    public String toString()
    {
        return pluginGoal;
    }
3061#@SuppressWarnings( { "UnusedDeclaration" } )
    public LifecycleThreadedBuilder()
    {
    }
3062#public void build( MavenSession session, ReactorContext reactorContext, ProjectBuildList projectBuilds,
                       List<TaskSegment> currentTaskSegment, ConcurrencyDependencyGraph analyzer,
                       CompletionService<ProjectSegment> service )
    {

        // Currently disabled
        ThreadOutputMuxer muxer = null; // new ThreadOutputMuxer( analyzer.getProjectBuilds(), System.out );

        for ( TaskSegment taskSegment : currentTaskSegment )
        {
            Map<MavenProject, ProjectSegment> projectBuildMap = projectBuilds.selectSegment( taskSegment );
                try
                {
                multiThreadedProjectTaskSegmentBuild( analyzer, reactorContext, session, service, taskSegment,
                                                      projectBuildMap, muxer );
                    if ( reactorContext.getReactorBuildStatus().isHalted( ) )
                    {
                        break;
                    }
                }
                catch ( Exception e )
                {
                    break;  // Why are we just ignoring this exception? Are exceptions are being used for flow control
                }

        }
    }
3063#private void multiThreadedProjectTaskSegmentBuild( ConcurrencyDependencyGraph analyzer,
                                                       ReactorContext reactorContext, MavenSession rootSession,
                                                       CompletionService<ProjectSegment> service,
                                                       TaskSegment taskSegment,
                                                       Map<MavenProject, ProjectSegment> projectBuildList,
                                                       ThreadOutputMuxer muxer )
    {

        // schedule independent projects
        for ( MavenProject mavenProject : analyzer.getRootSchedulableBuilds() )
        {
            ProjectSegment projectSegment = projectBuildList.get( mavenProject );
            logger.debug( "Scheduling: " + projectSegment.getProject() );
            Callable<ProjectSegment> cb =
                createBuildCallable( rootSession, projectSegment, reactorContext, taskSegment, muxer );
            service.submit( cb );
        }

        // for each finished project
        for ( int i = 0; i < analyzer.getNumberOfBuilds(); i++ )
        {
            try
            {
                ProjectSegment projectBuild = service.take().get();
                if ( reactorContext.getReactorBuildStatus().isHalted() )
                {
                    break;
                }
                final List<MavenProject> newItemsThatCanBeBuilt =
                    analyzer.markAsFinished( projectBuild.getProject() );
                for ( MavenProject mavenProject : newItemsThatCanBeBuilt )
                {
                    ProjectSegment scheduledDependent = projectBuildList.get( mavenProject );
                    logger.debug( "Scheduling: " + scheduledDependent );
                    Callable<ProjectSegment> cb =
                        createBuildCallable( rootSession, scheduledDependent, reactorContext, taskSegment, muxer );
                    service.submit( cb );
                }
            }
            catch ( InterruptedException e )
            {
                break;
            }
            catch ( ExecutionException e )
            {
                break;
            }
        }

        // cancel outstanding builds (if any)  - this can happen if an exception is thrown in above block

        Future<ProjectSegment> unprocessed;
        while ( ( unprocessed = service.poll() ) != null )
        {
            try
            {
                unprocessed.get();
            }
            catch ( InterruptedException e )
            {
                throw new RuntimeException( e );
            }
            catch ( ExecutionException e )
            {
                throw new RuntimeException( e );
            }
        }
    }
3064#private Callable<ProjectSegment> createBuildCallable( final MavenSession rootSession,
                                                          final ProjectSegment projectBuild,
                                                          final ReactorContext reactorContext,
                                                          final TaskSegment taskSegment, final ThreadOutputMuxer muxer )
    {
        return new Callable<ProjectSegment>()
        {
            public ProjectSegment call()
            {
                // muxer.associateThreadWithProjectSegment( projectBuild );
                lifecycleModuleBuilder.buildProject( projectBuild.getSession(), rootSession, reactorContext,
                                                     projectBuild.getProject(), taskSegment );
                // muxer.setThisModuleComplete( projectBuild );

                return projectBuild;
            }
        };
    }
3065#public ReactorContext( MavenExecutionResult result, ProjectIndex projectIndex,
                           ClassLoader originalContextClassLoader, ReactorBuildStatus reactorBuildStatus )
    {
        this.result = result;
        this.projectIndex = projectIndex;
        this.originalContextClassLoader = originalContextClassLoader;
        this.reactorBuildStatus = reactorBuildStatus;
    }
3066#public ReactorBuildStatus getReactorBuildStatus()
    {
        return reactorBuildStatus;
    }
3067#public MavenExecutionResult getResult()
    {
        return result;
    }
3068#public ProjectIndex getProjectIndex()
    {
        return projectIndex;
    }
3069#public ClassLoader getOriginalContextClassLoader()
    {
        return originalContextClassLoader;
    }
3070#public ProjectSegment( MavenProject project, TaskSegment taskSegment, MavenSession copiedSession )
    {
        this.project = project;
        this.taskSegment = taskSegment;
        this.session = copiedSession;
        final ProjectDependencyGraph dependencyGraph = getSession().getProjectDependencyGraph();
        nonTransitiveUpstreamProjects = dependencyGraph.getUpstreamProjects( getProject(), false );
        transitiveUpstreamProjects = dependencyGraph.getUpstreamProjects( getProject(), true );
    }
3071#public MavenSession getSession()
    {
        return session;
    }
3072#public MavenProject getProject()
    {
        return project;
    }
3073#public TaskSegment getTaskSegment()
    {
        return taskSegment;
    }
3074#public List<MavenProject> getImmediateUpstreamProjects()
    {
        return nonTransitiveUpstreamProjects;
    }
3075#public List<MavenProject> getTransitiveUpstreamProjects()
    {
        return transitiveUpstreamProjects;
    }
3076#@Override
    public String toString()
    {
        return getProject().getId() + " -> " + getTaskSegment();
    }
3077#public ProjectIndex( List<MavenProject> projects )
    {
        this.projects = new HashMap<String, MavenProject>( projects.size() * 2 );
        this.indices = new HashMap<String, Integer>( projects.size() * 2 );

        for ( int i = 0; i < projects.size(); i++ )
        {
            MavenProject project = projects.get( i );
            String key = BuilderCommon.getKey( project );

            this.getProjects().put( key, project );
            this.getIndices().put( key, i );
        }
    }
3078#public Map<String, MavenProject> getProjects()
    {
        return projects;
    }
3079#public Map<String, Integer> getIndices()
    {
        return indices;
    }
3080#@SuppressWarnings( { "UnusedDeclaration" } )
    public MojoDescriptorCreator()
    {
    }
3081#public MojoDescriptorCreator( PluginVersionResolver pluginVersionResolver, BuildPluginManager pluginManager,
                                  PluginPrefixResolver pluginPrefixResolver,
                                  LifecyclePluginResolver lifecyclePluginResolver )
    {
        this.pluginVersionResolver = pluginVersionResolver;
        this.pluginManager = pluginManager;
        this.pluginPrefixResolver = pluginPrefixResolver;
        this.lifecyclePluginResolver = lifecyclePluginResolver;
    }
3082#private Plugin findPlugin( String groupId, String artifactId, Collection<Plugin> plugins )
    {
        for ( Plugin plugin : plugins )
        {
            if ( artifactId.equals( plugin.getArtifactId() ) && groupId.equals( plugin.getGroupId() ) )
            {
                return plugin;
            }
        }

        return null;
    }
3083#public static Xpp3Dom convert( MojoDescriptor mojoDescriptor )
    {
        Xpp3Dom dom = new Xpp3Dom( "configuration" );

        PlexusConfiguration c = mojoDescriptor.getMojoConfiguration();

        PlexusConfiguration[] ces = c.getChildren();

        if ( ces != null )
        {
            for ( PlexusConfiguration ce : ces )
            {
                String value = ce.getValue( null );
                String defaultValue = ce.getAttribute( "default-value", null );
                if ( value != null || defaultValue != null )
                {
                    Xpp3Dom e = new Xpp3Dom( ce.getName() );
                    e.setValue( value );
                    if ( defaultValue != null )
                    {
                        e.setAttribute( "default-value", defaultValue );
                    }
                    dom.addChild( e );
                }
            }
        }

        return dom;
    }
3084#// org.apache.maven.plugins:maven-remote-resources-plugin:1.0:process

    public MojoDescriptor getMojoDescriptor( String task, MavenSession session, MavenProject project )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginVersionResolutionException
    {
        String goal = null;

        Plugin plugin = null;

        StringTokenizer tok = new StringTokenizer( task, ":" );

        int numTokens = tok.countTokens();

        if ( numTokens >= 4 )
        {
            // We have everything that we need
            //
            // org.apache.maven.plugins:maven-remote-resources-plugin:1.0:process
            //
            // groupId
            // artifactId
            // version
            // goal
            //
            plugin = new Plugin();
            plugin.setGroupId( tok.nextToken() );
            plugin.setArtifactId( tok.nextToken() );
            plugin.setVersion( tok.nextToken() );
            goal = tok.nextToken();

            // This won't be valid, but it constructs something easy to read in the error message
            while ( tok.hasMoreTokens() )
            {
                goal += ":" + tok.nextToken();
            }
        }
        else if ( numTokens == 3 )
        {
            // We have everything that we need except the version
            //
            // org.apache.maven.plugins:maven-remote-resources-plugin:???:process
            //
            // groupId
            // artifactId
            // ???
            // goal
            //
            plugin = new Plugin();
            plugin.setGroupId( tok.nextToken() );
            plugin.setArtifactId( tok.nextToken() );
            goal = tok.nextToken();
        }
        else if ( numTokens <= 2 )
        {
            // We have a prefix and goal
            //
            // idea:idea
            //
            String prefix = tok.nextToken();

            if ( numTokens == 2 )
            {
                goal = tok.nextToken();
            }
            else
            {
                // goal was missing - pass through to MojoNotFoundException
                goal = "";
            }

            // This is the case where someone has executed a single goal from the command line
            // of the form:
            //
            // mvn remote-resources:process
            //
            // From the metadata stored on the server which has been created as part of a standard
            // Maven plugin deployment we will find the right PluginDescriptor from the remote
            // repository.

            plugin = findPluginForPrefix( prefix, session );
        }

        injectPluginDeclarationFromProject( plugin, project );

        // If there is no version to be found then we need to look in the repository metadata for
        // this plugin and see what's specified as the latest release.
        //
        if ( plugin.getVersion() == null )
        {
            resolvePluginVersion( plugin, session, project );
        }

        return pluginManager.getMojoDescriptor( plugin, goal, project.getRemotePluginRepositories(),
                                                session.getRepositorySession() );
    }
3085#// TODO: take repo mans into account as one may be aggregating prefixes of many
    // TODO: collect at the root of the repository, read the one at the root, and fetch remote if something is missing
    // or the user forces the issue

    public Plugin findPluginForPrefix( String prefix, MavenSession session )
        throws NoPluginFoundForPrefixException
    {
        // [prefix]:[goal]

        if ( session.getCurrentProject() != null )
        {
            try
            {
                lifecyclePluginResolver.resolveMissingPluginVersions( session.getCurrentProject(), session );
            }
            catch ( PluginVersionResolutionException e )
            {
                // not critical here
                logger.debug( e.getMessage(), e );
            }
        }

        PluginPrefixRequest prefixRequest = new DefaultPluginPrefixRequest( prefix, session );
        PluginPrefixResult prefixResult = pluginPrefixResolver.resolve( prefixRequest );

        Plugin plugin = new Plugin();
        plugin.setGroupId( prefixResult.getGroupId() );
        plugin.setArtifactId( prefixResult.getArtifactId() );

        return plugin;
    }
3086#private void resolvePluginVersion( Plugin plugin, MavenSession session, MavenProject project )
        throws PluginVersionResolutionException
    {
        PluginVersionRequest versionRequest =
            new DefaultPluginVersionRequest( plugin, session.getRepositorySession(),
                                             project.getRemotePluginRepositories() );
        plugin.setVersion( pluginVersionResolver.resolve( versionRequest ).getVersion() );
    }
3087#private void injectPluginDeclarationFromProject( Plugin plugin, MavenProject project )
    {
        Plugin pluginInPom = findPlugin( plugin, project.getBuildPlugins() );

        if ( pluginInPom == null && project.getPluginManagement() != null )
        {
            pluginInPom = findPlugin( plugin, project.getPluginManagement().getPlugins() );
        }

        if ( pluginInPom != null )
        {
            if ( plugin.getVersion() == null )
            {
                plugin.setVersion( pluginInPom.getVersion() );
            }

            plugin.setDependencies( new ArrayList<Dependency>( pluginInPom.getDependencies() ) );
        }
    }
3088#private Plugin findPlugin( Plugin plugin, Collection<Plugin> plugins )
    {
        return findPlugin( plugin.getGroupId(), plugin.getArtifactId(), plugins );
    }
3089#@SuppressWarnings({"UnusedDeclaration"})
    public LifecycleDependencyResolver()
    {
    }
3090#public LifecycleDependencyResolver( ProjectDependenciesResolver projectDependenciesResolver, Logger logger )
    {
        this.dependenciesResolver = projectDependenciesResolver;
        this.logger = logger;
    }
3091#public static List<MavenProject> getProjects( MavenProject project, MavenSession session, boolean aggregator )
    {
        if ( aggregator )
        {
            return session.getProjects();
        }
        else
        {
            return Collections.singletonList( project );
        }
    }
3092#public void resolveProjectDependencies( MavenProject project, Collection<String> scopesToCollect,
                                            Collection<String> scopesToResolve, MavenSession session,
                                            boolean aggregating, Set<Artifact> projectArtifacts )
        throws LifecycleExecutionException
    {
        ClassLoader tccl = Thread.currentThread().getContextClassLoader();
        try
        {
            ClassLoader projectRealm = project.getClassRealm();
            if ( projectRealm != null && projectRealm != tccl )
            {
                Thread.currentThread().setContextClassLoader( projectRealm );
            }

            if ( project.getDependencyArtifacts() == null )
            {
                try
                {
                    project.setDependencyArtifacts( project.createArtifacts( artifactFactory, null, null ) );
                }
                catch ( InvalidDependencyVersionException e )
                {
                    throw new LifecycleExecutionException( e );
                }
            }

            Set<Artifact> artifacts =
                getDependencies( project, scopesToCollect, scopesToResolve, session, aggregating, projectArtifacts );

            project.setResolvedArtifacts( artifacts );

            Map<String, Artifact> map = new HashMap<String, Artifact>();
            for ( Artifact artifact : artifacts )
            {
                map.put( artifact.getDependencyConflictId(), artifact );
            }
            for ( Artifact artifact : project.getDependencyArtifacts() )
            {
                if ( artifact.getFile() == null )
                {
                    Artifact resolved = map.get( artifact.getDependencyConflictId() );
                    if ( resolved != null )
                    {
                        artifact.setFile( resolved.getFile() );
                        artifact.setDependencyTrail( resolved.getDependencyTrail() );
                        artifact.setResolvedVersion( resolved.getVersion() );
                        artifact.setResolved( true );
                    }
                }
            }
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( tccl );
        }
    }
3093#private Set<Artifact> getDependencies( MavenProject project, Collection<String> scopesToCollect,
                                           Collection<String> scopesToResolve, MavenSession session,
                                           boolean aggregating, Set<Artifact> projectArtifacts )
        throws LifecycleExecutionException
    {
        if ( scopesToCollect == null )
        {
            scopesToCollect = Collections.emptySet();
        }
        if ( scopesToResolve == null )
        {
            scopesToResolve = Collections.emptySet();
        }

        if ( scopesToCollect.isEmpty() && scopesToResolve.isEmpty() )
        {
            return new LinkedHashSet<Artifact>();
        }

        scopesToCollect = new HashSet<String>( scopesToCollect );
        scopesToCollect.addAll( scopesToResolve );

        DependencyFilter collectionFilter = new ScopeDependencyFilter( null, negate( scopesToCollect ) );
        DependencyFilter resolutionFilter = new ScopeDependencyFilter( null, negate( scopesToResolve ) );
        resolutionFilter = AndDependencyFilter.newInstance( collectionFilter, resolutionFilter );
        resolutionFilter =
            AndDependencyFilter.newInstance( resolutionFilter, new ReactorDependencyFilter( projectArtifacts ) );

        DependencyResolutionResult result;
        try
        {
            DefaultDependencyResolutionRequest request =
                new DefaultDependencyResolutionRequest( project, session.getRepositorySession() );
            request.setResolutionFilter( resolutionFilter );

            eventSpyDispatcher.onEvent( request );

            result = dependenciesResolver.resolve( request );
        }
        catch ( DependencyResolutionException e )
        {
            result = e.getResult();

            /*
             * MNG-2277, the check below compensates for our bad plugin support where we ended up with aggregator
             * plugins that require dependency resolution although they usually run in phases of the build where project
             * artifacts haven't been assembled yet. The prime example of this is "mvn release:prepare".
             */
            if ( aggregating && areAllDependenciesInReactor( session.getProjects(), result.getUnresolvedDependencies() ) )
            {
                logger.warn( "The following dependencies could not be resolved at this point of the build"
                    + " but seem to be part of the reactor:" );

                for ( Dependency dependency : result.getUnresolvedDependencies() )
                {
                    logger.warn( "o " + dependency );
                }

                logger.warn( "Try running the build up to the lifecycle phase \"package\"" );
            }
            else
            {
                throw new LifecycleExecutionException( null, project, e );
            }
        }

        eventSpyDispatcher.onEvent( result );

        Set<Artifact> artifacts = new LinkedHashSet<Artifact>();
        if ( result.getDependencyGraph() != null && !result.getDependencyGraph().getChildren().isEmpty() )
        {
            RepositoryUtils.toArtifacts( artifacts, result.getDependencyGraph().getChildren(),
                                         Collections.singletonList( project.getArtifact().getId() ), collectionFilter );
        }
        return artifacts;
    }
3094#private boolean areAllDependenciesInReactor( Collection<MavenProject> projects, Collection<Dependency> dependencies )
    {
        Set<String> projectKeys = getReactorProjectKeys( projects );

        for ( Dependency dependency : dependencies )
        {
            org.sonatype.aether.artifact.Artifact a = dependency.getArtifact();
            String key = ArtifactUtils.key( a.getGroupId(), a.getArtifactId(), a.getVersion() );
            if ( !projectKeys.contains( key ) )
            {
                return false;
            }
        }

        return true;
    }
3095#private Set<String> getReactorProjectKeys( Collection<MavenProject> projects )
    {
        Set<String> projectKeys = new HashSet<String>( projects.size() * 2 );
        for ( MavenProject project : projects )
        {
            String key = ArtifactUtils.key( project.getGroupId(), project.getArtifactId(), project.getVersion() );
            projectKeys.add( key );
        }
        return projectKeys;
    }
3096#private Collection<String> negate( Collection<String> scopes )
    {
        Collection<String> result = new HashSet<String>();
        Collections.addAll( result, "system", "compile", "provided", "runtime", "test" );

        for ( String scope : scopes )
        {
            if ( "compile".equals( scope ) )
            {
                result.remove( "compile" );
                result.remove( "system" );
                result.remove( "provided" );
            }
            else if ( "runtime".equals( scope ) )
            {
                result.remove( "compile" );
                result.remove( "runtime" );
            }
            else if ( "compile+runtime".equals( scope ) )
            {
                result.remove( "compile" );
                result.remove( "system" );
                result.remove( "provided" );
                result.remove( "runtime" );
            }
            else if ( "runtime+system".equals( scope ) )
            {
                result.remove( "compile" );
                result.remove( "system" );
                result.remove( "runtime" );
            }
            else if ( "test".equals( scope ) )
            {
                result.clear();
            }
        }

        return result;
    }
3097#public ReactorDependencyFilter( Collection<Artifact> artifacts )
        {
            for ( Artifact artifact : artifacts )
            {
                String key = ArtifactUtils.key( artifact );
                keys.add( key );
            }
        }
3098#public boolean accept( DependencyNode node, List<DependencyNode> parents )
        {
            Dependency dependency = node.getDependency();
            if ( dependency != null )
            {
                org.sonatype.aether.artifact.Artifact a = dependency.getArtifact();
                String key = ArtifactUtils.key( a.getGroupId(), a.getArtifactId(), a.getVersion() );
                return !keys.contains( key );
            }
            return false;
        }
3099#public LifecyclePluginResolver( PluginVersionResolver pluginVersionResolver )
    {
        this.pluginVersionResolver = pluginVersionResolver;
    }
3100#@SuppressWarnings( { "UnusedDeclaration" } )
    public LifecyclePluginResolver()
    {
    }
3101#public void resolveMissingPluginVersions( MavenProject project, MavenSession session )
        throws PluginVersionResolutionException
    {
        Map<String, String> versions = new HashMap<String, String>( 64 );

        for ( Plugin plugin : project.getBuildPlugins() )
        {
            if ( plugin.getVersion() == null )
            {
                PluginVersionRequest request =
                    new DefaultPluginVersionRequest( plugin, session.getRepositorySession(),
                                                     project.getRemotePluginRepositories() );
                plugin.setVersion( pluginVersionResolver.resolve( request ).getVersion() );
            }
            versions.put( plugin.getKey(), plugin.getVersion() );
        }

        PluginManagement pluginManagement = project.getPluginManagement();
        if ( pluginManagement != null )
        {
            for ( Plugin plugin : pluginManagement.getPlugins() )
            {
                if ( plugin.getVersion() == null )
                {
                    plugin.setVersion( versions.get( plugin.getKey() ) );
                    if ( plugin.getVersion() == null )
                    {
                        PluginVersionRequest request =
                            new DefaultPluginVersionRequest( plugin, session.getRepositorySession(),
                                                             project.getRemotePluginRepositories() );
                        plugin.setVersion( pluginVersionResolver.resolve( request ).getVersion() );
                    }
                }
            }
        }
    }
3102#public MojoExecutor()
    {
    }
3103#public DependencyContext newDependencyContext( MavenSession session, List<MojoExecution> mojoExecutions )
    {
        Set<String> scopesToCollect = new TreeSet<String>();
        Set<String> scopesToResolve = new TreeSet<String>();

        collectDependencyRequirements( scopesToResolve, scopesToCollect, mojoExecutions );

        return new DependencyContext( session.getCurrentProject(), scopesToCollect, scopesToResolve );
    }
3104#private void collectDependencyRequirements( Set<String> scopesToResolve, Set<String> scopesToCollect,
                                                Collection<MojoExecution> mojoExecutions )
    {
        for ( MojoExecution mojoExecution : mojoExecutions )
        {
            MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();

            scopesToResolve.addAll( toScopes( mojoDescriptor.getDependencyResolutionRequired() ) );

            scopesToCollect.addAll( toScopes( mojoDescriptor.getDependencyCollectionRequired() ) );
        }
    }
3105#private Collection<String> toScopes( String classpath )
    {
        if ( StringUtils.isNotEmpty( classpath ) )
        {
            if ( Artifact.SCOPE_COMPILE.equals( classpath ) )
            {
                return Arrays.asList( Artifact.SCOPE_COMPILE, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_PROVIDED );
            }
            else if ( Artifact.SCOPE_RUNTIME.equals( classpath ) )
            {
                return Arrays.asList( Artifact.SCOPE_COMPILE, Artifact.SCOPE_RUNTIME );
            }
            else if ( Artifact.SCOPE_COMPILE_PLUS_RUNTIME.equals( classpath ) )
            {
                return Arrays.asList( Artifact.SCOPE_COMPILE, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_PROVIDED,
                                      Artifact.SCOPE_RUNTIME );
            }
            else if ( Artifact.SCOPE_RUNTIME_PLUS_SYSTEM.equals( classpath ) )
            {
                return Arrays.asList( Artifact.SCOPE_COMPILE, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_RUNTIME );
            }
            else if ( Artifact.SCOPE_TEST.equals( classpath ) )
            {
                return Arrays.asList( Artifact.SCOPE_COMPILE, Artifact.SCOPE_SYSTEM, Artifact.SCOPE_PROVIDED,
                                      Artifact.SCOPE_RUNTIME, Artifact.SCOPE_TEST );
            }
        }
        return Collections.emptyList();
    }
3106#public void execute( MavenSession session, List<MojoExecution> mojoExecutions, ProjectIndex projectIndex )
        throws LifecycleExecutionException

    {
        DependencyContext dependencyContext = newDependencyContext( session, mojoExecutions );

        PhaseRecorder phaseRecorder = new PhaseRecorder( session.getCurrentProject() );

        for ( MojoExecution mojoExecution : mojoExecutions )
        {
            execute( session, mojoExecution, projectIndex, dependencyContext, phaseRecorder );
        }
    }
3107#public void execute( MavenSession session, MojoExecution mojoExecution, ProjectIndex projectIndex,
                         DependencyContext dependencyContext, PhaseRecorder phaseRecorder )
        throws LifecycleExecutionException
    {
        execute( session, mojoExecution, projectIndex, dependencyContext );
        phaseRecorder.observeExecution( mojoExecution );
    }
3108#@SuppressWarnings( { "ThrowableInstanceNeverThrown" } )
    private void execute( MavenSession session, MojoExecution mojoExecution, ProjectIndex projectIndex,
                          DependencyContext dependencyContext )
        throws LifecycleExecutionException
    {
        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();

        try
        {
            mavenPluginManager.checkRequiredMavenVersion( mojoDescriptor.getPluginDescriptor() );
        }
        catch ( PluginIncompatibleException e )
        {
            throw new LifecycleExecutionException( mojoExecution, session.getCurrentProject(), e );
        }

        if ( mojoDescriptor.isProjectRequired() && !session.isUsingPOMsFromFilesystem() )
        {
            Throwable cause =
                new MissingProjectException( "Goal requires a project to execute"
                    + " but there is no POM in this directory (" + session.getExecutionRootDirectory() + ")."
                    + " Please verify you invoked Maven from the correct directory." );
            throw new LifecycleExecutionException( mojoExecution, null, cause );
        }

        if ( mojoDescriptor.isOnlineRequired() && session.isOffline() )
        {
            if ( MojoExecution.Source.CLI.equals( mojoExecution.getSource() ) )
            {
                Throwable cause =
                    new IllegalStateException( "Goal requires online mode for execution"
                        + " but Maven is currently offline." );
                throw new LifecycleExecutionException( mojoExecution, session.getCurrentProject(), cause );
            }
            else
            {
                eventCatapult.fire( ExecutionEvent.Type.MojoSkipped, session, mojoExecution );

                return;
            }
        }

        List<MavenProject> forkedProjects = executeForkedExecutions( mojoExecution, session, projectIndex );

        ensureDependenciesAreResolved( mojoDescriptor, session, dependencyContext );

        eventCatapult.fire( ExecutionEvent.Type.MojoStarted, session, mojoExecution );

        try
        {
            try
            {
                pluginManager.executeMojo( session, mojoExecution );
            }
            catch ( MojoFailureException e )
            {
                throw new LifecycleExecutionException( mojoExecution, session.getCurrentProject(), e );
            }
            catch ( MojoExecutionException e )
            {
                throw new LifecycleExecutionException( mojoExecution, session.getCurrentProject(), e );
            }
            catch ( PluginConfigurationException e )
            {
                throw new LifecycleExecutionException( mojoExecution, session.getCurrentProject(), e );
            }
            catch ( PluginManagerException e )
            {
                throw new LifecycleExecutionException( mojoExecution, session.getCurrentProject(), e );
            }

            eventCatapult.fire( ExecutionEvent.Type.MojoSucceeded, session, mojoExecution );
        }
        catch ( LifecycleExecutionException e )
        {
            eventCatapult.fire( ExecutionEvent.Type.MojoFailed, session, mojoExecution, e );

            throw e;
        }
        finally
        {
            for ( MavenProject forkedProject : forkedProjects )
            {
                forkedProject.setExecutionProject( null );
            }
        }
    }
3109#public void ensureDependenciesAreResolved( MojoDescriptor mojoDescriptor, MavenSession session,
                                                DependencyContext dependencyContext )
        throws LifecycleExecutionException

    {
        MavenProject project = dependencyContext.getProject();
        boolean aggregating = mojoDescriptor.isAggregator();

        if ( dependencyContext.isResolutionRequiredForCurrentProject() )
        {
            Collection<String> scopesToCollect = dependencyContext.getScopesToCollectForCurrentProject();
            Collection<String> scopesToResolve = dependencyContext.getScopesToResolveForCurrentProject();

            lifeCycleDependencyResolver.resolveProjectDependencies( project, scopesToCollect, scopesToResolve, session,
                                                                    aggregating, Collections.<Artifact> emptySet() );

            dependencyContext.synchronizeWithProjectState();
        }

        if ( aggregating )
        {
            Collection<String> scopesToCollect = toScopes( mojoDescriptor.getDependencyCollectionRequired() );
            Collection<String> scopesToResolve = toScopes( mojoDescriptor.getDependencyResolutionRequired() );

            if ( dependencyContext.isResolutionRequiredForAggregatedProjects( scopesToCollect, scopesToResolve ) )
            {
                for ( MavenProject aggregatedProject : session.getProjects() )
                {
                    if ( aggregatedProject != project )
                    {
                        lifeCycleDependencyResolver.resolveProjectDependencies( aggregatedProject, scopesToCollect,
                                                                                scopesToResolve, session, aggregating,
                                                                                Collections.<Artifact> emptySet() );
                    }
                }
            }
        }

        ArtifactFilter artifactFilter = getArtifactFilter( mojoDescriptor );
        List<MavenProject> projectsToResolve =
            LifecycleDependencyResolver.getProjects( session.getCurrentProject(), session,
                                                     mojoDescriptor.isAggregator() );
        for ( MavenProject projectToResolve : projectsToResolve )
        {
            projectToResolve.setArtifactFilter( artifactFilter );
        }
    }
3110#private ArtifactFilter getArtifactFilter( MojoDescriptor mojoDescriptor )
    {
        String scopeToResolve = mojoDescriptor.getDependencyResolutionRequired();
        String scopeToCollect = mojoDescriptor.getDependencyCollectionRequired();

        List<String> scopes = new ArrayList<String>( 2 );
        if ( StringUtils.isNotEmpty( scopeToCollect ) )
        {
            scopes.add( scopeToCollect );
        }
        if ( StringUtils.isNotEmpty( scopeToResolve ) )
        {
            scopes.add( scopeToResolve );
        }

        if ( scopes.isEmpty() )
        {
            return null;
        }
        else
        {
            return new CumulativeScopeArtifactFilter( scopes );
        }
    }
3111#public List<MavenProject> executeForkedExecutions( MojoExecution mojoExecution, MavenSession session,
                                                       ProjectIndex projectIndex )
        throws LifecycleExecutionException
    {
        List<MavenProject> forkedProjects = Collections.emptyList();

        Map<String, List<MojoExecution>> forkedExecutions = mojoExecution.getForkedExecutions();

        if ( !forkedExecutions.isEmpty() )
        {
            eventCatapult.fire( ExecutionEvent.Type.ForkStarted, session, mojoExecution );

            MavenProject project = session.getCurrentProject();

            forkedProjects = new ArrayList<MavenProject>( forkedExecutions.size() );

            try
            {
                for ( Map.Entry<String, List<MojoExecution>> fork : forkedExecutions.entrySet() )
                {
                    String projectId = fork.getKey();

                    int index = projectIndex.getIndices().get( projectId );

                    MavenProject forkedProject = projectIndex.getProjects().get( projectId );

                    forkedProjects.add( forkedProject );

                    MavenProject executedProject = forkedProject.clone();

                    forkedProject.setExecutionProject( executedProject );

                    List<MojoExecution> mojoExecutions = fork.getValue();

                    if ( mojoExecutions.isEmpty() )
                    {
                        continue;
                    }

                    try
                    {
                        session.setCurrentProject( executedProject );
                        session.getProjects().set( index, executedProject );
                        projectIndex.getProjects().put( projectId, executedProject );

                        eventCatapult.fire( ExecutionEvent.Type.ForkedProjectStarted, session, mojoExecution );

                        execute( session, mojoExecutions, projectIndex );

                        eventCatapult.fire( ExecutionEvent.Type.ForkedProjectSucceeded, session, mojoExecution );
                    }
                    catch ( LifecycleExecutionException e )
                    {
                        eventCatapult.fire( ExecutionEvent.Type.ForkedProjectFailed, session, mojoExecution, e );

                        throw e;
                    }
                    finally
                    {
                        projectIndex.getProjects().put( projectId, forkedProject );
                        session.getProjects().set( index, forkedProject );
                        session.setCurrentProject( project );
                    }
                }

                eventCatapult.fire( ExecutionEvent.Type.ForkSucceeded, session, mojoExecution );
            }
            catch ( LifecycleExecutionException e )
            {
                eventCatapult.fire( ExecutionEvent.Type.ForkFailed, session, mojoExecution, e );

                throw e;
            }
        }

        return forkedProjects;
    }
3112#public void buildProject( MavenSession session, ReactorContext reactorContext, MavenProject currentProject,
                              TaskSegment taskSegment )
    {
        buildProject( session, session, reactorContext, currentProject, taskSegment );
    }
3113#public void buildProject( MavenSession session, MavenSession rootSession, ReactorContext reactorContext,
                              MavenProject currentProject, TaskSegment taskSegment )
    {
        session.setCurrentProject( currentProject );

        long buildStartTime = System.currentTimeMillis();

        try
        {

            if ( reactorContext.getReactorBuildStatus().isHaltedOrBlacklisted( currentProject ) )
            {
                eventCatapult.fire( ExecutionEvent.Type.ProjectSkipped, session, null );
                return;
            }

            eventCatapult.fire( ExecutionEvent.Type.ProjectStarted, session, null );

            BuilderCommon.attachToThread( currentProject );
            MavenExecutionPlan executionPlan =
                builderCommon.resolveBuildPlan( session, currentProject, taskSegment, new HashSet<Artifact>() );

            mojoExecutor.execute( session, executionPlan.getMojoExecutions(), reactorContext.getProjectIndex() );

            long buildEndTime = System.currentTimeMillis();

            reactorContext.getResult().addBuildSummary(
                new BuildSuccess( currentProject, buildEndTime - buildStartTime ) );

            eventCatapult.fire( ExecutionEvent.Type.ProjectSucceeded, session, null );
        }
        catch ( Exception e )
        {
            builderCommon.handleBuildError( reactorContext, rootSession, currentProject, e, buildStartTime );
        }
        finally
        {
            session.setCurrentProject( null );

            Thread.currentThread().setContextClassLoader( reactorContext.getOriginalContextClassLoader() );
        }
    }
3114#public ThreadOutputMuxer( ProjectBuildList segmentChunks, PrintStream originalSystemOut )
    {
        projects = segmentChunks.iterator();
        for ( ProjectSegment segmentChunk : segmentChunks )
        {
            final ByteArrayOutputStream value = new ByteArrayOutputStream();
            streams.put( segmentChunk, value );
            printStreams.put( segmentChunk, new PrintStream( value ) );
        }
        setNext();
        this.originalSystemOUtStream = originalSystemOut;
        System.setOut( new ThreadBoundPrintStream( this.originalSystemOUtStream ) );
        printer = new ConsolePrinter( segmentChunks );
        new Thread( printer ).start();
        printer.waitUntilRunning( true );
    }
3115#public void close()
    {
        printer.waitUntilRunning( false );
        System.setOut( this.originalSystemOUtStream );
    }
3116#private void setNext()
    {
        currentBuild = projects.hasNext() ? projects.next() : null;
    }
3117#private boolean ownsRealOutputStream( ProjectSegment projectBuild )
    {
        return projectBuild.equals( currentBuild );
    }
3118#private PrintStream getThreadBoundPrintStream()
    {
        ProjectSegment threadProject = projectBuildThreadLocal.get();
        if ( threadProject == null )
        {
            return defaultPringStream;
        }
        if ( ownsRealOutputStream( threadProject ) )
        {
            return originalSystemOUtStream;
        }
        return printStreams.get( threadProject );
    }
3119#public void associateThreadWithProjectSegment( ProjectSegment projectBuild )
    {
        projectBuildThreadLocal.set( projectBuild );
    }
3120#public void setThisModuleComplete( ProjectSegment projectBuild )
    {
        completedBuilds.add( projectBuild );
        PrintStream stream = printStreams.get( projectBuild );
        synchronized ( stream )
        {
            stream.notifyAll();
        }
        disconnectThreadFromProject();
    }
3121#private void disconnectThreadFromProject()
    {
        projectBuildThreadLocal.remove();
    }
3122#ConsolePrinter( ProjectBuildList projectBuildList )
        {
            this.projectBuildList = projectBuildList;
        }
3123#public void run()
        {
            running = true;
            for ( ProjectSegment projectBuild : projectBuildList )
            {
                final PrintStream projectStream = printStreams.get( projectBuild );
                ByteArrayOutputStream projectOs = streams.get( projectBuild );

                do
                {
                    synchronized ( projectStream )
                    {
                        try
                        {
                            projectStream.wait( 100 );
                        }
                        catch ( InterruptedException e )
                        {
                            throw new RuntimeException( e );
                        }
                        try
                        {
                            projectOs.writeTo( originalSystemOUtStream );
                        }
                        catch ( IOException e )
                        {
                            throw new RuntimeException( e );
                        }

                        projectOs.reset();
                    }
                }
                while ( !completedBuilds.contains( projectBuild ) );
            }
            running = false;
        }
3124#/*
        Wait until we are sure the print-stream thread is running.
         */

        public void waitUntilRunning( boolean expect )
        {
            while ( !running == expect )
            {
                try
                {
                    Thread.sleep( 10 );
                }
                catch ( InterruptedException e )
                {
                    throw new RuntimeException( e );
                }
            }
        }
3125#public ThreadBoundPrintStream( PrintStream systemOutStream )
        {
            super( systemOutStream );
        }
3126#private PrintStream getOutputStreamForCurrentThread()
        {
            return getThreadBoundPrintStream();
        }
3127#@Override
        public void println()
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.println();
                currentStream.notifyAll();
            }
        }
3128#@Override
        public void print( char c )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.print( c );
                currentStream.notifyAll();
            }
        }
3129#@Override
        public void println( char x )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.println( x );
                currentStream.notifyAll();
            }
        }
3130#@Override
        public void print( double d )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.print( d );
                currentStream.notifyAll();
            }
        }
3131#@Override
        public void println( double x )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.println( x );
                currentStream.notifyAll();
            }
        }
3132#@Override
        public void print( float f )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.print( f );
                currentStream.notifyAll();
            }
        }
3133#@Override
        public void println( float x )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.println( x );
                currentStream.notifyAll();
            }
        }
3134#@Override
        public void print( int i )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.print( i );
                currentStream.notifyAll();
            }
        }
3135#@Override
        public void println( int x )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.println( x );
                currentStream.notifyAll();
            }
        }
3136#@Override
        public void print( long l )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.print( l );
                currentStream.notifyAll();
            }
        }
3137#@Override
        public void println( long x )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.print( x );
                currentStream.notifyAll();
            }
        }
3138#@Override
        public void print( boolean b )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.print( b );
                currentStream.notifyAll();
            }
        }
3139#@Override
        public void println( boolean x )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.print( x );
                currentStream.notifyAll();
            }
        }
3140#@Override
        public void print( char s[] )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.print( s );
                currentStream.notifyAll();
            }
        }
3141#@Override
        public void println( char x[] )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.print( x );
                currentStream.notifyAll();
            }
        }
3142#@Override
        public void print( Object obj )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.print( obj );
                currentStream.notifyAll();
            }
        }
3143#@Override
        public void println( Object x )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.println( x );
                currentStream.notifyAll();
            }
        }
3144#@Override
        public void print( String s )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.print( s );
                currentStream.notifyAll();
            }
        }
3145#@Override
        public void println( String x )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.println( x );
                currentStream.notifyAll();
            }
        }
3146#@Override
        public void write( byte b[], int off, int len )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.write( b, off, len );
                currentStream.notifyAll();
            }
        }
3147#@Override
        public void close()
        {
            getOutputStreamForCurrentThread().close();
        }
3148#@Override
        public void flush()
        {
            getOutputStreamForCurrentThread().flush();
        }
3149#@Override
        public void write( int b )
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.write( b );
                currentStream.notifyAll();
            }
        }
3150#@Override
        public void write( byte b[] )
            throws IOException
        {
            final PrintStream currentStream = getOutputStreamForCurrentThread();
            synchronized ( currentStream )
            {
                currentStream.write( b );
                currentStream.notifyAll();
            }
        }
3151#@SuppressWarnings( { "UnusedDeclaration" } )
    public BuilderCommon()
    {
    }
3152#public BuilderCommon( LifecycleDebugLogger lifecycleDebugLogger,
                          LifecycleExecutionPlanCalculator lifeCycleExecutionPlanCalculator, Logger logger )
    {
        this.lifecycleDebugLogger = lifecycleDebugLogger;
        this.lifeCycleExecutionPlanCalculator = lifeCycleExecutionPlanCalculator;
        this.logger = logger;
    }
3153#public MavenExecutionPlan resolveBuildPlan( MavenSession session, MavenProject project, TaskSegment taskSegment,
                                                Set<Artifact> projectArtifacts )
        throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException,
        PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException,
        NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException,
        LifecycleExecutionException
    {
        MavenExecutionPlan executionPlan =
            lifeCycleExecutionPlanCalculator.calculateExecutionPlan( session, project, taskSegment.getTasks() );

        lifecycleDebugLogger.debugProjectPlan( project, executionPlan );

        if ( session.getRequest().isThreadConfigurationPresent() )
        {
            final Set<Plugin> unsafePlugins = executionPlan.getNonThreadSafePlugins();
            if ( !unsafePlugins.isEmpty() )
            {
                logger.warn( "*****************************************************************" );
                logger.warn( "* Your build is requesting parallel execution, but project      *" );
                logger.warn( "* contains the following plugin(s) that are not marked as       *" );
                logger.warn( "* @threadSafe to support parallel building.                     *" );
                logger.warn( "* While this /may/ work fine, please look for plugin updates    *" );
                logger.warn( "* and/or request plugins be made thread-safe.                   *" );
                logger.warn( "* If reporting an issue, report it against the plugin in        *" );
                logger.warn( "* question, not against maven-core                              *" );
                logger.warn( "*****************************************************************" );
                logger.warn( "The following plugins are not marked @threadSafe in " + project.getName() + ":" );
                for ( Plugin unsafePlugin : unsafePlugins )
                {
                    logger.warn( unsafePlugin.getId() );
                }
                logger.warn( "*****************************************************************" );
            }
        }

        return executionPlan;
    }
3154#public void handleBuildError( final ReactorContext buildContext, final MavenSession rootSession,
                                  final MavenProject mavenProject, Exception e, final long buildStartTime )
    {
        if ( e instanceof RuntimeException )
        {
            e = new InternalErrorException( "Internal error: " + e, e );
        }

        buildContext.getResult().addException( e );

        long buildEndTime = System.currentTimeMillis();

        buildContext.getResult().addBuildSummary( new BuildFailure( mavenProject, buildEndTime - buildStartTime, e ) );

        eventCatapult.fire( ExecutionEvent.Type.ProjectFailed, rootSession, null, e );

        if ( MavenExecutionRequest.REACTOR_FAIL_NEVER.equals( rootSession.getReactorFailureBehavior() ) )
        {
            // continue the build
        }
        else if ( MavenExecutionRequest.REACTOR_FAIL_AT_END.equals( rootSession.getReactorFailureBehavior() ) )
        {
            // continue the build but ban all projects that depend on the failed one
            buildContext.getReactorBuildStatus().blackList( mavenProject );
        }
        else if ( MavenExecutionRequest.REACTOR_FAIL_FAST.equals( rootSession.getReactorFailureBehavior() ) )
        {
            buildContext.getReactorBuildStatus().halt();
        }
        else
        {
            throw new IllegalArgumentException(
                "invalid reactor failure behavior " + rootSession.getReactorFailureBehavior() );
        }
    }
3155#public static void attachToThread( MavenProject currentProject )
    {
        ClassRealm projectRealm = currentProject.getClassRealm();
        if ( projectRealm != null )
        {
            Thread.currentThread().setContextClassLoader( projectRealm );
        }
    }
3156#// Todo: I'm really wondering where this method belongs; smells like it should be on MavenProject, but for some reason
    // it isn't ? This localization is kind-of a code smell.

    public static String getKey( MavenProject project )
    {
        return project.getGroupId() + ':' + project.getArtifactId() + ':' + project.getVersion();
    }
3157#@SuppressWarnings( { "UnusedDeclaration" } )
    public DefaultLifecycleExecutionPlanCalculator()
    {
    }
3158#public DefaultLifecycleExecutionPlanCalculator( BuildPluginManager pluginManager,
                                                    DefaultLifecycles defaultLifeCycles,
                                                    MojoDescriptorCreator mojoDescriptorCreator,
                                                    LifecyclePluginResolver lifecyclePluginResolver,
                                                    DefaultSchedules defaultSchedules )
    {
        this.pluginManager = pluginManager;
        this.defaultLifeCycles = defaultLifeCycles;
        this.mojoDescriptorCreator = mojoDescriptorCreator;
        this.lifecyclePluginResolver = lifecyclePluginResolver;
        this.defaultSchedules = defaultSchedules;
    }
3159#public MavenExecutionPlan calculateExecutionPlan( MavenSession session, MavenProject project, List<Object> tasks, boolean setup )
        throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException,
        PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException,
        NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        lifecyclePluginResolver.resolveMissingPluginVersions( project, session );

        final List<MojoExecution> executions = calculateMojoExecutions( session, project, tasks );

        if ( setup )
        {
            setupMojoExecutions( session, project, executions );
        }

        final List<ExecutionPlanItem> planItem = defaultSchedules.createExecutionPlanItem( project, executions );

        return new MavenExecutionPlan( planItem, defaultLifeCycles );
    }
3160#public MavenExecutionPlan calculateExecutionPlan( MavenSession session, MavenProject project, List<Object> tasks )
        throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException,
        PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException,
        NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        return calculateExecutionPlan( session, project, tasks, true );
    }
3161#private void setupMojoExecutions( MavenSession session, MavenProject project, List<MojoExecution> mojoExecutions )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, InvalidPluginDescriptorException, NoPluginFoundForPrefixException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        for ( MojoExecution mojoExecution : mojoExecutions )
        {
            setupMojoExecution( session, project, mojoExecution );
        }
    }
3162#public void setupMojoExecution( MavenSession session, MavenProject project, MojoExecution mojoExecution )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, InvalidPluginDescriptorException, NoPluginFoundForPrefixException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();

        if ( mojoDescriptor == null )
        {
            mojoDescriptor =
                pluginManager.getMojoDescriptor( mojoExecution.getPlugin(), mojoExecution.getGoal(),
                                                 project.getRemotePluginRepositories(),
                                                 session.getRepositorySession() );

            mojoExecution.setMojoDescriptor( mojoDescriptor );
        }

        populateMojoExecutionConfiguration( project, mojoExecution,
                                            MojoExecution.Source.CLI.equals( mojoExecution.getSource() ) );

        finalizeMojoConfiguration( mojoExecution );

        calculateForkedExecutions( mojoExecution, session, project, new HashSet<MojoDescriptor>() );
    }
3163#public List<MojoExecution> calculateMojoExecutions( MavenSession session, MavenProject project,
                                                         List<Object> tasks )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginVersionResolutionException, LifecyclePhaseNotFoundException
    {
        final List<MojoExecution> mojoExecutions = new ArrayList<MojoExecution>();

        for ( Object task : tasks )
        {
            if ( task instanceof GoalTask )
            {
                String pluginGoal = ( (GoalTask) task ).pluginGoal;

                MojoDescriptor mojoDescriptor = mojoDescriptorCreator.getMojoDescriptor( pluginGoal, session, project );

                MojoExecution mojoExecution =
                    new MojoExecution( mojoDescriptor, "default-cli", MojoExecution.Source.CLI );

                mojoExecutions.add( mojoExecution );
            }
            else if ( task instanceof LifecycleTask )
            {
                String lifecyclePhase = ( (LifecycleTask) task ).getLifecyclePhase();

                Map<String, List<MojoExecution>> phaseToMojoMapping =
                    calculateLifecycleMappings( session, project, lifecyclePhase );

                for ( List<MojoExecution> mojoExecutionsFromLifecycle : phaseToMojoMapping.values() )
                {
                    mojoExecutions.addAll( mojoExecutionsFromLifecycle );
                }
            }
            else
            {
                throw new IllegalStateException( "unexpected task " + task );
            }
        }
        return mojoExecutions;
    }
3164#private Map<String, List<MojoExecution>> calculateLifecycleMappings( MavenSession session, MavenProject project,
                                                                         String lifecyclePhase )
        throws LifecyclePhaseNotFoundException, PluginNotFoundException, PluginResolutionException,
        PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException
    {
        /*
         * Determine the lifecycle that corresponds to the given phase.
         */

        Lifecycle lifecycle = defaultLifeCycles.get( lifecyclePhase );

        if ( lifecycle == null )
        {
            throw new LifecyclePhaseNotFoundException(
                "Unknown lifecycle phase \"" + lifecyclePhase + "\". You must specify a valid lifecycle phase" +
                    " or a goal in the format <plugin-prefix>:<goal> or" +
                    " <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: " +
                    defaultLifeCycles.getLifecyclePhaseList() + ".", lifecyclePhase );
        }

        /*
         * Initialize mapping from lifecycle phase to bound mojos. The key set of this map denotes the phases the caller
         * is interested in, i.e. all phases up to and including the specified phase.
         */

        Map<String, Map<Integer, List<MojoExecution>>> mappings =
            new LinkedHashMap<String, Map<Integer, List<MojoExecution>>>();

        for ( String phase : lifecycle.getPhases() )
        {
            Map<Integer, List<MojoExecution>> phaseBindings = new TreeMap<Integer, List<MojoExecution>>();

            mappings.put( phase, phaseBindings );

            if ( phase.equals( lifecyclePhase ) )
            {
                break;
            }
        }

        /*
         * Grab plugin executions that are bound to the selected lifecycle phases from project. The effective model of
         * the project already contains the plugin executions induced by the project's packaging type. Remember, all
         * phases of interest and only those are in the lifecyle mapping, if a phase has no value in the map, we are not
         * interested in any of the executions bound to it.
         */

        for ( Plugin plugin : project.getBuild().getPlugins() )
        {
            for ( PluginExecution execution : plugin.getExecutions() )
            {
                // if the phase is specified then I don't have to go fetch the plugin yet and pull it down
                // to examine the phase it is associated to.
                if ( execution.getPhase() != null )
                {
                    Map<Integer, List<MojoExecution>> phaseBindings = mappings.get( execution.getPhase() );
                    if ( phaseBindings != null )
                    {
                        for ( String goal : execution.getGoals() )
                        {
                            MojoExecution mojoExecution = new MojoExecution( plugin, goal, execution.getId() );
                            mojoExecution.setLifecyclePhase( execution.getPhase() );
                            addMojoExecution( phaseBindings, mojoExecution, execution.getPriority() );
                        }
                    }
                }
                // if not then i need to grab the mojo descriptor and look at the phase that is specified
                else
                {
                    for ( String goal : execution.getGoals() )
                    {
                        MojoDescriptor mojoDescriptor =
                            pluginManager.getMojoDescriptor( plugin, goal, project.getRemotePluginRepositories(),
                                                             session.getRepositorySession() );

                        Map<Integer, List<MojoExecution>> phaseBindings = mappings.get( mojoDescriptor.getPhase() );
                        if ( phaseBindings != null )
                        {
                            MojoExecution mojoExecution = new MojoExecution( mojoDescriptor, execution.getId() );
                            mojoExecution.setLifecyclePhase( mojoDescriptor.getPhase() );
                            addMojoExecution( phaseBindings, mojoExecution, execution.getPriority() );
                        }
                    }
                }
            }
        }

        Map<String, List<MojoExecution>> lifecycleMappings = new LinkedHashMap<String, List<MojoExecution>>();

        for ( Map.Entry<String, Map<Integer, List<MojoExecution>>> entry : mappings.entrySet() )
        {
            List<MojoExecution> mojoExecutions = new ArrayList<MojoExecution>();

            for ( List<MojoExecution> executions : entry.getValue().values() )
            {
                mojoExecutions.addAll( executions );
            }

            lifecycleMappings.put( entry.getKey(), mojoExecutions );
        }

        return lifecycleMappings;
    }
3165#private void addMojoExecution( Map<Integer, List<MojoExecution>> phaseBindings, MojoExecution mojoExecution,
                                   int priority )
    {
        List<MojoExecution> mojoExecutions = phaseBindings.get( priority );

        if ( mojoExecutions == null )
        {
            mojoExecutions = new ArrayList<MojoExecution>();
            phaseBindings.put( priority, mojoExecutions );
        }

        mojoExecutions.add( mojoExecution );
    }
3166#private void populateMojoExecutionConfiguration( MavenProject project, MojoExecution mojoExecution,
                                                     boolean allowPluginLevelConfig )
    {
        String g = mojoExecution.getGroupId();

        String a = mojoExecution.getArtifactId();

        Plugin plugin = findPlugin( g, a, project.getBuildPlugins() );

        if ( plugin == null && project.getPluginManagement() != null )
        {
            plugin = findPlugin( g, a, project.getPluginManagement().getPlugins() );
        }

        if ( plugin != null )
        {
            PluginExecution pluginExecution =
                findPluginExecution( mojoExecution.getExecutionId(), plugin.getExecutions() );

            Xpp3Dom pomConfiguration = null;

            if ( pluginExecution != null )
            {
                pomConfiguration = (Xpp3Dom) pluginExecution.getConfiguration();
            }
            else if ( allowPluginLevelConfig )
            {
                pomConfiguration = (Xpp3Dom) plugin.getConfiguration();
            }

            Xpp3Dom mojoConfiguration = ( pomConfiguration != null ) ? new Xpp3Dom( pomConfiguration ) : null;

            mojoConfiguration = Xpp3Dom.mergeXpp3Dom( mojoExecution.getConfiguration(), mojoConfiguration );

            mojoExecution.setConfiguration( mojoConfiguration );
        }
    }
3167#private Plugin findPlugin( String groupId, String artifactId, Collection<Plugin> plugins )
    {
        for ( Plugin plugin : plugins )
        {
            if ( artifactId.equals( plugin.getArtifactId() ) && groupId.equals( plugin.getGroupId() ) )
            {
                return plugin;
            }
        }

        return null;
    }
3168#private PluginExecution findPluginExecution( String executionId, Collection<PluginExecution> executions )
    {
        if ( StringUtils.isNotEmpty( executionId ) )
        {
            for ( PluginExecution execution : executions )
            {
                if ( executionId.equals( execution.getId() ) )
                {
                    return execution;
                }
            }
        }

        return null;
    }
3169#/**
     * Post-processes the effective configuration for the specified mojo execution. This step discards all parameters
     * from the configuration that are not applicable to the mojo and injects the default values for any missing
     * parameters.
     *
     * @param mojoExecution The mojo execution whose configuration should be finalized, must not be {@code null}.
     */
    private void finalizeMojoConfiguration( MojoExecution mojoExecution )
    {
        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();

        Xpp3Dom executionConfiguration = mojoExecution.getConfiguration();
        if ( executionConfiguration == null )
        {
            executionConfiguration = new Xpp3Dom( "configuration" );
        }

        Xpp3Dom defaultConfiguration = getMojoConfiguration( mojoDescriptor );

        Xpp3Dom finalConfiguration = new Xpp3Dom( "configuration" );

        if ( mojoDescriptor.getParameters() != null )
        {
            for ( Parameter parameter : mojoDescriptor.getParameters() )
            {
                Xpp3Dom parameterConfiguration = executionConfiguration.getChild( parameter.getName() );

                if ( parameterConfiguration == null )
                {
                    parameterConfiguration = executionConfiguration.getChild( parameter.getAlias() );
                }

                Xpp3Dom parameterDefaults = defaultConfiguration.getChild( parameter.getName() );

                parameterConfiguration =
                    Xpp3Dom.mergeXpp3Dom( parameterConfiguration, parameterDefaults, Boolean.TRUE );

                if ( parameterConfiguration != null )
                {
                    parameterConfiguration = new Xpp3Dom( parameterConfiguration, parameter.getName() );

                    if ( StringUtils.isEmpty( parameterConfiguration.getAttribute( "implementation" ) ) &&
                        StringUtils.isNotEmpty( parameter.getImplementation() ) )
                    {
                        parameterConfiguration.setAttribute( "implementation", parameter.getImplementation() );
                    }

                    finalConfiguration.addChild( parameterConfiguration );
                }
            }
        }

        mojoExecution.setConfiguration( finalConfiguration );
    }
3170#private Xpp3Dom getMojoConfiguration( MojoDescriptor mojoDescriptor )
    {
        return MojoDescriptorCreator.convert( mojoDescriptor );
    }
3171#public void calculateForkedExecutions( MojoExecution mojoExecution, MavenSession session )
        throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        calculateForkedExecutions( mojoExecution, session, session.getCurrentProject(), new HashSet<MojoDescriptor>() );
    }
3172#private void calculateForkedExecutions( MojoExecution mojoExecution, MavenSession session, MavenProject project,
                                            Collection<MojoDescriptor> alreadyForkedExecutions )
        throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();

        if ( !mojoDescriptor.isForking() )
        {
            return;
        }

        if ( !alreadyForkedExecutions.add( mojoDescriptor ) )
        {
            return;
        }

        List<MavenProject> forkedProjects =
            LifecycleDependencyResolver.getProjects( project, session, mojoDescriptor.isAggregator() );

        for ( MavenProject forkedProject : forkedProjects )
        {
            if ( forkedProject != project )
            {
                lifecyclePluginResolver.resolveMissingPluginVersions( forkedProject, session );
            }

            List<MojoExecution> forkedExecutions;

            if ( StringUtils.isNotEmpty( mojoDescriptor.getExecutePhase() ) )
            {
                forkedExecutions =
                    calculateForkedLifecycle( mojoExecution, session, forkedProject, alreadyForkedExecutions );
            }
            else
            {
                forkedExecutions =
                    calculateForkedGoal( mojoExecution, session, forkedProject, alreadyForkedExecutions );
            }

            mojoExecution.setForkedExecutions( BuilderCommon.getKey( forkedProject ), forkedExecutions );
        }

        alreadyForkedExecutions.remove( mojoDescriptor );
    }
3173#private List<MojoExecution> calculateForkedLifecycle( MojoExecution mojoExecution, MavenSession session,
                                                          MavenProject project,
                                                          Collection<MojoDescriptor> alreadyForkedExecutions )
        throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();

        String forkedPhase = mojoDescriptor.getExecutePhase();

        Map<String, List<MojoExecution>> lifecycleMappings =
            calculateLifecycleMappings( session, project, forkedPhase );

        for ( List<MojoExecution> forkedExecutions : lifecycleMappings.values() )
        {
            for ( MojoExecution forkedExecution : forkedExecutions )
            {
                if ( forkedExecution.getMojoDescriptor() == null )
                {
                    MojoDescriptor forkedMojoDescriptor =
                        pluginManager.getMojoDescriptor( forkedExecution.getPlugin(), forkedExecution.getGoal(),
                                                         project.getRemotePluginRepositories(),
                                                         session.getRepositorySession() );

                    forkedExecution.setMojoDescriptor( forkedMojoDescriptor );
                }

                populateMojoExecutionConfiguration( project, forkedExecution, false );
            }
        }

        injectLifecycleOverlay( lifecycleMappings, mojoExecution, session, project );

        List<MojoExecution> mojoExecutions = new ArrayList<MojoExecution>();

        for ( List<MojoExecution> forkedExecutions : lifecycleMappings.values() )
        {
            for ( MojoExecution forkedExecution : forkedExecutions )
            {
                if ( !alreadyForkedExecutions.contains( forkedExecution.getMojoDescriptor() ) )
                {
                    finalizeMojoConfiguration( forkedExecution );

                    calculateForkedExecutions( forkedExecution, session, project, alreadyForkedExecutions );

                    mojoExecutions.add( forkedExecution );
                }
            }
        }

        return mojoExecutions;
    }
3174#private void injectLifecycleOverlay( Map<String, List<MojoExecution>> lifecycleMappings,
                                         MojoExecution mojoExecution, MavenSession session, MavenProject project )
        throws PluginDescriptorParsingException, LifecycleNotFoundException, MojoNotFoundException,
        PluginNotFoundException, PluginResolutionException, NoPluginFoundForPrefixException,
        InvalidPluginDescriptorException, PluginVersionResolutionException
    {
        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();

        PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();

        String forkedLifecycle = mojoDescriptor.getExecuteLifecycle();

        if ( StringUtils.isEmpty( forkedLifecycle ) )
        {
            return;
        }

        org.apache.maven.plugin.lifecycle.Lifecycle lifecycleOverlay;

        try
        {
            lifecycleOverlay = pluginDescriptor.getLifecycleMapping( forkedLifecycle );
        }
        catch ( IOException e )
        {
            throw new PluginDescriptorParsingException( pluginDescriptor.getPlugin(), pluginDescriptor.getSource(), e );
        }
        catch ( XmlPullParserException e )
        {
            throw new PluginDescriptorParsingException( pluginDescriptor.getPlugin(), pluginDescriptor.getSource(), e );
        }

        if ( lifecycleOverlay == null )
        {
            throw new LifecycleNotFoundException( forkedLifecycle );
        }

        for ( Phase phase : lifecycleOverlay.getPhases() )
        {
            List<MojoExecution> forkedExecutions = lifecycleMappings.get( phase.getId() );

            if ( forkedExecutions != null )
            {
                for ( Execution execution : phase.getExecutions() )
                {
                    for ( String goal : execution.getGoals() )
                    {
                        MojoDescriptor forkedMojoDescriptor;

                        if ( goal.indexOf( ':' ) < 0 )
                        {
                            forkedMojoDescriptor = pluginDescriptor.getMojo( goal );
                            if ( forkedMojoDescriptor == null )
                            {
                                throw new MojoNotFoundException( goal, pluginDescriptor );
                            }
                        }
                        else
                        {
                            forkedMojoDescriptor = mojoDescriptorCreator.getMojoDescriptor( goal, session, project );
                        }

                        MojoExecution forkedExecution =
                            new MojoExecution( forkedMojoDescriptor, mojoExecution.getExecutionId() );

                        Xpp3Dom forkedConfiguration = (Xpp3Dom) execution.getConfiguration();

                        forkedExecution.setConfiguration( forkedConfiguration );

                        populateMojoExecutionConfiguration( project, forkedExecution, true );

                        forkedExecutions.add( forkedExecution );
                    }
                }

                Xpp3Dom phaseConfiguration = (Xpp3Dom) phase.getConfiguration();

                if ( phaseConfiguration != null )
                {
                    for ( MojoExecution forkedExecution : forkedExecutions )
                    {
                        Xpp3Dom forkedConfiguration = forkedExecution.getConfiguration();

                        forkedConfiguration = Xpp3Dom.mergeXpp3Dom( phaseConfiguration, forkedConfiguration );

                        forkedExecution.setConfiguration( forkedConfiguration );
                    }
                }
            }
        }
    }
3175#// org.apache.maven.plugins:maven-remote-resources-plugin:1.0:process
    //TODO: take repo mans into account as one may be aggregating prefixes of many
    //TODO: collect at the root of the repository, read the one at the root, and fetch remote if something is missing
    //      or the user forces the issue

    private List<MojoExecution> calculateForkedGoal( MojoExecution mojoExecution, MavenSession session,
                                                     MavenProject project,
                                                     Collection<MojoDescriptor> alreadyForkedExecutions )
        throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();

        PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();

        String forkedGoal = mojoDescriptor.getExecuteGoal();

        MojoDescriptor forkedMojoDescriptor = pluginDescriptor.getMojo( forkedGoal );
        if ( forkedMojoDescriptor == null )
        {
            throw new MojoNotFoundException( forkedGoal, pluginDescriptor );
        }

        if ( alreadyForkedExecutions.contains( forkedMojoDescriptor ) )
        {
            return Collections.emptyList();
        }

        MojoExecution forkedExecution = new MojoExecution( forkedMojoDescriptor, forkedGoal );

        populateMojoExecutionConfiguration( project, forkedExecution, true );

        finalizeMojoConfiguration( forkedExecution );

        calculateForkedExecutions( forkedExecution, session, project, alreadyForkedExecutions );

        return Collections.singletonList( forkedExecution );
    }
3176#List<TaskSegment> calculateTaskSegments( MavenSession session )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginVersionResolutionException, LifecyclePhaseNotFoundException, LifecycleNotFoundException;
3177#public List<TaskSegment> calculateTaskSegments( MavenSession session, List<String> tasks )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginVersionResolutionException;
3178#boolean requiresProject( MavenSession session );
3179#public ProjectBuildList( List<ProjectSegment> items )
    {
        this.items = Collections.unmodifiableList( items );
    }
3180#// TODO: Optimize; or maybe just rewrite the whole way aggregating mojos are being run.
    /**
     * Returns aProjectBuildList that contains only items for the specified taskSegment
     * @param taskSegment the requested tasksegment
     * @return a project build list for the supplied task segment
     */
    public ProjectBuildList getByTaskSegment( TaskSegment taskSegment )
    {
        List<ProjectSegment> currentSegment = new ArrayList<ProjectSegment>();
        for ( ProjectSegment projectBuild : items )
        {
            if ( taskSegment == projectBuild.getTaskSegment() )
            { // NOTE: There's no notion of taskSegment equality.
                currentSegment.add( projectBuild );
            }
        }
        return new ProjectBuildList( currentSegment );
    }
3181#public Map<MavenProject, ProjectSegment> selectSegment( TaskSegment taskSegment )
    {
        Map<MavenProject, ProjectSegment> result = new HashMap<MavenProject, ProjectSegment>();
        for ( ProjectSegment projectBuild : items )
        {
            if ( taskSegment == projectBuild.getTaskSegment() )
            { // NOTE: There's no notion of taskSegment equality.
                result.put( projectBuild.getProject(), projectBuild );
            }
        }
        return result;
    }
3182#/**
     * Finds the first ProjectSegment matching the supplied project
     * @param mavenProject the requested project
     * @return The projectSegment or null.
     */
    public ProjectSegment findByMavenProject( MavenProject mavenProject )
    {
        for ( ProjectSegment projectBuild : items )
        {
            if ( mavenProject.equals( projectBuild.getProject() ) )
            {
                return projectBuild;
            }
        }
        return null;
    }
3183#public Iterator<ProjectSegment> iterator()
    {
        return items.iterator();
    }
3184#public void closeAll()
    {
        for ( ProjectSegment item : items )
        {
            MavenSession sessionForThisModule = item.getSession();
            sessionForThisModule.setCurrentProject( null );
        }
    }
3185#public int size()
    {
        return items.size();
    }
3186#ProjectSegment get( int index )
    {
        return items.get( index );
    }
3187#public Set<String> getReactorProjectKeys()
    {
        Set<String> projectKeys = new HashSet<String>( items.size() * 2 );
        for ( ProjectSegment projectBuild : items )
        {
            MavenProject project = projectBuild.getProject();
            String key = ArtifactUtils.key( project.getGroupId(), project.getArtifactId(), project.getVersion() );
            projectKeys.add( key );
        }
        return projectKeys;
    }
3188#public boolean isEmpty()
    {
        return items.isEmpty();
    }
3189#/**
     * Populates the lifecycle map from the injected list of lifecycle mappings (if not already done).
     */
    private void initLifecycleMap()
    {
        if ( lifecycleMap == null )
        {
            lifecycleMap = new HashMap<String, Lifecycle>();

            if ( lifecycles != null )
            {
                for ( Lifecycle lifecycle : lifecycles )
                {
                    lifecycleMap.put( lifecycle.getId(), lifecycle );
                }
            }
            else
            {
                /*
                 * NOTE: This is to provide a migration path for implementors of the legacy API which did not know about
                 * getLifecycles().
                 */

                String[] lifecycleIds = { "default", "clean", "site" };

                for ( String lifecycleId : lifecycleIds )
                {
                    Map<String, String> phases = getPhases( lifecycleId );
                    if ( phases != null )
                    {
                        Lifecycle lifecycle = new Lifecycle();

                        lifecycle.setId( lifecycleId );
                        lifecycle.setPhases( phases );

                        lifecycleMap.put( lifecycleId, lifecycle );
                    }
                }
            }
        }
    }
3190#public Map<String, Lifecycle> getLifecycles()
    {
        initLifecycleMap();

        return lifecycleMap;
    }
3191#public List<String> getOptionalMojos( String lifecycle )
    {
        return null;
    }
3192#public Map<String, String> getPhases( String lifecycle )
    {
        initLifecycleMap();

        Lifecycle lifecycleMapping = lifecycleMap.get( lifecycle );

        if ( lifecycleMapping != null )
        {
            return lifecycleMapping.getPhases();
        }
        else if ( "default".equals( lifecycle ) )
        {
            return phases;
        }
        else
        {
            return null;
        }
    }
3193#Map<String, Lifecycle> getLifecycles();
3194#@Deprecated
    List<String> getOptionalMojos( String lifecycle );
3195#@Deprecated
    Map<String, String> getPhases( String lifecycle );
3196#/**
     * Method getId
     */
    public String getId()
    {
        return this.id;
    }
3197#/**
     * Method getPhases
     */
    public Map<String, String> getPhases()
    {
        return this.phases;
    }
3198#/**
     * Method setId
     *
     * @param id
     */
    public void setId( String id )
    {
        this.id = id;
    }
3199#/**
     * Method setPhases
     *
     * @param phases
     */
    public void setPhases( Map<String, String> phases )
    {
        this.phases = phases;
    } //-- void setPhases(java.util.List)
3200#public void injectLifecycleBindings( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        String packaging = model.getPackaging();

        Collection<Plugin> defaultPlugins = lifecycle.getPluginsBoundByDefaultToAllLifecycles( packaging );

        if ( defaultPlugins == null )
        {
            problems.add( Severity.ERROR, "Unknown packaging: " + packaging, model.getLocation( "packaging" ), null );
        }
        else if ( !defaultPlugins.isEmpty() )
        {
            Model lifecycleModel = new Model();
            lifecycleModel.setBuild( new Build() );
            lifecycleModel.getBuild().getPlugins().addAll( defaultPlugins );

            merger.merge( model, lifecycleModel );
        }
    }
3201#public void merge( Model target, Model source )
        {
            if ( target.getBuild() == null )
            {
                target.setBuild( new Build() );
            }

            Map<Object, Object> context =
                Collections.<Object, Object> singletonMap( PLUGIN_MANAGEMENT, target.getBuild().getPluginManagement() );

            mergePluginContainer_Plugins( target.getBuild(), source.getBuild(), false, context );
        }
3202#@Override
        protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                     boolean sourceDominant, Map<Object, Object> context )
        {
            List<Plugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<Plugin> tgt = target.getPlugins();

                Map<Object, Plugin> merged = new LinkedHashMap<Object, Plugin>( ( src.size() + tgt.size() ) * 2 );

                for ( Iterator<Plugin> it = tgt.iterator(); it.hasNext(); )
                {
                    Plugin element = it.next();
                    Object key = getPluginKey( element );
                    merged.put( key, element );
                }

                Map<Object, Plugin> unmanaged = new LinkedHashMap<Object, Plugin>();

                for ( Iterator<Plugin> it = src.iterator(); it.hasNext(); )
                {
                    Plugin element = it.next();
                    Object key = getPluginKey( element );
                    Plugin existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePlugin( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                        unmanaged.put( key, element );
                    }
                }

                if ( !unmanaged.isEmpty() )
                {
                    PluginManagement pluginMgmt = (PluginManagement) context.get( PLUGIN_MANAGEMENT );
                    if ( pluginMgmt != null )
                    {
                        for ( Iterator<Plugin> it = pluginMgmt.getPlugins().iterator(); it.hasNext(); )
                        {
                            Plugin managedPlugin = it.next();
                            Object key = getPluginKey( managedPlugin );
                            Plugin unmanagedPlugin = unmanaged.get( key );
                            if ( unmanagedPlugin != null )
                            {
                                Plugin plugin = managedPlugin.clone();
                                mergePlugin( plugin, unmanagedPlugin, sourceDominant, Collections.emptyMap() );
                                merged.put( key, plugin );
                            }
                        }
                    }
                }

                List<Plugin> result = new ArrayList<Plugin>( merged.values() );

                target.setPlugins( result );
            }
        }
3203#@Override
        protected void mergePluginExecution( PluginExecution target, PluginExecution source, boolean sourceDominant,
                                             Map<Object, Object> context )
        {
            super.mergePluginExecution( target, source, sourceDominant, context );

            target.setPriority( Math.min( target.getPriority(), source.getPriority() ) );
        }
3204#void addEventMonitor( EventMonitor monitor );
3205#void dispatchStart( String event, String target );
3206#void dispatchEnd( String event, String target );
3207#void dispatchError( String event, String target, Throwable cause );
3208#void startEvent( String eventName, String target, long timestamp );
3209#void endEvent( String eventName, String target, long timestamp );
3210#void errorEvent( String eventName, String target, long timestamp, Throwable cause );
3211#public PluginLoaderException( Plugin plugin, String message, ArtifactResolutionException cause )
    {
        super( message, cause );
        pluginKey = plugin.getKey();
    }
3212#public PluginLoaderException( Plugin plugin, String message, ArtifactNotFoundException cause )
    {
        super( message, cause );
        pluginKey = plugin.getKey();
    }
3213#public PluginLoaderException( Plugin plugin, String message, PluginNotFoundException cause )
    {
        super( message, cause );
        pluginKey = plugin.getKey();
    }
3214#public PluginLoaderException( Plugin plugin, String message, PluginVersionResolutionException cause )
    {
        super( message, cause );
        pluginKey = plugin.getKey();
    }
3215#public PluginLoaderException( Plugin plugin, String message, InvalidVersionSpecificationException cause )
    {
        super( message, cause );
        pluginKey = plugin.getKey();
    }
3216#public PluginLoaderException( Plugin plugin, String message, InvalidPluginException cause )
    {
        super( message, cause );
        pluginKey = plugin.getKey();
    }
3217#public PluginLoaderException( Plugin plugin, String message, PluginManagerException cause )
    {
        super( message, cause );
        pluginKey = plugin.getKey();
    }
3218#public PluginLoaderException( Plugin plugin, String message, PluginVersionNotFoundException cause )
    {
        super( message, cause );
        pluginKey = plugin.getKey();
    }
3219#public PluginLoaderException( Plugin plugin, String message )
    {
        super( message );
        pluginKey = plugin.getKey();
    }
3220#public PluginLoaderException( String message )
    {
        super( message );
    }
3221#public PluginLoaderException( String message, Throwable cause )
    {
        super( message, cause );
    }
3222#public PluginLoaderException( ReportPlugin plugin, String message, Throwable cause )
    {
        super( message, cause );
        pluginKey = plugin.getKey();
    }
3223#public PluginLoaderException( ReportPlugin plugin, String message )
    {
        super( message );
        pluginKey = plugin.getKey();
    }
3224#public String getPluginKey()
    {
        return pluginKey;
    }
3225#public Key createKey( Plugin plugin, DependencyFilter extensionFilter, List<RemoteRepository> repositories,
                          RepositorySystemSession session )
    {
        return new CacheKey( plugin, extensionFilter, repositories, session );
    }
3226#public CacheRecord get( Key key )
        throws PluginResolutionException
    {
        CacheRecord cacheRecord = cache.get( key );

        if ( cacheRecord != null && cacheRecord.exception != null )
        {
            throw cacheRecord.exception;
        }

        return cacheRecord;
    }
3227#public CacheRecord put( Key key, List<Artifact> pluginArtifacts )
    {
        if ( pluginArtifacts == null )
        {
            throw new NullPointerException();
        }

        assertUniqueKey( key );

        CacheRecord record =
            new CacheRecord( Collections.unmodifiableList( new ArrayList<Artifact>( pluginArtifacts ) ) );

        cache.put( key, record );

        return record;
    }
3228#protected void assertUniqueKey( Key key )
    {
        if ( cache.containsKey( key ) )
        {
            throw new IllegalStateException( "Duplicate artifact resolution result for plugin " + key );
        }
    }
3229#public CacheRecord put( Key key, PluginResolutionException exception )
    {
        if ( exception == null )
        {
            throw new NullPointerException();
        }

        assertUniqueKey( key );

        CacheRecord record = new CacheRecord( exception );

        cache.put( key, record );

        return record;
    }
3230#public void flush()
    {
        cache.clear();
    }
3231#protected static int pluginHashCode( Plugin plugin )
    {
        return CacheUtils.pluginHashCode( plugin );
    }
3232#protected static boolean pluginEquals( Plugin a, Plugin b )
    {
        return CacheUtils.pluginEquals( a, b );
    }
3233#public void register( MavenProject project, CacheRecord record )
    {
        // default cache does not track record usage
    }
3234#public CacheKey( Plugin plugin, DependencyFilter extensionFilter, List<RemoteRepository> repositories,
                         RepositorySystemSession session )
        {
            this.plugin = plugin.clone();
            workspace = CacheUtils.getWorkspace( session );
            this.localRepo = session.getLocalRepository();
            this.repositories = new ArrayList<RemoteRepository>( repositories.size() );
            for ( RemoteRepository repository : repositories )
            {
                if ( repository.isRepositoryManager() )
                {
                    this.repositories.addAll( repository.getMirroredRepositories() );
                }
                else
                {
                    this.repositories.add( repository );
                }
            }
            this.filter = extensionFilter;

            int hash = 17;
            hash = hash * 31 + CacheUtils.pluginHashCode( plugin );
            hash = hash * 31 + hash( workspace );
            hash = hash * 31 + hash( localRepo );
            hash = hash * 31 + CacheUtils.repositoriesHashCode( repositories );
            hash = hash * 31 + hash( extensionFilter );
            this.hashCode = hash;
        }
3235#@Override
        public String toString()
        {
            return plugin.getId();
        }
3236#@Override
        public int hashCode()
        {
            return hashCode;
        }
3237#private static int hash( Object obj )
        {
            return obj != null ? obj.hashCode() : 0;
        }
3238#@Override
        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return CacheUtils.pluginEquals( plugin, that.plugin ) && eq( workspace, that.workspace )
                && eq( localRepo, that.localRepo ) && CacheUtils.repositoriesEquals( repositories, that.repositories )
                && eq( filter, that.filter );
        }
3239#private static <T> boolean eq( T s1, T s2 )
        {
            return s1 != null ? s1.equals( s2 ) : s2 == null;
        }
3240#Key createKey( Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session );
3241#void put( Key key, PluginDescriptor pluginDescriptor );
3242#PluginDescriptor get( Key key );
3243#void flush();
3244#@Deprecated //TODO: used by the Enforcer plugin
    public PluginParameterExpressionEvaluator( MavenSession session, MojoExecution mojoExecution,
                                               PathTranslator pathTranslator, Logger logger, MavenProject project,
                                               Properties properties )
    {
        this( session, mojoExecution );
    }
3245#public PluginParameterExpressionEvaluator( MavenSession session )
    {
        this( session, null );
    }
3246#public PluginParameterExpressionEvaluator( MavenSession session, MojoExecution mojoExecution )
    {
        this.session = session;
        this.mojoExecution = mojoExecution;
        this.properties = session.getExecutionProperties();
        this.project = session.getCurrentProject();

        String basedir = null;

        if ( project != null )
        {
            File projectFile = project.getBasedir();

            // this should always be the case for non-super POM instances...
            if ( projectFile != null )
            {
                basedir = projectFile.getAbsolutePath();
            }
        }

        if ( ( basedir == null ) && ( session != null ) )
        {
            basedir = session.getExecutionRootDirectory();
        }

        if ( basedir == null )
        {
            basedir = System.getProperty( "user.dir" );
        }

        this.basedir = basedir;
    }
3247#public Object evaluate( String expr )
        throws ExpressionEvaluationException
    {
        return evaluate( expr, null );
    }
3248#public Object evaluate( String expr, Class<?> type )
        throws ExpressionEvaluationException
    {
        Object value = null;

        if ( expr == null )
        {
            return null;
        }

        String expression = stripTokens( expr );
        if ( expression.equals( expr ) )
        {
            int index = expr.indexOf( "${" );
            if ( index >= 0 )
            {
                int lastIndex = expr.indexOf( "}", index );
                if ( lastIndex >= 0 )
                {
                    String retVal = expr.substring( 0, index );

                    if ( ( index > 0 ) && ( expr.charAt( index - 1 ) == '$' ) )
                    {
                        retVal += expr.substring( index + 1, lastIndex + 1 );
                    }
                    else
                    {
                        Object subResult = evaluate( expr.substring( index, lastIndex + 1 ) );

                        if ( subResult != null )
                        {
                            retVal += subResult;
                        }
                        else
                        {
                            retVal += "$" + expr.substring( index + 1, lastIndex + 1 );
                        }
                    }

                    retVal += evaluate( expr.substring( lastIndex + 1 ) );
                    return retVal;
                }
            }

            // Was not an expression
            if ( expression.indexOf( "$$" ) > -1 )
            {
                return expression.replaceAll( "\\$\\$", "\\$" );
            }
            else
            {
                return expression;
            }
        }

        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();

        if ( "localRepository".equals( expression ) )
        {
            value = session.getLocalRepository();
        }
        else if ( "session".equals( expression ) )
        {
            value = session;
        }
        else if ( expression.startsWith( "session" ) )
        {
            try
            {
                int pathSeparator = expression.indexOf( "/" );

                if ( pathSeparator > 0 )
                {
                    String pathExpression = expression.substring( 1, pathSeparator );
                    value = ReflectionValueExtractor.evaluate( pathExpression, session );
                    value = value + expression.substring( pathSeparator );
                }
                else
                {
                    value = ReflectionValueExtractor.evaluate( expression.substring( 1 ), session );
                }
            }
            catch ( Exception e )
            {
                // TODO: don't catch exception
                throw new ExpressionEvaluationException( "Error evaluating plugin parameter expression: " + expression,
                                                         e );
            }
        }
        else if ( "reactorProjects".equals( expression ) )
        {
            value = session.getProjects();
        }
        else if ( "mojoExecution".equals( expression ) )
        {
            value = mojoExecution;
        }
        else if ( "project".equals( expression ) )
        {
            value = project;
        }
        else if ( "executedProject".equals( expression ) )
        {
            value = project.getExecutionProject();
        }
        else if ( expression.startsWith( "project" ) || expression.startsWith( "pom" ) )
        {
            try
            {
                int pathSeparator = expression.indexOf( "/" );

                if ( pathSeparator > 0 )
                {
                    String pathExpression = expression.substring( 0, pathSeparator );
                    value = ReflectionValueExtractor.evaluate( pathExpression, project );
                    value = value + expression.substring( pathSeparator );
                }
                else
                {
                    value = ReflectionValueExtractor.evaluate( expression.substring( 1 ), project );
                }
            }
            catch ( Exception e )
            {
                // TODO: don't catch exception
                throw new ExpressionEvaluationException( "Error evaluating plugin parameter expression: " + expression,
                                                         e );
            }
        }
        else if ( expression.equals( "repositorySystemSession" ) )
        {
            value = session.getRepositorySession();
        }
        else if ( expression.equals( "mojo" ) )
        {
            value = mojoExecution;
        }
        else if ( expression.startsWith( "mojo" ) )
        {
            try
            {
                int pathSeparator = expression.indexOf( "/" );

                if ( pathSeparator > 0 )
                {
                    String pathExpression = expression.substring( 1, pathSeparator );
                    value = ReflectionValueExtractor.evaluate( pathExpression, mojoExecution );
                    value = value + expression.substring( pathSeparator );
                }
                else
                {
                    value = ReflectionValueExtractor.evaluate( expression.substring( 1 ), mojoExecution );
                }
            }
            catch ( Exception e )
            {
                // TODO: don't catch exception
                throw new ExpressionEvaluationException( "Error evaluating plugin parameter expression: " + expression,
                                                         e );
            }
        }
        else if ( expression.equals( "plugin" ) )
        {
            value = mojoDescriptor.getPluginDescriptor();
        }
        else if ( expression.startsWith( "plugin" ) )
        {
            try
            {
                int pathSeparator = expression.indexOf( "/" );

                PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();

                if ( pathSeparator > 0 )
                {
                    String pathExpression = expression.substring( 1, pathSeparator );
                    value = ReflectionValueExtractor.evaluate( pathExpression, pluginDescriptor );
                    value = value + expression.substring( pathSeparator );
                }
                else
                {
                    value = ReflectionValueExtractor.evaluate( expression.substring( 1 ), pluginDescriptor );
                }
            }
            catch ( Exception e )
            {
                throw new ExpressionEvaluationException( "Error evaluating plugin parameter expression: " + expression,
                                                         e );
            }
        }
        else if ( "settings".equals( expression ) )
        {
            value = session.getSettings();
        }
        else if ( expression.startsWith( "settings" ) )
        {
            try
            {
                int pathSeparator = expression.indexOf( "/" );

                if ( pathSeparator > 0 )
                {
                    String pathExpression = expression.substring( 1, pathSeparator );
                    value = ReflectionValueExtractor.evaluate( pathExpression, session.getSettings() );
                    value = value + expression.substring( pathSeparator );
                }
                else
                {
                    value = ReflectionValueExtractor.evaluate( expression.substring( 1 ), session.getSettings() );
                }
            }
            catch ( Exception e )
            {
                // TODO: don't catch exception
                throw new ExpressionEvaluationException( "Error evaluating plugin parameter expression: " + expression,
                                                         e );
            }
        }
        else if ( "basedir".equals( expression ) )
        {
            value = basedir;
        }
        else if ( expression.startsWith( "basedir" ) )
        {
            int pathSeparator = expression.indexOf( "/" );

            if ( pathSeparator > 0 )
            {
                value = basedir + expression.substring( pathSeparator );
            }
        }

        /*
         * MNG-4312: We neither have reserved all of the above magic expressions nor is their set fixed/well-known (it
         * gets occasionally extended by newer Maven versions). This imposes the risk for existing plugins to
         * unintentionally use such a magic expression for an ordinary system property. So here we check whether we
         * ended up with a magic value that is not compatible with the type of the configured mojo parameter (a string
         * could still be converted by the configurator so we leave those alone). If so, back off to evaluating the
         * expression from properties only.
         */
        if ( value != null && type != null && !( value instanceof String ) && !isTypeCompatible( type, value ) )
        {
            value = null;
        }

        if ( value == null )
        {
            // The CLI should win for defining properties

            if ( ( value == null ) && ( properties != null ) )
            {
                // We will attempt to get nab a system property as a way to specify a
                // parameter to a plugins. My particular case here is allowing the surefire
                // plugin to run a single test so I want to specify that class on the cli
                // as a parameter.

                value = properties.getProperty( expression );
            }

            if ( ( value == null ) && ( ( project != null ) && ( project.getProperties() != null ) ) )
            {
                value = project.getProperties().getProperty( expression );
            }

        }

        if ( value instanceof String )
        {
            // TODO: without #, this could just be an evaluate call...

            String val = (String) value;

            int exprStartDelimiter = val.indexOf( "${" );

            if ( exprStartDelimiter >= 0 )
            {
                if ( exprStartDelimiter > 0 )
                {
                    value = val.substring( 0, exprStartDelimiter ) + evaluate( val.substring( exprStartDelimiter ) );
                }
                else
                {
                    value = evaluate( val.substring( exprStartDelimiter ) );
                }
            }
        }

        return value;
    }
3249#private static boolean isTypeCompatible( Class<?> type, Object value )
    {
        if ( type.isInstance( value ) )
        {
            return true;
        }
        // likely Boolean -> boolean, Short -> int etc. conversions, it's not the problem case we try to avoid
        return ( ( type.isPrimitive() || type.getName().startsWith( "java.lang." ) )
                        && value.getClass().getName().startsWith( "java.lang." ) );
    }
3250#private String stripTokens( String expr )
    {
        if ( expr.startsWith( "${" ) && ( expr.indexOf( "}" ) == expr.length() - 1 ) )
        {
            expr = expr.substring( 2, expr.length() - 1 );
        }
        return expr;
    }
3251#public File alignToBaseDirectory( File file )
    {
        // TODO: Copied from the DefaultInterpolator. We likely want to resurrect the PathTranslator or at least a
        // similar component for re-usage
        if ( file != null )
        {
            if ( file.isAbsolute() )
            {
                // path was already absolute, just normalize file separator and we're done
            }
            else if ( file.getPath().startsWith( File.separator ) )
            {
                // drive-relative Windows path, don't align with project directory but with drive root
                file = file.getAbsoluteFile();
            }
            else
            {
                // an ordinary relative path, align with project directory
                file = new File( new File( basedir, file.getPath() ).toURI().normalize() ).getAbsoluteFile();
            }
        }
        return file;
    }
3252#public MavenPluginValidator( Artifact pluginArtifact )
    {
        this.pluginArtifact = pluginArtifact;
    }
3253#public void validate( PluginDescriptor pluginDescriptor )
    {
        /*
         * NOTE: For plugins that depend on other plugin artifacts the plugin realm contains more than one plugin
         * descriptor. However, only the first descriptor is of interest.
         */
        if ( !firstDescriptor )
        {
            return;
        }
        firstDescriptor = false;

        if ( !pluginArtifact.getGroupId().equals( pluginDescriptor.getGroupId() ) )
        {
            errors.add( "Plugin's descriptor contains the wrong group ID: " + pluginDescriptor.getGroupId() );
        }

        if ( !pluginArtifact.getArtifactId().equals( pluginDescriptor.getArtifactId() ) )
        {
            errors.add( "Plugin's descriptor contains the wrong artifact ID: " + pluginDescriptor.getArtifactId() );
        }

        if ( !pluginArtifact.getBaseVersion().equals( pluginDescriptor.getVersion() ) )
        {
            errors.add( "Plugin's descriptor contains the wrong version: " + pluginDescriptor.getVersion() );
        }
    }
3254#public boolean hasErrors()
    {
        return !errors.isEmpty();
    }
3255#public List<String> getErrors()
    {
        return errors;
    }
3256#public Key createKey( Plugin plugin, ClassLoader parentRealm, Map<String, ClassLoader> foreignImports,
                          DependencyFilter dependencyFilter, List<RemoteRepository> repositories,
                          RepositorySystemSession session )
    {
        return new CacheKey( plugin, parentRealm, foreignImports, dependencyFilter, repositories, session );
    }
3257#public CacheRecord get( Key key )
    {
        return cache.get( key );
    }
3258#public CacheRecord put( Key key, ClassRealm pluginRealm, List<Artifact> pluginArtifacts )
    {
        if ( pluginRealm == null || pluginArtifacts == null )
        {
            throw new IllegalArgumentException();
        }

        if ( cache.containsKey( key ) )
        {
            throw new IllegalStateException( "Duplicate plugin realm for plugin " + key );
        }

        CacheRecord record = new CacheRecord( pluginRealm, pluginArtifacts );

        cache.put( key, record );

        return record;
    }
3259#public void flush()
    {
        cache.clear();
    }
3260#protected static int pluginHashCode( Plugin plugin )
    {
        return CacheUtils.pluginHashCode( plugin );
    }
3261#protected static boolean pluginEquals( Plugin a, Plugin b )
    {
        return CacheUtils.pluginEquals( a, b );
    }
3262#public void register( MavenProject project, CacheRecord record )
    {
        // default cache does not track plugin usage
    }
3263#public CacheKey( Plugin plugin, ClassLoader parentRealm, Map<String, ClassLoader> foreignImports,
                         DependencyFilter dependencyFilter, List<RemoteRepository> repositories,
                         RepositorySystemSession session )
        {
            this.plugin = plugin.clone();
            this.workspace = CacheUtils.getWorkspace( session );
            this.localRepo = session.getLocalRepository();
            this.repositories = new ArrayList<RemoteRepository>( repositories.size() );
            for ( RemoteRepository repository : repositories )
            {
                if ( repository.isRepositoryManager() )
                {
                    this.repositories.addAll( repository.getMirroredRepositories() );
                }
                else
                {
                    this.repositories.add( repository );
                }
            }
            this.parentRealm = parentRealm;
            this.foreignImports =
                ( foreignImports != null ) ? foreignImports : Collections.<String, ClassLoader> emptyMap();
            this.filter = dependencyFilter;

            int hash = 17;
            hash = hash * 31 + CacheUtils.pluginHashCode( plugin );
            hash = hash * 31 + hash( workspace );
            hash = hash * 31 + hash( localRepo );
            hash = hash * 31 + CacheUtils.repositoriesHashCode( repositories );
            hash = hash * 31 + hash( parentRealm );
            hash = hash * 31 + this.foreignImports.hashCode();
            hash = hash * 31 + hash( dependencyFilter );
            this.hashCode = hash;
        }
3264#@Override
        public String toString()
        {
            return plugin.getId();
        }
3265#@Override
        public int hashCode()
        {
            return hashCode;
        }
3266#private static int hash( Object obj )
        {
            return obj != null ? obj.hashCode() : 0;
        }
3267#@Override
        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) o;

            return parentRealm == that.parentRealm && CacheUtils.pluginEquals( plugin, that.plugin )
                && eq( workspace, that.workspace ) && eq( localRepo, that.localRepo )
                && CacheUtils.repositoriesEquals( this.repositories, that.repositories ) && eq( filter, that.filter )
                && eq( foreignImports, that.foreignImports );
        }
3268#private static <T> boolean eq( T s1, T s2 )
        {
            return s1 != null ? s1.equals( s2 ) : s2 == null;
        }
3269#public PluginContainerException( MojoDescriptor mojoDescriptor, ClassRealm pluginRealm, String message, Throwable e )
    {
        super( mojoDescriptor, message, e );

        this.pluginRealm = pluginRealm;
    }
3270#public PluginContainerException( MojoDescriptor mojoDescriptor, ClassRealm pluginRealm, String message,
                                     ComponentLookupException e )
    {
        super( mojoDescriptor, message, e );

        this.pluginRealm = pluginRealm;
    }
3271#public PluginContainerException( Plugin plugin, ClassRealm pluginRealm, String message, Throwable e )
    {
        super( plugin, message, e );

        this.pluginRealm = pluginRealm;
    }
3272#public PluginContainerException( Plugin plugin, ClassRealm pluginRealm, String message,
                                     PlexusConfigurationException e )
    {
        super( plugin, message, e );

        this.pluginRealm = pluginRealm;
    }
3273#public PluginContainerException( Plugin plugin, ClassRealm pluginRealm, String message,
                                     ComponentRepositoryException e )
    {
        super( plugin, message, e );

        this.pluginRealm = pluginRealm;
    }
3274#public ClassRealm getPluginRealm()
    {
        return pluginRealm;
    }
3275#public PluginResolutionException( Plugin plugin, Throwable cause )
    {
        super( "Plugin " + plugin.getId() + " or one of its dependencies could not be resolved: " + cause.getMessage(),
               cause );
        this.plugin = plugin;
    }
3276#public Plugin getPlugin()
    {
        return plugin;
    }
3277#protected PluginManagerException( Plugin plugin, String message, MavenProject project, Throwable cause )
    {
        super( message, cause );

        this.project = project;
        pluginGroupId = plugin.getGroupId();
        pluginArtifactId = plugin.getArtifactId();
        pluginVersion = plugin.getVersion();
    }
3278#public PluginManagerException( Plugin plugin, String message, Throwable cause )
    {
        super( message, cause );

        pluginGroupId = plugin.getGroupId();
        pluginArtifactId = plugin.getArtifactId();
        pluginVersion = plugin.getVersion();
    }
3279#protected PluginManagerException( MojoDescriptor mojoDescriptor, String message, Throwable cause )
    {
        super( message, cause );
        pluginGroupId = mojoDescriptor.getPluginDescriptor().getGroupId();
        pluginArtifactId = mojoDescriptor.getPluginDescriptor().getArtifactId();
        pluginVersion = mojoDescriptor.getPluginDescriptor().getVersion();
        goal = mojoDescriptor.getGoal();
    }
3280#protected PluginManagerException( MojoDescriptor mojoDescriptor, MavenProject project, String message )
    {
        super( message );
        this.project = project;
        pluginGroupId = mojoDescriptor.getPluginDescriptor().getGroupId();
        pluginArtifactId = mojoDescriptor.getPluginDescriptor().getArtifactId();
        pluginVersion = mojoDescriptor.getPluginDescriptor().getVersion();
        goal = mojoDescriptor.getGoal();
    }
3281#protected PluginManagerException( MojoDescriptor mojoDescriptor, MavenProject project, String message,
                                      Throwable cause )
    {
        super( message, cause );
        this.project = project;
        pluginGroupId = mojoDescriptor.getPluginDescriptor().getGroupId();
        pluginArtifactId = mojoDescriptor.getPluginDescriptor().getArtifactId();
        pluginVersion = mojoDescriptor.getPluginDescriptor().getVersion();
        goal = mojoDescriptor.getGoal();
    }
3282#public PluginManagerException( Plugin plugin, InvalidVersionSpecificationException cause )
    {
        super( cause );

        pluginGroupId = plugin.getGroupId();
        pluginArtifactId = plugin.getArtifactId();
        pluginVersion = plugin.getVersion();
    }
3283#public PluginManagerException( Plugin plugin, String message, PlexusConfigurationException cause )
    {
        super( message, cause );

        pluginGroupId = plugin.getGroupId();
        pluginArtifactId = plugin.getArtifactId();
        pluginVersion = plugin.getVersion();
    }
3284#public PluginManagerException( Plugin plugin, String message, ComponentRepositoryException cause )
    {
        super( message, cause );

        pluginGroupId = plugin.getGroupId();
        pluginArtifactId = plugin.getArtifactId();
        pluginVersion = plugin.getVersion();
    }
3285#public PluginManagerException( MojoDescriptor mojoDescriptor, MavenProject project, String message,
                                   NoSuchRealmException cause )
    {
        super( message, cause );

        this.project = project;
        pluginGroupId = mojoDescriptor.getPluginDescriptor().getGroupId();
        pluginArtifactId = mojoDescriptor.getPluginDescriptor().getArtifactId();
        pluginVersion = mojoDescriptor.getPluginDescriptor().getVersion();
        goal = mojoDescriptor.getGoal();
    }
3286#public PluginManagerException( MojoDescriptor mojoDescriptor, String message, MavenProject project,
                                   PlexusContainerException cause )
    {
        super( message, cause );

        this.project = project;

        PluginDescriptor pd = mojoDescriptor.getPluginDescriptor();
        pluginGroupId = pd.getGroupId();
        pluginArtifactId = pd.getArtifactId();
        pluginVersion = pd.getVersion();

        goal = mojoDescriptor.getGoal();
    }
3287#public PluginManagerException( Plugin plugin, String message, PlexusContainerException cause )
    {
        super( message, cause );

        pluginGroupId = plugin.getGroupId();
        pluginArtifactId = plugin.getArtifactId();
        pluginVersion = plugin.getVersion();
    }
3288#public PluginManagerException( Plugin plugin, String message, MavenProject project )
    {
        super( message );

        pluginGroupId = plugin.getGroupId();
        pluginArtifactId = plugin.getArtifactId();
        pluginVersion = plugin.getVersion();
        this.project = project;
    }
3289#public String getPluginGroupId()
    {
        return pluginGroupId;
    }
3290#public String getPluginArtifactId()
    {
        return pluginArtifactId;
    }
3291#public String getPluginVersion()
    {
        return pluginVersion;
    }
3292#public String getGoal()
    {
        return goal;
    }
3293#public MavenProject getProject()
    {
        return project;
    }
3294#public void flush()
    {
        descriptors.clear();
    }
3295#public Key createKey( Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session )
    {
        return new CacheKey( plugin, repositories, session );
    }
3296#public PluginDescriptor get( Key cacheKey )
    {
        return clone( descriptors.get( cacheKey ) );
    }
3297#public void put( Key cacheKey, PluginDescriptor pluginDescriptor )
    {
        descriptors.put( cacheKey, clone( pluginDescriptor ) );
    }
3298#protected static PluginDescriptor clone( PluginDescriptor original )
    {
        PluginDescriptor clone = null;

        if ( original != null )
        {
            clone = new PluginDescriptor();

            clone.setGroupId( original.getGroupId() );
            clone.setArtifactId( original.getArtifactId() );
            clone.setVersion( original.getVersion() );
            clone.setGoalPrefix( original.getGoalPrefix() );
            clone.setInheritedByDefault( original.isInheritedByDefault() );

            clone.setName( original.getName() );
            clone.setDescription( original.getDescription() );
            clone.setRequiredMavenVersion( original.getRequiredMavenVersion() );

            clone.setPluginArtifact( ArtifactUtils.copyArtifactSafe( original.getPluginArtifact() ) );

            clone.setComponents( clone( original.getMojos(), clone ) );
            clone.setId( original.getId() );
            clone.setIsolatedRealm( original.isIsolatedRealm() );
            clone.setSource( original.getSource() );
        }

        return clone;
    }
3299#private static List<ComponentDescriptor<?>> clone( List<MojoDescriptor> mojos, PluginDescriptor pluginDescriptor )
    {
        List<ComponentDescriptor<?>> clones = null;

        if ( mojos != null )
        {
            clones = new ArrayList<ComponentDescriptor<?>>( mojos.size() );

            for ( MojoDescriptor mojo : mojos )
            {
                MojoDescriptor clone = mojo.clone();
                clone.setPluginDescriptor( pluginDescriptor );
                clones.add( clone );
            }
        }

        return clones;
    }
3300#public CacheKey( Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session )
        {
            groupId = plugin.getGroupId();
            artifactId = plugin.getArtifactId();
            version = plugin.getVersion();

            workspace = CacheUtils.getWorkspace( session );
            localRepo = session.getLocalRepository();
            this.repositories = new ArrayList<RemoteRepository>( repositories.size() );
            for ( RemoteRepository repository : repositories )
            {
                if ( repository.isRepositoryManager() )
                {
                    this.repositories.addAll( repository.getMirroredRepositories() );
                }
                else
                {
                    this.repositories.add( repository );
                }
            }

            int hash = 17;
            hash = hash * 31 + groupId.hashCode();
            hash = hash * 31 + artifactId.hashCode();
            hash = hash * 31 + version.hashCode();
            hash = hash * 31 + hash( workspace );
            hash = hash * 31 + localRepo.hashCode();
            hash = hash * 31 + CacheUtils.repositoriesHashCode( repositories );
            this.hashCode = hash;
        }
3301#@Override
        public int hashCode()
        {
            return hashCode;
        }
3302#@Override
        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return eq( this.artifactId, that.artifactId ) && eq( this.groupId, that.groupId )
                && eq( this.version, that.version ) && eq( this.localRepo, that.localRepo )
                && eq( this.workspace, that.workspace )
                && CacheUtils.repositoriesEquals( this.repositories, that.repositories );
        }
3303#@Override
        public String toString()
        {
            return groupId + ':' + artifactId + ':' + version;
        }
3304#private static int hash( Object obj )
        {
            return obj != null ? obj.hashCode() : 0;
        }
3305#private static <T> boolean eq( T s1, T s2 )
        {
            return s1 != null ? s1.equals( s2 ) : s2 == null;
        }
3306#// igorf: Way too many declared exceptions!
    PluginDescriptor loadPlugin( Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        InvalidPluginDescriptorException;
3307#// igorf: Way too many declared exceptions!
    MojoDescriptor getMojoDescriptor( Plugin plugin, String goal, List<RemoteRepository> repositories,
                                      RepositorySystemSession session )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, InvalidPluginDescriptorException;
3308#ClassRealm getPluginRealm( MavenSession session, PluginDescriptor pluginDescriptor )
        throws PluginResolutionException, PluginManagerException;
3309#void executeMojo( MavenSession session, MojoExecution execution )
        throws MojoFailureException, MojoExecutionException, PluginConfigurationException, PluginManagerException;
3310#public PluginExecutionException( MojoExecution mojoExecution, MavenProject project, String message )
    {
        super( mojoExecution.getMojoDescriptor(), project, message );
        this.mojoExecution = mojoExecution;
    }
3311#public PluginExecutionException( MojoExecution mojoExecution, MavenProject project, String message, Throwable cause )
    {
        super( mojoExecution.getMojoDescriptor(), project, message, cause );
        this.mojoExecution = mojoExecution;
    }
3312#public PluginExecutionException( MojoExecution mojoExecution, MavenProject project, Exception cause )
    {
        super( mojoExecution.getMojoDescriptor(), project, constructMessage( mojoExecution, cause ), cause );
        this.mojoExecution = mojoExecution;
    }
3313#public PluginExecutionException( MojoExecution mojoExecution, MavenProject project,
                                     DuplicateArtifactAttachmentException cause )
    {
        super( mojoExecution.getMojoDescriptor(), project, constructMessage( mojoExecution, cause ), cause );
        this.mojoExecution = mojoExecution;
    }
3314#public MojoExecution getMojoExecution()
    {
        return mojoExecution;
    }
3315#private static String constructMessage( MojoExecution mojoExecution, Throwable cause )
    {
        String message;

        if ( mojoExecution != null )
        {
            message =
                "Execution " + mojoExecution.getExecutionId() + " of goal " + mojoExecution.getMojoDescriptor().getId()
                    + " failed";
        }
        else
        {
            message = "Mojo execution failed";
        }

        if ( cause != null && StringUtils.isNotEmpty( cause.getMessage() ) )
        {
            message += ": " + cause.getMessage();
        }
        else
        {
            message += ".";
        }

        return message;
    }
3316#/**
     * Sets the currently active session. Some legacy components are basically stateful and their API is missing
     * parameters that would be required to delegate to a stateless component. Saving the session (in a thread-local
     * variable) is our best effort to record any state that is required to enable proper delegation.
     * 
     * @param session The currently active session, may be {@code null}.
     */
    void setSession( MavenSession session );
3317#/**
     * Gets the currently active session.
     * 
     * @return The currently active session or {@code null} if none.
     */
    MavenSession getSession();
3318#/**
     * Gets the currently active repository session.
     * 
     * @return The currently active repository session or {@code null} if none.
     */
    RepositorySystemSession getRepositorySession();
3319#void executeMojo( MavenProject project, MojoExecution execution, MavenSession session )
        throws MojoExecutionException, ArtifactResolutionException, MojoFailureException, ArtifactNotFoundException,
        InvalidDependencyVersionException, PluginManagerException, PluginConfigurationException;
3320#PluginDescriptor getPluginDescriptorForPrefix( String prefix );
3321#Plugin getPluginDefinitionForPrefix( String prefix, MavenSession session, MavenProject project );
3322#PluginDescriptor verifyPlugin( Plugin plugin, MavenProject project, Settings settings,
                                   ArtifactRepository localRepository )
        throws ArtifactResolutionException, PluginVersionResolutionException, ArtifactNotFoundException,
        InvalidVersionSpecificationException, InvalidPluginException, PluginManagerException, PluginNotFoundException,
        PluginVersionNotFoundException;
3323#Object getPluginComponent( Plugin plugin, String role, String roleHint )
        throws PluginManagerException, ComponentLookupException;
3324#Map getPluginComponents( Plugin plugin, String role )
        throws ComponentLookupException, PluginManagerException;
3325#/**
     * @since 2.2.1
     */
    PluginDescriptor loadPluginDescriptor( Plugin plugin, MavenProject project, MavenSession session )
        throws ArtifactResolutionException, PluginVersionResolutionException, ArtifactNotFoundException,
        InvalidVersionSpecificationException, InvalidPluginException, PluginManagerException, PluginNotFoundException,
        PluginVersionNotFoundException;
3326#/**
     * @since 2.2.1
     */
    PluginDescriptor loadPluginFully( Plugin plugin, MavenProject project, MavenSession session )
        throws ArtifactResolutionException, PluginVersionResolutionException, ArtifactNotFoundException,
        InvalidVersionSpecificationException, InvalidPluginException, PluginManagerException, PluginNotFoundException,
        PluginVersionNotFoundException;
3327#CacheRecord get( List<? extends Artifact> extensionArtifacts );
3328#CacheRecord put( List<? extends Artifact> extensionArtifacts, ClassRealm extensionRealm,
                     ExtensionDescriptor extensionDescriptor );
3329#void flush();
3330#/**
     * Registers the specified cache record for usage with the given project. Integrators can use the information
     * collected from this method in combination with a custom cache implementation to dispose unused records from the
     * cache.
     * 
     * @param project The project that employs the plugin realm, must not be {@code null}.
     * @param record The cache record being used for the project, must not be {@code null}.
     */
    void register( MavenProject project, CacheRecord record );
3331#public CacheRecord( ClassRealm realm, ExtensionDescriptor descriptor )
        {
            this.realm = realm;
            this.desciptor = descriptor;
        }
3332#public InvalidPluginException( String message, ProjectBuildingException e )
    {
        super( message, e );
    }
3333#public InvalidPluginException( String message, InvalidDependencyVersionException e )
    {
        super( message, e );
    }
3334#public InvalidPluginException( String message )
    {
        super( message );
    }
3335#public PluginParameterException( MojoDescriptor mojo, List<Parameter> parameters )
    {
        super( mojo.getPluginDescriptor(), "The parameters " + format( parameters ) + " for goal "
            + mojo.getRoleHint() + " are missing or invalid" );

        this.mojo = mojo;

        this.parameters = parameters;
    }
3336#private static String format( List<Parameter> parameters )
    {
        StringBuilder buffer = new StringBuilder( 128 );
        if ( parameters != null )
        {
            for ( Parameter parameter : parameters )
            {
                if ( buffer.length() > 0 )
                {
                    buffer.append( ", " );
                }
                buffer.append( '\'' ).append( parameter.getName() ).append( '\'' );
            }
        }
        return buffer.toString();
    }
3337#public MojoDescriptor getMojoDescriptor()
    {
        return mojo;
    }
3338#public List<Parameter> getParameters()
    {
        return parameters;
    }
3339#private static void decomposeParameterIntoUserInstructions( MojoDescriptor mojo, Parameter param,
                                                                StringBuilder messageBuffer )
    {
        String expression = param.getExpression();

        if ( param.isEditable() )
        {
            messageBuffer.append( "Inside the definition for plugin \'" + mojo.getPluginDescriptor().getArtifactId()
                + "\' specify the following:\n\n<configuration>\n  ...\n  <" + param.getName() + ">VALUE</"
                + param.getName() + ">\n</configuration>" );

            String alias = param.getAlias();
            if ( StringUtils.isNotEmpty( alias ) && !alias.equals( param.getName() ) )
            {
                messageBuffer.append(
                    "\n\n-OR-\n\n<configuration>\n  ...\n  <" + alias + ">VALUE</" + alias + ">\n</configuration>\n" );
            }
        }

        if ( StringUtils.isEmpty( expression ) )
        {
            messageBuffer.append( "." );
        }
        else
        {
            if ( param.isEditable() )
            {
                messageBuffer.append( "\n\n-OR-\n\n" );
            }

            //addParameterUsageInfo( expression, messageBuffer );
        }
    }
3340#public String buildDiagnosticMessage()
    {
        StringBuilder messageBuffer = new StringBuilder( 256 );

        List<Parameter> params = getParameters();
        MojoDescriptor mojo = getMojoDescriptor();

        messageBuffer.append( "One or more required plugin parameters are invalid/missing for \'" )
            .append( mojo.getPluginDescriptor().getGoalPrefix() ).append( ":" ).append( mojo.getGoal() )
            .append( "\'\n" );

        int idx = 0;
        for ( Iterator<Parameter> it = params.iterator(); it.hasNext(); idx++ )
        {
            Parameter param = it.next();

            messageBuffer.append( "\n[" ).append( idx ).append( "] " );

            decomposeParameterIntoUserInstructions( mojo, param, messageBuffer );

            messageBuffer.append( "\n" );
        }

        return messageBuffer.toString();
    }
3341#/**
     * 
     * @param plugin
     * @param repositoryRequest
     * @return PluginDescriptor The component descriptor for the Maven plugin.
     * @throws PluginNotFoundException The plugin could not be found in any repositories.
     * @throws PluginResolutionException The plugin could be found but could not be resolved.
     * @throws InvalidPluginDescriptorException 
     */
    public PluginDescriptor loadPlugin( Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, InvalidPluginDescriptorException
    {
        return mavenPluginManager.getPluginDescriptor( plugin, repositories, session );
    }
3342#// ----------------------------------------------------------------------
    // Mojo execution
    // ----------------------------------------------------------------------

    public void executeMojo( MavenSession session, MojoExecution mojoExecution )
        throws MojoFailureException, MojoExecutionException, PluginConfigurationException, PluginManagerException
    {
        MavenProject project = session.getCurrentProject();

        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();

        Mojo mojo = null;

        ClassRealm pluginRealm;
        try
        {
            pluginRealm = getPluginRealm( session, mojoDescriptor.getPluginDescriptor() );
        }
        catch ( PluginResolutionException e )
        {
            throw new PluginExecutionException( mojoExecution, project, e );
        }

        ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader( pluginRealm );

        MavenSession oldSession = legacySupport.getSession();

        try
        {
            mojo = mavenPluginManager.getConfiguredMojo( Mojo.class, session, mojoExecution );

            legacySupport.setSession( session );

            // NOTE: DuplicateArtifactAttachmentException is currently unchecked, so be careful removing this try/catch!
            // This is necessary to avoid creating compatibility problems for existing plugins that use
            // MavenProjectHelper.attachArtifact(..).
            try
            {
                mojo.execute();
            }
            catch ( ClassCastException e )
            {
                // to be processed in the outer catch block
                throw e;
            }
            catch ( RuntimeException e )
            {
                throw new PluginExecutionException( mojoExecution, project, e );
            }
        }
        catch ( PluginContainerException e )
        {
            throw new PluginExecutionException( mojoExecution, project, e );
        }
        catch ( NoClassDefFoundError e )
        {
            ByteArrayOutputStream os = new ByteArrayOutputStream( 1024 );
            PrintStream ps = new PrintStream( os );
            ps.println( "A required class was missing while executing " + mojoDescriptor.getId() + ": "
                + e.getMessage() );
            pluginRealm.display( ps );

            Exception wrapper = new PluginContainerException( mojoDescriptor, pluginRealm, os.toString(), e );

            throw new PluginExecutionException( mojoExecution, project, wrapper );
        }
        catch ( LinkageError e )
        {
            ByteArrayOutputStream os = new ByteArrayOutputStream( 1024 );
            PrintStream ps = new PrintStream( os );
            ps.println( "An API incompatibility was encountered while executing " + mojoDescriptor.getId() + ": "
                + e.getClass().getName() + ": " + e.getMessage() );
            pluginRealm.display( ps );

            Exception wrapper = new PluginContainerException( mojoDescriptor, pluginRealm, os.toString(), e );

            throw new PluginExecutionException( mojoExecution, project, wrapper );
        }
        catch ( ClassCastException e )
        {
            ByteArrayOutputStream os = new ByteArrayOutputStream( 1024 );
            PrintStream ps = new PrintStream( os );
            ps.println( "A type incompatibility occured while executing " + mojoDescriptor.getId() + ": "
                + e.getMessage() );
            pluginRealm.display( ps );

            throw new PluginExecutionException( mojoExecution, project, os.toString(), e );
        }
        finally
        {
            mavenPluginManager.releaseMojo( mojo, mojoExecution );

            Thread.currentThread().setContextClassLoader( oldClassLoader );

            legacySupport.setSession( oldSession );
        }
    }
3343#/**
     * TODO pluginDescriptor classRealm and artifacts are set as a side effect of this
     *      call, which is not nice.
     * @throws PluginResolutionException 
     */
    public ClassRealm getPluginRealm( MavenSession session, PluginDescriptor pluginDescriptor ) 
        throws PluginResolutionException, PluginManagerException
    {
        ClassRealm pluginRealm = pluginDescriptor.getClassRealm();
        if ( pluginRealm != null )
        {
            return pluginRealm;
        }

        mavenPluginManager.setupPluginRealm( pluginDescriptor, session, null, null, null );

        return pluginDescriptor.getClassRealm();
    }
3344#public MojoDescriptor getMojoDescriptor( Plugin plugin, String goal, List<RemoteRepository> repositories,
                                             RepositorySystemSession session )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, InvalidPluginDescriptorException
    {
        return mavenPluginManager.getMojoDescriptor( plugin, goal, repositories, session );
    }
3345#public CycleDetectedInPluginGraphException( Plugin plugin, CycleDetectedInComponentGraphException e )
    {
        super( "A cycle was detected in the component graph of the plugin: " + plugin.getArtifactId() ); 

        this.plugin = plugin;
    }
3346#public Plugin getPlugin()
    {
        return plugin;
    }
3347#public MojoExecution( Plugin plugin, String goal, String executionId )
    {
        this.plugin = plugin;
        this.goal = goal;
        this.executionId = executionId;
    }
3348#public MojoExecution( MojoDescriptor mojoDescriptor )
    {
        this.mojoDescriptor = mojoDescriptor;
        this.executionId = null;
        this.configuration = null;
    }
3349#public MojoExecution( MojoDescriptor mojoDescriptor, String executionId, Source source )
    {
        this.mojoDescriptor = mojoDescriptor;
        this.executionId = executionId;
        this.configuration = null;
        this.source = source;
    }
3350#public MojoExecution( MojoDescriptor mojoDescriptor, String executionId )
    {
        this.mojoDescriptor = mojoDescriptor;
        this.executionId = executionId;
        this.configuration = null;
    }
3351#public MojoExecution( MojoDescriptor mojoDescriptor, Xpp3Dom configuration )
    {
        this.mojoDescriptor = mojoDescriptor;
        this.configuration = configuration;
        this.executionId = null;
    }
3352#/**
     * Gets the source of this execution.
     * 
     * @return The source of this execution or {@code null} if unknown.
     */
    public Source getSource()
    {
        return source;
    }
3353#public String getExecutionId()
    {
        return executionId;
    }
3354#public Plugin getPlugin()
    {
        if ( mojoDescriptor != null )
        {
            return mojoDescriptor.getPluginDescriptor().getPlugin();
        }

        return plugin;
    }
3355#public MojoDescriptor getMojoDescriptor()
    {
        return mojoDescriptor;
    }
3356#public Xpp3Dom getConfiguration()
    {
        return configuration;
    }
3357#public void setConfiguration( Xpp3Dom configuration )
    {
        this.configuration = configuration;
    }
3358#public String identify()
    {
        StringBuilder sb = new StringBuilder( 256 );
        
        sb.append( executionId );
        sb.append( configuration.toString() );
        
        return sb.toString();
    }
3359#public String getLifecyclePhase()
    {
        return lifecyclePhase;
    }
3360#public void setLifecyclePhase( String lifecyclePhase )
    {
        this.lifecyclePhase = lifecyclePhase;
    }
3361#@Override
    public String toString()
    {
        StringBuilder buffer = new StringBuilder( 128 );
        if ( mojoDescriptor != null )
        {
            buffer.append( mojoDescriptor.getId() );
        }
        buffer.append( " {execution: " ).append( executionId ).append( "}" );
        return buffer.toString();
    }
3362#public String getGroupId()
    {
        if ( mojoDescriptor != null )
        {
            return mojoDescriptor.getPluginDescriptor().getGroupId();
        }
        
        return plugin.getGroupId();
    }
3363#public String getArtifactId()
    {
        if ( mojoDescriptor != null )
        {
            return mojoDescriptor.getPluginDescriptor().getArtifactId();
        }
        
        return plugin.getArtifactId();
    }
3364#public String getVersion()
    {
        if ( mojoDescriptor != null )
        {
            return mojoDescriptor.getPluginDescriptor().getVersion();
        }        
        
        return plugin.getVersion();
    }
3365#public String getGoal()
    {
        if ( mojoDescriptor != null )
        {
            return mojoDescriptor.getGoal();
        }
        
        return goal;
    }
3366#public void setMojoDescriptor( MojoDescriptor mojoDescriptor )
    {
        this.mojoDescriptor = mojoDescriptor;
    }
3367#public Map<String, List<MojoExecution>> getForkedExecutions()
    {
        return forkedExecutions;
    }
3368#public void setForkedExecutions( String projectKey, List<MojoExecution> forkedExecutions )
    {
        this.forkedExecutions.put( projectKey, forkedExecutions );
    }
3369#public DebugConfigurationListener( Logger logger )
    {
        this.logger = logger;
    }
3370#public void notifyFieldChangeUsingSetter( String fieldName, Object value, Object target )
    {
        if ( logger.isDebugEnabled() )
        {
            logger.debug( "  (s) " + fieldName + " = " + toString( value ) );
        }
    }
3371#public void notifyFieldChangeUsingReflection( String fieldName, Object value, Object target )
    {
        if ( logger.isDebugEnabled() )
        {
            logger.debug( "  (f) " + fieldName + " = " + toString( value ) );
        }
    }
3372#/**
     * Creates a human-friendly string represenation of the specified object.
     * 
     * @param obj The object to create a string representation for, may be <code>null</code>.
     * @return The string representation, never <code>null</code>.
     */
    private String toString( Object obj )
    {
        String str;
        if ( obj != null && obj.getClass().isArray() )
        {
            int n = Array.getLength( obj );
            StringBuilder buf = new StringBuilder( 256 );
            buf.append( '[' );
            for ( int i = 0; i < n; i++ )
            {
                if ( i > 0 )
                {
                    buf.append( ", " );
                }
                buf.append( String.valueOf( Array.get( obj, i ) ) );
            }
            buf.append( ']' );
            str = buf.toString();
        }
        else
        {
            str = String.valueOf( obj );
        }
        return str;
    }
3373#Key createKey( Plugin plugin, DependencyFilter extensionFilter, List<RemoteRepository> repositories,
                   RepositorySystemSession session );
3374#CacheRecord get( Key key ) throws PluginResolutionException;
3375#CacheRecord put( Key key, List<Artifact> pluginArtifacts );
3376#CacheRecord put( Key key, PluginResolutionException e );
3377#void flush();
3378#/**
     * Registers the specified cache record for usage with the given project. Integrators can use the information
     * collected from this method in combination with a custom cache implementation to dispose unused records from the
     * cache.
     * 
     * @param project The project that employs the plugin realm, must not be {@code null}.
     * @param record The cache record being used for the project, must not be {@code null}.
     */
    void register( MavenProject project, CacheRecord record );
3379#public CacheRecord( List<Artifact> artifacts )
        {
            this.artifacts = artifacts;
            this.exception = null;
        }
3380#public CacheRecord( PluginResolutionException exception )
        {
            this.artifacts = null;
            this.exception = exception;
        }
3381#public PluginIncompatibleException( Plugin plugin, String message )
    {
        super( plugin, message, (Throwable) null );
    }
3382#public InvalidPluginDescriptorException( String message, List<String> errors )
    {
        super( toMessage( message, errors ) );
    }
3383#private static String toMessage( String message, List<String> errors )
    {
        StringBuilder buffer = new StringBuilder( 256 );
        buffer.append( message );
        for ( String error : errors )
        {
            buffer.append( ", " ).append( error );
        }
        return buffer.toString();
    }
3384#public static <T> boolean eq( T s1, T s2 )
    {
        return s1 != null ? s1.equals( s2 ) : s2 == null;
    }
3385#public static int hash( Object obj )
    {
        return obj != null ? obj.hashCode() : 0;
    }
3386#public static int repositoriesHashCode( List<RemoteRepository> repositories )
    {
        int result = 17;
        for ( RemoteRepository repository : repositories )
        {
            result = 31 * result + repositoryHashCode( repository );
        }
        return result;
    }
3387#private static int repositoryHashCode( RemoteRepository repository )
    {
        int result = 17;
        result = 31 * result + hash( repository.getUrl() );
        return result;
    }
3388#private static boolean repositoryEquals( RemoteRepository r1, RemoteRepository r2 )
    {
        if ( r1 == r2 )
        {
            return true;
        }

        return eq( r1.getId(), r2.getId() ) && eq( r1.getUrl(), r2.getUrl() )
            && policyEquals( r1.getPolicy( false ), r2.getPolicy( false ) )
            && policyEquals( r1.getPolicy( true ), r2.getPolicy( true ) );
    }
3389#private static boolean policyEquals( RepositoryPolicy p1, RepositoryPolicy p2 )
    {
        if ( p1 == p2 )
        {
            return true;
        }
        // update policy doesn't affect contents
        return p1.isEnabled() == p2.isEnabled() && eq( p1.getChecksumPolicy(), p2.getChecksumPolicy() );
    }
3390#public static boolean repositoriesEquals( List<RemoteRepository> r1, List<RemoteRepository> r2 )
    {
        if ( r1.size() != r2.size() )
        {
            return false;
        }

        for ( Iterator<RemoteRepository> it1 = r1.iterator(), it2 = r2.iterator(); it1.hasNext(); )
        {
            if ( !repositoryEquals( it1.next(), it2.next() ) )
            {
                return false;
            }
        }

        return true;
    }
3391#public static int pluginHashCode( Plugin plugin )
    {
        int hash = 17;

        hash = hash * 31 + hash( plugin.getGroupId() );
        hash = hash * 31 + hash( plugin.getArtifactId() );
        hash = hash * 31 + hash( plugin.getVersion() );

        hash = hash * 31 + ( plugin.isExtensions() ? 1 : 0 );

        for ( Dependency dependency : plugin.getDependencies() )
        {
            hash = hash * 31 + hash( dependency.getGroupId() );
            hash = hash * 31 + hash( dependency.getArtifactId() );
            hash = hash * 31 + hash( dependency.getVersion() );
            hash = hash * 31 + hash( dependency.getType() );
            hash = hash * 31 + hash( dependency.getClassifier() );
            hash = hash * 31 + hash( dependency.getScope() );

            for ( Exclusion exclusion : dependency.getExclusions() )
            {
                hash = hash * 31 + hash( exclusion.getGroupId() );
                hash = hash * 31 + hash( exclusion.getArtifactId() );
            }
        }

        return hash;
    }
3392#public static boolean pluginEquals( Plugin a, Plugin b )
    {
        return eq( a.getArtifactId(), b.getArtifactId() ) //
            && eq( a.getGroupId(), b.getGroupId() ) //
            && eq( a.getVersion(), b.getVersion() ) // 
            && a.isExtensions() == b.isExtensions() //
            && dependenciesEquals( a.getDependencies(), b.getDependencies() );
    }
3393#private static boolean dependenciesEquals( List<Dependency> a, List<Dependency> b )
    {
        if ( a.size() != b.size() )
        {
            return false;
        }

        Iterator<Dependency> aI = a.iterator();
        Iterator<Dependency> bI = b.iterator();

        while ( aI.hasNext() )
        {
            Dependency aD = aI.next();
            Dependency bD = bI.next();

            boolean r = eq( aD.getGroupId(), bD.getGroupId() ) //
                && eq( aD.getArtifactId(), bD.getArtifactId() ) //
                && eq( aD.getVersion(), bD.getVersion() ) // 
                && eq( aD.getType(), bD.getType() ) //
                && eq( aD.getClassifier(), bD.getClassifier() ) //
                && eq( aD.getScope(), bD.getScope() );

            r &= exclusionsEquals( aD.getExclusions(), bD.getExclusions() );

            if ( !r )
            {
                return false;
            }
        }

        return true;
    }
3394#private static boolean exclusionsEquals( List<Exclusion> a, List<Exclusion> b )
    {
        if ( a.size() != b.size() )
        {
            return false;
        }

        Iterator<Exclusion> aI = a.iterator();
        Iterator<Exclusion> bI = b.iterator();

        while ( aI.hasNext() )
        {
            Exclusion aD = aI.next();
            Exclusion bD = bI.next();

            boolean r = eq( aD.getGroupId(), bD.getGroupId() ) //
                && eq( aD.getArtifactId(), bD.getArtifactId() );

            if ( !r )
            {
                return false;
            }
        }

        return true;
    }
3395#public static WorkspaceRepository getWorkspace( RepositorySystemSession session )
    {
        WorkspaceReader reader = session.getWorkspaceReader();
        return ( reader != null ) ? reader.getRepository() : null;
    }
3396#Key createKey( Plugin plugin, ClassLoader parentRealm, Map<String, ClassLoader> foreignImports,
                   DependencyFilter dependencyFilter, List<RemoteRepository> repositories,
                   RepositorySystemSession session );
3397#CacheRecord get( Key key );
3398#CacheRecord put( Key key, ClassRealm pluginRealm, List<Artifact> pluginArtifacts );
3399#void flush();
3400#/**
     * Registers the specified cache record for usage with the given project. Integrators can use the information
     * collected from this method in combination with a custom cache implementation to dispose unused records from the
     * cache.
     * 
     * @param project The project that employs the plugin realm, must not be {@code null}.
     * @param record The cache record being used for the project, must not be {@code null}.
     */
    void register( MavenProject project, CacheRecord record );
3401#public CacheRecord( ClassRealm realm, List<Artifact> artifacts )
        {
            this.realm = realm;
            this.artifacts = artifacts;
        }
3402#public PluginNotFoundException( Plugin plugin, ArtifactNotFoundException e )
    {
        super( "Plugin could not be found - check that the goal name is correct: " + e.getMessage(), e.getGroupId(),
               e.getArtifactId(), e.getVersion(), "maven-plugin", null, e.getRemoteRepositories(), null, e.getCause() );
        this.plugin = plugin;
    }
3403#public PluginNotFoundException( Plugin plugin, List<ArtifactRepository> remoteRepositories )
    {
        super( "Plugin could not be found, please check its coordinates for typos and ensure the required"
            + " plugin repositories are defined in the POM", plugin.getGroupId(), plugin.getArtifactId(),
               plugin.getVersion(), "maven-plugin", null, remoteRepositories, null );
        this.plugin = plugin;
    }
3404#public Plugin getPlugin()
    {
        return plugin;
    }
3405#/**
     * Retrieves the descriptor for the specified plugin from its main artifact.
     * 
     * @param plugin The plugin whose descriptor should be retrieved, must not be {@code null}.
     * @param repositories The plugin repositories to use for resolving the plugin's main artifact, must not be {@code
     *            null}.
     * @param session The repository session to use for resolving the plugin's main artifact, must not be {@code null}.
     * @return The plugin descriptor, never {@code null}.
     */
    PluginDescriptor getPluginDescriptor( Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session )
        throws PluginResolutionException, PluginDescriptorParsingException, InvalidPluginDescriptorException;
3406#/**
     * Retrieves the descriptor for the specified plugin goal from the plugin's main artifact.
     * 
     * @param plugin The plugin whose mojo descriptor should be retrieved, must not be {@code null}.
     * @param goal The simple name of the mojo whose descriptor should be retrieved, must not be {@code null}.
     * @param repositories The plugin repositories to use for resolving the plugin's main artifact, must not be {@code
     *            null}.
     * @param session The repository session to use for resolving the plugin's main artifact, must not be {@code null}.
     * @return The mojo descriptor, never {@code null}.
     */
    MojoDescriptor getMojoDescriptor( Plugin plugin, String goal, List<RemoteRepository> repositories,
                                      RepositorySystemSession session )
        throws MojoNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        InvalidPluginDescriptorException;
3407#/**
     * Verifies the specified plugin is compatible with the current Maven runtime.
     * 
     * @param pluginDescriptor The descriptor of the plugin to check, must not be {@code null}.
     */
    void checkRequiredMavenVersion( PluginDescriptor pluginDescriptor )
        throws PluginIncompatibleException;
3408#/**
     * Sets up the class realm for the specified plugin. Both the class realm and the plugin artifacts that constitute
     * it will be stored in the plugin descriptor.
     * 
     * @param pluginDescriptor The plugin descriptor in which to save the class realm and the plugin artifacts, must not
     *            be {@code null}.
     * @param session The build session from which to pick the current project and repository settings, must not be
     *            {@code null}.
     * @param parent The parent class realm for the plugin, may be {@code null} to use the Maven core realm.
     * @param imports The packages/types to import from the parent realm, may be {@code null}.
     * @param filter The filter used to exclude certain plugin dependencies, may be {@code null}.
     */
    void setupPluginRealm( PluginDescriptor pluginDescriptor, MavenSession session, ClassLoader parent,
                           List<String> imports, DependencyFilter filter )
        throws PluginResolutionException, PluginContainerException;
3409#/**
     * Looks up the mojo for the specified mojo execution and populates its parameters from the configuration given by
     * the mojo execution. The mojo/plugin descriptor associated with the mojo execution provides the class realm to
     * lookup the mojo from. <strong>Warning:</strong> The returned mojo instance must be released via
     * {@link #releaseMojo(Object, MojoExecution)} when the mojo is no longer needed to free any resources allocated for
     * it.
     * 
     * @param mojoInterface The component role of the mojo, must not be {@code null}.
     * @param session The build session in whose context the mojo will be used, must not be {@code null}.
     * @param mojoExecution The mojo execution to retrieve the mojo for, must not be {@code null}.
     * @return The ready-to-execute mojo, never {@code null}.
     */
    <T> T getConfiguredMojo( Class<T> mojoInterface, MavenSession session, MojoExecution mojoExecution )
        throws PluginConfigurationException, PluginContainerException;
3410#/**
     * Releases the specified mojo back to the container.
     * 
     * @param mojo The mojo to release, may be {@code null}.
     * @param mojoExecution The mojo execution the mojo was originally retrieved for, must not be {@code null}.
     */
    void releaseMojo( Object mojo, MojoExecution mojoExecution );
3411#public PluginConfigurationException( PluginDescriptor pluginDescriptor, String originalMessage )
    {
        super( originalMessage );
        this.pluginDescriptor = pluginDescriptor;
        this.originalMessage = originalMessage;
    }
3412#public PluginConfigurationException( PluginDescriptor pluginDescriptor, String originalMessage, Throwable cause )
    {
        super( originalMessage, cause );
        this.pluginDescriptor = pluginDescriptor;
        this.originalMessage = originalMessage;
    }
3413#public PluginConfigurationException( PluginDescriptor pluginDescriptor, String originalMessage,
                                         ExpressionEvaluationException cause )
    {
        super( originalMessage, cause );
        this.pluginDescriptor = pluginDescriptor;
        this.originalMessage = originalMessage;
    }
3414#public PluginConfigurationException( PluginDescriptor pluginDescriptor, String originalMessage,
                                         ComponentConfigurationException cause )
    {
        super( originalMessage, cause );
        this.pluginDescriptor = pluginDescriptor;
        this.originalMessage = originalMessage;
    }
3415#public PluginConfigurationException( PluginDescriptor pluginDescriptor, String originalMessage,
                                         ComponentLookupException cause )
    {
        super( originalMessage, cause );
        this.pluginDescriptor = pluginDescriptor;
        this.originalMessage = originalMessage;
    }
3416#public CacheRecord get( List<? extends Artifact> extensionArtifacts )
    {
        return cache.get( new CacheKey( extensionArtifacts ) );
    }
3417#public CacheRecord put( List<? extends Artifact> extensionArtifacts, ClassRealm extensionRealm,
                            ExtensionDescriptor extensionDescriptor )
    {
        if ( extensionRealm == null )
        {
            throw new NullPointerException();
        }

        CacheKey key = new CacheKey( extensionArtifacts );

        if ( cache.containsKey( key ) )
        {
            throw new IllegalStateException( "Duplicate extension realm for extension " + extensionArtifacts );
        }

        CacheRecord record = new CacheRecord( extensionRealm, extensionDescriptor );

        cache.put( key, record );

        return record;
    }
3418#public void flush()
    {
        cache.clear();
    }
3419#public void register( MavenProject project, CacheRecord record )
    {
        // default cache does not track extension usage
    }
3420#public CacheKey( List<? extends Artifact> extensionArtifacts )
        {
            this.files = new ArrayList<File>( extensionArtifacts.size() );
            this.timestamps = new ArrayList<Long>( extensionArtifacts.size() );
            this.sizes = new ArrayList<Long>( extensionArtifacts.size() );
            this.ids = new ArrayList<String>( extensionArtifacts.size() );

            for ( Artifact artifact : extensionArtifacts )
            {
                File file = artifact.getFile();
                files.add( file );
                timestamps.add( ( file != null ) ? Long.valueOf( file.lastModified() ) : Long.valueOf( 0 ) );
                sizes.add( ( file != null ) ? Long.valueOf( file.length() ) : Long.valueOf( 0 ) );
                ids.add( artifact.getVersion() );
            }

            this.hashCode =
                31 * files.hashCode() + 31 * ids.hashCode() + 31 * timestamps.hashCode() + 31 * sizes.hashCode();
        }
3421#@Override
        public int hashCode()
        {
            return hashCode;
        }
3422#@Override
        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return ids.equals( other.ids ) && files.equals( other.files ) && timestamps.equals( other.timestamps )
                && sizes.equals( other.sizes );
        }
3423#public PluginDescriptorParsingException( Plugin plugin, String descriptorLocation, Throwable e )
    {
        super( createMessage( plugin, descriptorLocation, e ), e );
    }
3424#private static String createMessage( Plugin plugin, String descriptorLocation, Throwable e )
    {
        String message = "Failed to parse plugin descriptor";

        if ( plugin != null )
        {
            message += " for " + plugin.getId();
        }

        if ( descriptorLocation != null )
        {
            message += " (" + descriptorLocation + ")";
        }

        if ( e != null )
        {
            message += ": " + e.getMessage();
        }

        return message;
    }
3425#private Artifact toArtifact( Plugin plugin, RepositorySystemSession session )
    {
        return new DefaultArtifact( plugin.getGroupId(), plugin.getArtifactId(), null, "jar", plugin.getVersion(),
                                    session.getArtifactTypeRegistry().get( "maven-plugin" ) );
    }
3426#public Artifact resolve( Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session )
        throws PluginResolutionException
    {
        RequestTrace trace = DefaultRequestTrace.newChild( null, plugin );

        Artifact pluginArtifact = toArtifact( plugin, session );

        try
        {
            RepositorySystemSession pluginSession = new FilterRepositorySystemSession( session )
            {
                @Override
                public boolean isIgnoreMissingArtifactDescriptor()
                {
                    return false;
                }
            };

            ArtifactDescriptorRequest request =
                new ArtifactDescriptorRequest( pluginArtifact, repositories, REPOSITORY_CONTEXT );
            request.setTrace( trace );
            ArtifactDescriptorResult result = repoSystem.readArtifactDescriptor( pluginSession, request );

            pluginArtifact = result.getArtifact();

            String requiredMavenVersion = (String) result.getProperties().get( "prerequisites.maven" );
            if ( requiredMavenVersion != null )
            {
                Map<String, String> props = new LinkedHashMap<String, String>( pluginArtifact.getProperties() );
                props.put( "requiredMavenVersion", requiredMavenVersion );
                pluginArtifact = pluginArtifact.setProperties( props );
            }
        }
        catch ( ArtifactDescriptorException e )
        {
            throw new PluginResolutionException( plugin, e );
        }

        try
        {
            ArtifactRequest request = new ArtifactRequest( pluginArtifact, repositories, REPOSITORY_CONTEXT );
            request.setTrace( trace );
            pluginArtifact = repoSystem.resolveArtifact( session, request ).getArtifact();
        }
        catch ( ArtifactResolutionException e )
        {
            throw new PluginResolutionException( plugin, e );
        }

        return pluginArtifact;
    }
3427#public DependencyNode resolve( Plugin plugin, Artifact pluginArtifact, DependencyFilter dependencyFilter,
                                   List<RemoteRepository> repositories, RepositorySystemSession session )
        throws PluginResolutionException
    {
        RequestTrace trace = DefaultRequestTrace.newChild( null, plugin );

        if ( pluginArtifact == null )
        {
            pluginArtifact = toArtifact( plugin, session );
        }

        DependencyFilter collectionFilter = new ScopeDependencyFilter( "provided", "test" );

        DependencyFilter resolutionFilter =
            new ExclusionsDependencyFilter( artifactFilterManager.getCoreArtifactExcludes() );
        resolutionFilter = AndDependencyFilter.newInstance( resolutionFilter, dependencyFilter );
        resolutionFilter = new AndDependencyFilter( collectionFilter, resolutionFilter );

        DependencyNode node;

        try
        {
            DependencySelector selector =
                AndDependencySelector.newInstance( session.getDependencySelector(), new WagonExcluder() );

            DependencyGraphTransformer transformer =
                ChainedDependencyGraphTransformer.newInstance( session.getDependencyGraphTransformer(),
                                                               new PlexusUtilsInjector() );

            DefaultRepositorySystemSession pluginSession = new DefaultRepositorySystemSession( session );
            pluginSession.setDependencySelector( selector );
            pluginSession.setDependencyGraphTransformer( transformer );

            CollectRequest request = new CollectRequest();
            request.setRequestContext( REPOSITORY_CONTEXT );
            request.setRepositories( repositories );
            request.setRoot( new org.sonatype.aether.graph.Dependency( pluginArtifact, null ) );
            for ( Dependency dependency : plugin.getDependencies() )
            {
                org.sonatype.aether.graph.Dependency pluginDep =
                    RepositoryUtils.toDependency( dependency, session.getArtifactTypeRegistry() );
                if ( !JavaScopes.SYSTEM.equals( pluginDep.getScope() ) )
                {
                    pluginDep = pluginDep.setScope( JavaScopes.RUNTIME );
                }
                request.addDependency( pluginDep );
            }

            DependencyRequest depRequest = new DependencyRequest( request, resolutionFilter );
            depRequest.setTrace( trace );

            request.setTrace( DefaultRequestTrace.newChild( trace, depRequest ) );

            node = repoSystem.collectDependencies( pluginSession, request ).getRoot();

            if ( logger.isDebugEnabled() )
            {
                node.accept( new GraphLogger() );
            }

            depRequest.setRoot( node );
            repoSystem.resolveDependencies( session, depRequest );
        }
        catch ( DependencyCollectionException e )
        {
            throw new PluginResolutionException( plugin, e );
        }
        catch ( DependencyResolutionException e )
        {
            throw new PluginResolutionException( plugin, e.getCause() );
        }

        return node;
    }
3428#public boolean visitEnter( DependencyNode node )
        {
            StringBuilder buffer = new StringBuilder( 128 );
            buffer.append( indent );
            org.sonatype.aether.graph.Dependency dep = node.getDependency();
            if ( dep != null )
            {
                org.sonatype.aether.artifact.Artifact art = dep.getArtifact();

                buffer.append( art );
                buffer.append( ':' ).append( dep.getScope() );

                if ( node.getPremanagedScope() != null && !node.getPremanagedScope().equals( dep.getScope() ) )
                {
                    buffer.append( " (scope managed from " ).append( node.getPremanagedScope() ).append( ")" );
                }

                if ( node.getPremanagedVersion() != null && !node.getPremanagedVersion().equals( art.getVersion() ) )
                {
                    buffer.append( " (version managed from " ).append( node.getPremanagedVersion() ).append( ")" );
                }
            }

            logger.debug( buffer.toString() );
            indent += "   ";
            return true;
        }
3429#public boolean visitLeave( DependencyNode node )
        {
            indent = indent.substring( 0, indent.length() - 3 );
            return true;
        }
3430#public WagonExcluder()
    {
        this( false );
    }
3431#private WagonExcluder( boolean coreArtifact )
    {
        this.coreArtifact = coreArtifact;
    }
3432#public boolean selectDependency( Dependency dependency )
    {
        return !coreArtifact || !isWagonProvider( dependency.getArtifact() );
    }
3433#public DependencySelector deriveChildSelector( DependencyCollectionContext context )
    {
        if ( coreArtifact || !isLegacyCoreArtifact( context.getDependency().getArtifact() ) )
        {
            return this;
        }
        else
        {
            return new WagonExcluder( true );
        }
    }
3434#private boolean isLegacyCoreArtifact( Artifact artifact )
    {
        String version = artifact.getVersion();
        return version != null && version.startsWith( "2." ) && artifact.getArtifactId().startsWith( "maven-" )
            && artifact.getGroupId().equals( "org.apache.maven" );
    }
3435#private boolean isWagonProvider( Artifact artifact )
    {
        if ( "org.apache.maven.wagon".equals( artifact.getGroupId() ) )
        {
            return artifact.getArtifactId().startsWith( "wagon-" );
        }
        return false;
    }
3436#@Override
    public boolean equals( Object obj )
    {
        if ( obj == this )
        {
            return true;
        }
        else if ( obj == null || !getClass().equals( obj.getClass() ) )
        {
            return false;
        }

        WagonExcluder that = (WagonExcluder) obj;
        return coreArtifact == that.coreArtifact;
    }
3437#@Override
    public int hashCode()
    {
        int hash = getClass().hashCode();
        hash = hash * 31 + ( coreArtifact ? 1 : 0 );
        return hash;
    }
3438#public void setSession( MavenSession session )
    {
        if ( session == null )
        {
            MavenSession[] oldSession = DefaultLegacySupport.session.get();
            if ( oldSession != null )
            {
                oldSession[0] = null;
                DefaultLegacySupport.session.remove();
            }
        }
        else
        {
            DefaultLegacySupport.session.set( new MavenSession[] { session } );
        }
    }
3439#public MavenSession getSession()
    {
        MavenSession[] currentSession = DefaultLegacySupport.session.get();
        return currentSession != null ? currentSession[0] : null;
    }
3440#public RepositorySystemSession getRepositorySession()
    {
        MavenSession session = getSession();
        return ( session != null ) ? session.getRepositorySession() : null;
    }
3441#public ValidatingConfigurationListener( Object mojo, MojoDescriptor mojoDescriptor, ConfigurationListener delegate )
    {
        this.mojo = mojo;
        this.delegate = delegate;
        this.missingParameters = new HashMap<String, Parameter>();

        if ( mojoDescriptor.getParameters() != null )
        {
            for ( Parameter param : mojoDescriptor.getParameters() )
            {
                if ( param.isRequired() )
                {
                    missingParameters.put( param.getName(), param );
                }
            }
        }
    }
3442#public Collection<Parameter> getMissingParameters()
    {
        return missingParameters.values();
    }
3443#public void notifyFieldChangeUsingSetter( String fieldName, Object value, Object target )
    {
        delegate.notifyFieldChangeUsingSetter( fieldName, value, target );

        if ( mojo == target )
        {
            notify( fieldName, value );
        }
    }
3444#public void notifyFieldChangeUsingReflection( String fieldName, Object value, Object target )
    {
        delegate.notifyFieldChangeUsingReflection( fieldName, value, target );

        if ( mojo == target )
        {
            notify( fieldName, value );
        }
    }
3445#private void notify( String fieldName, Object value )
    {
        if ( value != null )
        {
            missingParameters.remove( fieldName );
        }
    }
3446#public void executeMojo( MavenProject project, MojoExecution execution, MavenSession session )
        throws MojoExecutionException, ArtifactResolutionException, MojoFailureException, ArtifactNotFoundException,
        InvalidDependencyVersionException, PluginManagerException, PluginConfigurationException
    {
        throw new UnsupportedOperationException();
    }
3447#public Object getPluginComponent( Plugin plugin, String role, String roleHint )
        throws PluginManagerException, ComponentLookupException
    {
        MavenSession session = legacySupport.getSession();

        PluginDescriptor pluginDescriptor;
        try
        {
            pluginDescriptor =
                pluginManager.getPluginDescriptor( plugin, session.getCurrentProject().getRemotePluginRepositories(),
                                                   session.getRepositorySession() );

            pluginManager.setupPluginRealm( pluginDescriptor, session, null, null, null );
        }
        catch ( Exception e )
        {
            throw new PluginManagerException( plugin, e.getMessage(), e );
        }

        ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
        try
        {
            Thread.currentThread().setContextClassLoader( pluginDescriptor.getClassRealm() );

            return container.lookup( role, roleHint );
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( oldClassLoader );
        }
    }
3448#public Map getPluginComponents( Plugin plugin, String role )
        throws ComponentLookupException, PluginManagerException
    {
        MavenSession session = legacySupport.getSession();

        PluginDescriptor pluginDescriptor;
        try
        {
            pluginDescriptor =
                pluginManager.getPluginDescriptor( plugin, session.getCurrentProject().getRemotePluginRepositories(),
                                                   session.getRepositorySession() );

            pluginManager.setupPluginRealm( pluginDescriptor, session, null, null, null );
        }
        catch ( Exception e )
        {
            throw new PluginManagerException( plugin, e.getMessage(), e );
        }

        ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
        try
        {
            Thread.currentThread().setContextClassLoader( pluginDescriptor.getClassRealm() );

            return container.lookupMap( role );
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( oldClassLoader );
        }
    }
3449#public Plugin getPluginDefinitionForPrefix( String prefix, MavenSession session, MavenProject project )
    {
        PluginPrefixRequest request = new DefaultPluginPrefixRequest( prefix, session );
        request.setPom( project.getModel() );

        try
        {
            PluginPrefixResult result = pluginPrefixResolver.resolve( request );

            Plugin plugin = new Plugin();
            plugin.setGroupId( result.getGroupId() );
            plugin.setArtifactId( result.getArtifactId() );

            return plugin;
        }
        catch ( NoPluginFoundForPrefixException e )
        {
            return null;
        }
    }
3450#public PluginDescriptor getPluginDescriptorForPrefix( String prefix )
    {
        MavenSession session = legacySupport.getSession();

        PluginPrefixRequest request = new DefaultPluginPrefixRequest( prefix, session );

        try
        {
            PluginPrefixResult result = pluginPrefixResolver.resolve( request );

            Plugin plugin = new Plugin();
            plugin.setGroupId( result.getGroupId() );
            plugin.setArtifactId( result.getArtifactId() );

            return loadPluginDescriptor( plugin, session.getCurrentProject(), session );
        }
        catch ( Exception e )
        {
            return null;
        }
    }
3451#public PluginDescriptor loadPluginDescriptor( Plugin plugin, MavenProject project, MavenSession session )
        throws ArtifactResolutionException, PluginVersionResolutionException, ArtifactNotFoundException,
        InvalidVersionSpecificationException, InvalidPluginException, PluginManagerException, PluginNotFoundException,
        PluginVersionNotFoundException
    {
        return verifyPlugin( plugin, project, session.getSettings(), session.getLocalRepository() );
    }
3452#public PluginDescriptor loadPluginFully( Plugin plugin, MavenProject project, MavenSession session )
        throws ArtifactResolutionException, PluginVersionResolutionException, ArtifactNotFoundException,
        InvalidVersionSpecificationException, InvalidPluginException, PluginManagerException, PluginNotFoundException,
        PluginVersionNotFoundException
    {
        PluginDescriptor pluginDescriptor = loadPluginDescriptor( plugin, project, session );

        try
        {
            pluginManager.setupPluginRealm( pluginDescriptor, session, null, null, null );
        }
        catch ( PluginResolutionException e )
        {
            throw new PluginManagerException( plugin, e.getMessage(), e );
        }

        return pluginDescriptor;
    }
3453#public PluginDescriptor verifyPlugin( Plugin plugin, MavenProject project, Settings settings,
                                          ArtifactRepository localRepository )
        throws ArtifactResolutionException, PluginVersionResolutionException, ArtifactNotFoundException,
        InvalidVersionSpecificationException, InvalidPluginException, PluginManagerException, PluginNotFoundException,
        PluginVersionNotFoundException
    {
        MavenSession session = legacySupport.getSession();

        if ( plugin.getVersion() == null )
        {
            PluginVersionRequest versionRequest =
                new DefaultPluginVersionRequest( plugin, session.getRepositorySession(),
                                                 project.getRemotePluginRepositories() );
            plugin.setVersion( pluginVersionResolver.resolve( versionRequest ).getVersion() );
        }

        try
        {
            return pluginManager.getPluginDescriptor( plugin, project.getRemotePluginRepositories(),
                                                      session.getRepositorySession() );
        }
        catch ( PluginResolutionException e )
        {
            throw new PluginNotFoundException( plugin, project.getPluginArtifactRepositories() );
        }
        catch ( PluginDescriptorParsingException e )
        {
            throw new PluginManagerException( plugin, e.getMessage(), e );
        }
        catch ( InvalidPluginDescriptorException e )
        {
            throw new PluginManagerException( plugin, e.getMessage(), e );
        }
    }
3454#public DependencyNode transformGraph( DependencyNode node, DependencyGraphTransformationContext context )
        throws RepositoryException
    {
        if ( findPlexusUtils( node ) == null )
        {
            Artifact pu = new DefaultArtifact( GID, AID, null, EXT, VER );
            DefaultDependencyNode child = new DefaultDependencyNode( new Dependency( pu, JavaScopes.RUNTIME ) );
            child.setRepositories( node.getRepositories() );
            child.setRequestContext( node.getRequestContext() );
            node.getChildren().add( child );
        }

        return node;
    }
3455#private DependencyNode findPlexusUtils( DependencyNode node )
    {
        Artifact artifact = node.getDependency().getArtifact();

        if ( AID.equals( artifact.getArtifactId() ) && GID.equals( artifact.getGroupId() )
            && EXT.equals( artifact.getExtension() ) && "".equals( artifact.getClassifier() ) )
        {
            return node;
        }

        for ( DependencyNode child : node.getChildren() )
        {
            DependencyNode result = findPlexusUtils( child );
            if ( result != null )
            {
                return result;
            }
        }

        return null;
    }
3456#/**
     * Resolves the main artifact of the specified plugin.
     * 
     * @param plugin The plugin for which to resolve the main artifact, must not be {@code null}.
     * @param repositories The plugin repositories to use for resolving the plugin's main artifact, must not be {@code
     *            null}.
     * @param session The repository session to use for resolving the plugin's main artifact, must not be {@code null}.
     * @return The resolved plugin artifact, never {@code null}.
     * @throws PluginResolutionException If the plugin artifact could not be resolved.
     */
    public Artifact resolve( Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session )
        throws PluginResolutionException;
3457#/**
     * Resolves the runtime dependencies of the specified plugin.
     * 
     * @param plugin The plugin for which to resolve the dependencies, must not be {@code null}.
     * @param pluginArtifact The plugin's main artifact, may be {@code null}.
     * @param dependencyFilter A filter to exclude artifacts from resolution (but not collection), may be {@code null}.
     * @param repositories The plugin repositories to use for resolving the plugin artifacts, must not be {@code null}.
     * @param session The repository session to use for resolving the plugin artifacts, must not be {@code null}.
     * @return The dependency tree denoting the resolved plugin class path, never {@code null}.
     * @throws PluginResolutionException If any dependency could not be resolved.
     */
    DependencyNode resolve( Plugin plugin, Artifact pluginArtifact, DependencyFilter dependencyFilter,
                            List<RemoteRepository> repositories, RepositorySystemSession session )
        throws PluginResolutionException;
3458#public synchronized PluginDescriptor getPluginDescriptor( Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session )
        throws PluginResolutionException, PluginDescriptorParsingException, InvalidPluginDescriptorException
    {
        PluginDescriptorCache.Key cacheKey = pluginDescriptorCache.createKey( plugin, repositories, session );

        PluginDescriptor pluginDescriptor = pluginDescriptorCache.get( cacheKey );

        if ( pluginDescriptor == null )
        {
            org.sonatype.aether.artifact.Artifact artifact =
                pluginDependenciesResolver.resolve( plugin, repositories, session );

            Artifact pluginArtifact = RepositoryUtils.toArtifact( artifact );

            pluginDescriptor = extractPluginDescriptor( pluginArtifact, plugin );

            pluginDescriptor.setRequiredMavenVersion( artifact.getProperty( "requiredMavenVersion", null ) );

            pluginDescriptorCache.put( cacheKey, pluginDescriptor );
        }

        pluginDescriptor.setPlugin( plugin );

        return pluginDescriptor;
    }
3459#private PluginDescriptor extractPluginDescriptor( Artifact pluginArtifact, Plugin plugin )
        throws PluginDescriptorParsingException, InvalidPluginDescriptorException
    {
        PluginDescriptor pluginDescriptor = null;

        File pluginFile = pluginArtifact.getFile();

        try
        {
            if ( pluginFile.isFile() )
            {
                JarFile pluginJar = new JarFile( pluginFile, false );
                try
                {
                    ZipEntry pluginDescriptorEntry = pluginJar.getEntry( getPluginDescriptorLocation() );

                    if ( pluginDescriptorEntry != null )
                    {
                        InputStream is = pluginJar.getInputStream( pluginDescriptorEntry );

                        pluginDescriptor = parsePluginDescriptor( is, plugin, pluginFile.getAbsolutePath() );
                    }
                }
                finally
                {
                    pluginJar.close();
                }
            }
            else
            {
                File pluginXml = new File( pluginFile, getPluginDescriptorLocation() );

                if ( pluginXml.isFile() )
                {
                    InputStream is = new BufferedInputStream( new FileInputStream( pluginXml ) );
                    try
                    {
                        pluginDescriptor = parsePluginDescriptor( is, plugin, pluginXml.getAbsolutePath() );
                    }
                    finally
                    {
                        IOUtil.close( is );
                    }
                }
            }

            if ( pluginDescriptor == null )
            {
                throw new IOException( "No plugin descriptor found at " + getPluginDescriptorLocation() );
            }
        }
        catch ( IOException e )
        {
            throw new PluginDescriptorParsingException( plugin, pluginFile.getAbsolutePath(), e );
        }

        MavenPluginValidator validator = new MavenPluginValidator( pluginArtifact );

        validator.validate( pluginDescriptor );

        if ( validator.hasErrors() )
        {
            throw new InvalidPluginDescriptorException( "Invalid plugin descriptor for " + plugin.getId() + " ("
                + pluginFile + ")", validator.getErrors() );
        }

        pluginDescriptor.setPluginArtifact( pluginArtifact );

        return pluginDescriptor;
    }
3460#private String getPluginDescriptorLocation()
    {
        return "META-INF/maven/plugin.xml";
    }
3461#private PluginDescriptor parsePluginDescriptor( InputStream is, Plugin plugin, String descriptorLocation )
        throws PluginDescriptorParsingException
    {
        try
        {
            Reader reader = ReaderFactory.newXmlReader( is );

            PluginDescriptor pluginDescriptor = builder.build( reader, descriptorLocation );

            return pluginDescriptor;
        }
        catch ( IOException e )
        {
            throw new PluginDescriptorParsingException( plugin, descriptorLocation, e );
        }
        catch ( PlexusConfigurationException e )
        {
            throw new PluginDescriptorParsingException( plugin, descriptorLocation, e );
        }
    }
3462#public MojoDescriptor getMojoDescriptor( Plugin plugin, String goal, List<RemoteRepository> repositories,
                                             RepositorySystemSession session )
        throws MojoNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        InvalidPluginDescriptorException
    {
        PluginDescriptor pluginDescriptor = getPluginDescriptor( plugin, repositories, session );

        MojoDescriptor mojoDescriptor = pluginDescriptor.getMojo( goal );

        if ( mojoDescriptor == null )
        {
            throw new MojoNotFoundException( goal, pluginDescriptor );
        }

        return mojoDescriptor;
    }
3463#public void checkRequiredMavenVersion( PluginDescriptor pluginDescriptor )
        throws PluginIncompatibleException
    {
        String requiredMavenVersion = pluginDescriptor.getRequiredMavenVersion();
        if ( StringUtils.isNotBlank( requiredMavenVersion ) )
        {
            try
            {
                if ( !runtimeInformation.isMavenVersion( requiredMavenVersion ) )
                {
                    throw new PluginIncompatibleException( pluginDescriptor.getPlugin(), "The plugin "
                        + pluginDescriptor.getId() + " requires Maven version " + requiredMavenVersion );
                }
            }
            catch ( RuntimeException e )
            {
                logger.warn( "Could not verify plugin's Maven prerequisite: " + e.getMessage() );
            }
        }
    }
3464#public synchronized void setupPluginRealm( PluginDescriptor pluginDescriptor, MavenSession session,
                                               ClassLoader parent, List<String> imports, DependencyFilter filter )
        throws PluginResolutionException, PluginContainerException
    {
        Plugin plugin = pluginDescriptor.getPlugin();

        MavenProject project = session.getCurrentProject();

        Map<String, ClassLoader> foreignImports = calcImports( project, parent, imports );

        PluginRealmCache.Key cacheKey =
            pluginRealmCache.createKey( plugin, parent, foreignImports, filter, project.getRemotePluginRepositories(),
                                        session.getRepositorySession() );

        PluginRealmCache.CacheRecord cacheRecord = pluginRealmCache.get( cacheKey );

        if ( cacheRecord != null )
        {
            pluginDescriptor.setClassRealm( cacheRecord.realm );
            pluginDescriptor.setArtifacts( new ArrayList<Artifact>( cacheRecord.artifacts ) );
            for ( ComponentDescriptor<?> componentDescriptor : pluginDescriptor.getComponents() )
            {
                componentDescriptor.setRealm( cacheRecord.realm );
            }
        }
        else
        {
            createPluginRealm( pluginDescriptor, session, parent, foreignImports, filter );

            cacheRecord =
                pluginRealmCache.put( cacheKey, pluginDescriptor.getClassRealm(), pluginDescriptor.getArtifacts() );
        }

        pluginRealmCache.register( project, cacheRecord );
    }
3465#private void createPluginRealm( PluginDescriptor pluginDescriptor, MavenSession session, ClassLoader parent,
                                    Map<String, ClassLoader> foreignImports, DependencyFilter filter )
        throws PluginResolutionException, PluginContainerException
    {
        Plugin plugin = pluginDescriptor.getPlugin();

        if ( plugin == null )
        {
            throw new IllegalArgumentException( "incomplete plugin descriptor, plugin missing" );
        }

        Artifact pluginArtifact = pluginDescriptor.getPluginArtifact();

        if ( pluginArtifact == null )
        {
            throw new IllegalArgumentException( "incomplete plugin descriptor, plugin artifact missing" );
        }

        MavenProject project = session.getCurrentProject();

        DependencyFilter dependencyFilter = project.getExtensionDependencyFilter();
        dependencyFilter = AndDependencyFilter.newInstance( dependencyFilter, filter );

        DependencyNode root =
            pluginDependenciesResolver.resolve( plugin, RepositoryUtils.toArtifact( pluginArtifact ), dependencyFilter,
                                                project.getRemotePluginRepositories(), session.getRepositorySession() );

        PreorderNodeListGenerator nlg = new PreorderNodeListGenerator();
        root.accept( nlg );

        List<Artifact> exposedPluginArtifacts = new ArrayList<Artifact>( nlg.getNodes().size() );
        RepositoryUtils.toArtifacts( exposedPluginArtifacts, Collections.singleton( root ),
                                     Collections.<String> emptyList(), null );
        for ( Iterator<Artifact> it = exposedPluginArtifacts.iterator(); it.hasNext(); )
        {
            Artifact artifact = it.next();
            if ( artifact.getFile() == null )
            {
                it.remove();
            }
        }

        List<org.sonatype.aether.artifact.Artifact> pluginArtifacts = nlg.getArtifacts( true );

        ClassRealm pluginRealm =
            classRealmManager.createPluginRealm( plugin, parent, null, foreignImports, pluginArtifacts );

        pluginDescriptor.setClassRealm( pluginRealm );
        pluginDescriptor.setArtifacts( exposedPluginArtifacts );

        try
        {
            for ( ComponentDescriptor<?> componentDescriptor : pluginDescriptor.getComponents() )
            {
                componentDescriptor.setRealm( pluginRealm );
                container.addComponentDescriptor( componentDescriptor );
            }

            container.discoverComponents( pluginRealm );
        }
        catch ( PlexusConfigurationException e )
        {
            throw new PluginContainerException( plugin, pluginRealm, "Error in component graph of plugin "
                + plugin.getId() + ": " + e.getMessage(), e );
        }
        catch ( CycleDetectedInComponentGraphException e )
        {
            throw new PluginContainerException( plugin, pluginRealm, "Error in component graph of plugin "
                + plugin.getId() + ": " + e.getMessage(), e );
        }
    }
3466#private Map<String, ClassLoader> calcImports( MavenProject project, ClassLoader parent, List<String> imports )
    {
        Map<String, ClassLoader> foreignImports = new HashMap<String, ClassLoader>();

        ClassLoader projectRealm = project.getClassRealm();
        if ( projectRealm != null )
        {
            foreignImports.put( "", projectRealm );
        }
        else
        {
            foreignImports.put( "", classRealmManager.getMavenApiRealm() );
        }

        if ( parent != null && imports != null )
        {
            for ( String parentImport : imports )
            {
                foreignImports.put( parentImport, parent );
            }
        }

        return foreignImports;
    }
3467#public <T> T getConfiguredMojo( Class<T> mojoInterface, MavenSession session, MojoExecution mojoExecution )
        throws PluginConfigurationException, PluginContainerException
    {
        MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();

        PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();

        ClassRealm pluginRealm = pluginDescriptor.getClassRealm();

        if ( logger.isDebugEnabled() )
        {
            logger.debug( "Configuring mojo " + mojoDescriptor.getId() + " from plugin realm " + pluginRealm );
        }

        // We are forcing the use of the plugin realm for all lookups that might occur during
        // the lifecycle that is part of the lookup. Here we are specifically trying to keep
        // lookups that occur in contextualize calls in line with the right realm.
        ClassRealm oldLookupRealm = container.setLookupRealm( pluginRealm );

        ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader( pluginRealm );

        try
        {
            T mojo;

            try
            {
                mojo = container.lookup( mojoInterface, mojoDescriptor.getRoleHint() );
            }
            catch ( ComponentLookupException e )
            {
                Throwable cause = e.getCause();
                while ( cause != null && !( cause instanceof LinkageError )
                    && !( cause instanceof ClassNotFoundException ) )
                {
                    cause = cause.getCause();
                }

                if ( ( cause instanceof NoClassDefFoundError ) || ( cause instanceof ClassNotFoundException ) )
                {
                    ByteArrayOutputStream os = new ByteArrayOutputStream( 1024 );
                    PrintStream ps = new PrintStream( os );
                    ps.println( "Unable to load the mojo '" + mojoDescriptor.getGoal() + "' in the plugin '"
                        + pluginDescriptor.getId() + "'. A required class is missing: " + cause.getMessage() );
                    pluginRealm.display( ps );

                    throw new PluginContainerException( mojoDescriptor, pluginRealm, os.toString(), cause );
                }
                else if ( cause instanceof LinkageError )
                {
                    ByteArrayOutputStream os = new ByteArrayOutputStream( 1024 );
                    PrintStream ps = new PrintStream( os );
                    ps.println( "Unable to load the mojo '" + mojoDescriptor.getGoal() + "' in the plugin '"
                        + pluginDescriptor.getId() + "' due to an API incompatibility: " + e.getClass().getName()
                        + ": " + cause.getMessage() );
                    pluginRealm.display( ps );

                    throw new PluginContainerException( mojoDescriptor, pluginRealm, os.toString(), cause );
                }

                throw new PluginContainerException( mojoDescriptor, pluginRealm, "Unable to load the mojo '"
                    + mojoDescriptor.getGoal() + "' (or one of its required components) from the plugin '"
                    + pluginDescriptor.getId() + "'", e );
            }

            if ( mojo instanceof ContextEnabled )
            {
                MavenProject project = session.getCurrentProject();

                Map<String, Object> pluginContext = session.getPluginContext( pluginDescriptor, project );

                if ( pluginContext != null )
                {
                    pluginContext.put( "project", project );

                    pluginContext.put( "pluginDescriptor", pluginDescriptor );

                    ( (ContextEnabled) mojo ).setPluginContext( pluginContext );
                }
            }

            if ( mojo instanceof Mojo )
            {
                ( (Mojo) mojo ).setLog( new DefaultLog( logger ) );
            }

            Xpp3Dom dom = mojoExecution.getConfiguration();

            PlexusConfiguration pomConfiguration;

            if ( dom == null )
            {
                pomConfiguration = new XmlPlexusConfiguration( "configuration" );
            }
            else
            {
                pomConfiguration = new XmlPlexusConfiguration( dom );
            }

            ExpressionEvaluator expressionEvaluator = new PluginParameterExpressionEvaluator( session, mojoExecution );

            populatePluginFields( mojo, mojoDescriptor, pluginRealm, pomConfiguration, expressionEvaluator );

            return mojo;
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( oldClassLoader );
            container.setLookupRealm( oldLookupRealm );
        }
    }
3468#private void populatePluginFields( Object mojo, MojoDescriptor mojoDescriptor, ClassRealm pluginRealm,
                                       PlexusConfiguration configuration, ExpressionEvaluator expressionEvaluator )
        throws PluginConfigurationException
    {
        ComponentConfigurator configurator = null;

        String configuratorId = mojoDescriptor.getComponentConfigurator();

        if ( StringUtils.isEmpty( configuratorId ) )
        {
            configuratorId = "basic";
        }

        try
        {
            // TODO: could the configuration be passed to lookup and the configurator known to plexus via the descriptor
            // so that this method could entirely be handled by a plexus lookup?
            configurator = container.lookup( ComponentConfigurator.class, configuratorId );

            ConfigurationListener listener = new DebugConfigurationListener( logger );

            ValidatingConfigurationListener validator =
                new ValidatingConfigurationListener( mojo, mojoDescriptor, listener );

            logger.debug( "Configuring mojo '" + mojoDescriptor.getId() + "' with " + configuratorId
                + " configurator -->" );

            configurator.configureComponent( mojo, configuration, expressionEvaluator, pluginRealm, validator );

            logger.debug( "-- end configuration --" );

            Collection<Parameter> missingParameters = validator.getMissingParameters();
            if ( !missingParameters.isEmpty() )
            {
                if ( "basic".equals( configuratorId ) )
                {
                    throw new PluginParameterException( mojoDescriptor, new ArrayList<Parameter>( missingParameters ) );
                }
                else
                {
                    /*
                     * NOTE: Other configurators like the map-oriented one don't call into the listener, so do it the
                     * hard way.
                     */
                    validateParameters( mojoDescriptor, configuration, expressionEvaluator );
                }
            }
        }
        catch ( ComponentConfigurationException e )
        {
            String message = "Unable to parse configuration of mojo " + mojoDescriptor.getId();
            if ( e.getFailedConfiguration() != null )
            {
                message += " for parameter " + e.getFailedConfiguration().getName();
            }
            message += ": " + e.getMessage();

            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(), message, e );
        }
        catch ( ComponentLookupException e )
        {
            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(),
                                                    "Unable to retrieve component configurator " + configuratorId
                                                        + " for configuration of mojo " + mojoDescriptor.getId(), e );
        }
        catch ( NoClassDefFoundError e )
        {
            ByteArrayOutputStream os = new ByteArrayOutputStream( 1024 );
            PrintStream ps = new PrintStream( os );
            ps.println( "A required class was missing during configuration of mojo " + mojoDescriptor.getId() + ": "
                + e.getMessage() );
            pluginRealm.display( ps );

            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(), os.toString(), e );
        }
        catch ( LinkageError e )
        {
            ByteArrayOutputStream os = new ByteArrayOutputStream( 1024 );
            PrintStream ps = new PrintStream( os );
            ps.println( "An API incompatibility was encountered during configuration of mojo " + mojoDescriptor.getId()
                + ": " + e.getClass().getName() + ": " + e.getMessage() );
            pluginRealm.display( ps );

            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(), os.toString(), e );
        }
        finally
        {
            if ( configurator != null )
            {
                try
                {
                    container.release( configurator );
                }
                catch ( ComponentLifecycleException e )
                {
                    logger.debug( "Failed to release mojo configurator - ignoring." );
                }
            }
        }
    }
3469#private void validateParameters( MojoDescriptor mojoDescriptor, PlexusConfiguration configuration,
                                     ExpressionEvaluator expressionEvaluator )
        throws ComponentConfigurationException, PluginParameterException
    {
        if ( mojoDescriptor.getParameters() == null )
        {
            return;
        }

        List<Parameter> invalidParameters = new ArrayList<Parameter>();

        for ( Parameter parameter : mojoDescriptor.getParameters() )
        {
            if ( !parameter.isRequired() )
            {
                continue;
            }

            Object value = null;

            PlexusConfiguration config = configuration.getChild( parameter.getName(), false );
            if ( config != null )
            {
                String expression = config.getValue( null );

                try
                {
                    value = expressionEvaluator.evaluate( expression );

                    if ( value == null )
                    {
                        value = config.getAttribute( "default-value", null );
                    }
                }
                catch ( ExpressionEvaluationException e )
                {
                    String msg =
                        "Error evaluating the expression '" + expression + "' for configuration value '"
                            + configuration.getName() + "'";
                    throw new ComponentConfigurationException( configuration, msg, e );
                }
            }

            if ( value == null && ( config == null || config.getChildCount() <= 0 ) )
            {
                invalidParameters.add( parameter );
            }
        }

        if ( !invalidParameters.isEmpty() )
        {
            throw new PluginParameterException( mojoDescriptor, invalidParameters );
        }
    }
3470#public void releaseMojo( Object mojo, MojoExecution mojoExecution )
    {
        if ( mojo != null )
        {
            try
            {
                container.release( mojo );
            }
            catch ( ComponentLifecycleException e )
            {
                String goalExecId = mojoExecution.getGoal();

                if ( mojoExecution.getExecutionId() != null )
                {
                    goalExecId += " {execution: " + mojoExecution.getExecutionId() + "}";
                }

                logger.debug( "Error releasing mojo for " + goalExecId, e );
            }
        }
    }
3471#public PluginDependencyResolutionListener( ArtifactFilter coreFilter )
    {
        this.coreFilter = coreFilter;
    }
3472#public void removeBannedDependencies( Collection<Artifact> artifacts )
    {
        if ( !bannedArtifacts.isEmpty() && artifacts != null )
        {
            for ( Iterator<Artifact> it = artifacts.iterator(); it.hasNext(); )
            {
                Artifact artifact = it.next();
                if ( bannedArtifacts.containsKey( artifact ) )
                {
                    it.remove();
                }
            }
        }
    }
3473#public void startProcessChildren( Artifact artifact )
    {
        if ( wagonProvider == null )
        {
            if ( isLegacyCoreArtifact( artifact ) )
            {
                coreArtifacts.addFirst( artifact );
            }
            else if ( !coreArtifacts.isEmpty() && isWagonProvider( artifact ) )
            {
                wagonProvider = artifact;
                bannedArtifacts.put( artifact, null );
            }
        }
    }
3474#private boolean isLegacyCoreArtifact( Artifact artifact )
    {
        String version = artifact.getVersion();
        return version != null && version.startsWith( "2." ) && !coreFilter.include( artifact );
    }
3475#public void endProcessChildren( Artifact artifact )
    {
        if ( wagonProvider == artifact )
        {
            wagonProvider = null;
        }
        else if ( coreArtifacts.peek() == artifact )
        {
            coreArtifacts.removeFirst();
        }
    }
3476#public void includeArtifact( Artifact artifact )
    {
        if ( wagonProvider != null )
        {
            bannedArtifacts.put( artifact, null );
        }
    }
3477#private boolean isWagonProvider( Artifact artifact )
    {
        if ( "org.apache.maven.wagon".equals( artifact.getGroupId() ) )
        {
            return artifact.getArtifactId().startsWith( "wagon-" );
        }
        return false;
    }
3478#public void manageArtifact( Artifact artifact, Artifact replacement )
    {
    }
3479#public void omitForCycle( Artifact artifact )
    {
    }
3480#public void omitForNearer( Artifact omitted, Artifact kept )
    {
    }
3481#public void restrictRange( Artifact artifact, Artifact replacement, VersionRange newRange )
    {
    }
3482#public void selectVersionFromRange( Artifact artifact )
    {
    }
3483#public void testArtifact( Artifact node )
    {
    }
3484#public void updateScope( Artifact artifact, String scope )
    {
    }
3485#public void updateScopeCurrentPom( Artifact artifact, String ignoredScope )
    {
    }
3486#/**
     * Gets the prefix of the plugin.
     * 
     * @return The prefix of the plugin.
     */
    String getPrefix();
3487#/**
     * Sets the prefix of the plugin.
     * 
     * @param prefix The prefix of the plugin.
     * @return This request, never {@code null}.
     */
    PluginPrefixRequest setPrefix( String prefix );
3488#/**
     * Gets the list of group ids to scan for the plugin prefix.
     * 
     * @return The list of group ids to scan for the plugin prefix, never {@code null}.
     */
    List<String> getPluginGroups();
3489#/**
     * Sets the list of group ids to scan for the plugin prefix.
     * 
     * @param pluginGroups The list of group ids to scan for the plugin prefix, may be {@code null}.
     * @return This request, never {@code null}.
     */
    PluginPrefixRequest setPluginGroups( List<String> pluginGroups );
3490#/**
     * Gets the POM whose build plugins are to be scanned for the prefix.
     * 
     * @return The POM whose build plugins are to be scanned for the prefix or {@code null} to only search the plugin
     *         repositories.
     */
    Model getPom();
3491#/**
     * Sets the POM whose build plugins are to be scanned for the prefix.
     * 
     * @param pom The POM whose build plugins are to be scanned for the prefix, may be {@code null} to only search the
     *            plugin repositories.
     * @return This request, never {@code null}.
     */
    PluginPrefixRequest setPom( Model pom );
3492#/**
     * Gets the remote repositories to use.
     * 
     * @return The remote repositories to use, never {@code null}.
     */
    List<RemoteRepository> getRepositories();
3493#/**
     * Sets the remote repositories to use. <em>Note:</em> When creating a request from a project, be sure to use the
     * plugin repositories and not the regular project repositories.
     * 
     * @param repositories The remote repositories to use.
     * @return This request, never {@code null}.
     */
    PluginPrefixRequest setRepositories( List<RemoteRepository> repositories );
3494#/**
     * Gets the session to use for repository access.
     * 
     * @return The repository session or {@code null} if not set.
     */
    RepositorySystemSession getRepositorySession();
3495#/**
     * Sets the session to use for repository access.
     * 
     * @param repositorySession The repository session to use.
     * @return This request, never {@code null}.
     */
    PluginPrefixRequest setRepositorySession( RepositorySystemSession repositorySession );
3496#public NoPluginFoundForPrefixException( String prefix, List<String> pluginGroups, LocalRepository localRepository,
                                            List<RemoteRepository> remoteRepositories )
    {
        super( "No plugin found for prefix '" + prefix + "' in the current project and in the plugin groups "
            + pluginGroups + " available from the repositories " + format( localRepository, remoteRepositories ) );
    }
3497#private static String format( LocalRepository localRepository, List<RemoteRepository> remoteRepositories )
    {
        String repos = "[";

        if ( localRepository != null )
        {
            repos += localRepository.getId() + " (" + localRepository.getBasedir() + ")";
        }

        if ( remoteRepositories != null && !remoteRepositories.isEmpty() )
        {
            for ( RemoteRepository repository : remoteRepositories )
            {
                repos += ", ";

                if ( repository != null )
                {
                    repos += repository.getId() + " (" + repository.getUrl() + ")";
                }
            }
        }

        repos += "]";

        return repos;
    }
3498#/**
     * Creates an empty request.
     */
    public DefaultPluginPrefixRequest()
    {
    }
3499#/**
     * Creates a request for the specified plugin prefix and build session. The provided build session will be used to
     * configure repository settings. If the session has a current project, its plugin repositories and model will be
     * used as well.
     * 
     * @param prefix The plugin prefix to resolve, must not be {@code null}.
     * @param session The build session from which to derive further settings, must not be {@code null}.
     */
    public DefaultPluginPrefixRequest( String prefix, MavenSession session )
    {
        setPrefix( prefix );

        setRepositorySession( session.getRepositorySession() );

        MavenProject project = session.getCurrentProject();
        if ( project != null )
        {
            setRepositories( project.getRemotePluginRepositories() );
            setPom( project.getModel() );
        }

        setPluginGroups( session.getPluginGroups() );
    }
3500#public String getPrefix()
    {
        return prefix;
    }
3501#public DefaultPluginPrefixRequest setPrefix( String prefix )
    {
        this.prefix = prefix;

        return this;
    }
3502#public List<String> getPluginGroups()
    {
        return pluginGroups;
    }
3503#public DefaultPluginPrefixRequest setPluginGroups( List<String> pluginGroups )
    {
        if ( pluginGroups != null )
        {
            this.pluginGroups = pluginGroups;
        }
        else
        {
            this.pluginGroups = Collections.emptyList();
        }

        return this;
    }
3504#public Model getPom()
    {
        return pom;
    }
3505#public DefaultPluginPrefixRequest setPom( Model pom )
    {
        this.pom = pom;

        return this;
    }
3506#public List<RemoteRepository> getRepositories()
    {
        return repositories;
    }
3507#public DefaultPluginPrefixRequest setRepositories( List<RemoteRepository> repositories )
    {
        if ( repositories != null )
        {
            this.repositories = repositories;
        }
        else
        {
            this.repositories = Collections.emptyList();
        }

        return this;
    }
3508#public RepositorySystemSession getRepositorySession()
    {
        return session;
    }
3509#public DefaultPluginPrefixRequest setRepositorySession( RepositorySystemSession session )
    {
        this.session = session;

        return this;
    }
3510#/**
     * Resolves the plugin prefix for the specified request.
     * 
     * @param request The request that holds the details about the plugin and the repositories to consult, must not be
     *            {@code null}.
     * @return The result of the prefix resolution, never {@code null}.
     * @throws NoPluginFoundForPrefixException If the plugin prefix could not be resolved.
     */
    PluginPrefixResult resolve( PluginPrefixRequest request )
        throws NoPluginFoundForPrefixException;
3511#/**
     * The resolved group id for the plugin.
     * 
     * @return The resolved group id for the plugin, never {@code null}.
     */
    String getGroupId();
3512#/**
     * The resolved artifact id for the plugin.
     * 
     * @return The resolved artifact id for the plugin, never {@code null}.
     */
    String getArtifactId();
3513#/**
     * The repository from which the plugin prefix was resolved.
     * 
     * @return The repository from which the plugin prefix was resolved or {@code null} if the prefix was resolved from
     *         the supplied POM.
     */
    ArtifactRepository getRepository();
3514#public PluginPrefixResult resolve( PluginPrefixRequest request )
        throws NoPluginFoundForPrefixException
    {
        logger.debug( "Resolving plugin prefix " + request.getPrefix() + " from " + request.getPluginGroups() );

        PluginPrefixResult result = resolveFromProject( request );

        if ( result == null )
        {
            result = resolveFromRepository( request );

            if ( result == null )
            {
                throw new NoPluginFoundForPrefixException( request.getPrefix(), request.getPluginGroups(),
                                                           request.getRepositorySession().getLocalRepository(),
                                                           request.getRepositories() );
            }
            else if ( logger.isDebugEnabled() )
            {
                logger.debug( "Resolved plugin prefix " + request.getPrefix() + " to " + result.getGroupId() + ":"
                    + result.getArtifactId() + " from repository "
                    + ( result.getRepository() != null ? result.getRepository().getId() : "null" ) );
            }
        }
        else if ( logger.isDebugEnabled() )
        {
            logger.debug( "Resolved plugin prefix " + request.getPrefix() + " to " + result.getGroupId() + ":"
                + result.getArtifactId() + " from POM " + request.getPom() );
        }

        return result;
    }
3515#private PluginPrefixResult resolveFromProject( PluginPrefixRequest request )
    {
        PluginPrefixResult result = null;

        if ( request.getPom() != null && request.getPom().getBuild() != null )
        {
            Build build = request.getPom().getBuild();

            result = resolveFromProject( request, build.getPlugins() );

            if ( result == null && build.getPluginManagement() != null )
            {
                result = resolveFromProject( request, build.getPluginManagement().getPlugins() );
            }
        }

        return result;
    }
3516#private PluginPrefixResult resolveFromProject( PluginPrefixRequest request, List<Plugin> plugins )
    {
        for ( Plugin plugin : plugins )
        {
            try
            {
                PluginDescriptor pluginDescriptor =
                    pluginManager.loadPlugin( plugin, request.getRepositories(), request.getRepositorySession() );

                if ( request.getPrefix().equals( pluginDescriptor.getGoalPrefix() ) )
                {
                    return new DefaultPluginPrefixResult( plugin );
                }
            }
            catch ( Exception e )
            {
                if ( logger.isDebugEnabled() )
                {
                    logger.warn( "Failed to retrieve plugin descriptor for " + plugin.getId() + ": " + e.getMessage(),
                                 e );
                }
                else
                {
                    logger.warn( "Failed to retrieve plugin descriptor for " + plugin.getId() + ": " + e.getMessage() );
                }
            }
        }

        return null;
    }
3517#private PluginPrefixResult resolveFromRepository( PluginPrefixRequest request )
    {
        RequestTrace trace = DefaultRequestTrace.newChild( null, request );

        List<MetadataRequest> requests = new ArrayList<MetadataRequest>();

        for ( String pluginGroup : request.getPluginGroups() )
        {
            org.sonatype.aether.metadata.Metadata metadata =
                new DefaultMetadata( pluginGroup, "maven-metadata.xml", DefaultMetadata.Nature.RELEASE_OR_SNAPSHOT );

            requests.add( new MetadataRequest( metadata, null, REPOSITORY_CONTEXT ).setTrace( trace ) );

            for ( RemoteRepository repository : request.getRepositories() )
            {
                requests.add( new MetadataRequest( metadata, repository, REPOSITORY_CONTEXT ).setTrace( trace ) );
            }
        }

        // initial try, use locally cached metadata

        List<MetadataResult> results = repositorySystem.resolveMetadata( request.getRepositorySession(), requests );
        requests.clear();

        PluginPrefixResult result = processResults( request, trace, results, requests );

        if ( result != null )
        {
            return result;
        }

        // second try, refetch all (possibly outdated) metadata that wasn't updated in the first attempt

        if ( !request.getRepositorySession().isOffline() && !requests.isEmpty() )
        {
            DefaultRepositorySystemSession session =
                new DefaultRepositorySystemSession( request.getRepositorySession() );
            session.setUpdatePolicy( RepositoryPolicy.UPDATE_POLICY_ALWAYS );

            results = repositorySystem.resolveMetadata( session, requests );

            return processResults( request, trace, results, null );
        }

        return null;
    }
3518#private PluginPrefixResult processResults( PluginPrefixRequest request, RequestTrace trace,
                                               List<MetadataResult> results, List<MetadataRequest> requests )
    {
        for ( MetadataResult res : results )
        {
            org.sonatype.aether.metadata.Metadata metadata = res.getMetadata();

            if ( metadata != null )
            {
                ArtifactRepository repository = res.getRequest().getRepository();
                if ( repository == null )
                {
                    repository = request.getRepositorySession().getLocalRepository();
                }

                PluginPrefixResult result =
                    resolveFromRepository( request, trace, metadata.getGroupId(), metadata, repository );

                if ( result != null )
                {
                    return result;
                }
            }

            if ( requests != null && !res.isUpdated() )
            {
                requests.add( res.getRequest() );
            }
        }

        return null;
    }
3519#private PluginPrefixResult resolveFromRepository( PluginPrefixRequest request, RequestTrace trace,
                                                      String pluginGroup,
                                                      org.sonatype.aether.metadata.Metadata metadata,
                                                      ArtifactRepository repository )
    {
        if ( metadata != null && metadata.getFile() != null && metadata.getFile().isFile() )
        {
            try
            {
                Map<String, ?> options = Collections.singletonMap( MetadataReader.IS_STRICT, Boolean.FALSE );

                Metadata pluginGroupMetadata = metadataReader.read( metadata.getFile(), options );

                List<org.apache.maven.artifact.repository.metadata.Plugin> plugins = pluginGroupMetadata.getPlugins();

                if ( plugins != null )
                {
                    for ( org.apache.maven.artifact.repository.metadata.Plugin plugin : plugins )
                    {
                        if ( request.getPrefix().equals( plugin.getPrefix() ) )
                        {
                            return new DefaultPluginPrefixResult( pluginGroup, plugin.getArtifactId(), repository );
                        }
                    }
                }
            }
            catch ( IOException e )
            {
                invalidMetadata( request.getRepositorySession(), trace, metadata, repository, e );
            }
        }

        return null;
    }
3520#private void invalidMetadata( RepositorySystemSession session, RequestTrace trace,
                                  org.sonatype.aether.metadata.Metadata metadata, ArtifactRepository repository,
                                  Exception exception )
    {
        RepositoryListener listener = session.getRepositoryListener();
        if ( listener != null )
        {
            DefaultRepositoryEvent event = new DefaultRepositoryEvent( EventType.METADATA_INVALID, session, trace );
            event.setMetadata( metadata );
            event.setException( exception );
            event.setRepository( repository );
            listener.metadataInvalid( event );
        }
    }
3521#public DefaultPluginPrefixResult()
    {
        // does nothing
    }
3522#public DefaultPluginPrefixResult( Plugin plugin )
    {
        groupId = plugin.getGroupId();
        artifactId = plugin.getArtifactId();
    }
3523#public DefaultPluginPrefixResult( String groupId, String artifactId, ArtifactRepository repository )
    {
        this.groupId = groupId;
        this.artifactId = artifactId;
        this.repository = repository;
    }
3524#public String getGroupId()
    {
        return groupId;
    }
3525#public void setGroupId( String groupId )
    {
        this.groupId = groupId;
    }
3526#public String getArtifactId()
    {
        return artifactId;
    }
3527#public void setArtifactId( String artifactId )
    {
        this.artifactId = artifactId;
    }
3528#public ArtifactRepository getRepository()
    {
        return repository;
    }
3529#public void setRepository( ArtifactRepository repository )
    {
        this.repository = repository;
    }
3530#public PluginVersionNotFoundException( String groupId, String artifactId )
    {
        super( "The plugin \'" + groupId + ":" + artifactId + "\' does not exist or no valid version could be found" );

        this.groupId = groupId;
        this.artifactId = artifactId;
    }
3531#public String getGroupId()
    {
        return groupId;
    }
3532#public String getArtifactId()
    {
        return artifactId;
    }
3533#/**
     * The resolved plugin version.
     * 
     * @return The resolved plugin version, never {@code null}.
     */
    String getVersion();
3534#/**
     * The repository from which the plugin version was resolved.
     * 
     * @return The repository from which the plugin version was resolved, never {@code null}.
     */
    ArtifactRepository getRepository();
3535#public PluginVersionResolutionException( String groupId, String artifactId, String baseMessage, Throwable cause )
    {
        super( "Error resolving version for plugin \'" + groupId + ":" + artifactId + "\': " + baseMessage, cause );

        this.groupId = groupId;
        this.artifactId = artifactId;
        this.baseMessage = baseMessage;
    }
3536#public PluginVersionResolutionException( String groupId, String artifactId, String baseMessage )
    {
        super( "Error resolving version for plugin \'" + groupId + ":" + artifactId + "\': " + baseMessage );

        this.groupId = groupId;
        this.artifactId = artifactId;
        this.baseMessage = baseMessage;
    }
3537#public PluginVersionResolutionException( String groupId, String artifactId, LocalRepository localRepository,
                                             List<RemoteRepository> remoteRepositories, String baseMessage )
    {
        super( "Error resolving version for plugin \'" + groupId + ":" + artifactId + "\' from the repositories "
            + format( localRepository, remoteRepositories ) + ": " + baseMessage );

        this.groupId = groupId;
        this.artifactId = artifactId;
        this.baseMessage = baseMessage;
    }
3538#public String getGroupId()
    {
        return groupId;
    }
3539#public String getArtifactId()
    {
        return artifactId;
    }
3540#public String getBaseMessage()
    {
        return baseMessage;
    }
3541#private static String format( LocalRepository localRepository, List<RemoteRepository> remoteRepositories )
    {
        String repos = "[";

        if ( localRepository != null )
        {
            repos += localRepository.getId() + " (" + localRepository.getBasedir() + ")";
        }

        if ( remoteRepositories != null && !remoteRepositories.isEmpty() )
        {
            for ( RemoteRepository repository : remoteRepositories )
            {
                repos += ", ";

                if ( repository != null )
                {
                    repos += repository.getId() + " (" + repository.getUrl() + ")";
                }
            }
        }

        repos += "]";

        return repos;
    }
3542#/**
     * Gets the group id of the plugin.
     * 
     * @return The group id of the plugin.
     */
    String getGroupId();
3543#/**
     * Sets the group id of the plugin.
     * 
     * @param groupId The group id of the plugin.
     * @return This request, never {@code null}.
     */
    PluginVersionRequest setGroupId( String groupId );
3544#/**
     * Gets the artifact id of the plugin.
     * 
     * @return The artifact id of the plugin.
     */
    String getArtifactId();
3545#/**
     * Sets the artifact id of the plugin.
     * 
     * @param artifactId The artifact id of the plugin.
     * @return This request, never {@code null}.
     */
    PluginVersionRequest setArtifactId( String artifactId );
3546#/**
     * Gets the POM whose build plugins are to be scanned for the version.
     * 
     * @return The POM whose build plugins are to be scanned for the verion or {@code null} to only search the plugin
     *         repositories.
     */
    Model getPom();
3547#/**
     * Sets the POM whose build plugins are to be scanned for the version.
     * 
     * @param pom The POM whose build plugins are to be scanned for the version, may be {@code null} to only search the
     *            plugin repositories.
     * @return This request, never {@code null}.
     */
    PluginVersionRequest setPom( Model pom );
3548#/**
     * Gets the remote repositories to use.
     * 
     * @return The remote repositories to use, never {@code null}.
     */
    List<RemoteRepository> getRepositories();
3549#/**
     * Sets the remote repositories to use. <em>Note:</em> When creating a request from a project, be sure to use the
     * plugin repositories and not the regular project repositories.
     * 
     * @param repositories The remote repositories to use.
     * @return This request, never {@code null}.
     */
    PluginVersionRequest setRepositories( List<RemoteRepository> repositories );
3550#/**
     * Gets the session to use for repository access.
     * 
     * @return The repository session or {@code null} if not set.
     */
    RepositorySystemSession getRepositorySession();
3551#/**
     * Sets the session to use for repository access.
     * 
     * @param repositorySession The repository session to use.
     * @return This request, never {@code null}.
     */
    PluginVersionRequest setRepositorySession( RepositorySystemSession repositorySession );
3552#/**
     * Resolves the version for the specified request.
     * 
     * @param request The request that holds the details about the plugin and the repositories to consult, must not be
     *            {@code null}.
     * @return The result of the version resolution, never {@code null}.
     * @throws PluginVersionResolutionException If the plugin version could not be resolved.
     */
    PluginVersionResult resolve( PluginVersionRequest request )
        throws PluginVersionResolutionException;
3553#/**
     * Creates an empty request.
     */
    public DefaultPluginVersionRequest()
    {
    }
3554#/**
     * Creates a request for the specified plugin by copying settings from the specified build session. If the session
     * has a current project, its plugin repositories will be used as well.
     * 
     * @param plugin The plugin for which to resolve a version, must not be {@code null}.
     * @param repositoryRequest The repository request to copy from, must not be {@code null}.
     */
    public DefaultPluginVersionRequest( Plugin plugin, MavenSession session )
    {
        setGroupId( plugin.getGroupId() );
        setArtifactId( plugin.getArtifactId() );

        setRepositorySession( session.getRepositorySession() );

        MavenProject project = session.getCurrentProject();
        if ( project != null )
        {
            setRepositories( project.getRemotePluginRepositories() );
        }
    }
3555#/**
     * Creates a request for the specified plugin using the given repository session and plugin repositories.
     * 
     * @param plugin The plugin for which to resolve a version, must not be {@code null}.
     * @param session The repository session to use, must not be {@code null}.
     * @param repositories The plugin repositories to query, may be {@code null}.
     */
    public DefaultPluginVersionRequest( Plugin plugin, RepositorySystemSession session, List<RemoteRepository> repositories )
    {
        setGroupId( plugin.getGroupId() );
        setArtifactId( plugin.getArtifactId() );

        setRepositorySession( session );

        setRepositories( repositories );
    }
3556#public String getGroupId()
    {
        return groupId;
    }
3557#public DefaultPluginVersionRequest setGroupId( String groupId )
    {
        this.groupId = groupId;

        return this;
    }
3558#public String getArtifactId()
    {
        return artifactId;
    }
3559#public DefaultPluginVersionRequest setArtifactId( String artifactId )
    {
        this.artifactId = artifactId;

        return this;
    }
3560#public Model getPom()
    {
        return pom;
    }
3561#public DefaultPluginVersionRequest setPom( Model pom )
    {
        this.pom = pom;

        return this;
    }
3562#public List<RemoteRepository> getRepositories()
    {
        return repositories;
    }
3563#public DefaultPluginVersionRequest setRepositories( List<RemoteRepository> repositories )
    {
        if ( repositories != null )
        {
            this.repositories = repositories;
        }
        else
        {
            this.repositories = Collections.emptyList();
        }

        return this;
    }
3564#public RepositorySystemSession getRepositorySession()
    {
        return session;
    }
3565#public DefaultPluginVersionRequest setRepositorySession( RepositorySystemSession session )
    {
        this.session = session;

        return this;
    }
3566#public DefaultPluginVersionResult()
    {
        // does nothing
    }
3567#public DefaultPluginVersionResult( String version )
    {
        this.version = version;
    }
3568#public String getVersion()
    {
        return version;
    }
3569#public void setVersion( String version )
    {
        this.version = version;
    }
3570#public ArtifactRepository getRepository()
    {
        return repository;
    }
3571#public void setRepository( ArtifactRepository repository )
    {
        this.repository = repository;
    }
3572#public PluginVersionResult resolve( PluginVersionRequest request )
        throws PluginVersionResolutionException
    {
        logger.debug( "Resolving plugin version for " + request.getGroupId() + ":" + request.getArtifactId() );

        PluginVersionResult result = resolveFromProject( request );

        if ( result == null )
        {
            result = resolveFromRepository( request );

            if ( logger.isDebugEnabled() )
            {
                logger.debug( "Resolved plugin version for " + request.getGroupId() + ":" + request.getArtifactId()
                    + " to " + result.getVersion() + " from repository " + result.getRepository() );
            }
        }
        else if ( logger.isDebugEnabled() )
        {
            logger.debug( "Resolved plugin version for " + request.getGroupId() + ":" + request.getArtifactId()
                + " to " + result.getVersion() + " from POM " + request.getPom() );
        }

        return result;
    }
3573#private PluginVersionResult resolveFromRepository( PluginVersionRequest request )
        throws PluginVersionResolutionException
    {
        RequestTrace trace = DefaultRequestTrace.newChild( null, request );

        DefaultPluginVersionResult result = new DefaultPluginVersionResult();

        org.sonatype.aether.metadata.Metadata metadata =
            new DefaultMetadata( request.getGroupId(), request.getArtifactId(), "maven-metadata.xml",
                                 DefaultMetadata.Nature.RELEASE_OR_SNAPSHOT );

        List<MetadataRequest> requests = new ArrayList<MetadataRequest>();

        requests.add( new MetadataRequest( metadata, null, REPOSITORY_CONTEXT ).setTrace( trace ) );

        for ( RemoteRepository repository : request.getRepositories() )
        {
            requests.add( new MetadataRequest( metadata, repository, REPOSITORY_CONTEXT ).setTrace( trace ) );
        }

        List<MetadataResult> results = repositorySystem.resolveMetadata( request.getRepositorySession(), requests );

        Versions versions = new Versions();

        for ( MetadataResult res : results )
        {
            ArtifactRepository repository = res.getRequest().getRepository();
            if ( repository == null )
            {
                repository = request.getRepositorySession().getLocalRepository();
            }

            mergeMetadata( request.getRepositorySession(), trace, versions, res.getMetadata(), repository );
        }

        selectVersion( result, request, versions );

        return result;
    }
3574#private void selectVersion( DefaultPluginVersionResult result, PluginVersionRequest request, Versions versions )
        throws PluginVersionResolutionException
    {
        String version = null;
        ArtifactRepository repo = null;

        if ( StringUtils.isNotEmpty( versions.releaseVersion ) )
        {
            version = versions.releaseVersion;
            repo = versions.releaseRepository;
        }
        else if ( StringUtils.isNotEmpty( versions.latestVersion ) )
        {
            version = versions.latestVersion;
            repo = versions.latestRepository;
        }
        if ( version != null && !isCompatible( request, version ) )
        {
            versions.versions.remove( version );
            version = null;
        }

        if ( version == null )
        {
            VersionScheme versionScheme = new GenericVersionScheme();

            TreeSet<Version> releases = new TreeSet<Version>( Collections.reverseOrder() );
            TreeSet<Version> snapshots = new TreeSet<Version>( Collections.reverseOrder() );

            for ( String ver : versions.versions.keySet() )
            {
                try
                {
                    Version v = versionScheme.parseVersion( ver );

                    if ( ver.endsWith( "-SNAPSHOT" ) )
                    {
                        snapshots.add( v );
                    }
                    else
                    {
                        releases.add( v );
                    }
                }
                catch ( InvalidVersionSpecificationException e )
                {
                    continue;
                }
            }

            for ( Version v : releases )
            {
                String ver = v.toString();
                if ( isCompatible( request, ver ) )
                {
                    version = ver;
                    repo = versions.versions.get( version );
                    break;
                }
            }

            if ( version == null )
            {
                for ( Version v : snapshots )
                {
                    String ver = v.toString();
                    if ( isCompatible( request, ver ) )
                    {
                        version = ver;
                        repo = versions.versions.get( version );
                        break;
                    }
                }
            }
        }

        if ( version != null )
        {
            result.setVersion( version );
            result.setRepository( repo );
        }
        else
        {
            throw new PluginVersionResolutionException( request.getGroupId(), request.getArtifactId(),
                                                        request.getRepositorySession().getLocalRepository(),
                                                        request.getRepositories(),
                                                        "Plugin not found in any plugin repository" );
        }
    }
3575#private boolean isCompatible( PluginVersionRequest request, String version )
    {
        Plugin plugin = new Plugin();
        plugin.setGroupId( request.getGroupId() );
        plugin.setArtifactId( request.getArtifactId() );
        plugin.setVersion( version );

        PluginDescriptor pluginDescriptor;

        try
        {
            pluginDescriptor =
                pluginManager.getPluginDescriptor( plugin, request.getRepositories(), request.getRepositorySession() );
        }
        catch ( PluginResolutionException e )
        {
            logger.debug( "Ignoring unresolvable plugin version " + version, e );
            return false;
        }
        catch ( Exception e )
        {
            // ignore for now and delay failure to higher level processing
            return true;
        }

        try
        {
            pluginManager.checkRequiredMavenVersion( pluginDescriptor );
        }
        catch ( Exception e )
        {
            logger.debug( "Ignoring incompatible plugin version " + version + ": " + e.getMessage() );
            return false;
        }

        return true;
    }
3576#private void mergeMetadata( RepositorySystemSession session, RequestTrace trace, Versions versions,
                                org.sonatype.aether.metadata.Metadata metadata, ArtifactRepository repository )
    {
        if ( metadata != null && metadata.getFile() != null && metadata.getFile().isFile() )
        {
            try
            {
                Map<String, ?> options = Collections.singletonMap( MetadataReader.IS_STRICT, Boolean.FALSE );

                Metadata repoMetadata = metadataReader.read( metadata.getFile(), options );

                mergeMetadata( versions, repoMetadata, repository );
            }
            catch ( IOException e )
            {
                invalidMetadata( session, trace, metadata, repository, e );
            }
        }
    }
3577#private void invalidMetadata( RepositorySystemSession session, RequestTrace trace,
                                  org.sonatype.aether.metadata.Metadata metadata, ArtifactRepository repository,
                                  Exception exception )
    {
        RepositoryListener listener = session.getRepositoryListener();
        if ( listener != null )
        {
            DefaultRepositoryEvent event = new DefaultRepositoryEvent( EventType.METADATA_INVALID, session, trace );
            event.setMetadata( metadata );
            event.setException( exception );
            event.setRepository( repository );
            listener.metadataInvalid( event );
        }
    }
3578#private void mergeMetadata( Versions versions, Metadata source, ArtifactRepository repository )
    {
        Versioning versioning = source.getVersioning();
        if ( versioning != null )
        {
            String timestamp = StringUtils.clean( versioning.getLastUpdated() );

            if ( StringUtils.isNotEmpty( versioning.getRelease() )
                && timestamp.compareTo( versions.releaseTimestamp ) > 0 )
            {
                versions.releaseVersion = versioning.getRelease();
                versions.releaseTimestamp = timestamp;
                versions.releaseRepository = repository;
            }

            if ( StringUtils.isNotEmpty( versioning.getLatest() )
                && timestamp.compareTo( versions.latestTimestamp ) > 0 )
            {
                versions.latestVersion = versioning.getLatest();
                versions.latestTimestamp = timestamp;
                versions.latestRepository = repository;
            }

            for ( String version : versioning.getVersions() )
            {
                if ( !versions.versions.containsKey( version ) )
                {
                    versions.versions.put( version, repository );
                }
            }
        }
    }
3579#private PluginVersionResult resolveFromProject( PluginVersionRequest request )
    {
        PluginVersionResult result = null;

        if ( request.getPom() != null && request.getPom().getBuild() != null )
        {
            Build build = request.getPom().getBuild();

            result = resolveFromProject( request, build.getPlugins() );

            if ( result == null && build.getPluginManagement() != null )
            {
                result = resolveFromProject( request, build.getPluginManagement().getPlugins() );
            }
        }

        return result;
    }
3580#private PluginVersionResult resolveFromProject( PluginVersionRequest request, List<Plugin> plugins )
    {
        for ( Plugin plugin : plugins )
        {
            if ( request.getGroupId().equals( plugin.getGroupId() )
                && request.getArtifactId().equals( plugin.getArtifactId() ) )
            {
                if ( plugin.getVersion() != null )
                {
                    return new DefaultPluginVersionResult( plugin.getVersion() );
                }
                else
                {
                    return null;
                }
            }
        }
        return null;
    }
3581#/**
     * Gets the dependency graph of the project.
     * 
     * @return The dependency graph or {@code null} if not available.
     */
    DependencyNode getDependencyGraph();
3582#/**
     * Gets the transitive dependencies of the project that were not excluded by
     * {@link DependencyResolutionRequest#getResolutionFilter()}. This list is a union of the results from
     * {@link #getResolvedDependencies()} and {@link #getUnresolvedDependencies()}.
     * 
     * @return The transitive dependencies, never {@code null}.
     */
    List<Dependency> getDependencies();
3583#/**
     * Gets the dependencies that were successfully resolved.
     * 
     * @return The resolved dependencies, never {@code null}.
     */
    List<Dependency> getResolvedDependencies();
3584#/**
     * Gets the dependencies that could not be resolved.
     * 
     * @return The unresolved dependencies, never {@code null}.
     */
    List<Dependency> getUnresolvedDependencies();
3585#/**
     * Gets the errors that occurred while building the dependency graph.
     * 
     * @return The errors that occurred while building the dependency graph, never {@code null}.
     */
    List<Exception> getCollectionErrors();
3586#/**
     * Gets the errors that occurred while resolving the specified dependency.
     * 
     * @param dependency The dependency for which to retrieve the errors, must not be {@code null}.
     * @return The resolution errors for the specified dependency, never {@code null}.
     */
    List<Exception> getResolutionErrors( Dependency dependency );
3587#ExtensionDescriptor()
    {
        // hide constructor
    }
3588#public List<String> getExportedPackages()
    {
        if ( exportedPackages == null )
        {
            exportedPackages = new ArrayList<String>();
        }

        return exportedPackages;
    }
3589#public void setExportedPackages( List<String> exportedPackages )
    {
        if ( exportedPackages == null )
        {
            this.exportedPackages = null;
        }
        else
        {
            this.exportedPackages = new ArrayList<String>( exportedPackages );
        }
    }
3590#public List<String> getExportedArtifacts()
    {
        if ( exportedArtifacts == null )
        {
            exportedArtifacts = new ArrayList<String>();
        }

        return exportedArtifacts;
    }
3591#public void setExportedArtifacts( List<String> exportedArtifacts )
    {
        if ( exportedArtifacts == null )
        {
            this.exportedArtifacts = null;
        }
        else
        {
            this.exportedArtifacts = new ArrayList<String>( exportedArtifacts );
        }
    }
3592#void attachArtifact( MavenProject project, File artifactFile, String artifactClassifier );
3593#void attachArtifact( MavenProject project, String artifactType, File artifactFile );
3594#void attachArtifact( MavenProject project, String artifactType, String artifactClassifier, File artifactFile );
3595#void addResource( MavenProject project, String resourceDirectory, List includes, List excludes );
3596#void addTestResource( MavenProject project, String resourceDirectory, List includes, List excludes );
3597#public File get( String groupId, String artifactId, String version )
    {
        return pomFiles.get( new CacheKey( groupId, artifactId, version ) );
    }
3598#public void put( String groupId, String artifactId, String version, File pomFile )
    {
        pomFiles.put( new CacheKey( groupId, artifactId, version ), pomFile );
    }
3599#public CacheKey( String groupId, String artifactId, String version )
        {
            this.groupId = ( groupId != null ) ? groupId : "";
            this.artifactId = ( artifactId != null ) ? artifactId : "";
            this.version = ( version != null ) ? version : "";

            int hash = 17;
            hash = hash * 31 + this.groupId.hashCode();
            hash = hash * 31 + this.artifactId.hashCode();
            hash = hash * 31 + this.version.hashCode();
            hashCode = hash;
        }
3600#@Override
        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version );
        }
3601#@Override
        public int hashCode()
        {
            return hashCode;
        }
3602#@Override
        public String toString()
        {
            StringBuilder buffer = new StringBuilder( 96 );
            buffer.append( groupId ).append( ':' ).append( artifactId ).append( ':' ).append( version );
            return buffer.toString();
        }
3603#public DependencyResolutionException( DependencyResolutionResult result, String message, Throwable cause )
    {
        super( message, cause );
        this.result = result;
    }
3604#public DependencyResolutionResult getResult()
    {
        return result;
    }
3605#public CacheRecord get( List<? extends ClassRealm> extensionRealms )
    {
        return cache.get( new CacheKey( extensionRealms ) );
    }
3606#public CacheRecord put( List<? extends ClassRealm> extensionRealms, ClassRealm projectRealm,
                            DependencyFilter extensionArtifactFilter )
    {
        if ( projectRealm == null )
        {
            throw new NullPointerException();
        }

        CacheKey key = new CacheKey( extensionRealms );

        if ( cache.containsKey( key ) )
        {
            throw new IllegalStateException( "Duplicate project realm for extensions " + extensionRealms );
        }

        CacheRecord record = new CacheRecord( projectRealm, extensionArtifactFilter );

        cache.put( key, record );

        return record;
    }
3607#public void flush()
    {
        cache.clear();
    }
3608#public void register( MavenProject project, CacheRecord record )
    {
        // default cache does not track record usage
    }
3609#public CacheKey( List<? extends ClassRealm> extensionRealms )
        {
            this.extensionRealms = ( extensionRealms != null ) ? extensionRealms : Collections.<ClassRealm> emptyList();

            this.hashCode = this.extensionRealms.hashCode();
        }
3610#@Override
        public int hashCode()
        {
            return hashCode;
        }
3611#@Override
        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return extensionRealms.equals( other.extensionRealms );
        }
3612#public ProjectModelResolver( RepositorySystemSession session, RequestTrace trace, RepositorySystem resolver,
                                 RemoteRepositoryManager remoteRepositoryManager, List<RemoteRepository> repositories,
                                 ProjectBuildingRequest.RepositoryMerging repositoryMerging, ReactorModelPool modelPool )
    {
        this.session = session;
        this.trace = trace;
        this.resolver = resolver;
        this.remoteRepositoryManager = remoteRepositoryManager;
        this.pomRepositories = new ArrayList<RemoteRepository>();
        this.externalRepositories = repositories;
        this.repositories = repositories;
        this.repositoryMerging = repositoryMerging;
        this.repositoryIds = new HashSet<String>();
        this.modelPool = modelPool;
    }
3613#private ProjectModelResolver( ProjectModelResolver original )
    {
        this.session = original.session;
        this.trace = original.trace;
        this.resolver = original.resolver;
        this.remoteRepositoryManager = original.remoteRepositoryManager;
        this.pomRepositories = original.pomRepositories;
        this.externalRepositories = original.externalRepositories;
        this.repositories = original.repositories;
        this.repositoryMerging = original.repositoryMerging;
        this.repositoryIds = new HashSet<String>( original.repositoryIds );
        this.modelPool = original.modelPool;
    }
3614#public void addRepository( Repository repository )
        throws InvalidRepositoryException
    {
        if ( !repositoryIds.add( repository.getId() ) )
        {
            return;
        }

        List<RemoteRepository> newRepositories =
            Collections.singletonList( ArtifactDescriptorUtils.toRemoteRepository( repository ) );

        if ( ProjectBuildingRequest.RepositoryMerging.REQUEST_DOMINANT.equals( repositoryMerging ) )
        {
            repositories = remoteRepositoryManager.aggregateRepositories( session, repositories, newRepositories, true );
        }
        else
        {
            pomRepositories =
                remoteRepositoryManager.aggregateRepositories( session, pomRepositories, newRepositories, true );
            repositories =
                remoteRepositoryManager.aggregateRepositories( session, pomRepositories, externalRepositories, false );
        }
    }
3615#public ModelResolver newCopy()
    {
        return new ProjectModelResolver( this );
    }
3616#public ModelSource resolveModel( String groupId, String artifactId, String version )
        throws UnresolvableModelException
    {
        File pomFile = null;

        if ( modelPool != null )
        {
            pomFile = modelPool.get( groupId, artifactId, version );
        }

        if ( pomFile == null )
        {
            Artifact pomArtifact = new DefaultArtifact( groupId, artifactId, "", "pom", version );

            try
            {
                ArtifactRequest request = new ArtifactRequest( pomArtifact, repositories, context );
                request.setTrace( trace );
                pomArtifact = resolver.resolveArtifact( session, request ).getArtifact();
            }
            catch ( ArtifactResolutionException e )
            {
                throw new UnresolvableModelException( e.getMessage(), groupId, artifactId, version, e );
            }

            pomFile = pomArtifact.getFile();
        }

        return new FileModelSource( pomFile );
    }
3617#public DefaultModelBuildingListener( MavenProject project, ProjectBuildingHelper projectBuildingHelper,
                                         ProjectBuildingRequest projectBuildingRequest )
    {
        if ( project == null )
        {
            throw new IllegalArgumentException( "project missing" );
        }
        this.project = project;

        if ( projectBuildingHelper == null )
        {
            throw new IllegalArgumentException( "project building helper missing" );
        }
        this.projectBuildingHelper = projectBuildingHelper;

        if ( projectBuildingRequest == null )
        {
            throw new IllegalArgumentException( "project building request missing" );
        }
        this.projectBuildingRequest = projectBuildingRequest;
        this.remoteRepositories = projectBuildingRequest.getRemoteRepositories();
        this.pluginRepositories = projectBuildingRequest.getPluginArtifactRepositories();
    }
3618#/**
     * Gets the project whose model is being built.
     * 
     * @return The project, never {@code null}.
     */
    public MavenProject getProject()
    {
        return project;
    }
3619#@Override
    public void buildExtensionsAssembled( ModelBuildingEvent event )
    {
        Model model = event.getModel();

        try
        {
            pluginRepositories =
                projectBuildingHelper.createArtifactRepositories( model.getPluginRepositories(), pluginRepositories,
                                                                  projectBuildingRequest );
        }
        catch ( Exception e )
        {
            event.getProblems().add( Severity.ERROR, "Invalid plugin repository: " + e.getMessage(), null, e );
        }
        project.setPluginArtifactRepositories( pluginRepositories );

        if ( event.getRequest().isProcessPlugins() )
        {
            try
            {
                ProjectRealmCache.CacheRecord record =
                    projectBuildingHelper.createProjectRealm( project, model, projectBuildingRequest );

                project.setClassRealm( record.realm );
                project.setExtensionDependencyFilter( record.extensionArtifactFilter );
            }
            catch ( PluginResolutionException e )
            {
                event.getProblems().add( Severity.ERROR, "Unresolveable build extension: " + e.getMessage(), null, e );
            }
            catch ( PluginVersionResolutionException e )
            {
                event.getProblems().add( Severity.ERROR, "Unresolveable build extension: " + e.getMessage(), null, e );
            }

            projectBuildingHelper.selectProjectRealm( project );
        }

        // build the regular repos after extensions are loaded to allow for custom layouts
        try
        {
            remoteRepositories =
                projectBuildingHelper.createArtifactRepositories( model.getRepositories(), remoteRepositories,
                                                                  projectBuildingRequest );
        }
        catch ( Exception e )
        {
            event.getProblems().add( Severity.ERROR, "Invalid artifact repository: " + e.getMessage(), null, e );
        }
        project.setRemoteArtifactRepositories( remoteRepositories );
    }
3620#// ----------------------------------------------------------------------
    // MavenProjectBuilder Implementation
    // ----------------------------------------------------------------------

    public ProjectBuildingResult build( File pomFile, ProjectBuildingRequest request )
        throws ProjectBuildingException
    {
        return build( pomFile, new FileModelSource( pomFile ), new InternalConfig( request, null, null ) );
    }
3621#public ProjectBuildingResult build( ModelSource modelSource, ProjectBuildingRequest request )
        throws ProjectBuildingException
    {
        return build( null, modelSource, new InternalConfig( request, null, null ) );
    }
3622#private ProjectBuildingResult build( File pomFile, ModelSource modelSource, InternalConfig config )
        throws ProjectBuildingException
    {
        ClassLoader oldContextClassLoader = Thread.currentThread().getContextClassLoader();

        try
        {
            ProjectBuildingRequest configuration = config.request;

            MavenProject project = configuration.getProject();

            List<ModelProblem> modelProblems = null;
            Throwable error = null;

            if ( project == null )
            {
                ModelBuildingRequest request = getModelBuildingRequest( config );

                project = new MavenProject( repositorySystem, this, configuration, logger );

                DefaultModelBuildingListener listener =
                    new DefaultModelBuildingListener( project, projectBuildingHelper, configuration );
                request.setModelBuildingListener( listener );

                request.setPomFile( pomFile );
                request.setModelSource( modelSource );
                request.setLocationTracking( true );

                ModelBuildingResult result;
                try
                {
                    result = modelBuilder.build( request );
                }
                catch ( ModelBuildingException e )
                {
                    result = e.getResult();
                    if ( result == null || result.getEffectiveModel() == null )
                    {
                        throw new ProjectBuildingException( e.getModelId(), e.getMessage(), pomFile, e );
                    }
                    // validation error, continue project building and delay failing to help IDEs
                    error = e;
                }

                modelProblems = result.getProblems();

                initProject( project, Collections.<String, MavenProject> emptyMap(), result,
                             new HashMap<File, Boolean>() );
            }
            else if ( configuration.isResolveDependencies() )
            {
                projectBuildingHelper.selectProjectRealm( project );
            }

            DependencyResolutionResult resolutionResult = null;

            if ( configuration.isResolveDependencies() )
            {
                resolutionResult = resolveDependencies( project, config.session );
            }

            ProjectBuildingResult result = new DefaultProjectBuildingResult( project, modelProblems, resolutionResult );

            if ( error != null )
            {
                ProjectBuildingException e = new ProjectBuildingException( Arrays.asList( result ) );
                e.initCause( error );
                throw e;
            }

            return result;
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( oldContextClassLoader );
        }
    }
3623#private DependencyResolutionResult resolveDependencies( MavenProject project, RepositorySystemSession session )
    {
        DependencyResolutionResult resolutionResult = null;

        try
        {
            DefaultDependencyResolutionRequest resolution = new DefaultDependencyResolutionRequest( project, session );
            resolutionResult = dependencyResolver.resolve( resolution );
        }
        catch ( DependencyResolutionException e )
        {
            resolutionResult = e.getResult();
        }

        Set<Artifact> artifacts = new LinkedHashSet<Artifact>();
        if ( resolutionResult.getDependencyGraph() != null )
        {
            RepositoryUtils.toArtifacts( artifacts, resolutionResult.getDependencyGraph().getChildren(),
                                         Collections.singletonList( project.getArtifact().getId() ), null );

            // Maven 2.x quirk: an artifact always points at the local repo, regardless whether resolved or not
            LocalRepositoryManager lrm = session.getLocalRepositoryManager();
            for ( Artifact artifact : artifacts )
            {
                if ( !artifact.isResolved() )
                {
                    String path = lrm.getPathForLocalArtifact( RepositoryUtils.toArtifact( artifact ) );
                    artifact.setFile( new File( lrm.getRepository().getBasedir(), path ) );
                }
            }
        }
        project.setResolvedArtifacts( artifacts );
        project.setArtifacts( artifacts );

        return resolutionResult;
    }
3624#private List<String> getProfileIds( List<Profile> profiles )
    {
        List<String> ids = new ArrayList<String>( profiles.size() );

        for ( Profile profile : profiles )
        {
            ids.add( profile.getId() );
        }

        return ids;
    }
3625#private ModelBuildingRequest getModelBuildingRequest( InternalConfig config )
    {
        ProjectBuildingRequest configuration = config.request;

        ModelBuildingRequest request = new DefaultModelBuildingRequest();

        RequestTrace trace = DefaultRequestTrace.newChild( null, configuration ).newChild( request );

        ModelResolver resolver =
            new ProjectModelResolver( config.session, trace, repoSystem, repositoryManager, config.repositories,
                                      configuration.getRepositoryMerging(), config.modelPool );

        request.setValidationLevel( configuration.getValidationLevel() );
        request.setProcessPlugins( configuration.isProcessPlugins() );
        request.setProfiles( configuration.getProfiles() );
        request.setActiveProfileIds( configuration.getActiveProfileIds() );
        request.setInactiveProfileIds( configuration.getInactiveProfileIds() );
        request.setSystemProperties( configuration.getSystemProperties() );
        request.setUserProperties( configuration.getUserProperties() );
        request.setBuildStartTime( configuration.getBuildStartTime() );
        request.setModelResolver( resolver );
        request.setModelCache( config.modelCache );

        return request;
    }
3626#public ProjectBuildingResult build( Artifact artifact, ProjectBuildingRequest request )
        throws ProjectBuildingException
    {
        return build( artifact, false, request );
    }
3627#public ProjectBuildingResult build( Artifact artifact, boolean allowStubModel, ProjectBuildingRequest request )
        throws ProjectBuildingException
    {
        org.sonatype.aether.artifact.Artifact pomArtifact = RepositoryUtils.toArtifact( artifact );
        pomArtifact = ArtifactDescriptorUtils.toPomArtifact( pomArtifact );

        InternalConfig config = new InternalConfig( request, null, null );

        boolean localProject;

        try
        {
            ArtifactRequest pomRequest = new ArtifactRequest();
            pomRequest.setArtifact( pomArtifact );
            pomRequest.setRepositories( config.repositories );
            ArtifactResult pomResult = repoSystem.resolveArtifact( config.session, pomRequest );

            pomArtifact = pomResult.getArtifact();
            localProject = pomResult.getRepository() instanceof WorkspaceRepository;
        }
        catch ( org.sonatype.aether.resolution.ArtifactResolutionException e )
        {
            if ( e.getResults().get( 0 ).isMissing() && allowStubModel )
            {
                return build( null, createStubModelSource( artifact ), config );
            }
            throw new ProjectBuildingException( artifact.getId(),
                                                "Error resolving project artifact: " + e.getMessage(), e );
        }

        File pomFile = pomArtifact.getFile();

        if ( "pom".equals( artifact.getType() ) )
        {
            artifact.selectVersion( pomArtifact.getVersion() );
            artifact.setFile( pomFile );
            artifact.setResolved( true );
        }

        return build( localProject ? pomFile : null, new FileModelSource( pomFile ), config );
    }
3628#private ModelSource createStubModelSource( Artifact artifact )
    {
        StringBuilder buffer = new StringBuilder( 1024 );

        buffer.append( "<?xml version='1.0'?>" );
        buffer.append( "<project>" );
        buffer.append( "<modelVersion>4.0.0</modelVersion>" );
        buffer.append( "<groupId>" ).append( artifact.getGroupId() ).append( "</groupId>" );
        buffer.append( "<artifactId>" ).append( artifact.getArtifactId() ).append( "</artifactId>" );
        buffer.append( "<version>" ).append( artifact.getBaseVersion() ).append( "</version>" );
        buffer.append( "<packaging>" ).append( artifact.getType() ).append( "</packaging>" );
        buffer.append( "</project>" );

        return new StringModelSource( buffer, artifact.getId() );
    }
3629#public List<ProjectBuildingResult> build( List<File> pomFiles, boolean recursive, ProjectBuildingRequest request )
        throws ProjectBuildingException
    {
        List<ProjectBuildingResult> results = new ArrayList<ProjectBuildingResult>();

        List<InterimResult> interimResults = new ArrayList<InterimResult>();

        ReactorModelPool modelPool = new ReactorModelPool();

        ReactorModelCache modelCache = new ReactorModelCache();

        InternalConfig config = new InternalConfig( request, modelPool, modelCache );

        Map<String, MavenProject> projectIndex = new HashMap<String, MavenProject>( 256 );

        boolean noErrors =
            build( results, interimResults, projectIndex, pomFiles, new LinkedHashSet<File>(), true, recursive, config );

        populateReactorModelPool( modelPool, interimResults );

        ClassLoader oldContextClassLoader = Thread.currentThread().getContextClassLoader();

        try
        {
            noErrors =
                build( results, new ArrayList<MavenProject>(), projectIndex, interimResults, request,
                       new HashMap<File, Boolean>() ) && noErrors;
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( oldContextClassLoader );
        }

        if ( !noErrors )
        {
            throw new ProjectBuildingException( results );
        }

        return results;
    }
3630#private boolean build( List<ProjectBuildingResult> results, List<InterimResult> interimResults,
                           Map<String, MavenProject> projectIndex, List<File> pomFiles, Set<File> aggregatorFiles,
                           boolean isRoot, boolean recursive, InternalConfig config )
    {
        boolean noErrors = true;

        for ( File pomFile : pomFiles )
        {
            aggregatorFiles.add( pomFile );

            if ( !build( results, interimResults, projectIndex, pomFile, aggregatorFiles, isRoot, recursive, config ) )
            {
                noErrors = false;
            }

            aggregatorFiles.remove( pomFile );
        }

        return noErrors;
    }
3631#private boolean build( List<ProjectBuildingResult> results, List<InterimResult> interimResults,
                           Map<String, MavenProject> projectIndex, File pomFile, Set<File> aggregatorFiles,
                           boolean isRoot, boolean recursive, InternalConfig config )
    {
        boolean noErrors = true;

        ModelBuildingRequest request = getModelBuildingRequest( config );

        MavenProject project = new MavenProject( repositorySystem, this, config.request, logger );

        request.setPomFile( pomFile );
        request.setTwoPhaseBuilding( true );
        request.setLocationTracking( true );

        DefaultModelBuildingListener listener =
            new DefaultModelBuildingListener( project, projectBuildingHelper, config.request );
        request.setModelBuildingListener( listener );

        try
        {
            ModelBuildingResult result = modelBuilder.build( request );

            Model model = result.getEffectiveModel();

            projectIndex.put( result.getModelIds().get( 0 ), project );

            InterimResult interimResult = new InterimResult( pomFile, request, result, listener, isRoot );
            interimResults.add( interimResult );

            if ( recursive && !model.getModules().isEmpty() )
            {
                File basedir = pomFile.getParentFile();

                List<File> moduleFiles = new ArrayList<File>();

                for ( String module : model.getModules() )
                {
                    if ( StringUtils.isEmpty( module ) )
                    {
                        continue;
                    }

                    module = module.replace( '\\', File.separatorChar ).replace( '/', File.separatorChar );

                    File moduleFile = new File( basedir, module );

                    if ( moduleFile.isDirectory() )
                    {
                        moduleFile = modelProcessor.locatePom( moduleFile );
                    }

                    if ( !moduleFile.isFile() )
                    {
                        ModelProblem problem =
                            new DefaultModelProblem( "Child module " + moduleFile + " of " + pomFile
                                + " does not exist", ModelProblem.Severity.ERROR, model, -1, -1, null );
                        result.getProblems().add( problem );

                        noErrors = false;

                        continue;
                    }

                    if ( Os.isFamily( Os.FAMILY_WINDOWS ) )
                    {
                        // we don't canonicalize on unix to avoid interfering with symlinks
                        try
                        {
                            moduleFile = moduleFile.getCanonicalFile();
                        }
                        catch ( IOException e )
                        {
                            moduleFile = moduleFile.getAbsoluteFile();
                        }
                    }
                    else
                    {
                        moduleFile = new File( moduleFile.toURI().normalize() );
                    }

                    if ( aggregatorFiles.contains( moduleFile ) )
                    {
                        StringBuilder buffer = new StringBuilder( 256 );
                        for ( File aggregatorFile : aggregatorFiles )
                        {
                            buffer.append( aggregatorFile ).append( " -> " );
                        }
                        buffer.append( moduleFile );

                        ModelProblem problem =
                            new DefaultModelProblem( "Child module " + moduleFile + " of " + pomFile
                                + " forms aggregation cycle " + buffer, ModelProblem.Severity.ERROR, model, -1, -1,
                                                     null );
                        result.getProblems().add( problem );

                        noErrors = false;

                        continue;
                    }

                    moduleFiles.add( moduleFile );
                }

                interimResult.modules = new ArrayList<InterimResult>();

                if ( !build( results, interimResult.modules, projectIndex, moduleFiles, aggregatorFiles, false,
                             recursive, config ) )
                {
                    noErrors = false;
                }
            }
        }
        catch ( ModelBuildingException e )
        {
            results.add( new DefaultProjectBuildingResult( e.getModelId(), pomFile, e.getProblems() ) );

            noErrors = false;
        }

        return noErrors;
    }
3632#private void populateReactorModelPool( ReactorModelPool reactorModelPool, List<InterimResult> interimResults )
    {
        for ( InterimResult interimResult : interimResults )
        {
            Model model = interimResult.result.getEffectiveModel();
            reactorModelPool.put( model.getGroupId(), model.getArtifactId(), model.getVersion(), model.getPomFile() );

            populateReactorModelPool( reactorModelPool, interimResult.modules );
        }
    }
3633#private boolean build( List<ProjectBuildingResult> results, List<MavenProject> projects,
                           Map<String, MavenProject> projectIndex, List<InterimResult> interimResults,
                           ProjectBuildingRequest request, Map<File, Boolean> profilesXmls )
    {
        boolean noErrors = true;

        for ( InterimResult interimResult : interimResults )
        {
            try
            {
                ModelBuildingResult result = modelBuilder.build( interimResult.request, interimResult.result );

                MavenProject project = interimResult.listener.getProject();
                initProject( project, projectIndex, result, profilesXmls );

                List<MavenProject> modules = new ArrayList<MavenProject>();
                noErrors =
                    build( results, modules, projectIndex, interimResult.modules, request, profilesXmls ) && noErrors;

                projects.addAll( modules );
                projects.add( project );

                project.setExecutionRoot( interimResult.root );
                project.setCollectedProjects( modules );

                results.add( new DefaultProjectBuildingResult( project, result.getProblems(), null ) );
            }
            catch ( ModelBuildingException e )
            {
                results.add( new DefaultProjectBuildingResult( e.getModelId(), interimResult.pomFile, e.getProblems() ) );

                noErrors = false;
            }
        }

        return noErrors;
    }
3634#private void initProject( MavenProject project, Map<String, MavenProject> projects, ModelBuildingResult result,
                              Map<File, Boolean> profilesXmls )
    {
        Model model = result.getEffectiveModel();

        project.setModel( model );
        project.setOriginalModel( result.getRawModel() );

        project.setFile( model.getPomFile() );

        File parentPomFile = result.getRawModel( result.getModelIds().get( 1 ) ).getPomFile();
        project.setParentFile( parentPomFile );

        project.setParent( projects.get( result.getModelIds().get( 1 ) ) );

        Artifact projectArtifact =
            repositorySystem.createArtifact( project.getGroupId(), project.getArtifactId(), project.getVersion(), null,
                                             project.getPackaging() );
        project.setArtifact( projectArtifact );

        if ( project.getFile() != null )
        {
            Build build = project.getBuild();
            project.addScriptSourceRoot( build.getScriptSourceDirectory() );
            project.addCompileSourceRoot( build.getSourceDirectory() );
            project.addTestCompileSourceRoot( build.getTestSourceDirectory() );
        }

        List<Profile> activeProfiles = new ArrayList<Profile>();
        activeProfiles.addAll( result.getActivePomProfiles( result.getModelIds().get( 0 ) ) );
        activeProfiles.addAll( result.getActiveExternalProfiles() );
        project.setActiveProfiles( activeProfiles );

        project.setInjectedProfileIds( "external", getProfileIds( result.getActiveExternalProfiles() ) );
        for ( String modelId : result.getModelIds() )
        {
            project.setInjectedProfileIds( modelId, getProfileIds( result.getActivePomProfiles( modelId ) ) );
        }

        String modelId = findProfilesXml( result, profilesXmls );
        if ( modelId != null )
        {
            ModelProblem problem =
                new DefaultModelProblem( "Detected profiles.xml alongside " + modelId
                    + ", this file is no longer supported and was ignored" + ", please use the settings.xml instead",
                                         ModelProblem.Severity.WARNING, model, -1, -1, null );
            result.getProblems().add( problem );
        }
    }
3635#private String findProfilesXml( ModelBuildingResult result, Map<File, Boolean> profilesXmls )
    {
        for ( String modelId : result.getModelIds() )
        {
            Model model = result.getRawModel( modelId );

            File basedir = model.getProjectDirectory();
            if ( basedir == null )
            {
                break;
            }

            Boolean profilesXml = profilesXmls.get( basedir );
            if ( profilesXml == null )
            {
                profilesXml = Boolean.valueOf( new File( basedir, "profiles.xml" ).exists() );
                profilesXmls.put( basedir, profilesXml );
            }
            if ( profilesXml.booleanValue() )
            {
                return modelId;
            }
        }

        return null;
    }
3636#InterimResult( File pomFile, ModelBuildingRequest request, ModelBuildingResult result,
                       DefaultModelBuildingListener listener, boolean root )
        {
            this.pomFile = pomFile;
            this.request = request;
            this.result = result;
            this.listener = listener;
            this.root = root;
        }
3637#public InternalConfig( ProjectBuildingRequest request, ReactorModelPool modelPool, ReactorModelCache modelCache )
        {
            this.request = request;
            this.modelPool = modelPool;
            this.modelCache = modelCache;
            session =
                LegacyLocalRepositoryManager.overlay( request.getLocalRepository(), request.getRepositorySession(),
                                                      repoSystem );
            repositories = RepositoryUtils.toRepos( request.getRemoteRepositories() );
        }
3638#public List<ArtifactRepository> createArtifactRepositories( List<Repository> pomRepositories,
                                                                List<ArtifactRepository> externalRepositories,
                                                                ProjectBuildingRequest request )
        throws InvalidRepositoryException
    {
        List<ArtifactRepository> internalRepositories = new ArrayList<ArtifactRepository>();

        for ( Repository repository : pomRepositories )
        {
            internalRepositories.add( repositorySystem.buildArtifactRepository( repository ) );
        }

        repositorySystem.injectMirror( request.getRepositorySession(), internalRepositories );

        repositorySystem.injectProxy( request.getRepositorySession(), internalRepositories );

        repositorySystem.injectAuthentication( request.getRepositorySession(), internalRepositories );

        List<ArtifactRepository> dominantRepositories;
        List<ArtifactRepository> recessiveRepositories;

        if ( ProjectBuildingRequest.RepositoryMerging.REQUEST_DOMINANT.equals( request.getRepositoryMerging() ) )
        {
            dominantRepositories = externalRepositories;
            recessiveRepositories = internalRepositories;
        }
        else
        {
            dominantRepositories = internalRepositories;
            recessiveRepositories = externalRepositories;
        }

        List<ArtifactRepository> artifactRepositories = new ArrayList<ArtifactRepository>();
        Collection<String> repoIds = new HashSet<String>();

        if ( dominantRepositories != null )
        {
            for ( ArtifactRepository repository : dominantRepositories )
            {
                repoIds.add( repository.getId() );
                artifactRepositories.add( repository );
            }
        }

        if ( recessiveRepositories != null )
        {
            for ( ArtifactRepository repository : recessiveRepositories )
            {
                if ( repoIds.add( repository.getId() ) )
                {
                    artifactRepositories.add( repository );
                }
            }
        }

        artifactRepositories = repositorySystem.getEffectiveRepositories( artifactRepositories );

        return artifactRepositories;
    }
3639#public synchronized ProjectRealmCache.CacheRecord createProjectRealm( MavenProject project, Model model,
                                                                          ProjectBuildingRequest request )
        throws PluginResolutionException, PluginVersionResolutionException
    {
        ClassRealm projectRealm = null;

        List<Plugin> extensionPlugins = new ArrayList<Plugin>();

        Build build = model.getBuild();

        if ( build != null )
        {
            for ( Extension extension : build.getExtensions() )
            {
                Plugin plugin = new Plugin();
                plugin.setGroupId( extension.getGroupId() );
                plugin.setArtifactId( extension.getArtifactId() );
                plugin.setVersion( extension.getVersion() );
                extensionPlugins.add( plugin );
            }

            for ( Plugin plugin : build.getPlugins() )
            {
                if ( plugin.isExtensions() )
                {
                    extensionPlugins.add( plugin );
                }
            }
        }

        if ( extensionPlugins.isEmpty() )
        {
            if ( logger.isDebugEnabled() )
            {
                logger.debug( "Extension realms for project " + model.getId() + ": (none)" );
            }

            return new ProjectRealmCache.CacheRecord( null, null );
        }

        List<ClassRealm> extensionRealms = new ArrayList<ClassRealm>();

        Map<ClassRealm, List<String>> exportedPackages = new HashMap<ClassRealm, List<String>>();

        Map<ClassRealm, List<String>> exportedArtifacts = new HashMap<ClassRealm, List<String>>();

        List<Artifact> publicArtifacts = new ArrayList<Artifact>();

        for ( Plugin plugin : extensionPlugins )
        {
            if ( plugin.getVersion() == null )
            {
                PluginVersionRequest versionRequest =
                    new DefaultPluginVersionRequest( plugin, request.getRepositorySession(),
                                                     project.getRemotePluginRepositories() );
                plugin.setVersion( pluginVersionResolver.resolve( versionRequest ).getVersion() );
            }

            List<Artifact> artifacts;

            PluginArtifactsCache.Key cacheKey =
                pluginArtifactsCache.createKey( plugin, null, project.getRemotePluginRepositories(),
                                                request.getRepositorySession() );

            PluginArtifactsCache.CacheRecord recordArtifacts = pluginArtifactsCache.get( cacheKey );

            if ( recordArtifacts != null )
            {
                artifacts = recordArtifacts.artifacts;
            }
            else
            {
                try
                {
                    artifacts = resolveExtensionArtifacts( plugin, project.getRemotePluginRepositories(), request );

                    recordArtifacts = pluginArtifactsCache.put( cacheKey, artifacts );
                }
                catch ( PluginResolutionException e )
                {
                    pluginArtifactsCache.put( cacheKey, e );

                    pluginArtifactsCache.register( project, recordArtifacts );

                    throw e;
                }
            }

            pluginArtifactsCache.register( project, recordArtifacts );

            ClassRealm extensionRealm;
            ExtensionDescriptor extensionDescriptor = null;

            ExtensionRealmCache.CacheRecord recordRealm = extensionRealmCache.get( artifacts );

            if ( recordRealm != null )
            {
                extensionRealm = recordRealm.realm;
                extensionDescriptor = recordRealm.desciptor;
            }
            else
            {
                extensionRealm = classRealmManager.createExtensionRealm( plugin, artifacts );

                try
                {
                    container.discoverComponents( extensionRealm );
                }
                catch ( Exception e )
                {
                    throw new IllegalStateException( "Failed to discover components in extension realm "
                        + extensionRealm.getId(), e );
                }

                Artifact extensionArtifact = artifacts.get( 0 );
                try
                {
                    extensionDescriptor = extensionDescriptorBuilder.build( extensionArtifact.getFile() );
                }
                catch ( IOException e )
                {
                    String message = "Invalid extension descriptor for " + plugin.getId() + ": " + e.getMessage();
                    if ( logger.isDebugEnabled() )
                    {
                        logger.error( message, e );
                    }
                    else
                    {
                        logger.error( message );
                    }
                }

                recordRealm = extensionRealmCache.put( artifacts, extensionRealm, extensionDescriptor );
            }

            extensionRealmCache.register( project, recordRealm );

            extensionRealms.add( extensionRealm );
            if ( extensionDescriptor != null )
            {
                exportedPackages.put( extensionRealm, extensionDescriptor.getExportedPackages() );
                exportedArtifacts.put( extensionRealm, extensionDescriptor.getExportedArtifacts() );
            }

            if ( !plugin.isExtensions() && artifacts.size() == 2 && artifacts.get( 0 ).getFile() != null
                && "plexus-utils".equals( artifacts.get( 1 ).getArtifactId() ) )
            {
                /*
                 * This is purely for backward-compat with 2.x where <extensions> consisting of a single artifact where
                 * loaded into the core and hence available to plugins, in contrast to bigger extensions that were
                 * loaded into a dedicated realm which is invisible to plugins (MNG-2749).
                 */
                publicArtifacts.add( artifacts.get( 0 ) );
            }
        }

        if ( logger.isDebugEnabled() )
        {
            logger.debug( "Extension realms for project " + model.getId() + ": " + extensionRealms );
        }

        ProjectRealmCache.CacheRecord record = projectRealmCache.get( extensionRealms );

        if ( record == null )
        {
            projectRealm = classRealmManager.createProjectRealm( model, publicArtifacts );

            Set<String> exclusions = new LinkedHashSet<String>();

            for ( ClassRealm extensionRealm : extensionRealms )
            {
                List<String> excludes = exportedArtifacts.get( extensionRealm );

                if ( excludes != null )
                {
                    exclusions.addAll( excludes );
                }

                List<String> exports = exportedPackages.get( extensionRealm );

                if ( exports == null || exports.isEmpty() )
                {
                    /*
                     * Most existing extensions don't define exported packages, i.e. no classes are to be exposed to
                     * plugins, yet the components provided by the extension (e.g. artifact handlers) must be
                     * accessible, i.e. we still must import the extension realm into the project realm.
                     */
                    exports = Arrays.asList( extensionRealm.getId() );
                }

                for ( String export : exports )
                {
                    projectRealm.importFrom( extensionRealm, export );
                }
            }

            DependencyFilter extensionArtifactFilter = null;
            if ( !exclusions.isEmpty() )
            {
                extensionArtifactFilter = new ExclusionsDependencyFilter( exclusions );
            }

            record = projectRealmCache.put( extensionRealms, projectRealm, extensionArtifactFilter );
        }

        projectRealmCache.register( project, record );

        return record;
    }
3640#private List<Artifact> resolveExtensionArtifacts( Plugin extensionPlugin, List<RemoteRepository> repositories,
                                                      ProjectBuildingRequest request )
        throws PluginResolutionException
    {
        DependencyNode root =
            pluginDependenciesResolver.resolve( extensionPlugin, null, null, repositories,
                                                request.getRepositorySession() );

        PreorderNodeListGenerator nlg = new PreorderNodeListGenerator();
        root.accept( nlg );
        return nlg.getArtifacts( false );
    }
3641#public void selectProjectRealm( MavenProject project )
    {
        ClassLoader projectRealm = project.getClassRealm();

        if ( projectRealm == null )
        {
            projectRealm = classRealmManager.getCoreRealm();
        }

        Thread.currentThread().setContextClassLoader( projectRealm );
    }
3642#private String getExtensionDescriptorLocation()
    {
        return "META-INF/maven/extension.xml";
    }
3643#/**
     * Extracts the extension descriptor (if any) from the specified JAR file.
     * 
     * @param extensionJar The JAR file or directory to extract the descriptor from, must not be {@code null}.
     * @return The extracted descriptor or {@code null} if no descriptor was found.
     * @throws IOException If the descriptor is present but could not be parsed.
     */
    public ExtensionDescriptor build( File extensionJar )
        throws IOException
    {
        ExtensionDescriptor extensionDescriptor = null;

        if ( extensionJar.isFile() )
        {
            JarFile pluginJar = new JarFile( extensionJar, false );
            try
            {
                ZipEntry pluginDescriptorEntry = pluginJar.getEntry( getExtensionDescriptorLocation() );

                if ( pluginDescriptorEntry != null )
                {
                    InputStream is = pluginJar.getInputStream( pluginDescriptorEntry );

                    extensionDescriptor = build( is );
                }
            }
            finally
            {
                pluginJar.close();
            }
        }
        else
        {
            File pluginXml = new File( extensionJar, getExtensionDescriptorLocation() );

            if ( pluginXml.canRead() )
            {
                InputStream is = new BufferedInputStream( new FileInputStream( pluginXml ) );
                try
                {
                    extensionDescriptor = build( is );
                }
                finally
                {
                    IOUtil.close( is );
                }
            }
        }

        return extensionDescriptor;
    }
3644#ExtensionDescriptor build( InputStream is )
        throws IOException
    {
        ExtensionDescriptor extensionDescriptor = new ExtensionDescriptor();

        Xpp3Dom dom;
        try
        {
            dom = Xpp3DomBuilder.build( ReaderFactory.newXmlReader( is ) );
        }
        catch ( XmlPullParserException e )
        {
            throw (IOException) new IOException( e.getMessage() ).initCause( e );
        }
        finally
        {
            IOUtil.close( is );
        }

        if ( !"extension".equals( dom.getName() ) )
        {
            throw new IOException( "Unexpected root element \"" + dom.getName() + "\", expected \"extension\"" );
        }

        extensionDescriptor.setExportedPackages( parseStrings( dom.getChild( "exportedPackages" ) ) );

        extensionDescriptor.setExportedArtifacts( parseStrings( dom.getChild( "exportedArtifacts" ) ) );

        return extensionDescriptor;
    }
3645#private List<String> parseStrings( Xpp3Dom dom )
    {
        List<String> strings = null;

        if ( dom != null )
        {
            strings = new ArrayList<String>();

            for ( Xpp3Dom child : dom.getChildren() )
            {
                String string = child.getValue();
                if ( string != null )
                {
                    string = string.trim();
                    if ( string.length() > 0 )
                    {
                        strings.add( string );
                    }
                }
            }
        }

        return strings;
    }
3646#public MavenProject()
    {
        Model model = new Model();

        model.setGroupId( EMPTY_PROJECT_GROUP_ID );
        model.setArtifactId( EMPTY_PROJECT_ARTIFACT_ID );
        model.setVersion( EMPTY_PROJECT_VERSION );

        setModel( model );
    }
3647#public MavenProject( Model model )
    {
        setModel( model );
    }
3648#/**
     * @deprecated use {@link #clone()} so subclasses can provide a copy of the same class
     */
    @Deprecated
    public MavenProject( MavenProject project )
    {
        repositorySystem = project.repositorySystem;
        logger = project.logger;
        mavenProjectBuilder = project.mavenProjectBuilder;
        projectBuilderConfiguration = project.projectBuilderConfiguration;
        deepCopy( project );
    }
3649#@Deprecated
    public MavenProject( Model model, RepositorySystem repositorySystem )
    {        
        this.repositorySystem = repositorySystem;
        setModel( model );
    }
3650#public File getParentFile()
    {
        return parentFile;
    }
3651#public void setParentFile( File parentFile )
    {
        this.parentFile = parentFile;
    }
3652#/**
     * Constructor
     * 
     * @param repositorySystem - may not be null
     * @param mavenProjectBuilder
     * @param projectBuilderConfiguration
     * @throws InvalidRepositoryException
     */
    MavenProject( RepositorySystem repositorySystem, ProjectBuilder mavenProjectBuilder,
                  ProjectBuildingRequest projectBuilderConfiguration, Logger logger )
    {
        if ( repositorySystem == null )
        {
            throw new IllegalArgumentException( "mavenTools: null" );
        }

        this.mavenProjectBuilder = mavenProjectBuilder;
        this.projectBuilderConfiguration = projectBuilderConfiguration;
        this.repositorySystem = repositorySystem;
        this.logger = logger;
    }
3653#@Deprecated
    public Set<Artifact> createArtifacts( ArtifactFactory artifactFactory, String inheritedScope, ArtifactFilter filter )
        throws InvalidDependencyVersionException
    {
        return MavenMetadataSource.createArtifacts( artifactFactory, getDependencies(), inheritedScope, filter, this );
    }
3654#// TODO: Find a way to use <relativePath/> here...it's tricky, because the moduleProject
    // usually doesn't have a file associated with it yet.
    public String getModulePathAdjustment( MavenProject moduleProject )
        throws IOException
    {
        // FIXME: This is hacky. What if module directory doesn't match artifactid, and parent
        // is coming from the repository??
        String module = moduleProject.getArtifactId();

        File moduleFile = moduleProject.getFile();

        if ( moduleFile != null )
        {
            File moduleDir = moduleFile.getCanonicalFile().getParentFile();

            module = moduleDir.getName();
        }

        if ( moduleAdjustments == null )
        {
            moduleAdjustments = new HashMap<String, String>();

            List<String> modules = getModules();
            if ( modules != null )
            {
                for ( Iterator<String> it = modules.iterator(); it.hasNext(); )
                {
                    String modulePath = it.next();
                    String moduleName = modulePath;

                    if ( moduleName.endsWith( "/" ) || moduleName.endsWith( "\\" ) )
                    {
                        moduleName = moduleName.substring( 0, moduleName.length() - 1 );
                    }

                    int lastSlash = moduleName.lastIndexOf( '/' );

                    if ( lastSlash < 0 )
                    {
                        lastSlash = moduleName.lastIndexOf( '\\' );
                    }

                    String adjustment = null;

                    if ( lastSlash > -1 )
                    {
                        moduleName = moduleName.substring( lastSlash + 1 );
                        adjustment = modulePath.substring( 0, lastSlash );
                    }

                    moduleAdjustments.put( moduleName, adjustment );
                }
            }
        }

        return moduleAdjustments.get( module );
    }
3655#// ----------------------------------------------------------------------
    // Accessors
    // ----------------------------------------------------------------------

    public Artifact getArtifact()
    {
        return artifact;
    }
3656#public void setArtifact( Artifact artifact )
    {
        this.artifact = artifact;
    }
3657#//@todo I would like to get rid of this. jvz.
    public Model getModel()
    {
        return model;
    }
3658#public MavenProject getParent()
    {
        if ( parent == null )
        {
            /*
             * TODO: This is suboptimal. Without a cache in the project builder, rebuilding the parent chain currently
             * causes O(n^2) parser invocations for an inheritance hierarchy of depth n.
             */
            if ( parentFile != null )
            {
                checkProjectBuildingRequest();
                ProjectBuildingRequest request = new DefaultProjectBuildingRequest( projectBuilderConfiguration );
                request.setRemoteRepositories( getRemoteArtifactRepositories() );

                try
                {
                    parent = mavenProjectBuilder.build( parentFile, request ).getProject();
                }
                catch ( ProjectBuildingException e )
                {
                    throw new IllegalStateException( "Failed to build parent project for " + getId(), e );
                }
            }
            else if ( model.getParent() != null )
            {
                checkProjectBuildingRequest();
                ProjectBuildingRequest request = new DefaultProjectBuildingRequest( projectBuilderConfiguration );
                request.setRemoteRepositories( getRemoteArtifactRepositories() );

                try
                {
                    parent = mavenProjectBuilder.build( getParentArtifact(), request ).getProject();
                }
                catch ( ProjectBuildingException e )
                {
                    throw new IllegalStateException( "Failed to build parent project for " + getId(), e );
                }
            }
        }
        return parent;
    }
3659#public void setParent( MavenProject parent )
    {
        this.parent = parent;
    }
3660#public boolean hasParent()
    {
        return getParent() != null;
    }
3661#public File getFile()
    {
        return file;
    }
3662#public void setFile( File file )
    {
        this.file = file;
    }
3663#public File getBasedir()
    {
        if ( getFile() != null )
        {
            return getFile().getParentFile();
        }
        else
        {
            // repository based POM
            return null;
        }
    }
3664#public void setDependencies( List<Dependency> dependencies )
    {
        getModel().setDependencies( dependencies );
    }
3665#public List<Dependency> getDependencies()
    {
        return getModel().getDependencies();
    }
3666#public DependencyManagement getDependencyManagement()
    {
        return getModel().getDependencyManagement();
    }
3667#// ----------------------------------------------------------------------
    // Test and compile sourceroots.
    // ----------------------------------------------------------------------

    private void addPath( List<String> paths, String path )
    {
        if ( path != null )
        {
            path = path.trim();
            if ( path.length() > 0 )
            {
                File file = new File( path );
                if ( file.isAbsolute() )
                {
                    path = file.getAbsolutePath();
                }
                else
                {
                    path = new File( getBasedir(), path ).getAbsolutePath();
                }

                if ( !paths.contains( path ) )
                {
                    paths.add( path );
                }
            }
        }
    }
3668#public void addCompileSourceRoot( String path )
    {
        addPath( getCompileSourceRoots(), path );
    }
3669#public void addScriptSourceRoot( String path )
    {
        if ( path != null )
        {
            path = path.trim();
            if ( path.length() != 0 )
            {
                if ( !getScriptSourceRoots().contains( path ) )
                {
                    getScriptSourceRoots().add( path );
                }
            }
        }
    }
3670#public void addTestCompileSourceRoot( String path )
    {
        addPath( getTestCompileSourceRoots(), path );
    }
3671#public List<String> getCompileSourceRoots()
    {
        return compileSourceRoots;
    }
3672#public List<String> getScriptSourceRoots()
    {
        return scriptSourceRoots;
    }
3673#public List<String> getTestCompileSourceRoots()
    {
        return testCompileSourceRoots;
    }
3674#public List<String> getCompileClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );

        list.add( getBuild().getOutputDirectory() );

        for ( Artifact a : getArtifacts() )
        {                        
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO: let the scope handler deal with this
                if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() ) || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    addArtifactPath( a, list );
                }
            }
        }

        return list;
    }
3675#@Deprecated
    public List<Artifact> getCompileArtifacts()
    {
        List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );

        for ( Artifact a : getArtifacts() )
        {
            // TODO: classpath check doesn't belong here - that's the other method
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO: let the scope handler deal with this
                if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() ) || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    list.add( a );
                }
            }
        }
        return list;
    }
3676#@Deprecated
    public List<Dependency> getCompileDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );

        for ( Artifact a : getArtifacts()  )
        {
            // TODO: let the scope handler deal with this
            if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_PROVIDED.equals( a.getScope() ) || Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return list;
    }
3677#//TODO: this checking for file == null happens because the resolver has been confused about the root
    // artifact or not. things like the stupid dummy artifact coming from surefire.
    public List<String> getTestClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<String>( getArtifacts().size() + 2 );

        list.add( getBuild().getTestOutputDirectory() );

        list.add( getBuild().getOutputDirectory() );
        
        for ( Artifact a : getArtifacts() )
        {            
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {                
                addArtifactPath( a, list );
            }
        }

        return list;
    }
3678#@Deprecated
    public List<Artifact> getTestArtifacts()
    {
        List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );

        for ( Artifact a : getArtifacts() )
        {
            // TODO: classpath check doesn't belong here - that's the other method
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                list.add( a );
            }
        }
        return list;
    }
3679#@Deprecated
    public List<Dependency> getTestDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );

        for ( Artifact a : getArtifacts()  )
        {
            Dependency dependency = new Dependency();

            dependency.setArtifactId( a.getArtifactId() );
            dependency.setGroupId( a.getGroupId() );
            dependency.setVersion( a.getVersion() );
            dependency.setScope( a.getScope() );
            dependency.setType( a.getType() );
            dependency.setClassifier( a.getClassifier() );

            list.add( dependency );
        }
        return list;
    }
3680#public List<String> getRuntimeClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );

        list.add( getBuild().getOutputDirectory() );

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO: let the scope handler deal with this
                if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) )
                {
                    addArtifactPath( a, list );
                }
            }
        }
        return list;
    }
3681#@Deprecated
    public List<Artifact> getRuntimeArtifacts()
    {
        List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );

        for ( Artifact a : getArtifacts()  )
        {
            // TODO: classpath check doesn't belong here - that's the other method
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO: let the scope handler deal with this
                if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) )
                {
                    list.add( a );
                }
            }
        }
        return list;
    }
3682#@Deprecated
    public List<Dependency> getRuntimeDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );

        for ( Artifact a : getArtifacts()  )
        {
            // TODO: let the scope handler deal with this
            if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return list;
    }
3683#public List<String> getSystemClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<String>( getArtifacts().size() );

        list.add( getBuild().getOutputDirectory() );

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO: let the scope handler deal with this
                if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    addArtifactPath( a, list );
                }
            }
        }
        return list;
    }
3684#@Deprecated
    public List<Artifact> getSystemArtifacts()
    {
        List<Artifact> list = new ArrayList<Artifact>( getArtifacts().size() );

        for ( Artifact a : getArtifacts()  )
        {
            // TODO: classpath check doesn't belong here - that's the other method
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO: let the scope handler deal with this
                if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    list.add( a );
                }
            }
        }
        return list;
    }
3685#@Deprecated
    public List<Dependency> getSystemDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );

        for ( Artifact a : getArtifacts()  )
        {
            // TODO: let the scope handler deal with this
            if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return list;
    }
3686#// ----------------------------------------------------------------------
    // Delegate to the model
    // ----------------------------------------------------------------------

    public void setModelVersion( String pomVersion )
    {
        getModel().setModelVersion( pomVersion );
    }
3687#public String getModelVersion()
    {
        return getModel().getModelVersion();
    }
3688#public String getId()
    {
        return getModel().getId();
    }
3689#public void setGroupId( String groupId )
    {
        getModel().setGroupId( groupId );
    }
3690#public String getGroupId()
    {
        String groupId = getModel().getGroupId();

        if ( ( groupId == null ) && ( getModel().getParent() != null ) )
        {
            groupId = getModel().getParent().getGroupId();
        }

        return groupId;
    }
3691#public void setArtifactId( String artifactId )
    {
        getModel().setArtifactId( artifactId );
    }
3692#public String getArtifactId()
    {
        return getModel().getArtifactId();
    }
3693#public void setName( String name )
    {
        getModel().setName( name );
    }
3694#public String getName()
    {
        // TODO: this should not be allowed to be null.
        if ( getModel().getName() != null )
        {
            return getModel().getName();
        }
        else
        {
            return getArtifactId();
        }
    }
3695#public void setVersion( String version )
    {
        getModel().setVersion( version );
    }
3696#public String getVersion()
    {
        String version = getModel().getVersion();

        if ( ( version == null ) && ( getModel().getParent() != null ) )
        {
            version = getModel().getParent().getVersion();
        }

        return version;
    }
3697#public String getPackaging()
    {
        return getModel().getPackaging();
    }
3698#public void setPackaging( String packaging )
    {
        getModel().setPackaging( packaging );
    }
3699#public void setInceptionYear( String inceptionYear )
    {
        getModel().setInceptionYear( inceptionYear );
    }
3700#public String getInceptionYear()
    {
        return getModel().getInceptionYear();
    }
3701#public void setUrl( String url )
    {
        getModel().setUrl( url );
    }
3702#public String getUrl()
    {
        return getModel().getUrl();
    }
3703#public Prerequisites getPrerequisites()
    {
        return getModel().getPrerequisites();
    }
3704#public void setIssueManagement( IssueManagement issueManagement )
    {
        getModel().setIssueManagement( issueManagement );
    }
3705#public CiManagement getCiManagement()
    {
        return getModel().getCiManagement();
    }
3706#public void setCiManagement( CiManagement ciManagement )
    {
        getModel().setCiManagement( ciManagement );
    }
3707#public IssueManagement getIssueManagement()
    {
        return getModel().getIssueManagement();
    }
3708#public void setDistributionManagement( DistributionManagement distributionManagement )
    {
        getModel().setDistributionManagement( distributionManagement );
    }
3709#public DistributionManagement getDistributionManagement()
    {
        return getModel().getDistributionManagement();
    }
3710#public void setDescription( String description )
    {
        getModel().setDescription( description );
    }
3711#public String getDescription()
    {
        return getModel().getDescription();
    }
3712#public void setOrganization( Organization organization )
    {
        getModel().setOrganization( organization );
    }
3713#public Organization getOrganization()
    {
        return getModel().getOrganization();
    }
3714#public void setScm( Scm scm )
    {
        getModel().setScm( scm );
    }
3715#public Scm getScm()
    {
        return getModel().getScm();
    }
3716#public void setMailingLists( List<MailingList> mailingLists )
    {
        getModel().setMailingLists( mailingLists );
    }
3717#public List<MailingList> getMailingLists()
    {
        return getModel().getMailingLists();
    }
3718#public void addMailingList( MailingList mailingList )
    {
        getModel().addMailingList( mailingList );
    }
3719#public void setDevelopers( List<Developer> developers )
    {
        getModel().setDevelopers( developers );
    }
3720#public List<Developer> getDevelopers()
    {
        return getModel().getDevelopers();
    }
3721#public void addDeveloper( Developer developer )
    {
        getModel().addDeveloper( developer );
    }
3722#public void setContributors( List<Contributor> contributors )
    {
        getModel().setContributors( contributors );
    }
3723#public List<Contributor> getContributors()
    {
        return getModel().getContributors();
    }
3724#public void addContributor( Contributor contributor )
    {
        getModel().addContributor( contributor );
    }
3725#public void setBuild( Build build )
    {
        getModel().setBuild( build );
    }
3726#public Build getBuild()
    {
        return getModelBuild();
    }
3727#public List<Resource> getResources()
    {
        return getBuild().getResources();
    }
3728#public List<Resource> getTestResources()
    {
        return getBuild().getTestResources();
    }
3729#public void addResource( Resource resource )
    {
        getBuild().addResource( resource );
    }
3730#public void addTestResource( Resource testResource )
    {
        getBuild().addTestResource( testResource );
    }
3731#@Deprecated
    public void setReporting( Reporting reporting )
    {
        getModel().setReporting( reporting );
    }
3732#@Deprecated
    public Reporting getReporting()
    {
        return getModel().getReporting();
    }
3733#public void setLicenses( List<License> licenses )
    {
        getModel().setLicenses( licenses );
    }
3734#public List<License> getLicenses()
    {
        return getModel().getLicenses();
    }
3735#public void addLicense( License license )
    {
        getModel().addLicense( license );
    }
3736#public void setArtifacts( Set<Artifact> artifacts )
    {
        this.artifacts = artifacts;

        // flush the calculated artifactMap
        artifactMap = null;
    }
3737#/**
     * All dependencies that this project has, including transitive ones. Contents are lazily
     * populated, so depending on what phases have run dependencies in some scopes won't be
     * included. eg. if only compile phase has run, dependencies with scope test won't be included.
     * 
     * @return {@link Set} &lt; {@link Artifact} >
     * @see #getDependencyArtifacts() to get only direct dependencies
     */
    public Set<Artifact> getArtifacts()
    {
        if ( artifacts == null )
        {
            if ( artifactFilter == null || resolvedArtifacts == null )
            {
                artifacts = new LinkedHashSet<Artifact>();
            }
            else
            {
                artifacts = new LinkedHashSet<Artifact>( resolvedArtifacts.size() * 2 );
                for ( Artifact artifact : resolvedArtifacts )
                {
                    if ( artifactFilter.include( artifact ) )
                    {
                        artifacts.add( artifact );
                    }
                }
            }
        }
        return artifacts;
    }
3738#public Map<String, Artifact> getArtifactMap()
    {
        if ( artifactMap == null )
        {
            artifactMap = ArtifactUtils.artifactMapByVersionlessId( getArtifacts() );
        }
        return artifactMap;
    }
3739#public void setPluginArtifacts( Set<Artifact> pluginArtifacts )
    {
        this.pluginArtifacts = pluginArtifacts;

        this.pluginArtifactMap = null;
    }
3740#public Set<Artifact> getPluginArtifacts()
    {
        if ( pluginArtifacts != null )
        {
            return pluginArtifacts;
        }

        pluginArtifacts = new HashSet<Artifact>();

        if ( repositorySystem != null )
        {
            for ( Plugin p : getBuildPlugins() )
            {
                Artifact artifact = repositorySystem.createPluginArtifact( p );

                if ( artifact != null )
                {
                    pluginArtifacts.add( artifact );
                }
            }
        }

        pluginArtifactMap = null;

        return pluginArtifacts;
    }
3741#public Map<String, Artifact> getPluginArtifactMap()
    {
        if ( pluginArtifactMap == null )
        {
            pluginArtifactMap = ArtifactUtils.artifactMapByVersionlessId( getPluginArtifacts() );
        }

        return pluginArtifactMap;
    }
3742#@Deprecated
    public void setReportArtifacts( Set<Artifact> reportArtifacts )
    {
        this.reportArtifacts = reportArtifacts;

        reportArtifactMap = null;
    }
3743#@Deprecated
    public Set<Artifact> getReportArtifacts()
    {
        if ( reportArtifacts != null )
        {
            return reportArtifacts;
        }

        reportArtifacts = new HashSet<Artifact>();

        if ( repositorySystem != null )
        {
            for ( ReportPlugin p : getReportPlugins() )
            {
                Plugin pp = new Plugin();
                pp.setGroupId( p.getGroupId() );
                pp.setArtifactId( p.getArtifactId() );
                pp.setVersion( p.getVersion() );

                Artifact artifact = repositorySystem.createPluginArtifact( pp );

                if ( artifact != null )
                {
                    reportArtifacts.add( artifact );
                }
            }
        }

        reportArtifactMap = null;

        return reportArtifacts;
    }
3744#@Deprecated
    public Map<String, Artifact> getReportArtifactMap()
    {
        if ( reportArtifactMap == null )
        {
            reportArtifactMap = ArtifactUtils.artifactMapByVersionlessId( getReportArtifacts() );
        }

        return reportArtifactMap;
    }
3745#public void setExtensionArtifacts( Set<Artifact> extensionArtifacts )
    {
        this.extensionArtifacts = extensionArtifacts;

        extensionArtifactMap = null;
    }
3746#public Set<Artifact> getExtensionArtifacts()
    {
        if ( extensionArtifacts != null )
        {
            return extensionArtifacts;
        }
        extensionArtifacts = new HashSet<Artifact>();
        List<Extension> extensions = getBuildExtensions();
        if ( extensions != null )
        {
            for ( Iterator<Extension> i = extensions.iterator(); i.hasNext(); )
            {
                Extension ext = i.next();

                String version;
                if ( StringUtils.isEmpty( ext.getVersion() ) )
                {
                    version = "RELEASE";
                }
                else
                {
                    version = ext.getVersion();
                }

                Artifact artifact = repositorySystem.createArtifact( ext.getGroupId(), ext.getArtifactId(), version, null, "jar" );

                if ( artifact != null )
                {
                    extensionArtifacts.add( artifact );
                }
            }
        }
        extensionArtifactMap = null;
        return extensionArtifacts;
    }
3747#public Map<String, Artifact> getExtensionArtifactMap()
    {
        if ( extensionArtifactMap == null )
        {
            extensionArtifactMap = ArtifactUtils.artifactMapByVersionlessId( getExtensionArtifacts() );
        }

        return extensionArtifactMap;
    }
3748#public void setParentArtifact( Artifact parentArtifact )
    {
        this.parentArtifact = parentArtifact;
    }
3749#public Artifact getParentArtifact()
    {
        if ( parentArtifact == null && model.getParent() != null )
        {
            Parent p = model.getParent();
            parentArtifact = repositorySystem.createProjectArtifact( p.getGroupId(), p.getArtifactId(), p.getVersion() );
        }
        return parentArtifact;
    }
3750#public List<Repository> getRepositories()
    {
        return getModel().getRepositories();
    }
3751#// ----------------------------------------------------------------------
    // Plugins
    // ----------------------------------------------------------------------

    @Deprecated
    public List<ReportPlugin> getReportPlugins()
    {
        if ( getModel().getReporting() == null )
        {
            return Collections.emptyList();
        }
        return getModel().getReporting().getPlugins();

    }
3752#public List<Plugin> getBuildPlugins()
    {
        if ( getModel().getBuild() == null )
        {
            return Collections.emptyList();
        }
        return getModel().getBuild().getPlugins();
    }
3753#public List<String> getModules()
    {
        return getModel().getModules();
    }
3754#public PluginManagement getPluginManagement()
    {
        PluginManagement pluginMgmt = null;

        Build build = getModel().getBuild();
        if ( build != null )
        {
            pluginMgmt = build.getPluginManagement();
        }

        return pluginMgmt;
    }
3755#private Build getModelBuild()
    {
        Build build = getModel().getBuild();

        if ( build == null )
        {
            build = new Build();

            getModel().setBuild( build );
        }

        return build;
    }
3756#public void setRemoteArtifactRepositories( List<ArtifactRepository> remoteArtifactRepositories )
    {
        this.remoteArtifactRepositories = remoteArtifactRepositories;
        this.remoteProjectRepositories = RepositoryUtils.toRepos( getRemoteArtifactRepositories() );
    }
3757#public List<ArtifactRepository> getRemoteArtifactRepositories()
    {
        if ( remoteArtifactRepositories == null )
        {
            remoteArtifactRepositories = new ArrayList<ArtifactRepository>();
        }

        return remoteArtifactRepositories;
    }
3758#public void setPluginArtifactRepositories( List<ArtifactRepository> pluginArtifactRepositories )
    {
        this.pluginArtifactRepositories = pluginArtifactRepositories;
        this.remotePluginRepositories = RepositoryUtils.toRepos( getPluginArtifactRepositories() );
    }
3759#/**
     * @return a list of ArtifactRepository objects constructed from the Repository objects returned
     *         by getPluginRepositories.
     */
    public List<ArtifactRepository> getPluginArtifactRepositories()
    {
        if ( pluginArtifactRepositories == null )
        {
            pluginArtifactRepositories = new ArrayList<ArtifactRepository>();
        }

        return pluginArtifactRepositories;
    }
3760#public ArtifactRepository getDistributionManagementArtifactRepository()
    {
        return getArtifact().isSnapshot() && ( getSnapshotArtifactRepository() != null ) ? getSnapshotArtifactRepository() : getReleaseArtifactRepository();
    }
3761#public List<Repository> getPluginRepositories()
    {
        return getModel().getPluginRepositories();
    }
3762#public List<RemoteRepository> getRemoteProjectRepositories()
    {
        return remoteProjectRepositories;
    }
3763#public List<RemoteRepository> getRemotePluginRepositories()
    {
        return remotePluginRepositories;
    }
3764#public void setActiveProfiles( List<Profile> activeProfiles )
    {
        this.activeProfiles = activeProfiles;
    }
3765#public List<Profile> getActiveProfiles()
    {
        return activeProfiles;
    }
3766#public void setInjectedProfileIds( String source, List<String> injectedProfileIds )
    {
        if ( injectedProfileIds != null )
        {
            this.injectedProfileIds.put( source, new ArrayList<String>( injectedProfileIds ) );
        }
        else
        {
            this.injectedProfileIds.remove( source );
        }
    }
3767#/**
     * Gets the identifiers of all profiles that contributed to this project's effective model. This includes active
     * profiles from the project's POM and all its parent POMs as well as from external sources like the {@code
     * settings.xml}. The profile identifiers are grouped by the identifier of their source, e.g. {@code
     * <groupId>:<artifactId>:<version>} for a POM profile or {@code external} for profiles from the {@code
     * settings.xml}.
     * 
     * @return The identifiers of all injected profiles, indexed by the source from which the profiles originated, never
     *         {@code null}.
     */
    public Map<String, List<String>> getInjectedProfileIds()
    {
        return this.injectedProfileIds;
    }
3768#public void addAttachedArtifact( Artifact artifact )
        throws DuplicateArtifactAttachmentException
    {
        List<Artifact> attachedArtifacts = getAttachedArtifacts();

        if ( attachedArtifacts.contains( artifact ) )
        {
            if ( logger != null )
            {
                logger.warn( "Artifact " + artifact + " already attached to project, ignoring duplicate" );
            }
            return;
            //throw new DuplicateArtifactAttachmentException( this, artifact );
        }

        getAttachedArtifacts().add( artifact );
    }
3769#public List<Artifact> getAttachedArtifacts()
    {
        if ( attachedArtifacts == null )
        {
            attachedArtifacts = new ArrayList<Artifact>();
        }
        return attachedArtifacts;
    }
3770#public Xpp3Dom getGoalConfiguration( String pluginGroupId, String pluginArtifactId, String executionId,
                                         String goalId )
    {
        Xpp3Dom dom = null;

        if ( getBuildPlugins() != null )
        {
            for ( Plugin plugin : getBuildPlugins() )
            {
                if ( pluginGroupId.equals( plugin.getGroupId() ) && pluginArtifactId.equals( plugin.getArtifactId() ) )
                {
                    dom = (Xpp3Dom) plugin.getConfiguration();

                    if ( executionId != null )
                    {
                        PluginExecution execution = plugin.getExecutionsAsMap().get( executionId );
                        if ( execution != null )
                        {
                            // NOTE: The PluginConfigurationExpander already merged the plugin-level config in
                            dom = (Xpp3Dom) execution.getConfiguration();
                        }
                    }
                    break;
                }
            }
        }

        if ( dom != null )
        {
            // make a copy so the original in the POM doesn't get messed with
            dom = new Xpp3Dom( dom );
        }

        return dom;
    }
3771#@Deprecated
    public Xpp3Dom getReportConfiguration( String pluginGroupId, String pluginArtifactId, String reportSetId )
    {
        Xpp3Dom dom = null;

        // ----------------------------------------------------------------------
        // I would like to be able to lookup the Mojo object using a key but
        // we have a limitation in modello that will be remedied shortly. So
        // for now I have to iterate through and see what we have.
        // ----------------------------------------------------------------------

        if ( getReportPlugins() != null )
        {
            for ( Iterator<ReportPlugin> iterator = getReportPlugins().iterator(); iterator.hasNext(); )
            {
                ReportPlugin plugin = iterator.next();

                if ( pluginGroupId.equals( plugin.getGroupId() ) && pluginArtifactId.equals( plugin.getArtifactId() ) )
                {
                    dom = (Xpp3Dom) plugin.getConfiguration();

                    if ( reportSetId != null )
                    {
                        ReportSet reportSet = plugin.getReportSetsAsMap().get( reportSetId );
                        if ( reportSet != null )
                        {
                            Xpp3Dom executionConfiguration = (Xpp3Dom) reportSet.getConfiguration();
                            if ( executionConfiguration != null )
                            {
                                Xpp3Dom newDom = new Xpp3Dom( executionConfiguration );
                                dom = Xpp3Dom.mergeXpp3Dom( newDom, dom );
                            }
                        }
                    }
                    break;
                }
            }
        }

        if ( dom != null )
        {
            // make a copy so the original in the POM doesn't get messed with
            dom = new Xpp3Dom( dom );
        }

        return dom;
    }
3772#public MavenProject getExecutionProject()
    {
        return ( executionProject == null ? this : executionProject );
    }
3773#public void setExecutionProject( MavenProject executionProject )
    {
        this.executionProject = executionProject;
    }
3774#public List<MavenProject> getCollectedProjects()
    {
        return collectedProjects;
    }
3775#public void setCollectedProjects( List<MavenProject> collectedProjects )
    {
        this.collectedProjects = collectedProjects;
    }
3776#/**
     * Direct dependencies that this project has.
     * 
     * @return {@link Set} &lt; {@link Artifact} >
     * @see #getArtifacts() to get all transitive dependencies
     */
    public Set<Artifact> getDependencyArtifacts()
    {
        return dependencyArtifacts;
    }
3777#public void setDependencyArtifacts( Set<Artifact> dependencyArtifacts )
    {
        this.dependencyArtifacts = dependencyArtifacts;
    }
3778#public void setReleaseArtifactRepository( ArtifactRepository releaseArtifactRepository )
    {
        this.releaseArtifactRepository = releaseArtifactRepository;
    }
3779#public void setSnapshotArtifactRepository( ArtifactRepository snapshotArtifactRepository )
    {
        this.snapshotArtifactRepository = snapshotArtifactRepository;
    }
3780#public void setOriginalModel( Model originalModel )
    {
        this.originalModel = originalModel;
    }
3781#public Model getOriginalModel()
    {
        return originalModel;
    }
3782#public void setManagedVersionMap( Map<String, Artifact> map )
    {
        managedVersionMap = map;
    }
3783#public Map<String, Artifact> getManagedVersionMap()
    {
        if ( managedVersionMap != null )
        {
            return managedVersionMap;
        }

        Map<String, Artifact> map = null;
        if ( repositorySystem != null )
        {

            List<Dependency> deps;
            DependencyManagement dependencyManagement = getDependencyManagement();
            if ( ( dependencyManagement != null ) && ( ( deps = dependencyManagement.getDependencies() ) != null ) && ( deps.size() > 0 ) )
            {
                map = new HashMap<String, Artifact>();
                for ( Iterator<Dependency> i = dependencyManagement.getDependencies().iterator(); i.hasNext(); )
                {
                    Dependency d = i.next();

                    Artifact artifact = repositorySystem.createDependencyArtifact( d );

                    if ( artifact == null )
                    {
                        map = Collections.emptyMap();
                    }

                    map.put( d.getManagementKey(), artifact );
                }
            }
            else
            {
                map = Collections.emptyMap();
            }
        }
        managedVersionMap = map;
        return managedVersionMap;
    }
3784#@Override
    public boolean equals( Object other )
    {
        if ( other == this )
        {
            return true;
        }
        else if ( !( other instanceof MavenProject ) )
        {
            return false;
        }

        MavenProject that = (MavenProject) other;

        return eq( getArtifactId(), that.getArtifactId() )
            && eq( getGroupId(), that.getGroupId() )
            && eq( getVersion(), that.getVersion() );
    }
3785#private static <T> boolean eq( T s1, T s2 )
    {
        return ( s1 != null ) ? s1.equals( s2 ) : s2 == null;
    }
3786#@Override
    public int hashCode()
    {
        int hash = 17;
        hash = 31 * hash + getGroupId().hashCode();
        hash = 31 * hash + getArtifactId().hashCode();
        hash = 31 * hash + getVersion().hashCode();
        return hash;
    }
3787#public List<Extension> getBuildExtensions()
    {
        Build build = getBuild();
        if ( ( build == null ) || ( build.getExtensions() == null ) )
        {
            return Collections.emptyList();
        }
        else
        {
            return build.getExtensions();
        }
    }
3788#public void addProjectReference( MavenProject project )
    {
        projectReferences.put( getProjectReferenceId( project.getGroupId(), project.getArtifactId(), project.getVersion() ), project );
    }
3789#/**
     * @deprecated Use MavenProjectHelper.attachArtifact(..) instead.
     */
    @Deprecated
    public void attachArtifact( String type, String classifier, File file )
    {
    }
3790#public Properties getProperties()
    {
        return getModel().getProperties();
    }
3791#public List<String> getFilters()
    {
        return getBuild().getFilters();
    }
3792#public Map<String, MavenProject> getProjectReferences()
    {
        return projectReferences;
    }
3793#public boolean isExecutionRoot()
    {
        return executionRoot;
    }
3794#public void setExecutionRoot( boolean executionRoot )
    {
        this.executionRoot = executionRoot;
    }
3795#public String getDefaultGoal()
    {
        return getBuild() != null ? getBuild().getDefaultGoal() : null;
    }
3796#public Plugin getPlugin( String pluginKey )
    {
        return getBuild().getPluginsAsMap().get( pluginKey );
    }
3797#/**
     * Default toString
     */
    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder( 128 );
        sb.append( "MavenProject: " );
        sb.append( getGroupId() );
        sb.append( ":" );
        sb.append( getArtifactId() );
        sb.append( ":" );
        sb.append( getVersion() );
        sb.append( " @ " );

        try
        {
            sb.append( getFile().getPath() );
        }
        catch ( NullPointerException e )
        {
            //don't log it.
        }

        return sb.toString();
    }
3798#/**
     * @deprecated Use {@link org.apache.maven.model.io.ModelWriter}.
     */
    @Deprecated
    public void writeModel( Writer writer )
        throws IOException
    {
        MavenXpp3Writer pomWriter = new MavenXpp3Writer();
        pomWriter.write( writer, getModel() );
    }
3799#/**
     * @deprecated Use {@link org.apache.maven.model.io.ModelWriter}.
     */
    @Deprecated
    public void writeOriginalModel( Writer writer )
        throws IOException
    {
        MavenXpp3Writer pomWriter = new MavenXpp3Writer();
        pomWriter.write( writer, getOriginalModel() );
    }
3800#/**
     * @throws CloneNotSupportedException
     * @since 2.0.9
     */
    @Override
    public MavenProject clone()
    {
        MavenProject clone;
        try
        {
            clone = (MavenProject) super.clone();
        }
        catch ( CloneNotSupportedException e )
        {
            throw new UnsupportedOperationException( e );
        }

        clone.deepCopy( this );

        return clone;
    }
3801#protected void setModel( Model model )
    {
        this.model = model;
    }
3802#protected void setAttachedArtifacts( List<Artifact> attachedArtifacts )
    {
        this.attachedArtifacts = attachedArtifacts;
    }
3803#protected void setCompileSourceRoots( List<String> compileSourceRoots )
    {
        this.compileSourceRoots = compileSourceRoots;
    }
3804#protected void setTestCompileSourceRoots( List<String> testCompileSourceRoots )
    {
        this.testCompileSourceRoots = testCompileSourceRoots;
    }
3805#protected void setScriptSourceRoots( List<String> scriptSourceRoots )
    {
        this.scriptSourceRoots = scriptSourceRoots;
    }
3806#protected ArtifactRepository getReleaseArtifactRepository()
    {
        if ( releaseArtifactRepository == null )
        {
            if ( getDistributionManagement() != null && getDistributionManagement().getRepository() != null )
            {
                checkProjectBuildingRequest();
                try
                {
                    ArtifactRepository repo =
                        repositorySystem.buildArtifactRepository( getDistributionManagement().getRepository() );
                    repositorySystem.injectProxy( projectBuilderConfiguration.getRepositorySession(),
                                                  Arrays.asList( repo ) );
                    repositorySystem.injectAuthentication( projectBuilderConfiguration.getRepositorySession(),
                                                           Arrays.asList( repo ) );
                    setReleaseArtifactRepository( repo );
                }
                catch ( InvalidRepositoryException e )
                {
                    throw new IllegalStateException( "Failed to create release distribution repository for " + getId(),
                                                     e );
                }
            }
        }

        return releaseArtifactRepository;
    }
3807#protected ArtifactRepository getSnapshotArtifactRepository()
    {
        if ( snapshotArtifactRepository == null )
        {
            if ( getDistributionManagement() != null && getDistributionManagement().getSnapshotRepository() != null )
            {
                checkProjectBuildingRequest();
                try
                {
                    ArtifactRepository repo =
                        repositorySystem.buildArtifactRepository( getDistributionManagement().getSnapshotRepository() );
                    repositorySystem.injectProxy( projectBuilderConfiguration.getRepositorySession(),
                                                  Arrays.asList( repo ) );
                    repositorySystem.injectAuthentication( projectBuilderConfiguration.getRepositorySession(),
                                                           Arrays.asList( repo ) );
                    setSnapshotArtifactRepository( repo );
                }
                catch ( InvalidRepositoryException e )
                {
                    throw new IllegalStateException(
                                                     "Failed to create snapshot distribution repository for " + getId(),
                                                     e );
                }
            }
        }

        return snapshotArtifactRepository;
    }
3808#@Deprecated
    public Artifact replaceWithActiveArtifact( Artifact pluginArtifact )
    {
        return pluginArtifact;
    }
3809#private void deepCopy( MavenProject project )
    {
        // disown the parent

        // copy fields
        setFile( project.getFile() );

        // don't need a deep copy, they don't get modified or added/removed to/from - but make them unmodifiable to be
        // sure!
        if ( project.getDependencyArtifacts() != null )
        {
            setDependencyArtifacts( Collections.unmodifiableSet( project.getDependencyArtifacts() ) );
        }

        if ( project.getArtifacts() != null )
        {
            setArtifacts( Collections.unmodifiableSet( project.getArtifacts() ) );
        }

        if ( project.getParentFile() != null )
        {
            parentFile = new File( project.getParentFile().getAbsolutePath() );
        }

        if ( project.getPluginArtifacts() != null )
        {
            setPluginArtifacts( Collections.unmodifiableSet( project.getPluginArtifacts() ) );
        }

        if ( project.getReportArtifacts() != null )
        {
            setReportArtifacts( Collections.unmodifiableSet( project.getReportArtifacts() ) );
        }

        if ( project.getExtensionArtifacts() != null )
        {
            setExtensionArtifacts( Collections.unmodifiableSet( project.getExtensionArtifacts() ) );
        }

        setParentArtifact( ( project.getParentArtifact() ) );

        if ( project.getRemoteArtifactRepositories() != null )
        {
            setRemoteArtifactRepositories( Collections.unmodifiableList( project.getRemoteArtifactRepositories() ) );
        }

        if ( project.getPluginArtifactRepositories() != null )
        {
            setPluginArtifactRepositories( ( Collections.unmodifiableList( project.getPluginArtifactRepositories() ) ) );
        }

        if ( project.getActiveProfiles() != null )
        {
            setActiveProfiles( ( Collections.unmodifiableList( project.getActiveProfiles() ) ) );
        }

        if ( project.getAttachedArtifacts() != null )
        {
            // clone properties modifyable by plugins in a forked lifecycle
            setAttachedArtifacts( new ArrayList<Artifact>( project.getAttachedArtifacts() ) );
        }

        if ( project.getCompileSourceRoots() != null )
        {
            // clone source roots
            setCompileSourceRoots( ( new ArrayList<String>( project.getCompileSourceRoots() ) ) );
        }

        if ( project.getTestCompileSourceRoots() != null )
        {
            setTestCompileSourceRoots( ( new ArrayList<String>( project.getTestCompileSourceRoots() ) ) );
        }

        if ( project.getScriptSourceRoots() != null )
        {
            setScriptSourceRoots( ( new ArrayList<String>( project.getScriptSourceRoots() ) ) );
        }

        if ( project.getModel() != null )
        {
            setModel( project.getModel().clone() );
        }

        if ( project.getOriginalModel() != null )
        {
            setOriginalModel( project.getOriginalModel() );
        }

        setExecutionRoot( project.isExecutionRoot() );

        if ( project.getArtifact() != null )
        {
            setArtifact( ArtifactUtils.copyArtifact( project.getArtifact() ) );
        }

        if ( project.getManagedVersionMap() != null )
        {
            setManagedVersionMap( new HashMap<String, Artifact>( project.getManagedVersionMap() ) );
        }

        lifecyclePhases.addAll( project.lifecyclePhases );
    }
3810#private void addArtifactPath( Artifact artifact, List<String> classpath )
    {
        File file = artifact.getFile();
        if ( file != null )
        {
            classpath.add( file.getPath() );
        }
    }
3811#private static String getProjectReferenceId( String groupId, String artifactId, String version )
    {
        StringBuilder buffer = new StringBuilder( 128 );
        buffer.append( groupId ).append( ':' ).append( artifactId ).append( ':' ).append( version );
        return buffer.toString();
    }
3812#/**
     * Sets the value of the context value of this project identified
     * by the given key. If the supplied value is <code>null</code>,
     * the context value is removed from this project.
     * 
     * Context values are intended to allow core extensions to associate
     * derived state with project instances. 
     */
    public void setContextValue( String key, Object value )
    {
        if ( context == null )
        {
            context = new HashMap<String, Object>();
        }
        if ( value != null )
        {
            context.put( key, value );
        }
        else
        {
            context.remove( key );
        }
    }
3813#/**
     * Returns context value of this project associated with the given key 
     * or null if this project has no such value. 
     */
    public Object getContextValue( String key )
    {
        if ( context == null )
        {
            return null;
        }
        return context.get( key );
    }
3814#/**
     * Sets the project's class realm. <strong>Warning:</strong> This is an internal utility method that is only public
     * for technical reasons, it is not part of the public API. In particular, this method can be changed or deleted
     * without prior notice and must not be used by plugins.
     * 
     * @param classRealm The class realm hosting the build extensions of this project, may be {@code null}.
     */
    public void setClassRealm( ClassRealm classRealm )
    {
        this.classRealm = classRealm;
    }
3815#/**
     * Gets the project's class realm. This class realm hosts the build extensions of the project.
     * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not
     * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be
     * used by plugins.
     * 
     * @return The project's class realm or {@code null}.
     */
    public ClassRealm getClassRealm()
    {
        return classRealm;
    }
3816#/**
     * Sets the artifact filter used to exclude shared extension artifacts from plugin realms. <strong>Warning:</strong>
     * This is an internal utility method that is only public for technical reasons, it is not part of the public API.
     * In particular, this method can be changed or deleted without prior notice and must not be used by plugins.
     * 
     * @param extensionDependencyFilter The dependency filter to apply to plugins, may be {@code null}.
     */
    public void setExtensionDependencyFilter( DependencyFilter extensionDependencyFilter )
    {
        this.extensionDependencyFilter = extensionDependencyFilter;
    }
3817#/**
     * Gets the dependency filter used to exclude shared extension artifacts from plugin realms.
     * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not
     * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be
     * used by plugins.
     * 
     * @return The dependency filter or {@code null}.
     */
    public DependencyFilter getExtensionDependencyFilter()
    {
        return extensionDependencyFilter;
    }
3818#/**
     * Sets the transitive dependency artifacts that have been resolved/collected for this project.
     * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not
     * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be
     * used by plugins.
     * 
     * @param artifacts The set of artifacts, may be {@code null}.
     */
    public void setResolvedArtifacts( Set<Artifact> artifacts )
    {
        this.resolvedArtifacts = ( artifacts != null ) ? artifacts : Collections.<Artifact> emptySet();
        this.artifacts = null;
        this.artifactMap = null;
    }
3819#/**
     * Sets the scope filter to select the artifacts being exposed to the currently executed mojo.
     * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not
     * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be
     * used by plugins.
     * 
     * @param artifactFilter The artifact filter, may be {@code null} to exclude all artifacts.
     */
    public void setArtifactFilter( ArtifactFilter artifactFilter )
    {
        this.artifactFilter = artifactFilter;
        this.artifacts = null;
        this.artifactMap = null;
    }
3820#/**
     * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not
     * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be
     * used by plugins.
     * 
     * @param phase The phase to check for, must not be {@code null}.
     * @return {@code true} if the phase has been seen.
     */
    public boolean hasLifecyclePhase( String phase )
    {
        return lifecyclePhases.contains( phase );
    }
3821#/**
     * <strong>Warning:</strong> This is an internal utility method that is only public for technical reasons, it is not
     * part of the public API. In particular, this method can be changed or deleted without prior notice and must not be
     * used by plugins.
     * 
     * @param lifecyclePhase The lifecycle phase to add, must not be {@code null}.
     */
    public void addLifecyclePhase( String lifecyclePhase )
    {
        lifecyclePhases.add( lifecyclePhase );
    }
3822#/**
     * Gets the project building request from which this project instance was created. <strong>Warning:</strong> This is
     * an utility method that is meant to assist integrators of Maven, it must not be used by Maven plugins.
     * 
     * @return The project building request or {@code null}.
     */
    public ProjectBuildingRequest getProjectBuildingRequest()
    {
        return projectBuilderConfiguration;
    }
3823#/**
     * Sets the project building request from which this project instance was created. <strong>Warning:</strong> This is
     * an utility method that is meant to assist integrators of Maven, it must not be used by Maven plugins.
     * 
     * @param projectBuildingRequest The project building request, may be {@code null}.
     */
    public void setProjectBuildingRequest( ProjectBuildingRequest projectBuildingRequest )
    {
        projectBuilderConfiguration = projectBuildingRequest;
    }
3824#private void checkProjectBuildingRequest()
    {
        if ( projectBuilderConfiguration == null )
        {
            throw new IllegalStateException( "project building request missing" );
        }
    }
3825#public DependencyNode getDependencyGraph()
    {
        return root;
    }
3826#public void setDependencyGraph( DependencyNode root )
    {
        this.root = root;
    }
3827#public List<Dependency> getDependencies()
    {
        return dependencies;
    }
3828#public List<Dependency> getResolvedDependencies()
    {
        return resolvedDependencies;
    }
3829#public void addResolvedDependency( Dependency dependency )
    {
        dependencies.add( dependency );
        resolvedDependencies.add( dependency );
    }
3830#public List<Dependency> getUnresolvedDependencies()
    {
        return unresolvedDependencies;
    }
3831#public List<Exception> getCollectionErrors()
    {
        return collectionErrors;
    }
3832#public void setCollectionErrors( List<Exception> exceptions )
    {
        if ( exceptions != null )
        {
            this.collectionErrors = exceptions;
        }
        else
        {
            this.collectionErrors = new ArrayList<Exception>();
        }
    }
3833#public List<Exception> getResolutionErrors( Dependency dependency )
    {
        List<Exception> errors = resolutionErrors.get( dependency );
        return ( errors != null ) ? errors : Collections.<Exception> emptyList();
    }
3834#public void setResolutionErrors( Dependency dependency, List<Exception> errors )
    {
        dependencies.add( dependency );
        unresolvedDependencies.add( dependency );
        resolutionErrors.put( dependency, errors );
    }
3835#CacheRecord get( List<? extends ClassRealm> extensionRealms );
3836#CacheRecord put( List<? extends ClassRealm> extensionRealms, ClassRealm projectRealm,
                     DependencyFilter extensionArtifactFilter );
3837#void flush();
3838#/**
     * Registers the specified cache record for usage with the given project. Integrators can use the information
     * collected from this method in combination with a custom cache implementation to dispose unused records from the
     * cache.
     * 
     * @param project The project that employs the plugin realm, must not be {@code null}.
     * @param record The cache record being used for the project, must not be {@code null}.
     */
    void register( MavenProject project, CacheRecord record );
3839#public CacheRecord( ClassRealm realm, DependencyFilter extensionArtifactFilter )
        {
            this.realm = realm;
            this.extensionArtifactFilter = extensionArtifactFilter;
        }
3840#public DependencyResolutionResult resolve( DependencyResolutionRequest request )
        throws DependencyResolutionException
    {
        RequestTrace trace = DefaultRequestTrace.newChild( null, request );

        DefaultDependencyResolutionResult result = new DefaultDependencyResolutionResult();

        MavenProject project = request.getMavenProject();
        RepositorySystemSession session = request.getRepositorySession();
        DependencyFilter filter = request.getResolutionFilter();

        ArtifactTypeRegistry stereotypes = session.getArtifactTypeRegistry();

        CollectRequest collect = new CollectRequest();
        collect.setRequestContext( "project" );
        collect.setRepositories( project.getRemoteProjectRepositories() );

        if ( project.getDependencyArtifacts() == null )
        {
            for ( Dependency dependency : project.getDependencies() )
            {
                if ( StringUtils.isEmpty( dependency.getGroupId() ) || StringUtils.isEmpty( dependency.getArtifactId() )
                    || StringUtils.isEmpty( dependency.getVersion() ) )
                {
                    // guard against case where best-effort resolution for invalid models is requested
                    continue;
                }
                collect.addDependency( RepositoryUtils.toDependency( dependency, stereotypes ) );
            }
        }
        else
        {
            Map<String, Dependency> dependencies = new HashMap<String, Dependency>();
            for ( Dependency dependency : project.getDependencies() )
            {
                String classifier = dependency.getClassifier();
                if ( classifier == null )
                {
                    ArtifactType type = stereotypes.get( dependency.getType() );
                    if ( type != null )
                    {
                        classifier = type.getClassifier();
                    }
                }
                String key =
                    ArtifacIdUtils.toVersionlessId( dependency.getGroupId(), dependency.getArtifactId(),
                                                    dependency.getType(), classifier );
                dependencies.put( key, dependency );
            }
            for ( Artifact artifact : project.getDependencyArtifacts() )
            {
                String key = artifact.getDependencyConflictId();
                Dependency dependency = dependencies.get( key );
                Collection<Exclusion> exclusions = dependency != null ? dependency.getExclusions() : null;
                org.sonatype.aether.graph.Dependency dep = RepositoryUtils.toDependency( artifact, exclusions );
                if ( !JavaScopes.SYSTEM.equals( dep.getScope() ) && dep.getArtifact().getFile() != null )
                {
                    // enable re-resolution
                    org.sonatype.aether.artifact.Artifact art = dep.getArtifact();
                    art = art.setFile( null ).setVersion( art.getBaseVersion() );
                    dep = dep.setArtifact( art );
                }
                collect.addDependency( dep );
            }
        }

        DependencyManagement depMngt = project.getDependencyManagement();
        if ( depMngt != null )
        {
            for ( Dependency dependency : depMngt.getDependencies() )
            {
                collect.addManagedDependency( RepositoryUtils.toDependency( dependency, stereotypes ) );
            }
        }

        DependencyRequest depRequest = new DependencyRequest( collect, filter );
        depRequest.setTrace( trace );

        DependencyNode node;
        try
        {
            collect.setTrace( DefaultRequestTrace.newChild( trace, depRequest ) );
            node = repoSystem.collectDependencies( session, collect ).getRoot();
            result.setDependencyGraph( node );
        }
        catch ( DependencyCollectionException e )
        {
            result.setDependencyGraph( e.getResult().getRoot() );
            result.setCollectionErrors( e.getResult().getExceptions() );

            throw new DependencyResolutionException( result, "Could not resolve dependencies for project "
                + project.getId() + ": " + e.getMessage(), e );
        }

        depRequest.setRoot( node );

        if ( logger.isWarnEnabled() )
        {
            for ( DependencyNode child : node.getChildren() )
            {
                if ( !child.getRelocations().isEmpty() )
                {
                    logger.warn( "The artifact " + child.getRelocations().get( 0 ) + " has been relocated to "
                        + child.getDependency().getArtifact() );
                }
            }
        }

        if ( logger.isDebugEnabled() )
        {
            node.accept( new GraphLogger( project ) );
        }

        try
        {
            process( result, repoSystem.resolveDependencies( session, depRequest ).getArtifactResults() );
        }
        catch ( org.sonatype.aether.resolution.DependencyResolutionException e )
        {
            process( result, e.getResult().getArtifactResults() );

            throw new DependencyResolutionException( result, "Could not resolve dependencies for project "
                + project.getId() + ": " + e.getMessage(), e );
        }

        return result;
    }
3841#private void process( DefaultDependencyResolutionResult result, Collection<ArtifactResult> results )
    {
        for ( ArtifactResult ar : results )
        {
            DependencyNode node = ar.getRequest().getDependencyNode();
            if ( ar.isResolved() )
            {
                result.addResolvedDependency( node.getDependency() );
            }
            else
            {
                result.setResolutionErrors( node.getDependency(), ar.getExceptions() );
            }
        }
    }
3842#public GraphLogger( MavenProject project )
        {
            this.project = project;
        }
3843#public boolean visitEnter( DependencyNode node )
        {
            StringBuilder buffer = new StringBuilder( 128 );
            buffer.append( indent );
            org.sonatype.aether.graph.Dependency dep = node.getDependency();
            if ( dep != null )
            {
                org.sonatype.aether.artifact.Artifact art = dep.getArtifact();

                buffer.append( art );
                buffer.append( ':' ).append( dep.getScope() );

                if ( node.getPremanagedScope() != null && !node.getPremanagedScope().equals( dep.getScope() ) )
                {
                    buffer.append( " (scope managed from " ).append( node.getPremanagedScope() );
                    appendManagementSource( buffer, art, "scope" );
                    buffer.append( ")" );
                }

                if ( node.getPremanagedVersion() != null && !node.getPremanagedVersion().equals( art.getVersion() ) )
                {
                    buffer.append( " (version managed from " ).append( node.getPremanagedVersion() );
                    appendManagementSource( buffer, art, "version" );
                    buffer.append( ")" );
                }
            }
            else
            {
                buffer.append( project.getGroupId() );
                buffer.append( ':' ).append( project.getArtifactId() );
                buffer.append( ':' ).append( project.getPackaging() );
                buffer.append( ':' ).append( project.getVersion() );
            }

            logger.debug( buffer.toString() );
            indent += "   ";
            return true;
        }
3844#public boolean visitLeave( DependencyNode node )
        {
            indent = indent.substring( 0, indent.length() - 3 );
            return true;
        }
3845#private void appendManagementSource( StringBuilder buffer, org.sonatype.aether.artifact.Artifact artifact,
                                             String field )
        {
            if ( managed == null )
            {
                managed = new HashMap<String, Dependency>();
                if ( project.getDependencyManagement() != null )
                {
                    for ( Dependency dep : project.getDependencyManagement().getDependencies() )
                    {
                        managed.put( dep.getManagementKey(), dep );
                    }
                }
            }

            String key =
                ArtifacIdUtils.toVersionlessId( artifact.getGroupId(), artifact.getArtifactId(),
                                                artifact.getProperty( ArtifactProperties.TYPE, "jar" ),
                                                artifact.getClassifier() );

            Dependency dependency = managed.get( key );
            if ( dependency != null )
            {
                InputLocation location = dependency.getLocation( field );
                if ( location != null )
                {
                    InputSource source = location.getSource();
                    if ( source != null )
                    {
                        buffer.append( " by " ).append( source.getModelId() );
                    }
                }
            }
        }
3846#public DuplicateArtifactAttachmentException( MavenProject project, Artifact artifact )
    {
        super( constructMessage( project, artifact ) );
        this.project = project;
        this.artifact = artifact;
    }
3847#private static String constructMessage( MavenProject project, Artifact artifact )
    {
        return DEFAULT_MESSAGE + " (project: " + project.getId() + "; illegal attachment: " + artifact.getId() + ")";
    }
3848#public MavenProject getProject()
    {
        return project;
    }
3849#public Artifact getArtifact()
    {
        return artifact;
    }
3850#/**
     * Creates a new result with the specified contents.
     * 
     * @param project The project that was built, may be {@code null}.
     * @param problems The problems that were encouterned, may be {@code null}.
     * @param dependencyResolutionResult The result of the resolution for the project dependencies, may be {@code null}.
     */
    public DefaultProjectBuildingResult( MavenProject project, List<ModelProblem> problems,
                                         DependencyResolutionResult dependencyResolutionResult )
    {
        this.projectId =
            ( project != null ) ? project.getGroupId() + ':' + project.getArtifactId() + ':' + project.getVersion()
                            : "";
        this.pomFile = ( project != null ) ? project.getFile() : null;
        this.project = project;
        this.problems = problems;
        this.dependencyResolutionResult = dependencyResolutionResult;
    }
3851#/**
     * Creates a new result with the specified contents.
     * 
     * @param projectId The identifier of the project, may be {@code null}.
     * @param pomFile The POM file from which the project was built, may be {@code null}.
     * @param problems The problems that were encouterned, may be {@code null}.
     */
    public DefaultProjectBuildingResult( String projectId, File pomFile, List<ModelProblem> problems )
    {
        this.projectId = ( projectId != null ) ? projectId : "";
        this.pomFile = pomFile;
        this.problems = problems;
    }
3852#public String getProjectId()
    {
        return projectId;
    }
3853#public File getPomFile()
    {
        return pomFile;
    }
3854#public MavenProject getProject()
    {
        return project;
    }
3855#public List<ModelProblem> getProblems()
    {
        if ( problems == null )
        {
            problems = new ArrayList<ModelProblem>();
        }

        return problems;
    }
3856#public DependencyResolutionResult getDependencyResolutionResult()
    {
        return dependencyResolutionResult;
    }
3857#public ProjectBuildingException( String projectId, String message, Throwable cause )
    {
        super( createMessage( message, projectId, null ), cause );
        this.projectId = projectId;
    }
3858#/**
     * @param projectId
     * @param message
     * @param pomFile   pom file location
     */
    public ProjectBuildingException( String projectId, String message, File pomFile )
    {
        super( createMessage( message, projectId, pomFile ) );
        this.projectId = projectId;
        this.pomFile = pomFile;
    }
3859#/**
     * @param projectId
     * @param message
     * @param pomFile   pom file location
     * @param cause
     */
    protected ProjectBuildingException( String projectId, String message, File pomFile, Throwable cause )
    {
        super( createMessage( message, projectId, pomFile ), cause );
        this.projectId = projectId;
        this.pomFile = pomFile;
    }
3860#public ProjectBuildingException( List<ProjectBuildingResult> results )
    {
        super( createMessage( results ) );
        this.projectId = "";
        this.results = results;
    }
3861#public File getPomFile()
    {
        return pomFile;
    }
3862#/**
     * @deprecated use {@link #getPomFile()}
     */
    public String getPomLocation()
    {
        if ( getPomFile() != null )
        {
            return getPomFile().getAbsolutePath();
        }
        else
        {
            return "null";
        }
    }
3863#public String getProjectId()
    {
        return projectId;
    }
3864#public List<ProjectBuildingResult> getResults()
    {
        return results;
    }
3865#private static String createMessage( String message, String projectId, File pomFile )
    {
        StringBuilder buffer = new StringBuilder( 256 );
        buffer.append( message );
        buffer.append( " for project " ).append( projectId );
        if ( pomFile != null )
        {
            buffer.append( " at " ).append( pomFile.getAbsolutePath() );
        }
        return buffer.toString();
    }
3866#private static String createMessage( List<ProjectBuildingResult> results )
    {
        StringWriter buffer = new StringWriter( 1024 );

        PrintWriter writer = new PrintWriter( buffer );
        writer.println( "Some problems were encountered while processing the POMs:" );
        for ( ProjectBuildingResult result : results )
        {
            for ( ModelProblem problem : result.getProblems() )
            {
                writer.print( "[" );
                writer.print( problem.getSeverity() );
                writer.print( "] " );
                writer.print( problem.getMessage() );
                writer.print( " @ " );
                writer.println( ModelProblemUtils.formatLocation( problem, result.getProjectId() ) );
            }
        }
        writer.close();

        return buffer.toString();
    }
3867#/**
     * Creates the effective artifact repositories from the specified POM repositories.
     *
     * @param pomRepositories The POM repositories to create the artifact repositories from, must not be {@code null}.
     * @param externalRepositories The external (and already mirrored) repositories to merge into the result list, may
     *            be {@code null}.
     * @param request The project building request holding further settings like repository settings, must not be
     *            {@code null}.
     * @return The effective artifact repositories, never {@code null}.
     * @throws InvalidRepositoryException
     */
    List<ArtifactRepository> createArtifactRepositories( List<Repository> pomRepositories,
                                                         List<ArtifactRepository> externalRepositories,
                                                         ProjectBuildingRequest request )
        throws InvalidRepositoryException;
3868#/**
     * Creates the project realm that hosts the build extensions of the specified model.
     *
     * @param project The project to create the project realm for, must not be {@code null}
     * @param model The model to create the project realm for, must not be {@code null}
     * @param request The project building request holding further settings like repository settings, must not be
     *            {@code null}.
     * @return The record with the project realm and extension artifact filter, never {@code null}.
     * @throws PluginResolutionException If any build extension could not be resolved.
     */
    ProjectRealmCache.CacheRecord createProjectRealm( MavenProject project, Model model,
                                                      ProjectBuildingRequest request )
        throws PluginResolutionException, PluginVersionResolutionException;
3869#/**
     * Updates the context class loader such that the container will search the project realm when the model builder
     * injects the lifecycle bindings from the packaging in the next step. The context class loader is to be reset by
     * the project builder when the project is fully assembled.
     *
     * @param project The project whose class realm should be selected, must not be {@code null}.
     */
    void selectProjectRealm( MavenProject project );
3870#/**
     * Gets the project to resolve dependencies for.
     * 
     * @return The project to resolve dependencies for or {@code null} if not set.
     */
    MavenProject getMavenProject();
3871#/**
     * Sets the project to resolve dependencies for.
     * 
     * @param project The project to resolve dependencies for, may be {@code null}.
     * @return This request for chaining, never {@code null}.
     */
    DependencyResolutionRequest setMavenProject( MavenProject project );
3872#/**
     * Gets the filter used to exclude some dependencies from resolution.
     * 
     * @return The filter to exclude dependencies from resolution or {@code null} to resolve all dependencies.
     */
    DependencyFilter getResolutionFilter();
3873#/**
     * Sets the filter used to exclude some dependencies from resolution. Note that this filter only controls the
     * resolution/download of dependency artifacts, not the inclusion of dependency nodes in the resolved dependeny
     * graph.
     * 
     * @param filter The filter to exclude dependencies from resolution, may be {@code null} to resolve all
     *            dependencies.
     * @return This request for chaining, never {@code null}.
     */
    DependencyResolutionRequest setResolutionFilter( DependencyFilter filter );
3874#/**
     * Gets the session to use for repository access.
     * 
     * @return The repository session or {@code null} if not set.
     */
    RepositorySystemSession getRepositorySession();
3875#/**
     * Sets the session to use for repository access.
     * 
     * @param repositorySession The repository session to use.
     * @return This request for chaining, never {@code null}.
     */
    DependencyResolutionRequest setRepositorySession( RepositorySystemSession repositorySession );
3876#/**
     * Sort a list of projects.
     * <ul>
     * <li>collect all the vertices for the projects that we want to build.</li>
     * <li>iterate through the deps of each project and if that dep is within
     * the set of projects we want to build then add an edge, otherwise throw
     * the edge away because that dependency is not within the set of projects
     * we are trying to build. we assume a closed set.</li>
     * <li>do a topo sort on the graph that remains.</li>
     * </ul>
     * @throws DuplicateProjectException if any projects are duplicated by id
     */
    // MAVENAPI FIXME: the DAG used is NOT only used to represent the dependency relation,
    // but also for <parent>, <build><plugin>, <reports>. We need multiple DAG's
    // since a DAG can only handle 1 type of relationship properly.
    // Usecase:  This is detected as a cycle:
    // org.apache.maven:maven-plugin-api                -(PARENT)->
    // org.apache.maven:maven                           -(inherited REPORTING)->
    // org.apache.maven.plugins:maven-checkstyle-plugin -(DEPENDENCY)->
    // org.apache.maven:maven-plugin-api
    // In this case, both the verify and the report goals are called
    // in a different lifecycle. Though the compiler-plugin has a valid usecase, although
    // that seems to work fine. We need to take versions and lifecycle into account.
    public ProjectSorter( List<MavenProject> projects )
        throws CycleDetectedException, DuplicateProjectException
    {
        dag = new DAG();

        // groupId:artifactId:version -> project
        projectMap = new HashMap<String, MavenProject>( projects.size() * 2 );

        // groupId:artifactId -> (version -> vertex)
        Map<String, Map<String, Vertex>> vertexMap = new HashMap<String, Map<String, Vertex>>( projects.size() * 2 );

        for ( MavenProject project : projects )
        {
            String projectId = getId( project );

            MavenProject conflictingProject = projectMap.put( projectId, project );

            if ( conflictingProject != null )
            {
                throw new DuplicateProjectException( projectId, conflictingProject.getFile(), project.getFile(),
                                                     "Project '" + projectId + "' is duplicated in the reactor" );
            }

            String projectKey = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() );

            Map<String, Vertex> vertices = vertexMap.get( projectKey );
            if ( vertices == null )
            {
                vertices = new HashMap<String, Vertex>( 2, 1 );
                vertexMap.put( projectKey, vertices );
            }
            vertices.put( project.getVersion(), dag.addVertex( projectId ) );
        }

        for ( Vertex projectVertex : (List<Vertex>) dag.getVerticies() )
        {
            String projectId = projectVertex.getLabel();

            MavenProject project = projectMap.get( projectId );

            for ( Dependency dependency : project.getDependencies() )
            {
                addEdge( projectMap, vertexMap, project, projectVertex, dependency.getGroupId(),
                         dependency.getArtifactId(), dependency.getVersion(), false, false );
            }

            Parent parent = project.getModel().getParent();

            if ( parent != null )
            {
                // Parent is added as an edge, but must not cause a cycle - so we remove any other edges it has
                // in conflict
                addEdge( projectMap, vertexMap, null, projectVertex, parent.getGroupId(), parent.getArtifactId(),
                         parent.getVersion(), true, false );
            }

            List<Plugin> buildPlugins = project.getBuildPlugins();
            if ( buildPlugins != null )
            {
                for ( Plugin plugin : buildPlugins )
                {
                    addEdge( projectMap, vertexMap, project, projectVertex, plugin.getGroupId(),
                             plugin.getArtifactId(), plugin.getVersion(), false, true );

                    for ( Dependency dependency : plugin.getDependencies() )
                    {
                        addEdge( projectMap, vertexMap, project, projectVertex, dependency.getGroupId(),
                                 dependency.getArtifactId(), dependency.getVersion(), false, true );
                    }
                }
            }

            List<Extension> buildExtensions = project.getBuildExtensions();
            if ( buildExtensions != null )
            {
                for ( Extension extension : buildExtensions )
                {
                    addEdge( projectMap, vertexMap, project, projectVertex, extension.getGroupId(),
                             extension.getArtifactId(), extension.getVersion(), false, true );
                }
            }
        }

        List<MavenProject> sortedProjects = new ArrayList<MavenProject>( projects.size() );

        List<String> sortedProjectLabels = TopologicalSorter.sort( dag );

        for ( String id : sortedProjectLabels )
        {
            sortedProjects.add( projectMap.get( id ) );
        }

        this.sortedProjects = Collections.unmodifiableList( sortedProjects );
    }
3877#private void addEdge( Map<String, MavenProject> projectMap, Map<String, Map<String, Vertex>> vertexMap,
                          MavenProject project, Vertex projectVertex, String groupId, String artifactId,
                          String version, boolean force, boolean safe )
        throws CycleDetectedException
    {
        String projectKey = ArtifactUtils.versionlessKey( groupId, artifactId );

        Map<String, Vertex> vertices = vertexMap.get( projectKey );

        if ( vertices != null )
        {
            if ( isSpecificVersion( version ) )
            {
                Vertex vertex = vertices.get( version );
                if ( vertex != null )
                {
                    addEdge( projectVertex, vertex, project, projectMap, force, safe );
                }
            }
            else
            {
                for ( Vertex vertex : vertices.values() )
                {
                    addEdge( projectVertex, vertex, project, projectMap, force, safe );
                }
            }
        }
    }
3878#private void addEdge( Vertex fromVertex, Vertex toVertex, MavenProject fromProject,
                          Map<String, MavenProject> projectMap, boolean force, boolean safe )
        throws CycleDetectedException
    {
        if ( fromVertex.equals( toVertex ) )
        {
            return;
        }

        if ( fromProject != null )
        {
            MavenProject toProject = projectMap.get( toVertex.getLabel() );
            fromProject.addProjectReference( toProject );
        }

        if ( force && toVertex.getChildren().contains( fromVertex ) )
        {
            dag.removeEdge( toVertex, fromVertex );
        }

        try
        {
            dag.addEdge( fromVertex, toVertex );
        }
        catch ( CycleDetectedException e )
        {
            if ( !safe )
            {
                throw e;
            }
        }
    }
3879#private boolean isSpecificVersion( String version )
    {
        return !( StringUtils.isEmpty( version ) || version.startsWith( "[" ) || version.startsWith( "(" ) );
    }
3880#// TODO: !![jc; 28-jul-2005] check this; if we're using '-r' and there are aggregator tasks, this will result in weirdness.
    public MavenProject getTopLevelProject()
    {
        if ( topLevelProject == null )
        {
            for ( Iterator<MavenProject> i = sortedProjects.iterator(); i.hasNext() && ( topLevelProject == null ); )
            {
                MavenProject project = i.next();
                if ( project.isExecutionRoot() )
                {
                    topLevelProject = project;
                }
            }
        }

        return topLevelProject;
    }
3881#public List<MavenProject> getSortedProjects()
    {
        return sortedProjects;
    }
3882#public boolean hasMultipleProjects()
    {
        return sortedProjects.size() > 1;
    }
3883#public List<String> getDependents( String id )
    {
        return dag.getParentLabels( id );
    }
3884#public List<String> getDependencies( String id )
    {
        return dag.getChildLabels( id );
    }
3885#public static String getId( MavenProject project )
    {
        return ArtifactUtils.key( project.getGroupId(), project.getArtifactId(), project.getVersion() );
    }
3886#public DAG getDAG()
    {
        return dag;
    }
3887#public Map<String, MavenProject> getProjectMap()
    {
        return projectMap;
    }
3888#/**
     * Gets the identifier of the project that could not be built. The general format of the identifier is {@code
     * <groupId>:<artifactId>:<version>} but some of these coordinates may still be unknown at the point the exception
     * is thrown so this information is merely meant to assist the user.
     * 
     * @return The identifier of the project or an empty string if not known, never {@code null}.
     */
    String getProjectId();
3889#/**
     * Gets the POM file from which the project was built.
     * 
     * @return The POM file or {@code null} if unknown.
     */
    File getPomFile();
3890#/**
     * Gets the project that was built.
     * 
     * @return The project that was built or {@code null} if an error occurred and this result accompanies a
     *         {@link ProjectBuildingException}.
     */
    MavenProject getProject();
3891#/**
     * Gets the problems that were encountered during the project building.
     * 
     * @return The problems that were encountered during the project building, can be empty but never {@code null}.
     */
    List<ModelProblem> getProblems();
3892#/**
     * Gets the result of the dependency resolution for the project.
     * 
     * @return The result of the dependency resolution for the project or {@code null} if the project dependencies were
     *         not requested.
     */
    DependencyResolutionResult getDependencyResolutionResult();
3893#/**
     * @deprecated use {@link #DuplicateProjectException(String, File, File, String)}
     */
    public DuplicateProjectException( String message )
    {
        this( null, null, null, message );
    }
3894#/**
     * @deprecated use {@link #DuplicateProjectException(String, File, File, String)}
     */
    public DuplicateProjectException( String message, Exception e )
    {
        super( message, e );
        this.projectId = null;
        this.existingProjectFile = null;
        this.conflictingProjectFile = null;
    }
3895#public DuplicateProjectException( String projectId, File existingProjectFile, File conflictingProjectFile,
                                      String message )
    {
        super( message );
        this.projectId = projectId;
        this.existingProjectFile = existingProjectFile;
        this.conflictingProjectFile = conflictingProjectFile;
    }
3896#public String getProjectId()
    {
        return projectId;
    }
3897#public File getExistingProjectFile()
    {
        return existingProjectFile;
    }
3898#public File getConflictingProjectFile()
    {
        return conflictingProjectFile;
    }
3899#public DefaultDependencyResolutionRequest()
    {
        // enables default constructor
    }
3900#public DefaultDependencyResolutionRequest( MavenProject project, RepositorySystemSession session )
    {
        setMavenProject( project );
        setRepositorySession( session );
    }
3901#public DependencyFilter getResolutionFilter()
    {
        return filter;
    }
3902#public MavenProject getMavenProject()
    {
        return project;
    }
3903#public RepositorySystemSession getRepositorySession()
    {
        return session;
    }
3904#public DependencyResolutionRequest setResolutionFilter( DependencyFilter filter )
    {
        this.filter = filter;
        return this;
    }
3905#public DependencyResolutionRequest setMavenProject( MavenProject project )
    {
        this.project = project;
        return this;
    }
3906#public DependencyResolutionRequest setRepositorySession( RepositorySystemSession repositorySession )
    {
        this.session = repositorySession;
        return this;
    }
3907#ProjectBuildingRequest setLocalRepository( ArtifactRepository localRepository );
3908#ArtifactRepository getLocalRepository();
3909#ProjectBuildingRequest setRemoteRepositories( List<ArtifactRepository> remoteRepositories );
3910#List<ArtifactRepository> getRemoteRepositories();
3911#ProjectBuildingRequest setPluginArtifactRepositories( List<ArtifactRepository> pluginArtifacgRepositories );
3912#List<ArtifactRepository> getPluginArtifactRepositories();
3913#/**
     * Sets the system properties to use for interpolation and profile activation. The system properties are collected
     * from the runtime environment like {@link System#getProperties()} and environment variables.
     * 
     * @param systemProperties The system properties, may be {@code null}.
     * @return This request, never {@code null}.
     */
    ProjectBuildingRequest setSystemProperties( Properties systemProperties );
3914#/**
     * Gets the system properties to use for interpolation and profile activation. The system properties are collected
     * from the runtime environment like {@link System#getProperties()} and environment variables.
     * 
     * @return The system properties, never {@code null}.
     */
    Properties getSystemProperties();
3915#/**
     * Sets the user properties to use for interpolation and profile activation. The user properties have been
     * configured directly by the user on his discretion, e.g. via the {@code -Dkey=value} parameter on the command
     * line.
     * 
     * @param userProperties The user properties, may be {@code null}.
     * @return This request, never {@code null}.
     */
    ProjectBuildingRequest setUserProperties( Properties userProperties );
3916#/**
     * Gets the user properties to use for interpolation and profile activation. The user properties have been
     * configured directly by the user on his discretion, e.g. via the {@code -Dkey=value} parameter on the command
     * line.
     * 
     * @return The user properties, never {@code null}.
     */
    Properties getUserProperties();
3917#void setProject(MavenProject mavenProject);
3918#MavenProject getProject();
3919#ProjectBuildingRequest setProcessPlugins( boolean processPlugins );
3920#boolean isProcessPlugins();
3921#ProjectBuildingRequest setResolveDependencies( boolean resolveDependencies );
3922#boolean isResolveDependencies();
3923#/**
     * Controls the level of validation to perform on processed models. By default, models are validated in strict mode.
     * 
     * @param validationLevel The level of validation to perform on processed models, e.g.
     *            {@link ModelBuildingRequest#VALIDATION_LEVEL_STRICT}.
     * @return This configuration, never {@code null}.
     */
    ProjectBuildingRequest setValidationLevel( int validationLevel );
3924#/**
     * Gets the level of validation to perform on processed models.
     * 
     * @return The level of validation to perform on processed models.
     */
    int getValidationLevel();
3925#// Profiles
    
    /**
     * Set any active profiles that the {@link ProjectBuilder} should consider while constructing
     * a {@link MavenProject}.
     */
    void setActiveProfileIds( List<String> activeProfileIds );
3926#List<String> getActiveProfileIds();
3927#void setInactiveProfileIds( List<String> inactiveProfileIds );
3928#List<String> getInactiveProfileIds();
3929#/**
     * Add a {@link org.apache.maven.model.Profile} that has come from an external source. This may be from a custom configuration
     * like the MavenCLI settings.xml file, or from a custom dialog in an IDE integration like M2Eclipse.
     * @param profile
     */
    void addProfile( Profile profile );
3930#void setProfiles( List<Profile> profiles );
3931#List<Profile> getProfiles();
3932#/**
     * Gets the start time of the build.
     * 
     * @return The start time of the build or {@code null} if unknown.
     */
    Date getBuildStartTime();
3933#/**
     * Sets the start time of the build.
     * 
     * @param buildStartTime The start time of the build, may be {@code null}.
     * @return This request, never {@code null}.
     */
    void setBuildStartTime( Date buildStartTime );
3934#RepositorySystemSession getRepositorySession();
3935#ProjectBuildingRequest setRepositorySession( RepositorySystemSession repositorySession );
3936#/**
     * Sets the merge mode used to combine repositories declared in the POM with the repositories specified in this
     * request.
     * 
     * @param mode The repository merge mode, must not be {@code null}.
     * @return This request for chaining, never {@code null}.
     * @see #setRemoteRepositories(List)
     */
    ProjectBuildingRequest setRepositoryMerging( RepositoryMerging mode );
3937#/**
     * Gets the merge mode used to combine repositories declared in the POM with the repositories specified in this
     * request
     * 
     * @return The merge mode, never {@code null}.
     */
    RepositoryMerging getRepositoryMerging();
3938#/**
     * Resolves the transitive dependencies of a project.
     * 
     * @param request The resolution request holding the parameters, must not be {@code null}.
     * @return The resolution result, never {@code null}.
     * @throws DependencyResolutionException If any project dependency could not be resolved.
     */
    DependencyResolutionResult resolve( DependencyResolutionRequest request )
        throws DependencyResolutionException;
3939#public DefaultProjectBuildingRequest()
    {
        processPlugins = true;
        profiles = new ArrayList<Profile>();
        activeProfileIds = new ArrayList<String>();
        inactiveProfileIds = new ArrayList<String>();
        systemProperties = new Properties();
        userProperties = new Properties();
        remoteRepositories = new ArrayList<ArtifactRepository>();
        pluginArtifactRepositories = new ArrayList<ArtifactRepository>();
    }
3940#public DefaultProjectBuildingRequest( ProjectBuildingRequest request )
    {
        this();
        setProcessPlugins( request.isProcessPlugins() );
        setProfiles( request.getProfiles() );
        setActiveProfileIds( request.getActiveProfileIds() );
        setInactiveProfileIds( request.getInactiveProfileIds() );
        setSystemProperties( request.getSystemProperties() );
        setUserProperties( request.getUserProperties() );
        setRemoteRepositories( request.getRemoteRepositories() );
        setPluginArtifactRepositories( request.getPluginArtifactRepositories() );
        setRepositorySession( request.getRepositorySession() );
        setLocalRepository( request.getLocalRepository() );
        setBuildStartTime( request.getBuildStartTime() );
        setProject( request.getProject() );
        setResolveDependencies( request.isResolveDependencies() );
        setValidationLevel( request.getValidationLevel() );
    }
3941#public MavenProject getProject()
    {
        return project;
    }
3942#public void setProject( MavenProject mavenProject )
    {
        this.project = mavenProject;
    }
3943#public ProjectBuildingRequest setLocalRepository( ArtifactRepository localRepository )
    {
        this.localRepository = localRepository;
        return this;
    }
3944#public ArtifactRepository getLocalRepository()
    {
        return localRepository;
    }
3945#public List<ArtifactRepository> getRemoteRepositories()
    {
        return remoteRepositories;
    }
3946#public ProjectBuildingRequest setRemoteRepositories( List<ArtifactRepository> remoteRepositories )
    {
        if ( remoteRepositories != null )
        {
            this.remoteRepositories = new ArrayList<ArtifactRepository>( remoteRepositories );
        }
        else
        {
            this.remoteRepositories.clear();
        }

        return this;
    }
3947#public List<ArtifactRepository> getPluginArtifactRepositories()
    {
        return pluginArtifactRepositories;
    }
3948#public ProjectBuildingRequest setPluginArtifactRepositories( List<ArtifactRepository> pluginArtifactRepositories )
    {
        if ( pluginArtifactRepositories != null )
        {
            this.pluginArtifactRepositories = new ArrayList<ArtifactRepository>( pluginArtifactRepositories );
        }
        else
        {
            this.pluginArtifactRepositories.clear();
        }

        return this;
    }
3949#public Properties getSystemProperties()
    {
        return systemProperties;
    }
3950#public ProjectBuildingRequest setSystemProperties( Properties systemProperties )
    {
        if ( systemProperties != null )
        {
            this.systemProperties = new Properties();
            this.systemProperties.putAll( systemProperties );
        }
        else
        {
            this.systemProperties.clear();
        }

        return this;
    }
3951#public Properties getUserProperties()
    {
        return userProperties;
    }
3952#public ProjectBuildingRequest setUserProperties( Properties userProperties )
    {
        if ( userProperties != null )
        {
            this.userProperties = new Properties();
            this.userProperties.putAll( userProperties );
        }
        else
        {
            this.userProperties.clear();
        }

        return this;
    }
3953#public boolean isProcessPlugins()
    {
        return processPlugins;
    }
3954#public ProjectBuildingRequest setProcessPlugins( boolean processPlugins )
    {
        this.processPlugins = processPlugins;
        return this;
    }
3955#public ProjectBuildingRequest setResolveDependencies( boolean resolveDependencies )
    {
        this.resolveDependencies = resolveDependencies;
        return this;
    }
3956#public boolean isResolveDependencies()
    {
        return resolveDependencies;
    }
3957#public ProjectBuildingRequest setValidationLevel( int validationLevel )
    {
        this.validationLevel = validationLevel;
        return this;
    }
3958#public int getValidationLevel()
    {
        return validationLevel;
    }
3959#public List<String> getActiveProfileIds()
    {
        return activeProfileIds;
    }
3960#public void setActiveProfileIds( List<String> activeProfileIds )
    {
        if ( activeProfileIds != null )
        {
            this.activeProfileIds = new ArrayList<String>( activeProfileIds );
        }
        else
        {
            this.activeProfileIds.clear();
        }
    }
3961#public List<String> getInactiveProfileIds()
    {
        return inactiveProfileIds;
    }
3962#public void setInactiveProfileIds( List<String> inactiveProfileIds )
    {
        if ( inactiveProfileIds != null )
        {
            this.inactiveProfileIds = new ArrayList<String>( inactiveProfileIds );
        }
        else
        {
            this.inactiveProfileIds.clear();
        }
    }
3963#public void setProfiles( List<Profile> profiles )
    {
        if ( profiles != null )
        {
            this.profiles = new ArrayList<Profile>( profiles );
        }
        else
        {
            this.profiles.clear();
        }
    }
3964#public void addProfile( Profile profile )
    {
        profiles.add( profile );
    }
3965#public List<Profile> getProfiles()
    {
        return profiles;
    }
3966#public Date getBuildStartTime()
    {
        return buildStartTime;
    }
3967#public void setBuildStartTime( Date buildStartTime )
    {
        this.buildStartTime = buildStartTime;
    }
3968#public RepositorySystemSession getRepositorySession()
    {
        return repositorySession;
    }
3969#public DefaultProjectBuildingRequest setRepositorySession( RepositorySystemSession repositorySession )
    {
        this.repositorySession = repositorySession;
        return this;
    }
3970#public DefaultProjectBuildingRequest setRepositoryMerging( RepositoryMerging repositoryMerging )
    {
        if ( repositoryMerging == null )
        {
            throw new IllegalArgumentException( "repository merge mode not specified" );
        }
        this.repositoryMerging = repositoryMerging;
        return this;
    }
3971#public RepositoryMerging getRepositoryMerging()
    {
        return repositoryMerging;
    }
3972#public InvalidProjectVersionException( String projectId, String locationInPom, String offendingVersion,
                                           File pomFile, InvalidVersionSpecificationException cause )
    {
        super( projectId, formatMessage( projectId, locationInPom, offendingVersion, cause ), pomFile, cause );
        this.locationInPom = locationInPom;
        this.offendingVersion = offendingVersion;
    }
3973#private static String formatMessage( String projectId, String locationInPom, String offendingVersion,
                                         InvalidVersionSpecificationException cause )
    {
        return "Invalid version: " + offendingVersion + " found for: " + locationInPom + " in project: " + projectId
            + ". Reason: " + cause.getMessage();
    }
3974#public String getOffendingVersion()
    {
        return offendingVersion;
    }
3975#public String getLocationInPom()
    {
        return locationInPom;
    }
3976#public Object get( String groupId, String artifactId, String version, String tag )
    {
        return models.get( new CacheKey( groupId, artifactId, version, tag ) );
    }
3977#public void put( String groupId, String artifactId, String version, String tag, Object data )
    {
        models.put( new CacheKey( groupId, artifactId, version, tag ), data );
    }
3978#public CacheKey( String groupId, String artifactId, String version, String tag )
        {
            this.groupId = ( groupId != null ) ? groupId : "";
            this.artifactId = ( artifactId != null ) ? artifactId : "";
            this.version = ( version != null ) ? version : "";
            this.tag = ( tag != null ) ? tag : "";

            int hash = 17;
            hash = hash * 31 + this.groupId.hashCode();
            hash = hash * 31 + this.artifactId.hashCode();
            hash = hash * 31 + this.version.hashCode();
            hash = hash * 31 + this.tag.hashCode();
            hashCode = hash;
        }
3979#@Override
        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }

            if ( !( obj instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey that = (CacheKey) obj;

            return artifactId.equals( that.artifactId ) && groupId.equals( that.groupId )
                && version.equals( that.version ) && tag.equals( that.tag );
        }
3980#@Override
        public int hashCode()
        {
            return hashCode;
        }
3981#/**
     * Builds a project descriptor from the specified POM file.
     * 
     * @param projectFile The POM file to build the project from, must not be {@code null}.
     * @param request The project building request that holds further parameters, must not be {@code null}.
     * @return The result of the project building, never {@code null}.
     * @throws ProjectBuildingException If the project descriptor could not be successfully built.
     */
    ProjectBuildingResult build( File projectFile, ProjectBuildingRequest request )
        throws ProjectBuildingException;
3982#/**
     * Builds a project descriptor for the specified artifact.
     * 
     * @param projectArtifact The POM artifact to build the project from, must not be {@code null}.
     * @param request The project building request that holds further parameters, must not be {@code null}.
     * @return The result of the project building, never {@code null}.
     * @throws ProjectBuildingException If the project descriptor could not be successfully built.
     */
    ProjectBuildingResult build( Artifact projectArtifact, ProjectBuildingRequest request )
        throws ProjectBuildingException;
3983#/**
     * Builds a project descriptor for the specified artifact.
     * 
     * @param projectArtifact The POM artifact to build the project from, must not be {@code null}.
     * @param allowStubModel A flag controlling the case of a missing POM artifact. If {@code true} and the specified
     *            POM artifact does not exist, a simple stub model will be returned. If {@code false}, an exception will
     *            be thrown.
     * @param request The project building request that holds further parameters, must not be {@code null}.
     * @return The result of the project building, never {@code null}.
     * @throws ProjectBuildingException If the project descriptor could not be successfully built.
     */
    ProjectBuildingResult build( Artifact projectArtifact, boolean allowStubModel, ProjectBuildingRequest request )
        throws ProjectBuildingException;
3984#/**
     * Builds a project descriptor for the specified model source.
     * 
     * @param modelSource The source of the model to built the project descriptor from, must not be {@code null}.
     * @param request The project building request that holds further parameters, must not be {@code null}.
     * @return The result of the project building, never {@code null}.
     * @throws ProjectBuildingException If the project descriptor could not be successfully built.
     */
    ProjectBuildingResult build( ModelSource modelSource, ProjectBuildingRequest request )
        throws ProjectBuildingException;
3985#/**
     * Builds the projects for the specified POM files and optionally their children.
     * 
     * @param pomFiles The POM files to build, must not be {@code null}.
     * @param recursive {@code true} to recursively build sub modules referenced by the POM files, {@code false} to
     *            build only the specified POM files.
     * @param request The project builder configuration that provides further parameters, must not be {@code null}.
     * @return The results of the project builder where each result corresponds to one project that was built, never
     *         {@code null}.
     * @throws ProjectBuildingException If an error was encountered during building of any project.
     *             {@link ProjectBuildingException#getResults()} provides access to the details of the problems.
     */
    List<ProjectBuildingResult> build( List<File> pomFiles, boolean recursive, ProjectBuildingRequest request )
        throws ProjectBuildingException;
3986#public void attachArtifact( MavenProject project, String artifactType, String artifactClassifier,
                                File artifactFile )
    {
        String type = artifactType;

        ArtifactHandler handler = null;

        if ( type != null )
        {
            handler = artifactHandlerManager.getArtifactHandler( artifactType );
        }

        if ( handler == null )
        {
            handler = artifactHandlerManager.getArtifactHandler( "jar" );
        }

        Artifact artifact = new AttachedArtifact( project.getArtifact(), artifactType, artifactClassifier, handler );

        artifact.setFile( artifactFile );
        artifact.setResolved( true );

        attachArtifact( project, artifact );
    }
3987#public void attachArtifact( MavenProject project, String artifactType, File artifactFile )
    {
        ArtifactHandler handler = artifactHandlerManager.getArtifactHandler( artifactType );

        Artifact artifact = new AttachedArtifact( project.getArtifact(), artifactType, handler );

        artifact.setFile( artifactFile );
        artifact.setResolved( true );

        attachArtifact( project, artifact );
    }
3988#public void attachArtifact( MavenProject project, File artifactFile, String artifactClassifier )
    {
        Artifact projectArtifact = project.getArtifact();

        Artifact artifact = new AttachedArtifact( projectArtifact, projectArtifact.getType(), artifactClassifier,
                                                  projectArtifact.getArtifactHandler() );

        artifact.setFile( artifactFile );
        artifact.setResolved( true );

        attachArtifact( project, artifact );
    }
3989#public void attachArtifact( MavenProject project, Artifact artifact )
    {
        try
        {
            project.addAttachedArtifact( artifact );
        }
        catch ( DuplicateArtifactAttachmentException dae )
        {
            getLogger().warn( dae.getMessage() );

            // We can throw this because it's unchecked, and won't change the MavenProjectHelper API, which would break
            // backward compat if it did.
            throw dae;
        }
    }
3990#public void addResource( MavenProject project, String resourceDirectory, List includes, List excludes )
    {
        Resource resource = new Resource();
        resource.setDirectory( resourceDirectory );
        resource.setIncludes( includes );
        resource.setExcludes( excludes );

        project.addResource( resource );
    }
3991#public void addTestResource( MavenProject project, String resourceDirectory, List includes, List excludes )
    {
        Resource resource = new Resource();
        resource.setDirectory( resourceDirectory );
        resource.setIncludes( includes );
        resource.setExcludes( excludes );

        project.addTestResource( resource );
    }
3992#public PluginArtifact( Plugin plugin, Artifact pluginArtifact )
    {
        super( plugin.getGroupId(), plugin.getArtifactId(), plugin.getVersion(), null, "maven-plugin", null,
               new PluginArtifactHandler() );
        this.plugin = plugin;
        setFile( pluginArtifact.getFile() );
        setResolved( true );
    }
3993#public List<Dependency> getDependencies()
    {
        return plugin.getDependencies();
    }
3994#public List<Dependency> getManagedDependencies()
    {
        return Collections.emptyList();
    }
3995#public String getClassifier()
        {
            return null;
        }
3996#public String getDirectory()
        {
            return null;
        }
3997#public String getExtension()
        {
            return "jar";
        }
3998#public String getLanguage()
        {
            return "none";
        }
3999#public String getPackaging()
        {
            return "maven-plugin";
        }
4000#public boolean isAddedToClasspath()
        {
            return true;
        }
4001#public boolean isIncludesDependencies()
        {
            return false;
        }
4002#private void injectSession( MetadataResolutionRequest request )
    {
        RepositorySystemSession session = legacySupport.getRepositorySession();

        if ( session != null )
        {
            request.setOffline( session.isOffline() );
            request.setForceUpdate( RepositoryPolicy.UPDATE_POLICY_ALWAYS.equals( session.getUpdatePolicy() ) );
        }
    }
4003#public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository,
                                     List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException
    {
        return retrieve( artifact, localRepository, remoteRepositories, false );
    }
4004#public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository,
                                     List<ArtifactRepository> remoteRepositories, boolean resolveManagedVersions )
        throws ArtifactMetadataRetrievalException
    {
        MetadataResolutionRequest request = new DefaultMetadataResolutionRequest();
        injectSession( request );
        request.setArtifact( artifact );
        request.setLocalRepository( localRepository );
        request.setRemoteRepositories( remoteRepositories );
        request.setResolveManagedVersions( resolveManagedVersions );
        return retrieve( request );
    }
4005#public ResolutionGroup retrieve( MetadataResolutionRequest request )
        throws ArtifactMetadataRetrievalException
    {
        Artifact artifact = request.getArtifact();

        //
        // If we have a system scoped artifact then we do not want any searching in local or remote repositories
        // and we want artifact resolution to only return the system scoped artifact itself.
        //
        if ( artifact.getScope() != null && artifact.getScope().equals( Artifact.SCOPE_SYSTEM ) )
        {
            return new ResolutionGroup( null, null, null );
        }

        ResolutionGroup cached =
            cache.get( artifact, request.isResolveManagedVersions(), request.getLocalRepository(),
                       request.getRemoteRepositories() );

        if ( cached != null )
        {
            // if the POM has no file, we cached a missing artifact, only return the cached data if no update forced
            if ( !request.isForceUpdate() || hasFile( cached.getPomArtifact() ) )
            {
                return cached;
            }
        }

        List<Dependency> dependencies;

        List<Dependency> managedDependencies = null;

        List<ArtifactRepository> pomRepositories = null;

        Artifact pomArtifact;

        Artifact relocatedArtifact = null;

        //TODO: Not even sure this is really required as the project will be cached in the builder, we'll see this
        // is currently the biggest hotspot
        if ( artifact instanceof ArtifactWithDependencies )
        {
            pomArtifact = artifact;

            dependencies = ( (ArtifactWithDependencies) artifact ).getDependencies();

            managedDependencies = ( (ArtifactWithDependencies) artifact ).getManagedDependencies();
        }
        else
        {
            ProjectRelocation rel = retrieveRelocatedProject( artifact, request );

            if ( rel == null )
            {
                return null;
            }

            pomArtifact = rel.pomArtifact;

            relocatedArtifact = rel.relocatedArtifact;

            if ( rel.project == null )
            {
                // When this happens we have a Maven 1.x POM, or some invalid POM. 
                // It should have never found its way into Maven 2.x repository but it did.
                dependencies = Collections.emptyList();
            }
            else
            {
                dependencies = rel.project.getDependencies();

                DependencyManagement depMngt = rel.project.getDependencyManagement();
                managedDependencies = ( depMngt != null ) ? depMngt.getDependencies() : null;

                pomRepositories = rel.project.getRemoteArtifactRepositories();
            }
        }

        Set<Artifact> artifacts = Collections.<Artifact>emptySet();

        if ( !artifact.getArtifactHandler().isIncludesDependencies() )
        {
            artifacts = new LinkedHashSet<Artifact>();

            for ( Dependency dependency : dependencies )
            {
                Artifact dependencyArtifact = createDependencyArtifact( dependency, artifact, pomArtifact );

                if ( dependencyArtifact != null )
                {
                    artifacts.add( dependencyArtifact );
                }
            }
        }

        Map<String, Artifact> managedVersions = null;

        if ( managedDependencies != null && request.isResolveManagedVersions() )
        {
            managedVersions = new HashMap<String, Artifact>();

            for ( Dependency managedDependency : managedDependencies )
            {
                Artifact managedArtifact = createDependencyArtifact( managedDependency, null, pomArtifact );

                managedVersions.put( managedDependency.getManagementKey(), managedArtifact );
            }
        }

        List<ArtifactRepository> aggregatedRepositories =
            aggregateRepositories( request.getRemoteRepositories(), pomRepositories );

        ResolutionGroup result =
            new ResolutionGroup( pomArtifact, relocatedArtifact, artifacts, managedVersions, aggregatedRepositories );

        cache.put( artifact, request.isResolveManagedVersions(), request.getLocalRepository(),
                   request.getRemoteRepositories(), result );

        return result;
    }
4006#private boolean hasFile( Artifact artifact )
    {
        return artifact != null && artifact.getFile() != null && artifact.getFile().exists();
    }
4007#private List<ArtifactRepository> aggregateRepositories( List<ArtifactRepository> requestRepositories,
                                                            List<ArtifactRepository> pomRepositories )
    {
        List<ArtifactRepository> repositories = requestRepositories;

        if ( pomRepositories != null && !pomRepositories.isEmpty() )
        {
            Map<String, ArtifactRepository> repos = new LinkedHashMap<String, ArtifactRepository>();

            for ( ArtifactRepository repo : requestRepositories )
            {
                if ( !repos.containsKey( repo.getId() ) )
                {
                    repos.put( repo.getId(), repo );
                }
            }

            for ( ArtifactRepository repo : pomRepositories )
            {
                if ( !repos.containsKey( repo.getId() ) )
                {
                    repos.put( repo.getId(), repo );
                }
            }

            repositories = new ArrayList<ArtifactRepository>( repos.values() );
        }

        return repositories;
    }
4008#private Artifact createDependencyArtifact( Dependency dependency, Artifact owner, Artifact pom )
        throws ArtifactMetadataRetrievalException
    {
        try
        {
            String inheritedScope = ( owner != null ) ? owner.getScope() : null;

            ArtifactFilter inheritedFilter = ( owner != null ) ? owner.getDependencyFilter() : null;

            return createDependencyArtifact( repositorySystem, dependency, inheritedScope, inheritedFilter );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            throw new ArtifactMetadataRetrievalException( "Invalid version for dependency "
                + dependency.getManagementKey() + ": " + e.getMessage(), e, pom );
        }
    }
4009#private static Artifact createDependencyArtifact( ArtifactFactory factory, Dependency dependency,
                                                      String inheritedScope, ArtifactFilter inheritedFilter )
        throws InvalidVersionSpecificationException
    {
        String effectiveScope = getEffectiveScope( dependency.getScope(), inheritedScope );

        if ( effectiveScope == null )
        {
            return null;
        }

        VersionRange versionRange = VersionRange.createFromVersionSpec( dependency.getVersion() );

        Artifact dependencyArtifact =
            factory.createDependencyArtifact( dependency.getGroupId(), dependency.getArtifactId(), versionRange,
                                              dependency.getType(), dependency.getClassifier(), effectiveScope,
                                              dependency.isOptional() );

        ArtifactFilter dependencyFilter = inheritedFilter;

        if ( dependencyFilter != null && !dependencyFilter.include( dependencyArtifact ) )
        {
            return null;
        }

        if ( Artifact.SCOPE_SYSTEM.equals( effectiveScope ) )
        {
            dependencyArtifact.setFile( new File( dependency.getSystemPath() ) );
        }

        dependencyArtifact.setDependencyFilter( createDependencyFilter( dependency, dependencyFilter ) );

        return dependencyArtifact;
    }
4010#private static String getEffectiveScope( String originalScope, String inheritedScope )
    {
        String effectiveScope = Artifact.SCOPE_RUNTIME;

        if ( originalScope == null )
        {
            originalScope = Artifact.SCOPE_COMPILE;
        }

        if ( inheritedScope == null )
        {
            // direct dependency retains its scope
            effectiveScope = originalScope;
        }
        else if ( Artifact.SCOPE_TEST.equals( originalScope ) || Artifact.SCOPE_PROVIDED.equals( originalScope ) )
        {
            // test and provided are not transitive, so exclude them
            effectiveScope = null;
        }
        else if ( Artifact.SCOPE_SYSTEM.equals( originalScope ) )
        {
            // system scope come through unchanged...
            effectiveScope = Artifact.SCOPE_SYSTEM;
        }
        else if ( Artifact.SCOPE_COMPILE.equals( originalScope ) && Artifact.SCOPE_COMPILE.equals( inheritedScope ) )
        {
            // added to retain compile scope. Remove if you want compile inherited as runtime
            effectiveScope = Artifact.SCOPE_COMPILE;
        }
        else if ( Artifact.SCOPE_TEST.equals( inheritedScope ) )
        {
            effectiveScope = Artifact.SCOPE_TEST;
        }
        else if ( Artifact.SCOPE_PROVIDED.equals( inheritedScope ) )
        {
            effectiveScope = Artifact.SCOPE_PROVIDED;
        }

        return effectiveScope;
    }
4011#private static ArtifactFilter createDependencyFilter( Dependency dependency, ArtifactFilter inheritedFilter )
    {
        ArtifactFilter effectiveFilter = inheritedFilter;

        if ( !dependency.getExclusions().isEmpty() )
        {
            List<String> exclusions = new ArrayList<String>();

            for ( Exclusion e : dependency.getExclusions() )
            {
                exclusions.add( e.getGroupId() + ':' + e.getArtifactId() );
            }

            effectiveFilter = new ExcludesArtifactFilter( exclusions );

            if ( inheritedFilter != null )
            {
                effectiveFilter = new AndArtifactFilter( Arrays.asList( inheritedFilter, effectiveFilter ) );
            }
        }

        return effectiveFilter;
    }
4012#public List<ArtifactVersion> retrieveAvailableVersions( Artifact artifact, ArtifactRepository localRepository,
                                                            List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException
    {
        MetadataResolutionRequest request = new DefaultMetadataResolutionRequest();
        injectSession( request );
        request.setArtifact( artifact );
        request.setLocalRepository( localRepository );
        request.setRemoteRepositories( remoteRepositories );
        return retrieveAvailableVersions( request );
    }
4013#public List<ArtifactVersion> retrieveAvailableVersions( MetadataResolutionRequest request )
        throws ArtifactMetadataRetrievalException
    {
        RepositoryMetadata metadata = new ArtifactRepositoryMetadata( request.getArtifact() );

        try
        {
            repositoryMetadataManager.resolve( metadata, request );
        }
        catch ( RepositoryMetadataResolutionException e )
        {
            throw new ArtifactMetadataRetrievalException( e.getMessage(), e, request.getArtifact() );
        }

        List<String> availableVersions = request.getLocalRepository().findVersions( request.getArtifact() );

        return retrieveAvailableVersionsFromMetadata( metadata.getMetadata(), availableVersions );
    }
4014#public List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository( Artifact artifact,
                                                                                    ArtifactRepository localRepository,
                                                                                    ArtifactRepository deploymentRepository )
        throws ArtifactMetadataRetrievalException
    {
        RepositoryMetadata metadata = new ArtifactRepositoryMetadata( artifact );

        try
        {
            repositoryMetadataManager.resolveAlways( metadata, localRepository, deploymentRepository );
        }
        catch ( RepositoryMetadataResolutionException e )
        {
            throw new ArtifactMetadataRetrievalException( e.getMessage(), e, artifact );
        }

        List<String> availableVersions = localRepository.findVersions( artifact );

        return retrieveAvailableVersionsFromMetadata( metadata.getMetadata(), availableVersions );
    }
4015#private List<ArtifactVersion> retrieveAvailableVersionsFromMetadata( Metadata repoMetadata,
                                                                         List<String> availableVersions )
    {
        Collection<String> versions = new LinkedHashSet<String>();

        if ( ( repoMetadata != null ) && ( repoMetadata.getVersioning() != null ) )
        {
            versions.addAll( repoMetadata.getVersioning().getVersions() );
        }

        versions.addAll( availableVersions );

        List<ArtifactVersion> artifactVersions = new ArrayList<ArtifactVersion>( versions.size() );

        for ( String version : versions )
        {
            artifactVersions.add( new DefaultArtifactVersion( version ) );
        }

        return artifactVersions;
    }
4016#// USED BY MAVEN ASSEMBLY PLUGIN
    @Deprecated
    public static Set<Artifact> createArtifacts( ArtifactFactory artifactFactory, List<Dependency> dependencies,
                                                 String inheritedScope, ArtifactFilter dependencyFilter,
                                                 MavenProject project )
        throws InvalidDependencyVersionException
    {
        Set<Artifact> artifacts = new LinkedHashSet<Artifact>();

        for ( Dependency d : dependencies )
        {
            Artifact dependencyArtifact;
            try
            {
                dependencyArtifact = createDependencyArtifact( artifactFactory, d, inheritedScope, dependencyFilter );
            }
            catch ( InvalidVersionSpecificationException e )
            {
                throw new InvalidDependencyVersionException( project.getId(), d, project.getFile(), e );
            }

            if ( dependencyArtifact != null )
            {
                artifacts.add( dependencyArtifact );
            }
        }

        return artifacts;
    }
4017#private ProjectBuilder getProjectBuilder()
    {
        if ( projectBuilder != null )
        {
            return projectBuilder;
        }

        try
        {
            projectBuilder = container.lookup( ProjectBuilder.class );
        }
        catch ( ComponentLookupException e )
        {
            // Won't happen
        }

        return projectBuilder;
    }
4018#private ProjectRelocation retrieveRelocatedProject( Artifact artifact, MetadataResolutionRequest repositoryRequest )
        throws ArtifactMetadataRetrievalException
    {
        MavenProject project;

        Artifact pomArtifact;
        Artifact relocatedArtifact = null;
        boolean done = false;
        do
        {
            project = null;

            pomArtifact =
                repositorySystem.createProjectArtifact( artifact.getGroupId(),
                                                        artifact.getArtifactId(),
                                                        artifact.getVersion(), artifact.getScope() );

            if ( "pom".equals( artifact.getType() ) )
            {
                pomArtifact.setFile( artifact.getFile() );
            }

            if ( Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )
            {
                done = true;
            }
            else
            {
                try
                {
                    ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();
                    configuration.setLocalRepository( repositoryRequest.getLocalRepository() );
                    configuration.setRemoteRepositories( repositoryRequest.getRemoteRepositories() );
                    configuration.setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL );
                    configuration.setProcessPlugins( false );
                    configuration.setRepositoryMerging( ProjectBuildingRequest.RepositoryMerging.REQUEST_DOMINANT );
                    configuration.setSystemProperties( getSystemProperties() );
                    configuration.setRepositorySession( legacySupport.getRepositorySession() );

                    project = getProjectBuilder().build( pomArtifact, configuration ).getProject();
                }
                catch ( ProjectBuildingException e )
                {
                    ModelProblem missingParentPom = hasMissingParentPom( e );
                    if ( missingParentPom != null )
                    {
                        throw new ArtifactMetadataRetrievalException( "Failed to process POM for "
                            + artifact.getId() + ": " + missingParentPom.getMessage(),
                                                                      missingParentPom.getException(),
                                                                      artifact );
                    }

                    String message;

                    if ( isMissingPom( e ) )
                    {
                        message = "Missing POM for " + artifact.getId();
                    }
                    else if ( isNonTransferrablePom( e ) )
                    {
                        throw new ArtifactMetadataRetrievalException( "Failed to retrieve POM for "
                            + artifact.getId() + ": " + e.getCause().getMessage(), e.getCause(),
                                                                      artifact );
                    }
                    else
                    {
                        message =
                            "Invalid POM for " + artifact.getId()
                                + ", transitive dependencies (if any) will not be available"
                                + ", enable debug logging for more details";
                    }

                    if ( logger.isDebugEnabled() )
                    {
                        message += ": " + e.getMessage();
                    }

                    logger.warn( message );
                }

                if ( project != null )
                {
                    Relocation relocation = null;

                    DistributionManagement distMgmt = project.getDistributionManagement();
                    if ( distMgmt != null )
                    {
                        relocation = distMgmt.getRelocation();

                        artifact.setDownloadUrl( distMgmt.getDownloadUrl() );
                        pomArtifact.setDownloadUrl( distMgmt.getDownloadUrl() );
                    }

                    if ( relocation != null )
                    {
                        if ( relocation.getGroupId() != null )
                        {
                            artifact.setGroupId( relocation.getGroupId() );
                            relocatedArtifact = artifact;
                            project.setGroupId( relocation.getGroupId() );
                        }
                        if ( relocation.getArtifactId() != null )
                        {
                            artifact.setArtifactId( relocation.getArtifactId() );
                            relocatedArtifact = artifact;
                            project.setArtifactId( relocation.getArtifactId() );
                        }
                        if ( relocation.getVersion() != null )
                        {
                            // note: see MNG-3454. This causes a problem, but fixing it may break more.
                            artifact.setVersionRange( VersionRange.createFromVersion( relocation.getVersion() ) );
                            relocatedArtifact = artifact;
                            project.setVersion( relocation.getVersion() );
                        }

                        if ( artifact.getDependencyFilter() != null
                            && !artifact.getDependencyFilter().include( artifact ) )
                        {
                            return null;
                        }

                        // MNG-2861: the artifact data has changed. If the available versions where previously
                        // retrieved, we need to update it.
                        // TODO: shouldn't the versions be merged across relocations?
                        List<ArtifactVersion> available = artifact.getAvailableVersions();
                        if ( available != null && !available.isEmpty() )
                        {
                            MetadataResolutionRequest metadataRequest =
                                new DefaultMetadataResolutionRequest( repositoryRequest );
                            metadataRequest.setArtifact( artifact );
                            available = retrieveAvailableVersions( metadataRequest );
                            artifact.setAvailableVersions( available );
                        }

                        String message =
                            "\n  This artifact has been relocated to " + artifact.getGroupId() + ":"
                                + artifact.getArtifactId() + ":" + artifact.getVersion() + ".\n";

                        if ( relocation.getMessage() != null )
                        {
                            message += "  " + relocation.getMessage() + "\n";
                        }

                        if ( artifact.getDependencyTrail() != null && artifact.getDependencyTrail().size() == 1 )
                        {
                            logger.warn( "While downloading " + pomArtifact.getGroupId() + ":"
                                + pomArtifact.getArtifactId() + ":" + pomArtifact.getVersion() + message + "\n" );
                        }
                        else
                        {
                            logger.debug( "While downloading " + pomArtifact.getGroupId() + ":"
                                + pomArtifact.getArtifactId() + ":" + pomArtifact.getVersion() + message + "\n" );
                        }
                    }
                    else
                    {
                        done = true;
                    }
                }
                else
                {
                    done = true;
                }
            }
        }
        while ( !done );

        ProjectRelocation rel = new ProjectRelocation();
        rel.project = project;
        rel.pomArtifact = pomArtifact;
        rel.relocatedArtifact = relocatedArtifact;

        return rel;
    }
4019#private ModelProblem hasMissingParentPom( ProjectBuildingException e )
    {
        if ( e.getCause() instanceof ModelBuildingException )
        {
            ModelBuildingException mbe = (ModelBuildingException) e.getCause();
            for ( ModelProblem problem : mbe.getProblems() )
            {
                if ( problem.getException() instanceof UnresolvableModelException )
                {
                    return problem;
                }
            }

        }
        return null;
    }
4020#private boolean isMissingPom( Exception e )
    {
        if ( e.getCause() instanceof MultipleArtifactsNotFoundException )
        {
            return true;
        }
        if ( e.getCause() instanceof org.sonatype.aether.resolution.ArtifactResolutionException
            && e.getCause().getCause() instanceof ArtifactNotFoundException )
        {
            return true;
        }
        return false;
    }
4021#private boolean isNonTransferrablePom( Exception e )
    {
        if ( e.getCause() instanceof ArtifactResolutionException )
        {
            return true;
        }
        if ( e.getCause() instanceof org.sonatype.aether.resolution.ArtifactResolutionException
            && !( e.getCause().getCause() instanceof ArtifactNotFoundException ) )
        {
            return true;
        }
        return false;
    }
4022#private Properties getSystemProperties()
    {
        Properties props = new Properties();

        EnvironmentUtils.addEnvVars( props );

        props.putAll( System.getProperties() );

        return props;
    }
4023#List<Dependency> getDependencies();
4024#List<Dependency> getManagedDependencies();
4025#public ActiveProjectArtifact( MavenProject project, Artifact artifact )
    {
        this.artifact = artifact;
        this.project = project;

        artifact.setFile( project.getArtifact().getFile() );
        artifact.setResolved( true );
    }
4026#/** {@inheritDoc} */
    public File getFile()
    {
        // we need to get the latest file for the project, not the artifact that was created at one point in time
        return project.getArtifact().getFile();
    }
4027#/** {@inheritDoc} */
    public String getGroupId()
    {
        return artifact.getGroupId();
    }
4028#/** {@inheritDoc} */
    public String getArtifactId()
    {
        return artifact.getArtifactId();
    }
4029#/** {@inheritDoc} */
    public String getVersion()
    {
        return artifact.getVersion();
    }
4030#/** {@inheritDoc} */
    public void setVersion( String version )
    {
        artifact.setVersion( version );
    }
4031#/** {@inheritDoc} */
    public String getScope()
    {
        return artifact.getScope();
    }
4032#/** {@inheritDoc} */
    public String getType()
    {
        return artifact.getType();
    }
4033#/** {@inheritDoc} */
    public String getClassifier()
    {
        return artifact.getClassifier();
    }
4034#/** {@inheritDoc} */
    public boolean hasClassifier()
    {
        return artifact.hasClassifier();
    }
4035#/** {@inheritDoc} */
    public void setFile( File destination )
    {
        artifact.setFile( destination );
        project.getArtifact().setFile( destination );
    }
4036#/** {@inheritDoc} */
    public String getBaseVersion()
    {
        return artifact.getBaseVersion();
    }
4037#/** {@inheritDoc} */
    public void setBaseVersion( String baseVersion )
    {
        artifact.setBaseVersion( baseVersion );
    }
4038#/** {@inheritDoc} */
    public String getId()
    {
        return artifact.getId();
    }
4039#/** {@inheritDoc} */
    public String getDependencyConflictId()
    {
        return artifact.getDependencyConflictId();
    }
4040#/** {@inheritDoc} */
    public void addMetadata( ArtifactMetadata metadata )
    {
        artifact.addMetadata( metadata );
    }
4041#/** {@inheritDoc} */
    public Collection<ArtifactMetadata> getMetadataList()
    {
        return artifact.getMetadataList();
    }
4042#/** {@inheritDoc} */
    public void setRepository( ArtifactRepository remoteRepository )
    {
        artifact.setRepository( remoteRepository );
    }
4043#/** {@inheritDoc} */
    public ArtifactRepository getRepository()
    {
        return artifact.getRepository();
    }
4044#/** {@inheritDoc} */
    public void updateVersion( String version, ArtifactRepository localRepository )
    {
        artifact.updateVersion( version, localRepository );
    }
4045#/** {@inheritDoc} */
    public String getDownloadUrl()
    {
        return artifact.getDownloadUrl();
    }
4046#/** {@inheritDoc} */
    public void setDownloadUrl( String downloadUrl )
    {
        artifact.setDownloadUrl( downloadUrl );
    }
4047#/** {@inheritDoc} */
    public ArtifactFilter getDependencyFilter()
    {
        return artifact.getDependencyFilter();
    }
4048#/** {@inheritDoc} */
    public void setDependencyFilter( ArtifactFilter artifactFilter )
    {
        artifact.setDependencyFilter( artifactFilter );
    }
4049#/** {@inheritDoc} */
    public ArtifactHandler getArtifactHandler()
    {
        return artifact.getArtifactHandler();
    }
4050#/** {@inheritDoc} */
    public List<String> getDependencyTrail()
    {
        return artifact.getDependencyTrail();
    }
4051#/** {@inheritDoc} */
    public void setDependencyTrail( List<String> dependencyTrail )
    {
        artifact.setDependencyTrail( dependencyTrail );
    }
4052#/** {@inheritDoc} */
    public void setScope( String scope )
    {
        artifact.setScope( scope );
    }
4053#/** {@inheritDoc} */
    public VersionRange getVersionRange()
    {
        return artifact.getVersionRange();
    }
4054#/** {@inheritDoc} */
    public void setVersionRange( VersionRange newRange )
    {
        artifact.setVersionRange( newRange );
    }
4055#/** {@inheritDoc} */
    public void selectVersion( String version )
    {
        artifact.selectVersion( version );
    }
4056#/** {@inheritDoc} */
    public void setGroupId( String groupId )
    {
        artifact.setGroupId( groupId );
    }
4057#/** {@inheritDoc} */
    public void setArtifactId( String artifactId )
    {
        artifact.setArtifactId( artifactId );
    }
4058#/** {@inheritDoc} */
    public boolean isSnapshot()
    {
        return artifact.isSnapshot();
    }
4059#/** {@inheritDoc} */
    public int compareTo( Artifact a )
    {
        return artifact.compareTo( a );
    }
4060#/** {@inheritDoc} */
    public void setResolved( boolean resolved )
    {
        artifact.setResolved( resolved );
    }
4061#/** {@inheritDoc} */
    public boolean isResolved()
    {
        return artifact.isResolved();
    }
4062#/** {@inheritDoc} */
    public void setResolvedVersion( String version )
    {
        artifact.setResolvedVersion( version );
    }
4063#/** {@inheritDoc} */
    public void setArtifactHandler( ArtifactHandler handler )
    {
        artifact.setArtifactHandler( handler );
    }
4064#/** {@inheritDoc} */
    public String toString()
    {
        return "active project artifact:\n\tartifact = " + artifact + ";\n\tproject: " + project;
    }
4065#/** {@inheritDoc} */
    public boolean isRelease()
    {
        return artifact.isRelease();
    }
4066#/** {@inheritDoc} */
    public void setRelease( boolean release )
    {
        artifact.setRelease( release );
    }
4067#/** {@inheritDoc} */
    public List<ArtifactVersion> getAvailableVersions()
    {
        return artifact.getAvailableVersions();
    }
4068#/** {@inheritDoc} */
    public void setAvailableVersions( List<ArtifactVersion> versions )
    {
        artifact.setAvailableVersions( versions );
    }
4069#/** {@inheritDoc} */
    public boolean isOptional()
    {
        return artifact.isOptional();
    }
4070#/** {@inheritDoc} */
    public ArtifactVersion getSelectedVersion()
        throws OverConstrainedVersionException
    {
        return artifact.getSelectedVersion();
    }
4071#/** {@inheritDoc} */
    public boolean isSelectedVersionKnown()
        throws OverConstrainedVersionException
    {
        return artifact.isSelectedVersionKnown();
    }
4072#/** {@inheritDoc} */
    public void setOptional( boolean optional )
    {
        artifact.setOptional( optional );
    }
4073#/** {@inheritDoc} */
    public int hashCode()
    {
        int result = 17;

        result = 37 * result + getGroupId().hashCode();
        result = 37 * result + getArtifactId().hashCode();
        result = 37 * result + getType().hashCode();
        if ( getVersion() != null )
        {
            result = 37 * result + getVersion().hashCode();
        }
        result = 37 * result + ( getClassifier() != null ? getClassifier().hashCode() : 0 );

        return result;
    }
4074#/** {@inheritDoc} */
    public boolean equals( Object o )
    {
        if ( o == this )
        {
            return true;
        }

        if ( !( o instanceof Artifact ) )
        {
            return false;
        }

        Artifact a = (Artifact) o;

        if ( !a.getGroupId().equals( getGroupId() ) )
        {
            return false;
        }
        else if ( !a.getArtifactId().equals( getArtifactId() ) )
        {
            return false;
        }
        else if ( !a.getVersion().equals( getVersion() ) )
        {
            return false;
        }
        else if ( !a.getType().equals( getType() ) )
        {
            return false;
        }
        else if ( a.getClassifier() == null ? getClassifier() != null : !a.getClassifier().equals( getClassifier() ) )
        {
            return false;
        }

        return true;
    }
4075#public AttachedArtifact( Artifact parent, String type, String classifier, ArtifactHandler artifactHandler )
    {
        super( parent.getGroupId(), parent.getArtifactId(), parent.getVersionRange(), parent.getScope(), type,
               classifier, artifactHandler, parent.isOptional() );

        setDependencyTrail( Collections.singletonList( parent.getId() ) );

        this.parent = parent;

        if ( getId().equals( parent.getId() ) )
        {
            throw new InvalidArtifactRTException( parent.getGroupId(), parent.getArtifactId(), parent.getVersion(),
                                                  parent.getType(), "An attached artifact must have a different ID"
                                                      + " than its corresponding main artifact." );
        }
    }
4076#public AttachedArtifact( Artifact parent, String type, ArtifactHandler artifactHandler )
    {
        this( parent, type, null, artifactHandler );
    }
4077#public void setArtifactId( String artifactId )
    {
        throw new UnsupportedOperationException( "Cannot change the artifactId for an attached artifact."
            + " It is derived from the main artifact." );
    }
4078#public List getAvailableVersions()
    {
        return parent.getAvailableVersions();
    }
4079#public void setAvailableVersions( List availableVersions )
    {
        throw new UnsupportedOperationException( "Cannot change the version information for an attached artifact."
            + " It is derived from the main artifact." );
    }
4080#public String getBaseVersion()
    {
        return parent.getBaseVersion();
    }
4081#public void setBaseVersion( String baseVersion )
    {
        throw new UnsupportedOperationException( "Cannot change the version information for an attached artifact."
            + " It is derived from the main artifact." );
    }
4082#public String getDownloadUrl()
    {
        return parent.getDownloadUrl();
    }
4083#public void setDownloadUrl( String downloadUrl )
    {
        throw new UnsupportedOperationException( "Cannot change the download information for an attached artifact."
            + " It is derived from the main artifact." );
    }
4084#public void setGroupId( String groupId )
    {
        throw new UnsupportedOperationException( "Cannot change the groupId for an attached artifact."
            + " It is derived from the main artifact." );
    }
4085#public ArtifactRepository getRepository()
    {
        return parent.getRepository();
    }
4086#public void setRepository( ArtifactRepository repository )
    {
        throw new UnsupportedOperationException( "Cannot change the repository information for an attached artifact."
            + " It is derived from the main artifact." );
    }
4087#public String getScope()
    {
        return parent.getScope();
    }
4088#public void setScope( String scope )
    {
        throw new UnsupportedOperationException( "Cannot change the scoping information for an attached artifact."
            + " It is derived from the main artifact." );
    }
4089#public String getVersion()
    {
        return parent.getVersion();
    }
4090#public void setVersion( String version )
    {
        throw new UnsupportedOperationException( "Cannot change the version information for an attached artifact."
            + " It is derived from the main artifact." );
    }
4091#public VersionRange getVersionRange()
    {
        return parent.getVersionRange();
    }
4092#public void setVersionRange( VersionRange range )
    {
        throw new UnsupportedOperationException( "Cannot change the version information for an attached artifact."
            + " It is derived from the main artifact." );
    }
4093#public boolean isRelease()
    {
        return parent.isRelease();
    }
4094#public void setRelease( boolean release )
    {
        throw new UnsupportedOperationException( "Cannot change the version information for an attached artifact."
            + " It is derived from the main artifact." );
    }
4095#public boolean isSnapshot()
    {
        return parent.isSnapshot();
    }
4096#public void addMetadata( ArtifactMetadata metadata )
    {
        // ignore. The parent artifact will handle metadata.
        // we must fail silently here to avoid problems with the artifact transformers.
    }
4097#public Collection getMetadataList()
    {
        return Collections.EMPTY_LIST;
    }
4098#public InvalidDependencyVersionException( String projectId, Dependency dependency, File pomFile,
                                              InvalidVersionSpecificationException cause )
    {
        super( projectId, formatLocationInPom( dependency ), dependency.getVersion(), pomFile, cause );
        this.dependency = dependency;
    }
4099#private static String formatLocationInPom( Dependency dependency )
    {
        return "Dependency: " + ArtifactUtils.versionlessKey( dependency.getGroupId(), dependency.getArtifactId() );
    }
4100#public Dependency getDependency()
    {
        return dependency;
    }
4101#ResolutionGroup get( Artifact artifact, boolean resolveManagedVersions, ArtifactRepository localRepository,
                         List<ArtifactRepository> remoteRepositories );
4102#void put( Artifact artifact, boolean resolveManagedVersions, ArtifactRepository localRepository,
              List<ArtifactRepository> remoteRepositories, ResolutionGroup result );
4103#void flush();
4104#public ProjectArtifactMetadata( Artifact artifact )
    {
        this( artifact, null );
    }
4105#public ProjectArtifactMetadata( Artifact artifact, File file )
    {
        super( artifact );
        this.file = file;
    }
4106#public File getFile()
    {
        return file;
    }
4107#public String getRemoteFilename()
    {
        return getFilename();
    }
4108#public String getLocalFilename( ArtifactRepository repository )
    {
        return getFilename();
    }
4109#private String getFilename()
    {
        return getArtifactId() + "-" + artifact.getVersion() + ".pom";
    }
4110#public void storeInLocalRepository( ArtifactRepository localRepository, ArtifactRepository remoteRepository )
        throws RepositoryMetadataStoreException
    {
        File destination =
            new File( localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata( this,
                                                                                                   remoteRepository ) );

        // ----------------------------------------------------------------------------
        // I'm fully aware that the file could just be moved using File.rename but
        // there are bugs in various JVM that have problems doing this across
        // different filesystem. So we'll incur the small hit to actually copy
        // here and be safe. jvz.
        // ----------------------------------------------------------------------------

        try
        {
            FileUtils.copyFile( file, destination );
        }
        catch ( IOException e )
        {
            throw new RepositoryMetadataStoreException( "Error copying POM to the local repository.", e );
        }
    }
4111#public String toString()
    {
        return "project information for " + artifact.getArtifactId() + " " + artifact.getVersion();
    }
4112#public boolean storedInArtifactVersionDirectory()
    {
        return true;
    }
4113#public String getBaseVersion()
    {
        return artifact.getBaseVersion();
    }
4114#public Object getKey()
    {
        return "project " + artifact.getGroupId() + ":" + artifact.getArtifactId();
    }
4115#public void merge( ArtifactMetadata metadata )
    {
        ProjectArtifactMetadata m = (ProjectArtifactMetadata) metadata;
        if ( !m.file.equals( file ) )
        {
            throw new IllegalStateException( "Cannot add two different pieces of metadata for: " + getKey() );
        }
    }
4116#public void merge( org.apache.maven.repository.legacy.metadata.ArtifactMetadata metadata )
    {
        this.merge( (ArtifactMetadata) metadata );
    }
4117#public ProjectArtifact( MavenProject project )
    {
        super( project.getGroupId(), project.getArtifactId(), project.getVersion(), null, "pom", null,
               new PomArtifactHandler() );
        this.project = project;
        setFile( project.getFile() );
        setResolved( true );
    }
4118#public MavenProject getProject()
    {
        return project;
    }
4119#public List<Dependency> getDependencies()
    {
        return project.getDependencies();
    }
4120#public List<Dependency> getManagedDependencies()
    {
        DependencyManagement depMngt = project.getDependencyManagement();
        return ( depMngt != null ) ? depMngt.getDependencies() : Collections.<Dependency> emptyList();
    }
4121#public String getClassifier()
        {
            return null;
        }
4122#public String getDirectory()
        {
            return null;
        }
4123#public String getExtension()
        {
            return "pom";
        }
4124#public String getLanguage()
        {
            return "none";
        }
4125#public String getPackaging()
        {
            return "pom";
        }
4126#public boolean isAddedToClasspath()
        {
            return false;
        }
4127#public boolean isIncludesDependencies()
        {
            return false;
        }
4128#private static int artifactHashCode( Artifact a )
    {
        int result = 17;
        result = 31 * result + a.getGroupId().hashCode();
        result = 31 * result + a.getArtifactId().hashCode();
        result = 31 * result + a.getType().hashCode();
        if ( a.getVersion() != null )
        {
            result = 31 * result + a.getVersion().hashCode();
        }
        result = 31 * result + ( a.getClassifier() != null ? a.getClassifier().hashCode() : 0 );
        result = 31 * result + ( a.getScope() != null ? a.getScope().hashCode() : 0 );
        result = 31 * result + ( a.getDependencyFilter() != null ? a.getDependencyFilter().hashCode() : 0 );
        result = 31 * result + ( a.isOptional() ? 1 : 0 );
        return result;
    }
4129#private static boolean artifactEquals( Artifact a1, Artifact a2 )
    {
        if ( a1 == a2 )
        {
            return true;
        }

        return eq( a1.getGroupId(), a2.getGroupId() )
            && eq( a1.getArtifactId(), a2.getArtifactId() )
            && eq( a1.getType(), a2.getType() )
            && eq( a1.getVersion(), a2.getVersion() )
            && eq( a1.getClassifier(), a2.getClassifier() )
            && eq( a1.getScope(), a2.getScope() )
            && eq( a1.getDependencyFilter(), a2.getDependencyFilter() )
            && a1.isOptional() == a2.isOptional();
    }
4130#private static int repositoryHashCode( ArtifactRepository repository )
    {
        int result = 17;
        result = 31 * result + ( repository.getId() != null ? repository.getId().hashCode() : 0 );
        return result;
    }
4131#private static int repositoriesHashCode( List<ArtifactRepository> repositories )
    {
        int result = 17;
        for ( ArtifactRepository repository : repositories )
        {
            result = 31 * result + repositoryHashCode( repository );
        }
        return result;
    }
4132#private static boolean repositoryEquals( ArtifactRepository r1, ArtifactRepository r2 )
    {
        if ( r1 == r2 )
        {
            return true;
        }

        return eq( r1.getId(), r2.getId() ) && eq( r1.getUrl(), r2.getUrl() )
            && repositoryPolicyEquals( r1.getReleases(), r2.getReleases() )
            && repositoryPolicyEquals( r1.getSnapshots(), r2.getSnapshots() );
    }
4133#private static boolean repositoryPolicyEquals( ArtifactRepositoryPolicy p1, ArtifactRepositoryPolicy p2 )
    {
        if ( p1 == p2 )
        {
            return true;
        }

        return p1.isEnabled() == p2.isEnabled() && eq( p1.getUpdatePolicy(), p2.getUpdatePolicy() );
    }
4134#private static boolean repositoriesEquals( List<ArtifactRepository> r1, List<ArtifactRepository> r2 )
    {
        if ( r1.size() != r2.size() )
        {
            return false;
        }

        for ( Iterator<ArtifactRepository> it1 = r1.iterator(), it2 = r2.iterator(); it1.hasNext(); )
        {
            if ( !repositoryEquals( it1.next(), it2.next() ) )
            {
                return false;
            }
        }

        return true;
    }
4135#private static <T> boolean eq( T s1, T s2 )
    {
        return s1 != null ? s1.equals( s2 ) : s2 == null;
    }
4136#public ResolutionGroup get( Artifact artifact, boolean resolveManagedVersions, ArtifactRepository localRepository,
                                List<ArtifactRepository> remoteRepositories )
    {
        CacheKey cacheKey = newCacheKey( artifact, resolveManagedVersions, localRepository, remoteRepositories );

        CacheRecord cacheRecord = cache.get( cacheKey );

        if ( cacheRecord != null && !cacheRecord.isStale() )
        {
            Artifact pomArtifact = ArtifactUtils.copyArtifact( cacheRecord.getArtifact() );
            Artifact relocatedArtifact = ArtifactUtils.copyArtifactSafe( cacheRecord.getRelocatedArtifact() );
            Set<Artifact> artifacts =
                ArtifactUtils.copyArtifacts( cacheRecord.getArtifacts(), new LinkedHashSet<Artifact>() );
            Map<String, Artifact> managedVersions = cacheRecord.getManagedVersions();
            if ( managedVersions != null )
            {
                managedVersions = ArtifactUtils.copyArtifacts( managedVersions, new LinkedHashMap<String, Artifact>() );
            }
            return new ResolutionGroup( pomArtifact, relocatedArtifact, artifacts, managedVersions,
                                        cacheRecord.getRemoteRepositories() );
        }

        cache.remove( cacheKey );

        return null;
    }
4137#public void put( Artifact artifact, boolean resolveManagedVersions, ArtifactRepository localRepository,
                     List<ArtifactRepository> remoteRepositories, ResolutionGroup result )
    {
        put( newCacheKey( artifact, resolveManagedVersions, localRepository, remoteRepositories ), result );
    }
4138#protected CacheKey newCacheKey( Artifact artifact, boolean resolveManagedVersions,
                                    ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories )
    {
        return new CacheKey( artifact, resolveManagedVersions, localRepository, remoteRepositories );
    }
4139#protected void put( CacheKey cacheKey, ResolutionGroup result )
    {
        CacheRecord cacheRecord =
            new CacheRecord( result.getPomArtifact(), result.getRelocatedArtifact(), result.getArtifacts(),
                             result.getManagedVersions(), result.getResolutionRepositories() );

        cache.put( cacheKey, cacheRecord );
    }
4140#public void flush()
    {
        cache.clear();
    }
4141#public CacheKey( Artifact artifact, boolean resolveManagedVersions, ArtifactRepository localRepository,
                         List<ArtifactRepository> remoteRepositories )
        {
            File file = artifact.getFile();
            this.artifact = ArtifactUtils.copyArtifact( artifact );
            if ( "pom".equals( artifact.getType() ) && file != null )
            {
                pomHash = file.getPath().hashCode() + file.lastModified();
            }
            else
            {
                pomHash = 0;
            }
            this.resolveManagedVersions = resolveManagedVersions;
            this.repositories.add( localRepository );
            this.repositories.addAll( remoteRepositories );

            int hash = 17;
            hash = hash * 31 + artifactHashCode( artifact );
            hash = hash * 31 + ( resolveManagedVersions ? 1 : 2 );
            hash = hash * 31 + repositoriesHashCode( repositories );
            this.hashCode = hash;
        }
4142#@Override
        public int hashCode()
        {
            return hashCode;
        }
4143#@Override
        public boolean equals( Object o )
        {
            if ( o == this )
            {
                return true;
            }

            if ( !( o instanceof CacheKey ) )
            {
                return false;
            }

            CacheKey other = (CacheKey) o;

            return pomHash == other.pomHash && artifactEquals( artifact, other.artifact )
                && resolveManagedVersions == other.resolveManagedVersions
                && repositoriesEquals( repositories, other.repositories );
        }
4144#CacheRecord( Artifact pomArtifact, Artifact relocatedArtifact, Set<Artifact> artifacts,
                     Map<String, Artifact> managedVersions, List<ArtifactRepository> remoteRepositories )
        {
            this.pomArtifact = ArtifactUtils.copyArtifact( pomArtifact );
            this.relocatedArtifact = ArtifactUtils.copyArtifactSafe( relocatedArtifact );
            this.artifacts = ArtifactUtils.copyArtifacts( artifacts, new ArrayList<Artifact>() );
            this.remoteRepositories = new ArrayList<ArtifactRepository>( remoteRepositories );

            this.managedVersions = managedVersions;
            if ( managedVersions != null )
            {
                this.managedVersions =
                    ArtifactUtils.copyArtifacts( managedVersions, new LinkedHashMap<String, Artifact>() );
            }

            File pomFile = pomArtifact.getFile();
            if ( pomFile != null && pomFile.canRead() )
            {
                this.length = pomFile.length();
                this.timestamp = pomFile.lastModified();
            }
            else
            {
                this.length = -1;
                this.timestamp = -1;
            }
        }
4145#public Artifact getArtifact()
        {
            return pomArtifact;
        }
4146#public Artifact getRelocatedArtifact()
        {
            return relocatedArtifact;
        }
4147#public List<Artifact> getArtifacts()
        {
            return artifacts;
        }
4148#public Map<String, Artifact> getManagedVersions()
        {
            return managedVersions;
        }
4149#public List<ArtifactRepository> getRemoteRepositories()
        {
            return remoteRepositories;
        }
4150#public boolean isStale()
        {
            File pomFile = pomArtifact.getFile();
            if ( pomFile != null )
            {
                if ( pomFile.canRead() )
                {
                    return length != pomFile.length() || timestamp != pomFile.lastModified();
                }
                else
                {
                    // if the POM didn't exist, retry if any repo is configured to always update
                    boolean snapshot = pomArtifact.isSnapshot();
                    for ( ArtifactRepository repository : remoteRepositories )
                    {
                        ArtifactRepositoryPolicy policy =
                            snapshot ? repository.getSnapshots() : repository.getReleases();
                        if ( ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS.equals( policy.getUpdatePolicy() ) )
                        {
                            return true;
                        }
                    }
                }
            }

            return length != -1 || timestamp != -1;
        }
4151#void alignToBaseDirectory( Model model, File basedir );
4152#String alignToBaseDirectory( String path, File basedir );
4153#void unalignFromBaseDirectory( Model model, File basedir );
4154#String unalignFromBaseDirectory( String directory, File basedir );
4155#/**
     * Adds the environment variables in the form of properties whose keys are prefixed with {@code env.}, e.g. {@code
     * env.PATH}. Unlike native environment variables, properties are always case-sensitive. For the sake of
     * determinism, the environment variable names will be normalized to upper case on platforms with case-insensitive
     * variable lookup.
     * 
     * @param props The properties to add the environment variables to, may be {@code null}.
     */
    public static void addEnvVars( Properties props )
    {
        if ( props != null )
        {
            if ( envVars == null )
            {
                Properties tmp = new Properties();
                boolean caseSensitive = !Os.isFamily( Os.FAMILY_WINDOWS );
                for ( Map.Entry<String, String> entry : System.getenv().entrySet() )
                {
                    String key =
                        "env." + ( caseSensitive ? entry.getKey() : entry.getKey().toUpperCase( Locale.ENGLISH ) );
                    tmp.setProperty( key, entry.getValue() );
                }
                envVars = tmp;
            }

            props.putAll( envVars );
        }
    }
4156#public abstract Artifact find( Artifact artifact );
4157#public abstract boolean hasLocalMetadata();
4158#Artifact createArtifact( String groupId, String artifactId, String version, String packaging );
4159#Artifact createArtifact( String groupId, String artifactId, String version, String scope, String type );
4160#Artifact createProjectArtifact( String groupId, String artifactId, String version );
4161#Artifact createArtifactWithClassifier( String groupId, String artifactId, String version, String type,
                                           String classifier );
4162#Artifact createPluginArtifact( Plugin plugin );
4163#Artifact createDependencyArtifact( Dependency dependency );
4164#ArtifactRepository buildArtifactRepository( Repository repository )
        throws InvalidRepositoryException;
4165#ArtifactRepository createDefaultRemoteRepository()
        throws InvalidRepositoryException;
4166#ArtifactRepository createDefaultLocalRepository()
        throws InvalidRepositoryException;
4167#ArtifactRepository createLocalRepository( File localRepository )
        throws InvalidRepositoryException;
4168#ArtifactRepository createArtifactRepository( String id, String url, ArtifactRepositoryLayout repositoryLayout,
                                                 ArtifactRepositoryPolicy snapshots, ArtifactRepositoryPolicy releases );
4169#/**
     * Calculates the effective repositories for the given input repositories which are assumed to be already mirrored
     * (if applicable). This process will essentially remove duplicate repositories by merging them into one equivalent
     * repository. It is worth to point out that merging does not simply choose one of the input repositories and
     * discards the others but actually combines their possibly different policies.
     *
     * @param repositories The original repositories, may be {@code null}.
     * @return The effective repositories or {@code null} if the input was {@code null}.
     */
    List<ArtifactRepository> getEffectiveRepositories( List<ArtifactRepository> repositories );
4170#/**
     * Determines the mirror for the specified repository.
     *
     * @param repository The repository to determine the mirror for, must not be {@code null}.
     * @param mirrors The available mirrors, may be {@code null}.
     * @return The mirror specification for the repository or {@code null} if no mirror matched.
     */
    Mirror getMirror( ArtifactRepository repository, List<Mirror> mirrors );
4171#/**
     * Injects the mirroring information into the specified repositories. For each repository that is matched by a
     * mirror, its URL and ID will be updated to match the values from the mirror specification. Repositories without a
     * matching mirror will pass through unchanged. <em>Note:</em> This method must be called before
     * {@link #injectAuthentication(List, List)} or the repositories will end up with the wrong credentials.
     *
     * @param repositories The repositories into which to inject the mirror information, may be {@code null}.
     * @param mirrors The available mirrors, may be {@code null}.
     */
    void injectMirror( List<ArtifactRepository> repositories, List<Mirror> mirrors );
4172#/**
     * Injects the proxy information into the specified repositories. For each repository that is matched by a proxy,
     * its proxy data will be set accordingly. Repositories without a matching proxy will have their proxy cleared.
     * <em>Note:</em> This method must be called after {@link #injectMirror(List, List)} or the repositories will end up
     * with the wrong proxies.
     *
     * @param repositories The repositories into which to inject the proxy information, may be {@code null}.
     * @param proxies The available proxies, may be {@code null}.
     */
    void injectProxy( List<ArtifactRepository> repositories, List<org.apache.maven.settings.Proxy> proxies );
4173#/**
     * Injects the authentication information into the specified repositories. For each repository that is matched by a
     * server, its credentials will be updated to match the values from the server specification. Repositories without a
     * matching server will have their credentials cleared. <em>Note:</em> This method must be called after
     * {@link #injectMirror(List, List)} or the repositories will end up with the wrong credentials.
     *
     * @param repositories The repositories into which to inject the authentication information, may be {@code null}.
     * @param servers The available servers, may be {@code null}.
     */
    void injectAuthentication( List<ArtifactRepository> repositories, List<Server> servers );
4174#void injectMirror( RepositorySystemSession session, List<ArtifactRepository> repositories );
4175#void injectProxy( RepositorySystemSession session, List<ArtifactRepository> repositories );
4176#void injectAuthentication( RepositorySystemSession session, List<ArtifactRepository> repositories );
4177#ArtifactResolutionResult resolve( ArtifactResolutionRequest request );
4178#// Install

    // Deploy

    // Map types of artifacts

    //
    // Raw file transfers
    //
    void publish( ArtifactRepository repository, File source, String remotePath,
                  ArtifactTransferListener transferListener )
        throws ArtifactTransferFailedException;
4179#void retrieve( ArtifactRepository repository, File destination, String remotePath,
                   ArtifactTransferListener transferListener )
        throws ArtifactTransferFailedException, ArtifactDoesNotExistException;
4180#public LocalRepositoryNotAccessibleException( String message, Throwable cause )
    {
        super( message );
        initCause( cause );
    }
4181#public LocalRepositoryNotAccessibleException( String message )
    {
        super( message );
    }
4182#public ArtifactTransferEvent( String wagon, final int eventType, final int requestType,
                                  ArtifactTransferResource artifact )
    {
        super( wagon );

        setEventType( eventType );

        setRequestType( requestType );

        this.artifact = artifact;
    }
4183#public ArtifactTransferEvent( String wagon, final Exception exception, final int requestType,
                                  ArtifactTransferResource artifact )
    {
        this( wagon, TRANSFER_ERROR, requestType, artifact );

        this.exception = exception;
    }
4184#public ArtifactTransferResource getResource()
    {
        return artifact;
    }
4185#/**
     * @return Returns the exception.
     */
    public Exception getException()
    {
        return exception;
    }
4186#/**
     * Returns the request type.
     *
     * @return Returns the request type. The Request type is one of
     *         <code>TransferEvent.REQUEST_GET<code> or <code>TransferEvent.REQUEST_PUT<code>
     */
    public int getRequestType()
    {
        return requestType;
    }
4187#/**
     * Sets the request type
     *
     * @param requestType The requestType to set.
     *                    The Request type value should be either
     *                    <code>TransferEvent.REQUEST_GET<code> or <code>TransferEvent.REQUEST_PUT<code>.
     * @throws IllegalArgumentException when
     */
    public void setRequestType( final int requestType )
    {
        switch ( requestType )
        {

            case REQUEST_PUT:
                break;
            case REQUEST_GET:
                break;

            default :
                throw new IllegalArgumentException( "Illegal request type: " + requestType );
        }

        this.requestType = requestType;
    }
4188#/**
     * @return Returns the eventType.
     */
    public int getEventType()
    {
        return eventType;
    }
4189#/**
     * @param eventType The eventType to set.
     */
    public void setEventType( final int eventType )
    {
        switch ( eventType )
        {

            case TRANSFER_INITIATED:
                break;
            case TRANSFER_STARTED:
                break;
            case TRANSFER_COMPLETED:
                break;
            case TRANSFER_PROGRESS:
                break;
            case TRANSFER_ERROR:
                break;
            default :
                throw new IllegalArgumentException( "Illegal event type: " + eventType );
        }

        this.eventType = eventType;
    }
4190#/**
     * @return Returns the local file.
     */
    public File getLocalFile()
    {
        return localFile;
    }
4191#/**
     * @param localFile The local file to set.
     */
    public void setLocalFile( File localFile )
    {
        this.localFile = localFile;
    }
4192#public long getTransferredBytes()
    {
        return transferredBytes;
    }
4193#public void setTransferredBytes( long transferredBytes )
    {
        this.transferredBytes = transferredBytes;
    }
4194#public byte[] getDataBuffer()
    {
        return dataBuffer;
    }
4195#public void setDataBuffer( byte[] dataBuffer )
    {
        this.dataBuffer = dataBuffer;
    }
4196#public int getDataOffset()
    {
        return dataOffset;
    }
4197#public void setDataOffset( int dataOffset )
    {
        this.dataOffset = dataOffset;
    }
4198#public int getDataLength()
    {
        return dataLength;
    }
4199#public void setDataLength( int dataLength )
    {
        this.dataLength = dataLength;
    }
4200#public String toString()
    {
        StringBuffer sb = new StringBuffer();

        sb.append( "TransferEvent[" );

        switch ( this.getRequestType() )
        {
            case REQUEST_GET:
                sb.append( "GET" );
                break;
            case REQUEST_PUT:
                sb.append( "PUT" );
                break;
            default:
                sb.append( this.getRequestType() );
                break;
        }

        sb.append( "|" );
        switch ( this.getEventType() )
        {
            case TRANSFER_COMPLETED:
                sb.append( "COMPLETED" );
                break;
            case TRANSFER_ERROR:
                sb.append( "ERROR" );
                break;
            case TRANSFER_INITIATED:
                sb.append( "INITIATED" );
                break;
            case TRANSFER_PROGRESS:
                sb.append( "PROGRESS" );
                break;
            case TRANSFER_STARTED:
                sb.append( "STARTED" );
                break;
            default:
                sb.append( this.getEventType() );
                break;
        }

        sb.append( "|" );
        sb.append( this.getLocalFile() ).append( "|" );
        sb.append( "]" );

        return sb.toString();
    }
4201#public int hashCode()
    {
        final int prime = 31;
        int result = 1;
        result = prime * result + eventType;
        result = prime * result + ( ( exception == null ) ? 0 : exception.hashCode() );
        result = prime * result + ( ( localFile == null ) ? 0 : localFile.hashCode() );
        result = prime * result + requestType;
        return result;
    }
4202#public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( ( obj == null ) || ( getClass() != obj.getClass() ) )
        {
            return false;
        }
        final ArtifactTransferEvent other = (ArtifactTransferEvent) obj;
        if ( eventType != other.eventType )
        {
            return false;
        }
        if ( exception == null )
        {
            if ( other.exception != null )
            {
                return false;
            }
        }
        else if ( !exception.getClass().equals( other.exception.getClass() ) )
        {
            return false;
        }
        if ( requestType != other.requestType )
        {
            return false;
        }
        else if ( !source.equals( other.source ) )
        {
            return false;
        }
        return true;
    }
4203#/**
     * The base URL of the repository, e.g. "http://repo1.maven.org/maven2/". Unless the URL is unknown, it will be
     * terminated by a trailing slash.
     * 
     * @return The base URL of the repository or an empty string if unknown, never {@code null}.
     */
    String getRepositoryUrl();
4204#/**
     * The path of the artifact relative to the repository's base URL.
     * 
     * @return The path of the artifact, never {@code null}.
     */
    String getName();
4205#/**
     * Gets the full URL of the artifact.
     * 
     * @return The full URL of the artifact, never {@code null}.
     */
    String getUrl();
4206#/**
     * The size of the artifact in bytes.
     * 
     * @return The of the artifact in bytes or a negative value if unknown.
     */
    long getContentLength();
4207#/**
     * Gets the timestamp when the transfer of this artifact was started.
     * 
     * @return The timestamp when the transfer of this artifact was started.
     */
    long getTransferStartTime();
4208#boolean isShowChecksumEvents();
4209#void setShowChecksumEvents( boolean showChecksumEvents );
4210#void transferInitiated( ArtifactTransferEvent transferEvent );
4211#void transferStarted( ArtifactTransferEvent transferEvent );
4212#void transferProgress( ArtifactTransferEvent transferEvent );
4213#void transferCompleted( ArtifactTransferEvent transferEvent );
4214#public DelegatingLocalArtifactRepository( ArtifactRepository artifactRepository )
    {
        this.userLocalArtifactRepository = artifactRepository;
    }
4215#public void setBuildReactor( LocalArtifactRepository localRepository )
    {
        this.buildReactor = localRepository;
    }
4216#public void setIdeWorkspace( LocalArtifactRepository localRepository )
    {
        this.ideWorkspace = localRepository;
    }
4217#public LocalArtifactRepository getIdeWorspace()
    {
        return ideWorkspace;
    }
4218#@Override
    public Artifact find( Artifact artifact )
    {
        if ( !artifact.isRelease() && buildReactor != null )
        {
            artifact = buildReactor.find( artifact );
        }

        if ( !artifact.isResolved() && ideWorkspace != null )
        {
            artifact = ideWorkspace.find( artifact );
        }

        if ( !artifact.isResolved() )
        {
            artifact = userLocalArtifactRepository.find( artifact );
        }

        return artifact;
    }
4219#@Override
    public List<String> findVersions( Artifact artifact )
    {
        Collection<String> versions = new LinkedHashSet<String>();

        if ( buildReactor != null )
        {
            versions.addAll( buildReactor.findVersions( artifact ) );
        }

        if ( ideWorkspace != null )
        {
            versions.addAll( ideWorkspace.findVersions( artifact ) );
        }

        versions.addAll( userLocalArtifactRepository.findVersions( artifact ) );

        return Collections.unmodifiableList( new ArrayList<String>( versions ) );
    }
4220#public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository )
    {
        return userLocalArtifactRepository.pathOfLocalRepositoryMetadata( metadata, repository );
    }
4221#public String getId()
    {
        return userLocalArtifactRepository.getId();
    }
4222#@Override
    public String pathOf( Artifact artifact )
    {
        return userLocalArtifactRepository.pathOf( artifact );
    }
4223#@Override
    public String getBasedir()
    {
        return ( userLocalArtifactRepository != null ) ? userLocalArtifactRepository.getBasedir() : null;
    }
4224#@Override
    public ArtifactRepositoryLayout getLayout()
    {
        return userLocalArtifactRepository.getLayout();
    }
4225#@Override
    public ArtifactRepositoryPolicy getReleases()
    {
        return userLocalArtifactRepository.getReleases();
    }
4226#@Override
    public ArtifactRepositoryPolicy getSnapshots()
    {
        return userLocalArtifactRepository.getSnapshots();
    }
4227#@Override
    public String getKey()
    {
        return userLocalArtifactRepository.getKey();
    }
4228#@Override
    public String getUrl()
    {
        return userLocalArtifactRepository.getUrl();
    }
4229#@Override
    public int hashCode()
    {
        int hash = 17;
        hash = hash * 31 + ( buildReactor == null ? 0 : buildReactor.hashCode() );
        hash = hash * 31 + ( ideWorkspace == null ? 0 : ideWorkspace.hashCode() );
        hash = hash * 31 + ( userLocalArtifactRepository == null ? 0 : userLocalArtifactRepository.hashCode() );

        return hash;
    }
4230#@Override
    public boolean equals( Object obj )
    {
        if ( this == obj )
        {
            return true;
        }
        if ( obj == null )
        {
            return false;
        }
        if ( getClass() != obj.getClass() )
        {
            return false;
        }
        
        DelegatingLocalArtifactRepository other = (DelegatingLocalArtifactRepository) obj;

        return eq( buildReactor, other.buildReactor )
            && eq( ideWorkspace, other.ideWorkspace )
            && eq( userLocalArtifactRepository, other.userLocalArtifactRepository );
    }
4231#public ArtifactDoesNotExistException( final String message )
    {
        super( message );
    }
4232#public ArtifactDoesNotExistException( final String message, final Throwable cause )
    {
        super( message, cause );
    }
4233#public ArtifactTransferFailedException( final String message )
    {
        super( message );
    }
4234#public ArtifactTransferFailedException( final String message, final Throwable cause )
    {
        super( message, cause );
    }
4235#/**
     * Indicates whether network access to remote repositories has been disabled.
     * 
     * @return {@code true} if remote access has been disabled, {@code false} otherwise.
     */
    boolean isOffline();
4236#/**
     * Enables/disables network access to remote repositories.
     * 
     * @param offline {@code true} to disable remote access, {@code false} to allow network access.
     * @return This request, never {@code null}.
     */
    MetadataResolutionRequest setOffline( boolean offline );
4237#/**
     * Gets the artifact to resolve metadata for.
     * 
     * @return The artifact to resolve metadata for or {@code null} if not set.
     */
    Artifact getArtifact();
4238#/**
     * Sets the artifact for which to resolve metadata.
     * 
     * @param artifact The artifact for which to resolve metadata.
     * @return This request, never {@code null}.
     */
    MetadataResolutionRequest setArtifact( Artifact artifact );
4239#/**
     * Gets the local repository to use for the resolution.
     * 
     * @return The local repository to use for the resolution or {@code null} if not set.
     */
    ArtifactRepository getLocalRepository();
4240#/**
     * Sets the local repository to use for the resolution.
     * 
     * @param localRepository The local repository to use for the resolution.
     * @return This request, never {@code null}.
     */
    MetadataResolutionRequest setLocalRepository( ArtifactRepository localRepository );
4241#/**
     * Gets the remote repositories to use for the resolution.
     * 
     * @return The remote repositories to use for the resolution, never {@code null}.
     */
    List<ArtifactRepository> getRemoteRepositories();
4242#/**
     * Sets the remote repositories to use for the resolution.
     * 
     * @param remoteRepositories The remote repositories to use for the resolution.
     * @return This request, never {@code null}.
     */
    MetadataResolutionRequest setRemoteRepositories( List<ArtifactRepository> remoteRepositories );
4243#/**
     * Determines whether the managed version information should be retrieved.
     * 
     * @return {@code true} if the dependency management information should be retrieved, {@code false} otherwise.
     */
    boolean isResolveManagedVersions();
4244#/**
     * Enables/disables resolution of the dependency manageemnt information.
     * 
     * @param resolveManagedVersions {@code true} if the dependency management information should be retrieved, {@code
     *            false} otherwise.
     * @return This request, never {@code null}.
     */
    MetadataResolutionRequest setResolveManagedVersions( boolean resolveManagedVersions );
4245#public ResolutionGroup( Artifact pomArtifact, Set<Artifact> artifacts,
                            List<ArtifactRepository> resolutionRepositories )
    {
        this( pomArtifact, null, artifacts, null, resolutionRepositories );
    }
4246#public ResolutionGroup( Artifact pomArtifact, Artifact relocatedArtifact, Set<Artifact> artifacts,
                            Map<String, Artifact> managedVersions, List<ArtifactRepository> resolutionRepositories )
    {
        this.pomArtifact = pomArtifact;
        this.relocatedArtifact = relocatedArtifact;
        this.artifacts = artifacts;
        this.managedVersions = managedVersions;
        this.resolutionRepositories = resolutionRepositories;
    }
4247#public Artifact getPomArtifact()
    {
        return pomArtifact;
    }
4248#public Artifact getRelocatedArtifact()
    {
        return relocatedArtifact;
    }
4249#public Set<Artifact> getArtifacts()
    {
        return artifacts;
    }
4250#public List<ArtifactRepository> getResolutionRepositories()
    {
        return resolutionRepositories;
    }
4251#public Map<String, Artifact> getManagedVersions()
    {
        return managedVersions;
    }
4252#ResolutionGroup retrieve( MetadataResolutionRequest request )
        throws ArtifactMetadataRetrievalException;
4253#ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository,
                              List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException;
4254#/**
     * Get a list of available versions for an artifact in the remote repository
     *
     * @param artifact           artifact we are interested in. Only <code>groupid</code> and <code>artifactId</code>
     *                           are needed, for instance the following code will work
     *                           <code>artifactFactory.createProjectArtifact( "org.apache.maven", "maven", "" )</code>
     * @param localRepository    local repository
     * @param remoteRepositories remote repositories, {@link List} $lt; {@link ArtifactRepository} >
     * @return {@link List} $lt; {@link ArtifactVersion} >
     * @throws ArtifactMetadataRetrievalException
     *          in case of error while retrieving repository metadata from the repository.
     */
    List<ArtifactVersion> retrieveAvailableVersions( Artifact artifact, ArtifactRepository localRepository,
                                                     List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException;
4255#/**
     * Get a list of available versions for an artifact in the remote deployment repository. This ignores any update
     * policy checks and mirrors and always retrieves the latest information from the given repository.
     *
     * @param artifact artifact we are interested in. Only <code>groupid</code> and <code>artifactId</code> are
     *            needed, for instance the following code will work
     *            <code>artifactFactory.createProjectArtifact( "org.apache.maven", "maven", "" )</code>
     * @param localRepository    local repository
     * @param deploymentRepository remote repository
     * @return {@link List} $lt; {@link ArtifactVersion} >
     * @throws ArtifactMetadataRetrievalException
     *          in case of error while retrieving repository metadata from the repository.
     */
    List<ArtifactVersion> retrieveAvailableVersionsFromDeploymentRepository( Artifact artifact,
                                                                             ArtifactRepository localRepository,
                                                                             ArtifactRepository remoteRepository )
        throws ArtifactMetadataRetrievalException;
4256#/** @deprecated use {@link #ArtifactMetadataRetrievalException(String, Throwable, Artifact)} */
    @Deprecated
    public ArtifactMetadataRetrievalException( String message )
    {
        this( message, null, null );
    }
4257#/** @deprecated use {@link #ArtifactMetadataRetrievalException(String, Throwable, Artifact)} */
    @Deprecated
    public ArtifactMetadataRetrievalException( Throwable cause )
    {
        this( null, cause, null );
    }
4258#/** @deprecated use {@link #ArtifactMetadataRetrievalException(String, Throwable, Artifact)} */
    @Deprecated
    public ArtifactMetadataRetrievalException( String message,
                                               Throwable cause )
    {
        this( message, cause, null );
    }
4259#public ArtifactMetadataRetrievalException( String message,
                                               Throwable cause,
                                               Artifact artifact )
    {
        super( message, cause );
        this.artifact = artifact;
    }
4260#public Artifact getArtifact()
    {
        return artifact;
    }
4261#public DefaultMetadataResolutionRequest()
    {
        repositoryRequest = new DefaultRepositoryRequest();
    }
4262#public DefaultMetadataResolutionRequest( RepositoryRequest repositoryRequest )
    {
        this.repositoryRequest = new DefaultRepositoryRequest( repositoryRequest );
    }
4263#public DefaultMetadataResolutionRequest( ArtifactResolutionRequest resolutionRequest )
    {
        this.repositoryRequest = new DefaultRepositoryRequest( resolutionRequest );
    }
4264#public Artifact getArtifact()
    {
        return artifact;
    }
4265#public DefaultMetadataResolutionRequest setArtifact( Artifact artifact )
    {
        this.artifact = artifact;

        return this;
    }
4266#public ArtifactRepository getLocalRepository()
    {
        return repositoryRequest.getLocalRepository();
    }
4267#public DefaultMetadataResolutionRequest setLocalRepository( ArtifactRepository localRepository )
    {
        repositoryRequest.setLocalRepository( localRepository );

        return this;
    }
4268#public List<ArtifactRepository> getRemoteRepositories()
    {
        return repositoryRequest.getRemoteRepositories();
    }
4269#public DefaultMetadataResolutionRequest setRemoteRepositories( List<ArtifactRepository> remoteRepositories )
    {
        repositoryRequest.setRemoteRepositories( remoteRepositories );

        return this;
    }
4270#public boolean isResolveManagedVersions()
    {
        return resolveManagedVersions;
    }
4271#public DefaultMetadataResolutionRequest setResolveManagedVersions( boolean resolveManagedVersions )
    {
        this.resolveManagedVersions = resolveManagedVersions;

        return this;
    }
4272#public boolean isOffline()
    {
        return repositoryRequest.isOffline();
    }
4273#public DefaultMetadataResolutionRequest setOffline( boolean offline )
    {
        repositoryRequest.setOffline( offline );

        return this;
    }
4274#public boolean isForceUpdate()
    {
        return repositoryRequest.isForceUpdate();
    }
4275#public DefaultMetadataResolutionRequest setForceUpdate( boolean forceUpdate )
    {
        repositoryRequest.setForceUpdate( forceUpdate );

        return this;
    }
4276#protected AbstractArtifactMetadata( Artifact artifact )
    {
        this.artifact = artifact;
    }
4277#public boolean storedInGroupDirectory()
    {
        return false;
    }
4278#public String getGroupId()
    {
        return artifact.getGroupId();
    }
4279#public String getArtifactId()
    {
        return artifact.getArtifactId();
    }
4280#public String extendedToString()
    {
        StringBuilder buffer = new StringBuilder();

        buffer.append( "\nArtifact Metadata\n--------------------------" );
        buffer.append( "\nGroupId: " ).append( getGroupId() );
        buffer.append( "\nArtifactId: " ).append( getArtifactId() );
        buffer.append( "\nMetadata Type: " ).append( getClass().getName() );

        return buffer.toString();
    }
4281#/**
     * Retrieves the current Maven version, for example "3.0.2".
     * 
     * @return The current Maven version or an empty string if unknown, never {@code null}.
     */
    String getMavenVersion();
4282#/**
     * Checks whether the current Maven runtime matches the specified version range. A version range can either use the
     * usual mathematical syntax "[2.0.10,2.1.0),[3.0,)" or use a single version "2.2.1". The latter is a short form for
     * "[2.2.1,)", i.e. denotes the minimum version required.
     * 
     * @param versionRange The version range to match the current Maven runtime against, must not be {@code null}.
     * @return {@code true} if the current Maven runtime matches the specified version range, {@code false} otherwise.
     * @throws IllegalArgumentException If the specified version range is {@code null}, empty or otherwise not a valid
     *             version specification.
     */
    boolean isMavenVersion( String versionRange );
4283#public String getMavenVersion()
    {
        if ( mavenVersion == null )
        {
            Properties props = new Properties();

            String resource = "META-INF/maven/org.apache.maven/maven-core/pom.properties";

            InputStream is = DefaultRuntimeInformation.class.getResourceAsStream( "/" + resource );
            if ( is != null )
            {
                try
                {
                    props.load( is );
                }
                catch ( IOException e )
                {
                    String msg = "Could not parse " + resource + ", Maven runtime information not available";
                    if ( logger.isDebugEnabled() )
                    {
                        logger.warn( msg, e );
                    }
                    else
                    {
                        logger.warn( msg );
                    }
                }
                finally
                {
                    IOUtil.close( is );
                }
            }
            else
            {
                logger.warn( "Could not locate " + resource + " on classpath, Maven runtime information not available" );
            }

            String version = props.getProperty( "version", "" ).trim();

            if ( !version.startsWith( "${" ) )
            {
                mavenVersion = version;
            }
            else
            {
                mavenVersion = "";
            }
        }

        return mavenVersion;
    }
4284#public boolean isMavenVersion( String versionRange )
    {
        VersionScheme versionScheme = new GenericVersionScheme();

        if ( versionRange == null )
        {
            throw new IllegalArgumentException( "Version range must not be null" );
        }
        if ( StringUtils.isBlank( versionRange ) )
        {
            throw new IllegalArgumentException( "Version range must not be empty" );
        }

        VersionConstraint constraint;
        try
        {
            constraint = versionScheme.parseVersionConstraint( versionRange );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            throw new IllegalArgumentException( e.getMessage(), e );
        }

        Version current;
        try
        {
            String mavenVersion = getMavenVersion();
            if ( mavenVersion.length() <= 0 )
            {
                throw new IllegalStateException( "Could not determine current Maven version" );
            }

            current = versionScheme.parseVersion( mavenVersion );
        }
        catch ( InvalidVersionSpecificationException e )
        {
            throw new IllegalStateException( "Could not parse current Maven version: " + e.getMessage(), e );
        }

        if ( constraint.getRanges().isEmpty() )
        {
            return constraint.getVersion().compareTo( current ) <= 0;
        }
        return constraint.containsVersion( current );
    }
4285#public SettingsConfigurationException( String message )
    {
        super( message );
    }
4286#public SettingsConfigurationException( String message, Throwable cause )
    {
        super( message, cause );
    }
4287#public SettingsConfigurationException( String message, Throwable cause, int lineNumber, int columnNumber )
    {
        super( message + ( lineNumber > 0 ? "\n  Line:   " + lineNumber : "" )
            + ( columnNumber > 0 ? "\n  Column: " + columnNumber : "" ), cause );
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }
4288#public int getColumnNumber()
    {
        return columnNumber;
    }
4289#public int getLineNumber()
    {
        return lineNumber;
    }
4290#private SettingsUtils()
    {
        // don't allow construction.
    }
4291#/**
     * @param dominant
     * @param recessive
     * @param recessiveSourceLevel
     */
    public static void merge( Settings dominant, Settings recessive, String recessiveSourceLevel )
    {
        new MavenSettingsMerger().merge( dominant, recessive, recessiveSourceLevel );
    }
4292#/**
     * @param settingsProfile
     * @return a profile
     */
    public static Profile convertToSettingsProfile( org.apache.maven.model.Profile modelProfile )
    {
        Profile profile = new Profile();

        profile.setId( modelProfile.getId() );

        org.apache.maven.model.Activation modelActivation = modelProfile.getActivation();

        if ( modelActivation != null )
        {
            Activation activation = new Activation();

            activation.setActiveByDefault( modelActivation.isActiveByDefault() );

            activation.setJdk( modelActivation.getJdk() );

            org.apache.maven.model.ActivationProperty modelProp = modelActivation.getProperty();

            if ( modelProp != null )
            {
                ActivationProperty prop = new ActivationProperty();
                prop.setName( modelProp.getName() );
                prop.setValue( modelProp.getValue() );
                activation.setProperty( prop );
            }

            org.apache.maven.model.ActivationOS modelOs = modelActivation.getOs();

            if ( modelOs != null )
            {
                ActivationOS os = new ActivationOS();

                os.setArch( modelOs.getArch() );
                os.setFamily( modelOs.getFamily() );
                os.setName( modelOs.getName() );
                os.setVersion( modelOs.getVersion() );

                activation.setOs( os );
            }

            ActivationFile modelFile = modelActivation.getFile();

            if ( modelFile != null )
            {
                org.apache.maven.settings.ActivationFile file = new org.apache.maven.settings.ActivationFile();

                file.setExists( modelFile.getExists() );
                file.setMissing( modelFile.getMissing() );

                activation.setFile( file );
            }

            profile.setActivation( activation );
        }

        profile.setProperties( modelProfile.getProperties() );

        List<org.apache.maven.model.Repository> repos = modelProfile.getRepositories();
        if ( repos != null )
        {
            for ( org.apache.maven.model.Repository repo : repos )
            {
                profile.addRepository( convertToSettingsRepository( repo ) );
            }
        }

        List<org.apache.maven.model.Repository> pluginRepos = modelProfile.getPluginRepositories();
        if ( pluginRepos != null )
        {
            for ( org.apache.maven.model.Repository pluginRepo : pluginRepos )
            {
                profile.addPluginRepository( convertToSettingsRepository( pluginRepo ) );
            }
        }

        return profile;
    }
4293#/**
     * @param settingsProfile
     * @return a profile
     */
    public static org.apache.maven.model.Profile convertFromSettingsProfile( Profile settingsProfile )
    {
        org.apache.maven.model.Profile profile = new org.apache.maven.model.Profile();

        profile.setId( settingsProfile.getId() );

        profile.setSource( "settings.xml" );

        Activation settingsActivation = settingsProfile.getActivation();

        if ( settingsActivation != null )
        {
            org.apache.maven.model.Activation activation = new org.apache.maven.model.Activation();

            activation.setActiveByDefault( settingsActivation.isActiveByDefault() );

            activation.setJdk( settingsActivation.getJdk() );

            ActivationProperty settingsProp = settingsActivation.getProperty();

            if ( settingsProp != null )
            {
                org.apache.maven.model.ActivationProperty prop = new org.apache.maven.model.ActivationProperty();

                prop.setName( settingsProp.getName() );
                prop.setValue( settingsProp.getValue() );

                activation.setProperty( prop );
            }

            ActivationOS settingsOs = settingsActivation.getOs();

            if ( settingsOs != null )
            {
                org.apache.maven.model.ActivationOS os = new org.apache.maven.model.ActivationOS();

                os.setArch( settingsOs.getArch() );
                os.setFamily( settingsOs.getFamily() );
                os.setName( settingsOs.getName() );
                os.setVersion( settingsOs.getVersion() );

                activation.setOs( os );
            }

            org.apache.maven.settings.ActivationFile settingsFile = settingsActivation.getFile();

            if ( settingsFile != null )
            {
                ActivationFile file = new ActivationFile();

                file.setExists( settingsFile.getExists() );
                file.setMissing( settingsFile.getMissing() );

                activation.setFile( file );
            }

            profile.setActivation( activation );
        }

        profile.setProperties( settingsProfile.getProperties() );

        List<Repository> repos = settingsProfile.getRepositories();
        if ( repos != null )
        {
            for ( Repository repo : repos )
            {
                profile.addRepository( convertFromSettingsRepository( repo ) );
            }
        }

        List<Repository> pluginRepos = settingsProfile.getPluginRepositories();
        if ( pluginRepos != null )
        {
            for ( Repository pluginRepo : pluginRepos )
            {
                profile.addPluginRepository( convertFromSettingsRepository( pluginRepo ) );
            }
        }

        return profile;
    }
4294#/**
     * @param settingsRepo
     * @return a repository
     */
    private static org.apache.maven.model.Repository convertFromSettingsRepository( Repository settingsRepo )
    {
        org.apache.maven.model.Repository repo = new org.apache.maven.model.Repository();

        repo.setId( settingsRepo.getId() );
        repo.setLayout( settingsRepo.getLayout() );
        repo.setName( settingsRepo.getName() );
        repo.setUrl( settingsRepo.getUrl() );

        if ( settingsRepo.getSnapshots() != null )
        {
            repo.setSnapshots( convertRepositoryPolicy( settingsRepo.getSnapshots() ) );
        }
        if ( settingsRepo.getReleases() != null )
        {
            repo.setReleases( convertRepositoryPolicy( settingsRepo.getReleases() ) );
        }

        return repo;
    }
4295#/**
     * @param settingsPolicy
     * @return a RepositoryPolicy
     */
    private static org.apache.maven.model.RepositoryPolicy convertRepositoryPolicy( RepositoryPolicy settingsPolicy )
    {
        org.apache.maven.model.RepositoryPolicy policy = new org.apache.maven.model.RepositoryPolicy();
        policy.setEnabled( settingsPolicy.isEnabled() );
        policy.setUpdatePolicy( settingsPolicy.getUpdatePolicy() );
        policy.setChecksumPolicy( settingsPolicy.getChecksumPolicy() );
        return policy;
    }
4296#/**
     * @param modelRepo
     * @return a repository
     */
    private static Repository convertToSettingsRepository( org.apache.maven.model.Repository modelRepo )
    {
        Repository repo = new Repository();

        repo.setId( modelRepo.getId() );
        repo.setLayout( modelRepo.getLayout() );
        repo.setName( modelRepo.getName() );
        repo.setUrl( modelRepo.getUrl() );

        if ( modelRepo.getSnapshots() != null )
        {
            repo.setSnapshots( convertRepositoryPolicy( modelRepo.getSnapshots() ) );
        }
        if ( modelRepo.getReleases() != null )
        {
            repo.setReleases( convertRepositoryPolicy( modelRepo.getReleases() ) );
        }

        return repo;
    }
4297#/**
     * @param modelPolicy
     * @return a RepositoryPolicy
     */
    private static RepositoryPolicy convertRepositoryPolicy( org.apache.maven.model.RepositoryPolicy modelPolicy )
    {
        RepositoryPolicy policy = new RepositoryPolicy();
        policy.setEnabled( modelPolicy.isEnabled() );
        policy.setUpdatePolicy( modelPolicy.getUpdatePolicy() );
        policy.setChecksumPolicy( modelPolicy.getChecksumPolicy() );
        return policy;
    }
4298#/**
     * @param settings could be null
     * @return a new instance of settings or null if settings was null.
     */
    public static Settings copySettings( Settings settings )
    {
        if ( settings == null )
        {
            return null;
        }

        Settings clone = new Settings();
        clone.setActiveProfiles( settings.getActiveProfiles() );
        clone.setInteractiveMode( settings.isInteractiveMode() );
        clone.setLocalRepository( settings.getLocalRepository() );
        clone.setMirrors( settings.getMirrors() );
        clone.setModelEncoding( settings.getModelEncoding() );
        clone.setOffline( settings.isOffline() );
        clone.setPluginGroups( settings.getPluginGroups() );
        clone.setProfiles( settings.getProfiles() );
        clone.setProxies( settings.getProxies() );
        clone.setServers( settings.getServers() );
        clone.setSourceLevel( settings.getSourceLevel() );
        clone.setUsePluginRegistry( settings.isUsePluginRegistry() );

        return clone;
    }
4299#public Settings buildSettings()
        throws IOException, XmlPullParserException
    {
        File userSettingsFile =
            getFile( "${user.home}/.m2/settings.xml", "user.home",
                     MavenSettingsBuilder.ALT_USER_SETTINGS_XML_LOCATION );

        return buildSettings( userSettingsFile );
    }
4300#public Settings buildSettings( boolean useCachedSettings )
        throws IOException, XmlPullParserException
    {
        return buildSettings();
    }
4301#public Settings buildSettings( File userSettingsFile )
        throws IOException, XmlPullParserException
    {
        File globalSettingsFile =
            getFile( "${maven.home}/conf/settings.xml", "maven.home",
                     MavenSettingsBuilder.ALT_GLOBAL_SETTINGS_XML_LOCATION );

        SettingsBuildingRequest request = new DefaultSettingsBuildingRequest();
        request.setUserSettingsFile( userSettingsFile );
        request.setGlobalSettingsFile( globalSettingsFile );
        request.setSystemProperties( System.getProperties() );
        return build( request );
    }
4302#public Settings buildSettings( File userSettingsFile, boolean useCachedSettings )
        throws IOException, XmlPullParserException
    {
        return buildSettings( userSettingsFile );
    }
4303#private Settings build( SettingsBuildingRequest request )
        throws IOException, XmlPullParserException
    {
        try
        {
            return settingsBuilder.build( request ).getEffectiveSettings();
        }
        catch ( SettingsBuildingException e )
        {
            throw (IOException) new IOException( e.getMessage() ).initCause( e );
        }
    }
4304#/** @since 2.1 */
    public Settings buildSettings( MavenExecutionRequest request )
        throws IOException, XmlPullParserException
    {
        SettingsBuildingRequest settingsRequest = new DefaultSettingsBuildingRequest();
        settingsRequest.setUserSettingsFile( request.getUserSettingsFile() );
        settingsRequest.setGlobalSettingsFile( request.getGlobalSettingsFile() );
        settingsRequest.setUserProperties( request.getUserProperties() );
        settingsRequest.setSystemProperties( request.getSystemProperties() );

        return build( settingsRequest );
    }
4305#private File getFile( String pathPattern, String basedirSysProp, String altLocationSysProp )
    {
        // -------------------------------------------------------------------------------------
        // Alright, here's the justification for all the regexp wizardry below...
        //
        // Continuum and other server-like apps may need to locate the user-level and
        // global-level settings somewhere other than ${user.home} and ${maven.home},
        // respectively. Using a simple replacement of these patterns will allow them
        // to specify the absolute path to these files in a customized components.xml
        // file. Ideally, we'd do full pattern-evaluation against the sysprops, but this
        // is a first step. There are several replacements below, in order to normalize
        // the path character before we operate on the string as a regex input, and
        // in order to avoid surprises with the File construction...
        // -------------------------------------------------------------------------------------

        String path = System.getProperty( altLocationSysProp );

        if ( StringUtils.isEmpty( path ) )
        {
            // TODO: This replacing shouldn't be necessary as user.home should be in the
            // context of the container and thus the value would be interpolated by Plexus
            String basedir = System.getProperty( basedirSysProp );
            if ( basedir == null )
            {
                basedir = System.getProperty( "user.dir" );
            }

            basedir = basedir.replaceAll( "\\\\", "/" );
            basedir = basedir.replaceAll( "\\$", "\\\\\\$" );

            path = pathPattern.replaceAll( "\\$\\{" + basedirSysProp + "\\}", basedir );
            path = path.replaceAll( "\\\\", "/" );
            // ---------------------------------------------------------------------------------
            // I'm not sure if this last regexp was really intended to disallow the usage of
            // network paths as user.home directory. Unfortunately it did. I removed it and
            // have not detected any problems yet.
            // ---------------------------------------------------------------------------------
            // path = path.replaceAll( "//", "/" );

            return new File( path ).getAbsoluteFile();
        }
        else
        {
            return new File( path ).getAbsoluteFile();
        }
    }
4306#Settings buildSettings( MavenExecutionRequest request )
        throws IOException, XmlPullParserException;
4307#/**
     * @return a <code>Settings</code> object from the user settings file.
     * @throws IOException if any
     * @throws XmlPullParserException if any
     */
    Settings buildSettings()
        throws IOException, XmlPullParserException;
4308#/**
     * @param useCachedSettings if true, doesn't reload the user settings
     * @return a <code>Settings</code> object from the user settings file.
     * @throws IOException if any
     * @throws XmlPullParserException if any
     */
    Settings buildSettings( boolean useCachedSettings )
        throws IOException, XmlPullParserException;
4309#/**
     * @param userSettingsFile a given user settings file
     * @return a <code>Settings</code> object from the user settings file.
     * @throws IOException if any
     * @throws XmlPullParserException if any
     */
    Settings buildSettings( File userSettingsFile )
        throws IOException, XmlPullParserException;
4310#/**
     * @param userSettingsFile a given user settings file
     * @param useCachedSettings if true, doesn't reload the user settings
     * @return a <code>Settings</code> object from the user settings file.
     * @throws IOException if any
     * @throws XmlPullParserException if any
     */
    Settings buildSettings( File userSettingsFile, boolean useCachedSettings )
        throws IOException, XmlPullParserException;
4311#/**
     * Let the toolchain decide if it matches requirements defined
     * in the toolchain plugin configuration.
     * @param requirements Map<String, String> key value pair
     * @return
     */
    boolean matchesRequirements( Map requirements );
4312#ToolchainModel getModel();
4313#String getType();
4314#/**
     * Gets the platform tool executable.
     *
     * @param toolName the tool platform independent tool name.
     * @return file representing the tool executable, or null if the tool can not be found
     */
    String findTool( String toolName );
4315#public Toolchain getToolchainFromBuildContext( String type, MavenSession session )
    {
        Map<String, Object> context = retrieveContext( session );

        ToolchainModel model = (ToolchainModel) context.get( getStorageKey( type ) );

        if ( model != null )
        {
            try
            {
                ToolchainFactory fact = factories.get( type );
                if ( fact != null )
                {
                    return fact.createToolchain( model );
                }
                else
                {
                    logger.error( "Missing toolchain factory for type: " + type
                        + ". Possibly caused by misconfigured project." );
                }
            }
            catch ( MisconfiguredToolchainException ex )
            {
                logger.error( "Misconfigured toolchain.", ex );
            }
        }

        return null;
    }
4316#Map<String, Object> retrieveContext( MavenSession session )
    {
        Map<String, Object> context = null;

        if ( session != null )
        {
            PluginDescriptor desc = new PluginDescriptor();
            desc.setGroupId( PluginDescriptor.getDefaultPluginGroupId() );
            desc.setArtifactId( PluginDescriptor.getDefaultPluginArtifactId( "toolchains" ) );

            MavenProject current = session.getCurrentProject();
            
            if ( current != null )
            {
                //TODO: why is this using the context
                context = session.getPluginContext( desc, current );
            }
        }

        return ( context != null ) ? context : new HashMap<String, Object>();
    }
4317#public static final String getStorageKey( String type )
    {
        return "toolchain-" + type; // NOI18N
    }
4318#protected DefaultToolchain( ToolchainModel model, Logger logger )
    {
        this.model = model;

        this.logger = logger;
    }
4319#protected DefaultToolchain( ToolchainModel model, String type, Logger logger )
    {
        this( model, logger );
        this.type = type;
    }
4320#public final String getType()
    {
        return type != null ? type : model.getType();
    }
4321#public final ToolchainModel getModel()
    {
        return model;
    }
4322#public final void addProvideToken( String type, RequirementMatcher matcher )
    {
        provides.put( type, matcher );
    }
4323#public boolean matchesRequirements( Map requirements )
    {
        Iterator it = requirements.keySet().iterator();
        while ( it.hasNext() )
        {
            String key = (String) it.next();

            RequirementMatcher matcher = provides.get( key );

            if ( matcher == null )
            {
                getLog().debug( "Toolchain " + this + " is missing required property: " + key );
                return false;
            }
            if ( !matcher.matches( (String) requirements.get( key ) ) )
            {
                getLog().debug( "Toolchain " + this + " doesn't match required property: " + key );
                return false;
            }
        }
        return true;
    }
4324#protected Logger getLog()
    {
        return logger;
    }
4325#public PersistedToolchains build( File userToolchainsFile )
        throws MisconfiguredToolchainException
    {
        PersistedToolchains toolchains = null;

        if ( userToolchainsFile != null && userToolchainsFile.isFile() )
        {
            Reader in = null;
            try
            {
                in = ReaderFactory.newXmlReader( userToolchainsFile );
                toolchains = new MavenToolchainsXpp3Reader().read( in );
            }
            catch ( Exception e )
            {
                throw new MisconfiguredToolchainException( "Cannot read toolchains file at "
                    + userToolchainsFile.getAbsolutePath(), e );
            }
            finally
            {
                IOUtil.close( in );
            }
        }
        else if ( userToolchainsFile != null )
        {
            logger.debug( "Toolchains configuration was not found at " + userToolchainsFile );
        }

        return toolchains;
    }
4326#public MisconfiguredToolchainException( String message )
    {
        super( message );
    }
4327#public MisconfiguredToolchainException( String message, Throwable orig )
    {
        super( message, orig );
    }
4328#/**
     * Retrieves the toolchains of given type from the user settings.
     */
    ToolchainPrivate[] getToolchainsForType( String type, MavenSession context )
        throws MisconfiguredToolchainException;
4329#/**
     * Stores the toolchain into build context.
     */
    void storeToolchainToBuildContext( ToolchainPrivate toolchain, MavenSession context );
4330#/**
     * to be used from plugins capable of working with toolchains.
     */
    Toolchain getToolchainFromBuildContext( String type, MavenSession context );
4331#boolean matches( String requirement );
4332#public ToolchainPrivate[] getToolchainsForType( String type, MavenSession context )
        throws MisconfiguredToolchainException
    {
        PersistedToolchains pers = toolchainsBuilder.build( context.getRequest().getUserToolchainsFile() );

        List<ToolchainPrivate> toRet = new ArrayList<ToolchainPrivate>();

        if ( pers != null )
        {
            List<ToolchainModel> lst = pers.getToolchains();
            if ( lst != null )
            {
                for ( ToolchainModel toolchainModel : lst )
                {
                    ToolchainFactory fact = factories.get( toolchainModel.getType() );
                    if ( fact != null )
                    {
                        toRet.add( fact.createToolchain( toolchainModel ) );
                    }
                    else
                    {
                        logger.error( "Missing toolchain factory for type: " + toolchainModel.getType()
                            + ". Possibly caused by misconfigured project." );
                    }
                }
            }
        }

        for ( ToolchainFactory toolchainFactory : factories.values() )
        {
            ToolchainPrivate tool = toolchainFactory.createDefaultToolchain();
            if ( tool != null )
            {
                toRet.add( tool );
            }
        }

        return toRet.toArray( new ToolchainPrivate[toRet.size()] );
    }
4333#public void storeToolchainToBuildContext( ToolchainPrivate toolchain, MavenSession session )
    {
        Map<String, Object> context = retrieveContext( session );
        context.put( getStorageKey( toolchain.getType() ), toolchain.getModel() );
    }
4334#/**
     * Create instance of toolchain.
     **/
    ToolchainPrivate createToolchain( ToolchainModel model )
        throws MisconfiguredToolchainException;
4335#/**
     * Returns the default instance of the particular type of toolchain, can return null
     * if not applicable.
     * TODO keep around??
     **/
    ToolchainPrivate createDefaultToolchain();
4336#/**
     * Builds the toolchains model from the configured toolchain files.
     * 
     * @param userToolchainsFile The path to the toolchains file, may be <code>null</code> to disable parsing.
     * @return The toolchains model or <code>null</code> if no toolchain file was configured or the configured file does
     *         not exist.
     * @throws MisconfiguredToolchainException If the toolchain file exists but cannot be parsed.
     */
    PersistedToolchains build( File userToolchainsFile )
        throws MisconfiguredToolchainException;
4337#private RequirementMatcherFactory()
    {
    }
4338#public static RequirementMatcher createExactMatcher( String provideValue )
    {
        return new ExactMatcher( provideValue );
    }
4339#public static RequirementMatcher createVersionMatcher( String provideValue )
    {
        return new VersionMatcher( provideValue );
    }
4340#private ExactMatcher( String provides )
        {
            this.provides = provides;
        }
4341#public boolean matches( String requirement )
        {
            return provides.equalsIgnoreCase( requirement );
        }
4342#private VersionMatcher( String version )
        {
            this.version = new DefaultArtifactVersion( version );
        }
4343#public boolean matches( String requirement )
        {
            try
            {
                VersionRange range = VersionRange.createFromVersionSpec( requirement );
                if ( range.hasRestrictions() )
                {
                    return range.containsVersion( version );
                }
                else
                {
                    return range.getRecommendedVersion().compareTo( version ) == 0;
                }
            }
            catch ( InvalidVersionSpecificationException ex )
            {
                //TODO error reporting
                ex.printStackTrace();
                return false;
            }
        }
4344#public DefaultJavaToolChain( ToolchainModel model, Logger logger )
    {
        super( model, "jdk", logger );
    }
4345#public String getJavaHome()
    {
        return javaHome;
    }
4346#public void setJavaHome( String javaHome )
    {
        this.javaHome = javaHome;
    }
4347#public String toString()
    {
        return "JDK[" + getJavaHome() + "]";
    }
4348#public String findTool( String toolName )
    {
        File toRet = findTool( toolName, new File( FileUtils.normalize( getJavaHome() ) ) );
        if ( toRet != null )
        {
            return toRet.getAbsolutePath();
        }
        return null;
    }
4349#private static File findTool( String toolName, File installFolder )
    {
        File bin = new File( installFolder, "bin" ); //NOI18N
        if ( bin.exists() )
        {
            File tool = new File( bin, toolName + ( Os.isFamily( "windows" ) ? ".exe" : "" ) ); // NOI18N
            if ( tool.exists() )
            {
                return tool;
            }
        }
        return null;
   }
4350#public DefaultJavaToolchainFactory()
    {
    }
4351#public ToolchainPrivate createToolchain( ToolchainModel model )
        throws MisconfiguredToolchainException
    {
        if ( model == null )
        {
            return null;
        }
        DefaultJavaToolChain jtc = new DefaultJavaToolChain( model, logger );
        Xpp3Dom dom = (Xpp3Dom) model.getConfiguration();
        Xpp3Dom javahome = dom.getChild( DefaultJavaToolChain.KEY_JAVAHOME );
        if ( javahome == null )
        {
            throw new MisconfiguredToolchainException( "Java toolchain without the "
                + DefaultJavaToolChain.KEY_JAVAHOME + " configuration element." );
        }
        File normal = new File( FileUtils.normalize( javahome.getValue() ) );
        if ( normal.exists() )
        {
            jtc.setJavaHome( FileUtils.normalize( javahome.getValue() ) );
        }
        else
        {
            throw new MisconfiguredToolchainException( "Non-existing JDK home configuration at "
                + normal.getAbsolutePath() );
        }

        //now populate the provides section.
        //TODO possibly move at least parts to a utility method or abstract implementation.
        dom = (Xpp3Dom) model.getProvides();
        Xpp3Dom[] provides = dom.getChildren();
        for ( int i = 0; i < provides.length; i++ )
        {
            String key = provides[i].getName();
            String value = provides[i].getValue();
            if ( value == null )
            {
                throw new MisconfiguredToolchainException( "Provides token '" + key + "' doesn't have any value configured." );
            }
            if ( "version".equals( key ) )
            {
                jtc.addProvideToken( key,
                    RequirementMatcherFactory.createVersionMatcher( value ) );
            }
            else
            {
                jtc.addProvideToken( key,
                    RequirementMatcherFactory.createExactMatcher( value ) );
            }
        }
        return jtc;
    }
4352#public ToolchainPrivate createDefaultToolchain()
    {
        //not sure it's necessary to provide a default toolchain here.
        //only version can be eventually supplied, and
        return null;
    }
4353#protected Logger getLogger()
    {
        return logger;
    }
4354#@Override
    protected void setupContainer()
    {
        super.setupContainer();
    }
4355#@Override
    protected String getProjectsDirectory()
    {
        return "src/test/projects/lifecycle-listener";
    }
4356#public void testDependencyInjection()
        throws Exception
    {
        PlexusContainer container = getContainer();

        ComponentDescriptor cd =
            new ComponentDescriptor( InjectDependencyLifecycleListener.class, container.getContainerRealm() );
        cd.setRoleClass( AbstractMavenLifecycleParticipant.class );
        container.addComponentDescriptor( cd );

        Maven maven = container.lookup( Maven.class );
        File pom = getProject( "lifecycle-listener-dependency-injection" );
        MavenExecutionRequest request = createMavenExecutionRequest( pom );
        request.setGoals( Arrays.asList( "validate" ) );
        MavenExecutionResult result = maven.execute( request );

        assertFalse( result.getExceptions().toString(), result.hasExceptions() );

        MavenProject project = result.getProject();
        
        assertEquals( "bar", project.getProperties().getProperty( "foo" ) );

        ArrayList<Artifact> artifacts = new ArrayList<Artifact>( project.getArtifacts() );

        assertEquals( 1, artifacts.size() );
        assertEquals( INJECTED_ARTIFACT_ID, artifacts.get( 0 ).getArtifactId() );
    }
4357#@Override
        public void afterProjectsRead( MavenSession session )
        {
            MavenProject project = session.getProjects().get( 0 );

            Dependency dependency = new Dependency();
            dependency.setArtifactId( INJECTED_ARTIFACT_ID );
            dependency.setGroupId( "foo" );
            dependency.setVersion( "1.2.3" );
            dependency.setScope( "system" );
            try
            {
                dependency.setSystemPath( new File(
                                                    "src/test/projects/lifecycle-executor/project-with-additional-lifecycle-elements/pom.xml" ).getCanonicalPath() );
            }
            catch ( IOException e )
            {
                throw new RuntimeException( e );
            }

            project.getModel().addDependency( dependency );
        }
4358#@Override
        public void afterSessionStart( MavenSession session )
        {
            session.getUserProperties().setProperty( "injected", "bar" );
        }
4359#protected void setUp()
        throws Exception
    {
        super.setUp();
        maven = lookup( Maven.class );
        exceptionHandler = lookup( ExceptionHandler.class );
    }
4360#@Override
    protected void tearDown()
        throws Exception
    {
        maven = null;
        exceptionHandler = null;
        super.tearDown();
    }
4361#protected String getProjectsDirectory()
    {
        return "src/test/projects/lifecycle-executor";
    }
4362#public void testLifecycleExecutionUsingADefaultLifecyclePhase()
        throws Exception
    {
        /*
        File pom = getProject( "project-with-additional-lifecycle-elements" );
        MavenExecutionRequest request = createMavenExecutionRequest( pom );
        MavenExecutionResult result = maven.execute( request );
        if ( result.hasExceptions() )
        {
            ExceptionSummary es = exceptionHandler.handleException( result.getExceptions().get( 0 ) );
            System.out.println( es.getMessage() );
            es.getException().printStackTrace();
            fail( "Maven did not execute correctly." );
        }
        */
    }
4363#protected void setUp()
        throws Exception
    {
        super.setUp();
        resolver = lookup( ProjectDependenciesResolver.class );
    }
4364#@Override
    protected void tearDown()
        throws Exception
    {
        resolver = null;
        super.tearDown();
    }
4365#protected String getProjectsDirectory()
    {
        return "src/test/projects/project-dependencies-resolver";
    }
4366#/*
    public void testExclusionsInDependencies()
        throws Exception
    {
        MavenSession session = createMavenSession( null );
        MavenProject project = session.getCurrentProject();

        Exclusion exclusion = new Exclusion();
        exclusion.setGroupId( "org.apache.maven.its" );
        exclusion.setArtifactId( "a" );

        new ProjectBuilder( project ).addDependency( "org.apache.maven.its", "b", "0.1", Artifact.SCOPE_RUNTIME,
                                                     exclusion );
        
        Set<Artifact> artifactDependencies =
            resolver.resolve( project, Collections.singleton( Artifact.SCOPE_COMPILE ), session );
        assertEquals( 0, artifactDependencies.size() );

        artifactDependencies = resolver.resolve( project, Collections.singleton( Artifact.SCOPE_RUNTIME ), session );
        assertEquals( 1, artifactDependencies.size() );
        assertEquals( "b", artifactDependencies.iterator().next().getArtifactId() );
    }
    */
    
    public void testSystemScopeDependencies()
        throws Exception
    {
        MavenSession session = createMavenSession( null );
        MavenProject project = session.getCurrentProject();

        new ProjectBuilder( project )
            .addDependency( "com.mycompany", "system-dependency", "1.0", Artifact.SCOPE_SYSTEM, new File( getBasedir(), "pom.xml" ).getAbsolutePath() );

        Set<Artifact> artifactDependencies =
            resolver.resolve( project, Collections.singleton( Artifact.SCOPE_COMPILE ), session );
        assertEquals( 1, artifactDependencies.size() );
    }
4367#public void testSystemScopeDependencyIsPresentInTheCompileClasspathElements()
        throws Exception
    {
        File pom = getProject( "it0063" );

        Properties eps = new Properties();
        eps.setProperty( "jre.home", new File( pom.getParentFile(), "jdk/jre" ).getPath() );

        MavenSession session = createMavenSession( pom, eps );
        MavenProject project = session.getCurrentProject();

        project.setArtifacts( resolver.resolve( project, Collections.singleton( Artifact.SCOPE_COMPILE ), session ) );
                
        List<String> elements = project.getCompileClasspathElements();
        assertEquals( 2, elements.size() );
        
        List<Artifact> artifacts = project.getCompileArtifacts();
        assertEquals( 1, artifacts.size() );
        assertTrue( artifacts.get( 0 ).getFile().getName().endsWith( "tools.jar" ) );
    }
4368#protected void setUp()
        throws Exception
    {
        repositorySystem = lookup( RepositorySystem.class );
        projectBuilder = lookup( org.apache.maven.project.ProjectBuilder.class );
    }
4369#@Override
    protected void tearDown()
        throws Exception
    {
        repositorySystem = null;
        projectBuilder = null;
        super.tearDown();
    }
4370#abstract protected String getProjectsDirectory();
4371#protected File getProject( String name )
        throws Exception
    {
        File source = new File( new File( getBasedir(), getProjectsDirectory() ), name );
        File target = new File( new File( getBasedir(), "target" ), name );
        FileUtils.copyDirectoryStructureIfModified( source, target );
        return new File( target, "pom.xml" );
    }
4372#/**
     * We need to customize the standard Plexus container with the plugin discovery listener which
     * is what looks for the META-INF/maven/plugin.xml resources that enter the system when a Maven
     * plugin is loaded.
     * 
     * We also need to customize the Plexus container with a standard plugin discovery listener
     * which is the MavenPluginCollector. When a Maven plugin is discovered the MavenPluginCollector
     * collects the plugin descriptors which are found.
     */
    protected void customizeContainerConfiguration( ContainerConfiguration containerConfiguration )
    {
//        containerConfiguration.addComponentDiscoverer( PluginManager.class );
//        containerConfiguration.addComponentDiscoveryListener( PluginManager.class );
    }
4373#protected MavenExecutionRequest createMavenExecutionRequest( File pom )
        throws Exception
    {        
        MavenExecutionRequest request = new DefaultMavenExecutionRequest()
            .setPom( pom )
            .setProjectPresent( true )
            .setShowErrors( true )
            .setPluginGroups( Arrays.asList( new String[] { "org.apache.maven.plugins" } ) )
            .setLocalRepository( getLocalRepository() )
            .setRemoteRepositories( getRemoteRepositories() )
            .setPluginArtifactRepositories( getPluginArtifactRepositories() )
            .setGoals( Arrays.asList( new String[] { "package" } ) );

        return request;
    }
4374#// layer the creation of a project builder configuration with a request, but this will need to be
    // a Maven subclass because we don't want to couple maven to the project builder which we need to
    // separate.
    protected MavenSession createMavenSession( File pom )
        throws Exception        
    {
        return createMavenSession( pom, new Properties() );
    }
4375#protected MavenSession createMavenSession( File pom, Properties executionProperties )
        throws Exception
    {
        MavenExecutionRequest request = createMavenExecutionRequest( pom );
        
        ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest()
            .setLocalRepository( request.getLocalRepository() )
            .setRemoteRepositories( request.getRemoteRepositories() )
            .setPluginArtifactRepositories( request.getPluginArtifactRepositories() )
            .setSystemProperties( executionProperties );

        MavenProject project = null;

        if ( pom != null )
        {
            project = projectBuilder.build( pom, configuration ).getProject();
        }
        else
        {
            project = createStubMavenProject();
            project.setRemoteArtifactRepositories( request.getRemoteRepositories() );
            project.setPluginArtifactRepositories( request.getPluginArtifactRepositories() );
        }

        initRepoSession( configuration );

        MavenSession session =
            new MavenSession( getContainer(), configuration.getRepositorySession(), request,
                              new DefaultMavenExecutionResult() );
        session.setProjects( Arrays.asList( project ) );

        return session;
    }
4376#protected void initRepoSession( ProjectBuildingRequest request )
    {
        File localRepo = new File( request.getLocalRepository().getBasedir() );
        MavenRepositorySystemSession session = new MavenRepositorySystemSession();
        session.setLocalRepositoryManager( new SimpleLocalRepositoryManager( localRepo ) );
        request.setRepositorySession( session );
    }
4377#protected MavenProject createStubMavenProject()
    {
        Model model = new Model();
        model.setGroupId( "org.apache.maven.test" );
        model.setArtifactId( "maven-test" );
        model.setVersion( "1.0" );
        return new MavenProject( model );
    }
4378#protected List<ArtifactRepository> getRemoteRepositories()
        throws InvalidRepositoryException
    {
        File repoDir = new File( getBasedir(), "src/test/remote-repo" ).getAbsoluteFile();

        RepositoryPolicy policy = new RepositoryPolicy();
        policy.setEnabled( true );
        policy.setChecksumPolicy( "ignore" );
        policy.setUpdatePolicy( "always" );

        Repository repository = new Repository();
        repository.setId( RepositorySystem.DEFAULT_REMOTE_REPO_ID );
        repository.setUrl( "file://" + repoDir.toURI().getPath() );
        repository.setReleases( policy );
        repository.setSnapshots( policy );

        return Arrays.asList( repositorySystem.buildArtifactRepository( repository ) );
    }
4379#protected List<ArtifactRepository> getPluginArtifactRepositories()
        throws InvalidRepositoryException
    {
        return getRemoteRepositories();
    }
4380#protected ArtifactRepository getLocalRepository()
        throws InvalidRepositoryException
    {
        File repoDir = new File( getBasedir(), "target/local-repo" ).getAbsoluteFile();

        return repositorySystem.createLocalRepository( repoDir );
    }
4381#public ProjectBuilder( MavenProject project )
        {
            this.project = project;
        }
4382#public ProjectBuilder( String groupId, String artifactId, String version )
        {
            Model model = new Model();
            model.setModelVersion( "4.0.0" );
            model.setGroupId( groupId );
            model.setArtifactId( artifactId );
            model.setVersion( version );  
            model.setBuild(  new Build() );
            project = new MavenProject( model );            
        }
4383#public ProjectBuilder setGroupId( String groupId )
        {
            project.setGroupId( groupId );
            return this;
        }
4384#public ProjectBuilder setArtifactId( String artifactId )
        {
            project.setArtifactId( artifactId );
            return this;
        }
4385#public ProjectBuilder setVersion( String version )
        {
            project.setVersion( version );
            return this;
        }
4386#// Dependencies
        //
        public ProjectBuilder addDependency( String groupId, String artifactId, String version, String scope )
        {
            return addDependency( groupId, artifactId, version, scope, (Exclusion)null );
        }
4387#public ProjectBuilder addDependency( String groupId, String artifactId, String version, String scope, Exclusion exclusion )
        {
            return addDependency( groupId, artifactId, version, scope, null, exclusion );            
        }
4388#public ProjectBuilder addDependency( String groupId, String artifactId, String version, String scope, String systemPath )
        {
            return addDependency( groupId, artifactId, version, scope, systemPath, null );         
        }
4389#public ProjectBuilder addDependency( String groupId, String artifactId, String version, String scope, String systemPath, Exclusion exclusion )
        {
            Dependency d = new Dependency();
            d.setGroupId( groupId );
            d.setArtifactId( artifactId );
            d.setVersion( version );
            d.setScope( scope );
            
            if ( systemPath != null && scope.equals(  Artifact.SCOPE_SYSTEM ) )
            {
                d.setSystemPath( systemPath );
            }
            
            if ( exclusion != null )
            {
                d.addExclusion( exclusion );
            }
            
            project.getDependencies().add( d );
            
            return this;
        }
4390#// Plugins
        //
        public ProjectBuilder addPlugin( Plugin plugin )
        {
            project.getBuildPlugins().add( plugin );            
            return this;
        }
4391#public MavenProject get()
        {
            return project;
        }
4392#public PluginBuilder( String groupId, String artifactId, String version )
        {
            plugin = new Plugin();
            plugin.setGroupId( groupId );
            plugin.setArtifactId( artifactId );
            plugin.setVersion( version );                         
        }
4393#// Dependencies
        //
        public PluginBuilder addDependency( String groupId, String artifactId, String version, String scope, Exclusion exclusion )
        {
            return addDependency( groupId, artifactId, version, scope, exclusion );            
        }
4394#public PluginBuilder addDependency( String groupId, String artifactId, String version, String scope, String systemPath )
        {
            return addDependency( groupId, artifactId, version, scope, systemPath, null );         
        }
4395#public PluginBuilder addDependency( String groupId, String artifactId, String version, String scope, String systemPath, Exclusion exclusion )
        {
            Dependency d = new Dependency();
            d.setGroupId( groupId );
            d.setArtifactId( artifactId );
            d.setVersion( version );
            d.setScope( scope );
            
            if ( systemPath != null && scope.equals(  Artifact.SCOPE_SYSTEM ) )
            {
                d.setSystemPath( systemPath );
            }
            
            if ( exclusion != null )
            {
                d.addExclusion( exclusion );
            }
            
            plugin.getDependencies().add( d );
            
            return this;
        }
4396#public Plugin get()
        {
            return plugin;
        }
4397#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();

        configurator = lookup( BeanConfigurator.class );
    }
4398#@Override
    protected void tearDown()
        throws Exception
    {
        configurator = null;

        super.tearDown();
    }
4399#private Xpp3Dom toConfig( String xml )
    {
        try
        {
            return Xpp3DomBuilder.build( new StringReader( "<configuration>" + xml + "</configuration>" ) );
        }
        catch ( XmlPullParserException e )
        {
            throw new IllegalArgumentException( e );
        }
        catch ( IOException e )
        {
            throw new IllegalArgumentException( e );
        }
    }
4400#public void testMinimal()
        throws BeanConfigurationException
    {
        SomeBean bean = new SomeBean();

        Xpp3Dom config = toConfig( "<file>test</file>" );

        DefaultBeanConfigurationRequest request = new DefaultBeanConfigurationRequest();
        request.setBean( bean ).setConfiguration( config );

        configurator.configureBean( request );

        assertEquals( new File( "test" ), bean.file );
    }
4401#public void testPreAndPostProcessing()
        throws BeanConfigurationException
    {
        SomeBean bean = new SomeBean();

        Xpp3Dom config = toConfig( "<file>${test}</file>" );

        BeanConfigurationValuePreprocessor preprocessor = new BeanConfigurationValuePreprocessor()
        {
            public Object preprocessValue( String value, Class<?> type )
                throws BeanConfigurationException
            {
                if ( value != null && value.startsWith( "${" ) && value.endsWith( "}" ) )
                {
                    return value.substring( 2, value.length() - 1 );
                }
                return value;
            }
        };

        BeanConfigurationPathTranslator translator = new BeanConfigurationPathTranslator()
        {
            public File translatePath( File path )
            {
                return new File( "base", path.getPath() ).getAbsoluteFile();
            }
        };

        DefaultBeanConfigurationRequest request = new DefaultBeanConfigurationRequest();
        request.setBean( bean ).setConfiguration( config );
        request.setValuePreprocessor( preprocessor ).setPathTranslator( translator );

        configurator.configureBean( request );

        assertEquals( new File( "base/test" ).getAbsoluteFile(), bean.file );
    }
4402#public void testChildConfigurationElement()
        throws BeanConfigurationException
    {
        SomeBean bean = new SomeBean();

        Xpp3Dom config = toConfig( "<wrapper><file>test</file></wrapper>" );

        DefaultBeanConfigurationRequest request = new DefaultBeanConfigurationRequest();
        request.setBean( bean ).setConfiguration( config, "wrapper" );

        configurator.configureBean( request );

        assertEquals( new File( "test" ), bean.file );
    }
4403#public void testCopyDefault()
    {
        MavenExecutionRequest original = new DefaultMavenExecutionRequest();
        MavenExecutionRequest copy = DefaultMavenExecutionRequest.copy( original );
        assertNotNull( copy );
        assertNotSame( copy, original );
    }
4404#public void testResultWithNullTopologicallySortedProjectsIsEmptyList()
    {
        MavenExecutionResult result = new DefaultMavenExecutionResult();
        result.setTopologicallySortedProjects( null );
        List<MavenProject> projects = result.getTopologicallySortedProjects();
        assertNotNull( projects );
        assertTrue( projects.isEmpty() );
    }
4405#public DefaultSchedulesTest()
    {
    }
4406#protected void setUp()
        throws Exception
    {
        super.setUp();
        defaultSchedules = ( lookup( DefaultSchedules.class ) );
    }
4407#public void testScheduling()
        throws Exception
    {
        final List<Scheduling> schedulings = defaultSchedules.getSchedules();
        DefaultLifecyclesTest.assertNotNull( schedulings );
        DefaultLifecyclesTest.assertTrue( schedulings.size() > 0 );
        Scheduling first = schedulings.get( 0 );
        DefaultLifecyclesTest.assertNotNull( first.getLifecycle() );
        final List<Schedule> schedules = first.getSchedules();
        DefaultLifecyclesTest.assertNotNull( schedules );
        // Ok so if we ever change the first schedule this test will have to change
        Schedule firstSchedule = schedules.get( 0 );
        DefaultLifecyclesTest.assertEquals( "test", firstSchedule.getPhase() );
        DefaultLifecyclesTest.assertTrue( "Should be parllel", firstSchedule.isParallel() );

    }
4408#protected void setUp()
        throws Exception
    {
        super.setUp();
        defaultLifeCycles = lookup( DefaultLifecycles.class );
        mojoExecutor = lookup( MojoExecutor.class );
        lifeCycleBuilder = lookup( LifecycleModuleBuilder.class );
        lifeCycleDependencyResolver = lookup( LifecycleDependencyResolver.class );
        lifeCycleExecutionPlanCalculator = lookup( LifecycleExecutionPlanCalculator.class );
        lifeCyclePluginAnalyzer = lookup( LifeCyclePluginAnalyzer.class );
        lifeCycleTaskSegmentCalculator = lookup( LifecycleTaskSegmentCalculator.class );
        lookup( ExceptionHandler.class );
    }
4409#@Override
    protected void tearDown()
        throws Exception
    {
        defaultLifeCycles = null;
        super.tearDown();
    }
4410#protected String getProjectsDirectory()
    {
        return "src/test/projects/lifecycle-executor";
    }
4411#public void testCrweation()
        throws Exception
    {
        assertNotNull( defaultLifeCycles );
        assertNotNull( mojoExecutor );
        assertNotNull( lifeCycleBuilder );
        assertNotNull( lifeCycleDependencyResolver );
        assertNotNull( lifeCycleExecutionPlanCalculator );
        assertNotNull( lifeCyclePluginAnalyzer );
        assertNotNull( lifeCycleTaskSegmentCalculator );
    }
4412#protected void setUp()
        throws Exception
    {
        super.setUp();
        lifecycleExecutor = (DefaultLifecycleExecutor) lookup( LifecycleExecutor.class );
        lifeCycleTaskSegmentCalculator =
            (DefaultLifecycleTaskSegmentCalculator) lookup( LifecycleTaskSegmentCalculator.class );
        lifeCycleExecutionPlanCalculator = lookup( LifecycleExecutionPlanCalculator.class );
        mojoDescriptorCreator = lookup( MojoDescriptorCreator.class );
        lookup( ExceptionHandler.class );
    }
4413#@Override
    protected void tearDown()
        throws Exception
    {
        lifecycleExecutor = null;
        super.tearDown();
    }
4414#protected String getProjectsDirectory()
    {
        return "src/test/projects/lifecycle-executor";
    }
4415#// -----------------------------------------------------------------------------------------------
    // Tests which exercise the lifecycle executor when it is dealing with default lifecycle phases.
    // -----------------------------------------------------------------------------------------------

    public void testCalculationOfBuildPlanWithIndividualTaskWherePluginIsSpecifiedInThePom()
        throws Exception
    {
        // We are doing something like "mvn resources:resources" where no version is specified but this
        // project we are working on has the version specified in the POM so the version should come from there.
        File pom = getProject( "project-basic" );
        MavenSession session = createMavenSession( pom );
        assertEquals( "project-basic", session.getCurrentProject().getArtifactId() );
        assertEquals( "1.0", session.getCurrentProject().getVersion() );
        List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, "resources:resources" ) );
        assertEquals( 1, executionPlan.size() );
        MojoExecution mojoExecution = executionPlan.get( 0 );
        assertNotNull( mojoExecution );
        assertEquals( "org.apache.maven.plugins",
                      mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );
        assertEquals( "maven-resources-plugin",
                      mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );
        assertEquals( "0.1", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );
    }
4416#public void testCalculationOfBuildPlanWithIndividualTaskOfTheCleanLifecycle()
        throws Exception
    {
        // We are doing something like "mvn clean:clean" where no version is specified but this
        // project we are working on has the version specified in the POM so the version should come from there.
        File pom = getProject( "project-basic" );
        MavenSession session = createMavenSession( pom );
        assertEquals( "project-basic", session.getCurrentProject().getArtifactId() );
        assertEquals( "1.0", session.getCurrentProject().getVersion() );
        List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, "clean" ) );
        assertEquals( 1, executionPlan.size() );
        MojoExecution mojoExecution = executionPlan.get( 0 );
        assertNotNull( mojoExecution );
        assertEquals( "org.apache.maven.plugins",
                      mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );
        assertEquals( "maven-clean-plugin", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );
        assertEquals( "0.1", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );
    }
4417#public void testCalculationOfBuildPlanWithIndividualTaskOfTheCleanCleanGoal()
        throws Exception
    {
        // We are doing something like "mvn clean:clean" where no version is specified but this
        // project we are working on has the version specified in the POM so the version should come from there.
        File pom = getProject( "project-basic" );
        MavenSession session = createMavenSession( pom );
        assertEquals( "project-basic", session.getCurrentProject().getArtifactId() );
        assertEquals( "1.0", session.getCurrentProject().getVersion() );
        List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, "clean:clean" ) );
        assertEquals( 1, executionPlan.size() );
        MojoExecution mojoExecution = executionPlan.get( 0 );
        assertNotNull( mojoExecution );
        assertEquals( "org.apache.maven.plugins",
                      mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() );
        assertEquals( "maven-clean-plugin", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );
        assertEquals( "0.1", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );
    }
4418#List<MojoExecution> getExecutions( MavenExecutionPlan mavenExecutionPlan )
    {
        List<MojoExecution> result = new ArrayList<MojoExecution>();
        for ( ExecutionPlanItem executionPlanItem : mavenExecutionPlan )
        {
            result.add( executionPlanItem.getMojoExecution() );
        }
        return result;
    }
4419#// We need to take in multiple lifecycles
    public void testCalculationOfBuildPlanTasksOfTheCleanLifecycleAndTheInstallLifecycle()
        throws Exception
    {
        File pom = getProject( "project-with-additional-lifecycle-elements" );
        MavenSession session = createMavenSession( pom );
        assertEquals( "project-with-additional-lifecycle-elements", session.getCurrentProject().getArtifactId() );
        assertEquals( "1.0", session.getCurrentProject().getVersion() );
        List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, "clean", "install" ) );

        //[01] clean:clean
        //[02] resources:resources
        //[03] compiler:compile
        //[04] it:generate-metadata
        //[05] resources:testResources
        //[06] compiler:testCompile
        //[07] it:generate-test-metadata
        //[08] surefire:test
        //[09] jar:jar
        //[10] install:install
        //
        assertEquals( 10, executionPlan.size() );

        assertEquals( "clean:clean", executionPlan.get( 0 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "resources:resources", executionPlan.get( 1 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "compiler:compile", executionPlan.get( 2 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "it:generate-metadata", executionPlan.get( 3 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "resources:testResources", executionPlan.get( 4 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "compiler:testCompile", executionPlan.get( 5 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "it:generate-test-metadata", executionPlan.get( 6 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "surefire:test", executionPlan.get( 7 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "jar:jar", executionPlan.get( 8 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "install:install", executionPlan.get( 9 ).getMojoDescriptor().getFullGoalName() );
    }
4420#// We need to take in multiple lifecycles
    public void testCalculationOfBuildPlanWithMultipleExecutionsOfModello()
        throws Exception
    {
        File pom = getProject( "project-with-multiple-executions" );
        MavenSession session = createMavenSession( pom );
        assertEquals( "project-with-multiple-executions", session.getCurrentProject().getArtifactId() );
        assertEquals( "1.0.1", session.getCurrentProject().getVersion() );

        MavenExecutionPlan plan = calculateExecutionPlan( session, "clean", "install" );

        List<MojoExecution> executions = getExecutions( plan );

        //[01] clean:clean
        //[02] modello:xpp3-writer
        //[03] modello:java
        //[04] modello:xpp3-reader
        //[05] modello:xpp3-writer
        //[06] modello:java
        //[07] modello:xpp3-reader
        //[08] plugin:descriptor        
        //[09] resources:resources
        //[10] compiler:compile
        //[11] resources:testResources
        //[12] compiler:testCompile
        //[13] surefire:test
        //[14] jar:jar
        //[15] plugin:addPluginArtifactMetadata        
        //[16] install:install
        //

        assertEquals( 16, executions.size() );

        assertEquals( "clean:clean", executions.get( 0 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "it:xpp3-writer", executions.get( 1 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "it:java", executions.get( 2 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "it:xpp3-reader", executions.get( 3 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "it:xpp3-writer", executions.get( 4 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "it:java", executions.get( 5 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "it:xpp3-reader", executions.get( 6 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "plugin:descriptor", executions.get( 7 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "resources:resources", executions.get( 8 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "compiler:compile", executions.get( 9 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "resources:testResources", executions.get( 10 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "compiler:testCompile", executions.get( 11 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "surefire:test", executions.get( 12 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "jar:jar", executions.get( 13 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "plugin:addPluginArtifactMetadata", executions.get( 14 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "install:install", executions.get( 15 ).getMojoDescriptor().getFullGoalName() );

        assertEquals( "src/main/mdo/remote-resources.mdo",
                      new MojoExecutionXPathContainer( executions.get( 1 ) ).getValue(
                          "configuration/models[1]/model" ) );
        assertEquals( "src/main/mdo/supplemental-model.mdo",
                      new MojoExecutionXPathContainer( executions.get( 4 ) ).getValue(
                          "configuration/models[1]/model" ) );
    }
4421#public void testLifecycleQueryingUsingADefaultLifecyclePhase()
        throws Exception
    {
        File pom = getProject( "project-with-additional-lifecycle-elements" );
        MavenSession session = createMavenSession( pom );
        assertEquals( "project-with-additional-lifecycle-elements", session.getCurrentProject().getArtifactId() );
        assertEquals( "1.0", session.getCurrentProject().getVersion() );
        List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, "package" ) );

        //[01] resources:resources
        //[02] compiler:compile
        //[03] it:generate-metadata
        //[04] resources:testResources
        //[05] compiler:testCompile
        //[06] plexus-component-metadata:generate-test-metadata
        //[07] surefire:test
        //[08] jar:jar
        //
        assertEquals( 8, executionPlan.size() );

        assertEquals( "resources:resources", executionPlan.get( 0 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "compiler:compile", executionPlan.get( 1 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "it:generate-metadata", executionPlan.get( 2 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "resources:testResources", executionPlan.get( 3 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "compiler:testCompile", executionPlan.get( 4 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "it:generate-test-metadata", executionPlan.get( 5 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "surefire:test", executionPlan.get( 6 ).getMojoDescriptor().getFullGoalName() );
        assertEquals( "jar:jar", executionPlan.get( 7 ).getMojoDescriptor().getFullGoalName() );
    }
4422#public void testLifecyclePluginsRetrievalForDefaultLifecycle()
        throws Exception
    {
        List<Plugin> plugins =
            new ArrayList<Plugin>( lifecycleExecutor.getPluginsBoundByDefaultToAllLifecycles( "jar" ) );

        assertEquals( 8, plugins.size() );
    }
4423#public void testPluginConfigurationCreation()
        throws Exception
    {
        File pom = getProject( "project-with-additional-lifecycle-elements" );
        MavenSession session = createMavenSession( pom );
        MojoDescriptor mojoDescriptor =
            mojoDescriptorCreator.getMojoDescriptor( "org.apache.maven.its.plugins:maven-it-plugin:0.1:java", session,
                                                     session.getCurrentProject() );
        Xpp3Dom dom = MojoDescriptorCreator.convert( mojoDescriptor );
        System.out.println( dom );
    }
4424#MavenExecutionPlan calculateExecutionPlan( MavenSession session, String... tasks )
        throws Exception
    {
        List<TaskSegment> taskSegments =
            lifeCycleTaskSegmentCalculator.calculateTaskSegments( session, Arrays.asList( tasks ) );

        TaskSegment mergedSegment = new TaskSegment( false );

        for ( TaskSegment taskSegment : taskSegments )
        {
            mergedSegment.getTasks().addAll( taskSegment.getTasks() );
        }

        return lifeCycleExecutionPlanCalculator.calculateExecutionPlan( session, session.getCurrentProject(),
                                                                        mergedSegment.getTasks() );
    }
4425#public void testInvalidGoalName()
        throws Exception
    {
        File pom = getProject( "project-basic" );
        MavenSession session = createMavenSession( pom );
        try
        {
            getExecutions( calculateExecutionPlan( session, "resources:" ) );
            fail( "expected a MojoNotFoundException" );
        }
        catch ( MojoNotFoundException e )
        {
            assertEquals( "", e.getGoal() );
        }

        try
        {
            getExecutions( calculateExecutionPlan( session, "org.apache.maven.plugins:maven-resources-plugin:0.1:resources:toomany" ) );
            fail( "expected a MojoNotFoundException" );
        }
        catch ( MojoNotFoundException e )
        {
            assertEquals( "resources:toomany", e.getGoal() );
        }
    }
4426#public void testPluginPrefixRetrieval()
        throws Exception
    {
        File pom = getProject( "project-basic" );
        MavenSession session = createMavenSession( pom );
        Plugin plugin = mojoDescriptorCreator.findPluginForPrefix( "resources", session );
        assertEquals( "org.apache.maven.plugins", plugin.getGroupId() );
        assertEquals( "maven-resources-plugin", plugin.getArtifactId() );
    }
4427#// Prefixes

    public void testFindingPluginPrefixforCleanClean()
        throws Exception
    {
        File pom = getProject( "project-basic" );
        MavenSession session = createMavenSession( pom );
        Plugin plugin = mojoDescriptorCreator.findPluginForPrefix( "clean", session );
        assertNotNull( plugin );
    }
4428#public void testSetupMojoExecution()
        throws Exception
    {
        File pom = getProject( "mojo-configuration" );

        MavenSession session = createMavenSession( pom );

        LifecycleTask task = new LifecycleTask( "generate-sources" );
        MavenExecutionPlan executionPlan =
            lifeCycleExecutionPlanCalculator.calculateExecutionPlan( session, session.getCurrentProject(),
                                                                     Arrays.asList( (Object) task ), false );

        MojoExecution execution = executionPlan.getMojoExecutions().get(0);
        assertEquals(execution.toString(), "maven-it-plugin", execution.getArtifactId());
        assertNull(execution.getConfiguration());

        lifeCycleExecutionPlanCalculator.setupMojoExecution( session, session.getCurrentProject(), execution );
        assertNotNull(execution.getConfiguration());
        assertEquals("1.0", execution.getConfiguration().getChild( "version" ).getAttribute( "default-value" ));
    }
4429#public MojoExecutionXPathContainer( MojoExecution mojoExecution )
        throws IOException
    {
        this.mojoExecution = mojoExecution;
        context = JXPathContext.newContext( mojoExecution );
    }
4430#public Iterator<?> getIteratorForXPathExpression( String expression )
    {
        return context.iterate( expression );
    }
4431#public boolean containsXPathExpression( String expression )
    {
        return context.getValue( expression ) != null;
    }
4432#public Object getValue( String expression )
    {
        try
        {
            return context.getValue( expression );
        }
        catch ( JXPathNotFoundException e )
        {
            return null;
        }
    }
4433#public boolean xPathExpressionEqualsValue( String expression, String value )
    {
        return context.getValue( expression ) != null && context.getValue( expression ).equals( value );
    }
4434#public void testFindFirstWithMatchingSchedule()
        throws Exception
    {
        final List<Scheduling> cycles = DefaultLifecyclesStub.getSchedulingList();
        final Schedule schedule = cycles.get( 0 ).getSchedules().get( 0 );
        assertNotNull( schedule );

    }
4435#public void testForceAllComplete()
        throws Exception
    {
        MavenExecutionPlan plan = LifecycleExecutionPlanCalculatorStub.getProjectAExceutionPlan();
        plan.forceAllComplete();
        final Iterator<ExecutionPlanItem> planItemIterator = plan.iterator();
        assertTrue( planItemIterator.next().isDone() );
        assertTrue( planItemIterator.next().isDone() );
    }
4436#public void testFindLastInPhase()
        throws Exception
    {
        MavenExecutionPlan plan = LifecycleExecutionPlanCalculatorStub.getProjectAExceutionPlan();

        ExecutionPlanItem expected = plan.findLastInPhase( "package" );
        ExecutionPlanItem beerPhase = plan.findLastInPhase( "BEER" );  // Beer comes straight after package in stub
        assertEquals( expected, beerPhase );
        assertNotNull( expected );
    }
4437#public void testThreadSafeMojos()
        throws Exception
    {
        MavenExecutionPlan plan = LifecycleExecutionPlanCalculatorStub.getProjectAExceutionPlan();
        final Set<Plugin> unSafePlugins = plan.getNonThreadSafePlugins();
        // There is only a single threadsafe plugin here...
        assertEquals( plan.size() - 1, unSafePlugins.size() );

    }
4438#public void testFindLastWhenFirst()
        throws Exception
    {
        MavenExecutionPlan plan = LifecycleExecutionPlanCalculatorStub.getProjectAExceutionPlan();

        ExecutionPlanItem beerPhase = plan.findLastInPhase(
            LifecycleExecutionPlanCalculatorStub.VALIDATE.getPhase() );  // Beer comes straight after package in stub
        assertNull( beerPhase );
    }
4439#public void testFindLastInPhaseMisc()
        throws Exception
    {
        MavenExecutionPlan plan = LifecycleExecutionPlanCalculatorStub.getProjectAExceutionPlan();

        assertNull( plan.findLastInPhase( "pacXkage" ) );
        // Beer comes straight after package in stub, much like real life.
        assertNotNull( plan.findLastInPhase( LifecycleExecutionPlanCalculatorStub.INITIALIZE.getPhase() ) );
    }
4440#protected void setUp()
        throws Exception
    {
        super.setUp();
        defaultLifeCycles = lookup( DefaultLifecycles.class );
    }
4441#@Override
    protected void tearDown()
        throws Exception
    {
        defaultLifeCycles = null;
        super.tearDown();
    }
4442#public void testLifecycle()
        throws Exception
    {
        final List<Lifecycle> cycles = defaultLifeCycles.getLifeCycles();
        assertNotNull( cycles );
        final Lifecycle lifecycle = cycles.get( 0 );
        assertEquals( "default", lifecycle.getId() );
        assertEquals( 23, lifecycle.getPhases().size() );

    }
4443#public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<Plugin>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }
4444#private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }
4445#public void testGetByTaskSegment()
        throws Exception
    {
        final MavenSession session = ProjectDependencyGraphStub.getMavenSession();
        ProjectBuildList projectBuildList = ProjectDependencyGraphStub.getProjectBuildList( session );
        TaskSegment taskSegment = projectBuildList.get( 0 ).getTaskSegment();
        assertTrue( "This test assumes there are at least 6 elements in projectBuilds", projectBuildList.size() >= 6 );

        final ProjectBuildList byTaskSegment = projectBuildList.getByTaskSegment( taskSegment );
        assertEquals( projectBuildList.size(),
                      byTaskSegment.size() ); // Todo: Make multiple segments on projectBuildList
    }
4446#public void testSingleThreaded()
        throws Exception
    {
        ProjectBuildList src = getProjectBuildList();
        ProjectBuildList projectBuildList =
            new ProjectBuildList( Arrays.asList( src.get( 0 ), src.get( 1 ), src.get( 2 ) ) );

        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        PrintStream systemOut = new PrintStream( byteArrayOutputStream );
        ThreadOutputMuxer threadOutputMuxer = new ThreadOutputMuxer( projectBuildList, systemOut );

        threadOutputMuxer.associateThreadWithProjectSegment( projectBuildList.get( 0 ) );
        System.out.print( paid );  // No, this does not print to system.out. It's part of the test
        assertEquals( paid.length(), byteArrayOutputStream.size() );
        threadOutputMuxer.associateThreadWithProjectSegment( projectBuildList.get( 1 ) );
        System.out.print( in );  // No, this does not print to system.out. It's part of the test
        assertEquals( paid.length(), byteArrayOutputStream.size() );
        threadOutputMuxer.associateThreadWithProjectSegment( projectBuildList.get( 2 ) );
        System.out.print( full ); // No, this does not print to system.out. It's part of the test
        assertEquals( paid.length(), byteArrayOutputStream.size() );

        threadOutputMuxer.setThisModuleComplete( projectBuildList.get( 0 ) );
        threadOutputMuxer.setThisModuleComplete( projectBuildList.get( 1 ) );
        threadOutputMuxer.setThisModuleComplete( projectBuildList.get( 2 ) );
        threadOutputMuxer.close();
        assertEquals( ( paid + in + full ).length(), byteArrayOutputStream.size() );
    }
4447#public void testMultiThreaded()
        throws Exception
    {
        ProjectBuildList projectBuildList = getProjectBuildList();

        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        PrintStream systemOut = new PrintStream( byteArrayOutputStream );
        final ThreadOutputMuxer threadOutputMuxer = new ThreadOutputMuxer( projectBuildList, systemOut );

        final List<String> stringList =
            Arrays.asList( "Thinkin", "of", "a", "master", "plan", "Cuz", "ain’t", "nuthin", "but", "sweat", "inside",
                           "my", "hand" );
        Iterator<String> lyrics = stringList.iterator();
        List<Outputter> outputters = new ArrayList<Outputter>();

        ExecutorService executor = Executors.newFixedThreadPool( 10 );
        CompletionService<ProjectSegment> service = new ExecutorCompletionService<ProjectSegment>( executor );

        List<Future<ProjectSegment>> futures = new ArrayList<Future<ProjectSegment>>();
        for ( ProjectSegment projectBuild : projectBuildList )
        {
            final Future<ProjectSegment> buildFuture =
                service.submit( new Outputter( threadOutputMuxer, projectBuild, lyrics.next() ) );
            futures.add( buildFuture );
        }

        for ( Future<ProjectSegment> future : futures )
        {
            future.get();
        }
        int expectedLength = 0;
        for ( int i = 0; i < projectBuildList.size(); i++ )
        {
            expectedLength += stringList.get( i ).length();
        }

        threadOutputMuxer.close();
        final byte[] bytes = byteArrayOutputStream.toByteArray();
        String result = new String( bytes );
        assertEquals( result, expectedLength, bytes.length );


    }
4448#private ProjectBuildList getProjectBuildList()
        throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException,
        NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException
    {
        final MavenSession session = ProjectDependencyGraphStub.getMavenSession();
        return ProjectDependencyGraphStub.getProjectBuildList( session );
    }
4449#Outputter( ThreadOutputMuxer threadOutputMuxer, ProjectSegment item, String response )
        {
            this.threadOutputMuxer = threadOutputMuxer;
            this.item = item;
            this.response = response;
        }
4450#public ProjectSegment call()
            throws Exception
        {
            threadOutputMuxer.associateThreadWithProjectSegment( item );
            System.out.print( response );
            threadOutputMuxer.setThisModuleComplete( item );
            return item;
        }
4451#public void testCalculateExecutionPlanWithGoalTasks()
        throws Exception
    {
        MojoDescriptorCreator mojoDescriptorCreator = createMojoDescriptorCreator();
        LifecycleExecutionPlanCalculator lifecycleExecutionPlanCalculator =
            createExecutionPlaceCalculator( mojoDescriptorCreator );

        final GoalTask goalTask1 = new GoalTask( "compiler:compile" );
        final GoalTask goalTask2 = new GoalTask( "surefire:test" );
        final TaskSegment taskSegment1 = new TaskSegment( false, goalTask1, goalTask2 );
        final MavenSession session1 = ProjectDependencyGraphStub.getMavenSession( ProjectDependencyGraphStub.A );

        MavenExecutionPlan executionPlan =
            lifecycleExecutionPlanCalculator.calculateExecutionPlan( session1, ProjectDependencyGraphStub.A,
                                                                     taskSegment1.getTasks() );
        assertEquals( 2, executionPlan.size() );

        final GoalTask goalTask3 = new GoalTask( "surefire:test" );
        final TaskSegment taskSegment2 = new TaskSegment( false, goalTask1, goalTask2, goalTask3 );
        MavenExecutionPlan executionPlan2 =
            lifecycleExecutionPlanCalculator.calculateExecutionPlan( session1, ProjectDependencyGraphStub.A,
                                                                     taskSegment2.getTasks() );
        assertEquals( 3, executionPlan2.size() );
    }
4452#// Maybe also make one with LifeCycleTasks

    public static LifecycleExecutionPlanCalculator createExecutionPlaceCalculator( MojoDescriptorCreator mojoDescriptorCreator )
    {
        LifecyclePluginResolver lifecyclePluginResolver = new LifecyclePluginResolver( new PluginVersionResolverStub() );
        return new DefaultLifecycleExecutionPlanCalculator( new BuildPluginManagerStub(),
                                                            DefaultLifecyclesStub.createDefaultLifecycles(),
                                                            mojoDescriptorCreator, lifecyclePluginResolver,
                                                            DefaultSchedulesStub.createDefaultSchedules() );
    }
4453#public static MojoDescriptorCreator createMojoDescriptorCreator()
    {
        return new MojoDescriptorCreator( new PluginVersionResolverStub(), new BuildPluginManagerStub(),
                                          new PluginPrefixResolverStub(),
                                          new LifecyclePluginResolver( new PluginVersionResolverStub() ) );
    }
4454#@Override
    protected String getProjectsDirectory()
    {
        return "src/test/projects/lifecycle-executor";
    }
4455#public void testGetThreadCount()
        throws Exception
    {
        ThreadConfigurationService threadConfigurationService = new ThreadConfigurationService( new LoggerStub(), 3 );

        Assert.assertEquals( 5, threadConfigurationService.getThreadCount( "1.75", true, 6 ).intValue() );
        Assert.assertEquals( 6, threadConfigurationService.getThreadCount( "1.84", true, 6 ).intValue() );
    }
4456#public void testToGraph()
        throws Exception
    {
        ConcurrentBuildLogger concurrentBuildLogger = new ConcurrentBuildLogger();

        MojoDescriptorCreator mojoDescriptorCreator =
            LifecycleExecutionPlanCalculatorTest.createMojoDescriptorCreator();
        LifecycleExecutionPlanCalculator lifecycleExecutionPlanCalculator =
            LifecycleExecutionPlanCalculatorTest.createExecutionPlaceCalculator( mojoDescriptorCreator );

        MavenProject A = ProjectDependencyGraphStub.B;
        MavenProject B = ProjectDependencyGraphStub.C;

        final MavenSession session1 = ProjectDependencyGraphStub.getMavenSession( A );

        final GoalTask goalTask1 = new GoalTask( "compiler:compile" );
        final GoalTask goalTask2 = new GoalTask( "surefire:test" );
        final TaskSegment taskSegment1 = new TaskSegment( false, goalTask1, goalTask2 );

        MavenExecutionPlan executionPlan =
            lifecycleExecutionPlanCalculator.calculateExecutionPlan( session1, A, taskSegment1.getTasks() );

        MavenExecutionPlan executionPlan2 =
            lifecycleExecutionPlanCalculator.calculateExecutionPlan( session1, B, taskSegment1.getTasks() );

        final Iterator<ExecutionPlanItem> planItemIterator = executionPlan.iterator();
        final BuildLogItem a1 = concurrentBuildLogger.createBuildLogItem( A, planItemIterator.next() );

        final BuildLogItem a2 = concurrentBuildLogger.createBuildLogItem( A, planItemIterator.next() );

        final Iterator<ExecutionPlanItem> plan2ItemIterator = executionPlan.iterator();
        final BuildLogItem b1 = concurrentBuildLogger.createBuildLogItem( B, plan2ItemIterator.next() );
        final BuildLogItem b2 = concurrentBuildLogger.createBuildLogItem( B, plan2ItemIterator.next() );

        b1.addDependency( A, "Project dependency" );
        final Iterator<ExecutionPlanItem> aPlan = executionPlan.iterator();
        b1.addWait( A, aPlan.next(), System.currentTimeMillis() );
        b2.addWait( A, aPlan.next(), System.currentTimeMillis() );
        final String response = concurrentBuildLogger.toGraph();
        assertTrue( response.indexOf( "digraph" ) >= 0 );
    }
4457#public void testCalculateProjectBuilds()
        throws Exception
    {
        LifecycleTaskSegmentCalculator lifecycleTaskSegmentCalculator = getTaskSegmentCalculator();
        BuildListCalculator buildListCalculator = new BuildListCalculator();
        final MavenSession session = ProjectDependencyGraphStub.getMavenSession();
        List<TaskSegment> taskSegments = lifecycleTaskSegmentCalculator.calculateTaskSegments( session );

        final ProjectBuildList buildList = buildListCalculator.calculateProjectBuilds( session, taskSegments );
        final ProjectBuildList segments = buildList.getByTaskSegment( taskSegments.get( 0 ) );
        assertEquals( "Stub data contains 3 segments", 3, taskSegments.size() );
        assertEquals( "Stub data contains 6 items", 6, segments.size() );
        final ProjectSegment build = segments.get( 0 );
        assertNotNull( build );
    }
4458#private static LifecycleTaskSegmentCalculator getTaskSegmentCalculator()
    {
        return new LifecycleTaskSegmentCalculatorStub();
    }
4459#public void testCalculateProjectBuilds()
        throws Exception
    {
        LifecycleTaskSegmentCalculator lifecycleTaskSegmentCalculator = getTaskSegmentCalculator();
        BuildListCalculator buildListCalculator = new BuildListCalculator();
        final MavenSession session = ProjectDependencyGraphStub.getMavenSession();
        List<TaskSegment> taskSegments = lifecycleTaskSegmentCalculator.calculateTaskSegments( session );
        final ProjectBuildList buildList = buildListCalculator.calculateProjectBuilds( session, taskSegments );
        final ProjectBuildList segments = buildList.getByTaskSegment( taskSegments.get( 0 ) );
        assertEquals( "Stub data contains 3 segments", 3, taskSegments.size() );
        assertEquals( "Stub data contains 6 items", 6, segments.size() );
        final ProjectSegment build = segments.get( 0 );
        assertNotNull( build );
    }
4460#private static LifecycleTaskSegmentCalculator getTaskSegmentCalculator()
    {
        return new LifecycleTaskSegmentCalculatorStub();
    }
4461#public void testObserveExecution() throws Exception {
        PhaseRecorder phaseRecorder = new PhaseRecorder( ProjectDependencyGraphStub.A);
        MavenExecutionPlan plan = LifecycleExecutionPlanCalculatorStub.getProjectAExceutionPlan();
        final List<MojoExecution> executions = plan.getMojoExecutions();

        final MojoExecution mojoExecution1 = executions.get( 0 );
        final MojoExecution mojoExecution2 = executions.get( 1 );
        phaseRecorder.observeExecution( mojoExecution1 );

        assertTrue( ProjectDependencyGraphStub.A.hasLifecyclePhase( mojoExecution1.getLifecyclePhase() ));
        assertFalse( ProjectDependencyGraphStub.A.hasLifecyclePhase( mojoExecution2.getLifecyclePhase() ));

        assertFalse( phaseRecorder.isDifferentPhase( mojoExecution1));
        assertTrue( phaseRecorder.isDifferentPhase( mojoExecution2));

    }
4462#/*    public void testBuildProjectSynchronously()
        throws Exception
    {
        final CompletionService<ProjectSegment> service = new CompletionServiceStub( true );
        final ProjectBuildList projectBuildList = runWithCompletionService( service );
        assertEquals( "Expect all tasks to be scheduled", projectBuildList.size(),
                      ( (CompletionServiceStub) service ).size() );
    }
  */

    public void testBuildProjectThreaded()
        throws Exception
    {
        ExecutorService executor = Executors.newFixedThreadPool( 10 );
        ExecutorCompletionService<ProjectSegment> service = new ExecutorCompletionService<ProjectSegment>( executor );
        runWithCompletionService( executor );
        executor.shutdown();
    }
4463#public void testBuildProjectThreadedAggressive()
        throws Exception
    {
        ExecutorService executor = Executors.newFixedThreadPool( 10 );
        ExecutorCompletionService<ProjectSegment> service = new ExecutorCompletionService<ProjectSegment>( executor );
        runWithCompletionService( executor );
        executor.shutdown();
    }
4464#private ProjectBuildList runWithCompletionService( ExecutorService service )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginVersionResolutionException, LifecyclePhaseNotFoundException, LifecycleNotFoundException,
        ExecutionException, InterruptedException
    {
        final ClassLoader loader = Thread.currentThread().getContextClassLoader();
        try
        {
            BuildListCalculator buildListCalculator = new BuildListCalculator();
            final MavenSession session = ProjectDependencyGraphStub.getMavenSession();
            List<TaskSegment> taskSegments = getTaskSegmentCalculator().calculateTaskSegments( session );
            ProjectBuildList projectBuildList = buildListCalculator.calculateProjectBuilds( session, taskSegments );

            final MojoExecutorStub mojoExecutorStub = new MojoExecutorStub();
            final LifecycleWeaveBuilder builder = getWeaveBuilder( mojoExecutorStub );
            final ReactorContext buildContext = createBuildContext( session );
            ReactorBuildStatus reactorBuildStatus = new ReactorBuildStatus( session.getProjectDependencyGraph() );
            builder.build( projectBuildList, buildContext, taskSegments, session, service, reactorBuildStatus );

            LifecycleExecutionPlanCalculatorStub lifecycleExecutionPlanCalculatorStub =
                new LifecycleExecutionPlanCalculatorStub();
            final int expected = lifecycleExecutionPlanCalculatorStub.getNumberOfExceutions( projectBuildList );
            assertEquals( "All executions should be scheduled", expected, mojoExecutorStub.executions.size() );
            return projectBuildList;
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( loader );
        }
    }
4465#private static LifecycleTaskSegmentCalculator getTaskSegmentCalculator()
    {
        return new LifecycleTaskSegmentCalculatorStub();
    }
4466#private ReactorContext createBuildContext( MavenSession session )
    {
        MavenExecutionResult mavenExecutionResult = new DefaultMavenExecutionResult();
        ReactorBuildStatus reactorBuildStatus = new ReactorBuildStatus( session.getProjectDependencyGraph() );
        return new ReactorContext( mavenExecutionResult, null, null, reactorBuildStatus );
    }
4467#private LifecycleWeaveBuilder getWeaveBuilder( MojoExecutor mojoExecutor )
    {
        final BuilderCommon builderCommon = getBuilderCommon();
        final LoggerStub loggerStub = new LoggerStub();
        return new LifecycleWeaveBuilder( mojoExecutor, builderCommon, loggerStub, new ExecutionEventCatapultStub() );
    }
4468#private BuilderCommon getBuilderCommon()
    {
        final LifecycleDebugLogger logger = new LifecycleDebugLogger( new LoggerStub() );
        return new BuilderCommon( logger, new LifecycleExecutionPlanCalculatorStub(),
                                  new LoggerStub() );
    }
4469#public void testConcurrencyGraphPrimaryVersion()
        throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException,
        NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException
    {
        ProjectDependencyGraph dependencyGraph = new ProjectDependencyGraphStub();
        final MavenSession session = ProjectDependencyGraphStub.getMavenSession();

        ConcurrencyDependencyGraph graph =
            new ConcurrencyDependencyGraph( getProjectBuildList( session ), dependencyGraph );

        final List<MavenProject> projectBuilds = graph.getRootSchedulableBuilds();
        assertEquals( 1, projectBuilds.size() );
        assertEquals( A, projectBuilds.get( 0 ) );

        final List<MavenProject> subsequent = graph.markAsFinished( A );
        assertEquals( 2, subsequent.size() );
        assertEquals( ProjectDependencyGraphStub.B, subsequent.get( 0 ) );
        assertEquals( C, subsequent.get( 1 ) );

        final List<MavenProject> bDescendants = graph.markAsFinished( B );
        assertEquals( 1, bDescendants.size() );
        assertEquals( Y, bDescendants.get( 0 ) );

        final List<MavenProject> cDescendants = graph.markAsFinished( C );
        assertEquals( 2, cDescendants.size() );
        assertEquals( X, cDescendants.get( 0 ) );
        assertEquals( Z, cDescendants.get( 1 ) );
    }
4470#public void testConcurrencyGraphDifferentCompletionOrder()
        throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException,
        NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException
    {
        ProjectDependencyGraph dependencyGraph = new ProjectDependencyGraphStub();
        final MavenSession session = ProjectDependencyGraphStub.getMavenSession();
        ConcurrencyDependencyGraph graph =
            new ConcurrencyDependencyGraph( getProjectBuildList( session ), dependencyGraph );

        graph.markAsFinished( A );
        final List<MavenProject> cDescendants = graph.markAsFinished( C );
        assertEquals( 1, cDescendants.size() );
        assertEquals( Z, cDescendants.get( 0 ) );

        final List<MavenProject> bDescendants = graph.markAsFinished( B );
        assertEquals( 2, bDescendants.size() );
        assertEquals( X, bDescendants.get( 0 ) );
        assertEquals( Y, bDescendants.get( 1 ) );
    }
4471#public void testResolveBuildPlan()
        throws Exception
    {
        MavenSession original = ProjectDependencyGraphStub.getMavenSession();

        final TaskSegment taskSegment1 = new TaskSegment( false );
        final MavenSession session1 = original.clone();
        session1.setCurrentProject( ProjectDependencyGraphStub.A );

        final BuilderCommon builderCommon = getBuilderCommon();
        final MavenExecutionPlan plan =
            builderCommon.resolveBuildPlan( session1, ProjectDependencyGraphStub.A, taskSegment1,
                                            new HashSet<Artifact>() );
        assertEquals( LifecycleExecutionPlanCalculatorStub.getProjectAExceutionPlan().size(), plan.size() );

    }
4472#public void testHandleBuildError()
        throws Exception
    {
    }
4473#public void testAttachToThread()
        throws Exception
    {
    }
4474#public void testGetKey()
        throws Exception
    {
    }
4475#public static BuilderCommon getBuilderCommon()
    {
        final LifecycleDebugLogger logger = new LifecycleDebugLogger( new LoggerStub() );
        return new BuilderCommon( logger, new LifecycleExecutionPlanCalculatorStub(),
                                  new LoggerStub() );
    }
4476#public void testSetComplete()
        throws Exception
    {
        ExecutionPlanItem item = createExecutionPlanItem( "testMojo", null );
        item.setComplete();  // This itself is a valid test
        assertTrue( item.isDone() );
    }
4477#public void testWaitUntilDone()
        throws Exception
    {

        final ExecutionPlanItem item =
            createExecutionPlanItem( "testMojo", createExecutionPlanItem( "testMojo2", null ) );
        new Thread( new Runnable()
        {
            public void run()
            {
                item.setComplete();
            }
        } ).start();
        item.waitUntilDone();
    }
4478#public static ExecutionPlanItem createExecutionPlanItem( String mojoDescription, ExecutionPlanItem downStream )
    {
        return createExecutionPlanItem( mojoDescription, downStream, null );
    }
4479#public static ExecutionPlanItem createExecutionPlanItem( String mojoDescription, ExecutionPlanItem downStream,
                                                             Schedule schedule )
    {
        return new ExecutionPlanItem( new MojoExecution( MojoExecutorStub.createMojoDescriptor( mojoDescription ) ),
                                      schedule );
    }
4480#public static DefaultSchedules createDefaultSchedules()
    {
        return new DefaultSchedules( getSchedulingList() );
    }
4481#public static List<Scheduling> getSchedulingList()
    {
        return Arrays.asList( new Scheduling( "default", Arrays.asList( new Schedule( "compile", false, false ),
                                                                        new Schedule( "test", false, true ) ) ) );
    }
4482#public PluginPrefixResult resolve( PluginPrefixRequest request )
        throws NoPluginFoundForPrefixException
    {
        return new PluginPrefixResult()
        {
            public String getGroupId()
            {
                return "com.foobar";
            }

            public String getArtifactId()
            {
                return "bazbaz";
            }

            public ArtifactRepository getRepository()
            {
                return null;
            }
        };
    }
4483#public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<Plugin>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }
4484#private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }
4485#public Set<Artifact> resolve( MavenProject project, Collection<String> scopesToResolve, MavenSession session )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        return new HashSet<Artifact>();
    }
4486#public Set<Artifact> resolve( MavenProject project, Collection<String> scopesToCollect,
                                  Collection<String> scopesToResolve, MavenSession session )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        return new HashSet<Artifact>();
    }
4487#public Set<Artifact> resolve( Collection<? extends MavenProject> projects, Collection<String> scopes,
                                  MavenSession session )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        return new HashSet<Artifact>();
    }
4488#public Set<Artifact> resolve( MavenProject project, Collection<String> scopesToCollect,
                                  Collection<String> scopesToResolve, MavenSession session,
                                  Set<Artifact> ignoreableArtifacts )
        throws ArtifactResolutionException, ArtifactNotFoundException
    {
        return new HashSet<Artifact>();
    }
4489#public DependencyResolutionResult resolve( DependencyResolutionRequest request )
        throws DependencyResolutionException
    {
        return new DependencyResolutionResult()
        {

            public List<Dependency> getUnresolvedDependencies()
            {
                return Collections.emptyList();
            }

            public List<Dependency> getResolvedDependencies()
            {
                return Collections.emptyList();
            }

            public List<Exception> getResolutionErrors( Dependency dependency )
            {
                return Collections.emptyList();
            }

            public DependencyNode getDependencyGraph()
            {
                return new DefaultDependencyNode( (Dependency) null );
            }

            public List<Dependency> getDependencies()
            {
                return Collections.emptyList();
            }

            public List<Exception> getCollectionErrors()
            {
                return Collections.emptyList();
            }
        };
    }
4490#public void fire( Type eventType, MavenSession session, MojoExecution mojoExecution )
    {
    }
4491#public void fire( Type eventType, MavenSession session, MojoExecution mojoExecution, Exception exception )
    {
    }
4492#public static DefaultLifecycles createDefaultLifecycles()
    {

        List<String> stubDefaultCycle =
            Arrays.asList( VALIDATE.getPhase(), INITIALIZE.getPhase(), PROCESS_RESOURCES.getPhase(), COMPILE.getPhase(),
                           TEST.getPhase(), PROCESS_TEST_RESOURCES.getPhase(), PACKAGE.getPhase(), "BEER",
                           INSTALL.getPhase() );

        // The two phases below are really for future expansion, some would say they lack a drink
        // The point being that they do not really have to match the "real" stuff,
        List<String> stubCleanCycle = Arrays.asList( PRE_CLEAN.getPhase(), CLEAN.getPhase(), POST_CLEAN.getPhase() );

        List<String> stubSiteCycle =
            Arrays.asList( PRE_SITE.getPhase(), SITE.getPhase(), POST_SITE.getPhase(), SITE_DEPLOY.getPhase() );

        Iterator<List<String>> lcs = Arrays.asList( stubDefaultCycle, stubCleanCycle, stubSiteCycle ).iterator();

        Map<String, Lifecycle> lifeCycles = new HashMap<String, Lifecycle>();
        for ( String s : DefaultLifecycles.STANDARD_LIFECYCLES )
        {
            final Lifecycle lifecycle = new Lifecycle( s, lcs.next(), null );
            lifeCycles.put( s, lifecycle );

        }
        return new DefaultLifecycles( lifeCycles, new LoggerStub() );
    }
4493#public static List<Scheduling> getSchedulingList()
    {
        return Arrays.asList( new Scheduling( "default", Arrays.asList( new Schedule( "compile", false, false ),
                                                                        new Schedule( "test", false, true ) ) ) );
    }
4494#@Override
    public void execute( MavenSession session, MojoExecution mojoExecution, ProjectIndex projectIndex,
                         DependencyContext dependencyContext, PhaseRecorder phaseRecorder )
        throws LifecycleExecutionException
    {
        executions.add( mojoExecution );
    }
4495#@Override
    public void execute( MavenSession session, List<MojoExecution> mojoExecutions, ProjectIndex projectIndex )
        throws LifecycleExecutionException
    {
        for ( MojoExecution mojoExecution : mojoExecutions )
        {
            executions.add( mojoExecution );
        }
    }
4496#public static MojoDescriptor createMojoDescriptor( String mojoDescription )
    {
        final PluginDescriptor descriptor = new PluginDescriptor();
        descriptor.setArtifactId( mojoDescription );
        final MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setDescription( mojoDescription );
        mojoDescriptor.setPluginDescriptor( descriptor );
        return mojoDescriptor;
    }
4497#public void testADependencies()
    {
        ProjectDependencyGraphStub stub = new ProjectDependencyGraphStub();
        final List<MavenProject> mavenProjects = stub.getUpstreamProjects( ProjectDependencyGraphStub.A, false );
        assertEquals( 0, mavenProjects.size() );
    }
4498#public void testBDepenencies( ProjectDependencyGraphStub stub )
    {
        final List<MavenProject> bProjects = stub.getUpstreamProjects( ProjectDependencyGraphStub.B, false );
        assertEquals( 1, bProjects.size() );
        assertTrue( bProjects.contains( ProjectDependencyGraphStub.A ) );
    }
4499#public void testCDepenencies( ProjectDependencyGraphStub stub )
    {
        final List<MavenProject> cProjects = stub.getUpstreamProjects( ProjectDependencyGraphStub.C, false );
        assertEquals( 1, cProjects.size() );
        assertTrue( cProjects.contains( ProjectDependencyGraphStub.C ) );
    }
4500#public void testXDepenencies( ProjectDependencyGraphStub stub )
    {
        final List<MavenProject> cProjects = stub.getUpstreamProjects( ProjectDependencyGraphStub.X, false );
        assertEquals( 2, cProjects.size() );
        assertTrue( cProjects.contains( ProjectDependencyGraphStub.C ) );
        assertTrue( cProjects.contains( ProjectDependencyGraphStub.B ) );
    }
4501#public PluginDescriptor loadPlugin( Plugin plugin, List<RemoteRepository> repositories, RepositorySystemSession session )
    {
        return null;
    }
4502#public MojoDescriptor getMojoDescriptor( Plugin plugin, String goal, List<RemoteRepository> repositories,
                                             RepositorySystemSession session )
    {
        return MojoExecutorStub.createMojoDescriptor( plugin.getKey() );
    }
4503#public ClassRealm getPluginRealm( MavenSession session, PluginDescriptor pluginDescriptor )
    {
        return null;
    }
4504#public void executeMojo( MavenSession session, MojoExecution execution )
    {
    }
4505#public void debug( String s )
    {
    }
4506#public void debug( String s, Throwable throwable )
    {
    }
4507#public boolean isDebugEnabled()
    {
        return true;
    }
4508#public void info( String s )
    {
    }
4509#public void info( String s, Throwable throwable )
    {
    }
4510#public boolean isInfoEnabled()
    {
        return true;
    }
4511#public void warn( String s )
    {
    }
4512#public void warn( String s, Throwable throwable )
    {
    }
4513#public boolean isWarnEnabled()
    {
        return true;
    }
4514#public void error( String s )
    {
    }
4515#public void error( String s, Throwable throwable )
    {
    }
4516#public boolean isErrorEnabled()
    {
        return true;
    }
4517#public void fatalError( String s )
    {
    }
4518#public void fatalError( String s, Throwable throwable )
    {
    }
4519#public boolean isFatalErrorEnabled()
    {
        return true;
    }
4520#public Logger getChildLogger( String s )
    {
        return null;
    }
4521#public int getThreshold()
    {
        return 0;
    }
4522#public void setThreshold( int i )
    {

    }
4523#public String getName()
    {
        return "StubLogger";
    }
4524#public int getNumberOfExceutions( ProjectBuildList projectBuildList )
        throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException,
        NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException
    {
        int result = 0;
        for ( ProjectSegment projectBuild : projectBuildList )
        {
            MavenExecutionPlan plan = calculateExecutionPlan( projectBuild.getSession(), projectBuild.getProject(),
                                                              projectBuild.getTaskSegment().getTasks() );
            result += plan.size();
        }
        return result;
    }
4525#public void calculateForkedExecutions( MojoExecution mojoExecution, MavenSession session )
        throws MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        PluginDescriptorParsingException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        // Maybe do something ?
    }
4526#public MavenExecutionPlan calculateExecutionPlan( MavenSession session, MavenProject project, List<Object> tasks,
                                                      boolean setup )
        throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException,
        PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException,
        NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        if ( project.equals( ProjectDependencyGraphStub.A ) )
        {
            return getProjectAExceutionPlan();
        }
        if ( project.equals( ProjectDependencyGraphStub.B ) )
        {
            return getProjectBExecutionPlan();
        }
        // The remaining are basically "for future expansion"
        List<MojoExecution> me = new ArrayList<MojoExecution>();
        me.add( createMojoExecution( "resources", "default-resources", PROCESS_RESOURCES ) );
        me.add( createMojoExecution( "compile", "default-compile", COMPILE ) );
        return createExecutionPlan( project, me );
    }
4527#public MavenExecutionPlan calculateExecutionPlan( MavenSession session, MavenProject project, List<Object> tasks )
        throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException,
        PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException,
        NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        return calculateExecutionPlan( session, project, tasks, true );
    }
4528#public void setupMojoExecution( MavenSession session, MavenProject project, MojoExecution mojoExecution )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, InvalidPluginDescriptorException, NoPluginFoundForPrefixException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException
    {
    }
4529#public static MavenExecutionPlan getProjectAExceutionPlan()
        throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException,
        PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException,
        NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        List<MojoExecution> me = new ArrayList<MojoExecution>();
        me.add( createMojoExecution( "initialize", "default-initialize", INITIALIZE ) );
        me.add( createMojoExecution( "resources", "default-resources", PROCESS_RESOURCES ) );
        me.add( createMojoExecution( "compile", "default-compile", COMPILE ) );
        me.add( createMojoExecution( "testResources", "default-testResources", PROCESS_TEST_RESOURCES ) );
        me.add( createMojoExecution( "testCompile", "default-testCompile", TEST_COMPILE ) );
        me.add( createMojoExecution( "test", "default-test", TEST ) );
        me.add( createMojoExecution( "war", "default-war", PACKAGE ) );
        me.add( createMojoExecution( "install", "default-install", INSTALL ) );
        return createExecutionPlan( ProjectDependencyGraphStub.A.getExecutionProject(), me );
    }
4530#public static MavenExecutionPlan getProjectBExecutionPlan()
        throws PluginNotFoundException, PluginResolutionException, LifecyclePhaseNotFoundException,
        PluginDescriptorParsingException, MojoNotFoundException, InvalidPluginDescriptorException,
        NoPluginFoundForPrefixException, LifecycleNotFoundException, PluginVersionResolutionException
    {
        List<MojoExecution> me = new ArrayList<MojoExecution>();
        me.add( createMojoExecution( "enforce", "enforce-versions", VALIDATE ) );
        me.add( createMojoExecution( "resources", "default-resources", PROCESS_RESOURCES ) );
        me.add( createMojoExecution( "compile", "default-compile", COMPILE ) );
        me.add( createMojoExecution( "testResources", "default-testResources", PROCESS_TEST_RESOURCES ) );
        me.add( createMojoExecution( "testCompile", "default-testCompile", TEST_COMPILE ) );
        me.add( createMojoExecution( "test", "default-test", TEST ) );
        return createExecutionPlan( ProjectDependencyGraphStub.B.getExecutionProject(), me );
    }
4531#private static MavenExecutionPlan createExecutionPlan( MavenProject project, List<MojoExecution> mojoExecutions )
        throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException,
        NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException
    {
        final List<ExecutionPlanItem> planItemList =
            DefaultSchedulesStub.createDefaultSchedules().createExecutionPlanItem( project, mojoExecutions );
        return new MavenExecutionPlan( planItemList, DefaultLifecyclesStub.createDefaultLifecycles() );
    }
4532#private static MojoExecution createMojoExecution( String goal, String executionId, MojoDescriptor mojoDescriptor )
    {
        final Plugin plugin = mojoDescriptor.getPluginDescriptor().getPlugin();
        MojoExecution result = new MojoExecution( plugin, goal, executionId );
        result.setConfiguration( new Xpp3Dom( executionId + "-" + goal ) );
        result.setMojoDescriptor( mojoDescriptor );
        result.setLifecyclePhase( mojoDescriptor.getPhase() );

        return result;

    }
4533#public static MojoDescriptor createMojoDescriptor( String phaseName )
    {
        return createMojoDescriptor( phaseName, false );
    }
4534#public static MojoDescriptor createMojoDescriptor( String phaseName, boolean threadSafe )
    {
        final MojoDescriptor mojoDescriptor = new MojoDescriptor();
        mojoDescriptor.setPhase( phaseName );
        final PluginDescriptor descriptor = new PluginDescriptor();
        Plugin plugin = new Plugin();
        plugin.setArtifactId( "org.apache.maven.test.MavenExecutionPlan" );
        plugin.setGroupId( "stub-plugin-" + phaseName );
        descriptor.setPlugin( plugin );
        descriptor.setArtifactId( "artifact." + phaseName );
        mojoDescriptor.setPluginDescriptor( descriptor );
        mojoDescriptor.setThreadSafe( threadSafe );
        return mojoDescriptor;
    }
4535#public static Set<String> getScopes()
    {
        return new HashSet<String>( Arrays.asList( "compile" ) );
    }
4536#public int size()
    {
        return projectBuildFutureTasks.size();
    }
4537#public CompletionServiceStub( boolean finishImmediately )
    {
        this.finishImmediately = finishImmediately;
    }
4538#public Future<ProjectSegment> submit( Callable<ProjectSegment> task )
    {
        FutureTask<ProjectSegment> projectBuildFutureTask = new FutureTask<ProjectSegment>( task );
        projectBuildFutureTasks.add( projectBuildFutureTask );
        if ( finishImmediately )
        {
            projectBuildFutureTask.run();
        }
        return projectBuildFutureTask;
    }
4539#public Future<ProjectSegment> submit( Runnable task, ProjectSegment result )
    {
        FutureTask<ProjectSegment> projectBuildFutureTask = new FutureTask<ProjectSegment>( task, result );
        projectBuildFutureTasks.add( projectBuildFutureTask );
        if ( finishImmediately )
        {
            projectBuildFutureTask.run();
        }
        return projectBuildFutureTask;
    }
4540#public Future<ProjectSegment> take()
        throws InterruptedException
    {
        return null;
    }
4541#public Future<ProjectSegment> poll()
    {
        return null;
    }
4542#public Future<ProjectSegment> poll( long timeout, TimeUnit unit )
        throws InterruptedException
    {
        return null;
    }
4543#public List<TaskSegment> calculateTaskSegments( MavenSession session, List<String> tasks )
        throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,
        MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException,
        PluginVersionResolutionException
    {
        List<TaskSegment> taskSegments = new ArrayList<TaskSegment>( tasks.size() );

        TaskSegment currentSegment = null;

        for ( String task : tasks )
        {
            if ( aggr.equals( task ) )
            {
                boolean aggregating = true;

                if ( currentSegment == null || currentSegment.isAggregating() != aggregating )
                {
                    currentSegment = new TaskSegment( aggregating );
                    taskSegments.add( currentSegment );
                }

                currentSegment.getTasks().add( new GoalTask( task ) );
            }
            else
            {
                // lifecycle phase
                if ( currentSegment == null || currentSegment.isAggregating() )
                {
                    currentSegment = new TaskSegment( false );
                    taskSegments.add( currentSegment );
                }
                currentSegment.getTasks().add( new LifecycleTask( task ) );
            }
        }

        return taskSegments;
    }
4544#public boolean requiresProject( MavenSession session )
    {
        return true;
    }
4545#// This should probably be moved to a separate stub

    public static ProjectBuildList getProjectBuildList( MavenSession session )
        throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException,
        NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException
    {
        final List<ProjectSegment> list = getProjectBuilds( session );
        return new ProjectBuildList( list );

    }
4546#public static List<ProjectSegment> getProjectBuilds( MavenSession session )
        throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException,
        NoPluginFoundForPrefixException, PluginNotFoundException, MojoNotFoundException, PluginResolutionException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException
    {
        List<ProjectSegment> projectBuilds = new ArrayList<ProjectSegment>();

        TaskSegment segment = createTaskSegment();
        projectBuilds.add( createProjectBuild( A, session, segment ) );
        projectBuilds.add( createProjectBuild( B, session, segment ) );
        projectBuilds.add( createProjectBuild( C, session, segment ) );
        projectBuilds.add( createProjectBuild( X, session, segment ) );
        projectBuilds.add( createProjectBuild( Y, session, segment ) );
        projectBuilds.add( createProjectBuild( Z, session, segment ) );
        return projectBuilds;
    }
4547#private static ProjectSegment createProjectBuild( MavenProject project, MavenSession session,
                                                      TaskSegment taskSegment )
        throws InvalidPluginDescriptorException, PluginVersionResolutionException, PluginDescriptorParsingException,
        NoPluginFoundForPrefixException, MojoNotFoundException, PluginNotFoundException, PluginResolutionException,
        LifecyclePhaseNotFoundException, LifecycleNotFoundException
    {
        final MavenSession session1 = session.clone();
        return new ProjectSegment( project, taskSegment, session1 );
    }
4548#private static TaskSegment createTaskSegment()
    {
        TaskSegment result = new TaskSegment( false );
        result.getTasks().add( new GoalTask( "t1" ) );
        result.getTasks().add( new GoalTask( "t2" ) );
        return result;
    }
4549#private List<Dependency> getDependencies()
    {
        List<Dependency> dependencies = new ArrayList<Dependency>();
        dependencies.add( new Dependency( B, A ) );
        dependencies.add( new Dependency( C, A ) );
        dependencies.add( new Dependency( X, B ) );
        dependencies.add( new Dependency( X, C ) );
        dependencies.add( new Dependency( Y, B ) );
        dependencies.add( new Dependency( Z, C ) );
        return dependencies;
    }
4550#public List<MavenProject> getSortedProjects()
    {
        return Arrays.asList( A, B, C, X, Y, Z ); // I'm not entirely sure about the order but this shold do...
    }
4551#public List<MavenProject> getDownstreamProjects( MavenProject project, boolean transitive )
    {
        if ( transitive )
        {
            throw new RuntimeException( "Not implemented yet" );
        }
        List<MavenProject> result = new ArrayList<MavenProject>();
        for ( Dependency dependency : getDependencies() )
        {
            dependency.addIfDownstream( project, result );
        }
        return result;
    }
4552#public List<MavenProject> getUpstreamProjects( MavenProject project, boolean transitive )
    {
        /*  if ( transitive )
        {
            throw new RuntimeException( "Not implemented yet" );
        }*/
        List<MavenProject> result = new ArrayList<MavenProject>();
        final List<Dependency> dependencies = getDependencies();
        for ( Dependency dependency : dependencies )
        {
            dependency.addIfUpstreamOf( project, result );
        }
        return result;
    }
4553#public static MavenSession getMavenSession( MavenProject mavenProject )
    {
        final MavenSession session = getMavenSession();
        session.setCurrentProject( mavenProject );
        return session;
    }
4554#public static MavenSession getMavenSession()
    {
        final DefaultMavenExecutionResult defaultMavenExecutionResult = new DefaultMavenExecutionResult();
        MavenExecutionRequest mavenExecutionRequest = new DefaultMavenExecutionRequest();
        mavenExecutionRequest.setExecutionListener( new AbstractExecutionListener() );
        mavenExecutionRequest.setGoals( Arrays.asList( "clean", "aggr", "install" ) );
        final MavenSession session = new MavenSession( null, null, mavenExecutionRequest, defaultMavenExecutionResult );
        final ProjectDependencyGraphStub dependencyGraphStub = new ProjectDependencyGraphStub();
        session.setProjectDependencyGraph( dependencyGraphStub );
        session.setProjects( dependencyGraphStub.getSortedProjects() );
        return session;
    }
4555#Dependency( MavenProject dependant, MavenProject dependency )
        {
            this.dependant = dependant;
            this.dependency = dependency;
        }
4556#void addIfDownstream( MavenProject mavenProject, List<MavenProject> result )
        {
            if ( dependency == mavenProject )
            {
                result.add( dependant );
            }
        }
4557#void addIfUpstreamOf( MavenProject mavenProject, List<MavenProject> result )
        {
            if ( dependant == mavenProject )
            {
                result.add( dependency ); // All projects are the statics from this class
            }
        }
4558#public PluginVersionResult resolve( PluginVersionRequest request )
        throws PluginVersionResolutionException
    {
        return new PluginVersionResult()
        {
            public String getVersion()
            {
                return "0.42";
            }

            public ArtifactRepository getRepository()
            {
                return null;
            }
        };
    }
4559#public void setUp()
        throws Exception
    {
        super.setUp();
        factory = lookup( RepositorySystem.class );
    }
4560#@Override
    protected void tearDown()
        throws Exception
    {
        factory = null;
        super.tearDown();
    }
4561#public void testPluginDescriptorExpressionReference()
        throws Exception
    {
        MojoExecution exec = newMojoExecution();

        MavenSession session = newMavenSession();

        Object result = new PluginParameterExpressionEvaluator( session, exec ).evaluate( "${plugin}" );

        System.out.println( "Result: " + result );

        assertSame( "${plugin} expression does not return plugin descriptor.",
                    exec.getMojoDescriptor().getPluginDescriptor(),
                    result );
    }
4562#public void testPluginArtifactsExpressionReference()
        throws Exception
    {
        MojoExecution exec = newMojoExecution();

        Artifact depArtifact = createArtifact( "group", "artifact", "1" );

        List<Artifact> deps = new ArrayList<Artifact>();
        deps.add( depArtifact );

        exec.getMojoDescriptor().getPluginDescriptor().setArtifacts( deps );

        MavenSession session = newMavenSession();

        List depResults = (List) new PluginParameterExpressionEvaluator( session, exec ).evaluate( "${plugin.artifacts}" );

        System.out.println( "Result: " + depResults );

        assertNotNull( depResults );
        assertEquals( 1, depResults.size() );
        assertSame( "dependency artifact is wrong.", depArtifact, depResults.get( 0 ) );
    }
4563#public void testPluginArtifactMapExpressionReference()
        throws Exception
    {
        MojoExecution exec = newMojoExecution();

        Artifact depArtifact = createArtifact( "group", "artifact", "1" );

        List<Artifact> deps = new ArrayList<Artifact>();
        deps.add( depArtifact );

        exec.getMojoDescriptor().getPluginDescriptor().setArtifacts( deps );

        MavenSession session = newMavenSession();

        Map depResults = (Map) new PluginParameterExpressionEvaluator( session, exec ).evaluate( "${plugin.artifactMap}" );

        System.out.println( "Result: " + depResults );

        assertNotNull( depResults );
        assertEquals( 1, depResults.size() );
        assertSame( "dependency artifact is wrong.",
                    depArtifact,
                    depResults.get( ArtifactUtils.versionlessKey( depArtifact ) ) );
    }
4564#public void testPluginArtifactIdExpressionReference()
        throws Exception
    {
        MojoExecution exec = newMojoExecution();

        MavenSession session = newMavenSession();

        Object result = new PluginParameterExpressionEvaluator( session, exec ).evaluate( "${plugin.artifactId}" );

        System.out.println( "Result: " + result );

        assertSame( "${plugin.artifactId} expression does not return plugin descriptor's artifactId.",
                    exec.getMojoDescriptor().getPluginDescriptor().getArtifactId(),
                    result );
    }
4565#public void testValueExtractionWithAPomValueContainingAPath()
        throws Exception
    {
        String expected = getTestFile( "target/test-classes/target/classes" ).getCanonicalPath();

        Build build = new Build();
        build.setDirectory( expected.substring( 0, expected.length() - "/classes".length() ) );

        Model model = new Model();
        model.setBuild( build );

        MavenProject project = new MavenProject( model );
        project.setFile( new File( "pom.xml" ).getCanonicalFile() );

        ExpressionEvaluator expressionEvaluator = createExpressionEvaluator( project, null, new Properties() );

        Object value = expressionEvaluator.evaluate( "${project.build.directory}/classes" );
        String actual = new File( value.toString() ).getCanonicalPath();

        assertEquals( expected, actual );
    }
4566#public void testEscapedVariablePassthrough()
        throws Exception
    {
        String var = "${var}";

        Model model = new Model();
        model.setVersion( "1" );

        MavenProject project = new MavenProject( model );

        ExpressionEvaluator ee = createExpressionEvaluator( project, null, new Properties() );

        Object value = ee.evaluate( "$" + var );

        assertEquals( var, value );
    }
4567#public void testEscapedVariablePassthroughInLargerExpression()
        throws Exception
    {
        String var = "${var}";
        String key = var + " with version: ${project.version}";

        Model model = new Model();
        model.setVersion( "1" );

        MavenProject project = new MavenProject( model );

        ExpressionEvaluator ee = createExpressionEvaluator( project, null, new Properties() );

        Object value = ee.evaluate( "$" + key );

        assertEquals( "${var} with version: 1", value );
    }
4568#public void testMultipleSubExpressionsInLargerExpression()
        throws Exception
    {
        String key = "${project.artifactId} with version: ${project.version}";

        Model model = new Model();
        model.setArtifactId( "test" );
        model.setVersion( "1" );

        MavenProject project = new MavenProject( model );

        ExpressionEvaluator ee = createExpressionEvaluator( project, null, new Properties() );

        Object value = ee.evaluate( key );

        assertEquals( "test with version: 1", value );
    }
4569#public void testMissingPOMPropertyRefInLargerExpression()
        throws Exception
    {
        String expr = "/path/to/someproject-${baseVersion}";

        MavenProject project = new MavenProject( new Model() );

        ExpressionEvaluator ee = createExpressionEvaluator( project, null, new Properties() );

        Object value = ee.evaluate( expr );

        assertEquals( expr, value );
    }
4570#public void testPOMPropertyExtractionWithMissingProject_WithDotNotation()
        throws Exception
    {
        String key = "m2.name";
        String checkValue = "value";

        Properties properties = new Properties();
        properties.setProperty( key, checkValue );

        Model model = new Model();
        model.setProperties( properties );

        MavenProject project = new MavenProject( model );

        ExpressionEvaluator ee = createExpressionEvaluator( project, null, new Properties() );

        Object value = ee.evaluate( "${" + key + "}" );

        assertEquals( checkValue, value );
    }
4571#public void testBasedirExtractionWithMissingProject()
        throws Exception
    {
        ExpressionEvaluator ee = createExpressionEvaluator( null, null, new Properties() );

        Object value = ee.evaluate( "${basedir}" );

        assertEquals( System.getProperty( "user.dir" ), value );
    }
4572#public void testValueExtractionFromSystemPropertiesWithMissingProject()
        throws Exception
    {
        String sysprop = "PPEET_sysprop1";

        Properties executionProperties = new Properties();

        if ( executionProperties.getProperty( sysprop ) == null )
        {
            executionProperties.setProperty( sysprop, "value" );
        }

        ExpressionEvaluator ee = createExpressionEvaluator( null, null, executionProperties );

        Object value = ee.evaluate( "${" + sysprop + "}" );

        assertEquals( "value", value );
    }
4573#public void testValueExtractionFromSystemPropertiesWithMissingProject_WithDotNotation()
        throws Exception
    {
        String sysprop = "PPEET.sysprop2";

        Properties executionProperties = new Properties();

        if ( executionProperties.getProperty( sysprop ) == null )
        {
            executionProperties.setProperty( sysprop, "value" );
        }

        ExpressionEvaluator ee = createExpressionEvaluator( null, null, executionProperties );

        Object value = ee.evaluate( "${" + sysprop + "}" );

        assertEquals( "value", value );
    }
4574#private static MavenSession createSession( PlexusContainer container, ArtifactRepository repo, Properties properties )
        throws CycleDetectedException, DuplicateProjectException
    {
        MavenExecutionRequest request = new DefaultMavenExecutionRequest()
            .setSystemProperties( properties )
            .setGoals( Collections.EMPTY_LIST )
            .setBaseDirectory( new File( "" ) )
            .setLocalRepository( repo );

        return new MavenSession( container, request, new DefaultMavenExecutionResult(), Collections.EMPTY_LIST  );
    }
4575#public void testLocalRepositoryExtraction()
        throws Exception
    {
        ExpressionEvaluator expressionEvaluator =
            createExpressionEvaluator( createDefaultProject(), null, new Properties() );
        Object value = expressionEvaluator.evaluate( "${localRepository}" );

        assertEquals( "local", ( (ArtifactRepository) value ).getId() );
    }
4576#public void testTwoExpressions()
        throws Exception
    {
        Build build = new Build();
        build.setDirectory( "expected-directory" );
        build.setFinalName( "expected-finalName" );

        Model model = new Model();
        model.setBuild( build );

        ExpressionEvaluator expressionEvaluator =
            createExpressionEvaluator( new MavenProject( model ), null, new Properties() );

        Object value = expressionEvaluator.evaluate( "${project.build.directory}" + FS + "${project.build.finalName}" );

        assertEquals( "expected-directory" + File.separatorChar + "expected-finalName", value );
    }
4577#public void testShouldExtractPluginArtifacts()
        throws Exception
    {
        PluginDescriptor pd = new PluginDescriptor();

        Artifact artifact = createArtifact( "testGroup", "testArtifact", "1.0" );

        pd.setArtifacts( Collections.singletonList( artifact ) );

        ExpressionEvaluator ee = createExpressionEvaluator( createDefaultProject(), pd, new Properties() );

        Object value = ee.evaluate( "${plugin.artifacts}" );

        assertTrue( value instanceof List );

        List artifacts = (List) value;

        assertEquals( 1, artifacts.size() );

        Artifact result = (Artifact) artifacts.get( 0 );

        assertEquals( "testGroup", result.getGroupId() );
    }
4578#private MavenProject createDefaultProject()
    {
        return new MavenProject( new Model() );
    }
4579#private ExpressionEvaluator createExpressionEvaluator( MavenProject project, PluginDescriptor pluginDescriptor, Properties executionProperties )
        throws Exception
    {
        ArtifactRepository repo = factory.createDefaultLocalRepository();

        MutablePlexusContainer container = (MutablePlexusContainer) getContainer();
        MavenSession session = createSession( container, repo, executionProperties );
        session.setCurrentProject( project );

        MojoDescriptor mojo = new MojoDescriptor();
        mojo.setPluginDescriptor( pluginDescriptor );
        mojo.setGoal( "goal" );

        MojoExecution mojoExecution = new MojoExecution( mojo );

        return new PluginParameterExpressionEvaluator( session, mojoExecution );
    }
4580#protected Artifact createArtifact( String groupId, String artifactId, String version )
        throws Exception
    {
        Dependency dependency = new Dependency();
        dependency.setGroupId( groupId );
        dependency.setArtifactId( artifactId );
        dependency.setVersion( version );
        dependency.setType( "jar" );
        dependency.setScope( "compile" );

        return factory.createDependencyArtifact( dependency );
    }
4581#private MojoExecution newMojoExecution()
    {
        PluginDescriptor pd = new PluginDescriptor();
        pd.setArtifactId( "my-plugin" );
        pd.setGroupId( "org.myco.plugins" );
        pd.setVersion( "1" );

        MojoDescriptor md = new MojoDescriptor();
        md.setPluginDescriptor( pd );

        pd.addComponentDescriptor( md );

        return new MojoExecution( md );
    }
4582#private MavenSession newMavenSession()
        throws Exception
    {
        return createMavenSession( null );
    }
4583#@Override
    protected String getProjectsDirectory()
    {
        // TODO Auto-generated method stub
        return null;
    }
4584#protected void setUp()
        throws Exception
    {
        super.setUp();
        pluginManager = (DefaultBuildPluginManager) lookup( BuildPluginManager.class );
    }
4585#@Override
    protected void tearDown()
        throws Exception
    {
        pluginManager = null;
        super.tearDown();
    }
4586#protected String getProjectsDirectory()
    {
        return "src/test/projects/plugin-manager";
    }
4587#public void testPluginLoading()
        throws Exception
    {
        MavenSession session = createMavenSession( null );       
        Plugin plugin = new Plugin();
        plugin.setGroupId( "org.apache.maven.its.plugins" );
        plugin.setArtifactId( "maven-it-plugin" );
        plugin.setVersion( "0.1" );
        PluginDescriptor pluginDescriptor =
            pluginManager.loadPlugin( plugin, session.getCurrentProject().getRemotePluginRepositories(),
                                      session.getRepositorySession() );
        assertNotNull( pluginDescriptor );
    }
4588#public void testMojoDescriptorRetrieval()
        throws Exception
    {
        MavenSession session = createMavenSession( null );       
        String goal = "it";
        Plugin plugin = new Plugin();
        plugin.setGroupId( "org.apache.maven.its.plugins" );
        plugin.setArtifactId( "maven-it-plugin" );
        plugin.setVersion( "0.1" );
        
        MojoDescriptor mojoDescriptor =
            pluginManager.getMojoDescriptor( plugin, goal, session.getCurrentProject().getRemotePluginRepositories(),
                                             session.getRepositorySession() );
        assertNotNull( mojoDescriptor );
        assertEquals( goal, mojoDescriptor.getGoal() );
        // igorf: plugin realm comes later
        // assertNotNull( mojoDescriptor.getRealm() );
        
        PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();
        assertNotNull( pluginDescriptor );
        assertEquals( "org.apache.maven.its.plugins", pluginDescriptor.getGroupId() );
        assertEquals( "maven-it-plugin", pluginDescriptor.getArtifactId() );
        assertEquals( "0.1", pluginDescriptor.getVersion() );
    }
4589#// -----------------------------------------------------------------------------------------------
    // Tests which exercise the lifecycle executor when it is dealing with individual goals.
    // -----------------------------------------------------------------------------------------------
    
    //TODO: These two tests display a lack of symmetry with respect to the input which is a free form string and the
    //      mojo descriptor which comes back. All the free form parsing needs to be done somewhere else, this is
    //      really the function of the CLI, and then the pre-processing of that output still needs to be fed into
    //      a hinting process which helps flesh out the full specification of the plugin. The plugin manager should
    //      only deal in concrete terms -- all version finding mumbo jumbo is a customization to base functionality
    //      the plugin manager provides.
    
    public void testRemoteResourcesPlugin()
        throws Exception
    {
        //TODO: turn an equivalent back on when the RR plugin is released.
        
        /*

        This will not work until the RR plugin is released to get rid of the binding to the reporting exception which is a mistake.
        
        This happpens after removing the reporting API from the core:
        
        java.lang.NoClassDefFoundError: org/apache/maven/reporting/MavenReportException
        
        MavenSession session = createMavenSession( getProject( "project-with-inheritance" ) );       
        String goal = "process";
        
        Plugin plugin = new Plugin();
        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( "maven-remote-resources-plugin" );
        plugin.setVersion( "1.0-beta-2" );
        
        MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getCurrentProject(), session.getLocalRepository() );        
        assertPluginDescriptor( mojoDescriptor, "org.apache.maven.plugins", "maven-remote-resources-plugin", "1.0-beta-2" );
        MojoExecution mojoExecution = new MojoExecution( mojoDescriptor );
        pluginManager.executeMojo( session, mojoExecution );
        */
    }
4590#//TODO: this will be the basis of the customizable lifecycle execution so need to figure this out quickly.
    public void testSurefirePlugin()
        throws Exception
    {
        /*
        MavenSession session = createMavenSession( getProject( "project-with-inheritance" ) );
        String goal = "test";

        Plugin plugin = new Plugin();
        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( "maven-surefire-plugin" );
        plugin.setVersion( "2.4.2" );

        // The project has already been fully interpolated so getting the raw mojoDescriptor is not going to have the processes configuration.
        MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getLocalRepository(), session.getCurrentProject().getPluginArtifactRepositories() );        
        assertPluginDescriptor( mojoDescriptor, "org.apache.maven.plugins", "maven-surefire-plugin", "2.4.2" );
        
        System.out.println( session.getCurrentProject().getBuild().getPluginsAsMap() );
        
        Xpp3Dom configuration = (Xpp3Dom) session.getCurrentProject().getBuild().getPluginsAsMap().get( plugin.getKey() ).getExecutions().get( 0 ).getConfiguration();
        MojoExecution mojoExecution = new MojoExecution( mojoDescriptor, configuration );
        pluginManager.executeMojo( session, mojoExecution );
        */
    }
4591#public void testMojoConfigurationIsMergedCorrectly()
        throws Exception
    {
    }
4592#/**
     * The case where the user wants to specify an alternate version of the underlying tool. Common case
     * is in the Antlr plugin which comes bundled with a version of Antlr but the user often times needs
     * to use a specific version. We need to make sure the version that they specify takes precedence.
     */
    public void testMojoWhereInternallyStatedDependencyIsOverriddenByProject()
        throws Exception
    {
    }
4593#/** 
     * The case where you have a plugin in the current build that you want to be used on projects in
     * the current build.
     */
    public void testMojoThatIsPresentInTheCurrentBuild()
        throws Exception
    {
    }
4594#/**
     * This is the case where the Mojo wants to execute on every project and then do something at the end
     * with the results of each project.
     */
    public void testAggregatorMojo()
        throws Exception
    {
    }
4595#/**
     * This is the case where a Mojo needs the lifecycle run to a certain phase before it can do
     * anything useful.
     */
    public void testMojoThatRequiresExecutionToAGivenPhaseBeforeExecutingItself()
        throws Exception
    {
    }
4596#// test that mojo which does not require dependency resolution trigger no downloading of dependencies
    
    // test interpolation of basedir values in mojo configuration
    
    // test a build where projects use different versions of the same plugin
    
    public void testThatPluginDependencyThatHasSystemScopeIsResolved()
        throws Exception
    {
        /*
        File systemPath = new File( getBasedir(), "pom.xml" );

        Plugin plugin = new PluginBuilder( "org.apache.maven", "project-test", "1.0" )
            .addDependency( "org.apache.maven", "system-dependency", "1.0", Artifact.SCOPE_SYSTEM, systemPath.getAbsolutePath() )
            .get();        

        MavenProject pluginProject = new ProjectBuilder( "org.apache.maven", "project-test", "1.0" )
            .addPlugin( plugin )
            .addDependency( "junit", "junit", "3.8.1", Artifact.SCOPE_COMPILE )
            .get();        
        
        // i'm making this artifact which is assumed to come from a pom in the metadata processor, then it tries to create a POM artifact
        // and parse it for the dependencies and it blows up.
        //
        // we need to pass this through as is so it doesn't get parsed again.
        Artifact pluginArtifact = new ProjectArtifact( pluginProject );
        
        Set<Artifact> artifacts = pluginManager.getPluginArtifacts( pluginArtifact, plugin, getLocalRepository(), getPluginArtifactRepositories() );
        System.out.println( artifacts );
        */
        
        MavenSession session = createMavenSession( getProject( "project-contributing-system-scope-plugin-dep" ) );
        MavenProject project = session.getCurrentProject();
        Plugin plugin = project.getPlugin( "org.apache.maven.its.plugins:maven-it-plugin" );                
        
        RepositoryRequest repositoryRequest = new DefaultRepositoryRequest();
        repositoryRequest.setLocalRepository( getLocalRepository() );
        repositoryRequest.setRemoteRepositories( getPluginArtifactRepositories() );

        PluginDescriptor pluginDescriptor =
            pluginManager.loadPlugin( plugin, session.getCurrentProject().getRemotePluginRepositories(),
                                      session.getRepositorySession() );
        pluginManager.getPluginRealm( session, pluginDescriptor );
        List<Artifact> artifacts = pluginDescriptor.getArtifacts();

        for ( Artifact a : artifacts )
        {
            if ( a.getGroupId().equals( "org.apache.maven.its.mng3586" ) && a.getArtifactId().equals( "tools" ) )
            {
                // The system scoped dependencies will be present in the classloader for the plugin
                return;
            }
        }
        
        fail( "Can't find the system scoped dependency in the plugin artifacts." );
    }
4597#// -----------------------------------------------------------------------------------------------
    // Testing help
    // -----------------------------------------------------------------------------------------------

    protected void assertPluginDescriptor( MojoDescriptor mojoDescriptor, String groupId, String artifactId, String version )
    {
        assertNotNull( mojoDescriptor );        
        PluginDescriptor pd = mojoDescriptor.getPluginDescriptor();
        assertNotNull( pd );
        assertEquals( groupId, pd.getGroupId() );
        assertEquals( artifactId, pd.getArtifactId() );
        assertEquals( version, pd.getVersion() );        
    }
4598#public void testPluginRealmCache()
        throws Exception
    {
        RepositoryRequest repositoryRequest = new DefaultRepositoryRequest();
        repositoryRequest.setLocalRepository( getLocalRepository() );
        repositoryRequest.setRemoteRepositories( getPluginArtifactRepositories() );

        // prime realm cache
        MavenSession session = createMavenSession( getProject( "project-contributing-system-scope-plugin-dep" ) );
        MavenProject project = session.getCurrentProject();
        Plugin plugin = project.getPlugin( "org.apache.maven.its.plugins:maven-it-plugin" );

        PluginDescriptor pluginDescriptor =
            pluginManager.loadPlugin( plugin, session.getCurrentProject().getRemotePluginRepositories(),
                                      session.getRepositorySession() );
        pluginManager.getPluginRealm( session, pluginDescriptor );

        for ( ComponentDescriptor<?> descriptor : pluginDescriptor.getComponents() )
        {
            assertNotNull( descriptor.getRealm() );
            assertNotNull( descriptor.getImplementationClass() );
        }
        
        // reload plugin realm from cache
        session = createMavenSession( getProject( "project-contributing-system-scope-plugin-dep" ) );
        project = session.getCurrentProject();
        plugin = project.getPlugin( "org.apache.maven.its.plugins:maven-it-plugin" );

        pluginDescriptor =
            pluginManager.loadPlugin( plugin, session.getCurrentProject().getRemotePluginRepositories(),
                                      session.getRepositorySession() );
        pluginManager.getPluginRealm( session, pluginDescriptor );

        for ( ComponentDescriptor<?> descriptor : pluginDescriptor.getComponents() )
        {
            assertNotNull( descriptor.getRealm() );
            assertNotNull( descriptor.getImplementationClass() );
        }
    }
4599#@Override
    public void setUp()
        throws Exception
    {
        super.setUp();

        projectBuilder = lookup( ProjectBuilder.class );

        localRepoDir = new File( System.getProperty( "java.io.tmpdir" ), "local-repo." + System.currentTimeMillis() );
        localRepoDir.mkdirs();

        filesToDelete.add( localRepoDir );
    }
4600#@Override
    public void tearDown()
        throws Exception
    {
        super.tearDown();

        if ( !filesToDelete.isEmpty() )
        {
            for ( Iterator<File> it = filesToDelete.iterator(); it.hasNext(); )
            {
                File file = it.next();

                if ( file.exists() )
                {
                    if ( file.isDirectory() )
                    {
                        FileUtils.deleteDirectory( file );
                    }
                    else
                    {
                        file.delete();
                    }
                }
            }
        }
    }
4601#protected MavenProject getProject( Artifact pom, boolean allowStub )
        throws Exception
    {
        ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();
        configuration.setLocalRepository( getLocalRepository() );
        initRepoSession( configuration );

        return projectBuilder.build( pom, allowStub, configuration ).getProject();
    }
4602#/**
     * Check that we can build ok from the middle pom of a (parent,child,grandchild) heirarchy
     * @throws Exception
     */
    public void testBuildFromMiddlePom() throws Exception
    {
        File f1 = getTestFile( "src/test/resources/projects/grandchild-check/child/pom.xml");
        File f2 = getTestFile( "src/test/resources/projects/grandchild-check/child/grandchild/pom.xml");

        getProject( f1 );

        // it's the building of the grandchild project, having already cached the child project
        // (but not the parent project), which causes the problem.
        getProject( f2 );
    }
4603#public void testDuplicatePluginDefinitionsMerged()
        throws Exception
    {
        File f1 = getTestFile( "src/test/resources/projects/duplicate-plugins-merged-pom.xml" );

        MavenProject project = getProject( f1 );
        assertEquals( 2, project.getBuildPlugins().get( 0 ).getDependencies().size() );
        assertEquals( 2, project.getBuildPlugins().get( 0 ).getExecutions().size() );
        assertEquals( "first", project.getBuildPlugins().get( 0 ).getExecutions().get( 0 ).getId() );
    }
4604#public void testBuildStubModelForMissingRemotePom()
        throws Exception
    {
        Artifact pom = repositorySystem.createProjectArtifact( "org.apache.maven.its", "missing", "0.1" );
        MavenProject project = getProject( pom, true );

        assertNotNull( project.getArtifactId() );

        assertNotNull( project.getRemoteArtifactRepositories() );
        assertFalse( project.getRemoteArtifactRepositories().isEmpty() );

        assertNotNull( project.getPluginArtifactRepositories() );
        assertFalse( project.getPluginArtifactRepositories().isEmpty() );

        assertNull( project.getParent() );
        assertNull( project.getParentArtifact() );

        assertFalse( project.isExecutionRoot() );
    }
4605#@Override
    protected ArtifactRepository getLocalRepository()
        throws Exception
    {
        ArtifactRepositoryLayout repoLayout = lookup( ArtifactRepositoryLayout.class, "default" );
        ArtifactRepository r =
            repositorySystem.createArtifactRepository( "local", "file://" + localRepoDir.getAbsolutePath(), repoLayout,
                                                       null, null );
        return r;
    }
4606#public void xtestLoop()
        throws Exception
    {
        while ( true )
        {
            File f1 = getTestFile( "src/test/resources/projects/duplicate-plugins-merged-pom.xml" );
            getProject( f1 );
        }
    }
4607#public void testPartialResultUponBadDependencyDeclaration()
        throws Exception
    {
        File pomFile = getTestFile( "src/test/resources/projects/bad-dependency.xml" );

        try
        {
            ProjectBuildingRequest request = newBuildingRequest();
            request.setProcessPlugins( false );
            request.setResolveDependencies( true );
            projectBuilder.build( pomFile, request );
            fail( "Project building did not fail despite invalid POM" );
        }
        catch ( ProjectBuildingException e )
        {
            List<ProjectBuildingResult> results = e.getResults();
            assertNotNull( results );
            assertEquals( 1, results.size() );
            ProjectBuildingResult result = results.get( 0 );
            assertNotNull( result );
            assertNotNull( result.getProject() );
            assertEquals( 1, result.getProblems().size() );
            assertEquals( 1, result.getProject().getArtifacts().size() );
            assertNotNull( result.getDependencyResolutionResult() );
        }
    }
4608#@Override
    public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository,
                                     List<ArtifactRepository> remoteRepositories )
        throws ArtifactMetadataRetrievalException
    {        
        ResolutionGroup rg = super.retrieve( artifact, localRepository, remoteRepositories );
        
        for ( Artifact a : rg.getArtifacts() )
        {
            a.setResolved( true );
        }
        
        return rg;
    }
4609#protected void setUp()
        throws Exception
    {
        super.setUp();
        
        if ( getContainer().hasComponent( ProjectBuilder.class, "test" ) )
        {
            projectBuilder = lookup( ProjectBuilder.class, "test" );
        }
        else
        {
            // default over to the main project builder...
            projectBuilder = lookup( ProjectBuilder.class );
        }
        
        repositorySystem = lookup( RepositorySystem.class );        
    }
4610#@Override
    protected void tearDown()
        throws Exception
    {
        projectBuilder = null;

        super.tearDown();
    }
4611#protected ProjectBuilder getProjectBuilder()
    {
        return projectBuilder;
    }
4612#@Override
    protected String getCustomConfigurationName()
    {
        String name = AbstractMavenProjectTestCase.class.getName().replace( '.', '/' ) + ".xml";
        System.out.println( name );
        return name;
    }
4613#// ----------------------------------------------------------------------
    // Local repository
    // ----------------------------------------------------------------------

    protected File getLocalRepositoryPath()
        throws FileNotFoundException, URISyntaxException
    {
        File markerFile = getFileForClasspathResource( "local-repo/marker.txt" );

        return markerFile.getAbsoluteFile().getParentFile();
    }
4614#protected static File getFileForClasspathResource( String resource )
        throws FileNotFoundException
    {
        ClassLoader cloader = Thread.currentThread().getContextClassLoader();

        URL resourceUrl = cloader.getResource( resource );

        if ( resourceUrl == null )
        {
            throw new FileNotFoundException( "Unable to find: " + resource );
        }

        return new File( URI.create( resourceUrl.toString().replaceAll( " ", "%20" ) ) );
    }
4615#protected ArtifactRepository getLocalRepository()
        throws Exception
    {
        ArtifactRepositoryLayout repoLayout = lookup( ArtifactRepositoryLayout.class, "legacy" );

        ArtifactRepository r = repositorySystem.createArtifactRepository( "local", "file://" + getLocalRepositoryPath().getAbsolutePath(), repoLayout, null, null );

        return r;
    }
4616#// ----------------------------------------------------------------------
    // Project building
    // ----------------------------------------------------------------------

    protected MavenProject getProjectWithDependencies( File pom )
        throws Exception
    {
        ProjectBuildingRequest configuration = newBuildingRequest();
        configuration.setRemoteRepositories( Arrays.asList( new ArtifactRepository[] {} ) );
        configuration.setProcessPlugins( false );
        configuration.setResolveDependencies( true );

        try
        {
            return projectBuilder.build( pom, configuration ).getProject();
        }
        catch ( Exception e )
        {
            Throwable cause = e.getCause();
            if ( cause instanceof ModelBuildingException )
            {
                String message = "In: " + pom + "\n\n";
                for ( ModelProblem problem : ( (ModelBuildingException) cause ).getProblems() )
                {
                    message += problem + "\n";
                }
                System.out.println( message );
            }

            throw e;
        }
    }
4617#protected MavenProject getProject( File pom )
        throws Exception
    {
        ProjectBuildingRequest configuration = newBuildingRequest();

        return projectBuilder.build( pom, configuration ).getProject();
    }
4618#protected ProjectBuildingRequest newBuildingRequest()
        throws Exception
    {
        ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest();
        configuration.setLocalRepository( getLocalRepository() );
        initRepoSession( configuration );
        return configuration;
    }
4619#protected void initRepoSession( ProjectBuildingRequest request )
    {
        File localRepo = new File( request.getLocalRepository().getBasedir() );
        MavenRepositorySystemSession repoSession = new MavenRepositorySystemSession();
        repoSession.setLocalRepositoryManager( new LegacyLocalRepositoryManager( localRepo ) );
        request.setRepositorySession( repoSession );
    }
4620#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();

        builder = new ExtensionDescriptorBuilder();
    }
4621#@Override
    protected void tearDown()
        throws Exception
    {
        builder = null;

        super.tearDown();
    }
4622#private InputStream toStream( String xml )
    {
        try
        {
            return new ByteArrayInputStream( xml.getBytes( "UTF-8" ) );
        }
        catch ( UnsupportedEncodingException e )
        {
            throw new IllegalStateException( e );
        }
    }
4623#public void testEmptyDescriptor()
        throws Exception
    {
        String xml = "<extension></extension>";

        ExtensionDescriptor ed = builder.build( toStream( xml ) );

        assertNotNull( ed );
        assertNotNull( ed.getExportedPackages() );
        assertTrue( ed.getExportedPackages().isEmpty() );
        assertNotNull( ed.getExportedArtifacts() );
        assertTrue( ed.getExportedArtifacts().isEmpty() );
    }
4624#public void testCompleteDescriptor()
        throws Exception
    {
        String xml =
            "<?xml version='1.0' encoding='UTF-8'?>" + "<extension>" + "<exportedPackages>"
                + "<exportedPackage>a</exportedPackage>" + "<exportedPackage>b</exportedPackage>"
                + "<exportedPackage>c</exportedPackage>" + "</exportedPackages>" + "<exportedArtifacts>"
                + "<exportedArtifact>x</exportedArtifact>" + "<exportedArtifact>y</exportedArtifact>"
                + "<exportedArtifact> z </exportedArtifact>" + "</exportedArtifacts>" + "</extension>";

        ExtensionDescriptor ed = builder.build( toStream( xml ) );

        assertNotNull( ed );
        assertEquals( Arrays.asList( "a", "b", "c" ), ed.getExportedPackages() );
        assertEquals( Arrays.asList( "x", "y", "z" ), ed.getExportedArtifacts() );
    }
4625#private Parent createParent( MavenProject project )
    {
        return createParent( project.getGroupId(), project.getArtifactId(), project.getVersion() );
    }
4626#private Parent createParent( String groupId, String artifactId, String version )
    {
        Parent plugin = new Parent();
        plugin.setGroupId( groupId );
        plugin.setArtifactId( artifactId );
        plugin.setVersion( version );
        return plugin;
    }
4627#private Dependency createDependency( MavenProject project )
    {
        return createDependency( project.getGroupId(), project.getArtifactId(), project.getVersion() );
    }
4628#private Dependency createDependency( String groupId, String artifactId, String version )
    {
        Dependency depdendency = new Dependency();
        depdendency.setGroupId( groupId );
        depdendency.setArtifactId( artifactId );
        depdendency.setVersion( version );
        return depdendency;
    }
4629#private Plugin createPlugin( MavenProject project )
    {
        return createPlugin( project.getGroupId(), project.getArtifactId(), project.getVersion() );
    }
4630#private Plugin createPlugin( String groupId, String artifactId, String version )
    {
        Plugin plugin = new Plugin();
        plugin.setGroupId( groupId );
        plugin.setArtifactId( artifactId );
        plugin.setVersion( version );
        return plugin;
    }
4631#private Extension createExtension( String groupId, String artifactId, String version )
    {
        Extension extension = new Extension();
        extension.setGroupId( groupId );
        extension.setArtifactId( artifactId );
        extension.setVersion( version );
        return extension;
    }
4632#private static MavenProject createProject( String groupId, String artifactId, String version )
    {
        Model model = new Model();
        model.setGroupId( groupId );
        model.setArtifactId( artifactId );
        model.setVersion( version );
        model.setBuild( new Build() );
        return new MavenProject( model );
    }
4633#public void testShouldNotFailWhenPluginDepReferencesCurrentProject()
        throws CycleDetectedException, DuplicateProjectException
    {
        MavenProject project = createProject( "group", "artifact", "1.0" );

        Build build = project.getModel().getBuild();

        Plugin plugin = createPlugin( "other.group", "other-artifact", "1.0" );

        Dependency dep = createDependency( "group", "artifact", "1.0" );

        plugin.addDependency( dep );

        build.addPlugin( plugin );

        new ProjectSorter( Collections.singletonList( project ) );
    }
4634#public void testShouldNotFailWhenManagedPluginDepReferencesCurrentProject()
        throws CycleDetectedException, DuplicateProjectException
    {
        MavenProject project = createProject( "group", "artifact", "1.0" );

        Build build = project.getModel().getBuild();

        PluginManagement pMgmt = new PluginManagement();

        Plugin plugin = createPlugin( "other.group", "other-artifact", "1.0" );

        Dependency dep = createDependency( "group", "artifact", "1.0" );

        plugin.addDependency( dep );

        pMgmt.addPlugin( plugin );

        build.setPluginManagement( pMgmt );

        new ProjectSorter( Collections.singletonList( project ) );
    }
4635#public void testShouldNotFailWhenProjectReferencesNonExistentProject()
        throws CycleDetectedException, DuplicateProjectException
    {
        MavenProject project = createProject( "group", "artifact", "1.0" );

        Build build = project.getModel().getBuild();

        Extension extension = createExtension( "other.group", "other-artifact", "1.0" );

        build.addExtension( extension );

        new ProjectSorter( Collections.singletonList( project ) );
    }
4636#public void testMatchingArtifactIdsDifferentGroupIds()
        throws CycleDetectedException, DuplicateProjectException
    {
        List<MavenProject> projects = new ArrayList<MavenProject>();
        MavenProject project1 = createProject( "groupId1", "artifactId", "1.0" );
        projects.add( project1 );
        MavenProject project2 = createProject( "groupId2", "artifactId", "1.0" );
        projects.add( project2 );
        project1.getDependencies().add( createDependency( project2 ) );

        projects = new ProjectSorter( projects ).getSortedProjects();

        assertEquals( project2, projects.get( 0 ) );
        assertEquals( project1, projects.get( 1 ) );
    }
4637#public void testMatchingGroupIdsDifferentArtifactIds()
        throws CycleDetectedException, DuplicateProjectException
    {
        List<MavenProject> projects = new ArrayList<MavenProject>();
        MavenProject project1 = createProject( "groupId", "artifactId1", "1.0" );
        projects.add( project1 );
        MavenProject project2 = createProject( "groupId", "artifactId2", "1.0" );
        projects.add( project2 );
        project1.getDependencies().add( createDependency( project2 ) );

        projects = new ProjectSorter( projects ).getSortedProjects();

        assertEquals( project2, projects.get( 0 ) );
        assertEquals( project1, projects.get( 1 ) );
    }
4638#public void testMatchingIdsAndVersions()
        throws CycleDetectedException
    {
        List<MavenProject> projects = new ArrayList<MavenProject>();
        MavenProject project1 = createProject( "groupId", "artifactId", "1.0" );
        projects.add( project1 );
        MavenProject project2 = createProject( "groupId", "artifactId", "1.0" );
        projects.add( project2 );

        try
        {
            projects = new ProjectSorter( projects ).getSortedProjects();
            fail( "Duplicate projects should fail" );
        }
        catch ( DuplicateProjectException e )
        {
            // expected
            assertTrue( true );
        }
    }
4639#public void testMatchingIdsAndDifferentVersions()
        throws CycleDetectedException, DuplicateProjectException
    {
        List<MavenProject> projects = new ArrayList<MavenProject>();
        MavenProject project1 = createProject( "groupId", "artifactId", "1.0" );
        projects.add( project1 );
        MavenProject project2 = createProject( "groupId", "artifactId", "2.0" );
        projects.add( project2 );

        projects = new ProjectSorter( projects ).getSortedProjects();
        assertEquals( project1, projects.get( 0 ) );
        assertEquals( project2, projects.get( 1 ) );
    }
4640#public void testPluginDependenciesInfluenceSorting()
        throws Exception
    {
        List<MavenProject> projects = new ArrayList<MavenProject>();

        MavenProject parentProject = createProject( "groupId", "parent", "1.0" );
        projects.add( parentProject );

        MavenProject declaringProject = createProject( "groupId", "declarer", "1.0" );
        declaringProject.setParent( parentProject );
        declaringProject.getModel().setParent( createParent( parentProject ) );
        projects.add( declaringProject );

        MavenProject pluginLevelDepProject = createProject( "groupId", "plugin-level-dep", "1.0" );
        pluginLevelDepProject.setParent( parentProject );
        pluginLevelDepProject.getModel().setParent( createParent( parentProject ) );
        projects.add( pluginLevelDepProject );

        MavenProject pluginProject = createProject( "groupId", "plugin", "1.0" );
        pluginProject.setParent( parentProject );
        pluginProject.getModel().setParent( createParent( parentProject ) );
        projects.add( pluginProject );

        Plugin plugin = createPlugin( pluginProject );

        plugin.addDependency( createDependency( pluginLevelDepProject ) );

        Build build = declaringProject.getModel().getBuild();

        build.addPlugin( plugin );

        projects = new ProjectSorter( projects ).getSortedProjects();

        assertEquals( parentProject, projects.get( 0 ) );

        // the order of these two is non-deterministic, based on when they're added to the reactor.
        assertTrue( projects.contains( pluginProject ) );
        assertTrue( projects.contains( pluginLevelDepProject ) );

        // the declaring project MUST be listed after the plugin and its plugin-level dep, though.
        assertEquals( declaringProject, projects.get( 3 ) );
    }
4641#public void testPluginDependenciesInfluenceSorting_DeclarationInParent()
        throws Exception
    {
        List<MavenProject> projects = new ArrayList<MavenProject>();

        MavenProject parentProject = createProject( "groupId", "parent-declarer", "1.0" );
        projects.add( parentProject );

        MavenProject pluginProject = createProject( "groupId", "plugin", "1.0" );
        pluginProject.setParent( parentProject );
        pluginProject.getModel().setParent( createParent( parentProject ) );
        projects.add( pluginProject );

        MavenProject pluginLevelDepProject = createProject( "groupId", "plugin-level-dep", "1.0" );
        pluginLevelDepProject.setParent( parentProject );
        pluginLevelDepProject.getModel().setParent( createParent( parentProject ) );
        projects.add( pluginLevelDepProject );

        Plugin plugin = createPlugin( pluginProject );

        plugin.addDependency( createDependency( pluginLevelDepProject ) );

        Build build = parentProject.getModel().getBuild();

        build.addPlugin( plugin );

        projects = new ProjectSorter( projects ).getSortedProjects();

        System.out.println( projects );

        assertEquals( parentProject, projects.get( 0 ) );

        // the order of these two is non-deterministic, based on when they're added to the reactor.
        assertTrue( projects.contains( pluginProject ) );
        assertTrue( projects.contains( pluginLevelDepProject ) );
    }
4642#public void testPluginVersionsAreConsidered()
        throws Exception
    {
        List<MavenProject> projects = new ArrayList<MavenProject>();

        MavenProject pluginProjectA = createProject( "group", "plugin-a", "2.0-SNAPSHOT" );
        projects.add( pluginProjectA );
        pluginProjectA.getModel().getBuild().addPlugin( createPlugin( "group", "plugin-b", "1.0" ) );

        MavenProject pluginProjectB = createProject( "group", "plugin-b", "2.0-SNAPSHOT" );
        projects.add( pluginProjectB );
        pluginProjectB.getModel().getBuild().addPlugin( createPlugin( "group", "plugin-a", "1.0" ) );

        projects = new ProjectSorter( projects ).getSortedProjects();

        assertTrue( projects.contains( pluginProjectA ) );
        assertTrue( projects.contains( pluginProjectB ) );
    }
4643#public void testDependencyPrecedesProjectThatUsesSpecificDependencyVersion()
        throws Exception
    {
        List<MavenProject> projects = new ArrayList<MavenProject>();

        MavenProject usingProject = createProject( "group", "project", "1.0" );
        projects.add( usingProject );
        usingProject.getModel().addDependency( createDependency( "group", "dependency", "1.0" ) );

        MavenProject pluginProject = createProject( "group", "dependency", "1.0" );
        projects.add( pluginProject );

        projects = new ProjectSorter( projects ).getSortedProjects();

        assertEquals( pluginProject, projects.get( 0 ) );
        assertEquals( usingProject, projects.get( 1 ) );
    }
4644#public void testDependencyPrecedesProjectThatUsesUnresolvedDependencyVersion()
        throws Exception
    {
        List<MavenProject> projects = new ArrayList<MavenProject>();

        MavenProject usingProject = createProject( "group", "project", "1.0" );
        projects.add( usingProject );
        usingProject.getModel().addDependency( createDependency( "group", "dependency", "[1.0,)" ) );

        MavenProject pluginProject = createProject( "group", "dependency", "1.0" );
        projects.add( pluginProject );

        projects = new ProjectSorter( projects ).getSortedProjects();

        assertEquals( pluginProject, projects.get( 0 ) );
        assertEquals( usingProject, projects.get( 1 ) );
    }
4645#public void testShouldInterpretChildPathAdjustmentBasedOnModulePaths()
        throws IOException
    {
        Model parentModel = new Model();
        parentModel.addModule( "../child" );

        MavenProject parentProject = new MavenProject( parentModel );

        Model childModel = new Model();
        childModel.setArtifactId( "artifact" );

        MavenProject childProject = new MavenProject( childModel );
        
        File childFile =
            new File( System.getProperty( "java.io.tmpdir" ), "maven-project-tests" + System.currentTimeMillis()
                + "/child/pom.xml" );

        childProject.setFile( childFile );

        String adjustment = parentProject.getModulePathAdjustment( childProject );

        assertNotNull( adjustment );
        
        assertEquals( "..", adjustment );
    }
4646#public void testIdentityProtoInheritance()
    {
        Parent parent = new Parent();

        parent.setGroupId( "test-group" );
        parent.setVersion( "1000" );
        parent.setArtifactId( "test-artifact" );

        Model model = new Model();

        model.setParent( parent );
        model.setArtifactId( "real-artifact" );

        MavenProject project = new MavenProject( model );

        assertEquals( "groupId proto-inheritance failed.", "test-group", project.getGroupId() );
        assertEquals( "artifactId is masked.", "real-artifact", project.getArtifactId() );
        assertEquals( "version proto-inheritance failed.", "1000", project.getVersion() );

        // draw the NPE.
        project.getId();
    }
4647#public void testEmptyConstructor()
    {
        MavenProject project = new MavenProject();

        assertEquals( MavenProject.EMPTY_PROJECT_GROUP_ID + ":" + MavenProject.EMPTY_PROJECT_ARTIFACT_ID + ":jar:"
                        + MavenProject.EMPTY_PROJECT_VERSION, project.getId() );
    }
4648#public void testClone()
        throws Exception
    {
        File f = getFileForClasspathResource( "canonical-pom.xml" );
        MavenProject projectToClone = getProject( f );

        MavenProject clonedProject = (MavenProject) projectToClone.clone();
        assertEquals( "maven-core", clonedProject.getArtifactId() );
        Map<?, ?> clonedMap = clonedProject.getManagedVersionMap();
        assertNotNull( "ManagedVersionMap not copied", clonedMap );
        assertTrue( "ManagedVersionMap is not empty", clonedMap.isEmpty() );
    }
4649#public void testCloneWithDependencyManagement()
        throws Exception
    {
        File f = getFileForClasspathResource( "dependencyManagement-pom.xml" );
        MavenProject projectToClone = getProjectWithDependencies( f );
        DependencyManagement dep = projectToClone.getDependencyManagement();
        assertNotNull( "No dependencyManagement", dep );
        List<?> list = dep.getDependencies();
        assertNotNull( "No dependencies", list );
        assertTrue( "Empty dependency list", !list.isEmpty() );

        Map<?, ?> map = projectToClone.getManagedVersionMap();
        assertNotNull( "No ManagedVersionMap", map );
        assertTrue( "ManagedVersionMap is empty", !map.isEmpty() );

        MavenProject clonedProject = (MavenProject) projectToClone.clone();
        assertEquals( "maven-core", clonedProject.getArtifactId() );
        Map<?, ?> clonedMap = clonedProject.getManagedVersionMap();
        assertNotNull( "ManagedVersionMap not copied", clonedMap );
        assertTrue( "ManagedVersionMap is empty", !clonedMap.isEmpty() );
        assertTrue( "ManagedVersionMap does not contain test key",
                    clonedMap.containsKey( "maven-test:maven-test-b:jar" ) );
    }
4650#public void testGetModulePathAdjustment()
        throws IOException
    {
        Model moduleModel = new Model();

        MavenProject module = new MavenProject( moduleModel );
        module.setFile( new File( "module-dir/pom.xml" ) );

        Model parentModel = new Model();
        parentModel.addModule( "../module-dir" );

        MavenProject parent = new MavenProject( parentModel );
        parent.setFile( new File( "parent-dir/pom.xml" ) );

        String pathAdjustment = parent.getModulePathAdjustment( module );

        assertEquals( "..", pathAdjustment );
    }
4651#public void testCloneWithDistributionManagement() throws Exception
    {
        
        File f = getFileForClasspathResource( "distributionManagement-pom.xml" );
        MavenProject projectToClone = getProject( f );

        MavenProject clonedProject = (MavenProject) projectToClone.clone();
        assertNotNull( "clonedProject - distributionManagement", clonedProject.getDistributionManagementArtifactRepository() );
    }
4652#public void testCloneWithActiveProfile() throws Exception
    {

        File f = getFileForClasspathResource( "withActiveByDefaultProfile-pom.xml" );
        MavenProject projectToClone = getProject( f );
        List<Profile> activeProfilesOrig = projectToClone.getActiveProfiles();

        assertEquals( "Expecting 1 active profile", 1, activeProfilesOrig.size() );

        MavenProject clonedProject = (MavenProject) projectToClone.clone();

        List<Profile> activeProfilesClone = clonedProject.getActiveProfiles();

        assertEquals( "Expecting 1 active profile", 1, activeProfilesClone.size() );

        assertNotSame( "The list of active profiles should have been cloned too but is same", activeProfilesOrig,
                       activeProfilesClone );
    }
4653#protected String getProjectsDirectory()
    {
        return "src/test/projects/project-builder";
    }
4654#public void testSystemScopeDependencyIsPresentInTheCompileClasspathElements()
        throws Exception
    {
        File pom = getProject( "it0063" );
        
        Properties eps = new Properties();
        eps.setProperty( "jre.home", new File( pom.getParentFile(), "jdk/jre" ).getPath() );        
        
        MavenSession session = createMavenSession( pom, eps );
        MavenProject project = session.getCurrentProject();
        
        // Here we will actually not have any artifacts because the ProjectDependenciesResolver is not involved here. So
        // right now it's not valid to ask for artifacts unless plugins require the artifacts.
        
        List<String> elements = project.getCompileClasspathElements();
    }
4655#public List<ArtifactRepository> createArtifactRepositories( List<Repository> pomRepositories,
                                                                List<ArtifactRepository> externalRepositories,
                                                                ProjectBuildingRequest request )
    {
        if ( externalRepositories != null )
        {
            return externalRepositories;
        }
        else
        {
            return new ArrayList<ArtifactRepository>();
        }
    }
4656#public ProjectRealmCache.CacheRecord createProjectRealm( MavenProject proejct,
                                                             Model model, ProjectBuildingRequest request )
    {
        return new ProjectRealmCache.CacheRecord( null, null );
    }
4657#public void selectProjectRealm( MavenProject project )
    {
    }
4658#protected void setUp()
        throws Exception
    {
        testDirectory = new File( getBasedir(), BASE_POM_DIR );
        new File( getBasedir(), BASE_MIXIN_DIR );
        projectBuilder = (DefaultProjectBuilder) lookup( ProjectBuilder.class );
        repositorySystem = lookup( RepositorySystem.class );
    }
4659#@Override
    protected void tearDown()
        throws Exception
    {
        projectBuilder = null;

        super.tearDown();
    }
4660#/**
     * Will throw exception if url is empty. MNG-4050 
     *
     * @throws Exception
     */
 
    public void testEmptyUrl()
        throws Exception
    {
        buildPom( "empty-distMng-repo-url" );
    }
4661#/**
     * Tests that modules is not overriden by profile
     * 
     * @throws Exception
     */
    /* MNG-786*/
    public void testProfileModules()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "profile-module", "a" );
        assertEquals( "test-prop", pom.getValue( "properties[1]/b" ) );// verifies profile applied
        assertEquals( 4, ( (List<?>) pom.getValue( "modules" ) ).size() );
        assertEquals( "module-2", pom.getValue( "modules[1]" ) );
        assertEquals( "module-1", pom.getValue( "modules[2]" ) );
        assertEquals( "module-3", pom.getValue( "modules[3]" ) );
        assertEquals( "module-4", pom.getValue( "modules[4]" ) );
    }
4662#/**
     * Will throw exception if doesn't find parent(s) in build
     *
     * @throws Exception
     */
    public void testParentInheritance()
        throws Exception
    {
        buildPom( "parent-inheritance/sub" );
    }
4663#/*MNG-3995*/
    public void testExecutionConfigurationJoin()
       throws Exception
    {
        PomTestWrapper pom = buildPom( "execution-configuration-join" );
        assertEquals( 2, ( (List<?>) pom.getValue( "build/plugins[1]/executions[1]/configuration[1]/fileset[1]" ) ).size() );
    }
4664#/*MNG-3803*/
    public void testPluginConfigProperties()
       throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-config-properties" );
        assertEquals( "my.property", pom.getValue( "build/plugins[1]/configuration[1]/systemProperties[1]/property[1]/name" ) );
    }
4665#/*MNG-3900*/
    public void testProfilePropertiesInterpolation()
    	throws Exception 
    {
    	PomTestWrapper pom = buildPom( "profile-properties-interpolation", "interpolation-profile" );
        assertEquals( "PASSED", pom.getValue( "properties[1]/test" ) );
        assertEquals( "PASSED", pom.getValue( "properties[1]/property" ) );
    }
4666#// Some better conventions for the test poms needs to be created and each of these tests
    // that represent a verification of a specification item needs to be a couple lines at most.
    // The expressions help a lot, but we need a clean to pick up a directory of POMs, automatically load
    // them into a resolver, create the expression to extract the data to validate the Model, and the URI
    // to validate the properties. We also need a way to navigate from the Tex specification documents to
    // the test in question and vice versa. A little Eclipse plugin would do the trick.
    public void testThatExecutionsWithoutIdsAreMergedAndTheChildWins()
        throws Exception
    {
        PomTestWrapper tester = buildPom( "micromailer" );
        assertModelEquals( tester, "child-descriptor", "build/plugins[1]/executions[1]/goals[1]" );
    }
4667#/*MNG-
    public void testDependencyScope()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "dependency-scope/sub" );

    }

    /*MNG- 4010*/
    public void testDuplicateExclusionsDependency()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "duplicate-exclusions-dependency/sub" );
        assertEquals( 1, ( (List<?>) pom.getValue( "dependencies[1]/exclusions" ) ).size() );

    }
4668#/*MNG- 4008*/
    public void testMultipleFilters()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "multiple-filters" );
        assertEquals( 4, ( (List<?>) pom.getValue( "build/filters" ) ).size() );

    }
4669#/** MNG-4005: postponed to 3.1
    public void testValidationErrorUponNonUniqueDependencyKey()
        throws Exception
    {
        try
        {
            buildPom( "unique-dependency-key/deps" );
            fail( "Non-unique dependency keys did not cause validation error" );
        }
        catch ( ProjectBuildingException e )
        {
            // expected
        }
    }

    public void testValidationErrorUponNonUniqueDependencyManagementKey()
        throws Exception
    {
        try
        {
            buildPom( "unique-dependency-key/dep-mngt" );
            fail( "Non-unique dependency keys did not cause validation error" );
        }
        catch ( ProjectBuildingException e )
        {
            // expected
        }
    }

    public void testValidationErrorUponNonUniqueDependencyKeyInProfile()
        throws Exception
    {
        try
        {
            buildPom( "unique-dependency-key/deps-in-profile" );
            fail( "Non-unique dependency keys did not cause validation error" );
        }
        catch ( ProjectBuildingException e )
        {
            // expected
        }
    }

    public void testValidationErrorUponNonUniqueDependencyManagementKeyInProfile()
        throws Exception
    {
        try
        {
            buildPom( "unique-dependency-key/dep-mngt-in-profile" );
            fail( "Non-unique dependency keys did not cause validation error" );
        }
        catch ( ProjectBuildingException e )
        {
            // expected
        }
    }
    */

    public void testDuplicateDependenciesCauseLastDeclarationToBePickedInLenientMode()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "unique-dependency-key/deps", true, null );
        assertEquals( 1, ( (List<?>) pom.getValue( "dependencies" ) ).size() );
        assertEquals( "0.2", pom.getValue( "dependencies[1]/version" ) );
    }
4670#/* MNG-3567*/
    public void testParentInterpolation()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "parent-interpolation/sub" );
        pom = new PomTestWrapper( pom.getMavenProject().getParent() );
        assertEquals( "1.3.0-SNAPSHOT", pom.getValue( "build/plugins[1]/version" ) );
    }
4671#/*
    public void testMaven()
        throws Exception
    {
        PomTestWrapper pom =  buildPomFromMavenProject( "maven-build/sub/pom.xml", null );
  
        for( String s: pom.getMavenProject().getTestClasspathElements() ) 
        {
            System.out.println( s );
        }
        
    }
    */
    
    /* MNG-3567*/
    public void testPluginManagementInherited()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "pluginmanagement-inherited/sub" );
        assertEquals( "1.0-alpha-21", pom.getValue( "build/plugins[1]/version" ) );
    }
4672#/* MNG-2174*/
    public void testPluginManagementDependencies()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-management-dependencies/sub", "test" );
        assertEquals( "1.0-alpha-21", pom.getValue( "build/plugins[1]/version" ) );
        assertEquals( "1.0", pom.getValue( "build/plugins[1]/dependencies[1]/version" ) );
    }
4673#/* MNG-3877*/
    public void testReportingInterpolation()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "reporting-interpolation" );
        assertEquals( createPath( Arrays.asList( System.getProperty( "user.dir" ), "src", "test",
                                                 "resources-project-builder", "reporting-interpolation", "target",
                                                 "site" ) ), pom.getValue( "reporting/outputDirectory" ) );
    }
4674#public void testPluginOrder()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-order" );
        assertEquals( "plexus-component-metadata", pom.getValue( "build/plugins[1]/artifactId" ) );
        assertEquals( "maven-surefire-plugin", pom.getValue( "build/plugins[2]/artifactId" ) );
    }
4675#public void testErroneousJoiningOfDifferentPluginsWithEqualDependencies()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "equal-plugin-deps" );
        assertEquals( "maven-it-plugin-a", pom.getValue( "build/plugins[1]/artifactId" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/plugins[1]/dependencies" ) ).size() );
        assertEquals( "maven-it-plugin-b", pom.getValue( "build/plugins[2]/artifactId" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/plugins[1]/dependencies" ) ).size() );
    }
4676#/** MNG-3821 */
    public void testErroneousJoiningOfDifferentPluginsWithEqualExecutionIds()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "equal-plugin-exec-ids" );
        assertEquals( "maven-it-plugin-a", pom.getValue( "build/plugins[1]/artifactId" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
        assertEquals( "maven-it-plugin-b", pom.getValue( "build/plugins[2]/artifactId" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
        assertEquals( "maven-it-plugin-a", pom.getValue( "reporting/plugins[1]/artifactId" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "reporting/plugins[1]/reportSets" ) ).size() );
        assertEquals( "maven-it-plugin-b", pom.getValue( "reporting/plugins[2]/artifactId" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "reporting/plugins[1]/reportSets" ) ).size() );
    }
4677#/** MNG-3998 */
    public void testExecutionConfiguration()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "execution-configuration" );
        assertEquals( 2, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
        assertEquals( "src/main/mdo/nexus.xml",
                      ( pom.getValue( "build/plugins[1]/executions[1]/configuration[1]/model" ) ) );
        assertEquals( "src/main/mdo/security.xml",
                      ( pom.getValue( "build/plugins[1]/executions[2]/configuration[1]/model" ) ) );
    }
4678#/*
    public void testPluginConfigDuplicate()
    throws Exception
{
    PomTestWrapper pom = buildPom( "plugin-config-duplicate/dup" );
} 
*/


    public void testSingleConfigurationInheritance()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "single-configuration-inheritance" );

        assertEquals( 2, ( (List<?>) pom.getValue( "build/plugins[1]/executions[1]/configuration[1]/rules" ) ).size() );
        assertEquals( "2.0.6",
                      pom.getValue( "build/plugins[1]/executions[1]/configuration[1]/rules[1]/requireMavenVersion[1]/version" ) );
        assertEquals( "[1.4,)",
                      pom.getValue( "build/plugins[1]/executions[1]/configuration[1]/rules[1]/requireJavaVersion[1]/version" ) );
    }
4679#public void testConfigWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "config-with-plugin-mng" );
        assertEquals( 2, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
        assertEquals( "src/main/mdo/security.xml", pom.getValue( "build/plugins[1]/executions[2]/configuration[1]/model" ) );
        assertEquals( "1.0.8", pom.getValue( "build/plugins[1]/executions[1]/configuration[1]/version" ) );
    }
4680#/** MNG-3965 */
    public void testExecutionConfigurationSubcollections()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "execution-configuration-subcollections" );
        assertEquals( 2, ( (List<?>) pom.getValue( "build/plugins[1]/executions[1]/configuration[1]/rules[1]/bannedDependencies" ) ).size() );
    }
4681#/** MNG-3985 */
    public void testMultipleRepositories()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "multiple-repos/sub" );
        assertEquals( 3, ( (List<?>) pom.getValue( "repositories" ) ).size() );
    }
4682#/** MNG-3965 */
    public void testMultipleExecutionIds()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "dual-execution-ids/sub" );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
    }
4683#/** MNG-3997 */
    public void testConsecutiveEmptyElements()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "consecutive_empty_elements" );
    }
4684#public void testOrderOfGoalsFromPluginExecutionWithoutPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-goals-order/wo-plugin-mngt" );
        assertEquals( 5, ( (List<?>) pom.getValue( "build/plugins[1]/executions[1]/goals" ) ).size() );
        assertEquals( "b", pom.getValue( "build/plugins[1]/executions[1]/goals[1]" ) );
        assertEquals( "a", pom.getValue( "build/plugins[1]/executions[1]/goals[2]" ) );
        assertEquals( "d", pom.getValue( "build/plugins[1]/executions[1]/goals[3]" ) );
        assertEquals( "c", pom.getValue( "build/plugins[1]/executions[1]/goals[4]" ) );
        assertEquals( "e", pom.getValue( "build/plugins[1]/executions[1]/goals[5]" ) );
    }
4685#/* MNG-3886*/
    public void testOrderOfGoalsFromPluginExecutionWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-goals-order/w-plugin-mngt" );
        assertEquals( 5, ( (List<?>) pom.getValue( "build/plugins[1]/executions[1]/goals" ) ).size() );
        assertEquals( "b", pom.getValue( "build/plugins[1]/executions[1]/goals[1]" ) );
        assertEquals( "a", pom.getValue( "build/plugins[1]/executions[1]/goals[2]" ) );
        assertEquals( "d", pom.getValue( "build/plugins[1]/executions[1]/goals[3]" ) );
        assertEquals( "c", pom.getValue( "build/plugins[1]/executions[1]/goals[4]" ) );
        assertEquals( "e", pom.getValue( "build/plugins[1]/executions[1]/goals[5]" ) );
    }
4686#public void testOrderOfPluginExecutionsWithoutPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-order/wo-plugin-mngt" );
        assertEquals( 5, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
        assertEquals( "b", pom.getValue( "build/plugins[1]/executions[1]/id" ) );
        assertEquals( "a", pom.getValue( "build/plugins[1]/executions[2]/id" ) );
        assertEquals( "d", pom.getValue( "build/plugins[1]/executions[3]/id" ) );
        assertEquals( "c", pom.getValue( "build/plugins[1]/executions[4]/id" ) );
        assertEquals( "e", pom.getValue( "build/plugins[1]/executions[5]/id" ) );
    }
4687#/* MNG-3887 */
    public void testOrderOfPluginExecutionsWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-order/w-plugin-mngt" );
        assertEquals( 5, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
        assertEquals( "b", pom.getValue( "build/plugins[1]/executions[1]/id" ) );
        assertEquals( "a", pom.getValue( "build/plugins[1]/executions[2]/id" ) );
        assertEquals( "d", pom.getValue( "build/plugins[1]/executions[3]/id" ) );
        assertEquals( "c", pom.getValue( "build/plugins[1]/executions[4]/id" ) );
        assertEquals( "e", pom.getValue( "build/plugins[1]/executions[5]/id" ) );
    }
4688#public void testMergeOfPluginExecutionsWhenChildInheritsPluginVersion()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-merging-wo-version/sub" );
        assertEquals( 4, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
    }
4689#/* MNG-3943*/
    public void testMergeOfPluginExecutionsWhenChildAndParentUseDifferentPluginVersions()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-merging-version-insensitive/sub" );
        assertEquals( 4, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
    }
4690#public void testInterpolationWithXmlMarkup()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "xml-markup-interpolation" );
        assertEquals( "<?xml version='1.0'?>Tom&Jerry", pom.getValue( "properties/xmlTest" ) );
    }
4691#/* MNG-3925 */
    public void testOrderOfMergedPluginExecutionsWithoutPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "merged-plugin-exec-order/wo-plugin-mngt/sub" );
        assertEquals( 5, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
        assertEquals( "parent-1", pom.getValue( "build/plugins[1]/executions[1]/goals[1]" ) );
        assertEquals( "parent-2", pom.getValue( "build/plugins[1]/executions[2]/goals[1]" ) );
        assertEquals( "child-default", pom.getValue( "build/plugins[1]/executions[3]/goals[1]" ) );
        assertEquals( "child-1", pom.getValue( "build/plugins[1]/executions[4]/goals[1]" ) );
        assertEquals( "child-2", pom.getValue( "build/plugins[1]/executions[5]/goals[1]" ) );
    }
4692#public void testOrderOfMergedPluginExecutionsWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "merged-plugin-exec-order/w-plugin-mngt/sub" );
        assertEquals( 5, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
        assertEquals( "parent-1", pom.getValue( "build/plugins[1]/executions[1]/goals[1]" ) );
        assertEquals( "parent-2", pom.getValue( "build/plugins[1]/executions[2]/goals[1]" ) );
        assertEquals( "child-default", pom.getValue( "build/plugins[1]/executions[3]/goals[1]" ) );
        assertEquals( "child-1", pom.getValue( "build/plugins[1]/executions[4]/goals[1]" ) );
        assertEquals( "child-2", pom.getValue( "build/plugins[1]/executions[5]/goals[1]" ) );
    }
4693#/* MNG-3984*/
    public void testDifferentContainersWithSameId()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "join-different-containers-same-id" );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/plugins[1]/executions[1]/goals" ) ).size() );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/pluginManagement/plugins[@artifactId='maven-it-plugin-b']/executions[1]/goals" ) ).size() );
    }
4694#/* MNG-3937*/
    public void testOrderOfMergedPluginExecutionGoalsWithoutPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "merged-plugin-exec-goals-order/wo-plugin-mngt/sub" );

        assertEquals( 5, ( (List<?>) pom.getValue( "build/plugins[1]/executions[1]/goals" ) ).size() );
        assertEquals( "child-a", pom.getValue( "build/plugins[1]/executions[1]/goals[1]" ) );
        assertEquals( "merged", pom.getValue( "build/plugins[1]/executions[1]/goals[2]" ) );
        assertEquals( "child-b", pom.getValue( "build/plugins[1]/executions[1]/goals[3]" ) );
        assertEquals( "parent-b", pom.getValue( "build/plugins[1]/executions[1]/goals[4]" ) );
        assertEquals( "parent-a", pom.getValue( "build/plugins[1]/executions[1]/goals[5]" ) );
    }
4695#public void testOrderOfMergedPluginExecutionGoalsWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "merged-plugin-exec-goals-order/w-plugin-mngt/sub" );
        assertEquals( 5, ( (List<?>) pom.getValue( "build/plugins[1]/executions[1]/goals" ) ).size() );
        assertEquals( "child-a", pom.getValue( "build/plugins[1]/executions[1]/goals[1]" ) );
        assertEquals( "merged", pom.getValue( "build/plugins[1]/executions[1]/goals[2]" ) );
        assertEquals( "child-b", pom.getValue( "build/plugins[1]/executions[1]/goals[3]" ) );
        assertEquals( "parent-b", pom.getValue( "build/plugins[1]/executions[1]/goals[4]" ) );
        assertEquals( "parent-a", pom.getValue( "build/plugins[1]/executions[1]/goals[5]" ) );
    }
4696#/*MNG-3938*/
    public void testOverridingOfInheritedPluginExecutionsWithoutPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-merging/wo-plugin-mngt/sub" );
        assertEquals( 2, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
        assertEquals( "child-default", pom.getValue( "build/plugins[1]/executions[@id='default']/phase" ) );
        assertEquals( "child-non-default", pom.getValue( "build/plugins[1]/executions[@id='non-default']/phase" ) );
    }
4697#/* MNG-3938 */
    public void testOverridingOfInheritedPluginExecutionsWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-merging/w-plugin-mngt/sub" );
        assertEquals( 2, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
        assertEquals( "child-default", pom.getValue( "build/plugins[1]/executions[@id='default']/phase" ) );
        assertEquals( "child-non-default", pom.getValue( "build/plugins[1]/executions[@id='non-default']/phase" ) );
    }
4698#/* MNG-3906*/
    public void testOrderOfMergedPluginDependenciesWithoutPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "merged-plugin-class-path-order/wo-plugin-mngt/sub" );

        assertEquals( 5, ( (List<?>) pom.getValue( "build/plugins[1]/dependencies" ) ).size() );
        assertNotNull( pom.getValue( "build/plugins[1]/dependencies[1]" ) );
        assertEquals( "c", pom.getValue( "build/plugins[1]/dependencies[1]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[1]/version" ) );
        assertEquals( "a", pom.getValue( "build/plugins[1]/dependencies[2]/artifactId" ) );
        assertEquals( "2", pom.getValue( "build/plugins[1]/dependencies[2]/version" ) );
        assertEquals( "b", pom.getValue( "build/plugins[1]/dependencies[3]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[3]/version" ) );
        assertEquals( "e", pom.getValue( "build/plugins[1]/dependencies[4]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[4]/version" ) );
        assertEquals( "d", pom.getValue( "build/plugins[1]/dependencies[5]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[5]/version" ) );
    }
4699#public void testOrderOfMergedPluginDependenciesWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "merged-plugin-class-path-order/w-plugin-mngt/sub" );
        assertEquals( 5, ( (List<?>) pom.getValue( "build/plugins[1]/dependencies" ) ).size() );
        assertEquals( "c", pom.getValue( "build/plugins[1]/dependencies[1]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[1]/version" ) );
        assertEquals( "a", pom.getValue( "build/plugins[1]/dependencies[2]/artifactId" ) );
        assertEquals( "2", pom.getValue( "build/plugins[1]/dependencies[2]/version" ) );
        assertEquals( "b", pom.getValue( "build/plugins[1]/dependencies[3]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[3]/version" ) );
        assertEquals( "e", pom.getValue( "build/plugins[1]/dependencies[4]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[4]/version" ) );
        assertEquals( "d", pom.getValue( "build/plugins[1]/dependencies[5]/artifactId" ) );
        assertEquals( "1", pom.getValue( "build/plugins[1]/dependencies[5]/version" ) );
    }
4700#public void testInterpolationOfNestedBuildDirectories()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "nested-build-dir-interpolation" );
        assertEquals( new File( pom.getBasedir(), "target/classes/dir0" ),
                      new File( (String) pom.getValue( "properties/dir0" ) ) );
        assertEquals( new File( pom.getBasedir(), "src/test/dir1" ),
                      new File( (String) pom.getValue( "properties/dir1" ) ) );
        assertEquals( new File( pom.getBasedir(), "target/site/dir2" ),
                      new File( (String) pom.getValue( "properties/dir2" ) ) );
    }
4701#public void testAppendArtifactIdOfChildToInheritedUrls()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "url-inheritance/sub" );
        assertEquals( "http://parent.url/child", pom.getValue( "url" ) );
        assertEquals( "http://parent.url/org", pom.getValue( "organization/url" ) );
        assertEquals( "http://parent.url/license.txt", pom.getValue( "licenses[1]/url" ) );
        assertEquals( "http://parent.url/viewvc/child", pom.getValue( "scm/url" ) );
        assertEquals( "http://parent.url/scm/child", pom.getValue( "scm/connection" ) );
        assertEquals( "https://parent.url/scm/child", pom.getValue( "scm/developerConnection" ) );
        assertEquals( "http://parent.url/issues", pom.getValue( "issueManagement/url" ) );
        assertEquals( "http://parent.url/ci", pom.getValue( "ciManagement/url" ) );
        assertEquals( "http://parent.url/dist", pom.getValue( "distributionManagement/repository/url" ) );
        assertEquals( "http://parent.url/snaps", pom.getValue( "distributionManagement/snapshotRepository/url" ) );
        assertEquals( "http://parent.url/site/child", pom.getValue( "distributionManagement/site/url" ) );
        assertEquals( "http://parent.url/download", pom.getValue( "distributionManagement/downloadUrl" ) );
    }
4702#/* MNG-3846*/
    public void testAppendArtifactIdOfParentAndChildToInheritedUrls()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "url-inheritance/another-parent/sub" );
        assertEquals( "http://parent.url/ap/child", pom.getValue( "url" ) );
        assertEquals( "http://parent.url/org", pom.getValue( "organization/url" ) );
        assertEquals( "http://parent.url/license.txt", pom.getValue( "licenses[1]/url" ) );
        assertEquals( "http://parent.url/viewvc/ap/child", pom.getValue( "scm/url" ) );
        assertEquals( "http://parent.url/scm/ap/child", pom.getValue( "scm/connection" ) );
        assertEquals( "https://parent.url/scm/ap/child", pom.getValue( "scm/developerConnection" ) );
        assertEquals( "http://parent.url/issues", pom.getValue( "issueManagement/url" ) );
        assertEquals( "http://parent.url/ci", pom.getValue( "ciManagement/url" ) );
        assertEquals( "http://parent.url/dist", pom.getValue( "distributionManagement/repository/url" ) );
        assertEquals( "http://parent.url/snaps", pom.getValue( "distributionManagement/snapshotRepository/url" ) );
        assertEquals( "http://parent.url/site/ap/child", pom.getValue( "distributionManagement/site/url" ) );
        assertEquals( "http://parent.url/download", pom.getValue( "distributionManagement/downloadUrl" ) );
    }
4703#//*/

    public void testNonInheritedElementsInSubtreesOverriddenByChild()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "limited-inheritance/child" );
        assertEquals( null, pom.getValue( "organization/url" ) );
        assertEquals( null, pom.getValue( "issueManagement/system" ) );
        assertEquals( 0, ( (List<?>) pom.getValue( "ciManagement/notifiers" ) ).size() );
        assertEquals( "child-distros", pom.getValue( "distributionManagement/repository/id" ) );
        assertEquals( "ssh://child.url/distros", pom.getValue( "distributionManagement/repository/url" ) );
        assertEquals( null, pom.getValue( "distributionManagement/repository/name" ) );
        assertEquals( true, pom.getValue( "distributionManagement/repository/uniqueVersion" ) );
        assertEquals( "default", pom.getValue( "distributionManagement/repository/layout" ) );
        assertEquals( "child-snaps", pom.getValue( "distributionManagement/snapshotRepository/id" ) );
        assertEquals( "ssh://child.url/snaps", pom.getValue( "distributionManagement/snapshotRepository/url" ) );
        assertEquals( null, pom.getValue( "distributionManagement/snapshotRepository/name" ) );
        assertEquals( true, pom.getValue( "distributionManagement/snapshotRepository/uniqueVersion" ) );
        assertEquals( "default", pom.getValue( "distributionManagement/snapshotRepository/layout" ) );
        assertEquals( "child-site", pom.getValue( "distributionManagement/site/id" ) );
        assertEquals( "scp://child.url/site", pom.getValue( "distributionManagement/site/url" ) );
        assertEquals( null, pom.getValue( "distributionManagement/site/name" ) );
    }
4704#public void testXmlTextCoalescing()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "xml-coalesce-text" );
        assertEquals( "A  Test  Project Property", pom.getValue( "properties/prop0" ) );
        assertEquals( "That's a test!", pom.getValue( "properties/prop1" ) );
        assertEquals( 32 * 1024,
                      pom.getValue( "properties/prop2" ).toString().trim().replaceAll( "[\n\r]", "" ).length() );
    }
4705#public void testFullInterpolationOfNestedExpressions()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "full-interpolation" );
        for ( int i = 0; i < 24; i++ )
        {
            String index = ( ( i < 10 ) ? "0" : "" ) + i;
            assertEquals( "PASSED", pom.getValue( "properties/property" + index ) );
        }
    }
4706#public void testInterpolationOfLegacyExpressionsThatDontIncludeTheProjectPrefix()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "unprefixed-expression-interpolation/child" );

        assertEquals( pom.getBasedir(), new File( pom.getValue( "properties/projectDir" ).toString() ) );

        assertEquals( "org.apache.maven.its.mng3831.child", pom.getValue( "properties/projectGroupId" ) );
        assertEquals( "child", pom.getValue( "properties/projectArtifactId" ) );
        assertEquals( "2.0-alpha-1", pom.getValue( "properties/projectVersion" ) );
        assertEquals( "jar", pom.getValue( "properties/projectPackaging" ) );

        assertEquals( "child-name", pom.getValue( "properties/projectName" ) );
        assertEquals( "child-desc", pom.getValue( "properties/projectDesc" ) );
        assertEquals( "http://child.org/", pom.getValue( "properties/projectUrl" ) );
        assertEquals( "2008", pom.getValue( "properties/projectYear" ) );
        assertEquals( "child-org-name", pom.getValue( "properties/projectOrgName" ) );

        assertEquals( "2.0.0", pom.getValue( "properties/projectPrereqMvn" ) );
        assertEquals( "http://scm.org/", pom.getValue( "properties/projectScmUrl" ) );
        assertEquals( "http://issue.org/", pom.getValue( "properties/projectIssueUrl" ) );
        assertEquals( "http://ci.org/", pom.getValue( "properties/projectCiUrl" ) );
        assertEquals( "child-dist-repo", pom.getValue( "properties/projectDistRepoName" ) );
        assertEquals( "http://dist.org/", pom.getValue( "properties/projectDistRepoUrl" ) );
        assertEquals( "http://site.org/", pom.getValue( "properties/projectDistSiteUrl" ) );

        assertEquals( "org.apache.maven.its.mng3831", pom.getValue( "properties/parentGroupId" ) );
        assertEquals( "parent", pom.getValue( "properties/parentArtifactId" ) );
        assertEquals( "1.0", pom.getValue( "properties/parentVersion" ) );

        assertTrue( pom.getValue( "properties/projectBuildOut" ).toString().endsWith( "bin" ) );
        assertTrue( pom.getValue( "properties/projectSiteOut" ).toString().endsWith( "doc" ) );
    }
4707#public void testInterpolationWithBasedirAlignedDirectories()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "basedir-aligned-interpolation" );
        assertEquals( new File( pom.getBasedir(), "src/main/java" ),
                      new File( pom.getValue( "properties/buildMainSrc" ).toString() ) );
        assertEquals( new File( pom.getBasedir(), "src/test/java" ),
                      new File( pom.getValue( "properties/buildTestSrc" ).toString() ) );
        assertEquals( new File( pom.getBasedir(), "src/main/scripts" ),
                      new File( pom.getValue( "properties/buildScriptSrc" ).toString() ) );
        assertEquals( new File( pom.getBasedir(), "target" ),
                      new File( pom.getValue( "properties/buildOut" ).toString() ) );
        assertEquals( new File( pom.getBasedir(), "target/classes" ),
                      new File( pom.getValue( "properties/buildMainOut" ).toString() ) );
        assertEquals( new File( pom.getBasedir(), "target/test-classes" ),
                      new File( pom.getValue( "properties/buildTestOut" ).toString() ) );
        assertEquals( new File( pom.getBasedir(), "target/site" ),
                      new File( pom.getValue( "properties/siteOut" ).toString() ) );
    }
4708#/* MNG-3944*/
    public void testInterpolationOfBasedirInPomWithUnusualName()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "basedir-interpolation/pom-with-unusual-name.xml" );
        assertEquals( pom.getBasedir(), new File( pom.getValue( "properties/prop0" ).toString() ) );
        assertEquals( pom.getBasedir(), new File( pom.getValue( "properties/prop1" ).toString() ) );
    }
4709#/* MNG-3979 */
    public void testJoiningOfContainersWhenChildHasEmptyElements()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "id-container-joining-with-empty-elements/sub" );
        assertNotNull( pom );
    }
4710#public void testOrderOfPluginConfigurationElementsWithoutPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-config-order/wo-plugin-mngt" );
        assertEquals( "one", pom.getValue( "build/plugins[1]/configuration/stringParams/stringParam[1]" ) );
        assertEquals( "two", pom.getValue( "build/plugins[1]/configuration/stringParams/stringParam[2]" ) );
        assertEquals( "three", pom.getValue( "build/plugins[1]/configuration/stringParams/stringParam[3]" ) );
        assertEquals( "four", pom.getValue( "build/plugins[1]/configuration/stringParams/stringParam[4]" ) );
    }
4711#/* MNG-3827*/
    public void testOrderOfPluginConfigurationElementsWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-config-order/w-plugin-mngt" );
        assertEquals( "one", pom.getValue( "build/plugins[1]/configuration/stringParams/stringParam[1]" ) );
        assertEquals( "two", pom.getValue( "build/plugins[1]/configuration/stringParams/stringParam[2]" ) );
        assertEquals( "three", pom.getValue( "build/plugins[1]/configuration/stringParams/stringParam[3]" ) );
        assertEquals( "four", pom.getValue( "build/plugins[1]/configuration/stringParams/stringParam[4]" ) );
    }
4712#public void testOrderOfPluginExecutionConfigurationElementsWithoutPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-config-order/wo-plugin-mngt" );
        String prefix = "build/plugins[1]/executions[1]/configuration/";
        assertEquals( "one", pom.getValue( prefix + "stringParams/stringParam[1]" ) );
        assertEquals( "two", pom.getValue( prefix + "stringParams/stringParam[2]" ) );
        assertEquals( "three", pom.getValue( prefix + "stringParams/stringParam[3]" ) );
        assertEquals( "four", pom.getValue( prefix + "stringParams/stringParam[4]" ) );
        assertEquals( "key1", pom.getValue( prefix + "propertiesParam/property[1]/name" ) );
        assertEquals( "key2", pom.getValue( prefix + "propertiesParam/property[2]/name" ) );
    }
4713#/* MNG-3864*/
    public void testOrderOfPluginExecutionConfigurationElementsWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-config-order/w-plugin-mngt" );
        String prefix = "build/plugins[1]/executions[1]/configuration/";
        assertEquals( "one", pom.getValue( prefix + "stringParams/stringParam[1]" ) );
        assertEquals( "two", pom.getValue( prefix + "stringParams/stringParam[2]" ) );
        assertEquals( "three", pom.getValue( prefix + "stringParams/stringParam[3]" ) );
        assertEquals( "four", pom.getValue( prefix + "stringParams/stringParam[4]" ) );
        assertEquals( "key1", pom.getValue( prefix + "propertiesParam/property[1]/name" ) );
        assertEquals( "key2", pom.getValue( prefix + "propertiesParam/property[2]/name" ) );
    }
4714#/* MNG-3836*/
    public void testMergeOfInheritedPluginConfiguration()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-config-merging/child" );

        String prefix = "build/plugins[1]/configuration/";
        assertEquals( "PASSED", pom.getValue( prefix + "propertiesFile" ) );
        assertEquals( "PASSED", pom.getValue( prefix + "parent" ) );
        assertEquals( "PASSED-1", pom.getValue( prefix + "stringParams/stringParam[1]" ) );
        assertEquals( "PASSED-3", pom.getValue( prefix + "stringParams/stringParam[2]" ) );
        assertEquals( "PASSED-2", pom.getValue( prefix + "stringParams/stringParam[3]" ) );
        assertEquals( "PASSED-4", pom.getValue( prefix + "stringParams/stringParam[4]" ) );
        assertEquals( "PASSED-1", pom.getValue( prefix + "listParam/listParam[1]" ) );
        assertEquals( "PASSED-3", pom.getValue( prefix + "listParam/listParam[2]" ) );
        assertEquals( "PASSED-2", pom.getValue( prefix + "listParam/listParam[3]" ) );
        assertEquals( "PASSED-4", pom.getValue( prefix + "listParam/listParam[4]" ) );
    }
4715#/* MNG-2591 */
    public void testAppendOfInheritedPluginConfigurationWithNoProfile()
        throws Exception
    {
        testAppendOfInheritedPluginConfiguration( "no-profile" );
    }
4716#/* MNG-2591*/
    public void testAppendOfInheritedPluginConfigurationWithActiveProfile()
        throws Exception
    {
        testAppendOfInheritedPluginConfiguration( "with-profile" );
    }
4717#private void testAppendOfInheritedPluginConfiguration( String test )
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-config-append/" + test + "/subproject" );
        String prefix = "build/plugins[1]/configuration/";
        assertEquals( "PARENT-1", pom.getValue( prefix + "stringParams/stringParam[1]" ) );
        assertEquals( "PARENT-3", pom.getValue( prefix + "stringParams/stringParam[2]" ) );
        assertEquals( "PARENT-2", pom.getValue( prefix + "stringParams/stringParam[3]" ) );
        assertEquals( "PARENT-4", pom.getValue( prefix + "stringParams/stringParam[4]" ) );
        assertEquals( "CHILD-1", pom.getValue( prefix + "stringParams/stringParam[5]" ) );
        assertEquals( "CHILD-3", pom.getValue( prefix + "stringParams/stringParam[6]" ) );
        assertEquals( "CHILD-2", pom.getValue( prefix + "stringParams/stringParam[7]" ) );
        assertEquals( "CHILD-4", pom.getValue( prefix + "stringParams/stringParam[8]" ) );
        assertEquals( null, pom.getValue( prefix + "stringParams/stringParam[9]" ) );
        assertEquals( "PARENT-1", pom.getValue( prefix + "listParam/listParam[1]" ) );
        assertEquals( "PARENT-3", pom.getValue( prefix + "listParam/listParam[2]" ) );
        assertEquals( "PARENT-2", pom.getValue( prefix + "listParam/listParam[3]" ) );
        assertEquals( "PARENT-4", pom.getValue( prefix + "listParam/listParam[4]" ) );
        assertEquals( "CHILD-1", pom.getValue( prefix + "listParam/listParam[5]" ) );
        assertEquals( "CHILD-3", pom.getValue( prefix + "listParam/listParam[6]" ) );
        assertEquals( "CHILD-2", pom.getValue( prefix + "listParam/listParam[7]" ) );
        assertEquals( "CHILD-4", pom.getValue( prefix + "listParam/listParam[8]" ) );
        assertEquals( null, pom.getValue( prefix + "listParam/listParam[9]" ) );
    }
4718#/* MNG-4000 */
    public void testMultiplePluginExecutionsWithAndWithoutIdsWithoutPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-w-and-wo-id/wo-plugin-mngt" );
        assertEquals( 2, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
        assertEquals( "log-string", pom.getValue( "build/plugins[1]/executions[1]/goals[1]" ) );
        assertEquals( "log-string", pom.getValue( "build/plugins[1]/executions[2]/goals[1]" ) );
    }
4719#public void testMultiplePluginExecutionsWithAndWithoutIdsWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-w-and-wo-id/w-plugin-mngt" );
        assertEquals( 2, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
        assertEquals( "log-string", pom.getValue( "build/plugins[1]/executions[1]/goals[1]" ) );
        assertEquals( "log-string", pom.getValue( "build/plugins[1]/executions[2]/goals[1]" ) );
    }
4720#public void testDependencyOrderWithoutPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "dependency-order/wo-plugin-mngt" );
        assertEquals( 4, ( (List<?>) pom.getValue( "dependencies" ) ).size() );
        assertEquals( "a", pom.getValue( "dependencies[1]/artifactId" ) );
        assertEquals( "c", pom.getValue( "dependencies[2]/artifactId" ) );
        assertEquals( "b", pom.getValue( "dependencies[3]/artifactId" ) );
        assertEquals( "d", pom.getValue( "dependencies[4]/artifactId" ) );
    }
4721#public void testDependencyOrderWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "dependency-order/w-plugin-mngt" );
        assertEquals( 4, ( (List<?>) pom.getValue( "dependencies" ) ).size() );
        assertEquals( "a", pom.getValue( "dependencies[1]/artifactId" ) );
        assertEquals( "c", pom.getValue( "dependencies[2]/artifactId" ) );
        assertEquals( "b", pom.getValue( "dependencies[3]/artifactId" ) );
        assertEquals( "d", pom.getValue( "dependencies[4]/artifactId" ) );
    }
4722#public void testBuildDirectoriesUsePlatformSpecificFileSeparator()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "platform-file-separator" );
        assertPathWithNormalizedFileSeparators( pom.getValue( "build/directory" ) );
        assertPathWithNormalizedFileSeparators( pom.getValue( "build/outputDirectory" ) );
        assertPathWithNormalizedFileSeparators( pom.getValue( "build/testOutputDirectory" ) );
        assertPathWithNormalizedFileSeparators( pom.getValue( "build/sourceDirectory" ) );
        assertPathWithNormalizedFileSeparators( pom.getValue( "build/testSourceDirectory" ) );
        assertPathWithNormalizedFileSeparators( pom.getValue( "build/resources[1]/directory" ) );
        assertPathWithNormalizedFileSeparators( pom.getValue( "build/testResources[1]/directory" ) );
        assertPathWithNormalizedFileSeparators( pom.getValue( "build/filters[1]" ) );
        assertPathWithNormalizedFileSeparators( pom.getValue( "reporting/outputDirectory" ) );
    }
4723#/* MNG-4008 */
    public void testMergedFilterOrder()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "merged-filter-order/sub" );

        assertEquals( 7, ( (List<?>) pom.getValue( "build/filters" ) ).size() );
        assertTrue( pom.getValue( "build/filters[1]" ).toString().endsWith( "child-a.properties" ) );
        assertTrue( pom.getValue( "build/filters[2]" ).toString().endsWith( "child-c.properties" ) );
        assertTrue( pom.getValue( "build/filters[3]" ).toString().endsWith( "child-b.properties" ) );
        assertTrue( pom.getValue( "build/filters[4]" ).toString().endsWith( "child-d.properties" ) );
        assertTrue( pom.getValue( "build/filters[5]" ).toString().endsWith( "parent-c.properties" ) );
        assertTrue( pom.getValue( "build/filters[6]" ).toString().endsWith( "parent-b.properties" ) );
        assertTrue( pom.getValue( "build/filters[7]" ).toString().endsWith( "parent-d.properties" ) );
    }
4724#/** MNG-4027*/
    public void testProfileInjectedDependencies()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "profile-injected-dependencies" );
        assertEquals( 4, ( (List<?>) pom.getValue( "dependencies" ) ).size() );
        assertEquals( "a", pom.getValue( "dependencies[1]/artifactId" ) );
        assertEquals( "c", pom.getValue( "dependencies[2]/artifactId" ) );
        assertEquals( "b", pom.getValue( "dependencies[3]/artifactId" ) );
        assertEquals( "d", pom.getValue( "dependencies[4]/artifactId" ) );
    }
4725#/** IT-0021*/
    public void testProfileDependenciesMultipleProfiles()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "profile-dependencies-multiple-profiles", "profile-1", "profile-2" );
        assertEquals(2,  ( (List<?>) pom.getValue( "dependencies" ) ).size() );
    }
4726#public void testDependencyInheritance()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "dependency-inheritance/sub" );
        assertEquals( 1, ( (List<?>) pom.getValue( "dependencies" ) ).size() );
        assertEquals( "4.4", pom.getValue( "dependencies[1]/version" ) );
    }
4727#/** MNG-4034 */
    public void testManagedProfileDependency()
        throws Exception
    {
        PomTestWrapper pom = this.buildPom( "managed-profile-dependency/sub", "maven-core-it" );
        assertEquals( 1, ( (List<?>) pom.getValue( "dependencies" ) ).size() );
        assertEquals( "org.apache.maven.its", pom.getValue( "dependencies[1]/groupId" ) );
        assertEquals( "maven-core-it-support", pom.getValue( "dependencies[1]/artifactId" ) );
        assertEquals( "1.3", pom.getValue( "dependencies[1]/version" ) );
        assertEquals( "runtime", pom.getValue( "dependencies[1]/scope" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "dependencies[1]/exclusions" ) ).size() );
        assertEquals( "commons-lang", pom.getValue( "dependencies[1]/exclusions[1]/groupId" ) );
    }
4728#/** MNG-4040 */
    public void testProfileModuleInheritance()
        throws Exception
    {
        PomTestWrapper pom = this.buildPom( "profile-module-inheritance/sub", "dist" );
        assertEquals( 0, ( (List<?>) pom.getValue( "modules" ) ).size() );
    }
4729#/** MNG-3621 */
    public void testUncPath()
        throws Exception
    {
        PomTestWrapper pom = this.buildPom( "unc-path/sub" );
        assertEquals( "file:////host/site/test-child", pom.getValue( "distributionManagement/site/url" ) );
    }
4730#/** MNG-2006 */
    public void testUrlAppendWithChildPathAdjustment()
        throws Exception
    {
        PomTestWrapper pom = this.buildPom( "url-append/child" );
        assertEquals( "http://project.url/child", pom.getValue( "url" ) );
        assertEquals( "http://viewvc.project.url/child", pom.getValue( "scm/url" ) );
        assertEquals( "http://scm.project.url/child", pom.getValue( "scm/connection" ) );
        assertEquals( "https://scm.project.url/child", pom.getValue( "scm/developerConnection" ) );
        assertEquals( "http://site.project.url/child", pom.getValue( "distributionManagement/site/url" ) );
    }
4731#/** MNG-0479 */
    public void testRepoInheritance()
        throws Exception
    {
        PomTestWrapper pom = this.buildPom( "repo-inheritance" );
        assertEquals( 1, ( (List<?>) pom.getValue( "repositories" ) ).size() );
        assertEquals( "it0043", pom.getValue( "repositories[1]/name" ) );
    }
4732#public void testEmptyScm()
        throws Exception
    {
        PomTestWrapper pom = this.buildPom( "empty-scm" );
        assertNull( pom.getValue( "scm" ) );
    }
4733#public void testPluginConfigurationUsingAttributesWithoutPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-config-attributes/wo-plugin-mngt" );
        assertEquals( "src", pom.getValue( "build/plugins[1]/configuration/domParam/copy/@todir" ) );
        assertEquals( "true", pom.getValue( "build/plugins[1]/configuration/domParam/copy/@overwrite" ) );
        assertEquals( "target", pom.getValue( "build/plugins[1]/configuration/domParam/copy/fileset/@dir" ) );
        assertEquals( null, pom.getValue( "build/plugins[1]/configuration/domParam/copy/fileset/@todir" ) );
        assertEquals( null, pom.getValue( "build/plugins[1]/configuration/domParam/copy/fileset/@overwrite" ) );
    }
4734#/** MNG-4053*/
    public void testPluginConfigurationUsingAttributesWithPluginManagement()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-config-attributes/w-plugin-mngt" );
        assertEquals( "src", pom.getValue( "build/plugins[1]/configuration/domParam/copy/@todir" ) );
        assertEquals( "true", pom.getValue( "build/plugins[1]/configuration/domParam/copy/@overwrite" ) );
        assertEquals( "target", pom.getValue( "build/plugins[1]/configuration/domParam/copy/fileset/@dir" ) );
        assertEquals( null, pom.getValue( "build/plugins[1]/configuration/domParam/copy/fileset/@todir" ) );
        assertEquals( null, pom.getValue( "build/plugins[1]/configuration/domParam/copy/fileset/@overwrite" ) );
    }
4735#public void testPluginConfigurationUsingAttributesWithPluginManagementAndProfile()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-config-attributes/w-profile", "maven-core-it" );
        assertEquals( "src", pom.getValue( "build/plugins[1]/configuration/domParam/copy/@todir" ) );
        assertEquals( "true", pom.getValue( "build/plugins[1]/configuration/domParam/copy/@overwrite" ) );
        assertEquals( "target", pom.getValue( "build/plugins[1]/configuration/domParam/copy/fileset/@dir" ) );
        assertEquals( null, pom.getValue( "build/plugins[1]/configuration/domParam/copy/fileset/@todir" ) );
        assertEquals( null, pom.getValue( "build/plugins[1]/configuration/domParam/copy/fileset/@overwrite" ) );
    }
4736#public void testPomEncoding()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "pom-encoding/utf-8" );
        assertEquals( "TEST-CHARS: \u00DF\u0131\u03A3\u042F\u05D0\u20AC", pom.getValue( "description" ) );
        pom = buildPom( "pom-encoding/latin-1" );
        assertEquals( "TEST-CHARS: \u00C4\u00D6\u00DC\u00E4\u00F6\u00FC\u00DF", pom.getValue( "description" ) );
    }
4737#/* MNG-4070 */
    public void testXmlWhitespaceHandling()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "xml-whitespace/sub" );
        assertEquals( "org.apache.maven.its.mng4070", pom.getValue( "groupId" ) );
    }
4738#/* MNG-3760*/
    public void testInterpolationOfBaseUrl()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "baseurl-interpolation/pom.xml" );
        assertEquals( pom.getBasedir().toURI().toString(), pom.getValue( "properties/prop1" ).toString() );
    }
4739#/* MNG-3811*/
    public void testReportingPluginConfig()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "reporting-plugin-config/sub" );

        assertEquals( 2, ( (List<?>) pom.getValue( "reporting/plugins[1]/configuration/stringParams" ) ).size() );
        assertEquals( "parentParam", pom.getValue( "reporting/plugins[1]/configuration/stringParams[1]/stringParam[1]" ) );
        assertEquals( "childParam", pom.getValue( "reporting/plugins[1]/configuration/stringParams[1]/stringParam[2]" ) );
        assertEquals( "true", pom.getValue( "reporting/plugins[1]/configuration/booleanParam" ) );
    }
4740#public void testPropertiesNoDuplication()
    	throws Exception
    {
    	PomTestWrapper pom = buildPom( "properties-no-duplication/sub" );	
        assertEquals( 1, ( (Properties) pom.getValue( "properties" ) ).size() );
        assertEquals( "child", pom.getValue( "properties/pomProfile" ) );
    }
4741#public void testPomInheritance()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "pom-inheritance/sub" );
        assertEquals( "parent-description", pom.getValue( "description" ) );
        assertEquals( "jar", pom.getValue( "packaging" ) );
    }
4742#public void testCompleteModelWithoutParent()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "complete-model/wo-parent" );

        testCompleteModel( pom );
    }
4743#public void testCompleteModelWithParent()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "complete-model/w-parent/sub" );

        testCompleteModel( pom );
    }
4744#private void testCompleteModel( PomTestWrapper pom )
        throws Exception
    {
        assertEquals( "4.0.0", pom.getValue( "modelVersion" ) );

        assertEquals( "org.apache.maven.its.mng", pom.getValue( "groupId" ) );
        assertEquals( "test", pom.getValue( "artifactId" ) );
        assertEquals( "0.2", pom.getValue( "version" ) );
        assertEquals( "pom", pom.getValue( "packaging" ) );

        assertEquals( "project-name", pom.getValue( "name" ) );
        assertEquals( "project-description", pom.getValue( "description" ) );
        assertEquals( "http://project.url/", pom.getValue( "url" ) );
        assertEquals( "2009", pom.getValue( "inceptionYear" ) );

        assertEquals( "project-org", pom.getValue( "organization/name" ) );
        assertEquals( "http://project-org.url/", pom.getValue( "organization/url" ) );

        assertEquals( 1, ( (List<?>) pom.getValue( "licenses" ) ).size() );
        assertEquals( "project-license", pom.getValue( "licenses[1]/name" ) );
        assertEquals( "http://project.url/license", pom.getValue( "licenses[1]/url" ) );
        assertEquals( "repo", pom.getValue( "licenses[1]/distribution" ) );
        assertEquals( "free", pom.getValue( "licenses[1]/comments" ) );

        assertEquals( 1, ( (List<?>) pom.getValue( "developers" ) ).size() );
        assertEquals( "dev", pom.getValue( "developers[1]/id" ) );
        assertEquals( "project-developer", pom.getValue( "developers[1]/name" ) );
        assertEquals( "developer@", pom.getValue( "developers[1]/email" ) );
        assertEquals( "http://developer", pom.getValue( "developers[1]/url" ) );
        assertEquals( "developer", pom.getValue( "developers[1]/organization" ) );
        assertEquals( "http://devel.org", pom.getValue( "developers[1]/organizationUrl" ) );
        assertEquals( "-1", pom.getValue( "developers[1]/timezone" ) );
        assertEquals( "yes", pom.getValue( "developers[1]/properties/developer" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "developers[1]/roles" ) ).size() );
        assertEquals( "devel", pom.getValue( "developers[1]/roles[1]" ) );

        assertEquals( 1, ( (List<?>) pom.getValue( "contributors" ) ).size() );
        assertEquals( "project-contributor", pom.getValue( "contributors[1]/name" ) );
        assertEquals( "contributor@", pom.getValue( "contributors[1]/email" ) );
        assertEquals( "http://contributor", pom.getValue( "contributors[1]/url" ) );
        assertEquals( "contributor", pom.getValue( "contributors[1]/organization" ) );
        assertEquals( "http://contrib.org", pom.getValue( "contributors[1]/organizationUrl" ) );
        assertEquals( "+1", pom.getValue( "contributors[1]/timezone" ) );
        assertEquals( "yes", pom.getValue( "contributors[1]/properties/contributor" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "contributors[1]/roles" ) ).size() );
        assertEquals( "contrib", pom.getValue( "contributors[1]/roles[1]" ) );

        assertEquals( 1, ( (List<?>) pom.getValue( "mailingLists" ) ).size() );
        assertEquals( "project-mailing-list", pom.getValue( "mailingLists[1]/name" ) );
        assertEquals( "subscribe@", pom.getValue( "mailingLists[1]/subscribe" ) );
        assertEquals( "unsubscribe@", pom.getValue( "mailingLists[1]/unsubscribe" ) );
        assertEquals( "post@", pom.getValue( "mailingLists[1]/post" ) );
        assertEquals( "mail-archive", pom.getValue( "mailingLists[1]/archive" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "mailingLists[1]/otherArchives" ) ).size() );
        assertEquals( "other-archive", pom.getValue( "mailingLists[1]/otherArchives[1]" ) );

        assertEquals( "2.0.1", pom.getValue( "prerequisites/maven" ) );

        assertEquals( "http://project.url/trunk", pom.getValue( "scm/url" ) );
        assertEquals( "http://project.url/scm", pom.getValue( "scm/connection" ) );
        assertEquals( "https://project.url/scm", pom.getValue( "scm/developerConnection" ) );
        assertEquals( "TAG", pom.getValue( "scm/tag" ) );

        assertEquals( "issues", pom.getValue( "issueManagement/system" ) );
        assertEquals( "http://project.url/issues", pom.getValue( "issueManagement/url" ) );

        assertEquals( "ci", pom.getValue( "ciManagement/system" ) );
        assertEquals( "http://project.url/ci", pom.getValue( "ciManagement/url" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "ciManagement/notifiers" ) ).size() );
        assertEquals( "irc", pom.getValue( "ciManagement/notifiers[1]/type" ) );
        assertEquals( "ci@", pom.getValue( "ciManagement/notifiers[1]/address" ) );
        assertEquals( Boolean.TRUE, pom.getValue( "ciManagement/notifiers[1]/sendOnError" ) );
        assertEquals( Boolean.FALSE, pom.getValue( "ciManagement/notifiers[1]/sendOnFailure" ) );
        assertEquals( Boolean.FALSE, pom.getValue( "ciManagement/notifiers[1]/sendOnWarning" ) );
        assertEquals( Boolean.FALSE, pom.getValue( "ciManagement/notifiers[1]/sendOnSuccess" ) );
        assertEquals( "ci", pom.getValue( "ciManagement/notifiers[1]/configuration/ciProp" ) );

        assertEquals( "project.distros", pom.getValue( "distributionManagement/repository/id" ) );
        assertEquals( "distros", pom.getValue( "distributionManagement/repository/name" ) );
        assertEquals( "http://project.url/dist", pom.getValue( "distributionManagement/repository/url" ) );
        assertEquals( Boolean.TRUE, pom.getValue( "distributionManagement/repository/uniqueVersion" ) );

        assertEquals( "project.snaps", pom.getValue( "distributionManagement/snapshotRepository/id" ) );
        assertEquals( "snaps", pom.getValue( "distributionManagement/snapshotRepository/name" ) );
        assertEquals( "http://project.url/snaps", pom.getValue( "distributionManagement/snapshotRepository/url" ) );
        assertEquals( Boolean.FALSE, pom.getValue( "distributionManagement/snapshotRepository/uniqueVersion" ) );

        assertEquals( "project.site", pom.getValue( "distributionManagement/site/id" ) );
        assertEquals( "docs", pom.getValue( "distributionManagement/site/name" ) );
        assertEquals( "http://project.url/site", pom.getValue( "distributionManagement/site/url" ) );

        assertEquals( "http://project.url/download", pom.getValue( "distributionManagement/downloadUrl" ) );
        assertEquals( "reloc-gid", pom.getValue( "distributionManagement/relocation/groupId" ) );
        assertEquals( "reloc-aid", pom.getValue( "distributionManagement/relocation/artifactId" ) );
        assertEquals( "reloc-version", pom.getValue( "distributionManagement/relocation/version" ) );
        assertEquals( "project-reloc-msg", pom.getValue( "distributionManagement/relocation/message" ) );

        assertEquals( 1, ( (List<?>) pom.getValue( "modules" ) ).size() );
        assertEquals( "sub", pom.getValue( "modules[1]" ) );

        assertEquals( 1, ( (Map<?, ?>) pom.getValue( "properties" ) ).size() );
        assertEquals( "project-property", pom.getValue( "properties[1]/itProperty" ) );

        assertEquals( 1, ( (List<?>) pom.getValue( "dependencyManagement/dependencies" ) ).size() );
        assertEquals( "org.apache.maven.its", pom.getValue( "dependencyManagement/dependencies[1]/groupId" ) );
        assertEquals( "managed-dep", pom.getValue( "dependencyManagement/dependencies[1]/artifactId" ) );
        assertEquals( "0.1", pom.getValue( "dependencyManagement/dependencies[1]/version" ) );
        assertEquals( "war", pom.getValue( "dependencyManagement/dependencies[1]/type" ) );
        assertEquals( "runtime", pom.getValue( "dependencyManagement/dependencies[1]/scope" ) );
        assertEquals( Boolean.FALSE, pom.getValue( "dependencyManagement/dependencies[1]/optional" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "dependencyManagement/dependencies[1]/exclusions" ) ).size() );
        assertEquals( "org.apache.maven.its",
                      pom.getValue( "dependencyManagement/dependencies[1]/exclusions[1]/groupId" ) );
        assertEquals( "excluded-managed-dep",
                      pom.getValue( "dependencyManagement/dependencies[1]/exclusions[1]/artifactId" ) );

        assertEquals( 1, ( (List<?>) pom.getValue( "dependencies" ) ).size() );
        assertEquals( "org.apache.maven.its", pom.getValue( "dependencies[1]/groupId" ) );
        assertEquals( "dep", pom.getValue( "dependencies[1]/artifactId" ) );
        assertEquals( "0.2", pom.getValue( "dependencies[1]/version" ) );
        assertEquals( "ejb", pom.getValue( "dependencies[1]/type" ) );
        assertEquals( "test", pom.getValue( "dependencies[1]/scope" ) );
        assertEquals( Boolean.TRUE, pom.getValue( "dependencies[1]/optional" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "dependencies[1]/exclusions" ) ).size() );
        assertEquals( "org.apache.maven.its", pom.getValue( "dependencies[1]/exclusions[1]/groupId" ) );
        assertEquals( "excluded-dep", pom.getValue( "dependencies[1]/exclusions[1]/artifactId" ) );

        assertEquals( 2, ( (List<?>) pom.getValue( "repositories" ) ).size() );
        assertEquals( "project-remote-repo", pom.getValue( "repositories[1]/id" ) );
        assertEquals( "http://project.url/remote", pom.getValue( "repositories[1]/url" ) );
        assertEquals( "repo", pom.getValue( "repositories[1]/name" ) );
        assertEquals( RepositorySystem.DEFAULT_REMOTE_REPO_ID, pom.getValue( "repositories[2]/id" ) );
        assertEquals( RepositorySystem.DEFAULT_REMOTE_REPO_URL, pom.getValue( "repositories[2]/url" ) );

        assertEquals( "test", pom.getValue( "build/defaultGoal" ) );
        assertEquals( "coreit", pom.getValue( "build/finalName" ) );

        assertPathSuffixEquals( "build", pom.getValue( "build/directory" ) );
        assertPathSuffixEquals( "build/main", pom.getValue( "build/outputDirectory" ) );
        assertPathSuffixEquals( "build/test", pom.getValue( "build/testOutputDirectory" ) );
        assertPathSuffixEquals( "sources/main", pom.getValue( "build/sourceDirectory" ) );
        assertPathSuffixEquals( "sources/test", pom.getValue( "build/testSourceDirectory" ) );
        assertPathSuffixEquals( "sources/scripts", pom.getValue( "build/scriptSourceDirectory" ) );

        assertEquals( 1, ( (List<?>) pom.getValue( "build/filters" ) ).size() );
        assertPathSuffixEquals( "src/main/filter/it.properties", pom.getValue( "build/filters[1]" ) );

        assertEquals( 1, ( (List<?>) pom.getValue( "build/resources" ) ).size() );
        assertPathSuffixEquals( "res/main", pom.getValue( "build/resources[1]/directory" ) );
        assertPathSuffixEquals( "main", pom.getValue( "build/resources[1]/targetPath" ) );
        assertEquals( Boolean.TRUE, pom.getValue( "build/resources[1]/filtering" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/resources[1]/includes" ) ).size() );
        assertPathSuffixEquals( "main.included", pom.getValue( "build/resources[1]/includes[1]" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/resources[1]/excludes" ) ).size() );
        assertPathSuffixEquals( "main.excluded", pom.getValue( "build/resources[1]/excludes[1]" ) );

        assertEquals( 1, ( (List<?>) pom.getValue( "build/testResources" ) ).size() );
        assertPathSuffixEquals( "res/test", pom.getValue( "build/testResources[1]/directory" ) );
        assertPathSuffixEquals( "test", pom.getValue( "build/testResources[1]/targetPath" ) );
        assertEquals( Boolean.TRUE, pom.getValue( "build/testResources[1]/filtering" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/testResources[1]/includes" ) ).size() );
        assertPathSuffixEquals( "test.included", pom.getValue( "build/testResources[1]/includes[1]" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/testResources[1]/excludes" ) ).size() );
        assertPathSuffixEquals( "test.excluded", pom.getValue( "build/testResources[1]/excludes[1]" ) );

        assertEquals( 1, ( (List<?>) pom.getValue( "build/extensions" ) ).size() );
        assertEquals( "org.apache.maven.its.ext", pom.getValue( "build/extensions[1]/groupId" ) );
        assertEquals( "ext", pom.getValue( "build/extensions[1]/artifactId" ) );
        assertEquals( "3.0", pom.getValue( "build/extensions[1]/version" ) );

        assertEquals( 1, ( (List<?>) pom.getValue( "build/plugins" ) ).size() );
        assertEquals( "org.apache.maven.its.plugins", pom.getValue( "build/plugins[1]/groupId" ) );
        assertEquals( "maven-it-plugin-build", pom.getValue( "build/plugins[1]/artifactId" ) );
        assertEquals( "2.1-SNAPSHOT", pom.getValue( "build/plugins[1]/version" ) );
        assertEquals( "test.properties", pom.getValue( "build/plugins[1]/configuration/outputFile" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/plugins[1]/executions" ) ).size() );
        assertEquals( "test", pom.getValue( "build/plugins[1]/executions[1]/id" ) );
        assertEquals( "validate", pom.getValue( "build/plugins[1]/executions[1]/phase" ) );
        assertEquals( "pom.properties", pom.getValue( "build/plugins[1]/executions[1]/configuration/outputFile" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/plugins[1]/executions[1]/goals" ) ).size() );
        assertEquals( "eval", pom.getValue( "build/plugins[1]/executions[1]/goals[1]" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/plugins[1]/dependencies" ) ).size() );
        assertEquals( "org.apache.maven.its", pom.getValue( "build/plugins[1]/dependencies[1]/groupId" ) );
        assertEquals( "build-plugin-dep", pom.getValue( "build/plugins[1]/dependencies[1]/artifactId" ) );
        assertEquals( "0.3", pom.getValue( "build/plugins[1]/dependencies[1]/version" ) );
        assertEquals( "zip", pom.getValue( "build/plugins[1]/dependencies[1]/type" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/plugins[1]/dependencies[1]/exclusions" ) ).size() );
        assertEquals( "org.apache.maven.its", pom.getValue( "build/plugins[1]/dependencies[1]/exclusions[1]/groupId" ) );
        assertEquals( "excluded-build-plugin-dep",
                      pom.getValue( "build/plugins[1]/dependencies[1]/exclusions[1]/artifactId" ) );

        assertEquals( Boolean.TRUE, pom.getValue( "reporting/excludeDefaults" ) );
        assertPathSuffixEquals( "docs", pom.getValue( "reporting/outputDirectory" ) );

        assertEquals( 1, ( (List<?>) pom.getValue( "reporting/plugins" ) ).size() );
        assertEquals( "org.apache.maven.its.plugins", pom.getValue( "reporting/plugins[1]/groupId" ) );
        assertEquals( "maven-it-plugin-reporting", pom.getValue( "reporting/plugins[1]/artifactId" ) );
        assertEquals( "2.0-SNAPSHOT", pom.getValue( "reporting/plugins[1]/version" ) );
        assertEquals( "test.html", pom.getValue( "reporting/plugins[1]/configuration/outputFile" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "reporting/plugins[1]/reportSets" ) ).size() );
        assertEquals( "it", pom.getValue( "reporting/plugins[1]/reportSets[1]/id" ) );
        assertEquals( "index.html", pom.getValue( "reporting/plugins[1]/reportSets[1]/configuration/outputFile" ) );
        assertEquals( 1, ( (List<?>) pom.getValue( "reporting/plugins[1]/reportSets[1]/reports" ) ).size() );
        assertEquals( "run", pom.getValue( "reporting/plugins[1]/reportSets[1]/reports[1]" ) );
    }
4745#/* MNG-2309*/

    public void testProfileInjectionOrder()
        throws Exception
    {
        PomTestWrapper pom =
            buildPom( "profile-injection-order", "pom-a", "pom-b", "pom-e", "pom-c", "pom-d" );
        assertEquals( "e", pom.getValue( "properties[1]/pomProperty" ) );
    }
4746#public void testPropertiesInheritance()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "properties-inheritance/sub" );
        assertEquals( "parent-property", pom.getValue( "properties/parentProperty" ) );
        assertEquals( "child-property", pom.getValue( "properties/childProperty" ) );
        assertEquals( "child-override", pom.getValue( "properties/overriddenProperty" ) );
    }
4747#/* MNG-4102*/
    public void testInheritedPropertiesInterpolatedWithValuesFromChildWithoutProfiles()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "inherited-properties-interpolation/no-profile/sub" );

        assertEquals( "CHILD", pom.getValue( "properties/overridden" ) );
        assertEquals( "CHILD", pom.getValue( "properties/interpolated" ) );
    }
4748#/* MNG-4102 */
    public void testInheritedPropertiesInterpolatedWithValuesFromChildWithActiveProfiles()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "inherited-properties-interpolation/active-profile/sub" );

        assertEquals( 1, pom.getMavenProject().getModel().getProfiles().size() );

        buildPom( "inherited-properties-interpolation/active-profile/sub", "it-parent", "it-child" );
        assertEquals( "CHILD", pom.getValue( "properties/overridden" ) );
        assertEquals( "CHILD", pom.getValue( "properties/interpolated" ) );
    }
4749#/* MNG-3545 */
    public void testProfileDefaultActivation()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "profile-default-deactivation", "profile4" );
        assertEquals( 1, pom.getMavenProject().getActiveProfiles().size() );
        assertEquals( 1, ( (List<?>) pom.getValue( "build/plugins" ) ).size() );
        assertEquals( "2.1", pom.getValue( "build/plugins[1]/version" ) );
    }
4750#/* MNG-1995 */
    public void testBooleanInterpolation()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "boolean-interpolation" );
        assertTrue ((Boolean) pom.getValue( "repositories[1]/releases/enabled" ) );     
        assertTrue((Boolean) pom.getValue( "build/resources[1]/filtering" ) ); 
    }
4751#/* MNG-3899 */
    public void testBuildExtensionInheritance()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "build-extension-inheritance/sub" ); 
        assertEquals( 3, ( (List<?>) pom.getValue( "build/extensions" ) ).size() );
        assertEquals( "b", pom.getValue( "build/extensions[1]/artifactId" ) );
        assertEquals( "a", pom.getValue( "build/extensions[2]/artifactId" ) );
        assertEquals( "0.2", pom.getValue( "build/extensions[2]/version" ) );
        assertEquals( "c", pom.getValue( "build/extensions[3]/artifactId" ) );
    }
4752#/*MNG-1957*/
    public void testJdkActivation()
    	throws Exception
	{
    	Properties props = new Properties();
        props.put( "java.version", "1.5.0_15" );

        PomTestWrapper pom = buildPom( "jdk-activation", props );
        assertEquals( 3, pom.getMavenProject().getActiveProfiles().size() );
        assertEquals( "PASSED", pom.getValue( "properties/jdkProperty3" ) );
        assertEquals( "PASSED", pom.getValue( "properties/jdkProperty2" ) );
        assertEquals( "PASSED", pom.getValue( "properties/jdkProperty1" ) );
	}
4753#/* MNG-2174 */
    public void testProfilePluginMngDependencies()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "profile-plugin-mng-dependencies/sub", "maven-core-it" );
        assertEquals( "a", pom.getValue( "build/plugins[1]/dependencies[1]/artifactId" ) );
    }
4754#/** MNG-4116 */
    public void testPercentEncodedUrlsMustNotBeDecoded()
        throws Exception
    {
        PomTestWrapper pom = this.buildPom( "url-no-decoding" );
        assertEquals( "http://maven.apache.org/spacy%20path", pom.getValue( "url" ) );
        assertEquals( "http://svn.apache.org/viewvc/spacy%20path", pom.getValue( "scm/url" ) );
        assertEquals( "scm:svn:svn+ssh://svn.apache.org/spacy%20path", pom.getValue( "scm/connection" ) );
        assertEquals( "scm:svn:svn+ssh://svn.apache.org/spacy%20path", pom.getValue( "scm/developerConnection" ) );
        assertEquals( "http://issues.apache.org/spacy%20path", pom.getValue( "issueManagement/url" ) );
        assertEquals( "http://ci.apache.org/spacy%20path", pom.getValue( "ciManagement/url" ) );
        assertEquals( "scm:svn:svn+ssh://dist.apache.org/spacy%20path",
                      pom.getValue( "distributionManagement/repository/url" ) );
        assertEquals( "scm:svn:svn+ssh://snap.apache.org/spacy%20path",
                      pom.getValue( "distributionManagement/snapshotRepository/url" ) );
        assertEquals( "scm:svn:svn+ssh://site.apache.org/spacy%20path",
                      pom.getValue( "distributionManagement/site/url" ) );
    }
4755#public void testPluginManagementInheritance()
        throws Exception
    {
        PomTestWrapper pom = this.buildPom( "plugin-management-inheritance" );
        assertEquals( "0.1-stub-SNAPSHOT",
                      pom.getValue( "build/pluginManagement/plugins[@artifactId='maven-compiler-plugin']/version" ) );
    }
4756#public void testProfilePlugins()
	    throws Exception
	{
        PomTestWrapper pom = this.buildPom( "profile-plugins", "standard" );
        assertEquals( 2, ( (List<?>) pom.getValue( "build/plugins" ) ).size() );
        assertEquals( "maven-assembly2-plugin", pom.getValue( "build/plugins[2]/artifactId" ) );
	}
4757#public void testPluginInheritanceSimple()
	    throws Exception
	{
        PomTestWrapper pom = this.buildPom( "plugin-inheritance-simple/sub" );
	    assertEquals( 2, ( (List<?>) pom.getValue( "build/plugins" ) ).size() );   
	}
4758#public void testPluginManagementDuplicate()
	    throws Exception
	{
        PomTestWrapper pom = this.buildPom( "plugin-management-duplicate/sub" );
        assertEquals( 12, ( (List<?>) pom.getValue( "build/pluginManagement/plugins" ) ).size() );
	}
4759#public void testDistributionManagement()
	    throws Exception
	{
        PomTestWrapper pom = this.buildPom( "distribution-management" );
        assertEquals( "legacy", pom.getValue( "distributionManagement/repository/layout" ) );
	}
4760#public void testDependencyScopeInheritance()
	    throws Exception
	{
        PomTestWrapper pom = buildPom( "dependency-scope-inheritance/sub" );
        String scope = (String) pom.getValue( "dependencies[1]/scope" );
        assertEquals( "compile", scope );
	}
4761#public void testDependencyScope()
	    throws Exception
	{
	    PomTestWrapper pom = buildPom( "dependency-scope/sub" );
	}
4762#//This will fail on a validation error if incorrect
    public void testDependencyManagementWithInterpolation()
	    throws Exception
	{
	    PomTestWrapper pom = buildPom( "dependency-management-with-interpolation/sub" );
	}
4763#public void testInterpolationWithSystemProperty()
        throws Exception
    {
        Properties sysProps = new Properties();
        sysProps.setProperty( "system.property", "PASSED" );
        PomTestWrapper pom = buildPom( "sytem-property-interpolation", sysProps );
        assertEquals( "PASSED", pom.getValue( "name" ) );
    }
4764#/* MNG-4129 */
    public void testPluginExecutionInheritanceWhenChildDoesNotDeclarePlugin()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-inheritance/wo-merge" );
        List<PluginExecution> executions =
            (List<PluginExecution>) pom.getValue( "build/pluginsAsMap[@name='org.apache.maven.its.plugins:maven-it-plugin-log-file']/executions" );
        assertEquals( 1, executions.size() );
        assertEquals( "inherited-execution", executions.get( 0 ).getId() );
    }
4765#public void testPluginExecutionInheritanceWhenChildDoesDeclarePluginAsWell()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-inheritance/w-merge" );
        List<PluginExecution> executions =
            (List<PluginExecution>) pom.getValue( "build/pluginsAsMap[@name='org.apache.maven.its.plugins:maven-it-plugin-log-file']/executions" );
        assertEquals( 1, executions.size() );
        assertEquals( "inherited-execution", executions.get( 0 ).getId() );
    }
4766#/* MNG-4193 */
    public void testValidationErrorUponNonUniqueArtifactRepositoryId()
        throws Exception
    {
        try
        {
            buildPom( "unique-repo-id/artifact-repo" );
            fail( "Non-unique repository ids did not cause validation error" );
        }
        catch ( ProjectBuildingException e )
        {
            // expected
        }
    }
4767#/* MNG-4193 */
    public void testValidationErrorUponNonUniquePluginRepositoryId()
        throws Exception
    {
        try
        {
            buildPom( "unique-repo-id/plugin-repo" );
            fail( "Non-unique repository ids did not cause validation error" );
        }
        catch ( ProjectBuildingException e )
        {
            // expected
        }
    }
4768#/* MNG-4193 */
    public void testValidationErrorUponNonUniqueArtifactRepositoryIdInProfile()
        throws Exception
    {
        try
        {
            buildPom( "unique-repo-id/artifact-repo-in-profile" );
            fail( "Non-unique repository ids did not cause validation error" );
        }
        catch ( ProjectBuildingException e )
        {
            // expected
        }
    }
4769#/* MNG-4193 */
    public void testValidationErrorUponNonUniquePluginRepositoryIdInProfile()
        throws Exception
    {
        try
        {
            buildPom( "unique-repo-id/plugin-repo-in-profile" );
            fail( "Non-unique repository ids did not cause validation error" );
        }
        catch ( ProjectBuildingException e )
        {
            // expected
        }
    }
4770#/** MNG-3843 */
    public void testPrerequisitesAreNotInherited()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "prerequisites-inheritance/child" );
        assertSame( null, pom.getValue( "prerequisites" ) );
    }
4771#public void testLicensesAreInheritedButNotAggregated()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "licenses-inheritance/child-2" );
        assertEquals( 1, ( (List<?>) pom.getValue( "licenses" ) ).size() );
        assertEquals( "child-license", pom.getValue( "licenses[1]/name" ) );
        assertEquals( "http://child.url/license", pom.getValue( "licenses[1]/url" ) );
    }
4772#public void testDevelopersAreInheritedButNotAggregated()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "developers-inheritance/child-2" );
        assertEquals( 1, ( (List<?>) pom.getValue( "developers" ) ).size() );
        assertEquals( "child-developer", pom.getValue( "developers[1]/name" ) );
    }
4773#public void testContributorsAreInheritedButNotAggregated()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "contributors-inheritance/child-2" );
        assertEquals( 1, ( (List<?>) pom.getValue( "contributors" ) ).size() );
        assertEquals( "child-contributor", pom.getValue( "contributors[1]/name" ) );
    }
4774#public void testMailingListsAreInheritedButNotAggregated()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "mailing-lists-inheritance/child-2" );
        assertEquals( 1, ( (List<?>) pom.getValue( "mailingLists" ) ).size() );
        assertEquals( "child-mailing-list", pom.getValue( "mailingLists[1]/name" ) );
    }
4775#public void testPluginInheritanceOrder()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-inheritance-order/child" );

        assertEquals( "maven-it-plugin-log-file", pom.getValue( "build/plugins[1]/artifactId" ) );
        assertEquals( "maven-it-plugin-expression", pom.getValue( "build/plugins[2]/artifactId" ) );
        assertEquals( "maven-it-plugin-configuration", pom.getValue( "build/plugins[3]/artifactId" ) );

        assertEquals( "maven-it-plugin-log-file", pom.getValue( "reporting/plugins[1]/artifactId" ) );
        assertEquals( "maven-it-plugin-expression", pom.getValue( "reporting/plugins[2]/artifactId" ) );
        assertEquals( "maven-it-plugin-configuration", pom.getValue( "reporting/plugins[3]/artifactId" ) );
    }
4776#public void testCliPropsDominateProjectPropsDuringInterpolation()
        throws Exception
    {
        Properties props = new Properties();
        props.setProperty( "testProperty", "PASSED" );
        PomTestWrapper pom = buildPom( "interpolation-cli-wins", props );

        assertEquals( "PASSED", pom.getValue( "properties/interpolatedProperty" ) );
    }
4777#public void testParentPomPackagingMustBePom()
        throws Exception
    {
        try
        {
            buildPom( "parent-pom-packaging/sub" );
            fail( "Wrong packaging of parent POM was not rejected" );
        }
        catch ( ProjectBuildingException e )
        {
            // expected
        }
    }
4778#/** MNG-522, MNG-3018 */
    public void testManagedPluginConfigurationAppliesToImplicitPluginsIntroducedByPackaging()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-management-for-implicit-plugin/child" );
        assertEquals( "passed.txt",
                      pom.getValue( "build/plugins[@artifactId='maven-resources-plugin']/configuration/pathname" ) );
        assertEquals( "passed.txt",
                      pom.getValue( "build/plugins[@artifactId='maven-it-plugin-log-file']/configuration/logFile" ) );
    }
4779#public void testDefaultPluginsExecutionContributedByPackagingExecuteBeforeUserDefinedExecutions()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-order-and-default-exec" );
        List<PluginExecution> executions =
            (List<PluginExecution>) pom.getValue( "build/plugins[@artifactId='maven-resources-plugin']/executions" );
        assertNotNull( executions );
        assertEquals( 4, executions.size() );
        assertEquals( "default-resources", executions.get( 0 ).getId() );
        assertEquals( "default-testResources", executions.get( 1 ).getId() );
        assertEquals( "test-1", executions.get( 2 ).getId() );
        assertEquals( "test-2", executions.get( 3 ).getId() );
    }
4780#public void testPluginDeclarationsRetainPomOrderAfterInjectionOfDefaultPlugins()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-exec-order-with-lifecycle" );
        List<Plugin> plugins = (List<Plugin>) pom.getValue( "build/plugins" );
        int resourcesPlugin = -1;
        int customPlugin = -1;
        for ( int i = 0; i < plugins.size(); i++ )
        {
            Plugin plugin = plugins.get( i );
            if ( "maven-resources-plugin".equals( plugin.getArtifactId() ) )
            {
                assertTrue( resourcesPlugin < 0 );
                resourcesPlugin = i;
            }
            else if ( "maven-it-plugin-log-file".equals( plugin.getArtifactId() ) )
            {
                assertTrue( customPlugin < 0 );
                customPlugin = i;
            }
        }
        assertTrue( plugins.toString(), customPlugin == resourcesPlugin - 1 );
    }
4781#/** MNG-4415 */
    public void testPluginOrderAfterMergingWithInheritedPlugins()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-inheritance-merge-order/sub" );

        List<String> expected = new ArrayList<String>();
        expected.add( "maven-it-plugin-error" );
        expected.add( "maven-it-plugin-configuration" );
        expected.add( "maven-it-plugin-dependency-resolution" );
        expected.add( "maven-it-plugin-packaging" );
        expected.add( "maven-it-plugin-log-file" );
        expected.add( "maven-it-plugin-expression" );
        expected.add( "maven-it-plugin-fork" );
        expected.add( "maven-it-plugin-touch" );

        List<String> actual = new ArrayList<String>();
        for ( Plugin plugin : (List<Plugin>) pom.getValue( "build/plugins" ) )
        {
            actual.add( plugin.getArtifactId() );
        }

        actual.retainAll( expected );

        assertEquals( actual, expected );
    }
4782#/** MNG-4416 */
    public void testPluginOrderAfterMergingWithInjectedPlugins()
        throws Exception
    {
        PomTestWrapper pom = buildPom( "plugin-injection-merge-order" );

        List<String> expected = new ArrayList<String>();
        expected.add( "maven-it-plugin-error" );
        expected.add( "maven-it-plugin-configuration" );
        expected.add( "maven-it-plugin-dependency-resolution" );
        expected.add( "maven-it-plugin-packaging" );
        expected.add( "maven-it-plugin-log-file" );
        expected.add( "maven-it-plugin-expression" );
        expected.add( "maven-it-plugin-fork" );
        expected.add( "maven-it-plugin-touch" );

        List<String> actual = new ArrayList<String>();
        for ( Plugin plugin : (List<Plugin>) pom.getValue( "build/plugins" ) )
        {
            actual.add( plugin.getArtifactId() );
        }

        actual.retainAll( expected );

        assertEquals( actual, expected );
    }
4783#public void testProjectArtifactIdIsNotInheritedButMandatory()
        throws Exception
    {
        try
        {
            buildPom( "artifact-id-inheritance/child" );
            fail( "Missing artifactId did not cause validation error" );
        }
        catch ( ProjectBuildingException e )
        {
            // expected
        }
    }
4784#private void assertPathSuffixEquals( String expected, Object actual )
    {
        String a = actual.toString();
        a = a.substring( a.length() - expected.length() ).replace( '\\', '/' );
        assertEquals( expected, a );
    }
4785#private void assertPathWithNormalizedFileSeparators( Object value )
    {
        assertEquals( new File( value.toString() ).getPath(), value.toString() );
    }
4786#private PomTestWrapper buildPom( String pomPath, String... profileIds )
        throws ProjectBuildingException
    {
        return buildPom( pomPath, null, profileIds );
    }
4787#private PomTestWrapper buildPom( String pomPath, Properties executionProperties, String... profileIds )
        throws ProjectBuildingException
    {
        return buildPom( pomPath, false, executionProperties, profileIds );
    }
4788#private PomTestWrapper buildPom( String pomPath, boolean lenientValidation, Properties executionProperties,
                                     String... profileIds )
        throws ProjectBuildingException
    {
        File pomFile = new File( testDirectory, pomPath );
        if ( pomFile.isDirectory() )
        {
            pomFile = new File( pomFile, "pom.xml" );
        }

        ProjectBuildingRequest config = new DefaultProjectBuildingRequest();

        String localRepoUrl =
            System.getProperty( "maven.repo.local", System.getProperty( "user.home" ) + "/.m2/repository" );
        localRepoUrl = "file://" + localRepoUrl;
        config.setLocalRepository( repositorySystem.createArtifactRepository( "local", localRepoUrl, new DefaultRepositoryLayout(), null, null ) );
        config.setActiveProfileIds( Arrays.asList( profileIds ) );
        config.setSystemProperties( executionProperties );
        config.setUserProperties( executionProperties );
        config.setValidationLevel( lenientValidation ? ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0
                        : ModelBuildingRequest.VALIDATION_LEVEL_STRICT );
        MavenRepositorySystemSession repoSession = new MavenRepositorySystemSession();
        repoSession.setLocalRepositoryManager( new SimpleLocalRepositoryManager(
                                                                                 new File(
                                                                                           config.getLocalRepository().getBasedir() ) ) );
        config.setRepositorySession( repoSession );

        return new PomTestWrapper( pomFile, projectBuilder.build( pomFile, config ).getProject() );
    }
4789#protected void assertModelEquals( PomTestWrapper pom, Object expected, String expression )
    {
        assertEquals( expected, pom.getValue( expression ) );        
    }
4790#private static String createPath( List<String> elements )
    {
        StringBuilder buffer = new StringBuilder( 256 );
        for ( String s : elements )
        {
            buffer.append( s ).append( File.separator );
        }
        return buffer.toString().substring( 0, buffer.toString().length() - 1 );
    }
4791#public LegacyLocalRepositoryManager( File basedir )
    {
        super( basedir );
    }
4792#public String getPathForLocalArtifact( Artifact artifact )
    {
        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getGroupId() ).append( '/' );

        path.append( artifact.getExtension() ).append( 's' ).append( '/' );

        path.append( artifact.getArtifactId() ).append( '-' ).append( artifact.getVersion() );

        if ( artifact.getClassifier().length() > 0 )
        {
            path.append( '-' ).append( artifact.getClassifier() );
        }

        path.append( '.' ).append( artifact.getExtension() );

        return path.toString();
    }
4793#public LocalArtifactResult find( RepositorySystemSession session, LocalArtifactRequest request )
    {
 	    String path = getPathForLocalArtifact( request.getArtifact() );
 	    File file = new File( getRepository().getBasedir(), path );
        LocalArtifactResult result = new LocalArtifactResult( request );
 	    if ( file.isFile() )
        {
 	        result.setFile( file );
 	        result.setAvailable( true );
 	    }
 	    return result;
 	}
4794#public MavenExecutionPlan calculateExecutionPlan( MavenSession session, String... tasks )
    {
        return new MavenExecutionPlan( null, null );
    }
4795#public MavenExecutionPlan calculateExecutionPlan( MavenSession session, boolean setup, String... tasks )
    {
        return new MavenExecutionPlan( null, null );
    }
4796#public void execute( MavenSession session )
    {
    }
4797#public Set<Plugin> getPluginsBoundByDefaultToAllLifecycles( String packaging )
    {
        Set<Plugin> plugins;

        // NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests
        if ( "JAR".equals( packaging ) )
        {
            plugins = new LinkedHashSet<Plugin>();

            plugins.add( newPlugin( "maven-compiler-plugin", "compile", "testCompile" ) );
            plugins.add( newPlugin( "maven-resources-plugin", "resources", "testResources" ) );
            plugins.add( newPlugin( "maven-surefire-plugin", "test" ) );
            plugins.add( newPlugin( "maven-jar-plugin", "jar" ) );
            plugins.add( newPlugin( "maven-install-plugin", "install" ) );
            plugins.add( newPlugin( "maven-deploy-plugin", "deploy" ) );
        }
        else
        {
            plugins = Collections.emptySet();
        }

        return plugins;
    }
4798#private Plugin newPlugin( String artifactId, String... goals )
    {
        Plugin plugin = new Plugin();

        plugin.setGroupId( "org.apache.maven.plugins" );
        plugin.setArtifactId( artifactId );

        for ( String goal : goals )
        {
            PluginExecution pluginExecution = new PluginExecution();
            pluginExecution.setId( "default-" + goal );
            pluginExecution.addGoal( goal );
            plugin.addExecution( pluginExecution );
        }

        return plugin;
    }
4799#public void calculateForkedExecutions( MojoExecution mojoExecution, MavenSession session )
    {
    }
4800#public List<MavenProject> executeForkedExecutions( MojoExecution mojoExecution, MavenSession session )
    {
        return Collections.emptyList();
    }
4801#protected void setUp()
        throws Exception
    {
        super.setUp();
        repositorySystem = lookup( RepositorySystem.class );
    }
4802#@Override
    protected void tearDown()
        throws Exception
    {
        repositorySystem = null;
        super.tearDown();
    }
4803#public void testCacheKey()
        throws Exception
    {
        Artifact a1 = repositorySystem.createArtifact( "testGroup", "testArtifact", "1.2.3", "jar" );
        ArtifactRepository lr1 = new DelegatingLocalArtifactRepository( repositorySystem.createDefaultLocalRepository() );
        ArtifactRepository rr1 = repositorySystem.createDefaultRemoteRepository();
        a1.setDependencyFilter( new ExcludesArtifactFilter( Arrays.asList( "foo" ) ) );

        Artifact a2 = repositorySystem.createArtifact( "testGroup", "testArtifact", "1.2.3", "jar" );
        ArtifactRepository lr2 = new DelegatingLocalArtifactRepository( repositorySystem.createDefaultLocalRepository() );
        ArtifactRepository rr2 = repositorySystem.createDefaultRemoteRepository();
        a2.setDependencyFilter( new ExcludesArtifactFilter( Arrays.asList( "foo" ) ) );

        // sanity checks
        assertNotSame( a1, a2 );
        assertNotSame( lr1, lr2 );
        assertNotSame( rr1, rr2 );

        CacheKey k1 = new CacheKey( a1, false, lr1, Collections.singletonList( rr1 ) );
        CacheKey k2 = new CacheKey( a2, false, lr2, Collections.singletonList( rr2 ) );
        
        assertEquals(k1.hashCode(), k2.hashCode());
    }
4804#protected void setUp()
        throws Exception
    {
        super.setUp();
        repositorySystem = lookup( RepositorySystem.class );
    }
4805#@Override
    protected void tearDown()
        throws Exception
    {
        repositorySystem = null;
        super.tearDown();
    }
4806#public void testShouldNotCarryExclusionsOverFromDependencyToDependency()
        throws Exception
    {
        /*
        Dependency dep1 = new Dependency();
        dep1.setGroupId( "test" );
        dep1.setArtifactId( "test-artifact" );
        dep1.setVersion( "1" );
        dep1.setType( "jar" );

        Exclusion exc = new Exclusion();
        exc.setGroupId( "test" );
        exc.setArtifactId( "test-artifact3" );

        dep1.addExclusion( exc );

        Dependency dep2 = new Dependency();
        dep2.setGroupId( "test" );
        dep2.setArtifactId( "test-artifact2" );
        dep2.setVersion( "1" );
        dep2.setType( "jar" );

        List deps = new ArrayList();
        deps.add( dep1 );
        deps.add( dep2 );

        ArtifactFactory factory = lookup( ArtifactFactory.class );

        ArtifactFilter dependencyFilter = new ScopeArtifactFilter( Artifact.SCOPE_COMPILE );

        MavenProject project = new MavenProject( new Model() );

        Set result = project.createArtifacts( dependencyFilter );

        for ( Iterator it = result.iterator(); it.hasNext(); )
        {
            Artifact artifact = ( Artifact ) it.next();

            if ( "test-artifact2".equals( artifact.getArtifactId() ) )
            {
                ArtifactFilter filter = artifact.getDependencyFilter();

                assertSame( dependencyFilter, filter );
            }
        }
        */
    }
4807#public void testProjectBuilder()
        throws Exception
    {
        File f = getFileForClasspathResource( "canonical-pom.xml" );

        MavenProject project = getProject( f );

        // ----------------------------------------------------------------------
        // Top-level elements
        // ----------------------------------------------------------------------

        assertEquals( "4.0.0", project.getModelVersion() );

        // ----------------------------------------------------------------------
        // Plugins
        // ----------------------------------------------------------------------

        List plugins = project.getBuildPlugins();

        // Plugin0 [plexus]

        String key = "org.apache.maven.plugins:maven-plexus-plugin";

        Plugin plugin = null;
        for ( Iterator it = plugins.iterator(); it.hasNext(); )
        {
            Plugin check = (Plugin) it.next();

            if ( key.equals( check.getKey() ) )
            {
                plugin = check;
                break;
            }
        }

        assertNotNull( plugin );

        assertEquals( "1.0", plugin.getVersion() );

        Xpp3Dom configuration = (Xpp3Dom) plugin.getConfiguration();

        assertEquals( "src/conf/plexus.conf", configuration.getChild( "plexusConfiguration" ).getValue() );

        assertEquals( "src/conf/plexus.properties",
                      configuration.getChild( "plexusConfigurationPropertiesFile" ).getValue() );

        assertEquals( "Continuum", configuration.getChild( "plexusApplicationName" ).getValue() );

        // ----------------------------------------------------------------------
        // Goal specific configuration
        // ----------------------------------------------------------------------

        List executions = plugin.getExecutions();

        PluginExecution execution = (PluginExecution) executions.get( 0 );

        String g0 = (String) execution.getGoals().get( 0 );

        assertEquals( "plexus:runtime", g0 );

        configuration = (Xpp3Dom) execution.getConfiguration();

        assertEquals( "ContinuumPro", configuration.getChild( "plexusApplicationName" ).getValue() );

        // Plugin1 [antlr]
    }
4808#public Xpp3DomAttributePointer( NodePointer parent, Map.Entry<String, String> attrib )
    {
        super( parent );
        this.attrib = attrib;
    }
4809#@Override
    public int compareChildNodePointers( NodePointer pointer1, NodePointer pointer2 )
    {
        // should never happen because attributes have no children
        return 0;
    }
4810#@Override
    public Object getValue()
    {
        return attrib.getValue();
    }
4811#@Override
    public Object getBaseValue()
    {
        return attrib;
    }
4812#@Override
    public Object getImmediateNode()
    {
        return attrib;
    }
4813#@Override
    public int getLength()
    {
        return 1;
    }
4814#@Override
    public QName getName()
    {
        return new QName( null, attrib.getKey() );
    }
4815#@Override
    public boolean isActual()
    {
        return true;
    }
4816#@Override
    public boolean isCollection()
    {
        return false;
    }
4817#@Override
    public boolean isLeaf()
    {
        return true;
    }
4818#@Override
    public void setValue( Object value )
    {
        throw new UnsupportedOperationException();
    }
4819#public Xpp3DomNodePointer( Xpp3Dom node )
    {
        super( null );
        this.node = node;
    }
4820#public Xpp3DomNodePointer( NodePointer parent, Xpp3Dom node )
    {
        super( parent );
        this.node = node;
    }
4821#@Override
    public int compareChildNodePointers( NodePointer pointer1, NodePointer pointer2 )
    {
        Xpp3Dom node1 = (Xpp3Dom) pointer1.getBaseValue();
        Xpp3Dom node2 = (Xpp3Dom) pointer2.getBaseValue();
        if ( node1 == node2 )
        {
            return 0;
        }
        for ( int i = 0; i < node.getChildCount(); i++ )
        {
            Xpp3Dom child = node.getChild( i );
            if ( child == node1 )
            {
                return -1;
            }
            if ( child == node2 )
            {
                return 1;
            }
        }
        return 0;
    }
4822#@Override
    public Object getValue()
    {
        return getValue(node);
    }
4823#private static Object getValue( Xpp3Dom node )
    {
        if ( node.getValue() != null )
        {
            return node.getValue().trim();
        }
        else
        {
            List<Object> children = new ArrayList<Object>();
            for ( int i = 0; i < node.getChildCount(); i++ )
            {
                children.add( getValue( node.getChild( i ) ) );
            }
            return children;
        }
    }
4824#@Override
    public Object getBaseValue()
    {
        return node;
    }
4825#@Override
    public Object getImmediateNode()
    {
        return node;
    }
4826#@Override
    public int getLength()
    {
        return 1;
    }
4827#@Override
    public QName getName()
    {
        return new QName( null, node.getName() );
    }
4828#@Override
    public boolean isCollection()
    {
        return false;
    }
4829#@Override
    public boolean isLeaf()
    {
        return node.getChildCount() <= 0;
    }
4830#@Override
    public void setValue( Object value )
    {
        throw new UnsupportedOperationException();
    }
4831#@Override
    public NodeIterator childIterator( NodeTest test, boolean reverse, NodePointer startWith )
    {
        return new Xpp3DomNodeIterator( this, test, reverse, startWith );
    }
4832#@Override
    public NodeIterator attributeIterator( QName qname )
    {
        return new Xpp3DomAttributeIterator( this, qname );
    }
4833#public Xpp3DomNodeIterator( NodePointer parent, NodeTest test, boolean reverse, NodePointer startWith )
    {
        this.parent = parent;
        this.node = (Xpp3Dom) parent.getNode();
        this.children = this.node.getChildren();
        if ( startWith != null )
        {
            for ( ; filteredIndex < children.length; filteredIndex++ )
            {
                if ( startWith.equals( children[filteredIndex] ) )
                {
                    filteredIndex++;
                    break;
                }
            }
        }
        this.test = test;
        if ( reverse )
        {
            throw new UnsupportedOperationException();
        }
    }
4834#public NodePointer getNodePointer()
    {
        if ( position == 0 )
        {
            setPosition( 1 );
        }
        return ( child == null ) ? null : new Xpp3DomNodePointer( parent, child );
    }
4835#public int getPosition()
    {
        return position;
    }
4836#public boolean setPosition( int position )
    {
        this.position = position;
        filterChildren( position );
        child = ( position > 0 && position <= filteredChildren.size() ) ? filteredChildren.get( position - 1 ) : null;
        return child != null;
    }
4837#private void filterChildren( int position )
    {
        for ( ; position > filteredChildren.size() && filteredIndex < children.length; filteredIndex++ )
        {
            Xpp3Dom child = children[filteredIndex];
            if ( testNode( child ) )
            {
                filteredChildren.add( child );
            }
        }
    }
4838#private boolean testNode( Xpp3Dom node )
    {
        if ( test == null )
        {
            return true;
        }
        if ( test instanceof NodeNameTest )
        {
            String nodeName = node.getName();
            if ( StringUtils.isEmpty( nodeName ) )
            {
                return false;
            }

            NodeNameTest nodeNameTest = (NodeNameTest) test;
            String namespaceURI = nodeNameTest.getNamespaceURI();
            boolean wildcard = nodeNameTest.isWildcard();
            String testName = nodeNameTest.getNodeName().getName();
            String testPrefix = nodeNameTest.getNodeName().getPrefix();
            if ( wildcard && testPrefix == null )
            {
                return true;
            }
            if ( wildcard || testName.equals( nodeName ) )
            {
                return StringUtils.isEmpty( namespaceURI ) || StringUtils.isEmpty( testPrefix );
            }
            return false;
        }
        if ( test instanceof NodeTypeTest )
        {
            switch ( ( (NodeTypeTest) test ).getNodeType() )
            {
                case Compiler.NODE_TYPE_NODE:
                    return true;
                case Compiler.NODE_TYPE_TEXT:
                    return node.getValue() != null;
                default:
                    return false;
            }
        }
        return false;
    }
4839#public int getOrder()
    {
        return 200;
    }
4840#public NodePointer createNodePointer( QName name, Object object, Locale locale )
    {
        if ( object instanceof Xpp3Dom )
        {
            return new Xpp3DomNodePointer( (Xpp3Dom) object );
        }
        return null;
    }
4841#public NodePointer createNodePointer( NodePointer parent, QName name, Object object )
    {
        if ( object instanceof Xpp3Dom )
        {
            return new Xpp3DomNodePointer( parent, (Xpp3Dom) object );
        }
        return null;
    }
4842#public PomTestWrapper( File pomFile, MavenProject mavenProject )
    {
        if ( mavenProject == null )
        {
            throw new IllegalArgumentException( "mavenProject: null" );
        }
        this.mavenProject = mavenProject;
        this.pomFile = pomFile;
        context = JXPathContext.newContext( mavenProject.getModel() );
    }
4843#public PomTestWrapper( MavenProject mavenProject )
    {
        if ( mavenProject == null )
        {
            throw new IllegalArgumentException( "mavenProject: null" );
        }
        this.mavenProject = mavenProject;
        context = JXPathContext.newContext( mavenProject.getModel() );
    }
4844#public MavenProject getMavenProject()
    {
        return mavenProject;
    }
4845#public File getBasedir()
    {
        return ( pomFile != null ) ? pomFile.getParentFile() : null;
    }
4846#public void setValueOnModel( String expression, Object value )
    {
        context.setValue( expression, value );
    }
4847#/*
    public int containerCountForUri( String uri )
        throws IOException
    {
        if ( uri == null || uri.trim().equals( "" ) )
        {
            throw new IllegalArgumentException( "uri: null or empty" );
        }
        ModelDataSource source = new DefaultModelDataSource();
        source.init( domainModel.getModelProperties(), null );
        return source.queryFor( uri ).size();
    }
	*/

	public Iterator<?> getIteratorForXPathExpression( String expression )
    {
        return context.iterate( expression );
    }
4848#public boolean containsXPathExpression( String expression )
    {
        return context.getValue( expression ) != null;
    }
4849#public Object getValue( String expression )
    {
        try
        {
            return context.getValue( expression );
        }
        catch ( JXPathNotFoundException e )
        {
            return null;
        }
    }
4850#public boolean xPathExpressionEqualsValue( String expression, String value )
    {
        return context.getValue( expression ) != null && context.getValue( expression ).equals( value );
    }
4851#public Xpp3DomAttributeIterator( NodePointer parent, QName qname )
    {
        this.parent = parent;
        this.node = (Xpp3Dom) parent.getNode();

        Map<String, String> map = new LinkedHashMap<String, String>();
        for ( String name : this.node.getAttributeNames() )
        {
            if ( name.equals( qname.getName() ) || "*".equals( qname.getName() ) )
            {
                String value = this.node.getAttribute( name );
                map.put( name, value );
            }
        }
        this.attributes = new ArrayList<Map.Entry<String, String>>( map.entrySet() );
    }
4852#public NodePointer getNodePointer()
    {
        if ( position == 0 )
        {
            setPosition( 1 );
        }
        return ( attribute == null ) ? null : new Xpp3DomAttributePointer( parent, attribute );
    }
4853#public int getPosition()
    {
        return position;
    }
4854#public boolean setPosition( int position )
    {
        this.position = position;
        attribute = ( position > 0 && position <= attributes.size() ) ? attributes.get( position - 1 ) : null;
        return attribute != null;
    }
4855#public TestRepositoryConnector( RemoteRepository repository )
    {
        this.repository = repository;
        try
        {
            basedir = FileUtils.toFile( new URL( repository.getUrl() ) );
        }
        catch ( MalformedURLException e )
        {
            throw new IllegalStateException( e );
        }
    }
4856#public void close()
    {
    }
4857#public void get( Collection<? extends ArtifactDownload> artifactDownloads,
                     Collection<? extends MetadataDownload> metadataDownloads )
    {
        if ( artifactDownloads != null )
        {
            for ( ArtifactDownload download : artifactDownloads )
            {
                File remoteFile = new File( basedir, path( download.getArtifact() ) );
                try
                {
                    FileUtils.copyFile( remoteFile, download.getFile() );
                }
                catch ( IOException e )
                {
                    if ( !remoteFile.exists() )
                    {
                        download.setException( new ArtifactNotFoundException( download.getArtifact(), repository ) );
                    }
                    else
                    {
                        download.setException( new ArtifactTransferException( download.getArtifact(), repository, e ) );
                    }
                }
            }
        }
    }
4858#private String path( Artifact artifact )
    {
        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getGroupId().replace( '.', '/' ) ).append( '/' );

        path.append( artifact.getArtifactId() ).append( '/' );

        path.append( artifact.getBaseVersion() ).append( '/' );

        path.append( artifact.getArtifactId() ).append( '-' ).append( artifact.getVersion() );

        if ( artifact.getClassifier().length() > 0 )
        {
            path.append( '-' ).append( artifact.getClassifier() );
        }

        path.append( '.' ).append( artifact.getExtension() );

        return path.toString();
    }
4859#public void put( Collection<? extends ArtifactUpload> artifactUploads,
                     Collection<? extends MetadataUpload> metadataUploads )
    {
        // TODO Auto-generated method stub

    }
4860#public RepositoryConnector newInstance( RepositorySystemSession session, RemoteRepository repository )
        throws NoRepositoryConnectorException
    {
        return new TestRepositoryConnector( repository );
    }
4861#public int getPriority()
    {
        return 0;
    }
4862#public String getId()
    {
        return "legacy";
    }
4863#public String pathOf( Artifact artifact )
    {
        ArtifactHandler artifactHandler = artifact.getArtifactHandler();

        StringBuilder path = new StringBuilder( 128 );

        path.append( artifact.getGroupId() ).append( '/' );
        path.append( artifactHandler.getDirectory() ).append( '/' );
        path.append( artifact.getArtifactId() ).append( '-' ).append( artifact.getVersion() );

        if ( artifact.hasClassifier() )
        {
            path.append( '-' ).append( artifact.getClassifier() );
        }

        if ( artifactHandler.getExtension() != null && artifactHandler.getExtension().length() > 0 )
        {
            path.append( '.' ).append( artifactHandler.getExtension() );
        }

        return path.toString();
    }
4864#public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata,
                                                 ArtifactRepository repository )
    {
        return pathOfRepositoryMetadata( metadata, metadata.getLocalFilename( repository ) );
    }
4865#private String pathOfRepositoryMetadata( ArtifactMetadata metadata,
                                             String filename )
    {
        StringBuilder path = new StringBuilder( 128 );

        path.append( metadata.getGroupId() ).append( PATH_SEPARATOR ).append( "poms" ).append( PATH_SEPARATOR );

        path.append( filename );

        return path.toString();
    }
4866#public String pathOfRemoteRepositoryMetadata( ArtifactMetadata metadata )
    {
        return pathOfRepositoryMetadata( metadata, metadata.getRemoteFilename() );
    }
4867#public ArtifactRepository buildArtifactRepository( Repository repository )
        throws InvalidRepositoryException
    {
        return new MavenArtifactRepository( repository.getId(), repository.getUrl(), new DefaultRepositoryLayout(),
                                            new ArtifactRepositoryPolicy(), new ArtifactRepositoryPolicy() );
    }
4868#public Artifact createArtifact( String groupId, String artifactId, String version, String packaging )
    {
        return createArtifact( groupId, artifactId, version, null, packaging );
    }
4869#public Artifact createArtifact( String groupId, String artifactId, String version, String scope, String type )
    {
        return new DefaultArtifact( groupId, artifactId, version, scope, type, null, new TestArtifactHandler( type ) );
    }
4870#public ArtifactRepository createArtifactRepository( String id, String url,
                                                        ArtifactRepositoryLayout repositoryLayout,
                                                        ArtifactRepositoryPolicy snapshots,
                                                        ArtifactRepositoryPolicy releases )
    {
        return new MavenArtifactRepository( id, url, repositoryLayout, snapshots, releases );
    }
4871#public Artifact createArtifactWithClassifier( String groupId, String artifactId, String version, String type,
                                                  String classifier )
    {
        return new DefaultArtifact( groupId, artifactId, version, null, type, classifier,
                                    new TestArtifactHandler( type ) );
    }
4872#public ArtifactRepository createDefaultLocalRepository()
        throws InvalidRepositoryException
    {
        return createLocalRepository( new File( System.getProperty( "basedir", "" ), "target/local-repo" ).getAbsoluteFile() );
    }
4873#public ArtifactRepository createDefaultRemoteRepository()
        throws InvalidRepositoryException
    {
        return new MavenArtifactRepository( DEFAULT_REMOTE_REPO_ID, "file://"
            + new File( System.getProperty( "basedir", "" ), "src/test/remote-repo" ).toURI().getPath(),
                                            new DefaultRepositoryLayout(), new ArtifactRepositoryPolicy(),
                                            new ArtifactRepositoryPolicy() );
    }
4874#public Artifact createDependencyArtifact( Dependency dependency )
    {
        Artifact artifact =
            new DefaultArtifact( dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion(),
                                 dependency.getScope(), dependency.getType(), dependency.getClassifier(),
                                 new TestArtifactHandler( dependency.getType() ) );

        if ( Artifact.SCOPE_SYSTEM.equals( dependency.getScope() ) )
        {
            artifact.setFile( new File( dependency.getSystemPath() ) );
            artifact.setResolved( true );
        }

        return artifact;
    }
4875#public ArtifactRepository createLocalRepository( File localRepository )
        throws InvalidRepositoryException
    {
        return new MavenArtifactRepository( DEFAULT_LOCAL_REPO_ID, "file://" + localRepository.toURI().getPath(),
                                            new DefaultRepositoryLayout(), new ArtifactRepositoryPolicy(),
                                            new ArtifactRepositoryPolicy() );
    }
4876#public Artifact createPluginArtifact( Plugin plugin )
    {
        return new DefaultArtifact( plugin.getGroupId(), plugin.getArtifactId(), plugin.getVersion(), null,
                                    "maven-plugin", null, new TestArtifactHandler( "maven-plugin", "jar" ) );
    }
4877#public Artifact createProjectArtifact( String groupId, String artifactId, String version )
    {
        return createArtifact( groupId, artifactId, version, "pom" );
    }
4878#public List<ArtifactRepository> getEffectiveRepositories( List<ArtifactRepository> repositories )
    {
        return repositories;
    }
4879#public Mirror getMirror( ArtifactRepository repository, List<Mirror> mirrors )
    {
        return null;
    }
4880#public void injectAuthentication( List<ArtifactRepository> repositories, List<Server> servers )
    {
    }
4881#public void injectMirror( List<ArtifactRepository> repositories, List<Mirror> mirrors )
    {
    }
4882#public void injectProxy( List<ArtifactRepository> repositories, List<Proxy> proxies )
    {
    }
4883#public void publish( ArtifactRepository repository, File source, String remotePath,
                         ArtifactTransferListener transferListener )
        throws ArtifactTransferFailedException
    {
        // TODO Auto-generated method stub

    }
4884#public ArtifactResolutionResult resolve( ArtifactResolutionRequest request )
    {
        ArtifactResolutionResult result = new ArtifactResolutionResult();

        if ( request.isResolveRoot() )
        {
            try
            {
                resolve( request.getArtifact(), request );
                result.addArtifact( request.getArtifact() );
            }
            catch ( IOException e )
            {
                result.addMissingArtifact( request.getArtifact() );
            }
        }

        if ( request.isResolveTransitively() )
        {
            Map<String, Artifact> artifacts = new LinkedHashMap<String, Artifact>();

            if ( request.getArtifactDependencies() != null )
            {
                for ( Artifact artifact : request.getArtifactDependencies() )
                {
                    artifacts.put( artifact.getDependencyConflictId(), artifact );
                }
            }

            List<Dependency> dependencies = new ArrayList<Dependency>();
            if ( request.getArtifact() instanceof ArtifactWithDependencies )
            {
                dependencies = ( (ArtifactWithDependencies) request.getArtifact() ).getDependencies();
            }
            else
            {
                Artifact pomArtifact =
                    createProjectArtifact( request.getArtifact().getGroupId(), request.getArtifact().getArtifactId(),
                                           request.getArtifact().getVersion() );
                File pomFile =
                    new File( request.getLocalRepository().getBasedir(),
                              request.getLocalRepository().pathOf( pomArtifact ) );

                try
                {
                    Model model = modelReader.read( pomFile, null );

                    dependencies = model.getDependencies();
                }
                catch ( IOException e )
                {
                    e.printStackTrace();
                }
            }

            for ( Dependency dependency : dependencies )
            {
                Artifact artifact = createDependencyArtifact( dependency );
                if ( !artifacts.containsKey( artifact.getDependencyConflictId() ) )
                {
                    artifacts.put( artifact.getDependencyConflictId(), artifact );
                }
            }

            for ( Artifact artifact : artifacts.values() )
            {
                try
                {
                    resolve( artifact, request );
                    result.addArtifact( artifact );
                }
                catch ( IOException e )
                {
                    result.addMissingArtifact( artifact );
                }
            }
        }

        return result;
    }
4885#private void resolve( Artifact artifact, ArtifactResolutionRequest request )
        throws IOException
    {
        if ( Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )
        {
            return;
        }

        ArtifactRepository localRepo = request.getLocalRepository();

        File localFile = new File( localRepo.getBasedir(), localRepo.pathOf( artifact ) );

        artifact.setFile( localFile );

        if ( !localFile.exists() )
        {
            if ( request.getRemoteRepositories().isEmpty() )
            {
                throw new IOException( localFile + " does not exist and no remote repositories are configured" );
            }

            ArtifactRepository remoteRepo = request.getRemoteRepositories().get( 0 );

            File remoteFile = new File( remoteRepo.getBasedir(), remoteRepo.pathOf( artifact ) );

            FileUtils.copyFile( remoteFile, localFile );
        }

        artifact.setResolved( true );
    }
4886#public void retrieve( ArtifactRepository repository, File destination, String remotePath,
                          ArtifactTransferListener transferListener )
        throws ArtifactTransferFailedException, ArtifactDoesNotExistException
    {
        // TODO Auto-generated method stub

    }
4887#public void injectMirror( RepositorySystemSession session, List<ArtifactRepository> repositories )
    {
    }
4888#public void injectProxy( RepositorySystemSession session, List<ArtifactRepository> repositories )
    {
    }
4889#public void injectAuthentication( RepositorySystemSession session, List<ArtifactRepository> repositories )
    {
    }
4890#public TestArtifactHandler( String type )
    {
        this( type, type );
    }
4891#public TestArtifactHandler( String type, String extension )
    {
        this.type = type;
        this.extension = extension;
    }
4892#public String getClassifier()
    {
        return null;
    }
4893#public String getDirectory()
    {
        return getPackaging() + "s";
    }
4894#public String getExtension()
    {
        return extension;
    }
4895#public String getLanguage()
    {
        return "java";
    }
4896#public String getPackaging()
    {
        return type;
    }
4897#public boolean isAddedToClasspath()
    {
        return true;
    }
4898#public boolean isIncludesDependencies()
    {
        return false;
    }
4899#public void testGetMavenVersion()
        throws Exception
    {
        RuntimeInformation rtInfo = lookup( RuntimeInformation.class );

        String mavenVersion = rtInfo.getMavenVersion();
        assertNotNull( mavenVersion );
        assertTrue( mavenVersion.length() > 0 );
    }
4900#public void testIsMavenVersion()
        throws Exception
    {
        RuntimeInformation rtInfo = lookup( RuntimeInformation.class );

        assertTrue( rtInfo.isMavenVersion( "2.0" ) );
        assertFalse( rtInfo.isMavenVersion( "9.9" ) );

        assertTrue( rtInfo.isMavenVersion( "[2.0.11,2.1.0),[3.0,)" ) );
        assertFalse( rtInfo.isMavenVersion( "[9.0,)" ) );

        try
        {
            rtInfo.isMavenVersion( "[3.0," );
            fail( "Bad version range wasn't rejected" );
        }
        catch ( IllegalArgumentException e )
        {
            assertTrue( true );
        }

        try
        {
            rtInfo.isMavenVersion( "" );
            fail( "Bad version range wasn't rejected" );
        }
        catch ( IllegalArgumentException e )
        {
            assertTrue( true );
        }

        try
        {
            rtInfo.isMavenVersion( null );
            fail( "Bad version range wasn't rejected" );
        }
        catch ( IllegalArgumentException e )
        {
            assertTrue( true );
        }
    }
4901#public void testShouldAppendRecessivePluginGroupIds()
    {
        Settings dominant = new Settings();
        dominant.addPluginGroup( "org.apache.maven.plugins" );
        dominant.addPluginGroup( "org.codehaus.modello" );

        Settings recessive = new Settings();
        recessive.addPluginGroup( "org.codehaus.plexus" );

        SettingsUtils.merge( dominant, recessive, Settings.GLOBAL_LEVEL );

        List pluginGroups = dominant.getPluginGroups();

        assertNotNull( pluginGroups );
        assertEquals( 3, pluginGroups.size() );
        assertEquals( "org.apache.maven.plugins", pluginGroups.get( 0 ) );
        assertEquals( "org.codehaus.modello", pluginGroups.get( 1 ) );
        assertEquals( "org.codehaus.plexus", pluginGroups.get( 2 ) );
    }
4902#protected void setUp()
        throws Exception
    {
        testDirectory = new File( getBasedir(), BASE_POM_DIR );
        projectBuilder = (DefaultProjectBuilder) lookup( ProjectBuilder.class );
        repositorySystem = lookup( RepositorySystem.class );
    }
4903#@Override
    protected void tearDown()
        throws Exception
    {
        projectBuilder = null;

        super.tearDown();
    }
4904#public void testSettingsNoPom() throws Exception
    {
        PomTestWrapper pom = buildPom( "settings-no-pom" );
        assertEquals( "local-profile-prop-value", pom.getValue( "properties/local-profile-prop" ) );
    }
4905#/**MNG-4107 */
    public void testPomAndSettingsInterpolation() throws Exception
    {
        PomTestWrapper pom = buildPom( "test-pom-and-settings-interpolation" );
        assertEquals( "applied", pom.getValue( "properties/settingsProfile" ) );
        assertEquals( "applied", pom.getValue( "properties/pomProfile" ) );
        assertEquals( "settings", pom.getValue( "properties/pomVsSettings" ) );
        assertEquals( "settings", pom.getValue( "properties/pomVsSettingsInterpolated" ) );
    }
4906#/**MNG-4107 */
    public void testRepositories() throws Exception
    {
        PomTestWrapper pom = buildPom( "repositories" );
        assertEquals( "maven-core-it-0", pom.getValue( "repositories[1]/id" ) );
    }
4907#private PomTestWrapper buildPom( String pomPath )
        throws Exception
    {
        File pomFile = new File( testDirectory + File.separator + pomPath, "pom.xml" );
        File settingsFile = new File( testDirectory + File.separator + pomPath, "settings.xml" );
        Settings settings = readSettingsFile( settingsFile );

        ProjectBuildingRequest config = new DefaultProjectBuildingRequest();

        for ( org.apache.maven.settings.Profile rawProfile : settings.getProfiles() )
        {
            Profile profile = SettingsUtils.convertFromSettingsProfile( rawProfile );
            config.addProfile( profile );
        }

        String localRepoUrl =
            System.getProperty( "maven.repo.local", System.getProperty( "user.home" ) + "/.m2/repository" );
        localRepoUrl = "file://" + localRepoUrl;
        config.setLocalRepository( repositorySystem.createArtifactRepository( "local", localRepoUrl,
                                                                              new DefaultRepositoryLayout(), null, null ) );
        config.setActiveProfileIds( settings.getActiveProfiles() );
        MavenRepositorySystemSession repoSession = new MavenRepositorySystemSession();
        repoSession.setLocalRepositoryManager( new SimpleLocalRepositoryManager(
                                                                                 new File(
                                                                                           config.getLocalRepository().getBasedir() ) ) );
        config.setRepositorySession( repoSession );

        return new PomTestWrapper( pomFile, projectBuilder.build( pomFile, config ).getProject() );
    }
4908#private static Settings readSettingsFile( File settingsFile )
        throws IOException, XmlPullParserException
    {
        Settings settings = null;

        Reader reader = null;

        try
        {
            reader = ReaderFactory.newXmlReader( settingsFile );

            SettingsXpp3Reader modelReader = new SettingsXpp3Reader();

            settings = modelReader.read( reader );
        }
        finally
        {
            IOUtil.close( reader );
        }

        return settings;
    }
4909#public RequirementMatcherFactoryTest( String testName )
    {
        super( testName );
    }
4910#/**
     * Test of createExactMatcher method, of class RequirementMatcherFactory.
     */
    public void testCreateExactMatcher()
    {
        RequirementMatcher matcher;
        matcher = RequirementMatcherFactory.createExactMatcher( "foo" );
        assertFalse( matcher.matches( "bar" ) );
        assertFalse( matcher.matches( "foobar" ) );
        assertFalse( matcher.matches( "foob" ) );
        assertTrue( matcher.matches( "foo" ) );
    }
4911#/**
     * Test of createVersionMatcher method, of class RequirementMatcherFactory.
     */
    public void testCreateVersionMatcher()
    {
        RequirementMatcher matcher;
        matcher = RequirementMatcherFactory.createVersionMatcher( "1.5.2" );
        assertFalse( matcher.matches( "1.5" ) );
        assertTrue( matcher.matches( "1.5.2" ) );
        assertFalse( matcher.matches( "[1.4,1.5)" ) );
        assertFalse( matcher.matches( "[1.5,1.5.2)" ) );
        assertFalse( matcher.matches( "(1.5.2,1.6)" ) );
        assertTrue( matcher.matches( "(1.4,1.5.2]" ) );
        assertTrue( matcher.matches( "(1.5,)" ) );
    }
4912#public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
4913#/**
     * Create the test case
     *
     * @param testName name of the test case
     */
    public AppTest( String testName )
    {
        super( testName );
    }
4914#/**
     * @return the suite of tests being tested
     */
    public static Test suite()
    {
        return new TestSuite( AppTest.class );
    }
4915#/**
     * Rigourous Test :-)
     */
    public void testApp()
    {
        assertTrue( true );
    }
4916#public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
4917#/**
     * Create the test case
     *
     * @param testName name of the test case
     */
    public AppTest( String testName )
    {
        super( testName );
    }
4918#/**
     * @return the suite of tests being tested
     */
    public static Test suite()
    {
        return new TestSuite( AppTest.class );
    }
4919#/**
     * Rigourous Test :-)
     */
    public void testApp()
    {
        assertTrue( true );
    }
4920#public MavenCli()
    {
        this( null );
    }
4921#// This supports painless invocation by the Verifier during embedded execution of the core ITs
    public MavenCli( ClassWorld classWorld )
    {
        this.classWorld = classWorld;
    }
4922#public static void main( String[] args )
    {
        int result = main( args, null );

        System.exit( result );
    }
4923#/** @noinspection ConfusingMainMethod */
    public static int main( String[] args, ClassWorld classWorld )
    {
        MavenCli cli = new MavenCli();
        return cli.doMain( new CliRequest( args, classWorld ) );
    }
4924#// TODO: need to externalize CliRequest
    public static int doMain( String[] args, ClassWorld classWorld )
    {
        MavenCli cli = new MavenCli();
        return cli.doMain( new CliRequest( args, classWorld ) );
    }
4925#// This supports painless invocation by the Verifier during embedded execution of the core ITs
    public int doMain( String[] args, String workingDirectory, PrintStream stdout, PrintStream stderr )
    {
        PrintStream oldout = System.out;
        PrintStream olderr = System.err;

        try
        {
            if ( stdout != null )
            {
                System.setOut( stdout );
            }
            if ( stderr != null )
            {
                System.setErr( stderr );
            }

            CliRequest cliRequest = new CliRequest( args, classWorld );
            cliRequest.workingDirectory = workingDirectory;

            return doMain( cliRequest );
        }
        finally
        {
            System.setOut( oldout );
            System.setErr( olderr );
        }
    }
4926#// TODO: need to externalize CliRequest
    public int doMain( CliRequest cliRequest )
    {
        try
        {
            initialize( cliRequest );
            // Need to process cli options first to get possible logging options
            cli( cliRequest );
            logging( cliRequest );
            version( cliRequest );
            properties( cliRequest );
            container( cliRequest );
            commands( cliRequest );
            settings( cliRequest );
            populateRequest( cliRequest );
            encryption( cliRequest );
            return execute( cliRequest );
        }
        catch( ExitException e )
        {
            return e.exitCode;
        }
        catch ( UnrecognizedOptionException e )
        {
            // pure user error, suppress stack trace
            return 1;
        }
        catch ( BuildAbort e )
        {
            CLIReportingUtils.showError( logger, "ABORTED", e, cliRequest.showErrors );

            return 2;
        }
        catch ( Exception e )
        {
            CLIReportingUtils.showError( logger, "Error executing Maven.", e, cliRequest.showErrors );

            return 1;
        }
        finally
        {
            if ( cliRequest.fileStream != null )
            {
                cliRequest.fileStream.close();
            }
        }
    }
4927#private void initialize( CliRequest cliRequest )
    {
        if ( cliRequest.workingDirectory == null )
        {
            cliRequest.workingDirectory = System.getProperty( "user.dir" );
        }

        //
        // Make sure the Maven home directory is an absolute path to save us from confusion with say drive-relative
        // Windows paths.
        //
        String mavenHome = System.getProperty( "maven.home" );

        if ( mavenHome != null )
        {
            System.setProperty( "maven.home", new File( mavenHome ).getAbsolutePath() );
        }
    }
4928#//
    // Logging needs to be handled in a standard way at the container level.
    //
    private void logging( CliRequest cliRequest )
    {
        cliRequest.debug = cliRequest.commandLine.hasOption( CLIManager.DEBUG );
        cliRequest.quiet = !cliRequest.debug && cliRequest.commandLine.hasOption( CLIManager.QUIET );
        cliRequest.showErrors = cliRequest.debug || cliRequest.commandLine.hasOption( CLIManager.ERRORS );

        if ( cliRequest.debug )
        {
            cliRequest.request.setLoggingLevel( MavenExecutionRequest.LOGGING_LEVEL_DEBUG );
        }
        else if ( cliRequest.quiet )
        {
            // TODO: we need to do some more work here. Some plugins use sys out or log errors at info level.
            // Ideally, we could use Warn across the board
            cliRequest.request.setLoggingLevel( MavenExecutionRequest.LOGGING_LEVEL_ERROR );
            // TODO:Additionally, we can't change the mojo level because the component key includes the version and
            // it isn't known ahead of time. This seems worth changing.
        }
        else
        {
            cliRequest.request.setLoggingLevel( MavenExecutionRequest.LOGGING_LEVEL_INFO );
        }

        if ( cliRequest.commandLine.hasOption( CLIManager.LOG_FILE ) )
        {
            File logFile = new File( cliRequest.commandLine.getOptionValue( CLIManager.LOG_FILE ) );
            logFile = resolveFile( logFile, cliRequest.workingDirectory );

            try
            {
                cliRequest.fileStream = new PrintStream( logFile );

                System.setOut( cliRequest.fileStream );
                System.setErr( cliRequest.fileStream );
            }
            catch ( FileNotFoundException e )
            {
                System.err.println( e );
            }
        }
    }
4929#//
    // Every bit of information taken from the CLI should be processed here.
    //
    private void cli( CliRequest cliRequest )
        throws Exception
    {
        CLIManager cliManager = new CLIManager();

        try
        {
            cliRequest.commandLine = cliManager.parse( cliRequest.args );
        }
        catch ( ParseException e )
        {
            System.err.println( "Unable to parse command line options: " + e.getMessage() );
            cliManager.displayHelp( System.out );
            throw e;
        }

        // TODO: these should be moved out of here. Wrong place.
        //
        if ( cliRequest.commandLine.hasOption( CLIManager.HELP ) )
        {
            cliManager.displayHelp( System.out );
            throw new ExitException( 0 );
        }

        if ( cliRequest.commandLine.hasOption( CLIManager.VERSION ) )
        {
            CLIReportingUtils.showVersion( System.out );
            throw new ExitException( 0 );
        }
    }
4930#private void version( CliRequest cliRequest )
    {
        if ( cliRequest.debug || cliRequest.commandLine.hasOption( CLIManager.SHOW_VERSION ) )
        {
            CLIReportingUtils.showVersion( System.out );
        }
    }
4931#private void commands( CliRequest cliRequest )
    {
        if ( cliRequest.showErrors )
        {
            logger.info( "Error stacktraces are turned on." );
        }

        if ( MavenExecutionRequest.CHECKSUM_POLICY_WARN.equals( cliRequest.request.getGlobalChecksumPolicy() ) )
        {
            logger.info( "Disabling strict checksum verification on all artifact downloads." );
        }
        else if ( MavenExecutionRequest.CHECKSUM_POLICY_FAIL.equals( cliRequest.request.getGlobalChecksumPolicy() ) )
        {
            logger.info( "Enabling strict checksum verification on all artifact downloads." );
        }
    }
4932#private void properties( CliRequest cliRequest )
    {
        populateProperties( cliRequest.commandLine, cliRequest.systemProperties, cliRequest.userProperties );
    }
4933#private void container( CliRequest cliRequest )
        throws Exception
    {
        if ( cliRequest.classWorld == null )
        {
            cliRequest.classWorld = new ClassWorld( "plexus.core", Thread.currentThread().getContextClassLoader() );
        }

        DefaultPlexusContainer container = this.container;

        if ( container == null )
        {
            logger = setupLogger( cliRequest );

            ContainerConfiguration cc = new DefaultContainerConfiguration()
                .setClassWorld( cliRequest.classWorld )
                .setRealm( setupContainerRealm( cliRequest ) )
                .setName( "maven" );

            container = new DefaultPlexusContainer( cc );

            // NOTE: To avoid inconsistencies, we'll use the TCCL exclusively for lookups
            container.setLookupRealm( null );

            container.setLoggerManager( new MavenLoggerManager( logger ) );

            customizeContainer( container );

            if ( cliRequest.classWorld == classWorld )
            {
                this.container = container;
            }
        }

        container.getLoggerManager().setThresholds( cliRequest.request.getLoggingLevel() );

        Thread.currentThread().setContextClassLoader( container.getContainerRealm() );

        eventSpyDispatcher = container.lookup( EventSpyDispatcher.class );

        DefaultEventSpyContext eventSpyContext = new DefaultEventSpyContext();
        Map<String, Object> data = eventSpyContext.getData();
        data.put( "plexus", container );
        data.put( "workingDirectory", cliRequest.workingDirectory );
        data.put( "systemProperties", cliRequest.systemProperties );
        data.put( "userProperties", cliRequest.userProperties );
        data.put( "versionProperties", CLIReportingUtils.getBuildProperties() );
        eventSpyDispatcher.init( eventSpyContext );

        // refresh logger in case container got customized by spy
        logger = container.getLoggerManager().getLoggerForComponent( MavenCli.class.getName(), null );

        maven = container.lookup( Maven.class );

        executionRequestPopulator = container.lookup( MavenExecutionRequestPopulator.class );

        modelProcessor = createModelProcessor( container );

        settingsBuilder = container.lookup( SettingsBuilder.class );

        dispatcher = (DefaultSecDispatcher) container.lookup( SecDispatcher.class, "maven" );
    }
4934#private PrintStreamLogger setupLogger( CliRequest cliRequest )
    {
        PrintStreamLogger logger = new PrintStreamLogger( new PrintStreamLogger.Provider()
        {
            public PrintStream getStream()
            {
                return System.out;
            }
        } );

        logger.setThreshold( cliRequest.request.getLoggingLevel() );

        return logger;
    }
4935#private ClassRealm setupContainerRealm( CliRequest cliRequest )
        throws Exception
    {
        ClassRealm containerRealm = null;

        String extClassPath = cliRequest.userProperties.getProperty( EXT_CLASS_PATH );
        if ( extClassPath == null )
        {
            extClassPath = cliRequest.systemProperties.getProperty( EXT_CLASS_PATH );
        }

        if ( StringUtils.isNotEmpty( extClassPath ) )
        {
            String[] jars = StringUtils.split( extClassPath, File.pathSeparator );

            if ( jars.length > 0 )
            {
                ClassRealm coreRealm = cliRequest.classWorld.getClassRealm( "plexus.core" );
                if ( coreRealm == null )
                {
                    coreRealm = (ClassRealm) cliRequest.classWorld.getRealms().iterator().next();
                }

                ClassRealm extRealm = cliRequest.classWorld.newRealm( "maven.ext", null );

                logger.debug( "Populating class realm " + extRealm.getId() );

                for ( String jar : jars )
                {
                    File file = resolveFile( new File( jar ), cliRequest.workingDirectory );

                    logger.debug( "  Included " + file );

                    extRealm.addURL( file.toURI().toURL() );
                }

                extRealm.setParentRealm( coreRealm );

                containerRealm = extRealm;
            }
        }

        return containerRealm;
    }
4936#protected void customizeContainer( PlexusContainer container )
    {
    }
4937#//
    // This should probably be a separate tool and not be baked into Maven.
    //
    private void encryption( CliRequest cliRequest )
        throws Exception
    {
        if ( cliRequest.commandLine.hasOption( CLIManager.ENCRYPT_MASTER_PASSWORD ) )
        {
            String passwd = cliRequest.commandLine.getOptionValue( CLIManager.ENCRYPT_MASTER_PASSWORD );

            DefaultPlexusCipher cipher = new DefaultPlexusCipher();

            System.out.println( cipher.encryptAndDecorate( passwd, DefaultSecDispatcher.SYSTEM_PROPERTY_SEC_LOCATION ) );

            throw new ExitException( 0 );
        }
        else if ( cliRequest.commandLine.hasOption( CLIManager.ENCRYPT_PASSWORD ) )
        {
            String passwd = cliRequest.commandLine.getOptionValue( CLIManager.ENCRYPT_PASSWORD );

            String configurationFile = dispatcher.getConfigurationFile();

            if ( configurationFile.startsWith( "~" ) )
            {
                configurationFile = System.getProperty( "user.home" ) + configurationFile.substring( 1 );
            }

            String file = System.getProperty( DefaultSecDispatcher.SYSTEM_PROPERTY_SEC_LOCATION, configurationFile );

            String master = null;

            SettingsSecurity sec = SecUtil.read( file, true );
            if ( sec != null )
            {
                master = sec.getMaster();
            }

            if ( master == null )
            {
                throw new IllegalStateException( "Master password is not set in the setting security file: " + file );
            }

            DefaultPlexusCipher cipher = new DefaultPlexusCipher();
            String masterPasswd = cipher.decryptDecorated( master, DefaultSecDispatcher.SYSTEM_PROPERTY_SEC_LOCATION );
            System.out.println( cipher.encryptAndDecorate( passwd, masterPasswd ) );

            throw new ExitException( 0 );
        }
    }
4938#private int execute( CliRequest cliRequest )
    {
        eventSpyDispatcher.onEvent( cliRequest.request );

        MavenExecutionResult result = maven.execute( cliRequest.request );

        eventSpyDispatcher.onEvent( result );

        eventSpyDispatcher.close();

        if ( result.hasExceptions() )
        {
            ExceptionHandler handler = new DefaultExceptionHandler();

            Map<String, String> references = new LinkedHashMap<String, String>();

            MavenProject project = null;

            for ( Throwable exception : result.getExceptions() )
            {
                ExceptionSummary summary = handler.handleException( exception );

                logSummary( summary, references, "", cliRequest.showErrors );

                if ( project == null && exception instanceof LifecycleExecutionException )
                {
                    project = ( (LifecycleExecutionException) exception ).getProject();
                }
            }

            logger.error( "" );

            if ( !cliRequest.showErrors )
            {
                logger.error( "To see the full stack trace of the errors, re-run Maven with the -e switch." );
            }
            if ( !logger.isDebugEnabled() )
            {
                logger.error( "Re-run Maven using the -X switch to enable full debug logging." );
            }

            if ( !references.isEmpty() )
            {
                logger.error( "" );
                logger.error( "For more information about the errors and possible solutions"
                              + ", please read the following articles:" );

                for ( Map.Entry<String, String> entry : references.entrySet() )
                {
                    logger.error( entry.getValue() + " " + entry.getKey() );
                }
            }

            if ( project != null && !project.equals( result.getTopologicallySortedProjects().get( 0 ) ) )
            {
                logger.error( "" );
                logger.error( "After correcting the problems, you can resume the build with the command" );
                logger.error( "  mvn <goals> -rf :" + project.getArtifactId() );
            }

            if ( MavenExecutionRequest.REACTOR_FAIL_NEVER.equals( cliRequest.request.getReactorFailureBehavior() ) )
            {
                logger.info( "Build failures were ignored." );

                return 0;
            }
            else
            {
                return 1;
            }
        }
        else
        {
            return 0;
        }
    }
4939#private void logSummary( ExceptionSummary summary, Map<String, String> references, String indent,
                             boolean showErrors )
    {
        String referenceKey = "";

        if ( StringUtils.isNotEmpty( summary.getReference() ) )
        {
            referenceKey = references.get( summary.getReference() );
            if ( referenceKey == null )
            {
                referenceKey = "[Help " + ( references.size() + 1 ) + "]";
                references.put( summary.getReference(), referenceKey );
            }
        }

        String msg = summary.getMessage();

        if ( StringUtils.isNotEmpty( referenceKey ) )
        {
            if ( msg.indexOf( '\n' ) < 0 )
            {
                msg += " -> " + referenceKey;
            }
            else
            {
                msg += "\n-> " + referenceKey;
            }
        }

        String[] lines = msg.split( "(\r\n)|(\r)|(\n)" );

        for ( int i = 0; i < lines.length; i++ )
        {
            String line = indent + lines[i].trim();

            if ( i == lines.length - 1 && ( showErrors || ( summary.getException() instanceof InternalErrorException ) ) )
            {
                logger.error( line, summary.getException() );
            }
            else
            {
                logger.error( line );
            }
        }

        indent += "  ";

        for ( ExceptionSummary child : summary.getChildren() )
        {
            logSummary( child, references, indent, showErrors );
        }
    }
4940#protected ModelProcessor createModelProcessor( PlexusContainer container )
        throws ComponentLookupException
    {
        return container.lookup( ModelProcessor.class );
    }
4941#private void settings( CliRequest cliRequest )
        throws Exception
    {
        File userSettingsFile;

        if ( cliRequest.commandLine.hasOption( CLIManager.ALTERNATE_USER_SETTINGS ) )
        {
            userSettingsFile = new File( cliRequest.commandLine.getOptionValue( CLIManager.ALTERNATE_USER_SETTINGS ) );
            userSettingsFile = resolveFile( userSettingsFile, cliRequest.workingDirectory );

            if ( !userSettingsFile.isFile() )
            {
                throw new FileNotFoundException( "The specified user settings file does not exist: "
                    + userSettingsFile );
            }
        }
        else
        {
            userSettingsFile = DEFAULT_USER_SETTINGS_FILE;
        }

        File globalSettingsFile;

        if ( cliRequest.commandLine.hasOption( CLIManager.ALTERNATE_GLOBAL_SETTINGS ) )
        {
            globalSettingsFile =
                new File( cliRequest.commandLine.getOptionValue( CLIManager.ALTERNATE_GLOBAL_SETTINGS ) );
            globalSettingsFile = resolveFile( globalSettingsFile, cliRequest.workingDirectory );

            if ( !globalSettingsFile.isFile() )
            {
                throw new FileNotFoundException( "The specified global settings file does not exist: "
                    + globalSettingsFile );
            }
        }
        else
        {
            globalSettingsFile = DEFAULT_GLOBAL_SETTINGS_FILE;
        }

        cliRequest.request.setGlobalSettingsFile( globalSettingsFile );
        cliRequest.request.setUserSettingsFile( userSettingsFile );

        SettingsBuildingRequest settingsRequest = new DefaultSettingsBuildingRequest();
        settingsRequest.setGlobalSettingsFile( globalSettingsFile );
        settingsRequest.setUserSettingsFile( userSettingsFile );
        settingsRequest.setSystemProperties( cliRequest.systemProperties );
        settingsRequest.setUserProperties( cliRequest.userProperties );

        eventSpyDispatcher.onEvent( settingsRequest );

        logger.debug( "Reading global settings from "
            + getSettingsLocation( settingsRequest.getGlobalSettingsSource(), settingsRequest.getGlobalSettingsFile() ) );
        logger.debug( "Reading user settings from "
            + getSettingsLocation( settingsRequest.getUserSettingsSource(), settingsRequest.getUserSettingsFile() ) );

        SettingsBuildingResult settingsResult = settingsBuilder.build( settingsRequest );

        eventSpyDispatcher.onEvent( settingsResult );

        executionRequestPopulator.populateFromSettings( cliRequest.request, settingsResult.getEffectiveSettings() );

        if ( !settingsResult.getProblems().isEmpty() && logger.isWarnEnabled() )
        {
            logger.warn( "" );
            logger.warn( "Some problems were encountered while building the effective settings" );

            for ( SettingsProblem problem : settingsResult.getProblems() )
            {
                logger.warn( problem.getMessage() + " @ " + problem.getLocation() );
            }

            logger.warn( "" );
        }
    }
4942#private Object getSettingsLocation( SettingsSource source, File file )
    {
        if ( source != null )
        {
            return source.getLocation();
        }
        return file;
    }
4943#private MavenExecutionRequest populateRequest( CliRequest cliRequest )
    {
        MavenExecutionRequest request = cliRequest.request;
        CommandLine commandLine = cliRequest.commandLine;
        String workingDirectory = cliRequest.workingDirectory;
        boolean quiet = cliRequest.quiet;
        boolean showErrors = cliRequest.showErrors;

        String[] deprecatedOptions = { "up", "npu", "cpu", "npr" };
        for ( String deprecatedOption : deprecatedOptions )
        {
            if ( commandLine.hasOption( deprecatedOption ) )
            {
                logger.warn( "Command line option -" + deprecatedOption
                    + " is deprecated and will be removed in future Maven versions." );
            }
        }

        // ----------------------------------------------------------------------
        // Now that we have everything that we need we will fire up plexus and
        // bring the maven component to life for use.
        // ----------------------------------------------------------------------

        if ( commandLine.hasOption( CLIManager.BATCH_MODE ) )
        {
            request.setInteractiveMode( false );
        }

        boolean noSnapshotUpdates = false;
        if ( commandLine.hasOption( CLIManager.SUPRESS_SNAPSHOT_UPDATES ) )
        {
            noSnapshotUpdates = true;
        }

        // ----------------------------------------------------------------------
        //
        // ----------------------------------------------------------------------

        @SuppressWarnings("unchecked")
        List<String> goals = commandLine.getArgList();

        boolean recursive = true;

        // this is the default behavior.
        String reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_FAST;

        if ( commandLine.hasOption( CLIManager.NON_RECURSIVE ) )
        {
            recursive = false;
        }

        if ( commandLine.hasOption( CLIManager.FAIL_FAST ) )
        {
            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_FAST;
        }
        else if ( commandLine.hasOption( CLIManager.FAIL_AT_END ) )
        {
            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_AT_END;
        }
        else if ( commandLine.hasOption( CLIManager.FAIL_NEVER ) )
        {
            reactorFailureBehaviour = MavenExecutionRequest.REACTOR_FAIL_NEVER;
        }

        if ( commandLine.hasOption( CLIManager.OFFLINE ) )
        {
            request.setOffline( true );
        }

        boolean updateSnapshots = false;

        if ( commandLine.hasOption( CLIManager.UPDATE_SNAPSHOTS ) )
        {
            updateSnapshots = true;
        }

        String globalChecksumPolicy = null;

        if ( commandLine.hasOption( CLIManager.CHECKSUM_FAILURE_POLICY ) )
        {
            globalChecksumPolicy = MavenExecutionRequest.CHECKSUM_POLICY_FAIL;
        }
        else if ( commandLine.hasOption( CLIManager.CHECKSUM_WARNING_POLICY ) )
        {
            globalChecksumPolicy = MavenExecutionRequest.CHECKSUM_POLICY_WARN;
        }

        File baseDirectory = new File( workingDirectory, "" ).getAbsoluteFile();

        // ----------------------------------------------------------------------
        // Profile Activation
        // ----------------------------------------------------------------------

        List<String> activeProfiles = new ArrayList<String>();

        List<String> inactiveProfiles = new ArrayList<String>();

        if ( commandLine.hasOption( CLIManager.ACTIVATE_PROFILES ) )
        {
            String[] profileOptionValues = commandLine.getOptionValues( CLIManager.ACTIVATE_PROFILES );
            if ( profileOptionValues != null )
            {
                for ( int i = 0; i < profileOptionValues.length; ++i )
                {
                    StringTokenizer profileTokens = new StringTokenizer( profileOptionValues[i], "," );

                    while ( profileTokens.hasMoreTokens() )
                    {
                        String profileAction = profileTokens.nextToken().trim();

                        if ( profileAction.startsWith( "-" ) || profileAction.startsWith( "!" ) )
                        {
                            inactiveProfiles.add( profileAction.substring( 1 ) );
                        }
                        else if ( profileAction.startsWith( "+" ) )
                        {
                            activeProfiles.add( profileAction.substring( 1 ) );
                        }
                        else
                        {
                            activeProfiles.add( profileAction );
                        }
                    }
                }
            }
        }

        TransferListener transferListener;

        if ( quiet )
        {
            transferListener = new QuietMavenTransferListener();
        }
        else if ( request.isInteractiveMode() )
        {
            transferListener = new ConsoleMavenTransferListener( System.out );
        }
        else
        {
            transferListener = new BatchModeMavenTransferListener( System.out );
        }

        ExecutionListener executionListener = new ExecutionEventLogger( logger );
        executionListener = eventSpyDispatcher.chainListener( executionListener );

        String alternatePomFile = null;
        if ( commandLine.hasOption( CLIManager.ALTERNATE_POM_FILE ) )
        {
            alternatePomFile = commandLine.getOptionValue( CLIManager.ALTERNATE_POM_FILE );
        }

        File userToolchainsFile;
        if ( commandLine.hasOption( CLIManager.ALTERNATE_USER_TOOLCHAINS ) )
        {
            userToolchainsFile = new File( commandLine.getOptionValue( CLIManager.ALTERNATE_USER_TOOLCHAINS ) );
            userToolchainsFile = resolveFile( userToolchainsFile, workingDirectory );
        }
        else
        {
            userToolchainsFile = MavenCli.DEFAULT_USER_TOOLCHAINS_FILE;
        }

        request.setBaseDirectory( baseDirectory ).setGoals( goals )
            .setSystemProperties( cliRequest.systemProperties )
            .setUserProperties( cliRequest.userProperties )
            .setReactorFailureBehavior( reactorFailureBehaviour ) // default: fail fast
            .setRecursive( recursive ) // default: true
            .setShowErrors( showErrors ) // default: false
            .addActiveProfiles( activeProfiles ) // optional
            .addInactiveProfiles( inactiveProfiles ) // optional
            .setExecutionListener( executionListener )
            .setTransferListener( transferListener ) // default: batch mode which goes along with interactive
            .setUpdateSnapshots( updateSnapshots ) // default: false
            .setNoSnapshotUpdates( noSnapshotUpdates ) // default: false
            .setGlobalChecksumPolicy( globalChecksumPolicy ) // default: warn
            .setUserToolchainsFile( userToolchainsFile );

        if ( alternatePomFile != null )
        {
            File pom = resolveFile( new File( alternatePomFile ), workingDirectory );

            request.setPom( pom );
        }
        else
        {
            File pom = modelProcessor.locatePom( baseDirectory );

            if ( pom.isFile() )
            {
                request.setPom( pom );
            }
        }

        if ( ( request.getPom() != null ) && ( request.getPom().getParentFile() != null ) )
        {
            request.setBaseDirectory( request.getPom().getParentFile() );
        }

        if ( commandLine.hasOption( CLIManager.RESUME_FROM ) )
        {
            request.setResumeFrom( commandLine.getOptionValue( CLIManager.RESUME_FROM ) );
        }

        if ( commandLine.hasOption( CLIManager.PROJECT_LIST ) )
        {
            String[] values = commandLine.getOptionValues( CLIManager.PROJECT_LIST );
            List<String> projects = new ArrayList<String>();
            for ( int i = 0; i < values.length; i++ )
            {
                String[] tmp = StringUtils.split( values[i], "," );
                projects.addAll( Arrays.asList( tmp ) );
            }
            request.setSelectedProjects( projects );
        }

        if ( commandLine.hasOption( CLIManager.ALSO_MAKE )
                        && !commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )
        {
            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_UPSTREAM );
        }
        else if ( !commandLine.hasOption( CLIManager.ALSO_MAKE )
                        && commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )
        {
            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_DOWNSTREAM );
        }
        else if ( commandLine.hasOption( CLIManager.ALSO_MAKE )
                        && commandLine.hasOption( CLIManager.ALSO_MAKE_DEPENDENTS ) )
        {
            request.setMakeBehavior( MavenExecutionRequest.REACTOR_MAKE_BOTH );
        }

        String localRepoProperty = request.getUserProperties().getProperty( MavenCli.LOCAL_REPO_PROPERTY );

        if ( localRepoProperty == null )
        {
            localRepoProperty = request.getSystemProperties().getProperty( MavenCli.LOCAL_REPO_PROPERTY );
        }

        if ( localRepoProperty != null )
        {
            request.setLocalRepositoryPath( localRepoProperty );
        }

        final String threadConfiguration = commandLine.hasOption( CLIManager.THREADS )
            ? commandLine.getOptionValue( CLIManager.THREADS )
            : request.getSystemProperties().getProperty(
                MavenCli.THREADS_DEPRECATED ); // TODO: Remove this setting. Note that the int-tests use it

        if ( threadConfiguration != null )
        {
            request.setPerCoreThreadCount( threadConfiguration.contains( "C" ) );
            if ( threadConfiguration.contains( "W" ) )
            {
                LifecycleWeaveBuilder.setWeaveMode( request.getUserProperties() );
            }
            request.setThreadCount( threadConfiguration.replace( "C", "" ).replace( "W", "" ).replace( "auto", "" ) );
        }

        request.setCacheNotFound( true );
        request.setCacheTransferError( false );

        return request;
    }
4944#static File resolveFile( File file, String workingDirectory )
    {
        if ( file == null )
        {
            return null;
        }
        else if ( file.isAbsolute() )
        {
            return file;
        }
        else if ( file.getPath().startsWith( File.separator ) )
        {
            // drive-relative Windows path
            return file.getAbsoluteFile();
        }
        else
        {
            return new File( workingDirectory, file.getPath() ).getAbsoluteFile();
        }
    }
4945#// ----------------------------------------------------------------------
    // System properties handling
    // ----------------------------------------------------------------------

    static void populateProperties( CommandLine commandLine, Properties systemProperties, Properties userProperties )
    {
        EnvironmentUtils.addEnvVars( systemProperties );

        // ----------------------------------------------------------------------
        // Options that are set on the command line become system properties
        // and therefore are set in the session properties. System properties
        // are most dominant.
        // ----------------------------------------------------------------------

        if ( commandLine.hasOption( CLIManager.SET_SYSTEM_PROPERTY ) )
        {
            String[] defStrs = commandLine.getOptionValues( CLIManager.SET_SYSTEM_PROPERTY );

            if ( defStrs != null )
            {
                for ( int i = 0; i < defStrs.length; ++i )
                {
                    setCliProperty( defStrs[i], userProperties );
                }
            }
        }

        systemProperties.putAll( System.getProperties() );
        
        // ----------------------------------------------------------------------
        // Properties containing info about the currently running version of Maven
        // These override any corresponding properties set on the command line
        // ----------------------------------------------------------------------

        Properties buildProperties = CLIReportingUtils.getBuildProperties();

        String mavenVersion = buildProperties.getProperty( CLIReportingUtils.BUILD_VERSION_PROPERTY );
        systemProperties.setProperty( "maven.version", mavenVersion );

        String mavenBuildVersion = CLIReportingUtils.createMavenVersionString( buildProperties );
        systemProperties.setProperty( "maven.build.version", mavenBuildVersion );
    }
4946#private static void setCliProperty( String property, Properties properties )
    {
        String name;

        String value;

        int i = property.indexOf( "=" );

        if ( i <= 0 )
        {
            name = property.trim();

            value = "true";
        }
        else
        {
            name = property.substring( 0, i ).trim();

            value = property.substring( i + 1 );
        }

        properties.setProperty( name, value );

        // ----------------------------------------------------------------------
        // I'm leaving the setting of system properties here as not to break
        // the SystemPropertyProfileActivator. This won't harm embedding. jvz.
        // ----------------------------------------------------------------------

        System.setProperty( name, value );
    }
4947#CliRequest( String[] args, ClassWorld classWorld )
        {
            this.args = args;
            this.classWorld = classWorld;
            this.request = new DefaultMavenExecutionRequest();
        }
4948#public ExitException( int exitCode )
        {
            this.exitCode = exitCode;
        }
4949#@SuppressWarnings( "static-access" )
    public CLIManager()
    {
        options = new Options();
        options.addOption( OptionBuilder.withLongOpt( "help" ).withDescription( "Display help information" ).create( HELP ) );
        options.addOption( OptionBuilder.withLongOpt( "file" ).hasArg().withDescription( "Force the use of an alternate POM file." ).create( ALTERNATE_POM_FILE ) );
        options.addOption( OptionBuilder.withLongOpt( "define" ).hasArg().withDescription( "Define a system property" ).create( SET_SYSTEM_PROPERTY ) );
        options.addOption( OptionBuilder.withLongOpt( "offline" ).withDescription( "Work offline" ).create( OFFLINE ) );
        options.addOption( OptionBuilder.withLongOpt( "version" ).withDescription( "Display version information" ).create( VERSION ) );
        options.addOption( OptionBuilder.withLongOpt( "quiet" ).withDescription( "Quiet output - only show errors" ).create( QUIET ) );
        options.addOption( OptionBuilder.withLongOpt( "debug" ).withDescription( "Produce execution debug output" ).create( DEBUG ) );
        options.addOption( OptionBuilder.withLongOpt( "errors" ).withDescription( "Produce execution error messages" ).create( ERRORS ) );
        options.addOption( OptionBuilder.withLongOpt( "non-recursive" ).withDescription( "Do not recurse into sub-projects" ).create( NON_RECURSIVE ) );
        options.addOption( OptionBuilder.withLongOpt( "update-snapshots" ).withDescription( "Forces a check for updated releases and snapshots on remote repositories" ).create( UPDATE_SNAPSHOTS ) );
        options.addOption( OptionBuilder.withLongOpt( "activate-profiles" ).withDescription( "Comma-delimited list of profiles to activate" ).hasArg().create( ACTIVATE_PROFILES ) );
        options.addOption( OptionBuilder.withLongOpt( "batch-mode" ).withDescription( "Run in non-interactive (batch) mode" ).create( BATCH_MODE ) );
        options.addOption( OptionBuilder.withLongOpt( "no-snapshot-updates" ).withDescription( "Suppress SNAPSHOT updates" ).create( SUPRESS_SNAPSHOT_UPDATES ) );
        options.addOption( OptionBuilder.withLongOpt( "strict-checksums" ).withDescription( "Fail the build if checksums don't match" ).create( CHECKSUM_FAILURE_POLICY ) );
        options.addOption( OptionBuilder.withLongOpt( "lax-checksums" ).withDescription( "Warn if checksums don't match" ).create( CHECKSUM_WARNING_POLICY ) );
        options.addOption( OptionBuilder.withLongOpt( "settings" ).withDescription( "Alternate path for the user settings file" ).hasArg().create( ALTERNATE_USER_SETTINGS ) );
        options.addOption( OptionBuilder.withLongOpt( "global-settings" ).withDescription( "Alternate path for the global settings file" ).hasArg().create( ALTERNATE_GLOBAL_SETTINGS ) );
        options.addOption( OptionBuilder.withLongOpt( "toolchains" ).withDescription( "Alternate path for the user toolchains file" ).hasArg().create( ALTERNATE_USER_TOOLCHAINS ) );
        options.addOption( OptionBuilder.withLongOpt( "fail-fast" ).withDescription( "Stop at first failure in reactorized builds" ).create( FAIL_FAST ) );
        options.addOption( OptionBuilder.withLongOpt( "fail-at-end" ).withDescription( "Only fail the build afterwards; allow all non-impacted builds to continue" ).create( FAIL_AT_END ) );
        options.addOption( OptionBuilder.withLongOpt( "fail-never" ).withDescription( "NEVER fail the build, regardless of project result" ).create( FAIL_NEVER ) );
        options.addOption( OptionBuilder.withLongOpt( "resume-from" ).hasArg().withDescription( "Resume reactor from specified project" ).create( RESUME_FROM ) );
        options.addOption( OptionBuilder.withLongOpt( "projects" ).withDescription( "Comma-delimited list of specified reactor projects to build instead of all projects. A project can be specified by [groupId]:artifactId or by its relative path." ).hasArg().create( PROJECT_LIST ) );
        options.addOption( OptionBuilder.withLongOpt( "also-make" ).withDescription( "If project list is specified, also build projects required by the list" ).create( ALSO_MAKE ) );
        options.addOption( OptionBuilder.withLongOpt( "also-make-dependents" ).withDescription( "If project list is specified, also build projects that depend on projects on the list" ).create( ALSO_MAKE_DEPENDENTS ) );
        options.addOption( OptionBuilder.withLongOpt( "log-file" ).hasArg().withDescription( "Log file to where all build output will go." ).create( LOG_FILE ) );
        options.addOption( OptionBuilder.withLongOpt( "show-version" ).withDescription( "Display version information WITHOUT stopping build" ).create( SHOW_VERSION ) );
        options.addOption( OptionBuilder.withLongOpt( "encrypt-master-password" ).hasArg().withDescription( "Encrypt master security password" ).create( ENCRYPT_MASTER_PASSWORD ) );
        options.addOption( OptionBuilder.withLongOpt( "encrypt-password" ).hasArg().withDescription( "Encrypt server password" ).create( ENCRYPT_PASSWORD ) );
        options.addOption( OptionBuilder.withLongOpt( "threads" ).hasArg().withDescription( "Thread count, for instance 2.0C where C is core multiplied" ).create( THREADS ) );

        // Adding this back in for compatibility with the verifier that hard codes this option.

        options.addOption( OptionBuilder.withLongOpt( "no-plugin-registry" ).withDescription( "Ineffective, only kept for backward compatibility" ).create( "npr" ) );
        options.addOption( OptionBuilder.withLongOpt( "check-plugin-updates" ).withDescription( "Ineffective, only kept for backward compatibility" ).create( "cpu" ) );
        options.addOption( OptionBuilder.withLongOpt( "update-plugins" ).withDescription( "Ineffective, only kept for backward compatibility" ).create( "up" ) );
        options.addOption( OptionBuilder.withLongOpt( "no-plugin-updates" ).withDescription( "Ineffective, only kept for backward compatibility" ).create( "npu" ) );
    }
4950#public CommandLine parse( String[] args )
        throws ParseException
    {
        // We need to eat any quotes surrounding arguments...
        String[] cleanArgs = cleanArgs( args );

        CommandLineParser parser = new GnuParser();

        return parser.parse( options, cleanArgs );
    }
4951#private String[] cleanArgs( String[] args )
    {
        List<String> cleaned = new ArrayList<String>();

        StringBuilder currentArg = null;

        for ( int i = 0; i < args.length; i++ )
        {
            String arg = args[i];

            boolean addedToBuffer = false;

            if ( arg.startsWith( "\"" ) )
            {
                // if we're in the process of building up another arg, push it and start over.
                // this is for the case: "-Dfoo=bar "-Dfoo2=bar two" (note the first unterminated quote)
                if ( currentArg != null )
                {
                    cleaned.add( currentArg.toString() );
                }

                // start building an argument here.
                currentArg = new StringBuilder( arg.substring( 1 ) );
                addedToBuffer = true;
            }

            // this has to be a separate "if" statement, to capture the case of: "-Dfoo=bar"
            if ( arg.endsWith( "\"" ) )
            {
                String cleanArgPart = arg.substring( 0, arg.length() - 1 );

                // if we're building an argument, keep doing so.
                if ( currentArg != null )
                {
                    // if this is the case of "-Dfoo=bar", then we need to adjust the buffer.
                    if ( addedToBuffer )
                    {
                        currentArg.setLength( currentArg.length() - 1 );
                    }
                    // otherwise, we trim the trailing " and append to the buffer.
                    else
                    {
                        // TODO: introducing a space here...not sure what else to do but collapse whitespace
                        currentArg.append( ' ' ).append( cleanArgPart );
                    }

                    cleaned.add( currentArg.toString() );
                }
                else
                {
                    cleaned.add( cleanArgPart );
                }

                currentArg = null;

                continue;
            }

            // if we haven't added this arg to the buffer, and we ARE building an argument
            // buffer, then append it with a preceding space...again, not sure what else to
            // do other than collapse whitespace.
            // NOTE: The case of a trailing quote is handled by nullifying the arg buffer.
            if ( !addedToBuffer )
            {
                if ( currentArg != null )
                {
                    currentArg.append( ' ' ).append( arg );
                }
                else
                {
                    cleaned.add( arg );
                }
            }
        }

        if ( currentArg != null )
        {
            cleaned.add( currentArg.toString() );
        }

        int cleanedSz = cleaned.size();

        String[] cleanArgs = null;

        if ( cleanedSz == 0 )
        {
            cleanArgs = args;
        }
        else
        {
            cleanArgs = cleaned.toArray( new String[cleanedSz] );
        }

        return cleanArgs;
    }
4952#public void displayHelp( PrintStream stdout )
    {
        stdout.println();

        PrintWriter pw = new PrintWriter( stdout );

        HelpFormatter formatter = new HelpFormatter();

        formatter.printHelp( pw, HelpFormatter.DEFAULT_WIDTH, "mvn [options] [<goal(s)>] [<phase(s)>]", "\nOptions:",
                             options, HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, "\n", false );

        pw.flush();
    }
4953#public static void showVersion( PrintStream stdout )
    {
        Properties properties = getBuildProperties();
        stdout.println( createMavenVersionString( properties ) );
        String shortName = reduce( properties.getProperty( "distributionShortName" ) );

        stdout.println( shortName + " home: " + System.getProperty( "maven.home", "<unknown maven home>" ) );

        stdout.println( "Java version: " + System.getProperty( "java.version", "<unknown java version>" )
            + ", vendor: " + System.getProperty( "java.vendor", "<unknown vendor>" ) );

        stdout.println( "Java home: " + System.getProperty( "java.home", "<unknown java home>" ) );

        stdout.println( "Default locale: " + Locale.getDefault() + ", platform encoding: "
            + System.getProperty( "file.encoding", "<unknown encoding>" ) );

        stdout.println( "OS name: \"" + Os.OS_NAME + "\", version: \"" + Os.OS_VERSION + "\", arch: \"" + Os.OS_ARCH
            + "\", family: \"" + Os.OS_FAMILY + "\"" );
    }
4954#/**
     * Create a human readable string containing the Maven version, buildnumber, and time of build
     * 
     * @param buildProperties The build properties
     * @return Readable build info
     */
    static String createMavenVersionString( Properties buildProperties )
    {
        String timestamp = reduce( buildProperties.getProperty( "timestamp" ) );
        String version = reduce( buildProperties.getProperty( BUILD_VERSION_PROPERTY ) );
        String rev = reduce( buildProperties.getProperty( "buildNumber" ) );
        String distributionName = reduce( buildProperties.getProperty( "distributionName" ) );

        String msg = distributionName + " ";
        msg += ( version != null ? version : "<version unknown>" );
        if ( rev != null || timestamp != null )
        {
            msg += " (";
            msg += ( rev != null ? "r" + rev : "" );
            if ( timestamp != null )
            {
                SimpleDateFormat fmt = new SimpleDateFormat( "yyyy-MM-dd HH:mm:ssZ" );
                String ts = fmt.format( new Date( Long.valueOf( timestamp ).longValue() ) );
                msg += ( rev != null ? "; " : "" ) + ts;
            }
            msg += ")";
        }
        return msg;
    }
4955#private static String reduce( String s )
    {
        return ( s != null ? ( s.startsWith( "${" ) && s.endsWith( "}" ) ? null : s ) : null );
    }
4956#private static void stats( Date start, Logger logger )
    {
        Date finish = new Date();

        long time = finish.getTime() - start.getTime();

        logger.info( "Total time: " + formatTime( time ) );

        logger.info( "Finished at: " + finish );

        //noinspection CallToSystemGC
        System.gc();

        Runtime r = Runtime.getRuntime();

        logger.info( "Final Memory: " + ( r.totalMemory() - r.freeMemory() ) / MB + "M/" + r.totalMemory() / MB + "M" );
    }
4957#private static String formatTime( long ms )
    {
        long secs = ms / MS_PER_SEC;

        long min = secs / SEC_PER_MIN;

        secs = secs % SEC_PER_MIN;

        String msg = "";

        if ( min > 1 )
        {
            msg = min + " minutes ";
        }
        else if ( min == 1 )
        {
            msg = "1 minute ";
        }

        if ( secs > 1 )
        {
            msg += secs + " seconds";
        }
        else if ( secs == 1 )
        {
            msg += "1 second";
        }
        else if ( min == 0 )
        {
            msg += "< 1 second";
        }
        return msg;
    }
4958#private static String getFormattedTime( long time )
    {
        String pattern = "s.SSS's'";
        if ( time / 60000L > 0 )
        {
            pattern = "m:s" + pattern;
            if ( time / 3600000L > 0 )
            {
                pattern = "H:m" + pattern;
            }
        }
        DateFormat fmt = new SimpleDateFormat( pattern );
        fmt.setTimeZone( TimeZone.getTimeZone( "UTC" ) );
        return fmt.format( new Date( time ) );
    }
4959#static Properties getBuildProperties()
    {
        Properties properties = new Properties();
        InputStream resourceAsStream = null;
        try
        {
            resourceAsStream = MavenCli.class.getResourceAsStream( "/org/apache/maven/messages/build.properties" );

            if ( resourceAsStream != null )
            {
                properties.load( resourceAsStream );
            }
        }
        catch ( IOException e )
        {
            System.err.println( "Unable determine version from JAR file: " + e.getMessage() );
        }
        finally
        {
            IOUtil.close( resourceAsStream );
        }

        return properties;
    }
4960#public static void showError( Logger logger, String message, Throwable e, boolean showStackTrace )
    {
        if ( logger == null )
        {
            logger = new PrintStreamLogger( System.out );
        }

        if ( showStackTrace )
        {
            logger.error( message, e );
        }
        else
        {
            logger.error( message );

            if ( e != null )
            {
                logger.error( e.getMessage() );

                for ( Throwable cause = e.getCause(); cause != null; cause = cause.getCause() )
                {
                    logger.error( "Caused by: " + cause.getMessage() );
                }
            }
        }
    }
4961#public BatchModeMavenTransferListener( PrintStream out )
    {
        super( out );
    }
4962#public Map<String, Object> getData()
    {
        return data;
    }
4963#public MavenLoggerManager( Logger logger )
    {
        this.logger = logger;
    }
4964#public void initialize()
    {
        debug( "Initializing ConsoleLoggerManager: " + this.hashCode() + "." );

        currentThreshold = parseThreshold( threshold );

        if ( currentThreshold == -1 )
        {
            debug( "Could not parse the threshold level: '" + threshold + "', setting to debug." );
            currentThreshold = Logger.LEVEL_DEBUG;
        }
    }
4965#public void setThreshold( int currentThreshold )
    {
        this.currentThreshold = currentThreshold;
    }
4966#public void setThresholds( int currentThreshold )
    {
        this.currentThreshold = currentThreshold;

        logger.setThreshold( currentThreshold );
    }
4967#/** @return Returns the threshold. */
    public int getThreshold()
    {
        return currentThreshold;
    }
4968#public void setThreshold( String role,
                              String roleHint,
                              int threshold )
    {
    }
4969#public int getThreshold( String role,
                             String roleHint )
    {
        return currentThreshold;
    }
4970#public Logger getLoggerForComponent( String role,
                                         String roleHint )
    {
        return logger;
    }
4971#public void returnComponentLogger( String role,
                                       String roleHint )
    {
    }
4972#public int getActiveLoggerCount()
    {
        return 1;
    }
4973#private int parseThreshold( String text )
    {
        text = text.trim().toLowerCase( Locale.ENGLISH );

        if ( text.equals( "debug" ) )
        {
            return ConsoleLogger.LEVEL_DEBUG;
        }
        else if ( text.equals( "info" ) )
        {
            return ConsoleLogger.LEVEL_INFO;
        }
        else if ( text.equals( "warn" ) )
        {
            return ConsoleLogger.LEVEL_WARN;
        }
        else if ( text.equals( "error" ) )
        {
            return ConsoleLogger.LEVEL_ERROR;
        }
        else if ( text.equals( "fatal" ) )
        {
            return ConsoleLogger.LEVEL_FATAL;
        }

        return -1;
    }
4974#/**
     * Remove this method and all references when this code is verified.
     *
     * @param msg
     */
    private void debug( String msg )
    {
    }
4975#public ConsoleMavenTransferListener( PrintStream out )
    {
        super( out );
    }
4976#@Override
    public void transferProgressed( TransferEvent event )
        throws TransferCancelledException
    {
        TransferResource resource = event.getResource();
        downloads.put( resource, Long.valueOf( event.getTransferredBytes() ) );

        StringBuilder buffer = new StringBuilder( 64 );

        for ( Map.Entry<TransferResource, Long> entry : downloads.entrySet() )
        {
            long total = entry.getKey().getContentLength();
            Long complete = entry.getValue();
            // NOTE: This null check guards against http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6312056
            if ( complete != null )
            {
                buffer.append( getStatus( complete.longValue(), total ) ).append( "  " );
            }
        }

        int pad = lastLength - buffer.length();
        lastLength = buffer.length();
        pad( buffer, pad );
        buffer.append( '\r' );

        out.print( buffer );
    }
4977#private String getStatus( long complete, long total )
    {
        if ( total >= 1024 )
        {
            return toKB( complete ) + "/" + toKB( total ) + " KB ";
        }
        else if ( total >= 0 )
        {
            return complete + "/" + total + " B ";
        }
        else if ( complete >= 1024 )
        {
            return toKB( complete ) + " KB ";
        }
        else
        {
            return complete + " B ";
        }
    }
4978#private void pad( StringBuilder buffer, int spaces )
    {
        String block = "                                        ";
        while ( spaces > 0 )
        {
            int n = Math.min( spaces, block.length() );
            buffer.append( block, 0, n );
            spaces -= n;
        }
    }
4979#@Override
    public void transferSucceeded( TransferEvent event )
    {
        transferCompleted( event );

        super.transferSucceeded( event );
    }
4980#@Override
    public void transferFailed( TransferEvent event )
    {
        transferCompleted( event );

        super.transferFailed( event );
    }
4981#private void transferCompleted( TransferEvent event )
    {
        downloads.remove( event.getResource() );

        StringBuilder buffer = new StringBuilder( 64 );
        pad( buffer, lastLength );
        buffer.append( '\r' );
        out.print( buffer );
    }
4982#protected AbstractMavenTransferListener( PrintStream out )
    {
        this.out = ( out != null ) ? out : System.out;
    }
4983#@Override
    public void transferInitiated( TransferEvent event )
    {
        String message = event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploading" : "Downloading";

        out.println( message + ": " + event.getResource().getRepositoryUrl() + event.getResource().getResourceName() );
    }
4984#@Override
    public void transferCorrupted( TransferEvent event )
        throws TransferCancelledException
    {
        TransferResource resource = event.getResource();

        out.println( "[WARNING] " + event.getException().getMessage() + " for " + resource.getRepositoryUrl()
            + resource.getResourceName() );
    }
4985#@Override
    public void transferSucceeded( TransferEvent event )
    {
        TransferResource resource = event.getResource();
        long contentLength = event.getTransferredBytes();
        if ( contentLength >= 0 )
        {
            String type = ( event.getRequestType() == TransferEvent.RequestType.PUT ? "Uploaded" : "Downloaded" );
            String len = contentLength >= 1024 ? toKB( contentLength ) + " KB" : contentLength + " B";

            String throughput = "";
            long duration = System.currentTimeMillis() - resource.getTransferStartTime();
            if ( duration > 0 )
            {
                DecimalFormat format = new DecimalFormat( "0.0", new DecimalFormatSymbols( Locale.ENGLISH ) );
                double kbPerSec = ( contentLength / 1024.0 ) / ( duration / 1000.0 );
                throughput = " at " + format.format( kbPerSec ) + " KB/sec";
            }

            out.println( type + ": " + resource.getRepositoryUrl() + resource.getResourceName() + " (" + len
                + throughput + ")" );
        }
    }
4986#protected long toKB( long bytes )
    {
        return ( bytes + 1023 ) / 1024;
    }
4987#public ExecutionEventLogger( Logger logger )
    {
        if ( logger == null )
        {
            throw new IllegalArgumentException( "logger missing" );
        }

        this.logger = logger;
    }
4988#private static String chars( char c, int count )
    {
        StringBuilder buffer = new StringBuilder( count );

        for ( int i = count; i > 0; i-- )
        {
            buffer.append( c );
        }

        return buffer.toString();
    }
4989#private static String getFormattedTime( long time )
    {
        // NOTE: DateFormat is not suitable to format timespans of 24h+

        long h = time / ( 60 * 60 * 1000 );
        long m = ( time - h * 60 * 60 * 1000 ) / ( 60 * 1000 );
        long s = ( time - h * 60 * 60 * 1000 - m * 60 * 1000 ) / 1000;
        long ms = time % 1000;

        String format;
        if ( h > 0 )
        {
            format = "%1$d:%2$02d:%3$02d.%4$03ds";
        }
        else if ( m > 0 )
        {
            format = "%2$d:%3$02d.%4$03ds";
        }
        else
        {
            format = "%3$d.%4$03ds";
        }

        return String.format( format, h, m, s, ms );
    }
4990#@Override
    public void projectDiscoveryStarted( ExecutionEvent event )
    {
        if ( logger.isInfoEnabled() )
        {
            logger.info( "Scanning for projects..." );
        }
    }
4991#@Override
    public void sessionStarted( ExecutionEvent event )
    {
        if ( logger.isInfoEnabled() && event.getSession().getProjects().size() > 1 )
        {
            logger.info( chars( '-', LINE_LENGTH ) );

            logger.info( "Reactor Build Order:" );

            logger.info( "" );

            for ( MavenProject project : event.getSession().getProjects() )
            {
                logger.info( project.getName() );
            }
        }
    }
4992#@Override
    public void sessionEnded( ExecutionEvent event )
    {
        if ( logger.isInfoEnabled() )
        {
            if ( event.getSession().getProjects().size() > 1 )
            {
                logReactorSummary( event.getSession() );
            }

            logResult( event.getSession() );

            logStats( event.getSession() );

            logger.info( chars( '-', LINE_LENGTH ) );
        }
    }
4993#private void logReactorSummary( MavenSession session )
    {
        logger.info( chars( '-', LINE_LENGTH ) );

        logger.info( "Reactor Summary:" );

        logger.info( "" );

        MavenExecutionResult result = session.getResult();

        for ( MavenProject project : session.getProjects() )
        {
            StringBuilder buffer = new StringBuilder( 128 );

            buffer.append( project.getName() );

            buffer.append( ' ' );
            while ( buffer.length() < LINE_LENGTH - 21 )
            {
                buffer.append( '.' );
            }
            buffer.append( ' ' );

            BuildSummary buildSummary = result.getBuildSummary( project );

            if ( buildSummary == null )
            {
                buffer.append( "SKIPPED" );
            }
            else if ( buildSummary instanceof BuildSuccess )
            {
                buffer.append( "SUCCESS [" );
                buffer.append( getFormattedTime( buildSummary.getTime() ) );
                buffer.append( "]" );
            }
            else if ( buildSummary instanceof BuildFailure )
            {
                buffer.append( "FAILURE [" );
                buffer.append( getFormattedTime( buildSummary.getTime() ) );
                buffer.append( "]" );
            }

            logger.info( buffer.toString() );
        }
    }
4994#private void logResult( MavenSession session )
    {
        logger.info( chars( '-', LINE_LENGTH ) );

        if ( session.getResult().hasExceptions() )
        {
            logger.info( "BUILD FAILURE" );
        }
        else
        {
            logger.info( "BUILD SUCCESS" );
        }
    }
4995#private void logStats( MavenSession session )
    {
        logger.info( chars( '-', LINE_LENGTH ) );

        Date finish = new Date();

        long time = finish.getTime() - session.getRequest().getStartTime().getTime();

        String wallClock = session.getRequest().isThreadConfigurationPresent() ? " (Wall Clock)" : "";

        logger.info( "Total time: " + getFormattedTime( time ) + wallClock );

        logger.info( "Finished at: " + finish );

        System.gc();

        Runtime r = Runtime.getRuntime();

        long MB = 1024 * 1024;

        logger.info( "Final Memory: " + ( r.totalMemory() - r.freeMemory() ) / MB + "M/" + r.totalMemory() / MB + "M" );
    }
4996#@Override
    public void projectSkipped( ExecutionEvent event )
    {
        if ( logger.isInfoEnabled() )
        {
            logger.info( chars( ' ', LINE_LENGTH ) );
            logger.info( chars( '-', LINE_LENGTH ) );

            logger.info( "Skipping " + event.getProject().getName() );
            logger.info( "This project has been banned from the build due to previous failures." );

            logger.info( chars( '-', LINE_LENGTH ) );
        }
    }
4997#@Override
    public void projectStarted( ExecutionEvent event )
    {
        if ( logger.isInfoEnabled() )
        {
            logger.info( chars( ' ', LINE_LENGTH ) );
            logger.info( chars( '-', LINE_LENGTH ) );

            logger.info( "Building " + event.getProject().getName() + " " + event.getProject().getVersion() );

            logger.info( chars( '-', LINE_LENGTH ) );
        }
    }
4998#@Override
    public void mojoSkipped( ExecutionEvent event )
    {
        if ( logger.isWarnEnabled() )
        {
            logger.warn( "Goal " + event.getMojoExecution().getGoal()
                + " requires online mode for execution but Maven is currently offline, skipping" );
        }
    }
4999#/**
     * <pre>--- mojo-artifactId:version:goal (mojo-executionId) @ project-artifactId ---</pre>
     */
    @Override
    public void mojoStarted( ExecutionEvent event )
    {
        if ( logger.isInfoEnabled() )
        {
            StringBuilder buffer = new StringBuilder( 128 );

            buffer.append( "--- " );
            append( buffer, event.getMojoExecution() );
            append( buffer, event.getProject() );
            buffer.append( " ---" );

            logger.info( "" );
            logger.info( buffer.toString() );
        }
    }
5000#/**
     * <pre>>>> mojo-artifactId:version:goal (mojo-executionId) @ project-artifactId >>></pre>
     */
    @Override
    public void forkStarted( ExecutionEvent event )
    {
        if ( logger.isInfoEnabled() )
        {
            StringBuilder buffer = new StringBuilder( 128 );

            buffer.append( ">>> " );
            append( buffer, event.getMojoExecution() );
            append( buffer, event.getProject() );
            buffer.append( " >>>" );

            logger.info( "" );
            logger.info( buffer.toString() );
        }
    }
5001#/**
     * <pre>&lt;&lt;&lt; mojo-artifactId:version:goal (mojo-executionId) @ project-artifactId &lt;&lt;&lt;</pre>
     */
    @Override
    public void forkSucceeded( ExecutionEvent event )
    {
        if ( logger.isInfoEnabled() )
        {
            StringBuilder buffer = new StringBuilder( 128 );

            buffer.append( "<<< " );
            append( buffer, event.getMojoExecution() );
            append( buffer, event.getProject() );
            buffer.append( " <<<" );

            logger.info( "" );
            logger.info( buffer.toString() );
        }
    }
5002#private void append( StringBuilder buffer, MojoExecution me )
    {
        buffer.append( me.getArtifactId() ).append( ':' ).append( me.getVersion() );
        buffer.append( ':' ).append( me.getGoal() );
        if ( me.getExecutionId() != null )
        {
            buffer.append( " (" ).append( me.getExecutionId() ).append( ')' );
        }
    }
5003#private void append( StringBuilder buffer, MavenProject project )
    {
        buffer.append( " @ " ).append( project.getArtifactId() );
    }
5004#@Override
    public void forkedProjectStarted( ExecutionEvent event )
    {
        if ( logger.isInfoEnabled() && event.getMojoExecution().getForkedExecutions().size() > 1 )
        {
            logger.info( chars( ' ', LINE_LENGTH ) );
            logger.info( chars( '>', LINE_LENGTH ) );

            logger.info( "Forking " + event.getProject().getName() + " " + event.getProject().getVersion() );

            logger.info( chars( '>', LINE_LENGTH ) );
        }
    }
5005#public PrintStreamLogger( Provider provider )
    {
        super( Logger.LEVEL_INFO, Maven.class.getName() );

        if ( provider == null )
        {
            throw new IllegalArgumentException( "output stream provider missing" );
        }
        this.provider = provider;
    }
5006#public PrintStreamLogger( PrintStream out )
    {
        super( Logger.LEVEL_INFO, Maven.class.getName() );

        setStream( out );
    }
5007#public void setStream( final PrintStream out )
    {
        if ( out == null )
        {
            throw new IllegalArgumentException( "output stream missing" );
        }

        this.provider = new Provider()
        {
            public PrintStream getStream()
            {
                return out;
            }
        };
    }
5008#public void debug( String message, Throwable throwable )
    {
        if ( isDebugEnabled() )
        {
            PrintStream out = provider.getStream();

            out.print( DEBUG );
            out.println( message );

            if ( null != throwable )
            {
                throwable.printStackTrace( out );
            }
        }
    }
5009#public void info( String message, Throwable throwable )
    {
        if ( isInfoEnabled() )
        {
            PrintStream out = provider.getStream();

            out.print( INFO );
            out.println( message );

            if ( null != throwable )
            {
                throwable.printStackTrace( out );
            }
        }
    }
5010#public void warn( String message, Throwable throwable )
    {
        if ( isWarnEnabled() )
        {
            PrintStream out = provider.getStream();

            out.print( WARNING );
            out.println( message );

            if ( null != throwable )
            {
                throwable.printStackTrace( out );
            }
        }
    }
5011#public void error( String message, Throwable throwable )
    {
        if ( isErrorEnabled() )
        {
            PrintStream out = provider.getStream();

            out.print( ERROR );
            out.println( message );

            if ( null != throwable )
            {
                throwable.printStackTrace( out );
            }
        }
    }
5012#public void fatalError( String message, Throwable throwable )
    {
        if ( isFatalErrorEnabled() )
        {
            PrintStream out = provider.getStream();

            out.print( FATAL_ERROR );
            out.println( message );

            if ( null != throwable )
            {
                throwable.printStackTrace( out );
            }
        }
    }
5013#public void close()
    {
        PrintStream out = provider.getStream();

        if ( out == System.out || out == System.err )
        {
            out.flush();
        }
        else
        {
            out.close();
        }
    }
5014#public Logger getChildLogger( String arg0 )
    {
        return this;
    }
5015#PrintStream getStream();
5016#public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
5017#/**
     * Create the test case
     *
     * @param testName name of the test case
     */
    public AppTest( String testName )
    {
        super( testName );
    }
5018#/**
     * @return the suite of tests being tested
     */
    public static Test suite()
    {
        return new TestSuite( AppTest.class );
    }
5019#/**
     * Rigourous Test :-)
     */
    public void testApp()
    {
        assertTrue( true );
    }
5020#public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        throw new MojoFailureException( this, "This mojo will always fail.", "This mojo is programmed to fail at all times, to express certain error-reporting functions." );
    }
5021#public Log getLog()
    {
        return log;
    }
5022#public void setLog( Log log )
    {
        this.log = log;
    }
5023#public void execute()
        throws MojoExecutionException, MojoFailureException
    {
    }
5024#public Log getLog()
    {
        return log;
    }
5025#public void setLog( Log log )
    {
        this.log = log;
    }
5026#public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        throw new MojoExecutionException( "This is meant to fail." );
    }
5027#public Log getLog()
    {
        return log;
    }
5028#public void setLog( Log log )
    {
        this.log = log;
    }
5029#public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        throw new MojoExecutionException( "This is meant to fail." );
    }
5030#public Log getLog()
    {
        return log;
    }
5031#public void setLog( Log log )
    {
        this.log = log;
    }
5032#public void execute()
        throws MojoExecutionException, MojoFailureException
    {
    }
5033#public Log getLog()
    {
        return log;
    }
5034#public void setLog( Log log )
    {
        this.log = log;
    }
5035#public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        mavenProjectHelper.attachArtifact( project, "pom", "classifier", project.getFile() );
        mavenProjectHelper.attachArtifact( project, "pom", "classifier", project.getFile() );
    }
5036#public Log getLog()
    {
        return log;
    }
5037#public void setLog( Log log )
    {
        this.log = log;
    }
5038#public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
5039#/**
     * Create the test case
     *
     * @param testName name of the test case
     */
    public AppTest( String testName )
    {
        super( testName );
    }
5040#/**
     * @return the suite of tests being tested
     */
    public static Test suite()
    {
        return new TestSuite( AppTest.class );
    }
5041#/**
     * Rigourous Test :-)
     */
    public void testApp()
    {
        assertTrue( true );
    }
5042#public void execute()
        throws MojoExecutionException, MojoFailureException
    {
    }
5043#public Log getLog()
    {
        return log;
    }
5044#public void setLog( Log log )
    {
        this.log = log;
    }
5045#public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        throw new MojoExecutionException( "This is meant to fail." );
    }
5046#public Log getLog()
    {
        return log;
    }
5047#public void setLog( Log log )
    {
        this.log = log;
    }
5048#public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
5049#public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        throw new MojoFailureException( this, "This mojo will always fail.", "This mojo is programmed to fail at all times, to express certain error-reporting functions." );
    }
5050#public Log getLog()
    {
        return log;
    }
5051#public void setLog( Log log )
    {
        this.log = log;
    }
5052#public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
5053#/**
     * Create the test case
     *
     * @param testName name of the test case
     */
    public AppTest( String testName )
    {
        super( testName );
    }
5054#/**
     * @return the suite of tests being tested
     */
    public static Test suite()
    {
        return new TestSuite( AppTest.class );
    }
5055#/**
     * Rigourous Test :-)
     */
    public void testApp()
    {
        assertTrue( true );
    }
5056#public void execute()
        throws MojoExecutionException, MojoFailureException
    {
    }
5057#public Log getLog()
    {
        return log;
    }
5058#public void setLog( Log log )
    {
        this.log = log;
    }
5059#public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        throw new MojoExecutionException( "This is meant to fail." );
    }
5060#public Log getLog()
    {
        return log;
    }
5061#public void setLog( Log log )
    {
        this.log = log;
    }
5062#public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        throw new MojoExecutionException( "This is meant to fail." );
    }
5063#public Log getLog()
    {
        return log;
    }
5064#public void setLog( Log log )
    {
        this.log = log;
    }
5065#public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        throw new MojoExecutionException( "THIS SHOULD NEVER BE CALLED." );
    }
5066#public Log getLog()
    {
        return log;
    }
5067#public void setLog( Log log )
    {
        this.log = log;
    }
5068#public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
5069#public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
5070#/**
     * Create the test case
     *
     * @param testName name of the test case
     */
    public AppTest( String testName )
    {
        super( testName );
    }
5071#/**
     * @return the suite of tests being tested
     */
    public static Test suite()
    {
        return new TestSuite( AppTest.class );
    }
5072#/**
     * Rigourous Test :-)
     */
    public void testApp()
    {
        assertTrue( true );
    }
5073#public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
        StringUtils utils;
    }
5074#/**
     * Create the test case
     *
     * @param testName name of the test case
     */
    public AppTest( String testName )
    {
        super( testName );
    }
5075#/**
     * @return the suite of tests being tested
     */
    public static Test suite()
    {
        return new TestSuite( AppTest.class );
    }
5076#/**
     * Rigourous Test :-)
     */
    public void testApp()
    {
        assertTrue( true );
    }
5077#public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
5078#/**
     * Create the test case
     *
     * @param testName name of the test case
     */
    public AppTest( String testName )
    {
        super( testName );
    }
5079#/**
     * @return the suite of tests being tested
     */
    public static Test suite()
    {
        return new TestSuite( AppTest.class );
    }
5080#/**
     * Rigourous Test :-)
     */
    public void testApp()
    {
        assertTrue( true );
    }
5081#/**
     * Creates a new container for the specified model.
     * 
     * @param model The model to wrap, may be {@code null}.
     */
    public ModelData( Model model )
    {
        this.model = model;
    }
5082#/**
     * Creates a new container for the specified model.
     * 
     * @param model The model to wrap, may be {@code null}.
     * @param groupId The effective group identifier of the model, may be {@code null}.
     * @param artifactId The effective artifact identifier of the model, may be {@code null}.
     * @param version The effective version of the model, may be {@code null}.
     */
    public ModelData( Model model, String groupId, String artifactId, String version )
    {
        this.model = model;
        setGroupId( groupId );
        setArtifactId( artifactId );
        setVersion( version );
    }
5083#/**
     * Gets the model being wrapped.
     * 
     * @return The model or {@code null} if not set.
     */
    public Model getModel()
    {
        return model;
    }
5084#/**
     * Sets the model being wrapped.
     * 
     * @param model The model, may be {@code null}.
     */
    public void setModel( Model model )
    {
        this.model = model;
    }
5085#/**
     * Gets the raw model being wrapped.
     * 
     * @return The raw model or {@code null} if not set.
     */
    public Model getRawModel()
    {
        return rawModel;
    }
5086#/**
     * Sets the raw model being wrapped.
     * 
     * @param rawModel The raw model, may be {@code null}.
     */
    public void setRawModel( Model rawModel )
    {
        this.rawModel = rawModel;
    }
5087#/**
     * Gets the active profiles from the model.
     * 
     * @return The active profiles or {@code null} if not set.
     */
    public List<Profile> getActiveProfiles()
    {
        return activeProfiles;
    }
5088#/**
     * Sets the active profiles from the model.
     * 
     * @param activeProfiles The active profiles, may be {@code null}.
     */
    public void setActiveProfiles( List<Profile> activeProfiles )
    {
        this.activeProfiles = activeProfiles;
    }
5089#/**
     * Gets the effective group identifier of the model.
     * 
     * @return The effective group identifier of the model or an empty string if unknown, never {@code null}.
     */
    public String getGroupId()
    {
        return ( groupId != null ) ? groupId : "";
    }
5090#/**
     * Sets the effective group identifier of the model.
     * 
     * @param groupId The effective group identifier of the model, may be {@code null}.
     */
    public void setGroupId( String groupId )
    {
        this.groupId = groupId;
    }
5091#/**
     * Gets the effective artifact identifier of the model.
     * 
     * @return The effective artifact identifier of the model or an empty string if unknown, never {@code null}.
     */
    public String getArtifactId()
    {
        return ( artifactId != null ) ? artifactId : "";
    }
5092#/**
     * Sets the effective artifact identifier of the model.
     * 
     * @param artifactId The effective artifact identifier of the model, may be {@code null}.
     */
    public void setArtifactId( String artifactId )
    {
        this.artifactId = artifactId;
    }
5093#/**
     * Gets the effective version of the model.
     * 
     * @return The effective version of the model or an empty string if unknown, never {@code null}.
     */
    public String getVersion()
    {
        return ( version != null ) ? version : "";
    }
5094#/**
     * Sets the effective version of the model.
     * 
     * @param version The effective version of the model, may be {@code null}.
     */
    public void setVersion( String version )
    {
        this.version = version;
    }
5095#/**
     * Gets the effective identifier of the model in the form {@code <groupId>:<artifactId>:<version>}.
     * 
     * @return The effective identifier of the model, never {@code null}.
     */
    public String getId()
    {
        StringBuilder buffer = new StringBuilder( 96 );

        buffer.append( getGroupId() ).append( ':' ).append( getArtifactId() ).append( ':' ).append( getVersion() );

        return buffer.toString();
    }
5096#@Override
    public String toString()
    {
        return String.valueOf( model );
    }
5097#/**
     * Gets the source of the POM to process.
     *
     * @return The source of the POM or {@code null} if not set.
     */
    ModelSource getModelSource();
5098#/**
     * Sets the source of the POM to process. Eventually, either {@link #setModelSource(ModelSource)} or
     * {@link #setPomFile(File)} must be set.
     *
     * @param modelSource The source of the POM to process, may be {@code null}.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setModelSource( ModelSource modelSource );
5099#/**
     * Gets the POM file of the project to build.
     *
     * @return The POM file of the project or {@code null} if not applicable (i.e. when processing a POM from the
     *         repository).
     */
    File getPomFile();
5100#/**
     * Sets the POM file of the project to build. Note that providing the path to a POM file via this method will make
     * the model builder operate in project mode. This mode is meant for effective models that are employed during the
     * build process of a local project. Hence the effective model will support the notion of a project directory. To
     * build the model for a POM from the repository, use {@link #setModelSource(ModelSource)} in combination with a
     * {@link FileModelSource} instead.
     *
     * @param pomFile The POM file of the project to build the effective model for, may be {@code null} to build the
     *            model of some POM from the repository.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setPomFile( File pomFile );
5101#/**
     * Gets the level of validation to perform on processed models.
     *
     * @return The level of validation to perform on processed models.
     */
    int getValidationLevel();
5102#/**
     * Sets the level of validation to perform on processed models. For building of projects,
     * {@link #VALIDATION_LEVEL_STRICT} should be used to ensure proper building. For the mere retrievel of dependencies
     * during artifact resolution, {@link #VALIDATION_LEVEL_MINIMAL} should be used to account for models of poor
     * quality. By default, models are validated in strict mode.
     *
     * @param validationLevel The level of validation to perform on processed models.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setValidationLevel( int validationLevel );
5103#/**
     * Indicates whether plugin executions and configurations should be processed. If enabled, lifecycle-induced plugin
     * executions will be injected into the model and common plugin configuration will be propagated to individual
     * executions.
     *
     * @return {@code true} if plugins should be processed, {@code false} otherwise.
     */
    boolean isProcessPlugins();
5104#/**
     * Controls the processing of plugin executions and configurations.
     *
     * @param processPlugins {@code true} to enable plugin processing, {@code false} otherwise.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setProcessPlugins( boolean processPlugins );
5105#/**
     * Indicates whether the model building should happen in two phases. If enabled, the initial invocation of the model
     * builder will only produce an interim result which may be used to analyze inter-model dependencies before the
     * final invocation of the model builder is performed.
     *
     * @return {@code true} if two-phase building is enabled, {@code false} if the model should be build in a single
     *         step.
     */
    boolean isTwoPhaseBuilding();
5106#/**
     * Enables/disables two-phase building. If enabled, the initial invocation of the model builder will only produce an
     * interim result which may be used to analyze inter-model dependencies before the final invocation of the model
     * builder is performed.
     *
     * @param twoPhaseBuilding {@code true} to enable two-phase building, {@code false} if the model should be build in
     *            a single step.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setTwoPhaseBuilding( boolean twoPhaseBuilding );
5107#/**
     * Indicates whether the model should track the line/column number of the model source from which it was parsed.
     * 
     * @return {@code true} if location tracking is enabled, {@code false} otherwise.
     */
    boolean isLocationTracking();
5108#/**
     * Enables/disables the tracking of line/column numbers for the model source being parsed. By default, input
     * locations are not tracked.
     * 
     * @param locationTracking {@code true} to enable location tracking, {@code false} to disable it.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setLocationTracking( boolean locationTracking );
5109#/**
     * Gets the external profiles that should be considered for model building.
     *
     * @return The external profiles that should be considered for model building, never {@code null}.
     */
    List<Profile> getProfiles();
5110#/**
     * Sets the external profiles that should be considered for model building.
     *
     * @param profiles The external profiles that should be considered for model building, may be {@code null}.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setProfiles( List<Profile> profiles );
5111#/**
     * Gets the identifiers of those profiles that should be activated by explicit demand.
     *
     * @return The identifiers of those profiles to activate, never {@code null}.
     */
    List<String> getActiveProfileIds();
5112#/**
     * Sets the identifiers of those profiles that should be activated by explicit demand.
     *
     * @param activeProfileIds The identifiers of those profiles to activate, may be {@code null}.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setActiveProfileIds( List<String> activeProfileIds );
5113#/**
     * Gets the identifiers of those profiles that should be deactivated by explicit demand.
     *
     * @return The identifiers of those profiles to deactivate, never {@code null}.
     */
    List<String> getInactiveProfileIds();
5114#/**
     * Sets the identifiers of those profiles that should be deactivated by explicit demand.
     *
     * @param inactiveProfileIds The identifiers of those profiles to deactivate, may be {@code null}.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setInactiveProfileIds( List<String> inactiveProfileIds );
5115#/**
     * Gets the system properties to use for interpolation and profile activation. The system properties are collected
     * from the runtime environment like {@link System#getProperties()} and environment variables.
     *
     * @return The system properties, never {@code null}.
     */
    Properties getSystemProperties();
5116#/**
     * Sets the system properties to use for interpolation and profile activation. The system properties are collected
     * from the runtime environment like {@link System#getProperties()} and environment variables.
     *
     * @param systemProperties The system properties, may be {@code null}.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setSystemProperties( Properties systemProperties );
5117#/**
     * Gets the user properties to use for interpolation and profile activation. The user properties have been
     * configured directly by the user on his discretion, e.g. via the {@code -Dkey=value} parameter on the command
     * line.
     *
     * @return The user properties, never {@code null}.
     */
    Properties getUserProperties();
5118#/**
     * Sets the user properties to use for interpolation and profile activation. The user properties have been
     * configured directly by the user on his discretion, e.g. via the {@code -Dkey=value} parameter on the command
     * line.
     *
     * @param userProperties The user properties, may be {@code null}.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setUserProperties( Properties userProperties );
5119#/**
     * Gets the start time of the build.
     *
     * @return The start time of the build or {@code null} if unknown.
     */
    Date getBuildStartTime();
5120#/**
     * Sets the start time of the build.
     *
     * @param buildStartTime The start time of the build, may be {@code null}.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setBuildStartTime( Date buildStartTime );
5121#/**
     * Gets the model resolver to use for resolution of mixins or parents that are not locally reachable from the
     * project directory.
     *
     * @return The model resolver or {@code null} if not set.
     */
    ModelResolver getModelResolver();
5122#/**
     * Sets the model resolver to use for resolution of mixins or parents that are not locally reachable from the
     * project directory.
     *
     * @param modelResolver The model resolver to use, may be {@code null}.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setModelResolver( ModelResolver modelResolver );
5123#/**
     * Gets the model building listener to notify during the build process.
     *
     * @return The model building listener to notify or {@code null} if none.
     */
    ModelBuildingListener getModelBuildingListener();
5124#/**
     * Sets the model building listener to notify during the build process.
     *
     * @param modelBuildingListener The model building listener to notify, may be {@code null}.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setModelBuildingListener( ModelBuildingListener modelBuildingListener );
5125#/**
     * Gets the model cache to use for reuse of previously built models.
     *
     * @return The model cache or {@code null} if not set.
     */
    ModelCache getModelCache();
5126#/**
     * Sets the model cache to use for reuse of previously built models. This is an optional component that serves
     * performance optimizations.
     *
     * @param modelCache The model cache to use, may be {@code null}.
     * @return This request, never {@code null}.
     */
    ModelBuildingRequest setModelCache( ModelCache modelCache );
5127#/**
     * Puts the specified data into the cache.
     * 
     * @param groupId The group id of the cache record, must not be {@code null}.
     * @param artifactId The artifact id of the cache record, must not be {@code null}.
     * @param version The version of the cache record, must not be {@code null}.
     * @param tag The tag of the cache record, must not be {@code null}.
     * @param data The data to store in the cache, must not be {@code null}.
     */
    void put( String groupId, String artifactId, String version, String tag, Object data );
5128#/**
     * Gets the specified data from the cache.
     * 
     * @param groupId The group id of the cache record, must not be {@code null}.
     * @param artifactId The artifact id of the cache record, must not be {@code null}.
     * @param version The version of the cache record, must not be {@code null}.
     * @param tag The tag of the cache record, must not be {@code null}.
     * @return The requested data or {@code null} if none was present in the cache.
     */
    Object get( String groupId, String artifactId, String version, String tag );
5129#/**
     * Gets the sequence of model identifiers that denote the lineage of models from which the effective model was
     * constructed. Model identifiers have the form {@code <groupId>:<artifactId>:<version>}. The first identifier from
     * the list denotes the model on which the model builder was originally invoked. The last identifier will always be
     * an empty string that by definition denotes the super POM.
     * 
     * @return The model identifiers from the lineage of models, never {@code null}.
     */
    List<String> getModelIds();
5130#/**
     * Gets the assembled model.
     * 
     * @return The assembled model, never {@code null}.
     */
    Model getEffectiveModel();
5131#/**
     * Gets the raw model as it was read from the input model source. Apart from basic validation, the raw model has not
     * undergone any updates by the model builder, e.g. reflects neither inheritance nor interpolation.
     * 
     * @return The raw model, never {@code null}.
     */
    Model getRawModel();
5132#/**
     * Gets the specified raw model as it was read from a model source. Apart from basic validation, a raw model has not
     * undergone any updates by the model builder, e.g. reflects neither inheritance nor interpolation. The model
     * identifier should be from the collection obtained by {@link #getModelIds()}. As a special case, an empty string
     * can be used as the identifier for the super POM.
     * 
     * @param modelId The identifier of the desired raw model, must not be {@code null}.
     * @return The raw model or {@code null} if the specified model id does not refer to a known model.
     */
    Model getRawModel( String modelId );
5133#/**
     * Gets the profiles from the specified model that were active during model building. The model identifier should be
     * from the collection obtained by {@link #getModelIds()}. As a special case, an empty string can be used as the
     * identifier for the super POM.
     * 
     * @param modelId The identifier of the model whose active profiles should be retrieved, must not be {@code null}.
     * @return The active profiles of the model or an empty list if none or {@code null} if the specified model id does
     *         not refer to a known model.
     */
    List<Profile> getActivePomProfiles( String modelId );
5134#/**
     * Gets the external profiles that were active during model building. External profiles are those that were
     * contributed by {@link ModelBuildingRequest#getProfiles()}.
     * 
     * @return The active external profiles or an empty list if none, never {@code null}.
     */
    List<Profile> getActiveExternalProfiles();
5135#/**
     * Gets the problems that were encountered during the model building. Note that only problems of severity
     * {@link ModelProblem.Severity#WARNING} and below are reported here. Problems with a higher severity level cause
     * the model builder to fail with a {@link ModelBuildingException}.
     * 
     * @return The problems that were encountered during the model building, can be empty but never {@code null}.
     */
    List<ModelProblem> getProblems();
5136#public FilterModelBuildingRequest( ModelBuildingRequest request )
    {
        this.request = request;
    }
5137#public File getPomFile()
    {
        return request.getPomFile();
    }
5138#public FilterModelBuildingRequest setPomFile( File pomFile )
    {
        request.setPomFile( pomFile );

        return this;
    }
5139#public ModelSource getModelSource()
    {
        return request.getModelSource();
    }
5140#public FilterModelBuildingRequest setModelSource( ModelSource modelSource )
    {
        request.setModelSource( modelSource );

        return this;
    }
5141#public int getValidationLevel()
    {
        return request.getValidationLevel();
    }
5142#public FilterModelBuildingRequest setValidationLevel( int validationLevel )
    {
        request.setValidationLevel( validationLevel );

        return this;
    }
5143#public boolean isProcessPlugins()
    {
        return request.isProcessPlugins();
    }
5144#public FilterModelBuildingRequest setProcessPlugins( boolean processPlugins )
    {
        request.setProcessPlugins( processPlugins );

        return this;
    }
5145#public boolean isTwoPhaseBuilding()
    {
        return request.isTwoPhaseBuilding();
    }
5146#public FilterModelBuildingRequest setTwoPhaseBuilding( boolean twoPhaseBuilding )
    {
        request.setTwoPhaseBuilding( twoPhaseBuilding );

        return this;
    }
5147#public boolean isLocationTracking()
    {
        return request.isLocationTracking();
    }
5148#public FilterModelBuildingRequest setLocationTracking( boolean locationTracking )
    {
        request.setLocationTracking( locationTracking );

        return this;
    }
5149#public List<Profile> getProfiles()
    {
        return request.getProfiles();
    }
5150#public FilterModelBuildingRequest setProfiles( List<Profile> profiles )
    {
        request.setProfiles( profiles );

        return this;
    }
5151#public List<String> getActiveProfileIds()
    {
        return request.getActiveProfileIds();
    }
5152#public FilterModelBuildingRequest setActiveProfileIds( List<String> activeProfileIds )
    {
        request.setActiveProfileIds( activeProfileIds );

        return this;
    }
5153#public List<String> getInactiveProfileIds()
    {
        return request.getInactiveProfileIds();
    }
5154#public FilterModelBuildingRequest setInactiveProfileIds( List<String> inactiveProfileIds )
    {
        request.setInactiveProfileIds( inactiveProfileIds );

        return this;
    }
5155#public Properties getSystemProperties()
    {
        return request.getSystemProperties();
    }
5156#public FilterModelBuildingRequest setSystemProperties( Properties systemProperties )
    {
        request.setSystemProperties( systemProperties );

        return this;
    }
5157#public Properties getUserProperties()
    {
        return request.getUserProperties();
    }
5158#public FilterModelBuildingRequest setUserProperties( Properties userProperties )
    {
        request.setUserProperties( userProperties );

        return this;
    }
5159#public Date getBuildStartTime()
    {
        return request.getBuildStartTime();
    }
5160#public ModelBuildingRequest setBuildStartTime( Date buildStartTime )
    {
        request.setBuildStartTime( buildStartTime );

        return this;
    }
5161#public ModelResolver getModelResolver()
    {
        return request.getModelResolver();
    }
5162#public FilterModelBuildingRequest setModelResolver( ModelResolver modelResolver )
    {
        request.setModelResolver( modelResolver );

        return this;
    }
5163#public ModelBuildingListener getModelBuildingListener()
    {
        return request.getModelBuildingListener();
    }
5164#public ModelBuildingRequest setModelBuildingListener( ModelBuildingListener modelBuildingListener )
    {
        request.setModelBuildingListener( modelBuildingListener );

        return this;
    }
5165#public ModelCache getModelCache()
    {
        return request.getModelCache();
    }
5166#public FilterModelBuildingRequest setModelCache( ModelCache modelCache )
    {
        request.setModelCache( modelCache );

        return this;
    }
5167#/**
     * Creates a new problem with the specified message and exception.
     * 
     * @param message The message describing the problem, may be {@code null}.
     * @param severity The severity level of the problem, may be {@code null} to default to
     *            {@link ModelProblem.Severity#ERROR}.
     * @param source The source of the problem, may be {@code null}.
     * @param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.
     * @param columnNumber The one-based index of the column containing the error or {@code -1} if unknown.
     * @param exception The exception that caused this problem, may be {@code null}.
     */
    public DefaultModelProblem( String message, Severity severity, Model source, int lineNumber, int columnNumber,
                                Exception exception )
    {
        this( message, severity, ModelProblemUtils.toPath( source ), lineNumber, columnNumber,
              ModelProblemUtils.toId( source ), exception );
    }
5168#/**
     * Creates a new problem with the specified message and exception.
     * 
     * @param message The message describing the problem, may be {@code null}.
     * @param severity The severity level of the problem, may be {@code null} to default to
     *            {@link ModelProblem.Severity#ERROR}.
     * @param source A hint about the source of the problem like a file path, may be {@code null}.
     * @param lineNumber The one-based index of the line containing the problem or {@code -1} if unknown.
     * @param columnNumber The one-based index of the column containing the problem or {@code -1} if unknown.
     * @param modelId The identifier of the model that exhibits the problem, may be {@code null}.
     * @param exception The exception that caused this problem, may be {@code null}.
     */
    public DefaultModelProblem( String message, Severity severity, String source, int lineNumber, int columnNumber,
                                String modelId, Exception exception )
    {
        this.message = message;
        this.severity = ( severity != null ) ? severity : Severity.ERROR;
        this.source = ( source != null ) ? source : "";
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
        this.modelId = ( modelId != null ) ? modelId : "";
        this.exception = exception;
    }
5169#public String getSource()
    {
        return source;
    }
5170#public int getLineNumber()
    {
        return lineNumber;
    }
5171#public int getColumnNumber()
    {
        return columnNumber;
    }
5172#public String getModelId()
    {
        return modelId;
    }
5173#public Exception getException()
    {
        return exception;
    }
5174#public String getMessage()
    {
        String msg;

        if ( message != null && message.length() > 0 )
        {
            msg = message;
        }
        else
        {
            msg = exception.getMessage();

            if ( msg == null )
            {
                msg = "";
            }
        }

        return msg;
    }
5175#public Severity getSeverity()
    {
        return severity;
    }
5176#@Override
    public String toString()
    {
        StringBuilder buffer = new StringBuilder( 128 );

        buffer.append( "[" ).append( getSeverity() ).append( "] " );
        buffer.append( getMessage() );
        buffer.append( " @ " ).append( ModelProblemUtils.formatLocation( this, null ) );

        return buffer.toString();
    }
5177#/**
     * Creates a new exception with the specified problems.
     * 
     * @param model The model that could not be built, may be {@code null}.
     * @param modelId The identifier of the model that could not be built, may be {@code null}.
     * @param problems The problems that causes this exception, may be {@code null}.
     * @deprecated Use {@link #ModelBuildingException(ModelBuildingResult)} instead.
     */
    @Deprecated
    public ModelBuildingException( Model model, String modelId, List<ModelProblem> problems )
    {
        super( toMessage( modelId, problems ) );

        if ( model != null )
        {
            DefaultModelBuildingResult tmp = new DefaultModelBuildingResult();
            if ( modelId == null )
            {
                modelId = "";
            }
            tmp.addModelId( modelId );
            tmp.setRawModel( modelId, model );
            tmp.setProblems( problems );
            result = tmp;
        }
        else
        {
            result = null;
        }
    }
5178#/**
     * Creates a new exception from the specified interim result and its associated problems.
     * 
     * @param result The interim result, may be {@code null}.
     */
    public ModelBuildingException( ModelBuildingResult result )
    {
        super( toMessage( result ) );
        this.result = result;
    }
5179#/**
     * Gets the interim result of the model building up to the point where it failed.
     * 
     * @return The interim model building result or {@code null} if not available.
     */
    public ModelBuildingResult getResult()
    {
        return result;
    }
5180#/**
     * Gets the model that could not be built properly.
     * 
     * @return The erroneous model or {@code null} if not available.
     */
    public Model getModel()
    {
        if ( result == null )
        {
            return null;
        }
        if ( result.getEffectiveModel() != null )
        {
            return result.getEffectiveModel();
        }
        return result.getRawModel();
    }
5181#/**
     * Gets the identifier of the POM whose effective model could not be built. The general format of the identifier is
     * {@code <groupId>:<artifactId>:<version>} but some of these coordinates may still be unknown at the point the
     * exception is thrown so this information is merely meant to assist the user.
     * 
     * @return The identifier of the POM or an empty string if not known, never {@code null}.
     */
    public String getModelId()
    {
        if ( result == null || result.getModelIds().isEmpty() )
        {
            return "";
        }
        return result.getModelIds().get( 0 );
    }
5182#/**
     * Gets the problems that caused this exception.
     * 
     * @return The problems that caused this exception, never {@code null}.
     */
    public List<ModelProblem> getProblems()
    {
        if ( result == null )
        {
            return Collections.emptyList();
        }
        return result.getProblems();
    }
5183#private static String toMessage( ModelBuildingResult result )
    {
        if ( result != null && !result.getModelIds().isEmpty() )
        {
            return toMessage( result.getModelIds().get( 0 ), result.getProblems() );
        }
        return null;
    }
5184#private static String toMessage( String modelId, List<ModelProblem> problems )
    {
        StringWriter buffer = new StringWriter( 1024 );

        PrintWriter writer = new PrintWriter( buffer );

        writer.print( problems.size() );
        writer.print( ( problems.size() == 1 ) ? " problem was " : " problems were " );
        writer.print( "encountered while building the effective model" );
        if ( modelId != null && modelId.length() > 0 )
        {
            writer.print( " for " );
            writer.print( modelId );
        }
        writer.println();

        for ( ModelProblem problem : problems )
        {
            writer.print( "[" );
            writer.print( problem.getSeverity() );
            writer.print( "] " );
            writer.print( problem.getMessage() );
            writer.print( " @ " );
            writer.println( ModelProblemUtils.formatLocation( problem, modelId ) );
        }

        return buffer.toString();
    }
5185#/**
     * Builds the effective model of the specified POM.
     * 
     * @param request The model building request that holds the parameters, must not be {@code null}.
     * @return The result of the model building, never {@code null}.
     * @throws ModelBuildingException If the effective model could not be built.
     */
    ModelBuildingResult build( ModelBuildingRequest request )
        throws ModelBuildingException;
5186#/**
     * Builds the effective model by completing the specified interim result which was produced by a previous call to
     * {@link #build(ModelBuildingRequest)} with {@link ModelBuildingRequest#isTwoPhaseBuilding()} being {@code true}.
     * The model building request passed to this method must be the same as the one used for the first phase of the
     * model building.
     * 
     * @param request The model building request that holds the parameters, must not be {@code null}.
     * @param result The interim result of the first phase of model building, must not be {@code null}.
     * @return The result of the model building, never {@code null}.
     * @throws ModelBuildingException If the effective model could not be built.
     */
    ModelBuildingResult build( ModelBuildingRequest request, ModelBuildingResult result )
        throws ModelBuildingException;
5187#public DefaultModelBuilder setModelProcessor( ModelProcessor modelProcessor )
    {
        this.modelProcessor = modelProcessor;
        return this;
    }
5188#public DefaultModelBuilder setModelValidator( ModelValidator modelValidator )
    {
        this.modelValidator = modelValidator;
        return this;
    }
5189#public DefaultModelBuilder setModelNormalizer( ModelNormalizer modelNormalizer )
    {
        this.modelNormalizer = modelNormalizer;
        return this;
    }
5190#public DefaultModelBuilder setModelInterpolator( ModelInterpolator modelInterpolator )
    {
        this.modelInterpolator = modelInterpolator;
        return this;
    }
5191#public DefaultModelBuilder setModelPathTranslator( ModelPathTranslator modelPathTranslator )
    {
        this.modelPathTranslator = modelPathTranslator;
        return this;
    }
5192#public DefaultModelBuilder setModelUrlNormalizer( ModelUrlNormalizer modelUrlNormalizer )
    {
        this.modelUrlNormalizer = modelUrlNormalizer;
        return this;
    }
5193#public DefaultModelBuilder setSuperPomProvider( SuperPomProvider superPomProvider )
    {
        this.superPomProvider = superPomProvider;
        return this;
    }
5194#public DefaultModelBuilder setProfileSelector( ProfileSelector profileSelector )
    {
        this.profileSelector = profileSelector;
        return this;
    }
5195#public DefaultModelBuilder setProfileInjector( ProfileInjector profileInjector )
    {
        this.profileInjector = profileInjector;
        return this;
    }
5196#public DefaultModelBuilder setInheritanceAssembler( InheritanceAssembler inheritanceAssembler )
    {
        this.inheritanceAssembler = inheritanceAssembler;
        return this;
    }
5197#public DefaultModelBuilder setDependencyManagementImporter( DependencyManagementImporter depMngmntImporter )
    {
        this.dependencyManagementImporter = depMngmntImporter;
        return this;
    }
5198#public DefaultModelBuilder setDependencyManagementInjector( DependencyManagementInjector depMngmntInjector )
    {
        this.dependencyManagementInjector = depMngmntInjector;
        return this;
    }
5199#public DefaultModelBuilder setLifecycleBindingsInjector( LifecycleBindingsInjector lifecycleBindingsInjector )
    {
        this.lifecycleBindingsInjector = lifecycleBindingsInjector;
        return this;
    }
5200#public DefaultModelBuilder setPluginConfigurationExpander( PluginConfigurationExpander pluginConfigurationExpander )
    {
        this.pluginConfigurationExpander = pluginConfigurationExpander;
        return this;
    }
5201#public DefaultModelBuilder setPluginManagementInjector( PluginManagementInjector pluginManagementInjector )
    {
        this.pluginManagementInjector = pluginManagementInjector;
        return this;
    }
5202#public DefaultModelBuilder setReportConfigurationExpander( ReportConfigurationExpander reportConfigurationExpander )
    {
        this.reportConfigurationExpander = reportConfigurationExpander;
        return this;
    }
5203#public DefaultModelBuilder setReportingConverter( ReportingConverter reportingConverter )
    {
        this.reportingConverter = reportingConverter;
        return this;
    }
5204#public ModelBuildingResult build( ModelBuildingRequest request )
        throws ModelBuildingException
    {
        return build( request, new LinkedHashSet<String>() );
    }
5205#private ModelBuildingResult build( ModelBuildingRequest request, Collection<String> importIds )
        throws ModelBuildingException
    {
        DefaultModelBuildingResult result = new DefaultModelBuildingResult();

        DefaultModelProblemCollector problems = new DefaultModelProblemCollector( result );

        DefaultProfileActivationContext profileActivationContext = getProfileActivationContext( request );

        problems.setSource( "(external profiles)" );
        List<Profile> activeExternalProfiles =
            profileSelector.getActiveProfiles( request.getProfiles(), profileActivationContext, problems );

        result.setActiveExternalProfiles( activeExternalProfiles );

        if ( !activeExternalProfiles.isEmpty() )
        {
            Properties profileProps = new Properties();
            for ( Profile profile : activeExternalProfiles )
            {
                profileProps.putAll( profile.getProperties() );
            }
            profileProps.putAll( profileActivationContext.getUserProperties() );
            profileActivationContext.setUserProperties( profileProps );
        }

        Model inputModel = readModel( request.getModelSource(), request.getPomFile(), request, problems );

        problems.setRootModel( inputModel );

        ModelData resultData = new ModelData( inputModel );
        ModelData superData = new ModelData( getSuperModel() );

        Collection<String> parentIds = new LinkedHashSet<String>();
        parentIds.add( ModelProblemUtils.toId( inputModel ) );

        List<ModelData> lineage = new ArrayList<ModelData>();

        for ( ModelData currentData = resultData; currentData != null; )
        {
            lineage.add( currentData );

            Model tmpModel = currentData.getModel();

            Model rawModel = tmpModel.clone();
            currentData.setRawModel( rawModel );

            problems.setSource( tmpModel );

            modelNormalizer.mergeDuplicates( tmpModel, request, problems );

            List<Profile> activePomProfiles =
                profileSelector.getActiveProfiles( rawModel.getProfiles(), profileActivationContext, problems );
            currentData.setActiveProfiles( activePomProfiles );

            for ( Profile activeProfile : activePomProfiles )
            {
                profileInjector.injectProfile( tmpModel, activeProfile, request, problems );
            }

            if ( currentData == resultData )
            {
                for ( Profile activeProfile : activeExternalProfiles )
                {
                    profileInjector.injectProfile( tmpModel, activeProfile, request, problems );
                }
            }

            if ( currentData == superData )
            {
                break;
            }

            configureResolver( request.getModelResolver(), tmpModel, problems );

            currentData = readParent( tmpModel, request, problems );

            if ( currentData == null )
            {
                currentData = superData;
            }
            else if ( !parentIds.add( currentData.getId() ) )
            {
                String message = "The parents form a cycle: ";
                for ( String modelId : parentIds )
                {
                    message += modelId + " -> ";
                }
                message += currentData.getId();

                problems.add( ModelProblem.Severity.FATAL, message, null, null );
                throw problems.newModelBuildingException();
            }
        }

        problems.setSource( inputModel );
        checkPluginVersions( lineage, request, problems );

        assembleInheritance( lineage, request, problems );

        Model resultModel = resultData.getModel();

        problems.setSource( resultModel );
        problems.setRootModel( resultModel );

        resultModel = interpolateModel( resultModel, request, problems );
        resultData.setModel( resultModel );

        modelUrlNormalizer.normalize( resultModel, request );

        resultData.setGroupId( resultModel.getGroupId() );
        resultData.setArtifactId( resultModel.getArtifactId() );
        resultData.setVersion( resultModel.getVersion() );

        result.setEffectiveModel( resultModel );

        for ( ModelData currentData : lineage )
        {
            String modelId = ( currentData != superData ) ? currentData.getId() : "";

            result.addModelId( modelId );
            result.setActivePomProfiles( modelId, currentData.getActiveProfiles() );
            result.setRawModel( modelId, currentData.getRawModel() );
        }

        if ( !request.isTwoPhaseBuilding() )
        {
            build( request, result );
        }

        return result;
    }
5206#public ModelBuildingResult build( ModelBuildingRequest request, ModelBuildingResult result )
        throws ModelBuildingException
    {
        return build( request, result, new LinkedHashSet<String>() );
    }
5207#private ModelBuildingResult build( ModelBuildingRequest request, ModelBuildingResult result,
                                       Collection<String> imports )
        throws ModelBuildingException
    {
        Model resultModel = result.getEffectiveModel();

        DefaultModelProblemCollector problems = new DefaultModelProblemCollector( result );
        problems.setSource( resultModel );
        problems.setRootModel( resultModel );

        modelPathTranslator.alignToBaseDirectory( resultModel, resultModel.getProjectDirectory(), request );

        pluginManagementInjector.injectManagement( resultModel, request, problems );

        fireEvent( resultModel, request, problems, ModelBuildingEventCatapult.BUILD_EXTENSIONS_ASSEMBLED );

        if ( request.isProcessPlugins() )
        {
            if ( lifecycleBindingsInjector == null )
            {
                throw new IllegalStateException( "lifecycle bindings injector is missing" );
            }

            lifecycleBindingsInjector.injectLifecycleBindings( resultModel, request, problems );
        }

        importDependencyManagement( resultModel, request, problems, imports );

        dependencyManagementInjector.injectManagement( resultModel, request, problems );

        modelNormalizer.injectDefaultValues( resultModel, request, problems );

        if ( request.isProcessPlugins() )
        {
            reportConfigurationExpander.expandPluginConfiguration( resultModel, request, problems );

            reportingConverter.convertReporting( resultModel, request, problems );

            pluginConfigurationExpander.expandPluginConfiguration( resultModel, request, problems );
        }

        modelValidator.validateEffectiveModel( resultModel, request, problems );

        if ( problems.hasErrors() )
        {
            throw problems.newModelBuildingException();
        }

        return result;
    }
5208#private Model readModel( ModelSource modelSource, File pomFile, ModelBuildingRequest request,
                             DefaultModelProblemCollector problems )
        throws ModelBuildingException
    {
        Model model;

        if ( modelSource == null )
        {
            if ( pomFile != null )
            {
                modelSource = new FileModelSource( pomFile );
            }
            else
            {
                throw new IllegalArgumentException( "neither model source nor input file are specified" );
            }
        }

        problems.setSource( modelSource.getLocation() );
        try
        {
            boolean strict = request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0;
            InputSource source = request.isLocationTracking() ? new InputSource() : null;

            Map<String, Object> options = new HashMap<String, Object>();
            options.put( ModelProcessor.IS_STRICT, Boolean.valueOf( strict ) );
            options.put( ModelProcessor.INPUT_SOURCE, source );
            options.put( ModelProcessor.SOURCE, modelSource );

            try
            {
                model = modelProcessor.read( modelSource.getInputStream(), options );
            }
            catch ( ModelParseException e )
            {
                if ( !strict )
                {
                    throw e;
                }

                options.put( ModelProcessor.IS_STRICT, Boolean.FALSE );

                try
                {
                    model = modelProcessor.read( modelSource.getInputStream(), options );
                }
                catch ( ModelParseException ne )
                {
                    // still unreadable even in non-strict mode, rethrow original error
                    throw e;
                }

                if ( pomFile != null )
                {
                    problems.add( Severity.ERROR, "Malformed POM " + modelSource.getLocation() + ": " + e.getMessage(),
                                  null, e );
                }
                else
                {
                    problems.add( Severity.WARNING, "Malformed POM " + modelSource.getLocation() + ": "
                        + e.getMessage(), null, e );
                }
            }

            if ( source != null )
            {
                source.setModelId( ModelProblemUtils.toId( model ) );
                source.setLocation( modelSource.getLocation() );
            }
        }
        catch ( ModelParseException e )
        {
            problems.add( Severity.FATAL, "Non-parseable POM " + modelSource.getLocation() + ": " + e.getMessage(),
                          null, e );
            throw problems.newModelBuildingException();
        }
        catch ( IOException e )
        {
            String msg = e.getMessage();
            if ( msg == null || msg.length() <= 0 )
            {
                // NOTE: There's java.nio.charset.MalformedInputException and sun.io.MalformedInputException
                if ( e.getClass().getName().endsWith( "MalformedInputException" ) )
                {
                    msg = "Some input bytes do not match the file encoding.";
                }
                else
                {
                    msg = e.getClass().getSimpleName();
                }
            }
            problems.add( Severity.FATAL, "Non-readable POM " + modelSource.getLocation() + ": " + msg, null, e );
            throw problems.newModelBuildingException();
        }

        model.setPomFile( pomFile );

        problems.setSource( model );
        modelValidator.validateRawModel( model, request, problems );

        if ( problems.hasFatalErrors() )
        {
            throw problems.newModelBuildingException();
        }

        return model;
    }
5209#private DefaultProfileActivationContext getProfileActivationContext( ModelBuildingRequest request )
    {
        DefaultProfileActivationContext context = new DefaultProfileActivationContext();

        context.setActiveProfileIds( request.getActiveProfileIds() );
        context.setInactiveProfileIds( request.getInactiveProfileIds() );
        context.setSystemProperties( request.getSystemProperties() );
        context.setUserProperties( request.getUserProperties() );
        context.setProjectDirectory( ( request.getPomFile() != null ) ? request.getPomFile().getParentFile() : null );

        return context;
    }
5210#private void configureResolver( ModelResolver modelResolver, Model model, DefaultModelProblemCollector problems )
    {
        if ( modelResolver == null )
        {
            return;
        }

        problems.setSource( model );

        List<Repository> repositories = model.getRepositories();

        for ( Repository repository : repositories )
        {
            try
            {
                modelResolver.addRepository( repository );
            }
            catch ( InvalidRepositoryException e )
            {
                problems.add( Severity.ERROR, "Invalid repository " + repository.getId() + ": " + e.getMessage(),
                              repository.getLocation( "" ), e );
            }
        }
    }
5211#private void checkPluginVersions( List<ModelData> lineage, ModelBuildingRequest request,
                                      ModelProblemCollector problems )
    {
        if ( request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )
        {
            return;
        }

        Map<String, Plugin> plugins = new HashMap<String, Plugin>();
        Map<String, String> versions = new HashMap<String, String>();
        Map<String, String> managedVersions = new HashMap<String, String>();

        for ( int i = lineage.size() - 1; i >= 0; i-- )
        {
            Model model = lineage.get( i ).getModel();
            Build build = model.getBuild();
            if ( build != null )
            {
                for ( Plugin plugin : build.getPlugins() )
                {
                    String key = plugin.getKey();
                    if ( versions.get( key ) == null )
                    {
                        versions.put( key, plugin.getVersion() );
                        plugins.put( key, plugin );
                    }
                }
                PluginManagement mngt = build.getPluginManagement();
                if ( mngt != null )
                {
                    for ( Plugin plugin : mngt.getPlugins() )
                    {
                        String key = plugin.getKey();
                        if ( managedVersions.get( key ) == null )
                        {
                            managedVersions.put( key, plugin.getVersion() );
                        }
                    }
                }
            }
        }

        for ( String key : versions.keySet() )
        {
            if ( versions.get( key ) == null && managedVersions.get( key ) == null )
            {
                InputLocation location = plugins.get( key ).getLocation( "" );
                problems.add( Severity.WARNING, "'build.plugins.plugin.version' for " + key + " is missing.", location,
                              null );
            }
        }
    }
5212#private void assembleInheritance( List<ModelData> lineage, ModelBuildingRequest request,
                                      ModelProblemCollector problems )
    {
        for ( int i = lineage.size() - 2; i >= 0; i-- )
        {
            Model parent = lineage.get( i + 1 ).getModel();
            Model child = lineage.get( i ).getModel();
            inheritanceAssembler.assembleModelInheritance( child, parent, request, problems );
        }
    }
5213#private Model interpolateModel( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        Model result = modelInterpolator.interpolateModel( model, model.getProjectDirectory(), request, problems );
        result.setPomFile( model.getPomFile() );
        return result;
    }
5214#private ModelData readParent( Model childModel, ModelBuildingRequest request,
                                  DefaultModelProblemCollector problems )
        throws ModelBuildingException
    {
        ModelData parentData;

        Parent parent = childModel.getParent();

        if ( parent != null )
        {
            String groupId = parent.getGroupId();
            String artifactId = parent.getArtifactId();
            String version = parent.getVersion();

            parentData = getCache( request.getModelCache(), groupId, artifactId, version, ModelCacheTag.RAW );

            if ( parentData == null )
            {
                parentData = readParentLocally( childModel, request, problems );

                if ( parentData == null )
                {
                    parentData = readParentExternally( childModel, request, problems );
                }

                putCache( request.getModelCache(), groupId, artifactId, version, ModelCacheTag.RAW, parentData );
            }
            else
            {
                /*
                 * NOTE: This is a sanity check of the cache hit. If the cached parent POM was locally resolved, the
                 * child's <relativePath> should point at that parent, too. If it doesn't, we ignore the cache and
                 * resolve externally, to mimic the behavior if the cache didn't exist in the first place. Otherwise,
                 * the cache would obscure a bad POM.
                 */

                File pomFile = parentData.getModel().getPomFile();
                if ( pomFile != null )
                {
                    File expectedParentFile = getParentPomFile( childModel );

                    if ( !pomFile.equals( expectedParentFile ) )
                    {
                        parentData = readParentExternally( childModel, request, problems );
                    }
                }
            }

            Model parentModel = parentData.getModel();

            if ( !"pom".equals( parentModel.getPackaging() ) )
            {
                problems.add( Severity.ERROR, "Invalid packaging for parent POM "
                    + ModelProblemUtils.toSourceHint( parentModel ) + ", must be \"pom\" but is \""
                    + parentModel.getPackaging() + "\"", parentModel.getLocation( "packaging" ), null );
            }
        }
        else
        {
            parentData = null;
        }

        return parentData;
    }
5215#private ModelData readParentLocally( Model childModel, ModelBuildingRequest request,
                                         DefaultModelProblemCollector problems )
        throws ModelBuildingException
    {
        File pomFile = getParentPomFile( childModel );

        if ( pomFile == null || !pomFile.isFile() )
        {
            return null;
        }

        Model candidateModel = readModel( null, pomFile, request, problems );

        String groupId = candidateModel.getGroupId();
        if ( groupId == null && candidateModel.getParent() != null )
        {
            groupId = candidateModel.getParent().getGroupId();
        }
        String artifactId = candidateModel.getArtifactId();
        String version = candidateModel.getVersion();
        if ( version == null && candidateModel.getParent() != null )
        {
            version = candidateModel.getParent().getVersion();
        }

        Parent parent = childModel.getParent();

        if ( groupId == null || !groupId.equals( parent.getGroupId() ) || artifactId == null
            || !artifactId.equals( parent.getArtifactId() ) )
        {
            StringBuilder buffer = new StringBuilder( 256 );
            buffer.append( "'parent.relativePath'" );
            if ( childModel != problems.getRootModel() )
            {
                buffer.append( " of POM " ).append( ModelProblemUtils.toSourceHint( childModel ) );
            }
            buffer.append( " points at " ).append( groupId ).append( ":" ).append( artifactId );
            buffer.append( " instead of " ).append( parent.getGroupId() ).append( ":" ).append( parent.getArtifactId() );
            buffer.append( ", please verify your project structure" );

            problems.setSource( childModel );
            problems.add( Severity.WARNING, buffer.toString(), parent.getLocation( "" ), null );
            return null;
        }
        if ( version == null || !version.equals( parent.getVersion() ) )
        {
            return null;
        }

        ModelData parentData = new ModelData( candidateModel, groupId, artifactId, version );

        return parentData;
    }
5216#private File getParentPomFile( Model childModel )
    {
        File projectDirectory = childModel.getProjectDirectory();

        if ( projectDirectory == null )
        {
            return null;
        }

        String parentPath = childModel.getParent().getRelativePath();

        if ( parentPath == null || parentPath.length() <= 0 )
        {
            return null;
        }

        parentPath = parentPath.replace( '\\', File.separatorChar ).replace( '/', File.separatorChar );

        File pomFile = new File( new File( projectDirectory, parentPath ).toURI().normalize() );

        if ( pomFile.isDirectory() )
        {
            pomFile = modelProcessor.locatePom( pomFile );
        }

        return pomFile;
    }
5217#private ModelData readParentExternally( Model childModel, ModelBuildingRequest request,
                                            DefaultModelProblemCollector problems )
        throws ModelBuildingException
    {
        problems.setSource( childModel );

        Parent parent = childModel.getParent();

        String groupId = parent.getGroupId();
        String artifactId = parent.getArtifactId();
        String version = parent.getVersion();

        ModelResolver modelResolver = request.getModelResolver();

        if ( modelResolver == null )
        {
            throw new IllegalArgumentException( "no model resolver provided, cannot resolve parent POM "
                + ModelProblemUtils.toId( groupId, artifactId, version ) + " for POM "
                + ModelProblemUtils.toSourceHint( childModel ) );
        }

        ModelSource modelSource;
        try
        {
            modelSource = modelResolver.resolveModel( groupId, artifactId, version );
        }
        catch ( UnresolvableModelException e )
        {
            StringBuilder buffer = new StringBuilder( 256 );
            buffer.append( "Non-resolvable parent POM" );
            if ( !containsCoordinates( e.getMessage(), groupId, artifactId, version ) )
            {
                buffer.append( " " ).append( ModelProblemUtils.toId( groupId, artifactId, version ) );
            }
            if ( childModel != problems.getRootModel() )
            {
                buffer.append( " for " ).append( ModelProblemUtils.toId( childModel ) );
            }
            buffer.append( ": " ).append( e.getMessage() );
            if ( childModel.getProjectDirectory() != null )
            {
                if ( parent.getRelativePath() == null || parent.getRelativePath().length() <= 0 )
                {
                    buffer.append( " and 'parent.relativePath' points at no local POM" );
                }
                else
                {
                    buffer.append( " and 'parent.relativePath' points at wrong local POM" );
                }
            }

            problems.add( Severity.FATAL, buffer.toString(), parent.getLocation( "" ), e );
            throw problems.newModelBuildingException();
        }

        ModelBuildingRequest lenientRequest = request;
        if ( request.getValidationLevel() > ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )
        {
            lenientRequest = new FilterModelBuildingRequest( request )
            {
                @Override
                public int getValidationLevel()
                {
                    return ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0;
                }
            };
        }

        Model parentModel = readModel( modelSource, null, lenientRequest, problems );

        ModelData parentData = new ModelData( parentModel, groupId, artifactId, version );

        return parentData;
    }
5218#private Model getSuperModel()
    {
        return superPomProvider.getSuperModel( "4.0.0" ).clone();
    }
5219#private void importDependencyManagement( Model model, ModelBuildingRequest request,
                                             DefaultModelProblemCollector problems, Collection<String> importIds )
    {
        DependencyManagement depMngt = model.getDependencyManagement();

        if ( depMngt == null )
        {
            return;
        }

        String importing = model.getGroupId() + ':' + model.getArtifactId() + ':' + model.getVersion();

        importIds.add( importing );

        ModelResolver modelResolver = request.getModelResolver();

        ModelBuildingRequest importRequest = null;

        List<DependencyManagement> importMngts = null;

        for ( Iterator<Dependency> it = depMngt.getDependencies().iterator(); it.hasNext(); )
        {
            Dependency dependency = it.next();

            if ( !"pom".equals( dependency.getType() ) || !"import".equals( dependency.getScope() ) )
            {
                continue;
            }

            it.remove();

            String groupId = dependency.getGroupId();
            String artifactId = dependency.getArtifactId();
            String version = dependency.getVersion();

            if ( groupId == null || groupId.length() <= 0 )
            {
                problems.add( Severity.ERROR, "'dependencyManagement.dependencies.dependency.groupId' for "
                    + dependency.getManagementKey() + " is missing.", dependency.getLocation( "" ), null );
                continue;
            }
            if ( artifactId == null || artifactId.length() <= 0 )
            {
                problems.add( Severity.ERROR, "'dependencyManagement.dependencies.dependency.artifactId' for "
                    + dependency.getManagementKey() + " is missing.", dependency.getLocation( "" ), null );
                continue;
            }
            if ( version == null || version.length() <= 0 )
            {
                problems.add( Severity.ERROR, "'dependencyManagement.dependencies.dependency.version' for "
                    + dependency.getManagementKey() + " is missing.", dependency.getLocation( "" ), null );
                continue;
            }

            String imported = groupId + ':' + artifactId + ':' + version;

            if ( importIds.contains( imported ) )
            {
                String message = "The dependencies of type=pom and with scope=import form a cycle: ";
                for ( String modelId : importIds )
                {
                    message += modelId + " -> ";
                }
                message += imported;
                problems.add( Severity.ERROR, message, null, null );

                continue;
            }

            DependencyManagement importMngt =
                getCache( request.getModelCache(), groupId, artifactId, version, ModelCacheTag.IMPORT );

            if ( importMngt == null )
            {
                if ( modelResolver == null )
                {
                    throw new IllegalArgumentException( "no model resolver provided, cannot resolve import POM "
                        + ModelProblemUtils.toId( groupId, artifactId, version ) + " for POM "
                        + ModelProblemUtils.toSourceHint( model ) );
                }

                ModelSource importSource;
                try
                {
                    importSource = modelResolver.resolveModel( groupId, artifactId, version );
                }
                catch ( UnresolvableModelException e )
                {
                    StringBuilder buffer = new StringBuilder( 256 );
                    buffer.append( "Non-resolvable import POM" );
                    if ( !containsCoordinates( e.getMessage(), groupId, artifactId, version ) )
                    {
                        buffer.append( " " ).append( ModelProblemUtils.toId( groupId, artifactId, version ) );
                    }
                    buffer.append( ": " ).append( e.getMessage() );

                    problems.add( Severity.ERROR, buffer.toString(), dependency.getLocation( "" ), e );
                    continue;
                }

                if ( importRequest == null )
                {
                    importRequest = new DefaultModelBuildingRequest();
                    importRequest.setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL );
                    importRequest.setModelCache( request.getModelCache() );
                    importRequest.setSystemProperties( request.getSystemProperties() );
                    importRequest.setUserProperties( request.getUserProperties() );
                    importRequest.setLocationTracking( request.isLocationTracking() );
                }

                importRequest.setModelSource( importSource );
                importRequest.setModelResolver( modelResolver.newCopy() );

                ModelBuildingResult importResult;
                try
                {
                    importResult = build( importRequest, importIds );
                }
                catch ( ModelBuildingException e )
                {
                    problems.addAll( e.getProblems() );
                    continue;
                }

                problems.addAll( importResult.getProblems() );

                Model importModel = importResult.getEffectiveModel();

                importMngt = importModel.getDependencyManagement();

                if ( importMngt == null )
                {
                    importMngt = new DependencyManagement();
                }

                putCache( request.getModelCache(), groupId, artifactId, version, ModelCacheTag.IMPORT, importMngt );
            }

            if ( importMngts == null )
            {
                importMngts = new ArrayList<DependencyManagement>();
            }

            importMngts.add( importMngt );
        }

        importIds.remove( importing );

        dependencyManagementImporter.importManagement( model, importMngts, request, problems );
    }
5220#private <T> void putCache( ModelCache modelCache, String groupId, String artifactId, String version,
                               ModelCacheTag<T> tag, T data )
    {
        if ( modelCache != null )
        {
            modelCache.put( groupId, artifactId, version, tag.getName(), tag.intoCache( data ) );
        }
    }
5221#private <T> T getCache( ModelCache modelCache, String groupId, String artifactId, String version,
                            ModelCacheTag<T> tag )
    {
        if ( modelCache != null )
        {
            Object data = modelCache.get( groupId, artifactId, version, tag.getName() );
            if ( data != null )
            {
                return tag.fromCache( tag.getType().cast( data ) );
            }
        }
        return null;
    }
5222#private void fireEvent( Model model, ModelBuildingRequest request, ModelProblemCollector problems,
                            ModelBuildingEventCatapult catapult )
        throws ModelBuildingException
    {
        ModelBuildingListener listener = request.getModelBuildingListener();

        if ( listener != null )
        {
            ModelBuildingEvent event = new DefaultModelBuildingEvent( model, request, problems );

            catapult.fire( listener, event );
        }
    }
5223#private boolean containsCoordinates( String message, String groupId, String artifactId, String version )
    {
        return message != null && ( groupId == null || message.contains( groupId ) )
            && ( artifactId == null || message.contains( artifactId ) )
            && ( version == null || message.contains( version ) );
    }
5224#/**
     * Creates a new model source backed by the specified URL.
     * 
     * @param pomUrl The POM file, must not be {@code null}.
     */
    public UrlModelSource( URL pomUrl )
    {
        if ( pomUrl == null )
        {
            throw new IllegalArgumentException( "no POM URL specified" );
        }
        this.pomUrl = pomUrl;
    }
5225#public InputStream getInputStream()
        throws IOException
    {
        return pomUrl.openStream();
    }
5226#public String getLocation()
    {
        return pomUrl.toString();
    }
5227#/**
     * Gets the POM URL of this model source.
     * 
     * @return The underlying POM URL, never {@code null}.
     */
    public URL getPomUrl()
    {
        return pomUrl;
    }
5228#@Override
    public String toString()
    {
        return getLocation();
    }
5229#public DefaultModelBuildingResult()
    {
        modelIds = new ArrayList<String>();
        rawModels = new HashMap<String, Model>();
        activePomProfiles = new HashMap<String, List<Profile>>();
        activeExternalProfiles = new ArrayList<Profile>();
        problems = new ArrayList<ModelProblem>();
    }
5230#public Model getEffectiveModel()
    {
        return effectiveModel;
    }
5231#public DefaultModelBuildingResult setEffectiveModel( Model model )
    {
        this.effectiveModel = model;

        return this;
    }
5232#public List<String> getModelIds()
    {
        return modelIds;
    }
5233#public DefaultModelBuildingResult addModelId( String modelId )
    {
        if ( modelId == null )
        {
            throw new IllegalArgumentException( "no model identifier specified" );
        }

        modelIds.add( modelId );

        return this;
    }
5234#public Model getRawModel()
    {
        return rawModels.get( modelIds.get( 0 ) );
    }
5235#public Model getRawModel( String modelId )
    {
        return rawModels.get( modelId );
    }
5236#public DefaultModelBuildingResult setRawModel( String modelId, Model rawModel )
    {
        if ( modelId == null )
        {
            throw new IllegalArgumentException( "no model identifier specified" );
        }

        rawModels.put( modelId, rawModel );

        return this;
    }
5237#public List<Profile> getActivePomProfiles( String modelId )
    {
        return activePomProfiles.get( modelId );
    }
5238#public DefaultModelBuildingResult setActivePomProfiles( String modelId, List<Profile> activeProfiles )
    {
        if ( modelId == null )
        {
            throw new IllegalArgumentException( "no model identifier specified" );
        }

        if ( activeProfiles != null )
        {
            this.activePomProfiles.put( modelId, new ArrayList<Profile>( activeProfiles ) );
        }
        else
        {
            this.activePomProfiles.remove( modelId );
        }

        return this;
    }
5239#public List<Profile> getActiveExternalProfiles()
    {
        return activeExternalProfiles;
    }
5240#public DefaultModelBuildingResult setActiveExternalProfiles( List<Profile> activeProfiles )
    {
        if ( activeProfiles != null )
        {
            this.activeExternalProfiles = new ArrayList<Profile>( activeProfiles );
        }
        else
        {
            this.activeExternalProfiles.clear();
        }

        return this;
    }
5241#public List<ModelProblem> getProblems()
    {
        return problems;
    }
5242#public DefaultModelBuildingResult setProblems( List<ModelProblem> problems )
    {
        if ( problems != null )
        {
            this.problems = new ArrayList<ModelProblem>( problems );
        }
        else
        {
            this.problems.clear();
        }

        return this;
    }
5243#/**
     * Creates an empty request.
     */
    public DefaultModelBuildingRequest()
    {
    }
5244#/**
     * Creates a shallow copy of the specified request.
     * 
     * @param request The request to copy, must not be {@code null}.
     */
    public DefaultModelBuildingRequest( ModelBuildingRequest request )
    {
        setPomFile( request.getPomFile() );
        setModelSource( request.getModelSource() );
        setValidationLevel( request.getValidationLevel() );
        setProcessPlugins( request.isProcessPlugins() );
        setTwoPhaseBuilding( request.isTwoPhaseBuilding() );
        setProfiles( request.getProfiles() );
        setActiveProfileIds( request.getActiveProfileIds() );
        setInactiveProfileIds( request.getInactiveProfileIds() );
        setSystemProperties( request.getSystemProperties() );
        setUserProperties( request.getUserProperties() );
        setBuildStartTime( request.getBuildStartTime() );
        setModelResolver( request.getModelResolver() );
        setModelBuildingListener( request.getModelBuildingListener() );
        setModelCache( request.getModelCache() );
    }
5245#public File getPomFile()
    {
        return pomFile;
    }
5246#public DefaultModelBuildingRequest setPomFile( File pomFile )
    {
        this.pomFile = ( pomFile != null ) ? pomFile.getAbsoluteFile() : null;

        return this;
    }
5247#public ModelSource getModelSource()
    {
        return modelSource;
    }
5248#public DefaultModelBuildingRequest setModelSource( ModelSource modelSource )
    {
        this.modelSource = modelSource;

        return this;
    }
5249#public int getValidationLevel()
    {
        return validationLevel;
    }
5250#public DefaultModelBuildingRequest setValidationLevel( int validationLevel )
    {
        this.validationLevel = validationLevel;

        return this;
    }
5251#public boolean isProcessPlugins()
    {
        return processPlugins;
    }
5252#public DefaultModelBuildingRequest setProcessPlugins( boolean processPlugins )
    {
        this.processPlugins = processPlugins;

        return this;
    }
5253#public boolean isTwoPhaseBuilding()
    {
        return twoPhaseBuilding;
    }
5254#public DefaultModelBuildingRequest setTwoPhaseBuilding( boolean twoPhaseBuilding )
    {
        this.twoPhaseBuilding = twoPhaseBuilding;

        return this;
    }
5255#public boolean isLocationTracking()
    {
        return locationTracking;
    }
5256#public DefaultModelBuildingRequest setLocationTracking( boolean locationTracking )
    {
        this.locationTracking = locationTracking;

        return this;
    }
5257#public List<Profile> getProfiles()
    {
        if ( profiles == null )
        {
            profiles = new ArrayList<Profile>();
        }

        return profiles;
    }
5258#public DefaultModelBuildingRequest setProfiles( List<Profile> profiles )
    {
        if ( profiles != null )
        {
            this.profiles = new ArrayList<Profile>( profiles );
        }
        else
        {
            this.profiles = null;
        }

        return this;
    }
5259#public List<String> getActiveProfileIds()
    {
        if ( activeProfileIds == null )
        {
            activeProfileIds = new ArrayList<String>();
        }

        return activeProfileIds;
    }
5260#public DefaultModelBuildingRequest setActiveProfileIds( List<String> activeProfileIds )
    {
        if ( activeProfileIds != null )
        {
            this.activeProfileIds = new ArrayList<String>( activeProfileIds );
        }
        else
        {
            this.activeProfileIds = null;
        }

        return this;
    }
5261#public List<String> getInactiveProfileIds()
    {
        if ( inactiveProfileIds == null )
        {
            inactiveProfileIds = new ArrayList<String>();
        }

        return inactiveProfileIds;
    }
5262#public DefaultModelBuildingRequest setInactiveProfileIds( List<String> inactiveProfileIds )
    {
        if ( inactiveProfileIds != null )
        {
            this.inactiveProfileIds = new ArrayList<String>( inactiveProfileIds );
        }
        else
        {
            this.inactiveProfileIds = null;
        }

        return this;
    }
5263#public Properties getSystemProperties()
    {
        if ( systemProperties == null )
        {
            systemProperties = new Properties();
        }

        return systemProperties;
    }
5264#public DefaultModelBuildingRequest setSystemProperties( Properties systemProperties )
    {
        if ( systemProperties != null )
        {
            this.systemProperties = new Properties();
            this.systemProperties.putAll( systemProperties );
        }
        else
        {
            this.systemProperties = null;
        }

        return this;
    }
5265#public Properties getUserProperties()
    {
        if ( userProperties == null )
        {
            userProperties = new Properties();
        }

        return userProperties;
    }
5266#public DefaultModelBuildingRequest setUserProperties( Properties userProperties )
    {
        if ( userProperties != null )
        {
            this.userProperties = new Properties();
            this.userProperties.putAll( userProperties );
        }
        else
        {
            this.userProperties = null;
        }

        return this;
    }
5267#public Date getBuildStartTime()
    {
        return buildStartTime;
    }
5268#public ModelBuildingRequest setBuildStartTime( Date buildStartTime )
    {
        this.buildStartTime = buildStartTime;

        return this;
    }
5269#public ModelResolver getModelResolver()
    {
        return this.modelResolver;
    }
5270#public DefaultModelBuildingRequest setModelResolver( ModelResolver modelResolver )
    {
        this.modelResolver = modelResolver;

        return this;
    }
5271#public ModelBuildingListener getModelBuildingListener()
    {
        return modelBuildingListener;
    }
5272#public ModelBuildingRequest setModelBuildingListener( ModelBuildingListener modelBuildingListener )
    {
        this.modelBuildingListener = modelBuildingListener;

        return this;
    }
5273#public ModelCache getModelCache()
    {
        return this.modelCache;
    }
5274#public DefaultModelBuildingRequest setModelCache( ModelCache modelCache )
    {
        this.modelCache = modelCache;

        return this;
    }
5275#public DefaultModelBuildingEvent( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        this.model = model;
        this.request = request;
        this.problems = problems;
    }
5276#public Model getModel()
    {
        return model;
    }
5277#public ModelBuildingRequest getRequest()
    {
        return request;
    }
5278#public ModelProblemCollector getProblems()
    {
        return problems;
    }
5279#/**
     * Creates a new model source backed by the specified string.
     * 
     * @param pom The POM's string representation, may be empty or {@code null}.
     */
    public StringModelSource( CharSequence pom )
    {
        this( pom, null );
    }
5280#/**
     * Creates a new model source backed by the specified string.
     * 
     * @param pom The POM's string representation, may be empty or {@code null}.
     * @param location The location to report for this use, may be {@code null}.
     */
    public StringModelSource( CharSequence pom, String location )
    {
        this.pom = ( pom != null ) ? pom.toString() : "";
        this.location = ( location != null ) ? location : "(memory)";
    }
5281#public InputStream getInputStream()
        throws IOException
    {
        return new ByteArrayInputStream( pom.getBytes( "UTF-8" ) );
    }
5282#public String getLocation()
    {
        return location;
    }
5283#/**
     * Gets the character sequence of this model source.
     * 
     * @return The underlying character stream, never {@code null}.
     */
    public String getModel()
    {
        return pom;
    }
5284#@Override
    public String toString()
    {
        return getLocation();
    }
5285#/**
     * Gets the model being built. The precise state of this model depends on the event being fired.
     * 
     * @return The model being built, never {@code null}.
     */
    Model getModel();
5286#/**
     * Gets the model building request being processed.
     * 
     * @return The model building request being processed, never {@code null}.
     */
    ModelBuildingRequest getRequest();
5287#/**
     * Gets the container used to collect problems that were encountered while processing the event.
     * 
     * @return The container used to collect problems that were encountered, never {@code null}.
     */
    ModelProblemCollector getProblems();
5288#/**
     * Creates a new model source backed by the specified file.
     * 
     * @param pomFile The POM file, must not be {@code null}.
     */
    public FileModelSource( File pomFile )
    {
        if ( pomFile == null )
        {
            throw new IllegalArgumentException( "no POM file specified" );
        }
        this.pomFile = pomFile.getAbsoluteFile();
    }
5289#public InputStream getInputStream()
        throws IOException
    {
        return new FileInputStream( pomFile );
    }
5290#public String getLocation()
    {
        return pomFile.getPath();
    }
5291#/**
     * Gets the POM file of this model source.
     * 
     * @return The underlying POM file, never {@code null}.
     */
    public File getPomFile()
    {
        return pomFile;
    }
5292#@Override
    public String toString()
    {
        return getLocation();
    }
5293#/**
     * Gets the name of the tag.
     *
     * @return The name of the tag, must not be {@code null}.
     */
    String getName();
5294#/**
     * Gets the type of data associated with this tag.
     *
     * @return The type of data, must not be {@code null}.
     */
    Class<T> getType();
5295#/**
     * Creates a copy of the data suitable for storage in the cache. The original data to store can be mutated after the
     * cache is populated but the state of the cache must not change so we need to make a copy.
     *
     * @param data The data to store in the cache, must not be {@code null}.
     * @return The data being stored in the cache, never {@code null}.
     */
    T intoCache( T data );
5296#/**
     * Creates a copy of the data suitable for retrieval from the cache. The retrieved data can be mutated after the
     * cache is queried but the state of the cache must not change so we need to make a copy.
     *
     * @param data The data to retrieve from the cache, must not be {@code null}.
     * @return The data being retrieved from the cache, never {@code null}.
     */
    T fromCache( T data );
5297#/**
     * Gets the hint about the source of the problem. While the syntax of this hint is unspecified and depends on the
     * creator of the problem, the general expectation is that the hint provides sufficient information to the user to
     * track the problem back to its origin. A concrete example for such a source hint can be the file path or URL from
     * which a POM was read.
     * 
     * @return The hint about the source of the problem or an empty string if unknown, never {@code null}.
     */
    String getSource();
5298#/**
     * Gets the one-based index of the line containing the problem. The line number should refer to some text file that
     * is given by {@link #getSource()}.
     * 
     * @return The one-based index of the line containing the problem or a non-positive value if unknown.
     */
    int getLineNumber();
5299#/**
     * Gets the one-based index of the column containing the problem. The column number should refer to some text file
     * that is given by {@link #getSource()}.
     * 
     * @return The one-based index of the column containing the problem or non-positive value if unknown.
     */
    int getColumnNumber();
5300#/**
     * Gets the identifier of the model from which the problem originated. While the general form of this identifier is
     * <code>groupId:artifactId:version</code> the returned identifier need not be complete. The identifier is derived
     * from the information that is available at the point the problem occurs and as such merely serves as a best effort
     * to provide information to the user to track the problem back to its origin.
     * 
     * @return The identifier of the model from which the problem originated or an empty string if unknown, never
     *         {@code null}.
     */
    String getModelId();
5301#/**
     * Gets the exception that caused this problem (if any).
     * 
     * @return The exception that caused this problem or {@code null} if not applicable.
     */
    Exception getException();
5302#/**
     * Gets the message that describes this problem.
     * 
     * @return The message describing this problem, never {@code null}.
     */
    String getMessage();
5303#/**
     * Gets the severity level of this problem.
     * 
     * @return The severity level of this problem, never {@code null}.
     */
    Severity getSeverity();
5304#/**
     * Gets a byte stream to the POM contents. Closing the returned stream is the responsibility of the caller.
     * 
     * @return A byte stream to the POM contents, never {@code null}.
     */
    InputStream getInputStream()
        throws IOException;
5305#/**
     * Provides a user-friendly hint about the location of the POM. This could be a local file path, a URI or just an
     * empty string. The intention is to assist users during error reporting.
     * 
     * @return A user-friendly hint about the location of the POM, never {@code null}.
     */
    String getLocation();
5306#public DefaultModelProcessor setModelLocator( ModelLocator locator )
    {
        this.locator = locator;
        return this;
    }
5307#public DefaultModelProcessor setModelReader( ModelReader reader )
    {
        this.reader = reader;
        return this;
    }
5308#public File locatePom( File projectDirectory )
    {
        return locator.locatePom( projectDirectory );
    }
5309#public Model read( File input, Map<String, ?> options )
        throws IOException
    {
        return reader.read( input, options );
    }
5310#public Model read( Reader input, Map<String, ?> options )
        throws IOException
    {
        return reader.read( input, options );
    }
5311#public Model read( InputStream input, Map<String, ?> options )
        throws IOException
    {
        return reader.read( input, options );
    }
5312#/**
     * Creates a user-friendly source hint for the specified model.
     * 
     * @param model The model to create a source hint for, may be {@code null}.
     * @return The user-friendly source hint, never {@code null}.
     */
    static String toSourceHint( Model model )
    {
        if ( model == null )
        {
            return "";
        }

        StringBuilder buffer = new StringBuilder( 192 );

        buffer.append( toId( model ) );

        File pomFile = model.getPomFile();
        if ( pomFile != null )
        {
            buffer.append( " (" ).append( pomFile ).append( ")" );
        }

        return buffer.toString();
    }
5313#static String toPath( Model model )
    {
        String path = "";

        if ( model != null )
        {
            File pomFile = model.getPomFile();

            if ( pomFile != null )
            {
                path = pomFile.getAbsolutePath();
            }
        }

        return path;
    }
5314#static String toId( Model model )
    {
        if ( model == null )
        {
            return "";
        }

        String groupId = model.getGroupId();
        if ( groupId == null && model.getParent() != null )
        {
            groupId = model.getParent().getGroupId();
        }

        String artifactId = model.getArtifactId();

        String version = model.getVersion();
        if ( version == null && model.getParent() != null )
        {
            version = model.getParent().getVersion();
        }

        return toId( groupId, artifactId, version );
    }
5315#/**
     * Creates a user-friendly artifact id from the specified coordinates.
     * 
     * @param groupId The group id, may be {@code null}.
     * @param artifactId The artifact id, may be {@code null}.
     * @param version The version, may be {@code null}.
     * @return The user-friendly artifact id, never {@code null}.
     */
    static String toId( String groupId, String artifactId, String version )
    {
        StringBuilder buffer = new StringBuilder( 96 );

        buffer.append( ( groupId != null && groupId.length() > 0 ) ? groupId : "[unknown-group-id]" );
        buffer.append( ':' );
        buffer.append( ( artifactId != null && artifactId.length() > 0 ) ? artifactId : "[unknown-artifact-id]" );
        buffer.append( ':' );
        buffer.append( ( version != null && version.length() > 0 ) ? version : "[unknown-version]" );

        return buffer.toString();
    }
5316#/**
     * Creates a string with all location details for the specified model problem. If the project identifier is
     * provided, the generated location will omit the model id and source information and only give line/column
     * information for problems originating directly from this POM.
     * 
     * @param problem The problem whose location should be formatted, must not be {@code null}.
     * @param projectId The {@code <groupId>:<artifactId>:<version>} of the corresponding project, may be {@code null}
     *            to force output of model id and source.
     * @return The formatted problem location or an empty string if unknown, never {@code null}.
     */
    public static String formatLocation( ModelProblem problem, String projectId )
    {
        StringBuilder buffer = new StringBuilder( 256 );

        if ( !problem.getModelId().equals( projectId ) )
        {
            buffer.append( problem.getModelId() );

            if ( problem.getSource().length() > 0 )
            {
                if ( buffer.length() > 0 )
                {
                    buffer.append( ", " );
                }
                buffer.append( problem.getSource() );
            }
        }

        if ( problem.getLineNumber() > 0 )
        {
            if ( buffer.length() > 0 )
            {
                buffer.append( ", " );
            }
            buffer.append( "line " ).append( problem.getLineNumber() );
        }

        if ( problem.getColumnNumber() > 0 )
        {
            if ( buffer.length() > 0 )
            {
                buffer.append( ", " );
            }
            buffer.append( "column " ).append( problem.getColumnNumber() );
        }

        return buffer.toString();
    }
5317#/**
     * Adds the specified problem.
     * 
     * @param severity The severity of the problem, must not be {@code null}.
     * @param message The detail message of the problem, may be {@code null}.
     * @param location The location of the problem, may be {@code null}.
     * @param cause The cause of the problem, may be {@code null}.
     */
    void add( ModelProblem.Severity severity, String message, InputLocation location, Exception cause );
5318#protected ModelProcessor newModelProcessor()
    {
        DefaultModelProcessor processor = new DefaultModelProcessor();
        processor.setModelLocator( newModelLocator() );
        processor.setModelReader( newModelReader() );
        return processor;
    }
5319#protected ModelLocator newModelLocator()
    {
        return new DefaultModelLocator();
    }
5320#protected ModelReader newModelReader()
    {
        return new DefaultModelReader();
    }
5321#protected ProfileSelector newProfileSelector()
    {
        DefaultProfileSelector profileSelector = new DefaultProfileSelector();

        for ( ProfileActivator activator : newProfileActivators() )
        {
            profileSelector.addProfileActivator( activator );
        }

        return profileSelector;
    }
5322#protected ProfileActivator[] newProfileActivators()
    {
        return new ProfileActivator[] { new JdkVersionProfileActivator(), new OperatingSystemProfileActivator(),
            new PropertyProfileActivator(), new FileProfileActivator().setPathTranslator( newPathTranslator() ) };
    }
5323#protected UrlNormalizer newUrlNormalizer()
    {
        return new DefaultUrlNormalizer();
    }
5324#protected PathTranslator newPathTranslator()
    {
        return new DefaultPathTranslator();
    }
5325#protected ModelInterpolator newModelInterpolator()
    {
        UrlNormalizer urlNormalizer = newUrlNormalizer();
        PathTranslator pathTranslator = newPathTranslator();
        return new StringSearchModelInterpolator().setPathTranslator( pathTranslator ).setUrlNormalizer( urlNormalizer );
    }
5326#protected ModelValidator newModelValidator()
    {
        return new DefaultModelValidator();
    }
5327#protected ModelNormalizer newModelNormalizer()
    {
        return new DefaultModelNormalizer();
    }
5328#protected ModelPathTranslator newModelPathTranslator()
    {
        return new DefaultModelPathTranslator().setPathTranslator( newPathTranslator() );
    }
5329#protected ModelUrlNormalizer newModelUrlNormalizer()
    {
        return new DefaultModelUrlNormalizer().setUrlNormalizer( newUrlNormalizer() );
    }
5330#protected InheritanceAssembler newInheritanceAssembler()
    {
        return new DefaultInheritanceAssembler();
    }
5331#protected ProfileInjector newProfileInjector()
    {
        return new DefaultProfileInjector();
    }
5332#protected SuperPomProvider newSuperPomProvider()
    {
        return new DefaultSuperPomProvider().setModelProcessor( newModelProcessor() );
    }
5333#protected DependencyManagementImporter newDependencyManagementImporter()
    {
        return new DefaultDependencyManagementImporter();
    }
5334#protected DependencyManagementInjector newDependencyManagementInjector()
    {
        return new DefaultDependencyManagementInjector();
    }
5335#protected LifecycleBindingsInjector newLifecycleBindingsInjector()
    {
        return new StubLifecycleBindingsInjector();
    }
5336#protected PluginManagementInjector newPluginManagementInjector()
    {
        return new DefaultPluginManagementInjector();
    }
5337#protected PluginConfigurationExpander newPluginConfigurationExpander()
    {
        return new DefaultPluginConfigurationExpander();
    }
5338#protected ReportConfigurationExpander newReportConfigurationExpander()
    {
        return new DefaultReportConfigurationExpander();
    }
5339#protected ReportingConverter newReportingConverter()
    {
        return new DefaultReportingConverter();
    }
5340#/**
     * Creates a new model builder instance.
     * 
     * @return The new model builder instance, never {@code null}.
     */
    public DefaultModelBuilder newInstance()
    {
        DefaultModelBuilder modelBuilder = new DefaultModelBuilder();

        modelBuilder.setModelProcessor( newModelProcessor() );
        modelBuilder.setModelValidator( newModelValidator() );
        modelBuilder.setModelNormalizer( newModelNormalizer() );
        modelBuilder.setModelPathTranslator( newModelPathTranslator() );
        modelBuilder.setModelUrlNormalizer( newModelUrlNormalizer() );
        modelBuilder.setModelInterpolator( newModelInterpolator() );
        modelBuilder.setInheritanceAssembler( newInheritanceAssembler() );
        modelBuilder.setProfileInjector( newProfileInjector() );
        modelBuilder.setProfileSelector( newProfileSelector() );
        modelBuilder.setSuperPomProvider( newSuperPomProvider() );
        modelBuilder.setDependencyManagementImporter( newDependencyManagementImporter() );
        modelBuilder.setDependencyManagementInjector( newDependencyManagementInjector() );
        modelBuilder.setLifecycleBindingsInjector( newLifecycleBindingsInjector() );
        modelBuilder.setPluginManagementInjector( newPluginManagementInjector() );
        modelBuilder.setPluginConfigurationExpander( newPluginConfigurationExpander() );
        modelBuilder.setReportConfigurationExpander( newReportConfigurationExpander() );
        modelBuilder.setReportingConverter( newReportingConverter() );

        return modelBuilder;
    }
5341#public void injectLifecycleBindings( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
        {
        }
5342#/**
     * Notifies the listener that the model has been constructed to the extent where build extensions can be processed.
     * 
     * @param event The details about the event.
     */
    void buildExtensionsAssembled( ModelBuildingEvent event );
5343#public void buildExtensionsAssembled( ModelBuildingEvent event )
    {
        // default does nothing
    }
5344#/**
     * Notifies the specified listener of the given event.
     *
     * @param listener The listener to notify, must not be {@code null}.
     * @param event The event to fire, must not be {@code null}.
     */
    void fire( ModelBuildingListener listener, ModelBuildingEvent event );
5345#public DefaultModelProblemCollector( ModelBuildingResult result )
    {
        this.result = result;
        this.problems = result.getProblems();

        for ( ModelProblem problem : this.problems )
        {
            severities.add( problem.getSeverity() );
        }
    }
5346#public boolean hasFatalErrors()
    {
        return severities.contains( ModelProblem.Severity.FATAL );
    }
5347#public boolean hasErrors()
    {
        return severities.contains( ModelProblem.Severity.ERROR ) || severities.contains( ModelProblem.Severity.FATAL );
    }
5348#public List<ModelProblem> getProblems()
    {
        return problems;
    }
5349#public void setSource( String source )
    {
        this.source = source;
        this.sourceModel = null;
    }
5350#public void setSource( Model source )
    {
        this.sourceModel = source;
        this.source = null;

        if ( rootModel == null )
        {
            rootModel = source;
        }
    }
5351#private String getSource()
    {
        if ( source == null && sourceModel != null )
        {
            source = ModelProblemUtils.toPath( sourceModel );
        }
        return source;
    }
5352#private String getModelId()
    {
        return ModelProblemUtils.toId( sourceModel );
    }
5353#public void setRootModel( Model rootModel )
    {
        this.rootModel = rootModel;
    }
5354#public Model getRootModel()
    {
        return rootModel;
    }
5355#public String getRootModelId()
    {
        return ModelProblemUtils.toId( rootModel );
    }
5356#public void add( ModelProblem problem )
    {
        problems.add( problem );

        severities.add( problem.getSeverity() );
    }
5357#public void addAll( List<ModelProblem> problems )
    {
        this.problems.addAll( problems );

        for ( ModelProblem problem : problems )
        {
            severities.add( problem.getSeverity() );
        }
    }
5358#public void add( Severity severity, String message, InputLocation location, Exception cause )
    {
        int line = -1;
        int column = -1;
        String source = null;
        String modelId = null;

        if ( location != null )
        {
            line = location.getLineNumber();
            column = location.getColumnNumber();
            if ( location.getSource() != null )
            {
                modelId = location.getSource().getModelId();
                source = location.getSource().getLocation();
            }
        }

        if ( modelId == null )
        {
            modelId = getModelId();
            source = getSource();
        }

        if ( line <= 0 && column <= 0 && cause instanceof ModelParseException )
        {
            ModelParseException e = (ModelParseException) cause;
            line = e.getLineNumber();
            column = e.getColumnNumber();
        }

        ModelProblem problem = new DefaultModelProblem( message, severity, source, line, column, modelId, cause );

        add( problem );
    }
5359#public ModelBuildingException newModelBuildingException()
    {
        ModelBuildingResult result = this.result;
        if ( result.getModelIds().isEmpty() )
        {
            DefaultModelBuildingResult tmp = new DefaultModelBuildingResult();
            tmp.setEffectiveModel( result.getEffectiveModel() );
            tmp.setProblems( getProblems() );
            tmp.setActiveExternalProfiles( result.getActiveExternalProfiles() );
            String id = getRootModelId();
            tmp.addModelId( id );
            tmp.setRawModel( id, getRootModel() );
            result = tmp;
        }
        return new ModelBuildingException( result );
    }
5360#public void importManagement( Model target, List<? extends DependencyManagement> sources,
                                  ModelBuildingRequest request, ModelProblemCollector problems )
    {
        if ( sources != null && !sources.isEmpty() )
        {
            Map<String, Dependency> dependencies = new LinkedHashMap<String, Dependency>();

            DependencyManagement depMngt = target.getDependencyManagement();

            if ( depMngt != null )
            {
                for ( Dependency dependency : depMngt.getDependencies() )
                {
                    dependencies.put( dependency.getManagementKey(), dependency );
                }
            }
            else
            {
                depMngt = new DependencyManagement();
                target.setDependencyManagement( depMngt );
            }

            for ( DependencyManagement source : sources )
            {
                for ( Dependency dependency : source.getDependencies() )
                {
                    String key = dependency.getManagementKey();
                    if ( !dependencies.containsKey( key ) )
                    {
                        dependencies.put( key, dependency );
                    }
                }
            }

            depMngt.setDependencies( new ArrayList<Dependency>( dependencies.values() ) );
        }
    }
5361#/**
     * Imports the specified dependency management sections into the given target model.
     * 
     * @param target The model into which to import the dependency management section, must not be <code>null</code>.
     * @param sources The dependency management sections to import, may be <code>null</code>.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void importManagement( Model target, List<? extends DependencyManagement> sources, ModelBuildingRequest request,
                           ModelProblemCollector problems );
5362#public void assembleModelInheritance( Model child, Model parent, ModelBuildingRequest request,
                                          ModelProblemCollector problems )
    {
        Map<Object, Object> hints = new HashMap<Object, Object>();
        hints.put( MavenModelMerger.CHILD_PATH_ADJUSTMENT, getChildPathAdjustment( child, parent ) );
        merger.merge( child, parent, false, hints );
    }
5363#/**
     * Calculates the relative path from the base directory of the parent to the parent directory of the base directory
     * of the child. The general idea is to adjust inherited URLs to match the project layout (in SCM). This calculation
     * is only a heuristic based on our conventions. In detail, the algo relies on the following assumptions. The parent
     * uses aggregation and refers to the child via the modules section. The module path to the child is considered to
     * point at the POM rather than its base directory if the path ends with ".xml" (ignoring case). The name of the
     * child's base directory matches the artifact id of the child. Note that for the sake of independence from the user
     * environment, the filesystem is intentionally not used for the calculation.
     *
     * @param child The child model, must not be <code>null</code>.
     * @param parent The parent model, may be <code>null</code>.
     * @return The path adjustment, can be empty but never <code>null</code>.
     */
    private String getChildPathAdjustment( Model child, Model parent )
    {
        String adjustment = "";

        if ( parent != null )
        {
            String childName = child.getArtifactId();

            /*
             * This logic exists only for the sake of backward-compat with 2.x (MNG-5000). In generally, it is wrong to
             * base URL inheritance on the project directory names as this information is unavailable for POMs in the
             * repository. In other words, projects where artifactId != projectDirName will see different effective URLs
             * depending on how the POM was constructed.
             */
            File childDirectory = child.getProjectDirectory();
            if ( childDirectory != null )
            {
                childName = childDirectory.getName();
            }

            for ( String module : parent.getModules() )
            {
                module = module.replace( '\\', '/' );

                if ( module.regionMatches( true, module.length() - 4, ".xml", 0, 4 ) )
                {
                    module = module.substring( 0, module.lastIndexOf( '/' ) + 1 );
                }

                String moduleName = module;
                if ( moduleName.endsWith( "/" ) )
                {
                    moduleName = moduleName.substring( 0, moduleName.length() - 1 );
                }

                int lastSlash = moduleName.lastIndexOf( '/' );

                moduleName = moduleName.substring( lastSlash + 1 );

                if ( moduleName.equals( childName ) && lastSlash >= 0 )
                {
                    adjustment = module.substring( 0, lastSlash );
                    break;
                }
            }
        }

        return adjustment;
    }
5364#@Override
        protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                     boolean sourceDominant, Map<Object, Object> context )
        {
            List<Plugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<Plugin> tgt = target.getPlugins();
                Map<Object, Plugin> master = new LinkedHashMap<Object, Plugin>( src.size() * 2 );

                for ( Plugin element : src )
                {
                    if ( element.isInherited() || !element.getExecutions().isEmpty() )
                    {
                        // NOTE: Enforce recursive merge to trigger merging/inheritance logic for executions
                        Plugin plugin = new Plugin();
                        plugin.setLocation( "", element.getLocation( "" ) );
                        plugin.setGroupId( null );
                        mergePlugin( plugin, element, sourceDominant, context );

                        Object key = getPluginKey( element );

                        master.put( key, plugin );
                    }
                }

                Map<Object, List<Plugin>> predecessors = new LinkedHashMap<Object, List<Plugin>>();
                List<Plugin> pending = new ArrayList<Plugin>();
                for ( Plugin element : tgt )
                {
                    Object key = getPluginKey( element );
                    Plugin existing = master.get( key );
                    if ( existing != null )
                    {
                        mergePlugin( element, existing, sourceDominant, context );

                        master.put( key, element );

                        if ( !pending.isEmpty() )
                        {
                            predecessors.put( key, pending );
                            pending = new ArrayList<Plugin>();
                        }
                    }
                    else
                    {
                        pending.add( element );
                    }
                }

                List<Plugin> result = new ArrayList<Plugin>( src.size() + tgt.size() );
                for ( Map.Entry<Object, Plugin> entry : master.entrySet() )
                {
                    List<Plugin> pre = predecessors.get( entry.getKey() );
                    if ( pre != null )
                    {
                        result.addAll( pre );
                    }
                    result.add( entry.getValue() );
                }
                result.addAll( pending );

                target.setPlugins( result );
            }
        }
5365#@Override
        protected void mergePlugin( Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context )
        {
            if ( source.isInherited() )
            {
                mergeConfigurationContainer( target, source, sourceDominant, context );
            }
            mergePlugin_GroupId( target, source, sourceDominant, context );
            mergePlugin_ArtifactId( target, source, sourceDominant, context );
            mergePlugin_Version( target, source, sourceDominant, context );
            mergePlugin_Extensions( target, source, sourceDominant, context );
            mergePlugin_Dependencies( target, source, sourceDominant, context );
            mergePlugin_Executions( target, source, sourceDominant, context );
        }
5366#@Override
        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<Object, ReportPlugin>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element :  src )
                {
                    Object key = getReportPluginKey( element );
                    if ( element.isInherited() )
                    {
                        // NOTE: Enforce recursive merge to trigger merging/inheritance logic for executions as well
                        ReportPlugin plugin = new ReportPlugin();
                        plugin.setLocation( "", element.getLocation( "" ) );
                        plugin.setGroupId( null );
                        mergeReportPlugin( plugin, element, sourceDominant, context );

                        merged.put( key, plugin );
                    }
                }

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportPlugin( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setPlugins( new ArrayList<ReportPlugin>( merged.values() ) );
            }
        }
5367#/**
     * Merges values from the specified parent model into the given child model. Implementations are expected to keep
     * parent and child completely decoupled by injecting deep copies of objects into the child rather than the original
     * objects from the parent.
     * 
     * @param child The child model into which to merge the values inherited from the parent, must not be
     *            <code>null</code>.
     * @param parent The (read-only) parent model from which to inherit the values, may be <code>null</code>.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void assembleModelInheritance( Model child, Model parent, ModelBuildingRequest request,
                                   ModelProblemCollector problems );
5368#/**
     * Interpolates expressions in the specified model. Note that implementations are free to either interpolate the
     * provided model directly or to create a clone of the model and interpolate the clone. Callers should always use
     * the returned model and must not rely on the input model being updated.
     *
     * @param model The model to interpolate, must not be {@code null}.
     * @param projectDir The project directory, may be {@code null} if the model does not belong to a local project but
     *            to some artifact's metadata.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     * @return The interpolated model, never {@code null}.
     */
    Model interpolateModel( Model model, File projectDir, ModelBuildingRequest request,
                            ModelProblemCollector problems );
5369#public AbstractStringBasedModelInterpolator()
    {
        interpolator = createInterpolator();
        recursionInterceptor = new PrefixAwareRecursionInterceptor( PROJECT_PREFIXES );
    }
5370#public AbstractStringBasedModelInterpolator setPathTranslator( PathTranslator pathTranslator )
    {
        this.pathTranslator = pathTranslator;
        return this;
    }
5371#public AbstractStringBasedModelInterpolator setUrlNormalizer( UrlNormalizer urlNormalizer )
    {
        this.urlNormalizer = urlNormalizer;
        return this;
    }
5372#protected List<ValueSource> createValueSources( final Model model, final File projectDir,
                                                    final ModelBuildingRequest config,
                                                    final ModelProblemCollector problems )
    {
        Properties modelProperties = model.getProperties();

        ValueSource modelValueSource1 = new PrefixedObjectValueSource( PROJECT_PREFIXES, model, false );
        if ( config.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )
        {
            modelValueSource1 = new ProblemDetectingValueSource( modelValueSource1, "pom.", "project.", problems );
        }

        ValueSource modelValueSource2 = new ObjectBasedValueSource( model );
        if ( config.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )
        {
            modelValueSource2 = new ProblemDetectingValueSource( modelValueSource2, "", "project.", problems );
        }

        // NOTE: Order counts here!
        List<ValueSource> valueSources = new ArrayList<ValueSource>( 9 );

        if ( projectDir != null )
        {
            ValueSource basedirValueSource = new PrefixedValueSourceWrapper( new AbstractValueSource( false )
            {
                public Object getValue( String expression )
                {
                    if ( "basedir".equals( expression ) )
                    {
                        return projectDir.getAbsolutePath();
                    }
                    return null;
                }
            }, PROJECT_PREFIXES, true );
            valueSources.add( basedirValueSource );

            ValueSource baseUriValueSource = new PrefixedValueSourceWrapper( new AbstractValueSource( false )
            {
                public Object getValue( String expression )
                {
                    if ( "baseUri".equals( expression ) )
                    {
                        return projectDir.getAbsoluteFile().toURI().toString();
                    }
                    return null;
                }
            }, PROJECT_PREFIXES, false );
            valueSources.add( baseUriValueSource );

            String timestampFormat = DEFAULT_BUILD_TIMESTAMP_FORMAT;
            if ( modelProperties != null )
            {
                timestampFormat = modelProperties.getProperty( BUILD_TIMESTAMP_FORMAT_PROPERTY, timestampFormat );
            }
            valueSources.add( new BuildTimestampValueSource( config.getBuildStartTime(), timestampFormat ) );
        }

        valueSources.add( modelValueSource1 );

        valueSources.add( new MapBasedValueSource( config.getUserProperties() ) );

        valueSources.add( new MapBasedValueSource( modelProperties ) );

        valueSources.add( new MapBasedValueSource( config.getSystemProperties() ) );

        valueSources.add( new AbstractValueSource( false )
        {
            public Object getValue( String expression )
            {
                return config.getSystemProperties().getProperty( "env." + expression );
            }
        } );

        valueSources.add( modelValueSource2 );

        return valueSources;
    }
5373#protected List<? extends InterpolationPostProcessor> createPostProcessors( final Model model,
                                                                               final File projectDir,
                                                                               final ModelBuildingRequest config )
    {
        List<InterpolationPostProcessor> processors = new ArrayList<InterpolationPostProcessor>( 2 );
        if ( projectDir != null )
        {
            processors.add( new PathTranslatingPostProcessor( PROJECT_PREFIXES, TRANSLATED_PATH_EXPRESSIONS,
                                                              projectDir, pathTranslator ) );
        }
        processors.add( new UrlNormalizingPostProcessor( urlNormalizer ) );
        return processors;
    }
5374#protected String interpolateInternal( String src, List<? extends ValueSource> valueSources,
                                          List<? extends InterpolationPostProcessor> postProcessors,
                                          ModelProblemCollector problems )
    {
        if ( src.indexOf( "${" ) < 0 )
        {
            return src;
        }

        String result = src;
        synchronized ( this )
        {

            for ( ValueSource vs : valueSources )
            {
                interpolator.addValueSource( vs );
            }

            for ( InterpolationPostProcessor postProcessor : postProcessors )
            {
                interpolator.addPostProcessor( postProcessor );
            }

            try
            {
                try
                {
                    result = interpolator.interpolate( result, recursionInterceptor );
                }
                catch ( InterpolationException e )
                {
                    problems.add( Severity.ERROR, e.getMessage(), null, e );
                }

                interpolator.clearFeedback();
            }
            finally
            {
                for ( ValueSource vs : valueSources )
                {
                    interpolator.removeValuesSource( vs );
                }

                for ( InterpolationPostProcessor postProcessor : postProcessors )
                {
                    interpolator.removePostProcessor( postProcessor );
                }
            }
        }

        return result;
    }
5375#protected RecursionInterceptor getRecursionInterceptor()
    {
        return recursionInterceptor;
    }
5376#protected void setRecursionInterceptor( RecursionInterceptor recursionInterceptor )
    {
        this.recursionInterceptor = recursionInterceptor;
    }
5377#protected abstract Interpolator createInterpolator();
5378#protected final Interpolator getInterpolator()
    {
        return interpolator;
    }
5379#public UrlNormalizingPostProcessor( UrlNormalizer normalizer )
    {
        this.normalizer = normalizer;
    }
5380#public Object execute( String expression, Object value )
    {
        if ( value != null && URL_EXPRESSIONS.contains( expression ) )
        {
            return normalizer.normalize( value.toString() );
        }

        return null;
    }
5381#public PathTranslatingPostProcessor( List<String> expressionPrefixes, Collection<String> unprefixedPathKeys,
                                         File projectDir, PathTranslator pathTranslator )
    {
        this.expressionPrefixes = expressionPrefixes;
        this.unprefixedPathKeys = unprefixedPathKeys;
        this.projectDir = projectDir;
        this.pathTranslator = pathTranslator;
    }
5382#public Object execute( String expression, Object value )
    {
        if ( value != null )
        {
            expression = ValueSourceUtils.trimPrefix( expression, expressionPrefixes, true );

            if ( unprefixedPathKeys.contains( expression ) )
            {
                return pathTranslator.alignToBaseDirectory( String.valueOf( value ), projectDir );
            }
        }

        return null;
    }
5383#public BuildTimestampValueSource( Date startTime, String format )
    {
        super( false );
        this.startTime = startTime;
        this.format = format;
    }
5384#public Object getValue( String expression )
    {
        if ( "build.timestamp".equals( expression ) || "maven.build.timestamp".equals( expression ) )
        {
            if ( formattedDate == null && startTime != null )
            {
                formattedDate = new SimpleDateFormat( format ).format( startTime );
            }
            
            return formattedDate;
        }

        return null;
    }
5385#public ProblemDetectingValueSource( ValueSource valueSource, String bannedPrefix, String newPrefix,
                                        ModelProblemCollector problems )
    {
        this.valueSource = valueSource;
        this.bannedPrefix = bannedPrefix;
        this.newPrefix = newPrefix;
        this.problems = problems;
    }
5386#public Object getValue( String expression )
    {
        Object value = valueSource.getValue( expression );

        if ( value != null && expression.startsWith( bannedPrefix ) )
        {
            String msg = "The expression ${" + expression + "} is deprecated.";
            if ( newPrefix != null && newPrefix.length() > 0 )
            {
                msg += " Please use ${" + newPrefix + expression.substring( bannedPrefix.length() ) + "} instead.";
            }
            problems.add( Severity.WARNING, msg, null, null );
        }

        return value;
    }
5387#@SuppressWarnings( "unchecked" )
    public List getFeedback()
    {
        return valueSource.getFeedback();
    }
5388#public void clearFeedback()
    {
        valueSource.clearFeedback();
    }
5389#public Model interpolateModel( Model model, File projectDir, ModelBuildingRequest config,
                                   ModelProblemCollector problems )
    {
        interpolateObject( model, model, projectDir, config, problems );

        return model;
    }
5390#protected void interpolateObject( Object obj, Model model, File projectDir, ModelBuildingRequest config,
                                      ModelProblemCollector problems )
    {
        try
        {
            List<? extends ValueSource> valueSources = createValueSources( model, projectDir, config, problems );
            List<? extends InterpolationPostProcessor> postProcessors = createPostProcessors( model, projectDir,
                                                                                              config );

            InterpolateObjectAction action =
                new InterpolateObjectAction( obj, valueSources, postProcessors, this, problems );

            AccessController.doPrivileged( action );
        }
        finally
        {
            getInterpolator().clearAnswers();
        }
    }
5391#protected Interpolator createInterpolator()
    {
        StringSearchInterpolator interpolator = new StringSearchInterpolator();
        interpolator.setCacheAnswers( true );

        return interpolator;
    }
5392#public InterpolateObjectAction( Object target, List<? extends ValueSource> valueSources,
                                        List<? extends InterpolationPostProcessor> postProcessors,
                                        StringSearchModelInterpolator modelInterpolator,
                                        ModelProblemCollector problems )
        {
            this.valueSources = valueSources;
            this.postProcessors = postProcessors;

            this.interpolationTargets = new LinkedList<Object>();
            interpolationTargets.add( target );

            this.modelInterpolator = modelInterpolator;

            this.problems = problems;
        }
5393#public Object run()
        {
            while ( !interpolationTargets.isEmpty() )
            {
                Object obj = interpolationTargets.removeFirst();

                traverseObjectWithParents( obj.getClass(), obj );
            }

            return null;
        }
5394#private void traverseObjectWithParents( Class<?> cls, Object target )
        {
            if ( cls == null )
            {
                return;
            }

            if ( cls.isArray() )
            {
                evaluateArray( target );
            }
            else if ( isQualifiedForInterpolation( cls ) )
            {
                for ( Field currentField : getFields( cls ) )
                {
                    Class<?> type = currentField.getType();
                    if ( isQualifiedForInterpolation( currentField, type ) )
                    {
                        synchronized ( currentField )
                        {
                            interpolateField( cls, target, currentField, type );
                        }
                    }
                }

                traverseObjectWithParents( cls.getSuperclass(), target );
            }
        }
5395#private void interpolateField( Class<?> cls, Object target, Field field, Class<?> type )
        {
            boolean isAccessible = field.isAccessible();
            field.setAccessible( true );
            try
            {
                if ( String.class == type )
                {
                    interpolateStringField( target, field );
                }
                else if ( Collection.class.isAssignableFrom( type ) )
                {
                    interpolateCollectionField( target, field );
                }
                else if ( Map.class.isAssignableFrom( type ) )
                {
                    interpolateMapField( target, field );
                }
                else
                {
                    Object value = field.get( target );
                    if ( value != null )
                    {
                        if ( field.getType().isArray() )
                        {
                            evaluateArray( value );
                        }
                        else
                        {
                            interpolationTargets.add( value );
                        }
                    }
                }
            }
            catch ( IllegalArgumentException e )
            {
                problems.add( Severity.ERROR, "Failed to interpolate field3: " + field + " on class: " + cls.getName(),
                              null, e );
            }
            catch ( IllegalAccessException e )
            {
                problems.add( Severity.ERROR, "Failed to interpolate field4: " + field + " on class: " + cls.getName(),
                              null, e );
            }
            finally
            {
                field.setAccessible( isAccessible );
            }
        }
5396#private void interpolateStringField( Object target, Field field )
            throws IllegalAccessException
        {
            String value = (String) field.get( target );
            if ( value == null || Modifier.isFinal( field.getModifiers() ) )
            {
                return;
            }

            String interpolated =
                modelInterpolator.interpolateInternal( value, valueSources, postProcessors, problems );

            if ( !interpolated.equals( value ) )
            {
                field.set( target, interpolated );
            }
        }
5397#private void interpolateCollectionField( Object target, Field field )
            throws IllegalAccessException
        {
            @SuppressWarnings( "unchecked" )
            Collection<Object> c = (Collection<Object>) field.get( target );
            if ( c == null || c.isEmpty() )
            {
                return;
            }

            List<Object> originalValues = new ArrayList<Object>( c );
            try
            {
                c.clear();
            }
            catch ( UnsupportedOperationException e )
            {
                return;
            }

            for ( Object value : originalValues )
            {
                if ( value == null )
                {
                    // add the null back in...not sure what else to do...
                    c.add( value );
                }
                else if ( String.class == value.getClass() )
                {
                    String interpolated =
                        modelInterpolator.interpolateInternal( (String) value, valueSources, postProcessors, problems );

                    if ( !interpolated.equals( value ) )
                    {
                        c.add( interpolated );
                    }
                    else
                    {
                        c.add( value );
                    }
                }
                else
                {
                    c.add( value );
                    if ( value.getClass().isArray() )
                    {
                        evaluateArray( value );
                    }
                    else
                    {
                        interpolationTargets.add( value );
                    }
                }
            }
        }
5398#private void interpolateMapField( Object target, Field field )
            throws IllegalAccessException
        {
            @SuppressWarnings( "unchecked" )
            Map<Object, Object> m = (Map<Object, Object>) field.get( target );
            if ( m == null || m.isEmpty() )
            {
                return;
            }

            for ( Map.Entry<Object, Object> entry : m.entrySet() )
            {
                Object value = entry.getValue();

                if ( value == null )
                {
                    continue;
                }

                if ( String.class == value.getClass() )
                {
                    String interpolated =
                        modelInterpolator.interpolateInternal( (String) value, valueSources, postProcessors, problems );

                    if ( !interpolated.equals( value ) )
                    {
                        try
                        {
                            entry.setValue( interpolated );
                        }
                        catch ( UnsupportedOperationException e )
                        {
                            continue;
                        }
                    }
                }
                else if ( value.getClass().isArray() )
                {
                    evaluateArray( value );
                }
                else
                {
                    interpolationTargets.add( value );
                }
            }
        }
5399#private Field[] getFields( Class<?> cls )
        {
            Field[] fields = fieldsByClass.get( cls );
            if ( fields == null )
            {
                fields = cls.getDeclaredFields();
                fieldsByClass.put( cls, fields );
            }
            return fields;
        }
5400#private boolean isQualifiedForInterpolation( Class<?> cls )
        {
            return !cls.getName().startsWith( "java" );
        }
5401#private boolean isQualifiedForInterpolation( Field field, Class<?> fieldType )
        {
            if ( Map.class.equals( fieldType ) && "locations".equals( field.getName() ) )
            {
                return false;
            }

            Boolean primitive = fieldIsPrimitiveByClass.get( fieldType );
            if ( primitive == null )
            {
                primitive = fieldType.isPrimitive();
                fieldIsPrimitiveByClass.put( fieldType, primitive );
            }

            if ( primitive )
            {
                return false;
            }

            return !"parent".equals( field.getName() );
        }
5402#private void evaluateArray( Object target )
        {
            int len = Array.getLength( target );
            for ( int i = 0; i < len; i++ )
            {
                Object value = Array.get( target, i );
                if ( value != null )
                {
                    if ( String.class == value.getClass() )
                    {
                        String interpolated =
                            modelInterpolator.interpolateInternal( (String) value, valueSources, postProcessors,
                                                                   problems );

                        if ( !interpolated.equals( value ) )
                        {
                            Array.set( target, i, interpolated );
                        }
                    }
                    else
                    {
                        interpolationTargets.add( value );
                    }
                }
            }
        }
5403#/**
     * Creates a new parser exception with the specified details.
     * 
     * @param message The error message, may be {@code null}.
     * @param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.
     * @param columnNumber The one-based index of the column containing the error or {@code -1} if unknown.
     */
    public ModelParseException( String message, int lineNumber, int columnNumber )
    {
        super( message );
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }
5404#/**
     * Creates a new parser exception with the specified details.
     * 
     * @param message The error message, may be {@code null}.
     * @param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.
     * @param columnNumber The one-based index of the column containing the error or {@code -1} if unknown.
     * @param cause The nested cause of this error, may be {@code null}.
     */
    public ModelParseException( String message, int lineNumber, int columnNumber, Throwable cause )
    {
        super( message );
        initCause( cause );
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }
5405#/**
     * Gets the one-based index of the line containing the error.
     * 
     * @return The one-based index of the line containing the error or a non-positive value if unknown.
     */
    public int getLineNumber()
    {
        return lineNumber;
    }
5406#/**
     * Gets the one-based index of the column containing the error.
     * 
     * @return The one-based index of the column containing the error or non-positive value if unknown.
     */
    public int getColumnNumber()
    {
        return columnNumber;
    }
5407#/**
     * Writes the supplied model to the specified file. Any non-existing parent directories of the output file will be
     * created automatically.
     * 
     * @param output The file to serialize the model to, must not be {@code null}.
     * @param options The options to use for serialization, may be {@code null} to use the default values.
     * @param model The model to serialize, must not be {@code null}.
     * @throws IOException If the model could not be serialized.
     */
    void write( File output, Map<String, Object> options, Model model )
        throws IOException;
5408#/**
     * Writes the supplied model to the specified character writer. The writer will be automatically closed before the
     * method returns.
     * 
     * @param output The writer to serialize the model to, must not be {@code null}.
     * @param options The options to use for serialization, may be {@code null} to use the default values.
     * @param model The model to serialize, must not be {@code null}.
     * @throws IOException If the model could not be serialized.
     */
    void write( Writer output, Map<String, Object> options, Model model )
        throws IOException;
5409#/**
     * Writes the supplied model to the specified byte stream. The stream will be automatically closed before the method
     * returns.
     * 
     * @param output The stream to serialize the model to, must not be {@code null}.
     * @param options The options to use for serialization, may be {@code null} to use the default values.
     * @param model The model to serialize, must not be {@code null}.
     * @throws IOException If the model could not be serialized.
     */
    void write( OutputStream output, Map<String, Object> options, Model model )
        throws IOException;
5410#public Model read( File input, Map<String, ?> options )
        throws IOException
    {
        if ( input == null )
        {
            throw new IllegalArgumentException( "input file missing" );
        }

        Model model = read( new FileInputStream( input ), options );

        model.setPomFile( input );

        return model;
    }
5411#public Model read( Reader input, Map<String, ?> options )
        throws IOException
    {
        if ( input == null )
        {
            throw new IllegalArgumentException( "input reader missing" );
        }

        try
        {
            return read( input, isStrict( options ), getSource( options ) );
        }
        finally
        {
            IOUtil.close( input );
        }
    }
5412#public Model read( InputStream input, Map<String, ?> options )
        throws IOException
    {
        if ( input == null )
        {
            throw new IllegalArgumentException( "input stream missing" );
        }

        try
        {
            return read( ReaderFactory.newXmlReader( input ), isStrict( options ), getSource( options ) );
        }
        finally
        {
            IOUtil.close( input );
        }
    }
5413#private boolean isStrict( Map<String, ?> options )
    {
        Object value = ( options != null ) ? options.get( IS_STRICT ) : null;
        return value == null || Boolean.parseBoolean( value.toString() );
    }
5414#private InputSource getSource( Map<String, ?> options )
    {
        Object value = ( options != null ) ? options.get( INPUT_SOURCE ) : null;
        return (InputSource) value;
    }
5415#private Model read( Reader reader, boolean strict, InputSource source )
        throws IOException
    {
        try
        {
            if ( source != null )
            {
                return new MavenXpp3ReaderEx().read( reader, strict, source );
            }
            else
            {
                return new MavenXpp3Reader().read( reader, strict );
            }
        }
        catch ( XmlPullParserException e )
        {
            throw new ModelParseException( e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e );
        }
    }
5416#public void write( File output, Map<String, Object> options, Model model )
        throws IOException
    {
        if ( output == null )
        {
            throw new IllegalArgumentException( "output file missing" );
        }

        if ( model == null )
        {
            throw new IllegalArgumentException( "model missing" );
        }

        output.getParentFile().mkdirs();

        write( WriterFactory.newXmlWriter( output ), options, model );
    }
5417#public void write( Writer output, Map<String, Object> options, Model model )
        throws IOException
    {
        if ( output == null )
        {
            throw new IllegalArgumentException( "output writer missing" );
        }

        if ( model == null )
        {
            throw new IllegalArgumentException( "model missing" );
        }

        try
        {
            MavenXpp3Writer w = new MavenXpp3Writer();
            w.write( output, model );
        }
        finally
        {
            IOUtil.close( output );
        }
    }
5418#public void write( OutputStream output, Map<String, Object> options, Model model )
        throws IOException
    {
        if ( output == null )
        {
            throw new IllegalArgumentException( "output stream missing" );
        }

        if ( model == null )
        {
            throw new IllegalArgumentException( "model missing" );
        }

        try
        {
            String encoding = model.getModelEncoding();
            if ( encoding == null || encoding.length() <= 0 )
            {
                encoding = "UTF-8";
            }
            write( new OutputStreamWriter( output, encoding ), options, model );
        }
        finally
        {
            IOUtil.close( output );
        }
    }
5419#/**
     * Reads the model from the specified file.
     *
     * @param input The file to deserialize the model from, must not be {@code null}.
     * @param options The options to use for deserialization, may be {@code null} to use the default values.
     * @return The deserialized model, never {@code null}.
     * @throws IOException If the model could not be deserialized.
     * @throws ModelParseException If the input format could not be parsed.
     */
    Model read( File input, Map<String, ?> options )
        throws IOException, ModelParseException;
5420#/**
     * Reads the model from the specified character reader. The reader will be automatically closed before the method
     * returns.
     *
     * @param input The reader to deserialize the model from, must not be {@code null}.
     * @param options The options to use for deserialization, may be {@code null} to use the default values.
     * @return The deserialized model, never {@code null}.
     * @throws IOException If the model could not be deserialized.
     * @throws ModelParseException If the input format could not be parsed.
     */
    Model read( Reader input, Map<String, ?> options )
        throws IOException, ModelParseException;
5421#/**
     * Reads the model from the specified byte stream. The stream will be automatically closed before the method
     * returns.
     *
     * @param input The stream to deserialize the model from, must not be {@code null}.
     * @param options The options to use for deserialization, may be {@code null} to use the default values.
     * @return The deserialized model, never {@code null}.
     * @throws IOException If the model could not be deserialized.
     * @throws ModelParseException If the input format could not be parsed.
     */
    Model read( InputStream input, Map<String, ?> options )
        throws IOException, ModelParseException;
5422#public File locatePom( File projectDirectory )
    {
        return new File( projectDirectory, "pom.xml" );
    }
5423#/**
     * Locates the POM file within the specified project directory. In case the given project directory does not exist
     * or does not contain a POM file, the return value indicates the expected path to the POM file. Sub directories of
     * the project directory will not be considered when locating the POM file. The return value will be an absolute
     * path if the project directory is given as an absolute path.
     * 
     * @param projectDirectory The (possibly non-existent) base directory to locate the POM file in, must not be {@code
     *            null}.
     * @return The path to the (possibly non-existent) POM file, never {@code null}.
     */
    File locatePom( File projectDirectory );
5424#public void injectManagement( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        merger.mergeManagedBuildPlugins( model );
    }
5425#public void mergeManagedBuildPlugins( Model model )
        {
            Build build = model.getBuild();
            if ( build != null )
            {
                PluginManagement pluginManagement = build.getPluginManagement();
                if ( pluginManagement != null )
                {
                    mergePluginContainer_Plugins( build, pluginManagement );
                }
            }
        }
5426#private void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source )
        {
            List<Plugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<Plugin> tgt = target.getPlugins();

                Map<Object, Plugin> managedPlugins = new LinkedHashMap<Object, Plugin>( src.size() * 2 );

                Map<Object, Object> context = Collections.emptyMap();

                for ( Plugin element : src )
                {
                    Object key = getPluginKey( element );
                    managedPlugins.put( key, element );
                }

                for ( Plugin element : tgt )
                {
                    Object key = getPluginKey( element );
                    Plugin managedPlugin = managedPlugins.get( key );
                    if ( managedPlugin != null )
                    {
                        mergePlugin( element, managedPlugin, false, context );
                    }
                }
            }
        }
5427#@Override
        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();

                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<Object, PluginExecution>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element.clone() );
                }

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( element, existing, sourceDominant, context );
                    }
                    merged.put( key, element );
                }

                target.setExecutions( new ArrayList<PluginExecution>( merged.values() ) );
            }
        }
5428#public void injectManagement( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        merger.mergeManagedDependencies( model );
    }
5429#public void mergeManagedDependencies( Model model )
        {
            DependencyManagement dependencyManagement = model.getDependencyManagement();
            if ( dependencyManagement != null )
            {
                Map<Object, Dependency> dependencies = new HashMap<Object, Dependency>();
                Map<Object, Object> context = Collections.emptyMap();

                for ( Dependency dependency : model.getDependencies() )
                {
                    Object key = getDependencyKey( dependency );
                    dependencies.put( key, dependency );
                }

                for ( Dependency managedDependency : dependencyManagement.getDependencies() )
                {
                    Object key = getDependencyKey( managedDependency );
                    Dependency dependency = dependencies.get( key );
                    if ( dependency != null )
                    {
                        mergeDependency( dependency, managedDependency, false, context );
                    }
                }
            }
        }
5430#@Override
        protected void mergeDependency_Optional( Dependency target, Dependency source, boolean sourceDominant,
                                                 Map<Object, Object> context )
        {
            // optional flag is not managed
        }
5431#@Override
        protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                                   Map<Object, Object> context )
        {
            List<Exclusion> tgt = target.getExclusions();
            if ( tgt.isEmpty() )
            {
                List<Exclusion> src = source.getExclusions();

                for ( Exclusion element : src )
                {
                    Exclusion clone = element.clone();
                    target.addExclusion( clone );
                }
            }
        }
5432#/**
     * Merges default values from the dependency management section of the given model into itself.
     * 
     * @param model The model into which to merge the values specified by its dependency management sections, must not
     *            be <code>null</code>.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void injectManagement( Model model, ModelBuildingRequest request, ModelProblemCollector problems );
5433#/**
     * Merges default values from the plugin management section of the given model into itself.
     * 
     * @param model The model into which to merge the values specified by its plugin management section, must not be
     *            <code>null</code>.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void injectManagement( Model model, ModelBuildingRequest request, ModelProblemCollector problems );
5434#@Override
    protected void mergeModel( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        context.put( ARTIFACT_ID, target.getArtifactId() );

        super.mergeModel( target, source, sourceDominant, context );
    }
5435#@Override
    protected void mergeModel_Name( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getName();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setName( src );
                target.setLocation( "name", source.getLocation( "name" ) );
            }
        }
    }
5436#@Override
    protected void mergeModel_Url( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
            else if ( target.getUrl() == null )
            {
                target.setUrl( appendPath( src, context ) );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }
5437#/*
     * TODO: Whether the merge continues recursively into an existing node or not could be an option for the generated
     * merger
     */
    @Override
    protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setOrganization( tgt );
                mergeOrganization( tgt, src, sourceDominant, context );
            }
        }
    }
5438#@Override
    protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setIssueManagement( tgt );
                mergeIssueManagement( tgt, src, sourceDominant, context );
            }
        }
    }
5439#@Override
    protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setCiManagement( tgt );
                mergeCiManagement( tgt, src, sourceDominant, context );
            }
        }
    }
5440#@Override
    protected void mergeModel_ModelVersion( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        // neither inherited nor injected
    }
5441#@Override
    protected void mergeModel_ArtifactId( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        // neither inherited nor injected
    }
5442#@Override
    protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        // neither inherited nor injected
    }
5443#@Override
    protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        // neither inherited nor injected
    }
5444#@Override
    protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        if ( target.getLicenses().isEmpty() )
        {
            target.setLicenses( new ArrayList<License>( source.getLicenses() ) );
        }
    }
5445#@Override
    protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        if ( target.getDevelopers().isEmpty() )
        {
            target.setDevelopers( new ArrayList<Developer>( source.getDevelopers() ) );
        }
    }
5446#@Override
    protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        if ( target.getContributors().isEmpty() )
        {
            target.setContributors( new ArrayList<Contributor>( source.getContributors() ) );
        }
    }
5447#@Override
    protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        if ( target.getMailingLists().isEmpty() )
        {
            target.setMailingLists( new ArrayList<MailingList>( source.getMailingLists() ) );
        }
    }
5448#@Override
    protected void mergeModelBase_Modules( ModelBase target, ModelBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getModules();
        if ( !src.isEmpty() && sourceDominant )
        {
            List<Integer> indices = new ArrayList<Integer>();
            List<String> tgt = target.getModules();
            Set<String> excludes = new LinkedHashSet<String>( tgt );
            List<String> merged = new ArrayList<String>( tgt.size() + src.size() );
            merged.addAll( tgt );
            for ( int i = 0, n = tgt.size(); i < n; i++ )
            {
                indices.add( Integer.valueOf( i ) );
            }
            for ( int i = 0, n = src.size(); i < n; i++ )
            {
                String s = src.get( i );
                if ( !excludes.contains( s ) )
                {
                    merged.add( s );
                    indices.add( Integer.valueOf( ~i ) );
                }
            }
            target.setModules( merged );
            target.setLocation( "modules", InputLocation.merge( target.getLocation( "modules" ),
                                                                source.getLocation( "modules" ), indices ) );
        }
    }
5449#/*
     * TODO: The order of the merged list could be controlled by an attribute in the model association: target-first,
     * source-first, dominant-first, recessive-first
     */
    @Override
    protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<Object, Repository>( ( src.size() + tgt.size() ) * 2 );

            List<Repository> dominant, recessive;
            if ( sourceDominant )
            {
                dominant = src;
                recessive = tgt;
            }
            else
            {
                dominant = tgt;
                recessive = src;
            }

            for ( Repository element : dominant )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : recessive )
            {
                Object key = getRepositoryKey( element );
                if ( !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<Repository>( merged.values() ) );
        }
    }
5450#/*
     * TODO: Whether duplicates should be removed looks like an option for the generated merger.
     */
    @Override
    protected void mergeBuildBase_Filters( BuildBase target, BuildBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getFilters();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getFilters();
            Set<String> excludes = new LinkedHashSet<String>( tgt );
            List<String> merged = new ArrayList<String>( tgt.size() + src.size() );
            merged.addAll( tgt );
            for ( String s : src )
            {
                if ( !excludes.contains( s ) )
                {
                    merged.add( s );
                }
            }
            target.setFilters( merged );
        }
    }
5451#@Override
    protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        if ( sourceDominant || target.getResources().isEmpty() )
        {
            super.mergeBuildBase_Resources( target, source, sourceDominant, context );
        }
    }
5452#@Override
    protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        if ( sourceDominant || target.getTestResources().isEmpty() )
        {
            super.mergeBuildBase_TestResources( target, source, sourceDominant, context );
        }
    }
5453#@Override
    protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }
5454#@Override
    protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( sourceDominant || tgt == null )
            {
                tgt = new DeploymentRepository();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSnapshotRepository( tgt );
                mergeDeploymentRepository( tgt, src, sourceDominant, context );
            }
        }
    }
5455#@Override
    protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( sourceDominant || tgt == null )
            {
                tgt = new Site();
                tgt.setLocation( "", src.getLocation( "" ) );
                target.setSite( tgt );
                mergeSite( tgt, src, sourceDominant, context );
            }
        }
    }
5456#@Override
    protected void mergeSite_Url( Site target, Site source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
            else if ( target.getUrl() == null )
            {
                target.setUrl( appendPath( src, context ) );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }
5457#@Override
    protected void mergeScm_Url( Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
            else if ( target.getUrl() == null )
            {
                target.setUrl( appendPath( src, context ) );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }
5458#@Override
    protected void mergeScm_Connection( Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getConnection();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setConnection( src );
                target.setLocation( "connection", source.getLocation( "connection" ) );
            }
            else if ( target.getConnection() == null )
            {
                target.setConnection( appendPath( src, context ) );
                target.setLocation( "connection", source.getLocation( "connection" ) );
            }
        }
    }
5459#@Override
    protected void mergeScm_DeveloperConnection( Scm target, Scm source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        String src = source.getDeveloperConnection();
        if ( src != null )
        {
            if ( sourceDominant )
            {
                target.setDeveloperConnection( src );
                target.setLocation( "developerConnection", source.getLocation( "developerConnection" ) );
            }
            else if ( target.getDeveloperConnection() == null )
            {
                target.setDeveloperConnection( appendPath( src, context ) );
                target.setLocation( "developerConnection", source.getLocation( "developerConnection" ) );
            }
        }
    }
5460#@Override
    protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();
            Map<Object, PluginExecution> merged =
                new LinkedHashMap<Object, PluginExecution>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : src )
            {
                if ( sourceDominant
                                || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }
            }

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                PluginExecution existing = merged.get( key );
                if ( existing != null )
                {
                    mergePluginExecution( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setExecutions( new ArrayList<PluginExecution>( merged.values() ) );
        }
    }
5461#@Override
    protected void mergePluginExecution_Goals( PluginExecution target, PluginExecution source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<String> src = source.getGoals();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getGoals();
            Set<String> excludes = new LinkedHashSet<String>( tgt );
            List<String> merged = new ArrayList<String>( tgt.size() + src.size() );
            merged.addAll( tgt );
            for ( String s : src )
            {
                if ( !excludes.contains( s ) )
                {
                    merged.add( s );
                }
            }
            target.setGoals( merged );
        }
    }
5462#@Override
    protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<Object, ReportSet>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : src )
            {
                if ( sourceDominant || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }
            }

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                ReportSet existing = merged.get( key );
                if ( existing != null )
                {
                    mergeReportSet( element, existing, sourceDominant, context );
                }
                merged.put( key, element );
            }

            target.setReportSets( new ArrayList<ReportSet>( merged.values() ) );
        }
    }
5463#@Override
    protected Object getDependencyKey( Dependency dependency )
    {
        return dependency.getManagementKey();
    }
5464#@Override
    protected Object getPluginKey( Plugin object )
    {
        return object.getKey();
    }
5465#@Override
    protected Object getPluginExecutionKey( PluginExecution object )
    {
        return object.getId();
    }
5466#@Override
    protected Object getReportPluginKey( ReportPlugin object )
    {
        return object.getKey();
    }
5467#@Override
    protected Object getReportSetKey( ReportSet object )
    {
        return object.getId();
    }
5468#@Override
    protected Object getRepositoryBaseKey( RepositoryBase object )
    {
        return object.getId();
    }
5469#@Override
    protected Object getExtensionKey( Extension object )
    {
        return object.getGroupId() + ':' + object.getArtifactId();
    }
5470#@Override
    protected Object getExclusionKey( Exclusion object )
    {
        return object.getGroupId() + ':' + object.getArtifactId();
    }
5471#private String appendPath( String parentPath, Map<Object, Object> context )
    {
        Object artifactId = context.get( ARTIFACT_ID );
        Object childPathAdjustment = context.get( CHILD_PATH_ADJUSTMENT );

        if ( artifactId != null && childPathAdjustment != null )
        {
            return appendPath( parentPath, artifactId.toString(), childPathAdjustment.toString() );
        }
        else
        {
            return parentPath;
        }
    }
5472#private String appendPath( String parentPath, String childPath, String pathAdjustment )
    {
        String path = parentPath;
        path = concatPath( path, pathAdjustment );
        path = concatPath( path, childPath );
        return path;
    }
5473#private String concatPath( String base, String path )
    {
        String result = base;

        if ( path != null && path.length() > 0 )
        {
            if ( ( result.endsWith( "/" ) && !path.startsWith( "/" ) )
                || ( !result.endsWith( "/" ) && path.startsWith( "/" ) ) )
            {
                result += path;
            }
            else if ( result.endsWith( "/" ) && path.startsWith( "/" ) )
            {
                result += path.substring( 1 );
            }
            else
            {
                result += '/';
                result += path;
            }
            if ( base.endsWith( "/" ) && !result.endsWith( "/" ) )
            {
                result += '/';
            }
        }

        return result;
    }
5474#/**
     * Merges duplicate elements like multiple declarations of the same build plugin in the specified model.
     * 
     * @param model The model whose duplicate elements should be merged, must not be {@code null}.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void mergeDuplicates( Model model, ModelBuildingRequest request, ModelProblemCollector problems );
5475#/**
     * Sets default values in the specified model that for technical reasons cannot be set directly in the Modello
     * definition.
     * 
     * @param model The model in which to set the default values, must not be {@code null}.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void injectDefaultValues( Model model, ModelBuildingRequest request, ModelProblemCollector problems );
5476#public void mergeDuplicates( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        Build build = model.getBuild();
        if ( build != null )
        {
            List<Plugin> plugins = build.getPlugins();
            Map<Object, Plugin> normalized = new LinkedHashMap<Object, Plugin>( plugins.size() * 2 );

            for ( Plugin plugin : plugins )
            {
                Object key = plugin.getKey();
                Plugin first = normalized.get( key );
                if ( first != null )
                {
                    merger.mergePlugin( plugin, first );
                }
                normalized.put( key, plugin );
            }

            if ( plugins.size() != normalized.size() )
            {
                build.setPlugins( new ArrayList<Plugin>( normalized.values() ) );
            }
        }

        /*
         * NOTE: This is primarily to keep backward-compat with Maven 2.x which did not validate that dependencies are
         * unique within a single POM. Upon multiple declarations, 2.x just kept the last one but retained the order of
         * the first occurrence. So when we're in lenient/compat mode, we have to deal with such broken POMs and mimic
         * the way 2.x works. When we're in strict mode, the removal of duplicates just saves other merging steps from
         * aftereffects and bogus error messages.
         */
        List<Dependency> dependencies = model.getDependencies();
        Map<String, Dependency> normalized = new LinkedHashMap<String, Dependency>( dependencies.size() * 2 );

        for ( Dependency dependency : dependencies )
        {
            normalized.put( dependency.getManagementKey(), dependency );
        }

        if ( dependencies.size() != normalized.size() )
        {
            model.setDependencies( new ArrayList<Dependency>( normalized.values() ) );
        }
    }
5477#public void injectDefaultValues( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        injectDependencyDefaults( model.getDependencies() );

        Build build = model.getBuild();
        if ( build != null )
        {
            for ( Plugin plugin : build.getPlugins() )
            {
                injectDependencyDefaults( plugin.getDependencies() );
            }
        }
    }
5478#private void injectDependencyDefaults( List<Dependency> dependencies )
    {
        for ( Dependency dependency : dependencies )
        {
            if ( StringUtils.isEmpty( dependency.getScope() ) )
            {
                // we cannot set this directly in the MDO due to the interactions with dependency management
                dependency.setScope( "compile" );
            }
        }
    }
5479#public void mergePlugin( Plugin target, Plugin source )
        {
            super.mergePlugin( target, source, false, Collections.emptyMap() );
        }
5480#/**
     * Normalizes the well-known URLs of the specified model.
     * 
     * @param model The model whose URLs should be normalized, may be {@code null}.
     * @param request The model building request that holds further settings, must not be {@code null}.
     */
    void normalize( Model model, ModelBuildingRequest request );
5481#/**
     * Normalizes the specified URL.
     * 
     * @param url The URL to normalize, may be {@code null}.
     * @return The normalized URL or {@code null} if the input was {@code null}.
     */
    String normalize( String url );
5482#public DefaultModelPathTranslator setPathTranslator( PathTranslator pathTranslator )
    {
        this.pathTranslator = pathTranslator;
        return this;
    }
5483#public void alignToBaseDirectory( Model model, File basedir, ModelBuildingRequest request )
    {
        if ( model == null || basedir == null )
        {
            return;
        }

        Build build = model.getBuild();

        if ( build != null )
        {
            build.setDirectory( alignToBaseDirectory( build.getDirectory(), basedir ) );

            build.setSourceDirectory( alignToBaseDirectory( build.getSourceDirectory(), basedir ) );

            build.setTestSourceDirectory( alignToBaseDirectory( build.getTestSourceDirectory(), basedir ) );

            build.setScriptSourceDirectory( alignToBaseDirectory( build.getScriptSourceDirectory(), basedir ) );

            for ( Resource resource : build.getResources() )
            {
                resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) );
            }

            for ( Resource resource : build.getTestResources() )
            {
                resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) );
            }

            if ( build.getFilters() != null )
            {
                List<String> filters = new ArrayList<String>( build.getFilters().size() );
                for ( String filter : build.getFilters() )
                {
                    filters.add( alignToBaseDirectory( filter, basedir ) );
                }
                build.setFilters( filters );
            }

            build.setOutputDirectory( alignToBaseDirectory( build.getOutputDirectory(), basedir ) );

            build.setTestOutputDirectory( alignToBaseDirectory( build.getTestOutputDirectory(), basedir ) );
        }

        Reporting reporting = model.getReporting();

        if ( reporting != null )
        {
            reporting.setOutputDirectory( alignToBaseDirectory( reporting.getOutputDirectory(), basedir ) );
        }
    }
5484#private String alignToBaseDirectory( String path, File basedir )
    {
        return pathTranslator.alignToBaseDirectory( path, basedir );
    }
5485#/**
     * Resolves the specified path against the given base directory. The resolved path will be absolute and uses the
     * platform-specific file separator if a base directory is given. Otherwise, the input path will be returned
     * unaltered.
     * 
     * @param path The path to resolve, may be {@code null}.
     * @param basedir The base directory to resolve relative paths against, may be {@code null}.
     * @return The resolved path or {@code null} if the input path was {@code null}.
     */
    String alignToBaseDirectory( String path, File basedir );
5486#/**
     * Resolves the well-known paths of the specified model against the given base directory. Paths within plugin
     * configuration are not processed.
     * 
     * @param model The model whose paths should be resolved, may be {@code null}.
     * @param basedir The base directory to resolve relative paths against, may be {@code null}.
     * @param request The model building request that holds further settings, must not be {@code null}.
     */
    void alignToBaseDirectory( Model model, File basedir, ModelBuildingRequest request );
5487#public DefaultModelUrlNormalizer setUrlNormalizer( UrlNormalizer urlNormalizer )
    {
        this.urlNormalizer = urlNormalizer;
        return this;
    }
5488#public void normalize( Model model, ModelBuildingRequest request )
    {
        if ( model == null )
        {
            return;
        }

        model.setUrl( normalize( model.getUrl() ) );

        Scm scm = model.getScm();
        if ( scm != null )
        {
            scm.setUrl( normalize( scm.getUrl() ) );
            scm.setConnection( normalize( scm.getConnection() ) );
            scm.setDeveloperConnection( normalize( scm.getDeveloperConnection() ) );
        }

        DistributionManagement dist = model.getDistributionManagement();
        if ( dist != null )
        {
            Site site = dist.getSite();
            if ( site != null )
            {
                site.setUrl( normalize( site.getUrl() ) );
            }
        }
    }
5489#private String normalize( String url )
    {
        return urlNormalizer.normalize( url );
    }
5490#public String normalize( String url )
    {
        String result = url;

        if ( result != null )
        {
            while ( true )
            {
                int idx = result.indexOf( "/../" );
                if ( idx <= 0 )
                {
                    break;
                }
                int parent = idx - 1;
                while ( parent >= 0 && result.charAt( parent ) == '/' )
                {
                    parent--;
                }
                parent = result.lastIndexOf( '/', parent );
                if ( parent < 0 )
                {
                    break;
                }
                result = result.substring( 0, parent ) + result.substring( idx + 3 );
            }
        }

        return result;
    }
5491#public String alignToBaseDirectory( String path, File basedir )
    {
        String result = path;

        if ( path != null && basedir != null )
        {
            path = path.replace( '\\', File.separatorChar ).replace( '/', File.separatorChar );

            File file = new File( path );
            if ( file.isAbsolute() )
            {
                // path was already absolute, just normalize file separator and we're done
                result = file.getPath();
            }
            else if ( file.getPath().startsWith( File.separator ) )
            {
                // drive-relative Windows path, don't align with project directory but with drive root
                result = file.getAbsolutePath();
            }
            else
            {
                // an ordinary relative path, align with project directory
                result = new File( new File( basedir, path ).toURI().normalize() ).getAbsolutePath();
            }
        }

        return result;
    }
5492#public void convertReporting( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        Reporting reporting = model.getReporting();

        if ( reporting == null )
        {
            return;
        }

        Build build = model.getBuild();

        if ( build == null )
        {
            build = new Build();
            model.setBuild( build );
        }

        Plugin sitePlugin = findSitePlugin( build );

        if ( sitePlugin == null )
        {
            sitePlugin = new Plugin();
            sitePlugin.setArtifactId( "maven-site-plugin" );
            PluginManagement pluginManagement = build.getPluginManagement();
            if ( pluginManagement == null )
            {
                pluginManagement = new PluginManagement();
                build.setPluginManagement( pluginManagement );
            }
            pluginManagement.addPlugin( sitePlugin );
        }

        Xpp3Dom configuration = (Xpp3Dom) sitePlugin.getConfiguration();

        if ( configuration == null )
        {
            configuration = new Xpp3Dom( "configuration" );
            sitePlugin.setConfiguration( configuration );
        }

        Xpp3Dom reportPlugins = configuration.getChild( "reportPlugins" );

        if ( reportPlugins != null )
        {
            // new-style report configuration already present, assume user handled entire conversion
            return;
        }

        if ( configuration.getChild( "outputDirectory" ) == null )
        {
            addDom( configuration, "outputDirectory", reporting.getOutputDirectory() );
        }

        reportPlugins = new Xpp3Dom( "reportPlugins" );
        configuration.addChild( reportPlugins );

        boolean hasMavenProjectInfoReportsPlugin = false;

        if ( !reporting.getPlugins().isEmpty()
            && request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1 )
        {

            problems.add( Severity.WARNING, "The <reporting> section is deprecated"
                + ", please move the reports to the <configuration> section of the new Maven Site Plugin.",
                          reporting.getLocation( "" ), null );
        }

        for ( ReportPlugin plugin : reporting.getPlugins() )
        {
            Xpp3Dom reportPlugin = convert( plugin );
            reportPlugins.addChild( reportPlugin );

            if ( !reporting.isExcludeDefaults() && !hasMavenProjectInfoReportsPlugin
                && "org.apache.maven.plugins".equals( plugin.getGroupId() )
                && "maven-project-info-reports-plugin".equals( plugin.getArtifactId() ) )
            {
                hasMavenProjectInfoReportsPlugin = true;
            }
        }

        if ( !reporting.isExcludeDefaults() && !hasMavenProjectInfoReportsPlugin )
        {
            Xpp3Dom dom = new Xpp3Dom( "reportPlugin" );

            addDom( dom, "groupId", "org.apache.maven.plugins" );
            addDom( dom, "artifactId", "maven-project-info-reports-plugin" );

            reportPlugins.addChild( dom );
        }
    }
5493#private Plugin findSitePlugin( Build build )
    {
        for ( Plugin plugin : build.getPlugins() )
        {
            if ( isSitePlugin( plugin ) )
            {
                return plugin;
            }
        }

        PluginManagement pluginManagement = build.getPluginManagement();
        if ( pluginManagement != null )
        {
            for ( Plugin plugin : pluginManagement.getPlugins() )
            {
                if ( isSitePlugin( plugin ) )
                {
                    return plugin;
                }
            }
        }

        return null;
    }
5494#private boolean isSitePlugin( Plugin plugin )
    {
        return "maven-site-plugin".equals( plugin.getArtifactId() )
            && "org.apache.maven.plugins".equals( plugin.getGroupId() );
    }
5495#private Xpp3Dom convert( ReportPlugin plugin )
    {
        Xpp3Dom dom = new Xpp3Dom( "reportPlugin" );

        addDom( dom, "groupId", plugin.getGroupId() );
        addDom( dom, "artifactId", plugin.getArtifactId() );
        addDom( dom, "version", plugin.getVersion() );

        Xpp3Dom configuration = (Xpp3Dom) plugin.getConfiguration();
        if ( configuration != null )
        {
            configuration = new Xpp3Dom( configuration );
            dom.addChild( configuration );
        }

        if ( !plugin.getReportSets().isEmpty() )
        {
            Xpp3Dom reportSets = new Xpp3Dom( "reportSets" );
            for ( ReportSet reportSet : plugin.getReportSets() )
            {
                Xpp3Dom rs = convert( reportSet );
                reportSets.addChild( rs );
            }
            dom.addChild( reportSets );
        }

        return dom;
    }
5496#private Xpp3Dom convert( ReportSet reportSet )
    {
        Xpp3Dom dom = new Xpp3Dom( "reportSet" );

        addDom( dom, "id", reportSet.getId() );

        Xpp3Dom configuration = (Xpp3Dom) reportSet.getConfiguration();
        if ( configuration != null )
        {
            configuration = new Xpp3Dom( configuration );
            dom.addChild( configuration );
        }

        if ( !reportSet.getReports().isEmpty() )
        {
            Xpp3Dom reports = new Xpp3Dom( "reports" );
            for ( String report : reportSet.getReports() )
            {
                addDom( reports, "report", report );
            }
            dom.addChild( reports );
        }

        return dom;
    }
5497#private void addDom( Xpp3Dom parent, String childName, String childValue )
    {
        if ( StringUtils.isNotEmpty( childValue ) )
        {
            parent.addChild( newDom( childName, childValue ) );
        }
    }
5498#private Xpp3Dom newDom( String name, String value )
    {
        Xpp3Dom dom = new Xpp3Dom( name );
        dom.setValue( value );
        return dom;
    }
5499#/**
     * Injects plugin executions induced by lifecycle bindings into the specified model. The model has already undergone
     * injection of plugin management so any plugins that are injected by lifecycle bindings and are not already present
     * in the model's plugin section need to be subjected to the model's plugin management.
     * 
     * @param model The model into which to inject the default plugin executions for its packaging, must not be
     *            <code>null</code>.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void injectLifecycleBindings( Model model, ModelBuildingRequest request, ModelProblemCollector problems );
5500#/**
     * Merges values from general build plugin configuration into the individual plugin executions of the given model.
     * 
     * @param model The model whose build plugin configuration should be expanded, must not be <code>null</code>.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void expandPluginConfiguration( Model model, ModelBuildingRequest request, ModelProblemCollector problems );
5501#public void expandPluginConfiguration( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        Reporting reporting = model.getReporting();

        if ( reporting != null )
        {
            for ( ReportPlugin reportPlugin : reporting.getPlugins() )
            {
                Xpp3Dom parentDom = (Xpp3Dom) reportPlugin.getConfiguration();

                if ( parentDom != null )
                {
                    for ( ReportSet execution : reportPlugin.getReportSets() )
                    {
                        Xpp3Dom childDom = (Xpp3Dom) execution.getConfiguration();
                        childDom = Xpp3Dom.mergeXpp3Dom( childDom, new Xpp3Dom( parentDom ) );
                        execution.setConfiguration( childDom );
                    }
                }
            }
        }
    }
5502#/**
     * Merges values from general report plugin configuration into the individual reports sets of the given model.
     * 
     * @param model The model whose report plugin configuration should be expanded, must not be <code>null</code>.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void expandPluginConfiguration( Model model, ModelBuildingRequest request, ModelProblemCollector problems );
5503#public void expandPluginConfiguration( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        Build build = model.getBuild();

        if ( build != null )
        {
            expand( build.getPlugins() );

            PluginManagement pluginManagement = build.getPluginManagement();

            if ( pluginManagement != null )
            {
                expand( pluginManagement.getPlugins() );
            }
        }
    }
5504#private void expand( List<Plugin> plugins )
    {
        for ( Plugin plugin : plugins )
        {
            Xpp3Dom pluginConfiguration = (Xpp3Dom) plugin.getConfiguration();

            if ( pluginConfiguration != null )
            {
                for ( PluginExecution execution : plugin.getExecutions() )
                {
                    Xpp3Dom executionConfiguration = (Xpp3Dom) execution.getConfiguration();

                    executionConfiguration =
                        Xpp3Dom.mergeXpp3Dom( executionConfiguration, new Xpp3Dom( pluginConfiguration ) );

                    execution.setConfiguration( executionConfiguration );
                }
            }
        }
    }
5505#/**
     * Converts values from model's reporting section into the configuration for the new Maven Site Plugin.
     * 
     * @param model The model whose reporting section should be converted, must not be <code>null</code>.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void convertReporting( Model model, ModelBuildingRequest request, ModelProblemCollector problems );
5506#public void injectProfile( Model model, Profile profile, ModelBuildingRequest request,
                               ModelProblemCollector problems )
    {
        if ( profile != null )
        {
            merger.mergeModelBase( model, profile );

            if ( profile.getBuild() != null )
            {
                if ( model.getBuild() == null )
                {
                    model.setBuild( new Build() );
                }
                merger.mergeBuildBase( model.getBuild(), profile.getBuild() );
            }
        }
    }
5507#public void mergeModelBase( ModelBase target, ModelBase source )
        {
            mergeModelBase( target, source, true, Collections.emptyMap() );
        }
5508#public void mergeBuildBase( BuildBase target, BuildBase source )
        {
            mergeBuildBase( target, source, true, Collections.emptyMap() );
        }
5509#@Override
        protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                     boolean sourceDominant, Map<Object, Object> context )
        {
            List<Plugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<Plugin> tgt = target.getPlugins();
                Map<Object, Plugin> master = new LinkedHashMap<Object, Plugin>( tgt.size() * 2 );

                for ( Plugin element : tgt )
                {
                    Object key = getPluginKey( element );
                    master.put( key, element );
                }

                Map<Object, List<Plugin>> predecessors = new LinkedHashMap<Object, List<Plugin>>();
                List<Plugin> pending = new ArrayList<Plugin>();
                for ( Plugin element : src )
                {
                    Object key = getPluginKey( element );
                    Plugin existing = master.get( key );
                    if ( existing != null )
                    {
                        mergePlugin( existing, element, sourceDominant, context );

                        if ( !pending.isEmpty() )
                        {
                            predecessors.put( key, pending );
                            pending = new ArrayList<Plugin>();
                        }
                    }
                    else
                    {
                        pending.add( element );
                    }
                }

                List<Plugin> result = new ArrayList<Plugin>( src.size() + tgt.size() );
                for ( Map.Entry<Object, Plugin> entry : master.entrySet() )
                {
                    List<Plugin> pre = predecessors.get( entry.getKey() );
                    if ( pre != null )
                    {
                        result.addAll( pre );
                    }
                    result.add( entry.getValue() );
                }
                result.addAll( pending );

                target.setPlugins( result );
            }
        }
5510#@Override
        protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<PluginExecution> src = source.getExecutions();
            if ( !src.isEmpty() )
            {
                List<PluginExecution> tgt = target.getExecutions();
                Map<Object, PluginExecution> merged =
                    new LinkedHashMap<Object, PluginExecution>( ( src.size() + tgt.size() ) * 2 );

                for ( PluginExecution element : tgt )
                {
                    Object key = getPluginExecutionKey( element );
                    merged.put( key, element );
                }

                for ( PluginExecution element : src )
                {
                    Object key = getPluginExecutionKey( element );
                    PluginExecution existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergePluginExecution( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setExecutions( new ArrayList<PluginExecution>( merged.values() ) );
            }
        }
5511#@Override
        protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                               Map<Object, Object> context )
        {
            List<ReportPlugin> src = source.getPlugins();
            if ( !src.isEmpty() )
            {
                List<ReportPlugin> tgt = target.getPlugins();
                Map<Object, ReportPlugin> merged =
                    new LinkedHashMap<Object, ReportPlugin>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportPlugin element : tgt )
                {
                    Object key = getReportPluginKey( element );
                    merged.put( key, element );
                }

                for ( ReportPlugin element : src )
                {
                    Object key = getReportPluginKey( element );
                    ReportPlugin existing = merged.get( key );
                    if ( existing == null )
                    {
                        merged.put( key, element );
                    }
                    else
                    {
                        mergeReportPlugin( existing, element, sourceDominant, context );
                    }
                }

                target.setPlugins( new ArrayList<ReportPlugin>( merged.values() ) );
            }
        }
5512#@Override
        protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                     Map<Object, Object> context )
        {
            List<ReportSet> src = source.getReportSets();
            if ( !src.isEmpty() )
            {
                List<ReportSet> tgt = target.getReportSets();
                Map<Object, ReportSet> merged = new LinkedHashMap<Object, ReportSet>( ( src.size() + tgt.size() ) * 2 );

                for ( ReportSet element : tgt )
                {
                    Object key = getReportSetKey( element );
                    merged.put( key, element );
                }

                for ( ReportSet element : src )
                {
                    Object key = getReportSetKey( element );
                    ReportSet existing = merged.get( key );
                    if ( existing != null )
                    {
                        mergeReportSet( existing, element, sourceDominant, context );
                    }
                    else
                    {
                        merged.put( key, element );
                    }
                }

                target.setReportSets( new ArrayList<ReportSet>( merged.values() ) );
            }
        }
5513#/**
     * Merges values from the specified profile into the given model. Implementations are expected to keep the profile
     * and model completely decoupled by injecting deep copies rather than the original objects from the profile.
     * 
     * @param model The model into which to merge the values defined by the profile, must not be <code>null</code>.
     * @param profile The (read-only) profile whose values should be injected, may be <code>null</code>.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void injectProfile( Model model, Profile profile, ModelBuildingRequest request, ModelProblemCollector problems );
5514#public List<String> getActiveProfileIds()
    {
        return activeProfileIds;
    }
5515#/**
     * Sets the identifiers of those profiles that should be activated by explicit demand.
     * 
     * @param activeProfileIds The identifiers of those profiles to activate, may be {@code null}.
     * @return This context, never {@code null}.
     */
    public DefaultProfileActivationContext setActiveProfileIds( List<String> activeProfileIds )
    {
        if ( activeProfileIds != null )
        {
            this.activeProfileIds = Collections.unmodifiableList( activeProfileIds );
        }
        else
        {
            this.activeProfileIds = Collections.emptyList();
        }

        return this;
    }
5516#public List<String> getInactiveProfileIds()
    {
        return inactiveProfileIds;
    }
5517#/**
     * Sets the identifiers of those profiles that should be deactivated by explicit demand.
     * 
     * @param inactiveProfileIds The identifiers of those profiles to deactivate, may be {@code null}.
     * @return This context, never {@code null}.
     */
    public DefaultProfileActivationContext setInactiveProfileIds( List<String> inactiveProfileIds )
    {
        if ( inactiveProfileIds != null )
        {
            this.inactiveProfileIds = Collections.unmodifiableList( inactiveProfileIds );
        }
        else
        {
            this.inactiveProfileIds = Collections.emptyList();
        }

        return this;
    }
5518#public Map<String, String> getSystemProperties()
    {
        return systemProperties;
    }
5519#/**
     * Sets the system properties to use for interpolation and profile activation. The system properties are collected
     * from the runtime environment like {@link System#getProperties()} and environment variables.
     * 
     * @param systemProperties The system properties, may be {@code null}.
     * @return This context, never {@code null}.
     */
    @SuppressWarnings( "unchecked" )
    public DefaultProfileActivationContext setSystemProperties( Properties systemProperties )
    {
        if ( systemProperties != null )
        {
            this.systemProperties = Collections.unmodifiableMap( (Map) systemProperties );
        }
        else
        {
            this.systemProperties = Collections.emptyMap();
        }

        return this;
    }
5520#/**
     * Sets the system properties to use for interpolation and profile activation. The system properties are collected
     * from the runtime environment like {@link System#getProperties()} and environment variables.
     * 
     * @param systemProperties The system properties, may be {@code null}.
     * @return This context, never {@code null}.
     */
    public DefaultProfileActivationContext setSystemProperties( Map<String, String> systemProperties )
    {
        if ( systemProperties != null )
        {
            this.systemProperties = Collections.unmodifiableMap( systemProperties );
        }
        else
        {
            this.systemProperties = Collections.emptyMap();
        }

        return this;
    }
5521#public Map<String, String> getUserProperties()
    {
        return userProperties;
    }
5522#/**
     * Sets the user properties to use for interpolation and profile activation. The user properties have been
     * configured directly by the user on his discretion, e.g. via the {@code -Dkey=value} parameter on the command
     * line.
     * 
     * @param userProperties The user properties, may be {@code null}.
     * @return This context, never {@code null}.
     */
    @SuppressWarnings( "unchecked" )
    public DefaultProfileActivationContext setUserProperties( Properties userProperties )
    {
        if ( userProperties != null )
        {
            this.userProperties = Collections.unmodifiableMap( (Map) userProperties );
        }
        else
        {
            this.userProperties = Collections.emptyMap();
        }

        return this;
    }
5523#/**
     * Sets the user properties to use for interpolation and profile activation. The user properties have been
     * configured directly by the user on his discretion, e.g. via the {@code -Dkey=value} parameter on the command
     * line.
     * 
     * @param userProperties The user properties, may be {@code null}.
     * @return This context, never {@code null}.
     */
    public DefaultProfileActivationContext setUserProperties( Map<String, String> userProperties )
    {
        if ( userProperties != null )
        {
            this.userProperties = Collections.unmodifiableMap( userProperties );
        }
        else
        {
            this.userProperties = Collections.emptyMap();
        }

        return this;
    }
5524#public File getProjectDirectory()
    {
        return projectDirectory;
    }
5525#/**
     * Sets the base directory of the current project.
     * 
     * @param projectDirectory The base directory of the current project, may be {@code null} if profile activation
     *            happens in the context of metadata retrieval rather than project building.
     * @return This context, never {@code null}.
     */
    public DefaultProfileActivationContext setProjectDirectory( File projectDirectory )
    {
        this.projectDirectory = projectDirectory;

        return this;
    }
5526#/**
     * Determines the profiles which are active in the specified activation context. Active profiles will eventually be
     * injected into the model.
     * 
     * @param profiles The profiles whose activation status should be determined, must not be {@code null}.
     * @param context The environmental context used to determine the activation status of a profile, must not be
     *            {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     * @return The profiles that have been activated, never {@code null}.
     */
    List<Profile> getActiveProfiles( Collection<Profile> profiles, ProfileActivationContext context,
                                     ModelProblemCollector problems );
5527#public DefaultProfileSelector addProfileActivator( ProfileActivator profileActivator )
    {
        if ( profileActivator != null )
        {
            activators.add( profileActivator );
        }
        return this;
    }
5528#public List<Profile> getActiveProfiles( Collection<Profile> profiles, ProfileActivationContext context,
                                            ModelProblemCollector problems )
    {
        Collection<String> activatedIds = new HashSet<String>( context.getActiveProfileIds() );
        Collection<String> deactivatedIds = new HashSet<String>( context.getInactiveProfileIds() );

        List<Profile> activeProfiles = new ArrayList<Profile>( profiles.size() );
        List<Profile> activePomProfilesByDefault = new ArrayList<Profile>();
        boolean activatedPomProfileNotByDefault = false;

        for ( Profile profile : profiles )
        {
            if ( !deactivatedIds.contains( profile.getId() ) )
            {
                if ( activatedIds.contains( profile.getId() ) || isActive( profile, context, problems ) )
                {
                    activeProfiles.add( profile );

                    if ( Profile.SOURCE_POM.equals( profile.getSource() ) )
                    {
                        activatedPomProfileNotByDefault = true;
                    }
                }
                else if ( isActiveByDefault( profile ) )
                {
                    if ( Profile.SOURCE_POM.equals( profile.getSource() ) )
                    {
                        activePomProfilesByDefault.add( profile );
                    }
                    else
                    {
                        activeProfiles.add( profile );
                    }
                }

            }
        }

        if ( !activatedPomProfileNotByDefault )
        {
            activeProfiles.addAll( activePomProfilesByDefault );
        }

        return activeProfiles;
    }
5529#private boolean isActive( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        for ( ProfileActivator activator : activators )
        {
            try
            {
                if ( activator.isActive( profile, context, problems ) )
                {
                    return true;
                }
            }
            catch ( RuntimeException e )
            {
                problems.add( Severity.ERROR, "Failed to determine activation for profile " + profile.getId(),
                              profile.getLocation( "" ), e );
                return false;
            }
        }
        return false;
    }
5530#private boolean isActiveByDefault( Profile profile )
    {
        Activation activation = profile.getActivation();
        return activation != null && activation.isActiveByDefault();
    }
5531#/**
     * Gets the identifiers of those profiles that should be activated by explicit demand.
     * 
     * @return The identifiers of those profiles to activate, never {@code null}.
     */
    List<String> getActiveProfileIds();
5532#/**
     * Gets the identifiers of those profiles that should be deactivated by explicit demand.
     * 
     * @return The identifiers of those profiles to deactivate, never {@code null}.
     */
    List<String> getInactiveProfileIds();
5533#/**
     * Gets the system properties to use for interpolation and profile activation. The system properties are collected
     * from the runtime environment like {@link System#getProperties()} and environment variables.
     * 
     * @return The execution properties, never {@code null}.
     */
    Map<String, String> getSystemProperties();
5534#/**
     * Gets the user properties to use for interpolation and profile activation. The user properties have been
     * configured directly by the user on his discretion, e.g. via the {@code -Dkey=value} parameter on the command
     * line.
     * 
     * @return The user properties, never {@code null}.
     */
    Map<String, String> getUserProperties();
5535#/**
     * Gets the base directory of the current project (if any).
     * 
     * @return The base directory of the current project or {@code null} if none.
     */
    File getProjectDirectory();
5536#public boolean isActive( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        boolean active = false;

        Activation activation = profile.getActivation();

        if ( activation != null )
        {
            ActivationProperty property = activation.getProperty();

            if ( property != null )
            {
                String name = property.getName();
                boolean reverseName = false;

                if ( name != null && name.startsWith( "!" ) )
                {
                    reverseName = true;
                    name = name.substring( 1 );
                }

                if ( name == null || name.length() <= 0 )
                {
                    problems.add( Severity.ERROR, "The property name is required to activate the profile "
                        + profile.getId(), property.getLocation( "" ), null );
                    return false;
                }

                String sysValue = context.getUserProperties().get( name );
                if ( sysValue == null )
                {
                    sysValue = context.getSystemProperties().get( name );
                }

                String propValue = property.getValue();
                if ( StringUtils.isNotEmpty( propValue ) )
                {
                    boolean reverseValue = false;
                    if ( propValue.startsWith( "!" ) )
                    {
                        reverseValue = true;
                        propValue = propValue.substring( 1 );
                    }

                    // we have a value, so it has to match the system value...
                    boolean result = propValue.equals( sysValue );

                    if ( reverseValue )
                    {
                        active = !result;
                    }
                    else
                    {
                        active = result;
                    }
                }
                else
                {
                    boolean result = StringUtils.isNotEmpty( sysValue );

                    if ( reverseName )
                    {
                        active = !result;
                    }
                    else
                    {
                        active = result;
                    }
                }
            }
        }

        return active;
    }
5537#/**
     * Determines whether the specified profile is active in the given activator context.
     * 
     * @param profile The profile whose activation status should be determined, must not be {@code null}.
     * @param context The environmental context used to determine the activation status of the profile, must not be
     *            {@code null}.
     * @param problems The container used to collect problems (e.g. bad syntax) that were encountered, must not be
     *            {@code null}.
     * @return {@code true} if the profile is active, {@code false} otherwise.
     */
    boolean isActive( Profile profile, ProfileActivationContext context, ModelProblemCollector problems );
5538#public FileProfileActivator setPathTranslator( PathTranslator pathTranslator )
    {
        this.pathTranslator = pathTranslator;
        return this;
    }
5539#public boolean isActive( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        Activation activation = profile.getActivation();

        if ( activation == null )
        {
            return false;
        }

        ActivationFile file = activation.getFile();

        if ( file == null )
        {
            return false;
        }

        String path;
        boolean missing;

        if ( StringUtils.isNotEmpty( file.getExists() ) )
        {
            path = file.getExists();
            missing = false;
        }
        else if ( StringUtils.isNotEmpty( file.getMissing() ) )
        {
            path = file.getMissing();
            missing = true;
        }
        else
        {
            return false;
        }

        RegexBasedInterpolator interpolator = new RegexBasedInterpolator();

        final File basedir = context.getProjectDirectory();

        if ( basedir != null )
        {
            interpolator.addValueSource( new AbstractValueSource( false )
            {
                public Object getValue( String expression )
                {
                    /*
                     * NOTE: We intentionally only support ${basedir} and not ${project.basedir} as the latter form
                     * would suggest that other project.* expressions can be used which is however beyond the design.
                     */
                    if ( "basedir".equals( expression ) )
                    {
                        return basedir.getAbsolutePath();
                    }
                    return null;
                }
            } );
        }
        else if ( path.indexOf( "${basedir}" ) >= 0 )
        {
            return false;
        }

        interpolator.addValueSource( new MapBasedValueSource( context.getUserProperties() ) );

        interpolator.addValueSource( new MapBasedValueSource( context.getSystemProperties() ) );

        try
        {
            path = interpolator.interpolate( path, "" );
        }
        catch ( Exception e )
        {
            problems.add( Severity.ERROR, "Failed to interpolate file location " + path + " for profile "
                + profile.getId() + ": " + e.getMessage(), file.getLocation( missing ? "missing" : "exists" ), e );
            return false;
        }

        path = pathTranslator.alignToBaseDirectory( path, basedir );

        File f = new File( path );

        if ( !f.isAbsolute() )
        {
            return false;
        }

        boolean fileExists = f.exists();

        return missing ? !fileExists : fileExists;
    }
5540#public boolean isActive( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        boolean active = false;

        Activation activation = profile.getActivation();

        if ( activation != null )
        {
            ActivationOS os = activation.getOs();

            if ( os != null )
            {
                active = ensureAtLeastOneNonNull( os );

                if ( active && os.getFamily() != null )
                {
                    active = determineFamilyMatch( os.getFamily() );
                }
                if ( active && os.getName() != null )
                {
                    active = determineNameMatch( os.getName() );
                }
                if ( active && os.getArch() != null )
                {
                    active = determineArchMatch( os.getArch() );
                }
                if ( active && os.getVersion() != null )
                {
                    active = determineVersionMatch( os.getVersion() );
                }
            }
        }

        return active;
    }
5541#private boolean ensureAtLeastOneNonNull( ActivationOS os )
    {
        return os.getArch() != null || os.getFamily() != null || os.getName() != null || os.getVersion() != null;
    }
5542#private boolean determineVersionMatch( String version )
    {
        String test = version;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isVersion( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }
5543#private boolean determineArchMatch( String arch )
    {
        String test = arch;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isArch( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }
5544#private boolean determineNameMatch( String name )
    {
        String test = name;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isName( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }
5545#private boolean determineFamilyMatch( String family )
    {
        String test = family;
        boolean reverse = false;

        if ( test.startsWith( "!" ) )
        {
            reverse = true;
            test = test.substring( 1 );
        }

        boolean result = Os.isFamily( test );

        if ( reverse )
        {
            return !result;
        }
        else
        {
            return result;
        }
    }
5546#public boolean isActive( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )
    {
        boolean active = false;

        Activation activation = profile.getActivation();

        if ( activation != null )
        {
            String jdk = activation.getJdk();

            if ( jdk != null )
            {
                String version = context.getSystemProperties().get( "java.version" );

                if ( version == null || version.length() <= 0 )
                {
                    problems.add( Severity.ERROR, "Failed to determine Java version for profile " + profile.getId(),
                                  activation.getLocation( "jdk" ), null );
                    return false;
                }

                if ( jdk.startsWith( "!" ) )
                {
                    active = !version.startsWith( jdk.substring( 1 ) );
                }
                else if ( isRange( jdk ) )
                {
                    active = isInRange( version, getRange( jdk ) );
                }
                else
                {
                    active = version.startsWith( jdk );
                }
            }
        }

        return active;
    }
5547#private static boolean isInRange( String value, List<RangeValue> range )
    {
        int leftRelation = getRelationOrder( value, range.get( 0 ), true );

        if ( leftRelation == 0 )
        {
            return true;
        }

        if ( leftRelation < 0 )
        {
            return false;
        }

        return getRelationOrder( value, range.get( 1 ), false ) <= 0;
    }
5548#private static int getRelationOrder( String value, RangeValue rangeValue, boolean isLeft )
    {
        if ( rangeValue.value.length() <= 0 )
        {
            return isLeft ? 1 : -1;
        }

        value = value.replaceAll( "[^0-9\\.\\-\\_]", "" );

        List<String> valueTokens = new ArrayList<String>( Arrays.asList( value.split( "[\\.\\-\\_]" ) ) );
        List<String> rangeValueTokens = new ArrayList<String>( Arrays.asList( rangeValue.value.split( "\\." ) ) );

        addZeroTokens( valueTokens, 3 );
        addZeroTokens( rangeValueTokens, 3 );

        for ( int i = 0; i < 3; i++ )
        {
            int x = Integer.parseInt( valueTokens.get( i ) );
            int y = Integer.parseInt( rangeValueTokens.get( i ) );
            if ( x < y )
            {
                return -1;
            }
            else if ( x > y )
            {
                return 1;
            }
        }
        if ( !rangeValue.closed )
        {
            return isLeft ? -1 : 1;
        }
        return 0;
    }
5549#private static void addZeroTokens( List<String> tokens, int max )
    {
        while ( tokens.size() < max )
        {
            tokens.add( "0" );
        }
    }
5550#private static boolean isRange( String value )
    {
        return value.startsWith( "[" ) || value.startsWith( "(" );
    }
5551#private static List<RangeValue> getRange( String range )
    {
        List<RangeValue> ranges = new ArrayList<RangeValue>();

        for ( String token : range.split( "," ) )
        {
            if ( token.startsWith( "[" ) )
            {
                ranges.add( new RangeValue( token.replace( "[", "" ), true ) );
            }
            else if ( token.startsWith( "(" ) )
            {
                ranges.add( new RangeValue( token.replace( "(", "" ), false ) );
            }
            else if ( token.endsWith( "]" ) )
            {
                ranges.add( new RangeValue( token.replace( "]", "" ), true ) );
            }
            else if ( token.endsWith( ")" ) )
            {
                ranges.add( new RangeValue( token.replace( ")", "" ), false ) );
            }
            else if ( token.length() <= 0 )
            {
                ranges.add( new RangeValue( "", false ) );
            }
        }
        if ( ranges.size() < 2 )
        {
            ranges.add( new RangeValue( "99999999", false ) );
        }
        return ranges;
    }
5552#RangeValue( String value, boolean closed )
        {
            this.value = value.trim();
            this.closed = closed;
        }
5553#public String toString()
        {
            return value;
        }
5554#/**
     * Creates a new exception with specified detail message and cause for the given repository.
     * 
     * @param message The detail message, may be {@code null}.
     * @param repository The repository that caused the error, may be {@code null}.
     * @param cause The cause, may be {@code null}.
     */
    public InvalidRepositoryException( String message, Repository repository, Throwable cause )
    {
        super( message, cause );
        this.repository = repository;
    }
5555#/**
     * Creates a new exception with specified detail message for the given repository.
     * 
     * @param message The detail message, may be {@code null}.
     * @param repository The repository that caused the error, may be {@code null}.
     */
    public InvalidRepositoryException( String message, Repository repository )
    {
        super( message );
        this.repository = repository;
    }
5556#/**
     * Gets the repository that causes this error (if any).
     * 
     * @return The repository that causes this error or {@code null} if not known.
     */
    public Repository getRepository()
    {
        return repository;
    }
5557#/**
     * Tries to resolve the POM for the specified coordinates.
     *
     * @param groupId The group identifier of the POM, must not be {@code null}.
     * @param artifactId The artifact identifier of the POM, must not be {@code null}.
     * @param version The version of the POM, must not be {@code null}.
     * @return The source of the requested POM, never {@code null}.
     * @throws UnresolvableModelException If the POM could not be resolved from any configured repository.
     */
    ModelSource resolveModel( String groupId, String artifactId, String version )
        throws UnresolvableModelException;
5558#/**
     * Adds a repository to use for subsequent resolution requests. The order in which repositories are added matters,
     * repositories that were added first should also be searched first. When multiple repositories with the same
     * identifier are added, only the first repository being added will be used.
     *
     * @param repository The repository to add to the internal search chain, must not be {@code null}.
     * @throws InvalidRepositoryException If the repository could not be added (e.g. due to invalid URL or layout).
     */
    void addRepository( Repository repository )
        throws InvalidRepositoryException;
5559#/**
     * Clones this resolver for usage in a forked resolution process. In general, implementors need not provide a deep
     * clone. The only requirement is that invocations of {@link #addRepository(Repository)} on the clone do not affect
     * the state of the original resolver and vice versa.
     *
     * @return The cloned resolver, never {@code null}.
     */
    ModelResolver newCopy();
5560#/**
     * Creates a new exception with specified detail message and cause.
     * 
     * @param message The detail message, may be {@code null}.
     * @param groupId The group id of the unresolvable model, may be {@code null}.
     * @param artifactId The artifact id of the unresolvable model, may be {@code null}.
     * @param version The version of the unresolvable model, may be {@code null}.
     * @param cause The cause, may be {@code null}.
     */
    public UnresolvableModelException( String message, String groupId, String artifactId, String version,
                                       Throwable cause )
    {
        super( message, cause );
        this.groupId = ( groupId != null ) ? groupId : "";
        this.artifactId = ( artifactId != null ) ? artifactId : "";
        this.version = ( version != null ) ? version : "";
    }
5561#/**
     * Creates a new exception with specified detail message.
     * 
     * @param message The detail message, may be {@code null}.
     * @param groupId The group id of the unresolvable model, may be {@code null}.
     * @param artifactId The artifact id of the unresolvable model, may be {@code null}.
     * @param version The version of the unresolvable model, may be {@code null}.
     */
    public UnresolvableModelException( String message, String groupId, String artifactId, String version )
    {
        super( message );
        this.groupId = ( groupId != null ) ? groupId : "";
        this.artifactId = ( artifactId != null ) ? artifactId : "";
        this.version = ( version != null ) ? version : "";
    }
5562#/**
     * Gets the group id of the unresolvable model.
     * 
     * @return The group id of the unresolvable model, can be empty but never {@code null}.
     */
    public String getGroupId()
    {
        return groupId;
    }
5563#/**
     * Gets the artifact id of the unresolvable model.
     * 
     * @return The artifact id of the unresolvable model, can be empty but never {@code null}.
     */
    public String getArtifactId()
    {
        return artifactId;
    }
5564#/**
     * Gets the version of the unresolvable model.
     * 
     * @return The version of the unresolvable model, can be empty but never {@code null}.
     */
    public String getVersion()
    {
        return version;
    }
5565#public DefaultSuperPomProvider setModelProcessor( ModelProcessor modelProcessor )
    {
        this.modelProcessor = modelProcessor;
        return this;
    }
5566#public Model getSuperModel( String version )
    {
        if ( superModel == null )
        {
            String resource = "/org/apache/maven/model/pom-" + version + ".xml";

            InputStream is = getClass().getResourceAsStream( resource );

            if ( is == null )
            {
                throw new IllegalStateException( "The super POM " + resource + " was not found"
                    + ", please verify the integrity of your Maven installation" );
            }

            try
            {
                Map<String, String> options = new HashMap<String, String>();
                options.put( "xml:4.0.0", "xml:4.0.0" );
                superModel = modelProcessor.read( is, options );
            }
            catch ( IOException e )
            {
                throw new IllegalStateException( "The super POM " + resource + " is damaged"
                    + ", please verify the integrity of your Maven installation", e );
            }
        }

        return superModel;
    }
5567#/**
     * Gets the super POM for the specified model version. The returned model is supposed to be read-only, i.e. if the
     * caller intends to make updates to the model the return value must be cloned before updating to ensure the
     * modifications don't affect future retrievals of the super POM.
     * 
     * @param version The model version to retrieve the super POM for (e.g. "4.0.0"), must not be {@code null}.
     * @return The super POM, never {@code null}.
     */
    Model getSuperModel( String version );
5568#public void validateRawModel( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        Parent parent = model.getParent();
        if ( parent != null )
        {
            validateStringNotEmpty( "parent.groupId", problems, Severity.FATAL, parent.getGroupId(), parent );

            validateStringNotEmpty( "parent.artifactId", problems, Severity.FATAL, parent.getArtifactId(), parent );

            validateStringNotEmpty( "parent.version", problems, Severity.FATAL, parent.getVersion(), parent );

            if ( equals( parent.getGroupId(), model.getGroupId() )
                && equals( parent.getArtifactId(), model.getArtifactId() ) )
            {
                addViolation( problems, Severity.FATAL, "parent.artifactId", null, "must be changed"
                    + ", the parent element cannot have the same groupId:artifactId as the project.", parent );
            }
        }

        if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )
        {
            Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );

            validateEnum( "modelVersion", problems, Severity.ERROR, model.getModelVersion(), null, model, "4.0.0" );

            validateStringNoExpression( "groupId", problems, Severity.WARNING, model.getGroupId(), model );
            if ( parent == null )
            {
                validateStringNotEmpty( "groupId", problems, Severity.FATAL, model.getGroupId(), model );
            }

            validateStringNoExpression( "artifactId", problems, Severity.WARNING, model.getArtifactId(), model );
            validateStringNotEmpty( "artifactId", problems, Severity.FATAL, model.getArtifactId(), model );

            validateStringNoExpression( "version", problems, Severity.WARNING, model.getVersion(), model );
            if ( parent == null )
            {
                validateStringNotEmpty( "version", problems, Severity.FATAL, model.getVersion(), model );
            }

            validateRawDependencies( problems, model.getDependencies(), "dependencies.dependency", request );

            if ( model.getDependencyManagement() != null )
            {
                validateRawDependencies( problems, model.getDependencyManagement().getDependencies(),
                                      "dependencyManagement.dependencies.dependency", request );
            }

            validateRepositories( problems, model.getRepositories(), "repositories.repository", request );

            validateRepositories( problems, model.getPluginRepositories(), "pluginRepositories.pluginRepository",
                                  request );

            Build build = model.getBuild();
            if ( build != null )
            {
                validateRawPlugins( problems, build.getPlugins(), "build.plugins.plugin", request );

                PluginManagement mngt = build.getPluginManagement();
                if ( mngt != null )
                {
                    validateRawPlugins( problems, mngt.getPlugins(), "build.pluginManagement.plugins.plugin",
                                        request );
                }
            }

            Set<String> profileIds = new HashSet<String>();

            for ( Profile profile : model.getProfiles() )
            {
                String prefix = "profiles.profile[" + profile.getId() + "]";

                if ( !profileIds.add( profile.getId() ) )
                {
                    addViolation( problems, errOn30, "profiles.profile.id", null,
                                  "must be unique but found duplicate profile with id " + profile.getId(), profile );
                }

                validateRawDependencies( problems, profile.getDependencies(), prefix + ".dependencies.dependency",
                                         request );

                if ( profile.getDependencyManagement() != null )
                {
                    validateRawDependencies( problems, profile.getDependencyManagement().getDependencies(), prefix
                        + ".dependencyManagement.dependencies.dependency", request );
                }

                validateRepositories( problems, profile.getRepositories(), prefix + ".repositories.repository",
                                      request );

                validateRepositories( problems, profile.getPluginRepositories(), prefix
                    + ".pluginRepositories.pluginRepository", request );

                BuildBase buildBase = profile.getBuild();
                if ( buildBase != null )
                {
                    validateRawPlugins( problems, buildBase.getPlugins(), prefix + ".plugins.plugin", request );

                    PluginManagement mngt = buildBase.getPluginManagement();
                    if ( mngt != null )
                    {
                        validateRawPlugins( problems, mngt.getPlugins(), prefix + ".pluginManagement.plugins.plugin",
                                            request );
                    }
                }
            }
        }
    }
5569#private void validateRawPlugins( ModelProblemCollector problems, List<Plugin> plugins, String prefix,
                                     ModelBuildingRequest request )
    {
        Severity errOn31 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1 );

        Map<String, Plugin> index = new HashMap<String, Plugin>();

        for ( Plugin plugin : plugins )
        {
            String key = plugin.getKey();

            Plugin existing = index.get( key );

            if ( existing != null )
            {
                addViolation( problems, errOn31, prefix + ".(groupId:artifactId)", null,
                              "must be unique but found duplicate declaration of plugin " + key, plugin );
            }
            else
            {
                index.put( key, plugin );
            }

            Set<String> executionIds = new HashSet<String>();

            for ( PluginExecution exec : plugin.getExecutions() )
            {
                if ( !executionIds.add( exec.getId() ) )
                {
                    addViolation( problems, Severity.ERROR, prefix + "[" + plugin.getKey()
                        + "].executions.execution.id", null, "must be unique but found duplicate execution with id "
                        + exec.getId(), exec );
                }
            }
        }
    }
5570#public void validateEffectiveModel( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        validateStringNotEmpty( "modelVersion", problems, Severity.ERROR, model.getModelVersion(), model );

        validateId( "groupId", problems, model.getGroupId(), model );

        validateId( "artifactId", problems, model.getArtifactId(), model );

        validateStringNotEmpty( "packaging", problems, Severity.ERROR, model.getPackaging(), model );

        if ( !model.getModules().isEmpty() )
        {
            if ( !"pom".equals( model.getPackaging() ) )
            {
                addViolation( problems, Severity.ERROR, "packaging", null, "with value '" + model.getPackaging()
                    + "' is invalid. Aggregator projects " + "require 'pom' as packaging.", model );
            }

            for ( int i = 0, n = model.getModules().size(); i < n; i++ )
            {
                String module = model.getModules().get( i );
                if ( StringUtils.isBlank( module ) )
                {
                    addViolation( problems, Severity.WARNING, "modules.module[" + i + "]", null,
                                  "has been specified without a path to the project directory.",
                                  model.getLocation( "modules" ) );
                }
            }
        }

        validateStringNotEmpty( "version", problems, Severity.ERROR, model.getVersion(), model );

        Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );

        validateEffectiveDependencies( problems, model.getDependencies(), false, request );

        DependencyManagement mgmt = model.getDependencyManagement();
        if ( mgmt != null )
        {
            validateEffectiveDependencies( problems, mgmt.getDependencies(), true, request );
        }

        if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )
        {
            Set<String> modules = new HashSet<String>();
            for ( int i = 0, n = model.getModules().size(); i < n; i++ )
            {
                String module = model.getModules().get( i );
                if ( !modules.add( module ) )
                {
                    addViolation( problems, Severity.ERROR, "modules.module[" + i + "]", null,
                                  "specifies duplicate child module " + module, model.getLocation( "modules" ) );
                }
            }

            Severity errOn31 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1 );

            validateBannedCharacters( "version", problems, errOn31, model.getVersion(), null, model,
                                      ILLEGAL_VERSION_CHARS );
            validateProperSnapshotVersion( "version", problems, errOn31, model.getVersion(), null, model );

            Build build = model.getBuild();
            if ( build != null )
            {
                for ( Plugin p : build.getPlugins() )
                {
                    validateStringNotEmpty( "build.plugins.plugin.artifactId", problems, Severity.ERROR,
                                            p.getArtifactId(), p );

                    validateStringNotEmpty( "build.plugins.plugin.groupId", problems, Severity.ERROR, p.getGroupId(),
                                            p );

                    validatePluginVersion( "build.plugins.plugin.version", problems, p.getVersion(), p.getKey(), p,
                                           request );

                    validateBoolean( "build.plugins.plugin.inherited", problems, errOn30, p.getInherited(), p.getKey(),
                                     p );

                    validateBoolean( "build.plugins.plugin.extensions", problems, errOn30, p.getExtensions(),
                                     p.getKey(), p );

                    validateEffectivePluginDependencies( problems, p, request );
                }

                validateResources( problems, build.getResources(), "build.resources.resource", request );

                validateResources( problems, build.getTestResources(), "build.testResources.testResource", request );
            }

            Reporting reporting = model.getReporting();
            if ( reporting != null )
            {
                for ( ReportPlugin p : reporting.getPlugins() )
                {
                    validateStringNotEmpty( "reporting.plugins.plugin.artifactId", problems, Severity.ERROR,
                                            p.getArtifactId(), p );

                    validateStringNotEmpty( "reporting.plugins.plugin.groupId", problems, Severity.ERROR,
                                            p.getGroupId(), p );

                    validateStringNotEmpty( "reporting.plugins.plugin.version", problems, errOn31, p.getVersion(),
                                            p.getKey(), p );
                }
            }

            for ( Repository repository : model.getRepositories() )
            {
                validateRepository( problems, repository, "repositories.repository", request );
            }

            for ( Repository repository : model.getPluginRepositories() )
            {
                validateRepository( problems, repository, "pluginRepositories.pluginRepository", request );
            }

            DistributionManagement distMgmt = model.getDistributionManagement();
            if ( distMgmt != null )
            {
                if ( distMgmt.getStatus() != null )
                {
                    addViolation( problems, Severity.ERROR, "distributionManagement.status", null,
                                  "must not be specified.", distMgmt );
                }

                validateRepository( problems, distMgmt.getRepository(), "distributionManagement.repository", request );
                validateRepository( problems, distMgmt.getSnapshotRepository(),
                                    "distributionManagement.snapshotRepository", request );
            }
        }
    }
5571#private void validateRawDependencies( ModelProblemCollector problems, List<Dependency> dependencies, String prefix,
                                          ModelBuildingRequest request )
    {
        Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );
        Severity errOn31 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1 );

        Map<String, Dependency> index = new HashMap<String, Dependency>();

        for ( Dependency dependency : dependencies )
        {
            String key = dependency.getManagementKey();

            if ( "import".equals( dependency.getScope() ) )
            {
                if ( !"pom".equals( dependency.getType() ) )
                {
                    addViolation( problems, Severity.WARNING, prefix + ".type", key,
                                  "must be 'pom' to import the managed dependencies.", dependency );
                }
                else if ( StringUtils.isNotEmpty( dependency.getClassifier() ) )
                {
                    addViolation( problems, errOn30, prefix + ".classifier", key,
                                  "must be empty, imported POM cannot have a classifier.", dependency );
                }
            }
            else if ( "system".equals( dependency.getScope() ) )
            {
                String sysPath = dependency.getSystemPath();
                if ( StringUtils.isNotEmpty( sysPath ) )
                {
                    if ( !hasExpression( sysPath ) )
                    {
                        addViolation( problems, Severity.WARNING, prefix + ".systemPath", key,
                                      "should use a variable instead of a hard-coded path " + sysPath, dependency );
                    }
                    else if ( sysPath.contains( "${basedir}" ) || sysPath.contains( "${project.basedir}" ) )
                    {
                        addViolation( problems, Severity.WARNING, prefix + ".systemPath", key,
                                      "should not point at files within the project directory, " + sysPath
                                          + " will be unresolvable by dependent projects", dependency );
                    }
                }
            }

            Dependency existing = index.get( key );

            if ( existing != null )
            {
                String msg;
                if ( equals( existing.getVersion(), dependency.getVersion() ) )
                {
                    msg =
                        "duplicate declaration of version "
                            + StringUtils.defaultString( dependency.getVersion(), "(?)" );
                }
                else
                {
                    msg =
                        "version " + StringUtils.defaultString( existing.getVersion(), "(?)" ) + " vs "
                            + StringUtils.defaultString( dependency.getVersion(), "(?)" );
                }

                addViolation( problems, errOn31, prefix + ".(groupId:artifactId:type:classifier)", null,
                              "must be unique: " + key + " -> " + msg, dependency );
            }
            else
            {
                index.put( key, dependency );
            }
        }
    }
5572#private void validateEffectiveDependencies( ModelProblemCollector problems, List<Dependency> dependencies,
                                                boolean management, ModelBuildingRequest request )
    {
        Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );

        String prefix = management ? "dependencyManagement.dependencies.dependency." : "dependencies.dependency.";

        for ( Dependency d : dependencies )
        {
            validateEffectiveDependency( problems, d, management, prefix, request );

            if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )
            {
                validateBoolean( prefix + "optional", problems, errOn30, d.getOptional(), d.getManagementKey(), d );

                if ( !management )
                {
                    validateVersion( prefix + "version", problems, errOn30, d.getVersion(), d.getManagementKey(), d );

                    /*
                     * TODO: Extensions like Flex Mojos use custom scopes like "merged", "internal", "external", etc.
                     * In order to don't break backward-compat with those, only warn but don't error out.
                     */
                    validateEnum( prefix + "scope", problems, Severity.WARNING, d.getScope(), d.getManagementKey(), d,
                                  "provided", "compile", "runtime", "test", "system" );
                }
            }
        }
    }
5573#private void validateEffectivePluginDependencies( ModelProblemCollector problems, Plugin plugin,
                                                      ModelBuildingRequest request )
    {
        List<Dependency> dependencies = plugin.getDependencies();

        if ( !dependencies.isEmpty() )
        {
            String prefix = "build.plugins.plugin[" + plugin.getKey() + "].dependencies.dependency.";

            Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );

            for ( Dependency d : dependencies )
            {
                validateEffectiveDependency( problems, d, false, prefix, request );

                validateVersion( prefix + "version", problems, errOn30, d.getVersion(), d.getManagementKey(), d );

                validateEnum( prefix + "scope", problems, errOn30, d.getScope(), d.getManagementKey(), d, "compile",
                              "runtime", "system" );
            }
        }
    }
5574#private void validateEffectiveDependency( ModelProblemCollector problems, Dependency d, boolean management,
                                              String prefix, ModelBuildingRequest request )
    {
        validateId( prefix + "artifactId", problems, Severity.ERROR, d.getArtifactId(), d.getManagementKey(), d );

        validateId( prefix + "groupId", problems, Severity.ERROR, d.getGroupId(), d.getManagementKey(), d );

        if ( !management )
        {
            validateStringNotEmpty( prefix + "type", problems, Severity.ERROR, d.getType(), d.getManagementKey(), d );

            validateStringNotEmpty( prefix + "version", problems, Severity.ERROR, d.getVersion(), d.getManagementKey(),
                                    d );
        }

        if ( "system".equals( d.getScope() ) )
        {
            String systemPath = d.getSystemPath();

            if ( StringUtils.isEmpty( systemPath ) )
            {
                addViolation( problems, Severity.ERROR, prefix + "systemPath", d.getManagementKey(), "is missing.",
                              d );
            }
            else
            {
                File sysFile = new File( systemPath );
                if ( !sysFile.isAbsolute() )
                {
                    addViolation( problems, Severity.ERROR, prefix + "systemPath", d.getManagementKey(),
                                  "must specify an absolute path but is " + systemPath, d );
                }
                else if ( !sysFile.isFile() )
                {
                    String msg = "refers to a non-existing file " + sysFile.getAbsolutePath();
                    systemPath = systemPath.replace( '/', File.separatorChar ).replace( '\\', File.separatorChar );
                    String jdkHome =
                        request.getSystemProperties().getProperty( "java.home", "" ) + File.separator + "..";
                    if ( systemPath.startsWith( jdkHome ) )
                    {
                        msg += ". Please verify that you run Maven using a JDK and not just a JRE.";
                    }
                    addViolation( problems, Severity.WARNING, prefix + "systemPath", d.getManagementKey(), msg, d );
                }
            }
        }
        else if ( StringUtils.isNotEmpty( d.getSystemPath() ) )
        {
            addViolation( problems, Severity.ERROR, prefix + "systemPath", d.getManagementKey(), "must be omitted."
                + " This field may only be specified for a dependency with system scope.", d );
        }

        if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )
        {
            for ( Exclusion exclusion : d.getExclusions() )
            {
                validateId( prefix + "exclusions.exclusion.groupId", problems, Severity.WARNING,
                            exclusion.getGroupId(), d.getManagementKey(), exclusion );

                validateId( prefix + "exclusions.exclusion.artifactId", problems, Severity.WARNING,
                            exclusion.getArtifactId(), d.getManagementKey(), exclusion );
            }
        }
    }
5575#private void validateRepositories( ModelProblemCollector problems, List<Repository> repositories, String prefix,
                                       ModelBuildingRequest request )
    {
        Map<String, Repository> index = new HashMap<String, Repository>();

        for ( Repository repository : repositories )
        {
            validateStringNotEmpty( prefix + ".id", problems, Severity.ERROR, repository.getId(), repository );

            validateStringNotEmpty( prefix + "[" + repository.getId() + "].url", problems, Severity.ERROR,
                                    repository.getUrl(), repository );

            String key = repository.getId();

            Repository existing = index.get( key );

            if ( existing != null )
            {
                Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );

                addViolation( problems, errOn30, prefix + ".id", null, "must be unique: " + repository.getId() + " -> "
                    + existing.getUrl() + " vs " + repository.getUrl(), repository );
            }
            else
            {
                index.put( key, repository );
            }
        }
    }
5576#private void validateRepository( ModelProblemCollector problems, Repository repository, String prefix,
                                     ModelBuildingRequest request )
    {
        if ( repository != null )
        {
            Severity errOn31 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1 );

            validateBannedCharacters( prefix + ".id", problems, errOn31, repository.getId(), null, repository,
                                      ILLEGAL_REPO_ID_CHARS );

            if ( "local".equals( repository.getId() ) )
            {
                addViolation( problems, errOn31, prefix + ".id", null, "must not be 'local'"
                    + ", this identifier is reserved for the local repository"
                    + ", using it for other repositories will corrupt your repository metadata.", repository );
            }

            if ( "legacy".equals( repository.getLayout() ) )
            {
                addViolation( problems, Severity.WARNING, prefix + ".layout", repository.getId(),
                              "uses the unsupported value 'legacy', artifact resolution might fail.", repository );
            }
        }
    }
5577#private void validateResources( ModelProblemCollector problems, List<Resource> resources, String prefix,
                                    ModelBuildingRequest request )
    {
        Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );

        for ( Resource resource : resources )
        {
            validateStringNotEmpty( prefix + ".directory", problems, Severity.ERROR, resource.getDirectory(),
                                    resource );

            validateBoolean( prefix + ".filtering", problems, errOn30, resource.getFiltering(),
                             resource.getDirectory(), resource );
        }
    }
5578#// ----------------------------------------------------------------------
    // Field validation
    // ----------------------------------------------------------------------

    private boolean validateId( String fieldName, ModelProblemCollector problems, String id,
                                InputLocationTracker tracker )
    {
        return validateId( fieldName, problems, Severity.ERROR, id, null, tracker );
    }
5579#private boolean validateId( String fieldName, ModelProblemCollector problems, Severity severity, String id,
                                String sourceHint, InputLocationTracker tracker )
    {
        if ( !validateStringNotEmpty( fieldName, problems, severity, id, sourceHint, tracker ) )
        {
            return false;
        }
        else
        {
            boolean match = id.matches( ID_REGEX );
            if ( !match )
            {
                addViolation( problems, severity, fieldName, sourceHint, "with value '" + id
                    + "' does not match a valid id pattern.", tracker );
            }
            return match;
        }
    }
5580#private boolean validateStringNoExpression( String fieldName, ModelProblemCollector problems, Severity severity,
                                                String string, InputLocationTracker tracker )
    {
        if ( !hasExpression( string ) )
        {
            return true;
        }

        addViolation( problems, severity, fieldName, null, "contains an expression but should be a constant.",
                      tracker );

        return false;
    }
5581#private boolean hasExpression( String value )
    {
        return value != null && value.contains( "${" );
    }
5582#private boolean validateStringNotEmpty( String fieldName, ModelProblemCollector problems, Severity severity,
                                            String string, InputLocationTracker tracker )
    {
        return validateStringNotEmpty( fieldName, problems, severity, string, null, tracker );
    }
5583#/**
     * Asserts:
     * <p/>
     * <ul>
     * <li><code>string != null</code>
     * <li><code>string.length > 0</code>
     * </ul>
     */
    private boolean validateStringNotEmpty( String fieldName, ModelProblemCollector problems, Severity severity,
                                            String string, String sourceHint, InputLocationTracker tracker )
    {
        if ( !validateNotNull( fieldName, problems, severity, string, sourceHint, tracker ) )
        {
            return false;
        }

        if ( string.length() > 0 )
        {
            return true;
        }

        addViolation( problems, severity, fieldName, sourceHint, "is missing.", tracker );

        return false;
    }
5584#/**
     * Asserts:
     * <p/>
     * <ul>
     * <li><code>string != null</code>
     * </ul>
     */
    private boolean validateNotNull( String fieldName, ModelProblemCollector problems, Severity severity,
                                     Object object, String sourceHint, InputLocationTracker tracker )
    {
        if ( object != null )
        {
            return true;
        }

        addViolation( problems, severity, fieldName, sourceHint, "is missing.", tracker );

        return false;
    }
5585#private boolean validateBoolean( String fieldName, ModelProblemCollector problems, Severity severity,
                                     String string, String sourceHint, InputLocationTracker tracker )
    {
        if ( string == null || string.length() <= 0 )
        {
            return true;
        }

        if ( "true".equalsIgnoreCase( string ) || "false".equalsIgnoreCase( string ) )
        {
            return true;
        }

        addViolation( problems, severity, fieldName, sourceHint, "must be 'true' or 'false' but is '" + string + "'.",
                      tracker );

        return false;
    }
5586#private boolean validateEnum( String fieldName, ModelProblemCollector problems, Severity severity, String string,
                                  String sourceHint, InputLocationTracker tracker, String... validValues )
    {
        if ( string == null || string.length() <= 0 )
        {
            return true;
        }

        List<String> values = Arrays.asList( validValues );

        if ( values.contains( string ) )
        {
            return true;
        }

        addViolation( problems, severity, fieldName, sourceHint, "must be one of " + values + " but is '" + string
            + "'.", tracker );

        return false;
    }
5587#private boolean validateBannedCharacters( String fieldName, ModelProblemCollector problems, Severity severity,
                                              String string, String sourceHint, InputLocationTracker tracker,
                                              String banned )
    {
        if ( string != null )
        {
            for ( int i = string.length() - 1; i >= 0; i-- )
            {
                if ( banned.indexOf( string.charAt( i ) ) >= 0 )
                {
                    addViolation( problems, severity, fieldName, sourceHint,
                                  "must not contain any of these characters " + banned + " but found "
                                      + string.charAt( i ), tracker );
                    return false;
                }
            }
        }

        return true;
    }
5588#private boolean validateVersion( String fieldName, ModelProblemCollector problems, Severity severity,
                                     String string, String sourceHint, InputLocationTracker tracker )
    {
        if ( string == null || string.length() <= 0 )
        {
            return true;
        }

        if ( hasExpression( string ) )
        {
            addViolation( problems, severity, fieldName, sourceHint,
                          "must be a valid version but is '" + string + "'.", tracker );
            return false;
        }

        if ( !validateBannedCharacters( fieldName, problems, severity, string, sourceHint, tracker,
                                        ILLEGAL_VERSION_CHARS ) )
        {
            return false;
        }

        return true;
    }
5589#private boolean validateProperSnapshotVersion( String fieldName, ModelProblemCollector problems, Severity severity,
                                                   String string, String sourceHint, InputLocationTracker tracker )
    {
        if ( string == null || string.length() <= 0 )
        {
            return true;
        }

        if ( string.endsWith( "SNAPSHOT" ) && !string.endsWith( "-SNAPSHOT" ) )
        {
            addViolation( problems, severity, fieldName, sourceHint, "uses an unsupported snapshot version format"
                + ", should be '*-SNAPSHOT' instead.", tracker );
            return false;
        }

        return true;
    }
5590#private boolean validatePluginVersion( String fieldName, ModelProblemCollector problems, String string,
                                           String sourceHint, InputLocationTracker tracker,
                                           ModelBuildingRequest request )
    {
        if ( string == null )
        {
            // NOTE: The check for missing plugin versions is handled directly by the model builder
            return true;
        }

        Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );

        if ( !validateVersion( fieldName, problems, errOn30, string, sourceHint, tracker ) )
        {
            return false;
        }

        if ( string.length() <= 0 || "RELEASE".equals( string ) || "LATEST".equals( string ) )
        {
            addViolation( problems, errOn30, fieldName, sourceHint, "must be a valid version but is '" + string + "'.",
                          tracker );
            return false;
        }

        return true;
    }
5591#private static void addViolation( ModelProblemCollector problems, Severity severity, String fieldName,
                                      String sourceHint, String message, InputLocationTracker tracker )
    {
        StringBuilder buffer = new StringBuilder( 256 );
        buffer.append( '\'' ).append( fieldName ).append( '\'' );

        if ( sourceHint != null )
        {
            buffer.append( " for " ).append( sourceHint );
        }

        buffer.append( ' ' ).append( message );

        problems.add( severity, buffer.toString(), getLocation( fieldName, tracker ), null );
    }
5592#private static InputLocation getLocation( String fieldName, InputLocationTracker tracker )
    {
        InputLocation location = null;

        if ( tracker != null )
        {
            if ( fieldName != null )
            {
                Object key = fieldName;

                int idx = fieldName.lastIndexOf( '.' );
                if ( idx >= 0 )
                {
                    fieldName = fieldName.substring( idx + 1 );
                    key = fieldName;
                }

                if ( fieldName.endsWith( "]" ) )
                {
                    key = fieldName.substring( fieldName.lastIndexOf( '[' ) + 1, fieldName.length() - 1 );
                    try
                    {
                        key = Integer.valueOf( key.toString() );
                    }
                    catch ( NumberFormatException e )
                    {
                        // use key as is
                    }
                }

                location = tracker.getLocation( key );
            }

            if ( location == null )
            {
                location = tracker.getLocation( "" );
            }
        }

        return location;
    }
5593#private static boolean equals( String s1, String s2 )
    {
        return StringUtils.clean( s1 ).equals( StringUtils.clean( s2 ) );
    }
5594#private static Severity getSeverity( ModelBuildingRequest request, int errorThreshold )
    {
        return getSeverity( request.getValidationLevel(), errorThreshold );
    }
5595#private static Severity getSeverity( int validationLevel, int errorThreshold )
    {
        if ( validationLevel < errorThreshold )
        {
            return Severity.WARNING;
        }
        else
        {
            return Severity.ERROR;
        }
    }
5596#/**
     * Checks the specified (raw) model for missing or invalid values. The raw model is directly created from the POM
     * file and has not been subjected to inheritance, interpolation or profile/default injection.
     * 
     * @param model The model to validate, must not be {@code null}.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void validateRawModel( Model model, ModelBuildingRequest request, ModelProblemCollector problems );
5597#/**
     * Checks the specified (effective) model for missing or invalid values. The effective model is fully assembled and
     * has undergone inheritance, interpolation and other model operations.
     * 
     * @param model The model to validate, must not be {@code null}.
     * @param request The model building request that holds further settings, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void validateEffectiveModel( Model model, ModelBuildingRequest request, ModelProblemCollector problems );
5598#private File getPom( String name )
    {
        return new File( "src/test/resources/poms/factory/" + name + ".xml" ).getAbsoluteFile();
    }
5599#public void testCompleteWiring()
        throws Exception
    {
        ModelBuilder builder = new DefaultModelBuilderFactory().newInstance();
        assertNotNull( builder );

        DefaultModelBuildingRequest request = new DefaultModelBuildingRequest();
        request.setProcessPlugins( true );
        request.setPomFile( getPom( "simple" ) );

        ModelBuildingResult result = builder.build( request );
        assertNotNull( result );
        assertNotNull( result.getEffectiveModel() );
        assertEquals( "activated", result.getEffectiveModel().getProperties().get( "profile.file" ) );
    }
5600#public List<String> getWarnings()
    {
        return warnings;
    }
5601#public List<String> getErrors()
    {
        return errors;
    }
5602#public List<String> getFatals()
    {
        return fatals;
    }
5603#public void add( Severity severity, String message, InputLocation location, Exception cause )
    {
        switch ( severity )
        {
            case FATAL:
                fatals.add( message );
                break;
            case ERROR:
                errors.add( message );
                break;
            case WARNING:
                warnings.add( message );
                break;
        }

    }
5604#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();

        reader = lookup( ModelReader.class );
        writer = lookup( ModelWriter.class );
        assembler = lookup( InheritanceAssembler.class );
    }
5605#private File getPom( String name )
    {
        return getTestFile( "src/test/resources/poms/inheritance/" + name + ".xml" );
    }
5606#private Model getModel( String name )
        throws ModelParseException, IOException
    {
        return reader.read( getPom( name ), null );
    }
5607#public void testPluginConfiguration()
        throws Exception
    {
        Model parent = getModel( "plugin-configuration-parent" );

        Model child = getModel( "plugin-configuration-child" );

        SimpleProblemCollector problems = new SimpleProblemCollector();

        assembler.assembleModelInheritance( child, parent, null, problems );

        File actual = getTestFile( "target/test-classes/poms/inheritance/plugin-configuration-actual.xml" );

        writer.write( actual, null, child );

        // check with getPom( "plugin-configuration-effective" )
        Reader control = null;
        Reader test = null;
        try
        {
            File expected = getPom( "plugin-configuration-expected" );
            control = new InputStreamReader( new FileInputStream( expected ), "UTF-8" );

            test = new InputStreamReader( new FileInputStream( actual ), "UTF-8" );

            XMLUnit.setIgnoreComments( true );
            XMLUnit.setIgnoreWhitespace( true );
            XMLAssert.assertXMLEqual( control, test );
        }
        catch ( IOException ioe )
        {
            IOUtil.close( control );
            IOUtil.close( test );
        }
    }
5608#protected void setUp()
        throws Exception
    {
        super.setUp();

        context = new Properties();
        context.put( "basedir", "myBasedir" );
        context.put( "project.baseUri", "myBaseUri" );
    }
5609#protected void assertProblemFree( SimpleProblemCollector collector )
    {
        assertEquals( "Expected no errors", 0, collector.getErrors().size() );
        assertEquals( "Expected no warnings", 0, collector.getWarnings().size() );
        assertEquals( "Expected no fatals", 0, collector.getFatals().size() );
    }
5610#protected void assertColllectorState( int numFatals, int numErrors, int numWarnings,
                                          SimpleProblemCollector collector )
    {
        assertEquals( "Errors",  numErrors, collector.getErrors().size() );
        assertEquals( "Warnings", numWarnings, collector.getWarnings().size() );
        assertEquals( "Fatals", numFatals, collector.getFatals().size() );
    }
5611#private ModelBuildingRequest createModelBuildingRequest( Properties p )
    {
        ModelBuildingRequest config = new DefaultModelBuildingRequest();
        if ( p != null )
        {
            config.setSystemProperties( p );
        }
        return config;
    }
5612#public void testDefaultBuildTimestampFormatShouldParseTimeIn24HourFormat()
    {
        Calendar cal = Calendar.getInstance();
        cal.set( Calendar.HOUR, 12 );
        cal.set( Calendar.AM_PM, Calendar.AM );
        
        // just to make sure all the bases are covered...
        cal.set( Calendar.HOUR_OF_DAY, 0 );
        cal.set( Calendar.MINUTE, 16 );
        cal.set( Calendar.YEAR, 1976 );
        cal.set( Calendar.MONTH, Calendar.NOVEMBER );
        cal.set( Calendar.DATE, 11 );
        
        Date firstTestDate = cal.getTime();
        
        cal.set( Calendar.HOUR, 11 );
        cal.set( Calendar.AM_PM, Calendar.PM );
        
        // just to make sure all the bases are covered...
        cal.set( Calendar.HOUR_OF_DAY, 23 );
        
        Date secondTestDate = cal.getTime();
        
        SimpleDateFormat format =
            new SimpleDateFormat( AbstractStringBasedModelInterpolator.DEFAULT_BUILD_TIMESTAMP_FORMAT );
        assertEquals( "19761111-0016", format.format( firstTestDate ) );
        assertEquals( "19761111-2316", format.format( secondTestDate ) );
    }
5613#public void testShouldNotThrowExceptionOnReferenceToNonExistentValue()
        throws Exception
    {
        Model model = new Model();

        Scm scm = new Scm();
        scm.setConnection( "${test}/somepath" );

        model.setScm( scm );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );

        assertProblemFree(  collector );
        assertEquals( "${test}/somepath", out.getScm().getConnection() );
    }
5614#public void testShouldThrowExceptionOnRecursiveScmConnectionReference()
        throws Exception
    {
        Model model = new Model();

        Scm scm = new Scm();
        scm.setConnection( "${project.scm.connection}/somepath" );

        model.setScm( scm );

        try
        {
            ModelInterpolator interpolator = createInterpolator();

            final SimpleProblemCollector collector = new SimpleProblemCollector();
            interpolator.interpolateModel( model, null, createModelBuildingRequest( context ), collector );
            assertColllectorState(  0, 1, 0, collector );
        }
        catch ( Exception e )
        {

        }
    }
5615#public void testShouldNotThrowExceptionOnReferenceToValueContainingNakedExpression()
        throws Exception
    {
        Model model = new Model();

        Scm scm = new Scm();
        scm.setConnection( "${test}/somepath" );

        model.setScm( scm );

        model.addProperty( "test", "test" );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );

        assertProblemFree(  collector );

        assertEquals( "test/somepath", out.getScm().getConnection() );
    }
5616#public void testShouldInterpolateOrganizationNameCorrectly()
        throws Exception
    {
        String orgName = "MyCo";

        Model model = new Model();
        model.setName( "${pom.organization.name} Tools" );

        Organization org = new Organization();
        org.setName( orgName );

        model.setOrganization( org );

        ModelInterpolator interpolator = createInterpolator();
        
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ),
                                           new SimpleProblemCollector() );

        assertEquals( orgName + " Tools", out.getName() );
    }
5617#public void testShouldInterpolateDependencyVersionToSetSameAsProjectVersion()
        throws Exception
    {
        Model model = new Model();
        model.setVersion( "3.8.1" );

        Dependency dep = new Dependency();
        dep.setVersion( "${version}" );

        model.addDependency( dep );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertColllectorState(0, 0, 1, collector );
        
        assertEquals( "3.8.1", ( out.getDependencies().get( 0 ) ).getVersion() );
    }
5618#public void testShouldNotInterpolateDependencyVersionWithInvalidReference()
        throws Exception
    {
        Model model = new Model();
        model.setVersion( "3.8.1" );

        Dependency dep = new Dependency();
        dep.setVersion( "${something}" );

        model.addDependency( dep );

        /*
         // This is the desired behaviour, however there are too many crappy poms in the repo and an issue with the
         // timing of executing the interpolation

         try
         {
         new RegexBasedModelInterpolator().interpolate( model, context );
         fail( "Should have failed to interpolate with invalid reference" );
         }
         catch ( ModelInterpolationException expected )
         {
         assertTrue( true );
         }
         */

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );        
        
        assertEquals( "${something}", ( out.getDependencies().get( 0 ) ).getVersion() );
    }
5619#public void testTwoReferences()
        throws Exception
    {
        Model model = new Model();
        model.setVersion( "3.8.1" );
        model.setArtifactId( "foo" );

        Dependency dep = new Dependency();
        dep.setVersion( "${artifactId}-${version}" );

        model.addDependency( dep );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertColllectorState( 0, 0, 2, collector );
        
        assertEquals( "foo-3.8.1", ( out.getDependencies().get( 0 ) ).getVersion() );
    }
5620#public void testBasedir()
        throws Exception
    {
        Model model = new Model();
        model.setVersion( "3.8.1" );
        model.setArtifactId( "foo" );

        Repository repository = new Repository();

        repository.setUrl( "file://localhost/${basedir}/temp-repo" );

        model.addRepository( repository );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out = interpolator.interpolateModel( model, null, createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );        

        assertEquals( "file://localhost/myBasedir/temp-repo", ( out.getRepositories().get( 0 ) ).getUrl() );
    }
5621#public void testBaseUri()
        throws Exception
    {
        Model model = new Model();
        model.setVersion( "3.8.1" );
        model.setArtifactId( "foo" );

        Repository repository = new Repository();

        repository.setUrl( "${project.baseUri}/temp-repo" );

        model.addRepository( repository );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out = interpolator.interpolateModel( model, null, createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );

        assertEquals( "myBaseUri/temp-repo", ( out.getRepositories().get( 0 ) ).getUrl() );
    }
5622#public void testEnvars()
        throws Exception
    {
         Properties context = new Properties();

        context.put( "env.HOME", "/path/to/home" );

        Model model = new Model();

        Properties modelProperties = new Properties();

        modelProperties.setProperty( "outputDirectory", "${env.HOME}" );

        model.setProperties( modelProperties );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );        

        assertEquals( "/path/to/home", out.getProperties().getProperty( "outputDirectory" ) );
    }
5623#public void testEnvarExpressionThatEvaluatesToNullReturnsTheLiteralString()
        throws Exception
    {
        Model model = new Model();

        Properties modelProperties = new Properties();

        modelProperties.setProperty( "outputDirectory", "${env.DOES_NOT_EXIST}" );

        model.setProperties( modelProperties );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );        

        assertEquals( out.getProperties().getProperty( "outputDirectory" ), "${env.DOES_NOT_EXIST}" );
    }
5624#public void testExpressionThatEvaluatesToNullReturnsTheLiteralString()
        throws Exception
    {
        Model model = new Model();

        Properties modelProperties = new Properties();

        modelProperties.setProperty( "outputDirectory", "${DOES_NOT_EXIST}" );

        model.setProperties( modelProperties );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out =
            interpolator.interpolateModel( model, new File( "." ), createModelBuildingRequest( context ), collector );
        assertProblemFree( collector );        
        
        assertEquals( out.getProperties().getProperty( "outputDirectory" ), "${DOES_NOT_EXIST}" );
    }
5625#public void testShouldInterpolateSourceDirectoryReferencedFromResourceDirectoryCorrectly()
        throws Exception
    {
        Model model = new Model();

        Build build = new Build();
        build.setSourceDirectory( "correct" );

        Resource res = new Resource();
        res.setDirectory( "${project.build.sourceDirectory}" );

        build.addResource( res );

        Resource res2 = new Resource();
        res2.setDirectory( "${pom.build.sourceDirectory}" );

        build.addResource( res2 );

        Resource res3 = new Resource();
        res3.setDirectory( "${build.sourceDirectory}" );

        build.addResource( res3 );

        model.setBuild( build );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model out = interpolator.interpolateModel( model, null, createModelBuildingRequest( context ), collector );
        assertColllectorState( 0, 0, 2, collector );
        
        
        List<Resource> outResources = out.getBuild().getResources();
        Iterator<Resource> resIt = outResources.iterator();

        assertEquals( build.getSourceDirectory(), resIt.next().getDirectory() );
        assertEquals( build.getSourceDirectory(), resIt.next().getDirectory() );
        assertEquals( build.getSourceDirectory(), resIt.next().getDirectory() );
    }
5626#public void testShouldInterpolateUnprefixedBasedirExpression()
        throws Exception
    {
        File basedir = new File( "/test/path" );
        Model model = new Model();
        Dependency dep = new Dependency();
        dep.setSystemPath( "${basedir}/artifact.jar" );

        model.addDependency( dep );

        ModelInterpolator interpolator = createInterpolator();

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        Model result = interpolator.interpolateModel( model, basedir, createModelBuildingRequest( context ), collector );
        assertProblemFree(  collector );
        

        List<Dependency> rDeps = result.getDependencies();
        assertNotNull( rDeps );
        assertEquals( 1, rDeps.size() );
        assertEquals( new File( basedir, "artifact.jar" ).getAbsolutePath(),
                      new File( rDeps.get( 0 ).getSystemPath() ).getAbsolutePath() );
    }
5627#protected abstract ModelInterpolator createInterpolator( PathTranslator translator )
        throws Exception;
5628#protected abstract ModelInterpolator createInterpolator()
        throws Exception;
5629#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();
        interpolator = lookup( ModelInterpolator.class );
    }
5630#protected ModelInterpolator createInterpolator( org.apache.maven.model.path.PathTranslator translator )
        throws Exception
    {
        return this.interpolator;
    }
5631#protected ModelInterpolator createInterpolator()
        throws Exception
    {
        return this.interpolator;
    }
5632#public void testInterpolateStringArray()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        String[] values = { "${key}", "${key2}" };

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest(p);

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( values, model, new File( "." ), config, collector );
        assertProblemFree( collector );        

        assertEquals( "value", values[0] );
        assertEquals( "value2", values[1] );
    }
5633#private ModelBuildingRequest createModelBuildingRequest( Properties p )
    {
        ModelBuildingRequest config = new DefaultModelBuildingRequest();
        config.setSystemProperties( p );
        return config;
    }
5634#public void testInterpolateObjectWithStringArrayField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        String[] values = { "${key}", "${key2}" };

        ObjectWithStringArrayField obj = new ObjectWithStringArrayField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );        

        assertEquals( "value", obj.values[0] );
        assertEquals( "value2", obj.values[1] );
    }
5635#public void testInterpolateObjectWithStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<String>();
        values.add( "${key}" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }
5636#public void testInterpolateObjectWithStringListFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = new ArrayList<String>();
        values.add( "key" );
        values.add( "${key2}" );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );        

        assertEquals( "key", obj.values.get( 0 ) );
        assertEquals( "value2", obj.values.get( 1 ) );
    }
5637#public void testInterpolateObjectWithUnmodifiableStringListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        List<String> values = Collections.unmodifiableList( Collections.singletonList( "${key}" ) );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );        

        assertEquals( "${key}", obj.values.get( 0 ) );
    }
5638#public void testInterpolateObjectWithStringArrayListField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );
        p.setProperty( "key3", "value3" );
        p.setProperty( "key4", "value4" );

        List<String[]> values = new ArrayList<String[]>();
        values.add( new String[] { "${key}", "${key2}" } );
        values.add( new String[] { "${key3}", "${key4}" } );

        ObjectWithListField obj = new ObjectWithListField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", ( (String[]) obj.values.get( 0 ) )[0] );
        assertEquals( "value2", ( (String[]) obj.values.get( 0 ) )[1] );
        assertEquals( "value3", ( (String[]) obj.values.get( 1 ) )[0] );
        assertEquals( "value4", ( (String[]) obj.values.get( 1 ) )[1] );
    }
5639#public void testInterpolateObjectWithStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<String, String>();
        values.put( "key", "${key}" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "value", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }
5640#public void testInterpolateObjectWithStringToStringMapFieldAndOneLiteralValue()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = new HashMap<String, String>();
        values.put( "key", "val" );
        values.put( "key2", "${key2}" );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );        

        assertEquals( "val", obj.values.get( "key" ) );
        assertEquals( "value2", obj.values.get( "key2" ) );
    }
5641#public void testInterpolateObjectWithUnmodifiableStringToStringMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );

        Map<String, String> values = Collections.unmodifiableMap( Collections.singletonMap( "key", "${key}" ) );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );

        assertEquals( "${key}", obj.values.get( "key" ) );
    }
5642#public void testInterpolateObjectWithStringToStringArrayMapField()
        throws Exception
    {
        Model model = new Model();

        Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );
        p.setProperty( "key3", "value3" );
        p.setProperty( "key4", "value4" );

        Map<String, String[]> values = new HashMap<String, String[]>();
        values.put( "key", new String[] { "${key}", "${key2}" } );
        values.put( "key2", new String[] { "${key3}", "${key4}" } );

        ObjectWithMapField obj = new ObjectWithMapField( values );

        StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();

        ModelBuildingRequest config = createModelBuildingRequest( p );

        final SimpleProblemCollector collector = new SimpleProblemCollector();
        interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
        assertProblemFree( collector );        

        assertEquals( "value", ( (String[]) obj.values.get( "key" ) )[0] );
        assertEquals( "value2", ( (String[]) obj.values.get( "key" ) )[1] );
        assertEquals( "value3", ( (String[]) obj.values.get( "key2" ) )[0] );
        assertEquals( "value4", ( (String[]) obj.values.get( "key2" ) )[1] );
    }
5643#public void testConcurrentInterpolation()
        throws Exception
    {
        final Model model = new Model();

        final Properties p = new Properties();
        p.setProperty( "key", "value" );
        p.setProperty( "key2", "value2" );
        p.setProperty( "key3", "value3" );
        p.setProperty( "key4", "value4" );
        p.setProperty( "key5", "value5" );

        final StringSearchModelInterpolator interpolator = (StringSearchModelInterpolator) createInterpolator();


        int numItems = 100;
        final CountDownLatch countDownLatch = new CountDownLatch(1);

        List<Future<SimpleProblemCollector>>  futures = new ArrayList<Future<SimpleProblemCollector>>();
        for ( int i = 0; i < numItems; i++ )
        {
            Callable<SimpleProblemCollector> future = new Callable<SimpleProblemCollector>()
            {
                public SimpleProblemCollector call()
                    throws Exception
                {
                    final ObjectWithMixedProtection obj = getValueList();
                    final ModelBuildingRequest config = createModelBuildingRequest( p );

                    countDownLatch.await();
                    final SimpleProblemCollector collector = new SimpleProblemCollector();
                    interpolator.interpolateObject( obj, model, new File( "." ), config, collector );
                    return collector;
                }
            };
            FutureTask<SimpleProblemCollector> task = new FutureTask<SimpleProblemCollector>( future );
            futures.add( task );
            new Thread( task ).start();
        }
        countDownLatch.countDown(); // Start all the threads
        for ( Future<SimpleProblemCollector> result : futures )
        {
            SimpleProblemCollector problemCollector = result.get(); // ArrayIndexOutOfBoundsException are typical indication of threading issues
            assertProblemFree( problemCollector );
        }
    }
5644#private ObjectWithMixedProtection getValueList()
    {
        List<String[]> values = new ArrayList<String[]>();

        values.add( new String[] { "${key}", "${key2}" } );
        values.add( new String[] { "${key3}", "${key4}" } );
        List<String> values2 = new ArrayList<String>();
        values.add( new String[] { "${key}", "${key2}" } );
        values.add( new String[] { "${key3}", "${key4}" } );
        List<String> values3 = new ArrayList<String>();
        values.add( new String[] { "${key}", "${key2}" } );
        values.add( new String[] { "${key3}", "${key4}" } );

        return new ObjectWithMixedProtection( values, values2, values3, "${key5}" );
    }
5645#public void testFinalFieldsExcludedFromInterpolation()
    {
        Properties props = new Properties();
        props.setProperty( "expression", "value" );
        DefaultModelBuildingRequest request = new DefaultModelBuildingRequest();
        request.setUserProperties( props );

        SimpleProblemCollector problems = new SimpleProblemCollector();
        StringSearchModelInterpolator interpolator = new StringSearchModelInterpolator();
        interpolator.interpolateObject( new ClassWithFinalField(), new Model(), null, request, problems );

        assertProblemFree(  problems );
    }
5646#public void testLocationTrackerShouldBeExcludedFromInterpolation()
    {
        Properties props = new Properties();
        props.setProperty( "expression", "value" );
        DefaultModelBuildingRequest request = new DefaultModelBuildingRequest();
        request.setUserProperties( props );

        InputSource source = new InputSource();
        source.setLocation( "${expression}" );
        source.setModelId( "${expression}" );
        Model model = new Model();
        model.setLocation( "", new InputLocation( 1, 1, source ) );

        SimpleProblemCollector problems = new SimpleProblemCollector();
        StringSearchModelInterpolator interpolator = new StringSearchModelInterpolator();
        interpolator.interpolateObject( model, model, null, request, problems );

        assertProblemFree( problems );
        assertEquals( "${expression}", source.getLocation() );
        assertEquals( "${expression}", source.getModelId() );
    }
5647#public ObjectWithStringArrayField( String[] values )
        {
            this.values = values;
        }
5648#public ObjectWithListField( List<?> values )
        {
            this.values = values;
        }
5649#public ObjectWithMapField( Map<?, ?> values )
        {
            this.values = values;
        }
5650#private ObjectWithMixedProtection( List<?> values1, List<?> values2, List<?> values3 )
        {
            this.values1 = values1;
            this.values2 = values2;
            this.values3 = values3;
        }
5651#private ObjectWithMixedProtection( List<?> values1, List<?> values2, List<?> values3, String fooBar )
        {
            this.values1 = values1;
            this.values2 = values2;
            this.values3 = values3;
            this.fooBar = fooBar;
        }
5652#public String getFooBar()
        {
            return fooBar;
        }
5653#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();

        normalizer = new DefaultUrlNormalizer();
    }
5654#@Override
    protected void tearDown()
        throws Exception
    {
        normalizer = null;

        super.tearDown();
    }
5655#private String normalize( String url )
    {
        return normalizer.normalize( url );
    }
5656#public void testNullSafe()
    {
        assertNull( normalize( null ) );
    }
5657#public void testTrailingSlash()
    {
        assertEquals( "", normalize( "" ) );
        assertEquals( "http://server.org/dir", normalize( "http://server.org/dir" ) );
        assertEquals( "http://server.org/dir/", normalize( "http://server.org/dir/" ) );
    }
5658#public void testRemovalOfParentRefs()
    {
        assertEquals( "http://server.org/child", normalize( "http://server.org/parent/../child" ) );
        assertEquals( "http://server.org/child", normalize( "http://server.org/grand/parent/../../child" ) );

        assertEquals( "http://server.org//child", normalize( "http://server.org/parent/..//child" ) );
        assertEquals( "http://server.org/child", normalize( "http://server.org/parent//../child" ) );
    }
5659#public void testPreservationOfDoubleSlashes()
    {
        assertEquals( "scm:hg:ssh://localhost//home/user", normalize( "scm:hg:ssh://localhost//home/user" ) );
        assertEquals( "file:////UNC/server", normalize( "file:////UNC/server" ) );
        assertEquals( "[fetch=]http://server.org/[push=]ssh://server.org/",
                      normalize( "[fetch=]http://server.org/[push=]ssh://server.org/" ) );
    }
5660#public PropertyProfileActivatorTest()
    {
        super( PropertyProfileActivator.class );
    }
5661#private Profile newProfile( String key, String value )
    {
        ActivationProperty ap = new ActivationProperty();
        ap.setName( key );
        ap.setValue( value );

        Activation a = new Activation();
        a.setProperty( ap );

        Profile p = new Profile();
        p.setActivation( a );

        return p;
    }
5662#private Properties newProperties( String key, String value )
    {
        Properties props = new Properties();
        props.setProperty( key, value );
        return props;
    }
5663#public void testNullSafe()
        throws Exception
    {
        Profile p = new Profile();

        assertActivation( false, p, newContext( null, null ) );

        p.setActivation( new Activation() );

        assertActivation( false, p, newContext( null, null ) );
    }
5664#public void testWithNameOnly_UserProperty()
        throws Exception
    {
        Profile profile = newProfile( "prop", null );

        assertActivation( true, profile, newContext( newProperties( "prop", "value" ), null ) );

        assertActivation( false, profile, newContext( newProperties( "prop", "" ), null ) );

        assertActivation( false, profile, newContext( newProperties( "other", "value" ), null ) );
    }
5665#public void testWithNameOnly_SystemProperty()
        throws Exception
    {
        Profile profile = newProfile( "prop", null );

        assertActivation( true, profile, newContext( null, newProperties( "prop", "value" ) ) );

        assertActivation( false, profile, newContext( null, newProperties( "prop", "" ) ) );

        assertActivation( false, profile, newContext( null, newProperties( "other", "value" ) ) );
    }
5666#public void testWithNegatedNameOnly_UserProperty()
        throws Exception
    {
        Profile profile = newProfile( "!prop", null );

        assertActivation( false, profile, newContext( newProperties( "prop", "value" ), null ) );

        assertActivation( true, profile, newContext( newProperties( "prop", "" ), null ) );

        assertActivation( true, profile, newContext( newProperties( "other", "value" ), null ) );
    }
5667#public void testWithNegatedNameOnly_SystemProperty()
        throws Exception
    {
        Profile profile = newProfile( "!prop", null );

        assertActivation( false, profile, newContext( null, newProperties( "prop", "value" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "prop", "" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "other", "value" ) ) );
    }
5668#public void testWithValue_UserProperty()
        throws Exception
    {
        Profile profile = newProfile( "prop", "value" );

        assertActivation( true, profile, newContext( newProperties( "prop", "value" ), null ) );

        assertActivation( false, profile, newContext( newProperties( "prop", "other" ), null ) );

        assertActivation( false, profile, newContext( newProperties( "prop", "" ), null ) );
    }
5669#public void testWithValue_SystemProperty()
        throws Exception
    {
        Profile profile = newProfile( "prop", "value" );

        assertActivation( true, profile, newContext( null, newProperties( "prop", "value" ) ) );

        assertActivation( false, profile, newContext( null, newProperties( "prop", "other" ) ) );

        assertActivation( false, profile, newContext( null, newProperties( "other", "" ) ) );
    }
5670#public void testWithNegatedValue_UserProperty()
        throws Exception
    {
        Profile profile = newProfile( "prop", "!value" );

        assertActivation( false, profile, newContext( newProperties( "prop", "value" ), null ) );

        assertActivation( true, profile, newContext( newProperties( "prop", "other" ), null ) );

        assertActivation( true, profile, newContext( newProperties( "prop", "" ), null ) );
    }
5671#public void testWithNegatedValue_SystemProperty()
        throws Exception
    {
        Profile profile = newProfile( "prop", "!value" );

        assertActivation( false, profile, newContext( null, newProperties( "prop", "value" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "prop", "other" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "other", "" ) ) );
    }
5672#public void testWithValue_UserPropertyDominantOverSystemProperty()
        throws Exception
    {
        Profile profile = newProfile( "prop", "value" );

        Properties props1 = newProperties( "prop", "value" );
        Properties props2 = newProperties( "prop", "other" );

        assertActivation( true, profile, newContext( props1, props2 ) );

        assertActivation( false, profile, newContext( props2, props1 ) );
    }
5673#public JdkVersionProfileActivatorTest()
    {
        super( JdkVersionProfileActivator.class );
    }
5674#private Profile newProfile( String jdkVersion )
    {
        Activation a = new Activation();
        a.setJdk( jdkVersion );

        Profile p = new Profile();
        p.setActivation( a );

        return p;
    }
5675#private Properties newProperties( String javaVersion )
    {
        Properties props = new Properties();
        props.setProperty( "java.version", javaVersion );
        return props;
    }
5676#public void testNullSafe()
        throws Exception
    {
        Profile p = new Profile();

        assertActivation( false, p, newContext( null, null ) );

        p.setActivation( new Activation() );

        assertActivation( false, p, newContext( null, null ) );
    }
5677#public void testPrefix()
        throws Exception
    {
        Profile profile = newProfile( "1.4" );

        assertActivation( true, profile, newContext( null, newProperties( "1.4" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.4.2" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.4.2_09" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.4.2_09-b03" ) ) );

        assertActivation( false, profile, newContext( null, newProperties( "1.3" ) ) );

        assertActivation( false, profile, newContext( null, newProperties( "1.5" ) ) );
    }
5678#public void testPrefixNegated()
        throws Exception
    {
        Profile profile = newProfile( "!1.4" );

        assertActivation( false, profile, newContext( null, newProperties( "1.4" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2_09" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2_09-b03" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "1.3" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "1.5" ) ) );
    }
5679#public void testVersionRangeInclusiveBounds()
        throws Exception
    {
        Profile profile = newProfile( "[1.5,1.6]" );

        assertActivation( false, profile, newContext( null, newProperties( "1.4" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2_09" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2_09-b03" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "1.5" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0_09" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0_09-b03" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.1" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "1.6" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.6.0" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.6.0_09" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.6.0_09-b03" ) ) );
    }
5680#public void testVersionRangeExclusiveBounds()
        throws Exception
    {
        Profile profile = newProfile( "(1.3,1.6)" );

        assertActivation( false, profile, newContext( null, newProperties( "1.3" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.3.0" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.3.0_09" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.3.0_09-b03" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "1.3.1" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.3.1_09" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.3.1_09-b03" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "1.5" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0_09" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0_09-b03" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.1" ) ) );

        assertActivation( false, profile, newContext( null, newProperties( "1.6" ) ) );
    }
5681#public void testVersionRangeInclusiveLowerBound()
        throws Exception
    {
        Profile profile = newProfile( "[1.5,)" );

        assertActivation( false, profile, newContext( null, newProperties( "1.4" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2_09" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.4.2_09-b03" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "1.5" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0_09" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0_09-b03" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.1" ) ) );

        assertActivation( true, profile, newContext( null, newProperties( "1.6" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.6.0" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.6.0_09" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.6.0_09-b03" ) ) );
    }
5682#public void testVersionRangeExclusiveUpperBound()
        throws Exception
    {
        Profile profile = newProfile( "(,1.6)" );

        assertActivation( true, profile, newContext( null, newProperties( "1.5" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0_09" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.0_09-b03" ) ) );
        assertActivation( true, profile, newContext( null, newProperties( "1.5.1" ) ) );

        assertActivation( false, profile, newContext( null, newProperties( "1.6" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.6.0" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.6.0_09" ) ) );
        assertActivation( false, profile, newContext( null, newProperties( "1.6.0_09-b03" ) ) );
    }
5683#public AbstractProfileActivatorTest( Class<T> activatorClass )
    {
        if ( activatorClass == null )
        {
            throw new IllegalArgumentException( "class of profile activator to test is not specified" );
        }

        this.activatorClass = activatorClass;

        roleHint = activatorClass.getAnnotation( Component.class ).hint();
    }
5684#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();

        activator = activatorClass.cast( lookup( ProfileActivator.class, roleHint ) );
    }
5685#@Override
    protected void tearDown()
        throws Exception
    {
        activator = null;

        super.tearDown();
    }
5686#protected ProfileActivationContext newContext( final Properties userProperties, final Properties systemProperties )
    {
        DefaultProfileActivationContext context = new DefaultProfileActivationContext();
        return context.setUserProperties( userProperties ).setSystemProperties( systemProperties );
    }
5687#protected void assertActivation( boolean active, Profile profile, ProfileActivationContext context )
    {
        SimpleProblemCollector problems = new SimpleProblemCollector();

        assertEquals( active, activator.isActive( profile, context, problems ) );

        assertEquals( problems.getErrors().toString(), 0, problems.getErrors().size() );
        assertEquals( problems.getWarnings().toString(), 0, problems.getWarnings().size() );
    }
5688#private Model read( String pom )
        throws Exception
    {
        String resource = "/poms/validation/" + pom;
        InputStream is = getClass().getResourceAsStream( resource );
        assertNotNull( "missing resource: " + resource, is );
        return new MavenXpp3Reader().read( is );
    }
5689#private SimpleProblemCollector validate( String pom )
        throws Exception
    {
        return validateEffective( pom, ModelBuildingRequest.VALIDATION_LEVEL_STRICT );
    }
5690#private SimpleProblemCollector validateRaw( String pom )
        throws Exception
    {
        return validateRaw( pom, ModelBuildingRequest.VALIDATION_LEVEL_STRICT );
    }
5691#private SimpleProblemCollector validateEffective( String pom, int level )
        throws Exception
    {
        ModelBuildingRequest request = new DefaultModelBuildingRequest().setValidationLevel( level );

        SimpleProblemCollector problems = new SimpleProblemCollector();

        validator.validateEffectiveModel( read( pom ), request, problems );

        return problems;
    }
5692#private SimpleProblemCollector validateRaw( String pom, int level )
        throws Exception
    {
        ModelBuildingRequest request = new DefaultModelBuildingRequest().setValidationLevel( level );

        SimpleProblemCollector problems = new SimpleProblemCollector();

        validator.validateRawModel( read( pom ), request, problems );

        return problems;
    }
5693#private void assertContains( String msg, String substring )
    {
        assertTrue( "\"" + substring + "\" was not found in: " + msg, msg.contains( substring ) );
    }
5694#@Override
    protected void setUp()
        throws Exception
    {
        super.setUp();

        validator = lookup( ModelValidator.class );
    }
5695#@Override
    protected void tearDown()
        throws Exception
    {
        this.validator = null;

        super.tearDown();
    }
5696#private void assertViolations( SimpleProblemCollector result, int fatals, int errors, int warnings )
    {
        assertEquals( String.valueOf( result.getFatals() ), fatals, result.getFatals().size() );
        assertEquals( String.valueOf( result.getErrors() ), errors, result.getErrors().size() );
        assertEquals( String.valueOf( result.getWarnings() ), warnings, result.getWarnings().size() );
    }
5697#public void testMissingModelVersion()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-modelVersion-pom.xml" );

        assertViolations( result, 0, 1, 0 );

        assertEquals( "'modelVersion' is missing.", result.getErrors().get( 0 ) );
    }
5698#public void testBadModelVersion()
        throws Exception
    {
        SimpleProblemCollector result =
            validateRaw( "bad-modelVersion.xml", ModelBuildingRequest.VALIDATION_LEVEL_STRICT );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).indexOf( "modelVersion" ) > -1 );
    }
5699#public void testMissingArtifactId()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-artifactId-pom.xml" );

        assertViolations( result, 0, 1, 0 );

        assertEquals( "'artifactId' is missing.", result.getErrors().get( 0 ) );
    }
5700#public void testMissingGroupId()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-groupId-pom.xml" );

        assertViolations( result, 0, 1, 0 );

        assertEquals( "'groupId' is missing.", result.getErrors().get( 0 ) );
    }
5701#public void testInvalidIds()
        throws Exception
    {
        SimpleProblemCollector result = validate( "invalid-ids-pom.xml" );

        assertViolations( result, 0, 2, 0 );

        assertEquals( "'groupId' with value 'o/a/m' does not match a valid id pattern.", result.getErrors().get( 0 ) );

        assertEquals( "'artifactId' with value 'm$-do$' does not match a valid id pattern.", result.getErrors().get( 1 ) );
    }
5702#public void testMissingType()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-type-pom.xml" );

        assertViolations( result, 0, 1, 0 );

        assertEquals( "'packaging' is missing.", result.getErrors().get( 0 ) );
    }
5703#public void testMissingVersion()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-version-pom.xml" );

        assertViolations( result, 0, 1, 0 );

        assertEquals( "'version' is missing.", result.getErrors().get( 0 ) );
    }
5704#public void testInvalidAggregatorPackaging()
        throws Exception
    {
        SimpleProblemCollector result = validate( "invalid-aggregator-packaging-pom.xml" );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).indexOf( "Aggregator projects require 'pom' as packaging." ) > -1 );
    }
5705#public void testMissingDependencyArtifactId()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-dependency-artifactId-pom.xml" );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).indexOf(
                                                         "'dependencies.dependency.artifactId' for groupId:null:jar is missing" ) > -1 );
    }
5706#public void testMissingDependencyGroupId()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-dependency-groupId-pom.xml" );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).indexOf(
                                                         "'dependencies.dependency.groupId' for null:artifactId:jar is missing" ) > -1 );
    }
5707#public void testMissingDependencyVersion()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-dependency-version-pom.xml" );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).indexOf(
                                                         "'dependencies.dependency.version' for groupId:artifactId:jar is missing" ) > -1 );
    }
5708#public void testMissingDependencyManagementArtifactId()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-dependency-mgmt-artifactId-pom.xml" );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).indexOf(
                                                         "'dependencyManagement.dependencies.dependency.artifactId' for groupId:null:jar is missing" ) > -1 );
    }
5709#public void testMissingDependencyManagementGroupId()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-dependency-mgmt-groupId-pom.xml" );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).indexOf(
                                                         "'dependencyManagement.dependencies.dependency.groupId' for null:artifactId:jar is missing" ) > -1 );
    }
5710#public void testMissingAll()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-1-pom.xml" );

        assertViolations( result, 0, 4, 0 );

        List<String> messages = result.getErrors();

        assertTrue( messages.contains( "\'modelVersion\' is missing." ) );
        assertTrue( messages.contains( "\'groupId\' is missing." ) );
        assertTrue( messages.contains( "\'artifactId\' is missing." ) );
        assertTrue( messages.contains( "\'version\' is missing." ) );
        // type is inherited from the super pom
    }
5711#public void testMissingPluginArtifactId()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-plugin-artifactId-pom.xml" );

        assertViolations( result, 0, 1, 0 );

        assertEquals( "'build.plugins.plugin.artifactId' is missing.", result.getErrors().get( 0 ) );
    }
5712#public void testEmptyPluginVersion()
        throws Exception
    {
        SimpleProblemCollector result = validate( "empty-plugin-version.xml" );

        assertViolations( result, 0, 1, 0 );

        assertEquals( "'build.plugins.plugin.version' for org.apache.maven.plugins:maven-it-plugin"
            + " must be a valid version but is ''.", result.getErrors().get( 0 ) );
    }
5713#public void testMissingRepositoryId()
        throws Exception
    {
        SimpleProblemCollector result =
            validateRaw( "missing-repository-id-pom.xml", ModelBuildingRequest.VALIDATION_LEVEL_STRICT );

        assertViolations( result, 0, 4, 0 );

        assertEquals( "'repositories.repository.id' is missing.", result.getErrors().get( 0 ) );

        assertEquals( "'repositories.repository[null].url' is missing.", result.getErrors().get( 1 ) );

        assertEquals( "'pluginRepositories.pluginRepository.id' is missing.", result.getErrors().get( 2 ) );

        assertEquals( "'pluginRepositories.pluginRepository[null].url' is missing.", result.getErrors().get( 3 ) );
    }
5714#public void testMissingResourceDirectory()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-resource-directory-pom.xml" );

        assertViolations( result, 0, 2, 0 );

        assertEquals( "'build.resources.resource.directory' is missing.", result.getErrors().get( 0 ) );

        assertEquals( "'build.testResources.testResource.directory' is missing.", result.getErrors().get( 1 ) );
    }
5715#public void testBadPluginDependencyScope()
        throws Exception
    {
        SimpleProblemCollector result = validate( "bad-plugin-dependency-scope.xml" );

        assertViolations( result, 0, 3, 0 );

        assertTrue( result.getErrors().get( 0 ).contains( "test:d" ) );

        assertTrue( result.getErrors().get( 1 ).contains( "test:e" ) );

        assertTrue( result.getErrors().get( 2 ).contains( "test:f" ) );
    }
5716#public void testBadDependencyScope()
        throws Exception
    {
        SimpleProblemCollector result = validate( "bad-dependency-scope.xml" );

        assertViolations( result, 0, 0, 2 );

        assertTrue( result.getWarnings().get( 0 ).contains( "test:f" ) );

        assertTrue( result.getWarnings().get( 1 ).contains( "test:g" ) );
    }
5717#public void testBadDependencyVersion()
        throws Exception
    {
        SimpleProblemCollector result = validate( "bad-dependency-version.xml" );

        assertViolations( result, 0, 2, 0 );

        assertContains( result.getErrors().get( 0 ),
                        "'dependencies.dependency.version' for test:b:jar must be a valid version" );
        assertContains( result.getErrors().get( 1 ),
                        "'dependencies.dependency.version' for test:c:jar must not contain any of these characters" );
    }
5718#public void testDuplicateModule()
        throws Exception
    {
        SimpleProblemCollector result = validate( "duplicate-module.xml" );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).contains( "child" ) );
    }
5719#public void testDuplicateProfileId()
        throws Exception
    {
        SimpleProblemCollector result = validateRaw( "duplicate-profile-id.xml" );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).contains( "non-unique-id" ) );
    }
5720#public void testBadPluginVersion()
        throws Exception
    {
        SimpleProblemCollector result = validate( "bad-plugin-version.xml" );

        assertViolations( result, 0, 4, 0 );

        assertContains( result.getErrors().get( 0 ),
                        "'build.plugins.plugin.version' for test:mip must be a valid version" );
        assertContains( result.getErrors().get( 1 ),
                        "'build.plugins.plugin.version' for test:rmv must be a valid version" );
        assertContains( result.getErrors().get( 2 ),
                        "'build.plugins.plugin.version' for test:lmv must be a valid version" );
        assertContains( result.getErrors().get( 3 ),
                        "'build.plugins.plugin.version' for test:ifsc must not contain any of these characters" );
    }
5721#public void testDistributionManagementStatus()
        throws Exception
    {
        SimpleProblemCollector result = validate( "distribution-management-status.xml" );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).contains( "distributionManagement.status" ) );
    }
5722#public void testIncompleteParent()
        throws Exception
    {
        SimpleProblemCollector result = validateRaw( "incomplete-parent.xml" );

        assertViolations( result, 3, 0, 0 );

        assertTrue( result.getFatals().get( 0 ).contains( "parent.groupId" ) );
        assertTrue( result.getFatals().get( 1 ).contains( "parent.artifactId" ) );
        assertTrue( result.getFatals().get( 2 ).contains( "parent.version" ) );
    }
5723#public void testHardCodedSystemPath()
        throws Exception
    {
        SimpleProblemCollector result = validateRaw( "hard-coded-system-path.xml" );

        assertViolations( result, 0, 0, 1 );

        assertTrue( result.getWarnings().get( 0 ).contains( "test:a:jar" ) );
    }
5724#public void testEmptyModule()
        throws Exception
    {
        SimpleProblemCollector result = validate( "empty-module.xml" );

        assertViolations( result, 0, 0, 1 );

        assertTrue( result.getWarnings().get( 0 ).contains( "'modules.module[0]' has been specified without a path" ) );
    }
5725#public void testDuplicatePlugin()
        throws Exception
    {
        SimpleProblemCollector result = validateRaw( "duplicate-plugin.xml" );

        assertViolations( result, 0, 0, 4 );

        assertTrue( result.getWarnings().get( 0 ).contains( "duplicate declaration of plugin test:duplicate" ) );
        assertTrue( result.getWarnings().get( 1 ).contains( "duplicate declaration of plugin test:managed-duplicate" ) );
        assertTrue( result.getWarnings().get( 2 ).contains( "duplicate declaration of plugin profile:duplicate" ) );
        assertTrue( result.getWarnings().get( 3 ).contains( "duplicate declaration of plugin profile:managed-duplicate" ) );
    }
5726#public void testDuplicatePluginExecution()
        throws Exception
    {
        SimpleProblemCollector result = validateRaw( "duplicate-plugin-execution.xml" );

        assertViolations( result, 0, 4, 0 );

        assertContains( result.getErrors().get( 0 ), "duplicate execution with id a" );
        assertContains( result.getErrors().get( 1 ), "duplicate execution with id default" );
        assertContains( result.getErrors().get( 2 ), "duplicate execution with id c" );
        assertContains( result.getErrors().get( 3 ), "duplicate execution with id b" );
    }
5727#public void testReservedRepositoryId()
        throws Exception
    {
        SimpleProblemCollector result = validate( "reserved-repository-id.xml" );

        assertViolations( result, 0, 0, 4 );

        assertContains( result.getWarnings().get( 0 ), "'repositories.repository.id'" + " must not be 'local'" );
        assertContains( result.getWarnings().get( 1 ), "'pluginRepositories.pluginRepository.id' must not be 'local'" );
        assertContains( result.getWarnings().get( 2 ), "'distributionManagement.repository.id' must not be 'local'" );
        assertContains( result.getWarnings().get( 3 ),
                        "'distributionManagement.snapshotRepository.id' must not be 'local'" );
    }
5728#public void testMissingPluginDependencyGroupId()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-plugin-dependency-groupId.xml" );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).contains( ":a:" ) );
    }
5729#public void testMissingPluginDependencyArtifactId()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-plugin-dependency-artifactId.xml" );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).contains( "test:" ) );
    }
5730#public void testMissingPluginDependencyVersion()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-plugin-dependency-version.xml" );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).contains( "test:a" ) );
    }
5731#public void testBadPluginDependencyVersion()
        throws Exception
    {
        SimpleProblemCollector result = validate( "bad-plugin-dependency-version.xml" );

        assertViolations( result, 0, 1, 0 );

        assertTrue( result.getErrors().get( 0 ).contains( "test:b" ) );
    }
5732#public void testBadVersion()
        throws Exception
    {
        SimpleProblemCollector result = validate( "bad-version.xml" );

        assertViolations( result, 0, 0, 1 );

        assertContains( result.getWarnings().get( 0 ), "'version' must not contain any of these characters" );
    }
5733#public void testBadSnapshotVersion()
        throws Exception
    {
        SimpleProblemCollector result = validate( "bad-snapshot-version.xml" );

        assertViolations( result, 0, 0, 1 );

        assertContains( result.getWarnings().get( 0 ), "'version' uses an unsupported snapshot version format" );
    }
5734#public void testBadRepositoryId()
        throws Exception
    {
        SimpleProblemCollector result = validate( "bad-repository-id.xml" );

        assertViolations( result, 0, 0, 4 );

        assertContains( result.getWarnings().get( 0 ),
                        "'repositories.repository.id' must not contain any of these characters" );
        assertContains( result.getWarnings().get( 1 ),
                        "'pluginRepositories.pluginRepository.id' must not contain any of these characters" );
        assertContains( result.getWarnings().get( 2 ),
                        "'distributionManagement.repository.id' must not contain any of these characters" );
        assertContains( result.getWarnings().get( 3 ),
                        "'distributionManagement.snapshotRepository.id' must not contain any of these characters" );
    }
5735#public void testBadDependencyExclusionId()
        throws Exception
    {
        SimpleProblemCollector result = validate( "bad-dependency-exclusion-id.xml" );

        assertViolations( result, 0, 0, 2 );

        assertContains( result.getWarnings().get( 0 ),
                        "'dependencies.dependency.exclusions.exclusion.groupId' for gid:aid:jar" );
        assertContains( result.getWarnings().get( 1 ),
                        "'dependencies.dependency.exclusions.exclusion.artifactId' for gid:aid:jar" );
    }
5736#public void testMissingDependencyExclusionId()
        throws Exception
    {
        SimpleProblemCollector result = validate( "missing-dependency-exclusion-id.xml" );

        assertViolations( result, 0, 0, 2 );

        assertContains( result.getWarnings().get( 0 ),
                        "'dependencies.dependency.exclusions.exclusion.groupId' for gid:aid:jar is missing" );
        assertContains( result.getWarnings().get( 1 ),
                        "'dependencies.dependency.exclusions.exclusion.artifactId' for gid:aid:jar is missing" );
    }
5737#public void testBadImportScopeType()
        throws Exception
    {
        SimpleProblemCollector result = validateRaw( "bad-import-scope-type.xml" );

        assertViolations( result, 0, 0, 1 );

        assertContains( result.getWarnings().get( 0 ),
                        "'dependencyManagement.dependencies.dependency.type' for test:a:jar must be 'pom'" );
    }
5738#public void testBadImportScopeClassifier()
        throws Exception
    {
        SimpleProblemCollector result = validateRaw( "bad-import-scope-classifier.xml" );

        assertViolations( result, 0, 1, 0 );

        assertContains( result.getErrors().get( 0 ),
                        "'dependencyManagement.dependencies.dependency.classifier' for test:a:pom:cls must be empty" );
    }
5739#public void testSystemPathRefersToProjectBasedir()
        throws Exception
    {
        SimpleProblemCollector result = validateRaw( "basedir-system-path.xml" );

        assertViolations( result, 0, 0, 2 );

        assertContains( result.getWarnings().get( 0 ), "'dependencies.dependency.systemPath' for test:a:jar "
            + "should not point at files within the project directory" );
        assertContains( result.getWarnings().get( 1 ), "'dependencies.dependency.systemPath' for test:b:jar "
            + "should not point at files within the project directory" );
    }
5740#/**
     * Merges the specified source object into the given target object.
     *
     * @param target The target object whose existing contents should be merged with the source, must not be
     *            <code>null</code>.
     * @param source The (read-only) source object that should be merged into the target object, may be
     *            <code>null</code>.
     * @param sourceDominant A flag indicating whether either the target object or the source object provides the
     *            dominant data.
     * @param hints A set of key-value pairs that customized merger implementations can use to carry domain-specific
     *            information along, may be <code>null</code>.
     */
    public void merge( Model target, Model source, boolean sourceDominant, Map<?, ?> hints )
    {
        if ( target == null )
        {
            throw new IllegalArgumentException( "target missing" );
        }

        if ( source == null )
        {
            return;
        }

        Map<Object, Object> context = new HashMap<Object, Object>();
        if ( hints != null )
        {
            context.putAll( hints );
        }

        mergeModel( target, source, sourceDominant, context );
    }
5741#protected void mergeModel( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        mergeModelBase( target, source, sourceDominant, context );

        mergeModel_ModelVersion( target, source, sourceDominant, context );
        mergeModel_Parent( target, source, sourceDominant, context );
        mergeModel_GroupId( target, source, sourceDominant, context );
        mergeModel_ArtifactId( target, source, sourceDominant, context );
        mergeModel_Version( target, source, sourceDominant, context );
        mergeModel_Packaging( target, source, sourceDominant, context );
        mergeModel_Name( target, source, sourceDominant, context );
        mergeModel_Description( target, source, sourceDominant, context );
        mergeModel_Url( target, source, sourceDominant, context );
        mergeModel_InceptionYear( target, source, sourceDominant, context );
        mergeModel_Organization( target, source, sourceDominant, context );
        mergeModel_Licenses( target, source, sourceDominant, context );
        mergeModel_MailingLists( target, source, sourceDominant, context );
        mergeModel_Developers( target, source, sourceDominant, context );
        mergeModel_Contributors( target, source, sourceDominant, context );
        mergeModel_IssueManagement( target, source, sourceDominant, context );
        mergeModel_Scm( target, source, sourceDominant, context );
        mergeModel_CiManagement( target, source, sourceDominant, context );
        mergeModel_Prerequisites( target, source, sourceDominant, context );
        mergeModel_Build( target, source, sourceDominant, context );
        mergeModel_Profiles( target, source, sourceDominant, context );
    }
5742#protected void mergeModel_ModelVersion( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        String src = source.getModelVersion();
        if ( src != null )
        {
            if ( sourceDominant || target.getModelVersion() == null )
            {
                target.setModelVersion( src );
                target.setLocation( "modelVersion", source.getLocation( "modelVersion" ) );
            }
        }
    }
5743#protected void mergeModel_Parent( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Parent src = source.getParent();
        if ( src != null )
        {
            Parent tgt = target.getParent();
            if ( tgt == null )
            {
                tgt = new Parent();
                tgt.setRelativePath( null );
                target.setParent( tgt );
            }
            mergeParent( tgt, src, sourceDominant, context );
        }
    }
5744#protected void mergeModel_GroupId( Model target, Model source, boolean sourceDominant,
                                       Map<Object, Object> context )
    {
        String src = source.getGroupId();
        if ( src != null )
        {
            if ( sourceDominant || target.getGroupId() == null )
            {
                target.setGroupId( src );
                target.setLocation( "groupId", source.getLocation( "groupId" ) );
            }
        }
    }
5745#protected void mergeModel_ArtifactId( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        String src = source.getArtifactId();
        if ( src != null )
        {
            if ( sourceDominant || target.getArtifactId() == null )
            {
                target.setArtifactId( src );
                target.setLocation( "artifactId", source.getLocation( "artifactId" ) );
            }
        }
    }
5746#protected void mergeModel_Version( Model target, Model source, boolean sourceDominant,
                                       Map<Object, Object> context )
    {
        String src = source.getVersion();
        if ( src != null )
        {
            if ( sourceDominant || target.getVersion() == null )
            {
                target.setVersion( src );
                target.setLocation( "version", source.getLocation( "version" ) );
            }
        }
    }
5747#protected void mergeModel_Packaging( Model target, Model source, boolean sourceDominant,
                                         Map<Object, Object> context )
    {
        String src = source.getPackaging();
        if ( src != null )
        {
            if ( sourceDominant || target.getPackaging() == null )
            {
                target.setPackaging( src );
                target.setLocation( "packaging", source.getLocation( "packaging" ) );
            }
        }
    }
5748#protected void mergeModel_Name( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getName();
        if ( src != null )
        {
            if ( sourceDominant || target.getName() == null )
            {
                target.setName( src );
                target.setLocation( "name", source.getLocation( "name" ) );
            }
        }
    }
5749#protected void mergeModel_Description( Model target, Model source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        String src = source.getDescription();
        if ( src != null )
        {
            if ( sourceDominant || target.getDescription() == null )
            {
                target.setDescription( src );
                target.setLocation( "description", source.getLocation( "description" ) );
            }
        }
    }
5750#protected void mergeModel_Url( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant || target.getUrl() == null )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }
5751#protected void mergeModel_InceptionYear( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        String src = source.getInceptionYear();
        if ( src != null )
        {
            if ( sourceDominant || target.getInceptionYear() == null )
            {
                target.setInceptionYear( src );
                target.setLocation( "inceptionYear", source.getLocation( "inceptionYear" ) );
            }
        }
    }
5752#protected void mergeModel_Organization( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        Organization src = source.getOrganization();
        if ( src != null )
        {
            Organization tgt = target.getOrganization();
            if ( tgt == null )
            {
                tgt = new Organization();
                target.setOrganization( tgt );
            }
            mergeOrganization( tgt, src, sourceDominant, context );
        }
    }
5753#protected void mergeModel_Licenses( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<License> src = source.getLicenses();
        if ( !src.isEmpty() )
        {
            List<License> tgt = target.getLicenses();
            Map<Object, License> merged = new LinkedHashMap<Object, License>( ( src.size() + tgt.size() ) * 2 );

            for ( License element : tgt )
            {
                Object key = getLicenseKey( element );
                merged.put( key, element );
            }

            for ( License element : src )
            {
                Object key = getLicenseKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setLicenses( new ArrayList<License>( merged.values() ) );
        }
    }
5754#protected void mergeModel_MailingLists( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<MailingList> src = source.getMailingLists();
        if ( !src.isEmpty() )
        {
            List<MailingList> tgt = target.getMailingLists();
            Map<Object, MailingList> merged = new LinkedHashMap<Object, MailingList>( ( src.size() + tgt.size() ) * 2 );

            for ( MailingList element : tgt )
            {
                Object key = getMailingListKey( element );
                merged.put( key, element );
            }

            for ( MailingList element : src )
            {
                Object key = getMailingListKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setMailingLists( new ArrayList<MailingList>( merged.values() ) );
        }
    }
5755#protected void mergeModel_Developers( Model target, Model source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Developer> src = source.getDevelopers();
        if ( !src.isEmpty() )
        {
            List<Developer> tgt = target.getDevelopers();
            Map<Object, Developer> merged = new LinkedHashMap<Object, Developer>( ( src.size() + tgt.size() ) * 2 );

            for ( Developer element : tgt )
            {
                Object key = getDeveloperKey( element );
                merged.put( key, element );
            }

            for ( Developer element : src )
            {
                Object key = getDeveloperKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDevelopers( new ArrayList<Developer>( merged.values() ) );
        }
    }
5756#protected void mergeModel_Contributors( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        List<Contributor> src = source.getContributors();
        if ( !src.isEmpty() )
        {
            List<Contributor> tgt = target.getContributors();
            Map<Object, Contributor> merged = new LinkedHashMap<Object, Contributor>( ( src.size() + tgt.size() ) * 2 );

            for ( Contributor element : tgt )
            {
                Object key = getContributorKey( element );
                merged.put( key, element );
            }

            for ( Contributor element : src )
            {
                Object key = getContributorKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setContributors( new ArrayList<Contributor>( merged.values() ) );
        }
    }
5757#protected void mergeModel_IssueManagement( Model target, Model source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        IssueManagement src = source.getIssueManagement();
        if ( src != null )
        {
            IssueManagement tgt = target.getIssueManagement();
            if ( tgt == null )
            {
                tgt = new IssueManagement();
                target.setIssueManagement( tgt );
            }
            mergeIssueManagement( tgt, src, sourceDominant, context );
        }
    }
5758#protected void mergeModel_Scm( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Scm src = source.getScm();
        if ( src != null )
        {
            Scm tgt = target.getScm();
            if ( tgt == null )
            {
                tgt = new Scm();
                tgt.setTag( null );
                target.setScm( tgt );
            }
            mergeScm( tgt, src, sourceDominant, context );
        }
    }
5759#protected void mergeModel_CiManagement( Model target, Model source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        CiManagement src = source.getCiManagement();
        if ( src != null )
        {
            CiManagement tgt = target.getCiManagement();
            if ( tgt == null )
            {
                tgt = new CiManagement();
                target.setCiManagement( tgt );
            }
            mergeCiManagement( tgt, src, sourceDominant, context );
        }
    }
5760#protected void mergeModel_Prerequisites( Model target, Model source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Prerequisites src = source.getPrerequisites();
        if ( src != null )
        {
            Prerequisites tgt = target.getPrerequisites();
            if ( tgt == null )
            {
                tgt = new Prerequisites();
                tgt.setMaven( null );
                target.setPrerequisites( tgt );
            }
            mergePrerequisites( tgt, src, sourceDominant, context );
        }
    }
5761#protected void mergeModel_Build( Model target, Model source, boolean sourceDominant, Map<Object, Object> context )
    {
        Build src = source.getBuild();
        if ( src != null )
        {
            Build tgt = target.getBuild();
            if ( tgt == null )
            {
                tgt = new Build();
                target.setBuild( tgt );
            }
            mergeBuild( tgt, src, sourceDominant, context );
        }
    }
5762#protected void mergeModel_Profiles( Model target, Model source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        List<Profile> src = source.getProfiles();
        if ( !src.isEmpty() )
        {
            List<Profile> tgt = target.getProfiles();
            Map<Object, Profile> merged = new LinkedHashMap<Object, Profile>( ( src.size() + tgt.size() ) * 2 );

            for ( Profile element : tgt )
            {
                Object key = getProfileKey( element );
                merged.put( key, element );
            }

            for ( Profile element : src )
            {
                Object key = getProfileKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setProfiles( new ArrayList<Profile>( merged.values() ) );
        }
    }
5763#protected void mergeModelBase( ModelBase target, ModelBase source, boolean sourceDominant,
                                   Map<Object, Object> context )
    {
        mergeModelBase_DistributionManagement( target, source, sourceDominant, context );
        mergeModelBase_Modules( target, source, sourceDominant, context );
        mergeModelBase_Repositories( target, source, sourceDominant, context );
        mergeModelBase_PluginRepositories( target, source, sourceDominant, context );
        mergeModelBase_Dependencies( target, source, sourceDominant, context );
        mergeModelBase_Reporting( target, source, sourceDominant, context );
        mergeModelBase_DependencyManagement( target, source, sourceDominant, context );
        mergeModelBase_Properties( target, source, sourceDominant, context );
    }
5764#protected void mergeModelBase_Modules( ModelBase target, ModelBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getModules();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getModules();
            List<String> merged = new ArrayList<String>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setModules( merged );
        }
    }
5765#protected void mergeModelBase_Dependencies( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<Object, Dependency>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<Dependency>( merged.values() ) );
        }
    }
5766#protected void mergeModelBase_Repositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Repository> src = source.getRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<Object, Repository>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setRepositories( new ArrayList<Repository>( merged.values() ) );
        }
    }
5767#protected void mergeModelBase_PluginRepositories( ModelBase target, ModelBase source, boolean sourceDominant,
                                                      Map<Object, Object> context )
    {
        List<Repository> src = source.getPluginRepositories();
        if ( !src.isEmpty() )
        {
            List<Repository> tgt = target.getPluginRepositories();
            Map<Object, Repository> merged = new LinkedHashMap<Object, Repository>( ( src.size() + tgt.size() ) * 2 );

            for ( Repository element : tgt )
            {
                Object key = getRepositoryKey( element );
                merged.put( key, element );
            }

            for ( Repository element : src )
            {
                Object key = getRepositoryKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPluginRepositories( new ArrayList<Repository>( merged.values() ) );
        }
    }
5768#protected void mergeModelBase_DistributionManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                          Map<Object, Object> context )
    {
        DistributionManagement src = source.getDistributionManagement();
        if ( src != null )
        {
            DistributionManagement tgt = target.getDistributionManagement();
            if ( tgt == null )
            {
                tgt = new DistributionManagement();
                target.setDistributionManagement( tgt );
            }
            mergeDistributionManagement( tgt, src, sourceDominant, context );
        }
    }
5769#protected void mergeModelBase_Reporting( ModelBase target, ModelBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        Reporting src = source.getReporting();
        if ( src != null )
        {
            Reporting tgt = target.getReporting();
            if ( tgt == null )
            {
                tgt = new Reporting();
                target.setReporting( tgt );
            }
            mergeReporting( tgt, src, sourceDominant, context );
        }
    }
5770#protected void mergeModelBase_DependencyManagement( ModelBase target, ModelBase source, boolean sourceDominant,
                                                        Map<Object, Object> context )
    {
        DependencyManagement src = source.getDependencyManagement();
        if ( src != null )
        {
            DependencyManagement tgt = target.getDependencyManagement();
            if ( tgt == null )
            {
                tgt = new DependencyManagement();
                target.setDependencyManagement( tgt );
            }
            mergeDependencyManagement( tgt, src, sourceDominant, context );
        }
    }
5771#protected void mergeModelBase_Properties( ModelBase target, ModelBase source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        Properties merged = new Properties();
        if ( sourceDominant )
        {
            merged.putAll( target.getProperties() );
            merged.putAll( source.getProperties() );
        }
        else
        {
            merged.putAll( source.getProperties() );
            merged.putAll( target.getProperties() );
        }
        target.setProperties( merged );
        target.setLocation( "properties", InputLocation.merge( target.getLocation( "properties" ),
                                                               source.getLocation( "properties" ), sourceDominant ) );
    }
5772#protected void mergeDistributionManagement( DistributionManagement target, DistributionManagement source,
                                                boolean sourceDominant, Map<Object, Object> context )
    {
        mergeDistributionManagement_Repository( target, source, sourceDominant, context );
        mergeDistributionManagement_SnapshotRepository( target, source, sourceDominant, context );
        mergeDistributionManagement_Site( target, source, sourceDominant, context );
        mergeDistributionManagement_Status( target, source, sourceDominant, context );
        mergeDistributionManagement_DownloadUrl( target, source, sourceDominant, context );
    }
5773#protected void mergeDistributionManagement_Repository( DistributionManagement target,
                                                           DistributionManagement source, boolean sourceDominant,
                                                           Map<Object, Object> context )
    {
        DeploymentRepository src = source.getRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }
5774#protected void mergeDistributionManagement_SnapshotRepository( DistributionManagement target,
                                                                   DistributionManagement source,
                                                                   boolean sourceDominant,
                                                                   Map<Object, Object> context )
    {
        DeploymentRepository src = source.getSnapshotRepository();
        if ( src != null )
        {
            DeploymentRepository tgt = target.getSnapshotRepository();
            if ( tgt == null )
            {
                tgt = new DeploymentRepository();
                target.setSnapshotRepository( tgt );
            }
            mergeDeploymentRepository( tgt, src, sourceDominant, context );
        }
    }
5775#protected void mergeDistributionManagement_Site( DistributionManagement target, DistributionManagement source,
                                                     boolean sourceDominant, Map<Object, Object> context )
    {
        Site src = source.getSite();
        if ( src != null )
        {
            Site tgt = target.getSite();
            if ( tgt == null )
            {
                tgt = new Site();
                target.setSite( tgt );
            }
            mergeSite( tgt, src, sourceDominant, context );
        }
    }
5776#protected void mergeDistributionManagement_Status( DistributionManagement target, DistributionManagement source,
                                                       boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getStatus();
        if ( src != null )
        {
            if ( sourceDominant || target.getStatus() == null )
            {
                target.setStatus( src );
                target.setLocation( "status", source.getLocation( "status" ) );
            }
        }
    }
5777#protected void mergeDistributionManagement_DownloadUrl( DistributionManagement target,
                                                            DistributionManagement source, boolean sourceDominant,
                                                            Map<Object, Object> context )
    {
        String src = source.getDownloadUrl();
        if ( src != null )
        {
            if ( sourceDominant || target.getDownloadUrl() == null )
            {
                target.setDownloadUrl( src );
                target.setLocation( "downloadUrl", source.getLocation( "downloadUrl" ) );
            }
        }
    }
5778#protected void mergeRelocation( Relocation target, Relocation source, boolean sourceDominant,
                                    Map<Object, Object> context )
    {
        mergeRelocation_GroupId( target, source, sourceDominant, context );
        mergeRelocation_ArtifactId( target, source, sourceDominant, context );
        mergeRelocation_Version( target, source, sourceDominant, context );
        mergeRelocation_Message( target, source, sourceDominant, context );
    }
5779#protected void mergeRelocation_GroupId( Relocation target, Relocation source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        String src = source.getGroupId();
        if ( src != null )
        {
            if ( sourceDominant || target.getGroupId() == null )
            {
                target.setGroupId( src );
                target.setLocation( "groupId", source.getLocation( "groupId" ) );
            }
        }
    }
5780#protected void mergeRelocation_ArtifactId( Relocation target, Relocation source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        String src = source.getArtifactId();
        if ( src != null )
        {
            if ( sourceDominant || target.getArtifactId() == null )
            {
                target.setArtifactId( src );
                target.setLocation( "artifactId", source.getLocation( "artifactId" ) );
            }
        }
    }
5781#protected void mergeRelocation_Version( Relocation target, Relocation source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        String src = source.getVersion();
        if ( src != null )
        {
            if ( sourceDominant || target.getVersion() == null )
            {
                target.setVersion( src );
                target.setLocation( "version", source.getLocation( "version" ) );
            }
        }
    }
5782#protected void mergeRelocation_Message( Relocation target, Relocation source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        String src = source.getMessage();
        if ( src != null )
        {
            if ( sourceDominant || target.getMessage() == null )
            {
                target.setMessage( src );
                target.setLocation( "message", source.getLocation( "message" ) );
            }
        }
    }
5783#protected void mergeDeploymentRepository( DeploymentRepository target, DeploymentRepository source,
                                              boolean sourceDominant, Map<Object, Object> context )
    {
        mergeRepository( target, source, sourceDominant, context );
        mergeDeploymentRepository_UniqueVersion( target, source, sourceDominant, context );
    }
5784#protected void mergeDeploymentRepository_UniqueVersion( DeploymentRepository target, DeploymentRepository source,
                                                            boolean sourceDominant, Map<Object, Object> context )
    {
        if ( sourceDominant )
        {
            target.setUniqueVersion( source.isUniqueVersion() );
            target.setLocation( "uniqueVersion", source.getLocation( "uniqueVersion" ) );
        }
    }
5785#protected void mergeSite( Site target, Site source, boolean sourceDominant, Map<Object, Object> context )
    {
        mergeSite_Id( target, source, sourceDominant, context );
        mergeSite_Name( target, source, sourceDominant, context );
        mergeSite_Url( target, source, sourceDominant, context );
    }
5786#protected void mergeSite_Id( Site target, Site source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getId();
        if ( src != null )
        {
            if ( sourceDominant || target.getId() == null )
            {
                target.setId( src );
                target.setLocation( "id", source.getLocation( "id" ) );
            }
        }
    }
5787#protected void mergeSite_Name( Site target, Site source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getName();
        if ( src != null )
        {
            if ( sourceDominant || target.getName() == null )
            {
                target.setName( src );
                target.setLocation( "name", source.getLocation( "name" ) );
            }
        }
    }
5788#protected void mergeSite_Url( Site target, Site source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant || target.getUrl() == null )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }
5789#protected void mergeRepository( Repository target, Repository source, boolean sourceDominant,
                                    Map<Object, Object> context )
    {
        mergeRepositoryBase( target, source, sourceDominant, context );
        mergeRepository_Releases( target, source, sourceDominant, context );
        mergeRepository_Snapshots( target, source, sourceDominant, context );
    }
5790#protected void mergeRepository_Releases( Repository target, Repository source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getReleases();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getReleases();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setReleases( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }
5791#protected void mergeRepository_Snapshots( Repository target, Repository source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        RepositoryPolicy src = source.getSnapshots();
        if ( src != null )
        {
            RepositoryPolicy tgt = target.getSnapshots();
            if ( tgt == null )
            {
                tgt = new RepositoryPolicy();
                target.setSnapshots( tgt );
            }
            mergeRepositoryPolicy( tgt, src, sourceDominant, context );
        }
    }
5792#protected void mergeRepositoryBase( RepositoryBase target, RepositoryBase source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        mergeRepositoryBase_Id( target, source, sourceDominant, context );
        mergeRepositoryBase_Name( target, source, sourceDominant, context );
        mergeRepositoryBase_Url( target, source, sourceDominant, context );
        mergeRepositoryBase_Layout( target, source, sourceDominant, context );
    }
5793#protected void mergeRepositoryBase_Id( RepositoryBase target, RepositoryBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        String src = source.getId();
        if ( src != null )
        {
            if ( sourceDominant || target.getId() == null )
            {
                target.setId( src );
                target.setLocation( "id", source.getLocation( "id" ) );
            }
        }
    }
5794#protected void mergeRepositoryBase_Url( RepositoryBase target, RepositoryBase source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant || target.getUrl() == null )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }
5795#protected void mergeRepositoryBase_Name( RepositoryBase target, RepositoryBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        String src = source.getName();
        if ( src != null )
        {
            if ( sourceDominant || target.getName() == null )
            {
                target.setName( src );
                target.setLocation( "name", source.getLocation( "name" ) );
            }
        }
    }
5796#protected void mergeRepositoryBase_Layout( RepositoryBase target, RepositoryBase source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        String src = source.getLayout();
        if ( src != null )
        {
            if ( sourceDominant || target.getLayout() == null )
            {
                target.setLayout( src );
                target.setLocation( "layout", source.getLocation( "layout" ) );
            }
        }
    }
5797#protected void mergeRepositoryPolicy( RepositoryPolicy target, RepositoryPolicy source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        mergeRepositoryPolicy_Enabled( target, source, sourceDominant, context );
        mergeRepositoryPolicy_UpdatePolicy( target, source, sourceDominant, context );
        mergeRepositoryPolicy_ChecksumPolicy( target, source, sourceDominant, context );
    }
5798#protected void mergeRepositoryPolicy_Enabled( RepositoryPolicy target, RepositoryPolicy source,
                                                  boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getEnabled();
        if ( src != null )
        {
            if ( sourceDominant || target.getEnabled() == null )
            {
                target.setEnabled( src );
                target.setLocation( "enabled", source.getLocation( "enabled" ) );
            }
        }
    }
5799#protected void mergeRepositoryPolicy_UpdatePolicy( RepositoryPolicy target, RepositoryPolicy source,
                                                       boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUpdatePolicy();
        if ( src != null )
        {
            if ( sourceDominant || target.getUpdatePolicy() == null )
            {
                target.setUpdatePolicy( src );
                target.setLocation( "updatePolicy", source.getLocation( "updatePolicy" ) );
            }
        }
    }
5800#protected void mergeRepositoryPolicy_ChecksumPolicy( RepositoryPolicy target, RepositoryPolicy source,
                                                         boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getChecksumPolicy();
        if ( src != null )
        {
            if ( sourceDominant || target.getChecksumPolicy() == null )
            {
                target.setChecksumPolicy( src );
                target.setLocation( "checksumPolicy", source.getLocation( "checksumPolicy" ) );
            }
        }
    }
5801#protected void mergeDependency( Dependency target, Dependency source, boolean sourceDominant,
                                    Map<Object, Object> context )
    {
        mergeDependency_GroupId( target, source, sourceDominant, context );
        mergeDependency_ArtifactId( target, source, sourceDominant, context );
        mergeDependency_Version( target, source, sourceDominant, context );
        mergeDependency_Type( target, source, sourceDominant, context );
        mergeDependency_Classifier( target, source, sourceDominant, context );
        mergeDependency_Scope( target, source, sourceDominant, context );
        mergeDependency_SystemPath( target, source, sourceDominant, context );
        mergeDependency_Optional( target, source, sourceDominant, context );
        mergeDependency_Exclusions( target, source, sourceDominant, context );
    }
5802#protected void mergeDependency_GroupId( Dependency target, Dependency source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        String src = source.getGroupId();
        if ( src != null )
        {
            if ( sourceDominant || target.getGroupId() == null )
            {
                target.setGroupId( src );
                target.setLocation( "groupId", source.getLocation( "groupId" ) );
            }
        }
    }
5803#protected void mergeDependency_ArtifactId( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        String src = source.getArtifactId();
        if ( src != null )
        {
            if ( sourceDominant || target.getArtifactId() == null )
            {
                target.setArtifactId( src );
                target.setLocation( "artifactId", source.getLocation( "artifactId" ) );
            }
        }
    }
5804#protected void mergeDependency_Version( Dependency target, Dependency source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        String src = source.getVersion();
        if ( src != null )
        {
            if ( sourceDominant || target.getVersion() == null )
            {
                target.setVersion( src );
                target.setLocation( "version", source.getLocation( "version" ) );
            }
        }
    }
5805#protected void mergeDependency_Type( Dependency target, Dependency source, boolean sourceDominant,
                                         Map<Object, Object> context )
    {
        String src = source.getType();
        if ( src != null )
        {
            if ( sourceDominant || target.getType() == null )
            {
                target.setType( src );
                target.setLocation( "type", source.getLocation( "type" ) );
            }
        }
    }
5806#protected void mergeDependency_Classifier( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        String src = source.getClassifier();
        if ( src != null )
        {
            if ( sourceDominant || target.getClassifier() == null )
            {
                target.setClassifier( src );
                target.setLocation( "classifier", source.getLocation( "classifier" ) );
            }
        }
    }
5807#protected void mergeDependency_Scope( Dependency target, Dependency source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        String src = source.getScope();
        if ( src != null )
        {
            if ( sourceDominant || target.getScope() == null )
            {
                target.setScope( src );
                target.setLocation( "scope", source.getLocation( "scope" ) );
            }
        }
    }
5808#protected void mergeDependency_SystemPath( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        String src = source.getSystemPath();
        if ( src != null )
        {
            if ( sourceDominant || target.getSystemPath() == null )
            {
                target.setSystemPath( src );
                target.setLocation( "systemPath", source.getLocation( "systemPath" ) );
            }
        }
    }
5809#protected void mergeDependency_Optional( Dependency target, Dependency source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        String src = source.getOptional();
        if ( src != null )
        {
            if ( sourceDominant || target.getOptional() == null )
            {
                target.setOptional( src );
                target.setLocation( "optional", source.getLocation( "optional" ) );
            }
        }
    }
5810#protected void mergeDependency_Exclusions( Dependency target, Dependency source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<Exclusion> src = source.getExclusions();
        if ( !src.isEmpty() )
        {
            List<Exclusion> tgt = target.getExclusions();

            Map<Object, Exclusion> merged = new LinkedHashMap<Object, Exclusion>( ( src.size() + tgt.size() ) * 2 );

            for ( Exclusion element : tgt )
            {
                Object key = getExclusionKey( element );
                merged.put( key, element );
            }

            for ( Exclusion element : src )
            {
                Object key = getExclusionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExclusions( new ArrayList<Exclusion>( merged.values() ) );
        }
    }
5811#protected void mergeExclusion( Exclusion target, Exclusion source, boolean sourceDominant,
                                   Map<Object, Object> context )
    {
        mergeExclusion_GroupId( target, source, sourceDominant, context );
        mergeExclusion_ArtifactId( target, source, sourceDominant, context );
    }
5812#protected void mergeExclusion_GroupId( Exclusion target, Exclusion source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        String src = source.getGroupId();
        if ( src != null )
        {
            if ( sourceDominant || target.getGroupId() == null )
            {
                target.setGroupId( src );
                target.setLocation( "groupId", source.getLocation( "groupId" ) );
            }
        }
    }
5813#protected void mergeExclusion_ArtifactId( Exclusion target, Exclusion source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        String src = source.getArtifactId();
        if ( src != null )
        {
            if ( sourceDominant || target.getArtifactId() == null )
            {
                target.setArtifactId( src );
                target.setLocation( "artifactId", source.getLocation( "artifactId" ) );
            }
        }
    }
5814#protected void mergeReporting( Reporting target, Reporting source, boolean sourceDominant,
                                   Map<Object, Object> context )
    {
        mergeReporting_OutputDirectory( target, source, sourceDominant, context );
        mergeReporting_ExcludeDefaults( target, source, sourceDominant, context );
        mergeReporting_Plugins( target, source, sourceDominant, context );
    }
5815#protected void mergeReporting_OutputDirectory( Reporting target, Reporting source, boolean sourceDominant,
                                                   Map<Object, Object> context )
    {
        String src = source.getOutputDirectory();
        if ( src != null )
        {
            if ( sourceDominant || target.getOutputDirectory() == null )
            {
                target.setOutputDirectory( src );
                target.setLocation( "outputDirectory", source.getLocation( "outputDirectory" ) );
            }
        }
    }
5816#protected void mergeReporting_ExcludeDefaults( Reporting target, Reporting source, boolean sourceDominant,
                                                   Map<Object, Object> context )
    {
        String src = source.getExcludeDefaults();
        if ( src != null )
        {
            if ( sourceDominant || target.getExcludeDefaults() == null )
            {
                target.setExcludeDefaults( src );
                target.setLocation( "excludeDefaults", source.getLocation( "excludeDefaults" ) );
            }
        }
    }
5817#protected void mergeReporting_Plugins( Reporting target, Reporting source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<ReportPlugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<ReportPlugin> tgt = target.getPlugins();
            Map<Object, ReportPlugin> merged =
                new LinkedHashMap<Object, ReportPlugin>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportPlugin element : tgt )
            {
                Object key = getReportPluginKey( element );
                merged.put( key, element );
            }

            for ( ReportPlugin element : src )
            {
                Object key = getReportPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<ReportPlugin>( merged.values() ) );
        }
    }
5818#protected void mergeReportPlugin( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                      Map<Object, Object> context )
    {
        mergeConfigurationContainer( target, source, sourceDominant, context );
        mergeReportPlugin_GroupId( target, source, sourceDominant, context );
        mergeReportPlugin_ArtifactId( target, source, sourceDominant, context );
        mergeReportPlugin_Version( target, source, sourceDominant, context );
        mergeReportPlugin_ReportSets( target, source, sourceDominant, context );
    }
5819#protected void mergeReportPlugin_GroupId( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        String src = source.getGroupId();
        if ( src != null )
        {
            if ( sourceDominant || target.getGroupId() == null )
            {
                target.setGroupId( src );
                target.setLocation( "groupId", source.getLocation( "groupId" ) );
            }
        }
    }
5820#protected void mergeReportPlugin_ArtifactId( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        String src = source.getArtifactId();
        if ( src != null )
        {
            if ( sourceDominant || target.getArtifactId() == null )
            {
                target.setArtifactId( src );
                target.setLocation( "artifactId", source.getLocation( "artifactId" ) );
            }
        }
    }
5821#protected void mergeReportPlugin_Version( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        String src = source.getVersion();
        if ( src != null )
        {
            if ( sourceDominant || target.getVersion() == null )
            {
                target.setVersion( src );
                target.setLocation( "version", source.getLocation( "version" ) );
            }
        }
    }
5822#protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<ReportSet> src = source.getReportSets();
        if ( !src.isEmpty() )
        {
            List<ReportSet> tgt = target.getReportSets();
            Map<Object, ReportSet> merged = new LinkedHashMap<Object, ReportSet>( ( src.size() + tgt.size() ) * 2 );

            for ( ReportSet element : tgt )
            {
                Object key = getReportSetKey( element );
                merged.put( key, element );
            }

            for ( ReportSet element : src )
            {
                Object key = getReportSetKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setReportSets( new ArrayList<ReportSet>( merged.values() ) );
        }
    }
5823#protected void mergeReportSet( ReportSet target, ReportSet source, boolean sourceDominant,
                                   Map<Object, Object> context )
    {
        mergeConfigurationContainer( target, source, sourceDominant, context );
        mergeReportSet_Id( target, source, sourceDominant, context );
        mergeReportSet_Reports( target, source, sourceDominant, context );
    }
5824#protected void mergeReportSet_Id( ReportSet target, ReportSet source, boolean sourceDominant,
                                      Map<Object, Object> context )
    {
        String src = source.getId();
        if ( src != null )
        {
            if ( sourceDominant || target.getId() == null )
            {
                target.setId( src );
                target.setLocation( "id", source.getLocation( "id" ) );
            }
        }
    }
5825#protected void mergeReportSet_Reports( ReportSet target, ReportSet source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getReports();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getReports();
            List<String> merged = new ArrayList<String>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setReports( merged );
        }
    }
5826#protected void mergeDependencyManagement( DependencyManagement target, DependencyManagement source,
                                              boolean sourceDominant, Map<Object, Object> context )
    {
        mergeDependencyManagement_Dependencies( target, source, sourceDominant, context );
    }
5827#protected void mergeDependencyManagement_Dependencies( DependencyManagement target, DependencyManagement source,
                                                           boolean sourceDominant, Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<Object, Dependency>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<Dependency>( merged.values() ) );
        }
    }
5828#protected void mergeParent( Parent target, Parent source, boolean sourceDominant, Map<Object, Object> context )
    {
        mergeParent_GroupId( target, source, sourceDominant, context );
        mergeParent_ArtifactId( target, source, sourceDominant, context );
        mergeParent_Version( target, source, sourceDominant, context );
        mergeParent_RelativePath( target, source, sourceDominant, context );
    }
5829#protected void mergeParent_GroupId( Parent target, Parent source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        String src = source.getGroupId();
        if ( src != null )
        {
            if ( sourceDominant || target.getGroupId() == null )
            {
                target.setGroupId( src );
                target.setLocation( "groupId", source.getLocation( "groupId" ) );
            }
        }
    }
5830#protected void mergeParent_ArtifactId( Parent target, Parent source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        String src = source.getArtifactId();
        if ( src != null )
        {
            if ( sourceDominant || target.getArtifactId() == null )
            {
                target.setArtifactId( src );
                target.setLocation( "artifactId", source.getLocation( "artifactId" ) );
            }
        }
    }
5831#protected void mergeParent_Version( Parent target, Parent source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        String src = source.getVersion();
        if ( src != null )
        {
            if ( sourceDominant || target.getVersion() == null )
            {
                target.setVersion( src );
                target.setLocation( "version", source.getLocation( "version" ) );
            }
        }
    }
5832#protected void mergeParent_RelativePath( Parent target, Parent source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        String src = source.getRelativePath();
        if ( src != null )
        {
            if ( sourceDominant || target.getRelativePath() == null )
            {
                target.setRelativePath( src );
                target.setLocation( "relativePath", source.getLocation( "relativePath" ) );
            }
        }
    }
5833#protected void mergeOrganization( Organization target, Organization source, boolean sourceDominant,
                                      Map<Object, Object> context )
    {
        mergeOrganization_Name( target, source, sourceDominant, context );
        mergeOrganization_Url( target, source, sourceDominant, context );
    }
5834#protected void mergeOrganization_Name( Organization target, Organization source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        String src = source.getName();
        if ( src != null )
        {
            if ( sourceDominant || target.getName() == null )
            {
                target.setName( src );
                target.setLocation( "name", source.getLocation( "name" ) );
            }
        }
    }
5835#protected void mergeOrganization_Url( Organization target, Organization source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant || target.getUrl() == null )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }
5836#protected void mergeLicense( License target, License source, boolean sourceDominant, Map<Object, Object> context )
    {
        mergeLicense_Name( target, source, sourceDominant, context );
        mergeLicense_Url( target, source, sourceDominant, context );
        mergeLicense_Distribution( target, source, sourceDominant, context );
        mergeLicense_Comments( target, source, sourceDominant, context );
    }
5837#protected void mergeLicense_Name( License target, License source, boolean sourceDominant,
                                      Map<Object, Object> context )
    {
        String src = source.getName();
        if ( src != null )
        {
            if ( sourceDominant || target.getName() == null )
            {
                target.setName( src );
                target.setLocation( "name", source.getLocation( "name" ) );
            }
        }
    }
5838#protected void mergeLicense_Url( License target, License source, boolean sourceDominant,
                                     Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant || target.getUrl() == null )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }
5839#protected void mergeLicense_Distribution( License target, License source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        String src = source.getDistribution();
        if ( src != null )
        {
            if ( sourceDominant || target.getDistribution() == null )
            {
                target.setDistribution( src );
                target.setLocation( "distribution", source.getLocation( "distribution" ) );
            }
        }
    }
5840#protected void mergeLicense_Comments( License target, License source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        String src = source.getComments();
        if ( src != null )
        {
            if ( sourceDominant || target.getComments() == null )
            {
                target.setComments( src );
                target.setLocation( "comments", source.getLocation( "comments" ) );
            }
        }
    }
5841#protected void mergeMailingList( MailingList target, MailingList source, boolean sourceDominant,
                                     Map<Object, Object> context )
    {
        mergeMailingList_Name( target, source, sourceDominant, context );
        mergeMailingList_Subscribe( target, source, sourceDominant, context );
        mergeMailingList_Unsubscribe( target, source, sourceDominant, context );
        mergeMailingList_Post( target, source, sourceDominant, context );
        mergeMailingList_OtherArchives( target, source, sourceDominant, context );
    }
5842#protected void mergeMailingList_Name( MailingList target, MailingList source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        String src = source.getName();
        if ( src != null )
        {
            if ( sourceDominant || target.getName() == null )
            {
                target.setName( src );
                target.setLocation( "name", source.getLocation( "name" ) );
            }
        }
    }
5843#protected void mergeMailingList_Subscribe( MailingList target, MailingList source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        String src = source.getSubscribe();
        if ( src != null )
        {
            if ( sourceDominant || target.getSubscribe() == null )
            {
                target.setSubscribe( src );
                target.setLocation( "subscribe", source.getLocation( "subscribe" ) );
            }
        }
    }
5844#protected void mergeMailingList_Unsubscribe( MailingList target, MailingList source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        String src = source.getUnsubscribe();
        if ( src != null )
        {
            if ( sourceDominant || target.getUnsubscribe() == null )
            {
                target.setUnsubscribe( src );
                target.setLocation( "unsubscribe", source.getLocation( "unsubscribe" ) );
            }
        }
    }
5845#protected void mergeMailingList_Post( MailingList target, MailingList source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        String src = source.getPost();
        if ( src != null )
        {
            if ( sourceDominant || target.getPost() == null )
            {
                target.setPost( src );
                target.setLocation( "post", source.getLocation( "post" ) );
            }
        }
    }
5846#protected void mergeMailingList_Archive( MailingList target, MailingList source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        String src = source.getArchive();
        if ( src != null )
        {
            if ( sourceDominant || target.getArchive() == null )
            {
                target.setArchive( src );
                target.setLocation( "archive", source.getLocation( "archive" ) );
            }
        }
    }
5847#protected void mergeMailingList_OtherArchives( MailingList target, MailingList source, boolean sourceDominant,
                                                   Map<Object, Object> context )
    {
        List<String> src = source.getOtherArchives();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getOtherArchives();
            List<String> merged = new ArrayList<String>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setOtherArchives( merged );
        }
    }
5848#protected void mergeDeveloper( Developer target, Developer source, boolean sourceDominant,
                                   Map<Object, Object> context )
    {
        mergeContributor( target, source, sourceDominant, context );
        mergeDeveloper_Id( target, source, sourceDominant, context );
    }
5849#protected void mergeDeveloper_Id( Developer target, Developer source, boolean sourceDominant,
                                      Map<Object, Object> context )
    {
        String src = source.getId();
        if ( src != null )
        {
            if ( sourceDominant || target.getId() == null )
            {
                target.setId( src );
                target.setLocation( "id", source.getLocation( "id" ) );
            }
        }
    }
5850#protected void mergeContributor( Contributor target, Contributor source, boolean sourceDominant,
                                     Map<Object, Object> context )
    {
        mergeContributor_Name( target, source, sourceDominant, context );
        mergeContributor_Email( target, source, sourceDominant, context );
        mergeContributor_Url( target, source, sourceDominant, context );
        mergeContributor_Organization( target, source, sourceDominant, context );
        mergeContributor_OrganizationUrl( target, source, sourceDominant, context );
        mergeContributor_Timezone( target, source, sourceDominant, context );
        mergeContributor_Roles( target, source, sourceDominant, context );
        mergeContributor_Properties( target, source, sourceDominant, context );
    }
5851#protected void mergeContributor_Name( Contributor target, Contributor source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        String src = source.getName();
        if ( src != null )
        {
            if ( sourceDominant || target.getName() == null )
            {
                target.setName( src );
                target.setLocation( "name", source.getLocation( "name" ) );
            }
        }
    }
5852#protected void mergeContributor_Email( Contributor target, Contributor source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        String src = source.getEmail();
        if ( src != null )
        {
            if ( sourceDominant || target.getEmail() == null )
            {
                target.setEmail( src );
                target.setLocation( "email", source.getLocation( "email" ) );
            }
        }
    }
5853#protected void mergeContributor_Url( Contributor target, Contributor source, boolean sourceDominant,
                                         Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant || target.getUrl() == null )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }
5854#protected void mergeContributor_Organization( Contributor target, Contributor source, boolean sourceDominant,
                                                  Map<Object, Object> context )
    {
        String src = source.getOrganization();
        if ( src != null )
        {
            if ( sourceDominant || target.getOrganization() == null )
            {
                target.setOrganization( src );
                target.setLocation( "organization", source.getLocation( "organization" ) );
            }
        }
    }
5855#protected void mergeContributor_OrganizationUrl( Contributor target, Contributor source, boolean sourceDominant,
                                                     Map<Object, Object> context )
    {
        String src = source.getOrganizationUrl();
        if ( src != null )
        {
            if ( sourceDominant || target.getOrganizationUrl() == null )
            {
                target.setOrganizationUrl( src );
                target.setLocation( "organizationUrl", source.getLocation( "organizationUrl" ) );
            }
        }
    }
5856#protected void mergeContributor_Timezone( Contributor target, Contributor source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        String src = source.getTimezone();
        if ( src != null )
        {
            if ( sourceDominant || target.getTimezone() == null )
            {
                target.setTimezone( src );
                target.setLocation( "timezone", source.getLocation( "timezone" ) );
            }
        }
    }
5857#protected void mergeContributor_Roles( Contributor target, Contributor source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getRoles();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getRoles();
            List<String> merged = new ArrayList<String>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setRoles( merged );
        }
    }
5858#protected void mergeContributor_Properties( Contributor target, Contributor source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        Properties merged = new Properties();
        if ( sourceDominant )
        {
            merged.putAll( target.getProperties() );
            merged.putAll( source.getProperties() );
        }
        else
        {
            merged.putAll( source.getProperties() );
            merged.putAll( target.getProperties() );
        }
        target.setProperties( merged );
        target.setLocation( "properties", InputLocation.merge( target.getLocation( "properties" ),
                                                               source.getLocation( "properties" ), sourceDominant ) );
    }
5859#protected void mergeIssueManagement( IssueManagement target, IssueManagement source, boolean sourceDominant,
                                         Map<Object, Object> context )
    {
        mergeIssueManagement_Url( target, source, sourceDominant, context );
        mergeIssueManagement_System( target, source, sourceDominant, context );
    }
5860#protected void mergeIssueManagement_System( IssueManagement target, IssueManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        String src = source.getSystem();
        if ( src != null )
        {
            if ( sourceDominant || target.getSystem() == null )
            {
                target.setSystem( src );
                target.setLocation( "system", source.getLocation( "system" ) );
            }
        }
    }
5861#protected void mergeIssueManagement_Url( IssueManagement target, IssueManagement source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant || target.getUrl() == null )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }
5862#protected void mergeScm( Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context )
    {
        mergeScm_Url( target, source, sourceDominant, context );
        mergeScm_Connection( target, source, sourceDominant, context );
        mergeScm_DeveloperConnection( target, source, sourceDominant, context );
        mergeScm_Tag( target, source, sourceDominant, context );
    }
5863#protected void mergeScm_Url( Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant || target.getUrl() == null )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }
5864#protected void mergeScm_Connection( Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getConnection();
        if ( src != null )
        {
            if ( sourceDominant || target.getConnection() == null )
            {
                target.setConnection( src );
                target.setLocation( "connection", source.getLocation( "connection" ) );
            }
        }
    }
5865#protected void mergeScm_DeveloperConnection( Scm target, Scm source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        String src = source.getDeveloperConnection();
        if ( src != null )
        {
            if ( sourceDominant || target.getDeveloperConnection() == null )
            {
                target.setDeveloperConnection( src );
                target.setLocation( "developerConnection", source.getLocation( "developerConnection" ) );
            }
        }
    }
5866#protected void mergeScm_Tag( Scm target, Scm source, boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getTag();
        if ( src != null )
        {
            if ( sourceDominant || target.getTag() == null )
            {
                target.setTag( src );
                target.setLocation( "tag", source.getLocation( "tag" ) );
            }
        }
    }
5867#protected void mergeCiManagement( CiManagement target, CiManagement source, boolean sourceDominant,
                                      Map<Object, Object> context )
    {
        mergeCiManagement_System( target, source, sourceDominant, context );
        mergeCiManagement_Url( target, source, sourceDominant, context );
        mergeCiManagement_Notifiers( target, source, sourceDominant, context );
    }
5868#protected void mergeCiManagement_System( CiManagement target, CiManagement source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        String src = source.getSystem();
        if ( src != null )
        {
            if ( sourceDominant || target.getSystem() == null )
            {
                target.setSystem( src );
                target.setLocation( "system", source.getLocation( "system" ) );
            }
        }
    }
5869#protected void mergeCiManagement_Url( CiManagement target, CiManagement source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        String src = source.getUrl();
        if ( src != null )
        {
            if ( sourceDominant || target.getUrl() == null )
            {
                target.setUrl( src );
                target.setLocation( "url", source.getLocation( "url" ) );
            }
        }
    }
5870#protected void mergeCiManagement_Notifiers( CiManagement target, CiManagement source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        List<Notifier> src = source.getNotifiers();
        if ( !src.isEmpty() )
        {
            List<Notifier> tgt = target.getNotifiers();
            Map<Object, Notifier> merged = new LinkedHashMap<Object, Notifier>( ( src.size() + tgt.size() ) * 2 );

            for ( Notifier element : tgt )
            {
                Object key = getNotifierKey( element );
                merged.put( key, element );
            }

            for ( Notifier element : src )
            {
                Object key = getNotifierKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setNotifiers( new ArrayList<Notifier>( merged.values() ) );
        }
    }
5871#protected void mergeNotifier( Notifier target, Notifier source, boolean sourceDominant,
                                  Map<Object, Object> context )
    {
        mergeNotifier_Type( target, source, sourceDominant, context );
        mergeNotifier_Address( target, source, sourceDominant, context );
        mergeNotifier_Configuration( target, source, sourceDominant, context );
        mergeNotifier_SendOnError( target, source, sourceDominant, context );
        mergeNotifier_SendOnFailure( target, source, sourceDominant, context );
        mergeNotifier_SendOnSuccess( target, source, sourceDominant, context );
        mergeNotifier_SendOnWarning( target, source, sourceDominant, context );
    }
5872#protected void mergeNotifier_Type( Notifier target, Notifier source, boolean sourceDominant,
                                       Map<Object, Object> context )
    {
        String src = source.getType();
        if ( src != null )
        {
            if ( sourceDominant || target.getType() == null )
            {
                target.setType( src );
            }
        }
    }
5873#protected void mergeNotifier_Address( Notifier target, Notifier source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        String src = source.getAddress();
        if ( src != null )
        {
            if ( sourceDominant || target.getAddress() == null )
            {
                target.setAddress( src );
            }
        }
    }
5874#protected void mergeNotifier_Configuration( Notifier target, Notifier source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        Properties merged = new Properties();
        if ( sourceDominant )
        {
            merged.putAll( target.getConfiguration() );
            merged.putAll( source.getConfiguration() );
        }
        else
        {
            merged.putAll( source.getConfiguration() );
            merged.putAll( target.getConfiguration() );
        }
        target.setConfiguration( merged );
    }
5875#protected void mergeNotifier_SendOnError( Notifier target, Notifier source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        if ( sourceDominant )
        {
            target.setSendOnError( source.isSendOnError() );
        }
    }
5876#protected void mergeNotifier_SendOnFailure( Notifier target, Notifier source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        if ( sourceDominant )
        {
            target.setSendOnFailure( source.isSendOnFailure() );
        }
    }
5877#protected void mergeNotifier_SendOnSuccess( Notifier target, Notifier source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        if ( sourceDominant )
        {
            target.setSendOnSuccess( source.isSendOnSuccess() );
        }
    }
5878#protected void mergeNotifier_SendOnWarning( Notifier target, Notifier source, boolean sourceDominant,
                                                Map<Object, Object> context )
    {
        if ( sourceDominant )
        {
            target.setSendOnWarning( source.isSendOnWarning() );
        }
    }
5879#protected void mergePrerequisites( Prerequisites target, Prerequisites source, boolean sourceDominant,
                                       Map<Object, Object> context )
    {
        mergePrerequisites_Maven( target, source, sourceDominant, context );
    }
5880#protected void mergePrerequisites_Maven( Prerequisites target, Prerequisites source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        String src = source.getMaven();
        if ( src != null )
        {
            if ( sourceDominant || target.getMaven() == null )
            {
                target.setMaven( src );
                target.setLocation( "maven", source.getLocation( "maven" ) );
            }
        }
    }
5881#protected void mergeBuild( Build target, Build source, boolean sourceDominant, Map<Object, Object> context )
    {
        mergeBuildBase( target, source, sourceDominant, context );
        mergeBuild_SourceDirectory( target, source, sourceDominant, context );
        mergeBuild_ScriptSourceDirectory( target, source, sourceDominant, context );
        mergeBuild_TestSourceDirectory( target, source, sourceDominant, context );
        mergeBuild_OutputDirectory( target, source, sourceDominant, context );
        mergeBuild_TestOutputDirectory( target, source, sourceDominant, context );
        mergeBuild_Extensions( target, source, sourceDominant, context );
    }
5882#protected void mergeBuild_SourceDirectory( Build target, Build source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        String src = source.getSourceDirectory();
        if ( src != null )
        {
            if ( sourceDominant || target.getSourceDirectory() == null )
            {
                target.setSourceDirectory( src );
                target.setLocation( "sourceDirectory", source.getLocation( "sourceDirectory" ) );
            }
        }
    }
5883#protected void mergeBuild_ScriptSourceDirectory( Build target, Build source, boolean sourceDominant,
                                                     Map<Object, Object> context )
    {
        String src = source.getScriptSourceDirectory();
        if ( src != null )
        {
            if ( sourceDominant || target.getScriptSourceDirectory() == null )
            {
                target.setScriptSourceDirectory( src );
                target.setLocation( "scriptSourceDirectory", source.getLocation( "scriptSourceDirectory" ) );
            }
        }
    }
5884#protected void mergeBuild_TestSourceDirectory( Build target, Build source, boolean sourceDominant,
                                                   Map<Object, Object> context )
    {
        String src = source.getTestSourceDirectory();
        if ( src != null )
        {
            if ( sourceDominant || target.getTestSourceDirectory() == null )
            {
                target.setTestSourceDirectory( src );
                target.setLocation( "testSourceDirectory", source.getLocation( "testSourceDirectory" ) );
            }
        }
    }
5885#protected void mergeBuild_OutputDirectory( Build target, Build source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        String src = source.getOutputDirectory();
        if ( src != null )
        {
            if ( sourceDominant || target.getOutputDirectory() == null )
            {
                target.setOutputDirectory( src );
                target.setLocation( "outputDirectory", source.getLocation( "outputDirectory" ) );
            }
        }
    }
5886#protected void mergeBuild_TestOutputDirectory( Build target, Build source, boolean sourceDominant,
                                                   Map<Object, Object> context )
    {
        String src = source.getTestOutputDirectory();
        if ( src != null )
        {
            if ( sourceDominant || target.getTestOutputDirectory() == null )
            {
                target.setTestOutputDirectory( src );
                target.setLocation( "testOutputDirectory", source.getLocation( "testOutputDirectory" ) );
            }
        }
    }
5887#protected void mergeBuild_Extensions( Build target, Build source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        List<Extension> src = source.getExtensions();
        if ( !src.isEmpty() )
        {
            List<Extension> tgt = target.getExtensions();
            Map<Object, Extension> merged = new LinkedHashMap<Object, Extension>( ( src.size() + tgt.size() ) * 2 );

            for ( Extension element : tgt )
            {
                Object key = getExtensionKey( element );
                merged.put( key, element );
            }

            for ( Extension element : src )
            {
                Object key = getExtensionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExtensions( new ArrayList<Extension>( merged.values() ) );
        }
    }
5888#protected void mergeExtension( Extension target, Extension source, boolean sourceDominant,
                                   Map<Object, Object> context )
    {
        mergeExtension_GroupId( target, source, sourceDominant, context );
        mergeExtension_ArtifactId( target, source, sourceDominant, context );
        mergeExtension_Version( target, source, sourceDominant, context );
    }
5889#protected void mergeExtension_GroupId( Extension target, Extension source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        String src = source.getGroupId();
        if ( src != null )
        {
            if ( sourceDominant || target.getGroupId() == null )
            {
                target.setGroupId( src );
                target.setLocation( "groupId", source.getLocation( "groupId" ) );
            }
        }
    }
5890#protected void mergeExtension_ArtifactId( Extension target, Extension source, boolean sourceDominant,
                                              Map<Object, Object> context )
    {
        String src = source.getArtifactId();
        if ( src != null )
        {
            if ( sourceDominant || target.getArtifactId() == null )
            {
                target.setArtifactId( src );
                target.setLocation( "artifactId", source.getLocation( "artifactId" ) );
            }
        }
    }
5891#protected void mergeExtension_Version( Extension target, Extension source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        String src = source.getVersion();
        if ( src != null )
        {
            if ( sourceDominant || target.getVersion() == null )
            {
                target.setVersion( src );
                target.setLocation( "version", source.getLocation( "version" ) );
            }
        }
    }
5892#protected void mergeBuildBase( BuildBase target, BuildBase source, boolean sourceDominant,
                                   Map<Object, Object> context )
    {
        mergePluginConfiguration( target, source, sourceDominant, context );
        mergeBuildBase_DefaultGoal( target, source, sourceDominant, context );
        mergeBuildBase_FinalName( target, source, sourceDominant, context );
        mergeBuildBase_Directory( target, source, sourceDominant, context );
        mergeBuildBase_Resources( target, source, sourceDominant, context );
        mergeBuildBase_TestResources( target, source, sourceDominant, context );
        mergeBuildBase_Filters( target, source, sourceDominant, context );
    }
5893#protected void mergeBuildBase_DefaultGoal( BuildBase target, BuildBase source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        String src = source.getDefaultGoal();
        if ( src != null )
        {
            if ( sourceDominant || target.getDefaultGoal() == null )
            {
                target.setDefaultGoal( src );
                target.setLocation( "defaultGoal", source.getLocation( "defaultGoal" ) );
            }
        }
    }
5894#protected void mergeBuildBase_Directory( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        String src = source.getDirectory();
        if ( src != null )
        {
            if ( sourceDominant || target.getDirectory() == null )
            {
                target.setDirectory( src );
                target.setLocation( "directory", source.getLocation( "directory" ) );
            }
        }
    }
5895#protected void mergeBuildBase_FinalName( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        String src = source.getFinalName();
        if ( src != null )
        {
            if ( sourceDominant || target.getFinalName() == null )
            {
                target.setFinalName( src );
                target.setLocation( "finalName", source.getLocation( "finalName" ) );
            }
        }
    }
5896#protected void mergeBuildBase_Filters( BuildBase target, BuildBase source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<String> src = source.getFilters();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getFilters();
            List<String> merged = new ArrayList<String>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setFilters( merged );
        }
    }
5897#protected void mergeBuildBase_Resources( BuildBase target, BuildBase source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Resource> src = source.getResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getResources();
            Map<Object, Resource> merged = new LinkedHashMap<Object, Resource>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setResources( new ArrayList<Resource>( merged.values() ) );
        }
    }
5898#protected void mergeBuildBase_TestResources( BuildBase target, BuildBase source, boolean sourceDominant,
                                                 Map<Object, Object> context )
    {
        List<Resource> src = source.getTestResources();
        if ( !src.isEmpty() )
        {
            List<Resource> tgt = target.getTestResources();
            Map<Object, Resource> merged = new LinkedHashMap<Object, Resource>( ( src.size() + tgt.size() ) * 2 );

            for ( Resource element : tgt )
            {
                Object key = getResourceKey( element );
                merged.put( key, element );
            }

            for ( Resource element : src )
            {
                Object key = getResourceKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setTestResources( new ArrayList<Resource>( merged.values() ) );
        }
    }
5899#protected void mergePluginConfiguration( PluginConfiguration target, PluginConfiguration source,
                                             boolean sourceDominant, Map<Object, Object> context )
    {
        mergePluginContainer( target, source, sourceDominant, context );
        mergePluginConfiguration_PluginManagement( target, source, sourceDominant, context );
    }
5900#protected void mergePluginConfiguration_PluginManagement( PluginConfiguration target, PluginConfiguration source,
                                                              boolean sourceDominant, Map<Object, Object> context )
    {
        PluginManagement src = source.getPluginManagement();
        if ( src != null )
        {
            PluginManagement tgt = target.getPluginManagement();
            if ( tgt == null )
            {
                tgt = new PluginManagement();
                target.setPluginManagement( tgt );
            }
            mergePluginManagement( tgt, src, sourceDominant, context );
        }
    }
5901#protected void mergePluginContainer( PluginContainer target, PluginContainer source, boolean sourceDominant,
                                         Map<Object, Object> context )
    {
        mergePluginContainer_Plugins( target, source, sourceDominant, context );
    }
5902#protected void mergePluginContainer_Plugins( PluginContainer target, PluginContainer source,
                                                 boolean sourceDominant, Map<Object, Object> context )
    {
        List<Plugin> src = source.getPlugins();
        if ( !src.isEmpty() )
        {
            List<Plugin> tgt = target.getPlugins();
            Map<Object, Plugin> merged = new LinkedHashMap<Object, Plugin>( ( src.size() + tgt.size() ) * 2 );

            for ( Plugin element : tgt )
            {
                Object key = getPluginKey( element );
                merged.put( key, element );
            }

            for ( Plugin element : src )
            {
                Object key = getPluginKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setPlugins( new ArrayList<Plugin>( merged.values() ) );
        }
    }
5903#protected void mergePluginManagement( PluginManagement target, PluginManagement source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        mergePluginContainer( target, source, sourceDominant, context );
    }
5904#protected void mergePlugin( Plugin target, Plugin source, boolean sourceDominant, Map<Object, Object> context )
    {
        mergeConfigurationContainer( target, source, sourceDominant, context );
        mergePlugin_GroupId( target, source, sourceDominant, context );
        mergePlugin_ArtifactId( target, source, sourceDominant, context );
        mergePlugin_Version( target, source, sourceDominant, context );
        mergePlugin_Extensions( target, source, sourceDominant, context );
        mergePlugin_Dependencies( target, source, sourceDominant, context );
        mergePlugin_Executions( target, source, sourceDominant, context );
    }
5905#protected void mergePlugin_GroupId( Plugin target, Plugin source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        String src = source.getGroupId();
        if ( src != null )
        {
            if ( sourceDominant || target.getGroupId() == null )
            {
                target.setGroupId( src );
                target.setLocation( "groupId", source.getLocation( "groupId" ) );
            }
        }
    }
5906#protected void mergePlugin_ArtifactId( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        String src = source.getArtifactId();
        if ( src != null )
        {
            if ( sourceDominant || target.getArtifactId() == null )
            {
                target.setArtifactId( src );
                target.setLocation( "artifactId", source.getLocation( "artifactId" ) );
            }
        }
    }
5907#protected void mergePlugin_Version( Plugin target, Plugin source, boolean sourceDominant,
                                        Map<Object, Object> context )
    {
        String src = source.getVersion();
        if ( src != null )
        {
            if ( sourceDominant || target.getVersion() == null )
            {
                target.setVersion( src );
                target.setLocation( "version", source.getLocation( "version" ) );
            }
        }
    }
5908#protected void mergePlugin_Extensions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        String src = source.getExtensions();
        if ( src != null )
        {
            if ( sourceDominant || target.getExtensions() == null )
            {
                target.setExtensions( src );
                target.setLocation( "extensions", source.getLocation( "extensions" ) );
            }
        }
    }
5909#protected void mergePlugin_Dependencies( Plugin target, Plugin source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<Dependency> src = source.getDependencies();
        if ( !src.isEmpty() )
        {
            List<Dependency> tgt = target.getDependencies();
            Map<Object, Dependency> merged = new LinkedHashMap<Object, Dependency>( ( src.size() + tgt.size() ) * 2 );

            for ( Dependency element : tgt )
            {
                Object key = getDependencyKey( element );
                merged.put( key, element );
            }

            for ( Dependency element : src )
            {
                Object key = getDependencyKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setDependencies( new ArrayList<Dependency>( merged.values() ) );
        }
    }
5910#protected void mergePlugin_Executions( Plugin target, Plugin source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        List<PluginExecution> src = source.getExecutions();
        if ( !src.isEmpty() )
        {
            List<PluginExecution> tgt = target.getExecutions();

            Map<Object, PluginExecution> merged =
                new LinkedHashMap<Object, PluginExecution>( ( src.size() + tgt.size() ) * 2 );

            for ( PluginExecution element : tgt )
            {
                Object key = getPluginExecutionKey( element );
                merged.put( key, element );
            }

            for ( PluginExecution element : src )
            {
                Object key = getPluginExecutionKey( element );
                if ( sourceDominant || !merged.containsKey( key ) )
                {
                    merged.put( key, element );
                }
            }

            target.setExecutions( new ArrayList<PluginExecution>( merged.values() ) );
        }
    }
5911#protected void mergeConfigurationContainer( ConfigurationContainer target, ConfigurationContainer source,
                                                boolean sourceDominant, Map<Object, Object> context )
    {
        mergeConfigurationContainer_Inherited( target, source, sourceDominant, context );
        mergeConfigurationContainer_Configuration( target, source, sourceDominant, context );
    }
5912#protected void mergeConfigurationContainer_Inherited( ConfigurationContainer target, ConfigurationContainer source,
                                                          boolean sourceDominant, Map<Object, Object> context )
    {
        String src = source.getInherited();
        if ( src != null )
        {
            if ( sourceDominant || target.getInherited() == null )
            {
                target.setInherited( src );
                target.setLocation( "inherited", source.getLocation( "inherited" ) );
            }
        }
    }
5913#protected void mergeConfigurationContainer_Configuration( ConfigurationContainer target,
                                                              ConfigurationContainer source, boolean sourceDominant,
                                                              Map<Object, Object> context )
    {
        Xpp3Dom src = (Xpp3Dom) source.getConfiguration();
        if ( src != null )
        {
            Xpp3Dom tgt = (Xpp3Dom) target.getConfiguration();
            if ( sourceDominant || tgt == null )
            {
                tgt = Xpp3Dom.mergeXpp3Dom( new Xpp3Dom( src ), tgt );
            }
            else
            {
                tgt = Xpp3Dom.mergeXpp3Dom( tgt, src );
            }
            target.setConfiguration( tgt );
        }
    }
5914#protected void mergePluginExecution( PluginExecution target, PluginExecution source, boolean sourceDominant,
                                         Map<Object, Object> context )
    {
        mergeConfigurationContainer( target, source, sourceDominant, context );
        mergePluginExecution_Id( target, source, sourceDominant, context );
        mergePluginExecution_Phase( target, source, sourceDominant, context );
        mergePluginExecution_Goals( target, source, sourceDominant, context );
    }
5915#protected void mergePluginExecution_Id( PluginExecution target, PluginExecution source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        String src = source.getId();
        if ( src != null )
        {
            if ( sourceDominant || target.getId() == null )
            {
                target.setId( src );
                target.setLocation( "id", source.getLocation( "id" ) );
            }
        }
    }
5916#protected void mergePluginExecution_Phase( PluginExecution target, PluginExecution source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        String src = source.getPhase();
        if ( src != null )
        {
            if ( sourceDominant || target.getPhase() == null )
            {
                target.setPhase( src );
                target.setLocation( "phase", source.getLocation( "phase" ) );
            }
        }
    }
5917#protected void mergePluginExecution_Goals( PluginExecution target, PluginExecution source, boolean sourceDominant,
                                               Map<Object, Object> context )
    {
        List<String> src = source.getGoals();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getGoals();
            List<String> merged = new ArrayList<String>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setGoals( merged );
        }
    }
5918#protected void mergeResource( Resource target, Resource source, boolean sourceDominant,
                                  Map<Object, Object> context )
    {
        mergeFileSet( target, source, sourceDominant, context );
        mergeResource_TargetPath( target, source, sourceDominant, context );
        mergeResource_Filtering( target, source, sourceDominant, context );
        mergeResource_MergeId( target, source, sourceDominant, context );
    }
5919#protected void mergeResource_TargetPath( Resource target, Resource source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        String src = source.getTargetPath();
        if ( src != null )
        {
            if ( sourceDominant || target.getTargetPath() == null )
            {
                target.setTargetPath( src );
                target.setLocation( "targetPath", source.getLocation( "targetPath" ) );
            }
        }
    }
5920#protected void mergeResource_Filtering( Resource target, Resource source, boolean sourceDominant,
                                            Map<Object, Object> context )
    {
        String src = source.getFiltering();
        if ( src != null )
        {
            if ( sourceDominant || target.getFiltering() == null )
            {
                target.setFiltering( src );
                target.setLocation( "filtering", source.getLocation( "filtering" ) );
            }
        }
    }
5921#protected void mergeResource_MergeId( Resource target, Resource source, boolean sourceDominant,
                                          Map<Object, Object> context )
    {
        String src = source.getMergeId();
        if ( src != null )
        {
            if ( sourceDominant || target.getMergeId() == null )
            {
                target.setMergeId( src );
            }
        }
    }
5922#protected void mergeFileSet( FileSet target, FileSet source, boolean sourceDominant, Map<Object, Object> context )
    {
        mergePatternSet( target, source, sourceDominant, context );
        mergeFileSet_Directory( target, source, sourceDominant, context );
    }
5923#protected void mergeFileSet_Directory( FileSet target, FileSet source, boolean sourceDominant,
                                           Map<Object, Object> context )
    {
        String src = source.getDirectory();
        if ( src != null )
        {
            if ( sourceDominant || target.getDirectory() == null )
            {
                target.setDirectory( src );
                target.setLocation( "directory", source.getLocation( "directory" ) );
            }
        }
    }
5924#protected void mergePatternSet( PatternSet target, PatternSet source, boolean sourceDominant,
                                    Map<Object, Object> context )
    {
        mergePatternSet_Includes( target, source, sourceDominant, context );
        mergePatternSet_Excludes( target, source, sourceDominant, context );
    }
5925#protected void mergePatternSet_Includes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getIncludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getIncludes();
            List<String> merged = new ArrayList<String>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setIncludes( merged );
        }
    }
5926#protected void mergePatternSet_Excludes( PatternSet target, PatternSet source, boolean sourceDominant,
                                             Map<Object, Object> context )
    {
        List<String> src = source.getExcludes();
        if ( !src.isEmpty() )
        {
            List<String> tgt = target.getExcludes();
            List<String> merged = new ArrayList<String>( tgt.size() + src.size() );
            merged.addAll( tgt );
            merged.addAll( src );
            target.setExcludes( merged );
        }
    }
5927#protected void mergeProfile( Profile target, Profile source, boolean sourceDominant, Map<Object, Object> context )
    {
        mergeModelBase( target, source, sourceDominant, context );
        // TODO
    }
5928#protected void mergeActivation( Activation target, Activation source, boolean sourceDominant,
                                    Map<Object, Object> context )
    {
        // TODO
    }
5929#protected Object getDependencyKey( Dependency dependency )
    {
        return dependency;
    }
5930#protected Object getPluginKey( Plugin object )
    {
        return object;
    }
5931#protected Object getPluginExecutionKey( PluginExecution object )
    {
        return object;
    }
5932#protected Object getReportPluginKey( ReportPlugin object )
    {
        return object;
    }
5933#protected Object getReportSetKey( ReportSet object )
    {
        return object;
    }
5934#protected Object getLicenseKey( License object )
    {
        return object;
    }
5935#protected Object getMailingListKey( MailingList object )
    {
        return object;
    }
5936#protected Object getDeveloperKey( Developer object )
    {
        return object;
    }
5937#protected Object getContributorKey( Contributor object )
    {
        return object;
    }
5938#protected Object getProfileKey( Profile object )
    {
        return object;
    }
5939#protected Object getRepositoryKey( Repository object )
    {
        return getRepositoryBaseKey( object );
    }
5940#protected Object getRepositoryBaseKey( RepositoryBase object )
    {
        return object;
    }
5941#protected Object getNotifierKey( Notifier object )
    {
        return object;
    }
5942#protected Object getResourceKey( Resource object )
    {
        return object;
    }
5943#protected Object getExtensionKey( Extension object )
    {
        return object;
    }
5944#protected Object getExclusionKey( Exclusion object )
    {
        return object;
    }
5945#public void testHashCodeNullSafe()
    {
        new RepositoryPolicy().hashCode();
    }
5946#public void testEqualsNullSafe()
    {
        assertFalse( new RepositoryPolicy().equals( null ) );

        new RepositoryPolicy().equals( new RepositoryPolicy() );
    }
5947#public void testEqualsIdentity()
    {
        RepositoryPolicy thing = new RepositoryPolicy();
        assertTrue( thing.equals( thing ) );
    }
5948#public void testToStringNullSafe()
    {
        assertNotNull( new RepositoryPolicy().toString() );
    }
5949#public void testHashCodeNullSafe()
    {
        new ActivationOS().hashCode();
    }
5950#public void testEqualsNullSafe()
    {
        assertFalse( new ActivationOS().equals( null ) );

        new ActivationOS().equals( new ActivationOS() );
    }
5951#public void testEqualsIdentity()
    {
        ActivationOS thing = new ActivationOS();
        assertTrue( thing.equals( thing ) );
    }
5952#public void testToStringNullSafe()
    {
        assertNotNull( new ActivationOS().toString() );
    }
5953#public void testHashCodeNullSafe()
    {
        new ActivationFile().hashCode();
    }
5954#public void testEqualsNullSafe()
    {
        assertFalse( new ActivationFile().equals( null ) );

        new ActivationFile().equals( new ActivationFile() );
    }
5955#public void testEqualsIdentity()
    {
        ActivationFile thing = new ActivationFile();
        assertTrue( thing.equals( thing ) );
    }
5956#public void testToStringNullSafe()
    {
        assertNotNull( new ActivationFile().toString() );
    }
5957#public void testHashCodeNullSafe()
    {
        new Repository().hashCode();
    }
5958#public void testEqualsNullSafe()
    {
        assertFalse( new Repository().equals( null ) );

        new Repository().equals( new Repository() );
    }
5959#public void testEqualsIdentity()
    {
        Repository thing = new Repository();
        assertTrue( thing.equals( thing ) );
    }
5960#public void testToStringNullSafe()
    {
        assertNotNull( new Repository().toString() );
    }
5961#public void testHashCodeNullSafe()
    {
        new License().hashCode();
    }
5962#public void testEqualsNullSafe()
    {
        assertFalse( new License().equals( null ) );

        new License().equals( new License() );
    }
5963#public void testEqualsIdentity()
    {
        License thing = new License();
        assertTrue( thing.equals( thing ) );
    }
5964#public void testToStringNullSafe()
    {
        assertNotNull( new License().toString() );
    }
5965#public void testHashCodeNullSafe()
    {
        new ActivationProperty().hashCode();
    }
5966#public void testEqualsNullSafe()
    {
        assertFalse( new ActivationProperty().equals( null ) );

        new ActivationProperty().equals( new ActivationProperty() );
    }
5967#public void testEqualsIdentity()
    {
        ActivationProperty thing = new ActivationProperty();
        assertTrue( thing.equals( thing ) );
    }
5968#public void testToStringNullSafe()
    {
        assertNotNull( new ActivationProperty().toString() );
    }
5969#public void testHashCodeNullSafe()
    {
        new Site().hashCode();
    }
5970#public void testEqualsNullSafe()
    {
        assertFalse( new Site().equals( null ) );

        new Site().equals( new Site() );
    }
5971#public void testEqualsIdentity()
    {
        Site thing = new Site();
        assertTrue( thing.equals( thing ) );
    }
5972#public void testToStringNullSafe()
    {
        assertNotNull( new Site().toString() );
    }
5973#public void testHashCodeNullSafe()
    {
        new Scm().hashCode();
    }
5974#public void testEqualsNullSafe()
    {
        assertFalse( new Scm().equals( null ) );

        new Scm().equals( new Scm() );
    }
5975#public void testEqualsIdentity()
    {
        Scm thing = new Scm();
        assertTrue( thing.equals( thing ) );
    }
5976#public void testToStringNullSafe()
    {
        assertNotNull( new Scm().toString() );
    }
5977#public void testHashCodeNullSafe()
    {
        new Resource().hashCode();
    }
5978#public void testEqualsNullSafe()
    {
        assertFalse( new Resource().equals( null ) );

        new Resource().equals( new Resource() );
    }
5979#public void testEqualsIdentity()
    {
        Resource thing = new Resource();
        assertTrue( thing.equals( thing ) );
    }
5980#public void testToStringNullSafe()
    {
        assertNotNull( new Resource().toString() );
    }
5981#public void testHashCodeNullSafe()
    {
        new Plugin().hashCode();
    }
5982#public void testEqualsNullSafe()
    {
        assertFalse( new Plugin().equals( null ) );

        new Plugin().equals( new Plugin() );
    }
5983#public void testEqualsIdentity()
    {
        Plugin thing = new Plugin();
        assertTrue( thing.equals( thing ) );
    }
5984#public void testToStringNullSafe()
    {
        assertNotNull( new Plugin().toString() );
    }
5985#public void testHashCodeNullSafe()
    {
        new PluginConfiguration().hashCode();
    }
5986#public void testEqualsNullSafe()
    {
        assertFalse( new PluginConfiguration().equals( null ) );

        new PluginConfiguration().equals( new PluginConfiguration() );
    }
5987#public void testEqualsIdentity()
    {
        PluginConfiguration thing = new PluginConfiguration();
        assertTrue( thing.equals( thing ) );
    }
5988#public void testToStringNullSafe()
    {
        assertNotNull( new PluginConfiguration().toString() );
    }
5989#public void testHashCodeNullSafe()
    {
        new Prerequisites().hashCode();
    }
5990#public void testEqualsNullSafe()
    {
        assertFalse( new Prerequisites().equals( null ) );

        new Prerequisites().equals( new Prerequisites() );
    }
5991#public void testEqualsIdentity()
    {
        Prerequisites thing = new Prerequisites();
        assertTrue( thing.equals( thing ) );
    }
5992#public void testToStringNullSafe()
    {
        assertNotNull( new Prerequisites().toString() );
    }
5993#public void testHashCodeNullSafe()
    {
        new Reporting().hashCode();
    }
5994#public void testEqualsNullSafe()
    {
        assertFalse( new Reporting().equals( null ) );

        new Reporting().equals( new Reporting() );
    }
5995#public void testEqualsIdentity()
    {
        Reporting thing = new Reporting();
        assertTrue( thing.equals( thing ) );
    }
5996#public void testToStringNullSafe()
    {
        assertNotNull( new Reporting().toString() );
    }
5997#public void testHashCodeNullSafe()
    {
        new ReportPlugin().hashCode();
    }
5998#public void testEqualsNullSafe()
    {
        assertFalse( new ReportPlugin().equals( null ) );

        new ReportPlugin().equals( new ReportPlugin() );
    }
5999#public void testEqualsIdentity()
    {
        ReportPlugin thing = new ReportPlugin();
        assertTrue( thing.equals( thing ) );
    }
6000#public void testToStringNullSafe()
    {
        assertNotNull( new ReportPlugin().toString() );
    }
6001#public void testHashCodeNullSafe()
    {
        new Notifier().hashCode();
    }
6002#public void testEqualsNullSafe()
    {
        assertFalse( new Notifier().equals( null ) );

        new Notifier().equals( new Notifier() );
    }
6003#public void testEqualsIdentity()
    {
        Notifier thing = new Notifier();
        assertTrue( thing.equals( thing ) );
    }
6004#public void testToStringNullSafe()
    {
        assertNotNull( new Notifier().toString() );
    }
6005#public void testHashCodeNullSafe()
    {
        new MailingList().hashCode();
    }
6006#public void testEqualsNullSafe()
    {
        assertFalse( new MailingList().equals( null ) );

        new MailingList().equals( new MailingList() );
    }
6007#public void testEqualsIdentity()
    {
        MailingList thing = new MailingList();
        assertTrue( thing.equals( thing ) );
    }
6008#public void testToStringNullSafe()
    {
        assertNotNull( new MailingList().toString() );
    }
6009#public void testHashCodeNullSafe()
    {
        new Parent().hashCode();
    }
6010#public void testEqualsNullSafe()
    {
        assertFalse( new Parent().equals( null ) );

        new Parent().equals( new Parent() );
    }
6011#public void testEqualsIdentity()
    {
        Parent thing = new Parent();
        assertTrue( thing.equals( thing ) );
    }
6012#public void testToStringNullSafe()
    {
        assertNotNull( new Parent().toString() );
    }
6013#public void testHashCodeNullSafe()
    {
        new Relocation().hashCode();
    }
6014#public void testEqualsNullSafe()
    {
        assertFalse( new Relocation().equals( null ) );

        new Relocation().equals( new Relocation() );
    }
6015#public void testEqualsIdentity()
    {
        Relocation thing = new Relocation();
        assertTrue( thing.equals( thing ) );
    }
6016#public void testToStringNullSafe()
    {
        assertNotNull( new Relocation().toString() );
    }
6017#public void testHashCodeNullSafe()
    {
        new PluginManagement().hashCode();
    }
6018#public void testEqualsNullSafe()
    {
        assertFalse( new PluginManagement().equals( null ) );

        new PluginManagement().equals( new PluginManagement() );
    }
6019#public void testEqualsIdentity()
    {
        PluginManagement thing = new PluginManagement();
        assertTrue( thing.equals( thing ) );
    }
6020#public void testToStringNullSafe()
    {
        assertNotNull( new PluginManagement().toString() );
    }
6021#public void testHashCodeNullSafe()
    {
        new Build().hashCode();
    }
6022#public void testEqualsNullSafe()
    {
        assertFalse( new Build().equals( null ) );

        new Build().equals( new Build() );
    }
6023#public void testEqualsIdentity()
    {
        Build thing = new Build();
        assertTrue( thing.equals( thing ) );
    }
6024#public void testToStringNullSafe()
    {
        assertNotNull( new Build().toString() );
    }
6025#public void testHashCodeNullSafe()
    {
        new DeploymentRepository().hashCode();
    }
6026#public void testEqualsNullSafe()
    {
        assertFalse( new DeploymentRepository().equals( null ) );

        new DeploymentRepository().equals( new DeploymentRepository() );
    }
6027#public void testEqualsIdentity()
    {
        DeploymentRepository thing = new DeploymentRepository();
        assertTrue( thing.equals( thing ) );
    }
6028#public void testToStringNullSafe()
    {
        assertNotNull( new DeploymentRepository().toString() );
    }
6029#public void testHashCodeNullSafe()
    {
        new Contributor().hashCode();
    }
6030#public void testEqualsNullSafe()
    {
        assertFalse( new Contributor().equals( null ) );

        new Contributor().equals( new Contributor() );
    }
6031#public void testEqualsIdentity()
    {
        Contributor thing = new Contributor();
        assertTrue( thing.equals( thing ) );
    }
6032#public void testToStringNullSafe()
    {
        assertNotNull( new Contributor().toString() );
    }
6033#public void testHashCodeNullSafe()
    {
        new Activation().hashCode();
    }
6034#public void testEqualsNullSafe()
    {
        assertFalse( new Activation().equals( null ) );

        new Activation().equals( new Activation() );
    }
6035#public void testEqualsIdentity()
    {
        Activation thing = new Activation();
        assertTrue( thing.equals( thing ) );
    }
6036#public void testToStringNullSafe()
    {
        assertNotNull( new Activation().toString() );
    }
6037#public void testHashCodeNullSafe()
    {
        new DistributionManagement().hashCode();
    }
6038#public void testEqualsNullSafe()
    {
        assertFalse( new DistributionManagement().equals( null ) );

        new DistributionManagement().equals( new DistributionManagement() );
    }
6039#public void testEqualsIdentity()
    {
        DistributionManagement thing = new DistributionManagement();
        assertTrue( thing.equals( thing ) );
    }
6040#public void testToStringNullSafe()
    {
        assertNotNull( new DistributionManagement().toString() );
    }
6041#public void testHashCodeNullSafe()
    {
        new DependencyManagement().hashCode();
    }
6042#public void testEqualsNullSafe()
    {
        assertFalse( new DependencyManagement().equals( null ) );

        new DependencyManagement().equals( new DependencyManagement() );
    }
6043#public void testEqualsIdentity()
    {
        DependencyManagement thing = new DependencyManagement();
        assertTrue( thing.equals( thing ) );
    }
6044#public void testToStringNullSafe()
    {
        assertNotNull( new DependencyManagement().toString() );
    }
6045#public void testHashCodeNullSafe()
    {
        new ReportSet().hashCode();
    }
6046#public void testEqualsNullSafe()
    {
        assertFalse( new ReportSet().equals( null ) );

        new ReportSet().equals( new ReportSet() );
    }
6047#public void testEqualsIdentity()
    {
        ReportSet thing = new ReportSet();
        assertTrue( thing.equals( thing ) );
    }
6048#public void testToStringNullSafe()
    {
        assertNotNull( new ReportSet().toString() );
    }
6049#public void testHashCodeNullSafe()
    {
        new Exclusion().hashCode();
    }
6050#public void testEqualsNullSafe()
    {
        assertFalse( new Exclusion().equals( null ) );

        new Exclusion().equals( new Exclusion() );
    }
6051#public void testEqualsIdentity()
    {
        Exclusion thing = new Exclusion();
        assertTrue( thing.equals( thing ) );
    }
6052#public void testToStringNullSafe()
    {
        assertNotNull( new Exclusion().toString() );
    }
6053#public void testHashCodeNullSafe()
    {
        new Model().hashCode();
    }
6054#public void testEqualsNullSafe()
    {
        assertFalse( new Model().equals( null ) );

        new Model().equals( new Model() );
    }
6055#public void testEqualsIdentity()
    {
        Model thing = new Model();
        assertTrue( thing.equals( thing ) );
    }
6056#public void testToStringNullSafe()
    {
        assertNotNull( new Model().toString() );
    }
6057#public void testHashCodeNullSafe()
    {
        new Developer().hashCode();
    }
6058#public void testEqualsNullSafe()
    {
        assertFalse( new Developer().equals( null ) );

        new Developer().equals( new Developer() );
    }
6059#public void testEqualsIdentity()
    {
        Developer thing = new Developer();
        assertTrue( thing.equals( thing ) );
    }
6060#public void testToStringNullSafe()
    {
        assertNotNull( new Developer().toString() );
    }
6061#public void testHashCodeNullSafe()
    {
        new PluginContainer().hashCode();
    }
6062#public void testEqualsNullSafe()
    {
        assertFalse( new PluginContainer().equals( null ) );

        new PluginContainer().equals( new PluginContainer() );
    }
6063#public void testEqualsIdentity()
    {
        PluginContainer thing = new PluginContainer();
        assertTrue( thing.equals( thing ) );
    }
6064#public void testToStringNullSafe()
    {
        assertNotNull( new PluginContainer().toString() );
    }
6065#public void testHashCodeNullSafe()
    {
        new Profile().hashCode();
    }
6066#public void testEqualsNullSafe()
    {
        assertFalse( new Profile().equals( null ) );

        new Profile().equals( new Profile() );
    }
6067#public void testEqualsIdentity()
    {
        Profile thing = new Profile();
        assertTrue( thing.equals( thing ) );
    }
6068#public void testToStringNullSafe()
    {
        assertNotNull( new Profile().toString() );
    }
6069#public void testHashCodeNullSafe()
    {
        new IssueManagement().hashCode();
    }
6070#public void testEqualsNullSafe()
    {
        assertFalse( new IssueManagement().equals( null ) );

        new IssueManagement().equals( new IssueManagement() );
    }
6071#public void testEqualsIdentity()
    {
        IssueManagement thing = new IssueManagement();
        assertTrue( thing.equals( thing ) );
    }
6072#public void testToStringNullSafe()
    {
        assertNotNull( new IssueManagement().toString() );
    }
6073#public void testHashCodeNullSafe()
    {
        new PluginExecution().hashCode();
    }
6074#public void testEqualsNullSafe()
    {
        assertFalse( new PluginExecution().equals( null ) );

        new PluginExecution().equals( new PluginExecution() );
    }
6075#public void testEqualsIdentity()
    {
        PluginExecution thing = new PluginExecution();
        assertTrue( thing.equals( thing ) );
    }
6076#public void testToStringNullSafe()
    {
        assertNotNull( new PluginExecution().toString() );
    }
6077#public void testHashCodeNullSafe()
    {
        new Dependency().hashCode();
    }
6078#public void testEqualsNullSafe()
    {
        assertFalse( new Dependency().equals( null ) );

        new Dependency().equals( new Dependency() );
    }
6079#public void testEqualsIdentity()
    {
        Dependency thing = new Dependency();
        assertTrue( thing.equals( thing ) );
    }
6080#public void testToStringNullSafe()
    {
        assertNotNull( new Dependency().toString() );
    }
6081#public void testHashCodeNullSafe()
    {
        new CiManagement().hashCode();
    }
6082#public void testEqualsNullSafe()
    {
        assertFalse( new CiManagement().equals( null ) );

        new CiManagement().equals( new CiManagement() );
    }
6083#public void testEqualsIdentity()
    {
        CiManagement thing = new CiManagement();
        assertTrue( thing.equals( thing ) );
    }
6084#public void testToStringNullSafe()
    {
        assertNotNull( new CiManagement().toString() );
    }
6085#public void testHashCodeNullSafe()
    {
        new Extension().hashCode();
    }
6086#public void testEqualsNullSafe()
    {
        assertFalse( new Extension().equals( null ) );

        new Extension().equals( new Extension() );
    }
6087#public void testEqualsIdentity()
    {
        Extension thing = new Extension();
        assertTrue( thing.equals( thing ) );
    }
6088#public void testToStringNullSafe()
    {
        assertNotNull( new Extension().toString() );
    }
6089#public void testHashCodeNullSafe()
    {
        new Organization().hashCode();
    }
6090#public void testEqualsNullSafe()
    {
        assertFalse( new Organization().equals( null ) );

        new Organization().equals( new Organization() );
    }
6091#public void testEqualsIdentity()
    {
        Organization thing = new Organization();
        assertTrue( thing.equals( thing ) );
    }
6092#public void testToStringNullSafe()
    {
        assertNotNull( new Organization().toString() );
    }
6093#public DefaultLog( Logger logger )
    {
        this.logger = logger;
    }
6094#public void debug( CharSequence content )
    {
        logger.debug( toString( content ) );
    }
6095#private String toString( CharSequence content )
    {
        if ( content == null )
        {
            return "";
        }
        else
        {
            return content.toString();
        }
    }
6096#public void debug( CharSequence content, Throwable error )
    {
        logger.debug( toString( content ), error );
    }
6097#public void debug( Throwable error )
    {
        logger.debug( "", error );
    }
6098#public void info( CharSequence content )
    {
        logger.info( toString( content ) );
    }
6099#public void info( CharSequence content, Throwable error )
    {
        logger.info( toString( content ), error );
    }
6100#public void info( Throwable error )
    {
        logger.info( "", error );
    }
6101#public void warn( CharSequence content )
    {
        logger.warn( toString( content ) );
    }
6102#public void warn( CharSequence content, Throwable error )
    {
        logger.warn( toString( content ), error );
    }
6103#public void warn( Throwable error )
    {
        logger.warn( "", error );
    }
6104#public void error( CharSequence content )
    {
        logger.error( toString( content ) );
    }
6105#public void error( CharSequence content, Throwable error )
    {
        logger.error( toString( content ), error );
    }
6106#public void error( Throwable error )
    {
        logger.error( "", error );
    }
6107#public boolean isDebugEnabled()
    {
        return logger.isDebugEnabled();
    }
6108#public boolean isInfoEnabled()
    {
        return logger.isInfoEnabled();
    }
6109#public boolean isWarnEnabled()
    {
        return logger.isWarnEnabled();
    }
6110#public boolean isErrorEnabled()
    {
        return logger.isErrorEnabled();
    }
6111#/**
     * Set a new shared context <code>Map</code> to a mojo before executing it.
     *
     * @param pluginContext a new <code>Map</code>
     */
    void setPluginContext( Map pluginContext );
6112#/**
     * @return a <code>Map</code> stored in the plugin container's context.
     */
    Map getPluginContext();
6113#public MojoNotFoundException( String goal, PluginDescriptor pluginDescriptor )
    {
        super( toMessage( goal, pluginDescriptor ) );

        this.goal = goal;
        this.pluginDescriptor = pluginDescriptor;
    }
6114#public String getGoal()
    {
        return goal;
    }
6115#public PluginDescriptor getPluginDescriptor()
    {
        return pluginDescriptor;
    }
6116#private static String toMessage( String goal, PluginDescriptor pluginDescriptor )
    {
        StringBuilder buffer = new StringBuilder( 256 );

        buffer.append( "Could not find goal '" ).append( goal ).append( "'" );

        if ( pluginDescriptor != null )
        {
            buffer.append( " in plugin " ).append( pluginDescriptor.getId() );

            buffer.append( " among available goals " );
            List<MojoDescriptor> mojos = pluginDescriptor.getMojos();
            if ( mojos != null )
            {
                for ( Iterator<MojoDescriptor> it = mojos.iterator(); it.hasNext(); )
                {
                    MojoDescriptor mojo = it.next();
                    if ( mojo != null )
                    {
                        buffer.append( mojo.getGoal() );
                    }
                    if ( it.hasNext() )
                    {
                        buffer.append( ", " );
                    }
                }
            }
        }

        return buffer.toString();
    }
6117#/**
     * Construct a new <code>MojoExecutionException</code> exception providing the source and a short and long message:
     * these messages are used to improve the message written at the end of Maven build.
     *
     * @param source
     * @param shortMessage
     * @param longMessage
     */
    public MojoExecutionException( Object source, String shortMessage, String longMessage )
    {
        super( shortMessage );
        this.source = source;
        this.longMessage = longMessage;
    }
6118#/**
     * Construct a new <code>MojoExecutionException</code> exception wrapping an underlying <code>Exception</code>
     * and providing a <code>message</code>.
     *
     * @param message
     * @param cause
     */
    public MojoExecutionException( String message, Exception cause )
    {
        super( message, cause );
    }
6119#/**
     * Construct a new <code>MojoExecutionException</code> exception wrapping an underlying <code>Throwable</code>
     * and providing a <code>message</code>.
     *
     * @param message
     * @param cause
     */
    public MojoExecutionException( String message, Throwable cause )
    {
        super( message, cause );
    }
6120#/**
     * Construct a new <code>MojoExecutionException</code> exception providing a <code>message</code>.
     *
     * @param message
     */
    public MojoExecutionException( String message )
    {
        super( message );
    }
6121#public AbstractMojoExecutionException( String message )
    {
        super( message );
    }
6122#public AbstractMojoExecutionException( String message, Throwable cause )
    {
        super( message, cause );
    }
6123#public String getLongMessage()
    {
        return longMessage;
    }
6124#public Object getSource()
    {
        return source;
    }
6125#/**
     * @see org.apache.maven.plugin.Mojo#setLog(org.apache.maven.plugin.logging.Log)
     */
    public void setLog( Log log )
    {
        this.log = log;
    }
6126#/**
     * Returns the logger that has been injected into this mojo. If no logger has been setup yet, a
     * <code>SystemStreamLog</code> logger will be created and returned.
     * <br/><br/>
     * <strong>Note:</strong>
     * The logger returned by this method must not be cached in an instance field during the construction of the mojo.
     * This would cause the mojo to use a wrongly configured default logger when being run by Maven. The proper logger
     * gets injected by the Plexus container <em>after</em> the mojo has been constructed. Therefore, simply call this
     * method directly whenever you need the logger, it is fast enough and needs no caching.
     *
     * @see org.apache.maven.plugin.Mojo#getLog()
     */
    public Log getLog()
    {
        if ( log == null )
        {
            log = new SystemStreamLog();
        }

        return log;
    }
6127#/**
     * @see org.apache.maven.plugin.ContextEnabled#getPluginContext()
     */
    public Map getPluginContext()
    {
        return pluginContext;
    }
6128#/**
     * @see org.apache.maven.plugin.ContextEnabled#setPluginContext(java.util.Map)
     */
    public void setPluginContext( Map pluginContext )
    {
        this.pluginContext = pluginContext;
    }
6129#/**
     * Construct a new <code>MojoFailureException</code> exception providing the source and a short and long message:
     * these messages are used to improve the message written at the end of Maven build.
     *
     * @param source
     * @param shortMessage
     * @param longMessage
     */
    public MojoFailureException( Object source, String shortMessage, String longMessage )
    {
        super( shortMessage );
        this.source = source;
        this.longMessage = longMessage;
    }
6130#/**
     * Construct a new <code>MojoFailureException</code> exception providing a message.
     *
     * @param message
     */
    public MojoFailureException( String message )
    {
        super( message );
    }
6131#/**
     * Construct a new <code>MojoFailureException</code> exception wrapping an underlying <code>Throwable</code>
     * and providing a <code>message</code>.
     *
     * @param message
     * @param cause
     * @since 2.0.9
     */
    public MojoFailureException( String message, Throwable cause )
    {
        super( message, cause );
    }
6132#/**
     * Perform whatever build-process behavior this <code>Mojo</code> implements.
     * <br/>
     * This is the main trigger for the <code>Mojo</code> inside the <code>Maven</code> system, and allows
     * the <code>Mojo</code> to communicate errors.
     *
     * @throws MojoExecutionException if an unexpected problem occurs.
     * Throwing this exception causes a "BUILD ERROR" message to be displayed.
     * @throws MojoFailureException if an expected problem (such as a compilation failure) occurs.
     * Throwing this exception causes a "BUILD FAILURE" message to be displayed.
     */
    void execute()
        throws MojoExecutionException, MojoFailureException;
6133#/**
     * Inject a standard <code>Maven</code> logging mechanism to allow this <code>Mojo</code> to communicate events
     * and feedback to the user.
     *
     * @param log a new logger
     */
    // TODO: not sure about this here, and may want a getLog on here as well/instead
    void setLog( Log log );
6134#/**
     * Furnish access to the standard Maven logging mechanism which is managed in this base class.
     *
     * @return a log4j-like logger object which allows plugins to create messages at levels of <code>"debug"</code>,
     * <code>"info"</code>, <code>"warn"</code>, and <code>"error"</code>. This logger is the accepted means to display
     * information to the user.
     */
    Log getLog();
6135#public InvalidParameterException( String element, int i )
    {
        super( "The " + element + " element in parameter # " + i + " is invalid. It cannot be null." );
    }
6136#public InvalidParameterException( String message, Throwable cause )
    {
        super( message, cause );
    }
6137#public PluginDescriptor build( Reader reader )
        throws PlexusConfigurationException
    {
        return build( reader, null );
    }
6138#public PluginDescriptor build( Reader reader, String source )
        throws PlexusConfigurationException
    {
        PlexusConfiguration c = buildConfiguration( reader );

        PluginDescriptor pluginDescriptor = new PluginDescriptor();

        pluginDescriptor.setSource( source );
        pluginDescriptor.setGroupId( c.getChild( "groupId" ).getValue() );
        pluginDescriptor.setArtifactId( c.getChild( "artifactId" ).getValue() );
        pluginDescriptor.setVersion( c.getChild( "version" ).getValue() );
        pluginDescriptor.setGoalPrefix( c.getChild( "goalPrefix" ).getValue() );

        pluginDescriptor.setName( c.getChild( "name" ).getValue() );
        pluginDescriptor.setDescription( c.getChild( "description" ).getValue() );

        String isolatedRealm = c.getChild( "isolatedRealm" ).getValue();

        if ( isolatedRealm != null )
        {
            pluginDescriptor.setIsolatedRealm( Boolean.parseBoolean( isolatedRealm ) );
        }

        String inheritedByDefault = c.getChild( "inheritedByDefault" ).getValue();

        if ( inheritedByDefault != null )
        {
            pluginDescriptor.setInheritedByDefault( Boolean.parseBoolean( inheritedByDefault ) );
        }

        // ----------------------------------------------------------------------
        // Components
        // ----------------------------------------------------------------------

        PlexusConfiguration[] mojoConfigurations = c.getChild( "mojos" ).getChildren( "mojo" );

        for ( PlexusConfiguration component : mojoConfigurations )
        {
            MojoDescriptor mojoDescriptor = buildComponentDescriptor( component, pluginDescriptor );

            pluginDescriptor.addMojo( mojoDescriptor );
        }

        // ----------------------------------------------------------------------
        // Dependencies
        // ----------------------------------------------------------------------

        PlexusConfiguration[] dependencyConfigurations = c.getChild( "dependencies" ).getChildren( "dependency" );

        List<ComponentDependency> dependencies = new ArrayList<ComponentDependency>();

        for ( PlexusConfiguration d : dependencyConfigurations )
        {
            ComponentDependency cd = new ComponentDependency();

            cd.setArtifactId( d.getChild( "artifactId" ).getValue() );

            cd.setGroupId( d.getChild( "groupId" ).getValue() );

            cd.setType( d.getChild( "type" ).getValue() );

            cd.setVersion( d.getChild( "version" ).getValue() );

            dependencies.add( cd );
        }

        pluginDescriptor.setDependencies( dependencies );

        return pluginDescriptor;
    }
6139#public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDescriptor pluginDescriptor )
        throws PlexusConfigurationException
    {
        MojoDescriptor mojo = new MojoDescriptor();
        mojo.setPluginDescriptor( pluginDescriptor );

        mojo.setGoal( c.getChild( "goal" ).getValue() );

        mojo.setImplementation( c.getChild( "implementation" ).getValue() );

        PlexusConfiguration langConfig = c.getChild( "language" );

        if ( langConfig != null )
        {
            mojo.setLanguage( langConfig.getValue() );
        }

        PlexusConfiguration configuratorConfig = c.getChild( "configurator" );

        if ( configuratorConfig != null )
        {
            mojo.setComponentConfigurator( configuratorConfig.getValue() );
        }

        PlexusConfiguration composerConfig = c.getChild( "composer" );

        if ( composerConfig != null )
        {
            mojo.setComponentComposer( composerConfig.getValue() );
        }

        String since = c.getChild( "since" ).getValue();

        if ( since != null )
        {
            mojo.setSince( since );
        }

        PlexusConfiguration deprecated = c.getChild( "deprecated", false );

        if ( deprecated != null )
        {
            mojo.setDeprecated( deprecated.getValue() );
        }

        String phase = c.getChild( "phase" ).getValue();

        if ( phase != null )
        {
            mojo.setPhase( phase );
        }

        String executePhase = c.getChild( "executePhase" ).getValue();

        if ( executePhase != null )
        {
            mojo.setExecutePhase( executePhase );
        }

        String executeMojo = c.getChild( "executeGoal" ).getValue();

        if ( executeMojo != null )
        {
            mojo.setExecuteGoal( executeMojo );
        }

        String executeLifecycle = c.getChild( "executeLifecycle" ).getValue();

        if ( executeLifecycle != null )
        {
            mojo.setExecuteLifecycle( executeLifecycle );
        }

        mojo.setInstantiationStrategy( c.getChild( "instantiationStrategy" ).getValue() );

        mojo.setDescription( c.getChild( "description" ).getValue() );

        PlexusConfiguration dependencyResolution = c.getChild( "requiresDependencyResolution", false );

        if ( dependencyResolution != null )
        {
            mojo.setDependencyResolutionRequired( dependencyResolution.getValue() );
        }

        PlexusConfiguration dependencyCollection = c.getChild( "requiresDependencyCollection", false );

        if ( dependencyCollection != null )
        {
            mojo.setDependencyCollectionRequired( dependencyCollection.getValue() );
        }

        String directInvocationOnly = c.getChild( "requiresDirectInvocation" ).getValue();

        if ( directInvocationOnly != null )
        {
            mojo.setDirectInvocationOnly( Boolean.parseBoolean( directInvocationOnly ) );
        }

        String requiresProject = c.getChild( "requiresProject" ).getValue();

        if ( requiresProject != null )
        {
            mojo.setProjectRequired( Boolean.parseBoolean( requiresProject ) );
        }

        String requiresReports = c.getChild( "requiresReports" ).getValue();

        if ( requiresReports != null )
        {
            mojo.setRequiresReports( Boolean.parseBoolean( requiresReports ) );
        }

        String aggregator = c.getChild( "aggregator" ).getValue();

        if ( aggregator != null )
        {
            mojo.setAggregator( Boolean.parseBoolean( aggregator ) );
        }

        String requiresOnline = c.getChild( "requiresOnline" ).getValue();

        if ( requiresOnline != null )
        {
            mojo.setOnlineRequired( Boolean.parseBoolean( requiresOnline ) );
        }

        String inheritedByDefault = c.getChild( "inheritedByDefault" ).getValue();

        if ( inheritedByDefault != null )
        {
            mojo.setInheritedByDefault( Boolean.parseBoolean( inheritedByDefault ) );
        }

        String threadSafe = c.getChild( "threadSafe" ).getValue();

        if ( threadSafe != null )
        {
            mojo.setThreadSafe( Boolean.parseBoolean( threadSafe ) );
        }

        // ----------------------------------------------------------------------
        // Configuration
        // ----------------------------------------------------------------------

        PlexusConfiguration mojoConfig = c.getChild( "configuration" );
        mojo.setMojoConfiguration( mojoConfig );

        // ----------------------------------------------------------------------
        // Parameters
        // ----------------------------------------------------------------------

        PlexusConfiguration[] parameterConfigurations = c.getChild( "parameters" ).getChildren( "parameter" );

        List<Parameter> parameters = new ArrayList<Parameter>();

        for ( PlexusConfiguration d : parameterConfigurations )
        {
            Parameter parameter = new Parameter();

            parameter.setName( d.getChild( "name" ).getValue() );

            parameter.setAlias( d.getChild( "alias" ).getValue() );

            parameter.setType( d.getChild( "type" ).getValue() );

            String required = d.getChild( "required" ).getValue();

            parameter.setRequired( Boolean.parseBoolean( required ) );

            PlexusConfiguration editableConfig = d.getChild( "editable" );

            // we need the null check for pre-build legacy plugins...
            if ( editableConfig != null )
            {
                String editable = d.getChild( "editable" ).getValue();

                parameter.setEditable( editable == null || Boolean.parseBoolean( editable ) );
            }

            parameter.setDescription( d.getChild( "description" ).getValue() );

            parameter.setDeprecated( d.getChild( "deprecated" ).getValue() );

            parameter.setImplementation( d.getChild( "implementation" ).getValue() );

            PlexusConfiguration paramConfig = mojoConfig.getChild( parameter.getName(), false );
            if ( paramConfig != null )
            {
                parameter.setExpression( paramConfig.getValue( null ) );
                parameter.setDefaultValue( paramConfig.getAttribute( "default-value" ) );
            }

            parameters.add( parameter );
        }

        mojo.setParameters( parameters );

        // TODO: this should not need to be handed off...

        // ----------------------------------------------------------------------
        // Requirements
        // ----------------------------------------------------------------------

        PlexusConfiguration[] requirements = c.getChild( "requirements" ).getChildren( "requirement" );

        for ( PlexusConfiguration requirement : requirements )
        {
            ComponentRequirement cr = new ComponentRequirement();

            cr.setRole( requirement.getChild( "role" ).getValue() );

            cr.setRoleHint( requirement.getChild( "role-hint" ).getValue() );

            cr.setFieldName( requirement.getChild( "field-name" ).getValue() );

            mojo.addRequirement( cr );
        }

        return mojo;
    }
6140#// ----------------------------------------------------------------------
    //
    // ----------------------------------------------------------------------

    public PlexusConfiguration buildConfiguration( Reader configuration )
        throws PlexusConfigurationException
    {
        try
        {
            return new XmlPlexusConfiguration( Xpp3DomBuilder.build( configuration ) );
        }
        catch ( IOException e )
        {
            throw new PlexusConfigurationException( e.getMessage(), e );
        }
        catch ( XmlPullParserException e )
        {
            throw new PlexusConfigurationException( e.getMessage(), e );
        }
    }
6141#public InvalidPluginDescriptorException( String message, Throwable cause )
    {
        super( message, cause );
    }
6142#public InvalidPluginDescriptorException( String message )
    {
        super( message );
    }
6143#public Requirement( String role )
    {
        this.role = role;
        this.roleHint = null;
    }
6144#public Requirement( String role, String roleHint )
    {
        this.role = role;
        this.roleHint = roleHint;
    }
6145#public String getRole()
    {
        return role;
    }
6146#public String getRoleHint()
    {
        return roleHint;
    }
6147#/**
     * Creates a shallow copy of this requirement.
     */
    @Override
    public Requirement clone()
    {
        try
        {
            return (Requirement) super.clone();
        }
        catch ( CloneNotSupportedException e )
        {
            throw new UnsupportedOperationException( e );
        }
    }
6148#// ----------------------------------------------------------------------
    //
    // ----------------------------------------------------------------------

    @SuppressWarnings( { "unchecked", "rawtypes" } )
    public List<MojoDescriptor> getMojos()
    {
        return (List) getComponents();
    }
6149#public void addMojo( MojoDescriptor mojoDescriptor )
        throws DuplicateMojoDescriptorException
    {
        MojoDescriptor existing = null;
        // this relies heavily on the equals() and hashCode() for ComponentDescriptor,
        // which uses role:roleHint for identity...and roleHint == goalPrefix:goal.
        // role does not vary for Mojos.
        List<MojoDescriptor> mojos = getMojos();

        if ( mojos != null && mojos.contains( mojoDescriptor ) )
        {
            int indexOf = mojos.indexOf( mojoDescriptor );

            existing = mojos.get( indexOf );
        }

        if ( existing != null )
        {
            throw new DuplicateMojoDescriptorException( getGoalPrefix(), mojoDescriptor.getGoal(), existing
                .getImplementation(), mojoDescriptor.getImplementation() );
        }
        else
        {
            addComponentDescriptor( mojoDescriptor );
        }
    }
6150#public String getGroupId()
    {
        return groupId;
    }
6151#public void setGroupId( String groupId )
    {
        this.groupId = groupId;
    }
6152#public String getArtifactId()
    {
        return artifactId;
    }
6153#public void setArtifactId( String artifactId )
    {
        this.artifactId = artifactId;
    }
6154#// ----------------------------------------------------------------------
    // Dependencies
    // ----------------------------------------------------------------------

    public static String constructPluginKey( String groupId, String artifactId, String version )
    {
        return groupId + ":" + artifactId + ":" + version;
    }
6155#public String getPluginLookupKey()
    {
        return groupId + ":" + artifactId;
    }
6156#public String getId()
    {
        return constructPluginKey( groupId, artifactId, version );
    }
6157#public static String getDefaultPluginArtifactId( String id )
    {
        return "maven-" + id + "-plugin";
    }
6158#public static String getDefaultPluginGroupId()
    {
        return "org.apache.maven.plugins";
    }
6159#/**
     * Parse maven-...-plugin.
     *
     * @todo move to plugin-tools-api as a default only
     */
    public static String getGoalPrefixFromArtifactId( String artifactId )
    {
        if ( "maven-plugin-plugin".equals( artifactId ) )
        {
            return "plugin";
        }
        else
        {
            return artifactId.replaceAll( "-?maven-?", "" ).replaceAll( "-?plugin-?", "" );
        }
    }
6160#public String getGoalPrefix()
    {
        return goalPrefix;
    }
6161#public void setGoalPrefix( String goalPrefix )
    {
        this.goalPrefix = goalPrefix;
    }
6162#public void setVersion( String version )
    {
        this.version = version;
    }
6163#public String getVersion()
    {
        return version;
    }
6164#public void setSource( String source )
    {
        this.source = source;
    }
6165#public String getSource()
    {
        return source;
    }
6166#public boolean isInheritedByDefault()
    {
        return inheritedByDefault;
    }
6167#public void setInheritedByDefault( boolean inheritedByDefault )
    {
        this.inheritedByDefault = inheritedByDefault;
    }
6168#/**
     * Gets the artifacts that make up the plugin's class realm, excluding artifacts shadowed by the Maven core realm
     * like {@code maven-project}.
     *
     * @return The plugin artifacts, never {@code null}.
     */
    public List<Artifact> getArtifacts()
    {
        return artifacts;
    }
6169#public void setArtifacts( List<Artifact> artifacts )
    {
        this.artifacts = artifacts;

        // clear the calculated artifactMap
        artifactMap = null;
    }
6170#public Map<String, Artifact> getArtifactMap()
    {
        if ( artifactMap == null )
        {
            artifactMap = ArtifactUtils.artifactMapByVersionlessId( getArtifacts() );
        }

        return artifactMap;
    }
6171#public boolean equals( Object object )
    {
        if ( this == object )
        {
            return true;
        }

        return getId().equals( ( (PluginDescriptor) object ).getId() );
    }
6172#public int hashCode()
    {
        return 10 + getId().hashCode();
    }
6173#public MojoDescriptor getMojo( String goal )
    {
        if ( getMojos() == null )
        {
            return null; // no mojo in this POM
        }

        // TODO: could we use a map? Maybe if the parent did that for components too, as this is too vulnerable to
        // changes above not being propagated to the map
        for ( MojoDescriptor desc : getMojos() )
        {
            if ( goal.equals( desc.getGoal() ) )
            {
                return desc;
            }
        }
        return null;
    }
6174#public void setClassRealm( ClassRealm classRealm )
    {
        this.classRealm = classRealm;
    }
6175#public ClassRealm getClassRealm()
    {
        return classRealm;
    }
6176#public void setIntroducedDependencyArtifacts( Set<Artifact> introducedDependencyArtifacts )
    {
        this.introducedDependencyArtifacts = introducedDependencyArtifacts;
    }
6177#public Set<Artifact> getIntroducedDependencyArtifacts()
    {
        return ( introducedDependencyArtifacts != null ) ? introducedDependencyArtifacts
                        : Collections.<Artifact> emptySet();
    }
6178#public void setName( String name )
    {
        this.name = name;
    }
6179#public String getName()
    {
        return name;
    }
6180#public void setDescription( String description )
    {
        this.description = description;
    }
6181#public String getDescription()
    {
        return description;
    }
6182#public void setRequiredMavenVersion( String requiredMavenVersion )
    {
        this.requiredMavenVersion = requiredMavenVersion;
    }
6183#public String getRequiredMavenVersion()
    {
        return requiredMavenVersion;
    }
6184#public void setPlugin( Plugin plugin )
    {
        this.plugin = plugin;
    }
6185#public Plugin getPlugin()
    {
        return plugin;
    }
6186#public Artifact getPluginArtifact()
    {
        return pluginArtifact;
    }
6187#public void setPluginArtifact( Artifact pluginArtifact )
    {
        this.pluginArtifact = pluginArtifact;
    }
6188#public Lifecycle getLifecycleMapping( String lifecycleId )
        throws IOException, XmlPullParserException
    {
        if ( lifecycleMappings == null )
        {
            LifecycleConfiguration lifecycleConfiguration;

            Reader reader = null;
            try
            {
                reader = ReaderFactory.newXmlReader( getDescriptorStream( LIFECYCLE_DESCRIPTOR ) );

                lifecycleConfiguration = new LifecycleMappingsXpp3Reader().read( reader );
            }
            finally
            {
                IOUtil.close( reader );
            }

            lifecycleMappings = new HashMap<String, Lifecycle>();

            for ( Lifecycle lifecycle : lifecycleConfiguration.getLifecycles() )
            {
                lifecycleMappings.put( lifecycle.getId(), lifecycle );
            }
        }

        return lifecycleMappings.get( lifecycleId );
    }
6189#private InputStream getDescriptorStream( String descriptor )
        throws IOException
    {
        File pluginFile = ( pluginArtifact != null ) ? pluginArtifact.getFile() : null;
        if ( pluginFile == null )
        {
            throw new IllegalStateException( "plugin main artifact has not been resolved for " + getId() );
        }

        if ( pluginFile.isFile() )
        {
            try
            {
                return new URL( "jar:" + pluginFile.toURI() + "!/" + descriptor ).openStream();
            }
            catch ( MalformedURLException e )
            {
                throw new IllegalStateException( e );
            }
        }
        else
        {
            return new FileInputStream( new File( pluginFile, descriptor ) );
        }
    }
6190#/**
     * Creates a shallow copy of this plugin descriptor.
     */
    @Override
    public PluginDescriptor clone()
    {
        try
        {
            return (PluginDescriptor) super.clone();
        }
        catch ( CloneNotSupportedException e )
        {
            throw new UnsupportedOperationException( e );
        }
    }
6191#public DuplicateParameterException( String message )
    {
        super( message );
    }
6192#public DuplicateMojoDescriptorException( String goalPrefix, String goal, String existingImplementation,
                                             String newImplementation )
    {
        super( "Goal: " + goal + " already exists in the plugin descriptor for prefix: " + goalPrefix
            + "\nExisting implementation is: " + existingImplementation
            + "\nConflicting implementation is: " + newImplementation );
    }
6193#// ----------------------------------------------------------------------
    //
    // ----------------------------------------------------------------------

    public String getName()
    {
        return name;
    }
6194#public void setName( String name )
    {
        this.name = name;
    }
6195#public String getType()
    {
        return type;
    }
6196#public void setType( String type )
    {
        this.type = type;
    }
6197#public boolean isRequired()
    {
        return required;
    }
6198#public void setRequired( boolean required )
    {
        this.required = required;
    }
6199#public String getDescription()
    {
        return description;
    }
6200#public void setDescription( String description )
    {
        this.description = description;
    }
6201#public String getExpression()
    {
        return expression;
    }
6202#public void setExpression( String expression )
    {
        this.expression = expression;
    }
6203#public String getDeprecated()
    {
        return deprecated;
    }
6204#public void setDeprecated( String deprecated )
    {
        this.deprecated = deprecated;
    }
6205#public int hashCode()
    {
        return name.hashCode();
    }
6206#public boolean equals( Object other )
    {
        return ( other instanceof Parameter ) && getName().equals( ( (Parameter) other ).getName() );
    }
6207#public String getAlias()
    {
        return alias;
    }
6208#public void setAlias( String alias )
    {
        this.alias = alias;
    }
6209#public boolean isEditable()
    {
        return editable;
    }
6210#public void setEditable( boolean editable )
    {
        this.editable = editable;
    }
6211#public void setDefaultValue( String defaultValue )
    {
        this.defaultValue = defaultValue;
    }
6212#public String getDefaultValue()
    {
        return defaultValue;
    }
6213#public String toString()
    {
        return "Mojo parameter [name: \'" + getName() + "\'; alias: \'" + getAlias() + "\']";
    }
6214#public Requirement getRequirement()
    {
        return requirement;
    }
6215#public void setRequirement( Requirement requirement )
    {
        this.requirement = requirement;
    }
6216#public String getImplementation()
    {
        return implementation;
    }
6217#public void setImplementation( String implementation )
    {
        this.implementation = implementation;
    }
6218#public String getSince()
    {
        return since;
    }
6219#public void setSince( String since )
    {
        this.since = since;
    }
6220#/**
     * Creates a shallow copy of this parameter.
     */
    @Override
    public Parameter clone()
    {
        try
        {
            return (Parameter) super.clone();
        }
        catch ( CloneNotSupportedException e )
        {
            throw new UnsupportedOperationException( e );
        }
    }
6221#/**
     * Default constructor.
     */
    public MojoDescriptor()
    {
        setInstantiationStrategy( DEFAULT_INSTANTIATION_STRATEGY );
        setComponentFactory( DEFAULT_LANGUAGE );
    }
6222#// ----------------------------------------------------------------------
    //
    // ----------------------------------------------------------------------

    /**
     * @return the language of this Mojo, i.e. <code>java</code>
     */
    public String getLanguage()
    {
        return getComponentFactory();
    }
6223#/**
     * @param language the new language
     */
    public void setLanguage( String language )
    {
        setComponentFactory( language );
    }
6224#/**
     * @return <code>true</code> if the Mojo is deprecated, <code>false</code> otherwise.
     */
    public String getDeprecated()
    {
        return deprecated;
    }
6225#/**
     * @param deprecated <code>true</code> to deprecate the Mojo, <code>false</code> otherwise.
     */
    public void setDeprecated( String deprecated )
    {
        this.deprecated = deprecated;
    }
6226#/**
     * @return the list of parameters
     */
    public List<Parameter> getParameters()
    {
        return parameters;
    }
6227#/**
     * @param parameters the new list of parameters
     * @throws DuplicateParameterException if any
     */
    public void setParameters( List<Parameter> parameters )
        throws DuplicateParameterException
    {
        for ( Parameter parameter : parameters )
        {
            addParameter( parameter );
        }
    }
6228#/**
     * @param parameter add a new parameter
     * @throws DuplicateParameterException if any
     */
    public void addParameter( Parameter parameter )
        throws DuplicateParameterException
    {
        if ( parameters != null && parameters.contains( parameter ) )
        {
            throw new DuplicateParameterException( parameter.getName()
                + " has been declared multiple times in mojo with goal: " + getGoal() + " (implementation: "
                + getImplementation() + ")" );
        }

        if ( parameters == null )
        {
            parameters = new LinkedList<Parameter>();
        }

        parameters.add( parameter );
    }
6229#/**
     * @return the list parameters as a Map
     */
    public Map<String, Parameter> getParameterMap()
    {
        if ( parameterMap == null )
        {
            parameterMap = new HashMap<String, Parameter>();

            if ( parameters != null )
            {
                for ( Parameter pd : parameters )
                {
                    parameterMap.put( pd.getName(), pd );
                }
            }
        }

        return parameterMap;
    }
6230#// ----------------------------------------------------------------------
    // Dependency requirement
    // ----------------------------------------------------------------------

    /**
     * @param requiresDependencyResolution the new required dependencies in a specified scope
     */
    public void setDependencyResolutionRequired( String requiresDependencyResolution )
    {
        this.dependencyResolutionRequired = requiresDependencyResolution;
    }
6231#public String getDependencyResolutionRequired()
    {
        return dependencyResolutionRequired;
    }
6232#/**
     * @return the required dependencies in a specified scope
     * @TODO the name is not intelligible
     */
    @Deprecated
    public String isDependencyResolutionRequired()
    {
        return dependencyResolutionRequired;
    }
6233#public void setDependencyCollectionRequired( String requiresDependencyCollection )
    {
        this.dependencyCollectionRequired = requiresDependencyCollection;
    }
6234#/**
     * Gets the scope of (transitive) dependencies that should be collected. Dependency collection refers to the process
     * of calculating the complete dependency tree in terms of artifact coordinates. In contrast to dependency
     * resolution, this does not include the download of the files for the dependency artifacts.
     *
     * @return The scope of (transitive) dependencies that should be collected or {@code null} if none.
     */
    public String getDependencyCollectionRequired()
    {
        return dependencyCollectionRequired;
    }
6235#// ----------------------------------------------------------------------
    // Project requirement
    // ----------------------------------------------------------------------

    /**
     * @param requiresProject <code>true</code> if the Mojo needs a Maven project to be executed, <code>false</code>
     * otherwise.
     */
    public void setProjectRequired( boolean requiresProject )
    {
        this.projectRequired = requiresProject;
    }
6236#/**
     * @return <code>true</code> if the Mojo needs a Maven project to be executed, <code>false</code> otherwise.
     */
    public boolean isProjectRequired()
    {
        return projectRequired;
    }
6237#// ----------------------------------------------------------------------
    // Online vs. Offline requirement
    // ----------------------------------------------------------------------

    /**
     * @param requiresOnline <code>true</code> if the Mojo is online, <code>false</code> otherwise.
     */
    public void setOnlineRequired( boolean requiresOnline )
    {
        this.onlineRequired = requiresOnline;
    }
6238#/**
     * @return <code>true</code> if the Mojo is online, <code>false</code> otherwise.
     */
    // blech! this isn't even intelligible as a method name. provided for
    // consistency...
    public boolean isOnlineRequired()
    {
        return onlineRequired;
    }
6239#/**
     * @return <code>true</code> if the Mojo is online, <code>false</code> otherwise.
     */
    // more english-friendly method...keep the code clean! :)
    public boolean requiresOnline()
    {
        return onlineRequired;
    }
6240#/**
     * @return the binded phase name of the Mojo
     */
    public String getPhase()
    {
        return phase;
    }
6241#/**
     * @param phase the new binded phase name of the Mojo
     */
    public void setPhase( String phase )
    {
        this.phase = phase;
    }
6242#/**
     * @return the version when the Mojo was added to the API
     */
    public String getSince()
    {
        return since;
    }
6243#/**
     * @param since the new version when the Mojo was added to the API
     */
    public void setSince( String since )
    {
        this.since = since;
    }
6244#/**
     * @return The goal name of the Mojo
     */
    public String getGoal()
    {
        return goal;
    }
6245#/**
     * @param goal The new goal name of the Mojo
     */
    public void setGoal( String goal )
    {
        this.goal = goal;
    }
6246#/**
     * @return the invocation phase of the Mojo
     */
    public String getExecutePhase()
    {
        return executePhase;
    }
6247#/**
     * @param executePhase the new invocation phase of the Mojo
     */
    public void setExecutePhase( String executePhase )
    {
        this.executePhase = executePhase;
    }
6248#/**
     * @return <code>true</code> if the Mojo uses <code>always</code> for the <code>executionStrategy</code>
     */
    public boolean alwaysExecute()
    {
        return MULTI_PASS_EXEC_STRATEGY.equals( executionStrategy );
    }
6249#/**
     * @return the execution strategy
     */
    public String getExecutionStrategy()
    {
        return executionStrategy;
    }
6250#/**
     * @param executionStrategy the new execution strategy
     */
    public void setExecutionStrategy( String executionStrategy )
    {
        this.executionStrategy = executionStrategy;
    }
6251#/**
     * @return the mojo configuration
     */
    public PlexusConfiguration getMojoConfiguration()
    {
        if ( mojoConfiguration == null )
        {
            mojoConfiguration = new XmlPlexusConfiguration( "configuration" );
        }
        return mojoConfiguration;
    }
6252#/**
     * @param mojoConfiguration a new mojo configuration
     */
    public void setMojoConfiguration( PlexusConfiguration mojoConfiguration )
    {
        this.mojoConfiguration = mojoConfiguration;
    }
6253#/** {@inheritDoc} */
    public String getRole()
    {
        return Mojo.ROLE;
    }
6254#/** {@inheritDoc} */
    public String getRoleHint()
    {
        return getId();
    }
6255#/**
     * @return the id of the mojo, based on the goal name
     */
    public String getId()
    {
        return getPluginDescriptor().getId() + ":" + getGoal();
    }
6256#/**
     * @return the full goal name
     * @see PluginDescriptor#getGoalPrefix()
     * @see #getGoal()
     */
    public String getFullGoalName()
    {
        return getPluginDescriptor().getGoalPrefix() + ":" + getGoal();
    }
6257#/** {@inheritDoc} */
    public String getComponentType()
    {
        return MAVEN_PLUGIN;
    }
6258#/**
     * @return the plugin descriptor
     */
    public PluginDescriptor getPluginDescriptor()
    {
        return pluginDescriptor;
    }
6259#/**
     * @param pluginDescriptor the new plugin descriptor
     */
    public void setPluginDescriptor( PluginDescriptor pluginDescriptor )
    {
        this.pluginDescriptor = pluginDescriptor;
    }
6260#/**
     * @return <code>true</code> if the Mojo is herited, <code>false</code> otherwise.
     */
    public boolean isInheritedByDefault()
    {
        return inheritedByDefault;
    }
6261#/**
     * @param inheritedByDefault <code>true</code> if the Mojo is herited, <code>false</code> otherwise.
     */
    public void setInheritedByDefault( boolean inheritedByDefault )
    {
        this.inheritedByDefault = inheritedByDefault;
    }
6262#/** {@inheritDoc} */
    public boolean equals( Object object )
    {
        if ( this == object )
        {
            return true;
        }

        if ( object instanceof MojoDescriptor )
        {
            MojoDescriptor other = (MojoDescriptor) object;

            if ( !compareObjects( getPluginDescriptor(), other.getPluginDescriptor() ) )
            {
                return false;
            }

            if ( !compareObjects( getGoal(), other.getGoal() ) )
            {
                return false;
            }

            return true;
        }

        return false;
    }
6263#private boolean compareObjects( Object first, Object second )
    {
        if ( ( first == null && second != null ) || ( first != null && second == null ) )
        {
            return false;
        }

        return first.equals( second );
    }
6264#/** {@inheritDoc} */
    public int hashCode()
    {
        int result = 1;

        String goal = getGoal();

        if ( goal != null )
        {
            result += goal.hashCode();
        }

        PluginDescriptor pd = getPluginDescriptor();

        if ( pd != null )
        {
            result -= pd.hashCode();
        }

        return result;
    }
6265#/**
     * @return the invocation lifecycle of the Mojo
     */
    public String getExecuteLifecycle()
    {
        return executeLifecycle;
    }
6266#/**
     * @param executeLifecycle the new invocation lifecycle of the Mojo
     */
    public void setExecuteLifecycle( String executeLifecycle )
    {
        this.executeLifecycle = executeLifecycle;
    }
6267#/**
     * @param aggregator <code>true</code> if the Mojo uses the Maven project and its child modules,
     * <code>false</code> otherwise.
     */
    public void setAggregator( boolean aggregator )
    {
        this.aggregator = aggregator;
    }
6268#/**
     * @return <code>true</code> if the Mojo uses the Maven project and its child modules,
     * <code>false</code> otherwise.
     */
    public boolean isAggregator()
    {
        return aggregator;
    }
6269#/**
     * @return <code>true</code> if the Mojo could not be invoke directly, <code>false</code> otherwise.
     */
    public boolean isDirectInvocationOnly()
    {
        return directInvocationOnly;
    }
6270#/**
     * @param directInvocationOnly <code>true</code> if the Mojo could not be invoke directly,
     * <code>false</code> otherwise.
     */
    public void setDirectInvocationOnly( boolean directInvocationOnly )
    {
        this.directInvocationOnly = directInvocationOnly;
    }
6271#/**
     * @return <code>true</code> if the Mojo needs reports to run, <code>false</code> otherwise.
     */
    public boolean isRequiresReports()
    {
        return requiresReports;
    }
6272#/**
     * @param requiresReports <code>true</code> if the Mojo needs reports to run, <code>false</code> otherwise.
     */
    public void setRequiresReports( boolean requiresReports )
    {
        this.requiresReports = requiresReports;
    }
6273#/**
     * @param executeGoal the new invocation goal of the Mojo
     */
    public void setExecuteGoal( String executeGoal )
    {
        this.executeGoal = executeGoal;
    }
6274#/**
     * @return the invocation goal of the Mojo
     */
    public String getExecuteGoal()
    {
        return executeGoal;
    }
6275#/**
     * @return True if the <code>Mojo</code> is thread-safe and can be run safely in parallel
     */
    public boolean isThreadSafe()
    {
        return threadSafe;
    }
6276#/**
     * @param threadSafe indicates that the mojo is thread-safe and can be run safely in parallel
     */
    public void setThreadSafe( boolean threadSafe )
    {
        this.threadSafe = threadSafe;
    }
6277#/**
     * @return {@code true} if this mojo forks either a goal or the lifecycle, {@code false} otherwise.
     */
    public boolean isForking()
    {
        return ( getExecuteGoal() != null && getExecuteGoal().length() > 0 )
            || ( getExecutePhase() != null && getExecutePhase().length() > 0 );
    }
6278#/**
     * Creates a shallow copy of this mojo descriptor.
     */
    @Override
    public MojoDescriptor clone()
    {
        try
        {
            return (MojoDescriptor) super.clone();
        }
        catch ( CloneNotSupportedException e )
        {
            throw new UnsupportedOperationException( e );
        }
    }
6279#/**
     * @return true if the <b>debug</b> error level is enabled
     */
    boolean isDebugEnabled();
6280#/**
     * Send a message to the user in the <b>debug</b> error level.
     *
     * @param content
     */
    void debug( CharSequence content );
6281#/**
     * Send a message (and accompanying exception) to the user in the <b>debug</b> error level.
     * <br/>
     * The error's stacktrace will be output when this error level is enabled.
     *
     * @param content
     * @param error
     */
    void debug( CharSequence content, Throwable error );
6282#/**
     * Send an exception to the user in the <b>debug</b> error level.
     * <br/>
     * The stack trace for this exception will be output when this error level is enabled.
     *
     * @param error
     */
    void debug( Throwable error );
6283#/**
     * @return true if the <b>info</b> error level is enabled
     */
    boolean isInfoEnabled();
6284#/**
     * Send a message to the user in the <b>info</b> error level.
     *
     * @param content
     */
    void info( CharSequence content );
6285#/**
     * Send a message (and accompanying exception) to the user in the <b>info</b> error level.
     * <br/>
     * The error's stacktrace will be output when this error level is enabled.
     *
     * @param content
     * @param error
     */
    void info( CharSequence content, Throwable error );
6286#/**
     * Send an exception to the user in the <b>info</b> error level.
     * <br/>
     * The stack trace for this exception will be output when this error level is enabled.
     *
     * @param error
     */
    void info( Throwable error );
6287#/**
     * @return true if the <b>warn</b> error level is enabled
     */
    boolean isWarnEnabled();
6288#/**
     * Send a message to the user in the <b>warn</b> error level.
     *
     * @param content
     */
    void warn( CharSequence content );
6289#/**
     * Send a message (and accompanying exception) to the user in the <b>warn</b> error level.
     * <br/>
     * The error's stacktrace will be output when this error level is enabled.
     *
     * @param content
     * @param error
     */
    void warn( CharSequence content, Throwable error );
6290#/**
     * Send an exception to the user in the <b>warn</b> error level.
     * <br/>
     * The stack trace for this exception will be output when this error level is enabled.
     *
     * @param error
     */
    void warn( Throwable error );
6291#/**
     * @return true if the <b>error</b> error level is enabled
     */
    boolean isErrorEnabled();
6292#/**
     * Send a message to the user in the <b>error</b> error level.
     *
     * @param content
     */
    void error( CharSequence content );
6293#/**
     * Send a message (and accompanying exception) to the user in the <b>error</b> error level.
     * <br/>
     * The error's stacktrace will be output when this error level is enabled.
     *
     * @param content
     * @param error
     */
    void error( CharSequence content, Throwable error );
6294#/**
     * Send an exception to the user in the <b>error</b> error level.
     * <br/>
     * The stack trace for this exception will be output when this error level is enabled.
     *
     * @param error
     */
    void error( Throwable error );
6295#/**
     * @see org.apache.maven.plugin.logging.Log#debug(java.lang.CharSequence)
     */
    public void debug( CharSequence content )
    {
        print( "debug", content );
    }
6296#/**
     * @see org.apache.maven.plugin.logging.Log#debug(java.lang.CharSequence, java.lang.Throwable)
     */
    public void debug( CharSequence content, Throwable error )
    {
        print( "debug", content, error );
    }
6297#/**
     * @see org.apache.maven.plugin.logging.Log#debug(java.lang.Throwable)
     */
    public void debug( Throwable error )
    {
        print( "debug", error );
    }
6298#/**
     * @see org.apache.maven.plugin.logging.Log#info(java.lang.CharSequence)
     */
    public void info( CharSequence content )
    {
        print( "info", content );
    }
6299#/**
     * @see org.apache.maven.plugin.logging.Log#info(java.lang.CharSequence, java.lang.Throwable)
     */
    public void info( CharSequence content, Throwable error )
    {
        print( "info", content, error );
    }
6300#/**
     * @see org.apache.maven.plugin.logging.Log#info(java.lang.Throwable)
     */
    public void info( Throwable error )
    {
        print( "info", error );
    }
6301#/**
     * @see org.apache.maven.plugin.logging.Log#warn(java.lang.CharSequence)
     */
    public void warn( CharSequence content )
    {
        print( "warn", content );
    }
6302#/**
     * @see org.apache.maven.plugin.logging.Log#warn(java.lang.CharSequence, java.lang.Throwable)
     */
    public void warn( CharSequence content, Throwable error )
    {
        print( "warn", content, error );
    }
6303#/**
     * @see org.apache.maven.plugin.logging.Log#warn(java.lang.Throwable)
     */
    public void warn( Throwable error )
    {
        print( "warn", error );
    }
6304#/**
     * @see org.apache.maven.plugin.logging.Log#error(java.lang.CharSequence)
     */
    public void error( CharSequence content )
    {
        System.err.println( "[error] " + content.toString() );
    }
6305#/**
     * @see org.apache.maven.plugin.logging.Log#error(java.lang.CharSequence, java.lang.Throwable)
     */
    public void error( CharSequence content, Throwable error )
    {
        StringWriter sWriter = new StringWriter();
        PrintWriter pWriter = new PrintWriter( sWriter );

        error.printStackTrace( pWriter );

        System.err.println( "[error] " + content.toString() + "\n\n" + sWriter.toString() );
    }
6306#/**
     * @see org.apache.maven.plugin.logging.Log#error(java.lang.Throwable)
     */
    public void error( Throwable error )
    {
        StringWriter sWriter = new StringWriter();
        PrintWriter pWriter = new PrintWriter( sWriter );

        error.printStackTrace( pWriter );

        System.err.println( "[error] " + sWriter.toString() );
    }
6307#/**
     * @see org.apache.maven.plugin.logging.Log#isDebugEnabled()
     */
    public boolean isDebugEnabled()
    {
        // TODO: Not sure how best to set these for this implementation...
        return false;
    }
6308#/**
     * @see org.apache.maven.plugin.logging.Log#isInfoEnabled()
     */
    public boolean isInfoEnabled()
    {
        return true;
    }
6309#/**
     * @see org.apache.maven.plugin.logging.Log#isWarnEnabled()
     */
    public boolean isWarnEnabled()
    {
        return true;
    }
6310#/**
     * @see org.apache.maven.plugin.logging.Log#isErrorEnabled()
     */
    public boolean isErrorEnabled()
    {
        return true;
    }
6311#private void print( String prefix, CharSequence content )
    {
        System.out.println( "[" + prefix + "] " + content.toString() );
    }
6312#private void print( String prefix, Throwable error )
    {
        StringWriter sWriter = new StringWriter();
        PrintWriter pWriter = new PrintWriter( sWriter );

        error.printStackTrace( pWriter );

        System.out.println( "[" + prefix + "] " + sWriter.toString() );
    }
6313#private void print( String prefix, CharSequence content, Throwable error )
    {
        StringWriter sWriter = new StringWriter();
        PrintWriter pWriter = new PrintWriter( sWriter );

        error.printStackTrace( pWriter );

        System.out.println( "[" + prefix + "] " + content.toString() + "\n\n" + sWriter.toString() );
    }
6314#private PluginDescriptor build( String resource )
        throws IOException, PlexusConfigurationException
    {
        Reader reader = ReaderFactory.newXmlReader( getClass().getResourceAsStream( resource ) );

        return new PluginDescriptorBuilder().build( reader );
    }
6315#public void testBuildReader()
        throws Exception
    {
        PluginDescriptor pd = build( "/plugin.xml" );

        assertEquals( "org.apache.maven.plugins", pd.getGroupId() );
        assertEquals( "maven-jar-plugin", pd.getArtifactId() );
        assertEquals( "2.3-SNAPSHOT", pd.getVersion() );
        assertEquals( "jar", pd.getGoalPrefix() );
        assertEquals( "plugin-description", pd.getDescription() );
        assertEquals( false, pd.isIsolatedRealm() );
        assertEquals( true, pd.isInheritedByDefault() );
        assertEquals( 2, pd.getMojos().size() );
        assertEquals( 1, pd.getDependencies().size() );

        MojoDescriptor md = pd.getMojos().get( 0 );

        assertEquals( "jar", md.getGoal() );
        assertEquals( "mojo-description", md.getDescription() );
        assertEquals( "runtime", md.getDependencyResolutionRequired() );
        assertEquals( "test", md.getDependencyCollectionRequired() );
        assertEquals( false, md.isAggregator() );
        assertEquals( false, md.isDirectInvocationOnly() );
        assertEquals( true, md.isInheritedByDefault() );
        assertEquals( false, md.isOnlineRequired() );
        assertEquals( true, md.isProjectRequired() );
        assertEquals( false, md.isThreadSafe() );
        assertEquals( "package", md.getPhase() );
        assertEquals( "org.apache.maven.plugin.jar.JarMojo", md.getImplementation() );
        assertEquals( "antrun", md.getComponentConfigurator() );
        assertEquals( "java", md.getLanguage() );
        assertEquals( "per-lookup", md.getInstantiationStrategy() );
        assertEquals( "some-goal", md.getExecuteGoal() );
        assertEquals( "generate-sources", md.getExecutePhase() );
        assertEquals( "cobertura", md.getExecuteLifecycle() );
        assertEquals( "2.2", md.getSince() );
        assertEquals( "deprecated-mojo", md.getDeprecated() );
        assertEquals( 1, md.getRequirements().size() );
        assertEquals( 1, md.getParameters().size() );

        assertNotNull( md.getMojoConfiguration() );
        assertEquals( 1, md.getMojoConfiguration().getChildCount() );

        PlexusConfiguration pc = md.getMojoConfiguration().getChild( 0 );

        assertEquals( "${jar.finalName}", pc.getValue() );
        assertEquals( "${project.build.finalName}", pc.getAttribute( "default-value" ) );
        assertEquals( "java.lang.String", pc.getAttribute( "implementation" ) );

        Parameter mp = md.getParameters().get( 0 );

        assertEquals( "finalName", mp.getName() );
        assertEquals( "jarName", mp.getAlias() );
        assertEquals( "java.lang.String", mp.getType() );
        assertEquals( "java.lang.String", mp.getImplementation() );
        assertEquals( true, mp.isEditable() );
        assertEquals( false, mp.isRequired() );
        assertEquals( "parameter-description", mp.getDescription() );
        assertEquals( "deprecated-parameter", mp.getDeprecated() );
        assertEquals( "${jar.finalName}", mp.getExpression() );
        assertEquals( "${project.build.finalName}", mp.getDefaultValue() );

        ComponentRequirement cr = md.getRequirements().get( 0 );

        assertEquals( "org.codehaus.plexus.archiver.Archiver", cr.getRole() );
        assertEquals( "jar", cr.getRoleHint() );
        assertEquals( "jarArchiver", cr.getFieldName() );

        ComponentDependency cd = pd.getDependencies().get( 0 );

        assertEquals( "org.apache.maven", cd.getGroupId() );
        assertEquals( "maven-plugin-api", cd.getArtifactId() );
        assertEquals( "2.0.6", cd.getVersion() );
        assertEquals( "jar", cd.getType() );

        md = pd.getMojos().get( 1 );

        assertEquals( "war", md.getGoal() );
        assertEquals( null, md.getDependencyResolutionRequired() );
        assertEquals( null, md.getDependencyCollectionRequired() );
        assertEquals( true, md.isThreadSafe() );
    }
6316#public void testLifecycleReader()
        throws IOException, XmlPullParserException
    {/*
        LifecycleMappingsXpp3Reader reader = new LifecycleMappingsXpp3Reader();
        LifecycleConfiguration config = reader.read( new InputStreamReader( getClass().getResourceAsStream( "/lifecycle.xml" ) ) );
        assertEquals( "check number of lifecycles", 1, config.getLifecycles().size() );
        Lifecycle l = (Lifecycle) config.getLifecycles().iterator().next();
        assertEquals( "check id", "clover", l.getId() );
        assertEquals( "check number of phases", 1, l.getPhases().size() );
        Phase p = (Phase) l.getPhases().iterator().next();
        assertEquals( "check id", "generate-sources", p.getId() );
        assertEquals( "check number of executions", 1, p.getExecutions().size() );
        Execution e = (Execution) p.getExecutions().iterator().next();
        assertEquals( "check configuration", "true", ((Xpp3Dom) e.getConfiguration()).getChild( "debug" ).getValue() );
        assertEquals( "check number of goals", 1, e.getGoals().size() );
        String g = (String) e.getGoals().iterator().next();
        assertEquals( "check goal", "clover:compiler", g );
        */
    }
6317#/**
     * Gets a byte stream to the settings contents. Closing the returned stream is the responsibility of the caller.
     * Note that each invocation of this method returns a new/fresh stream which represents the entire contents.
     * 
     * @return A byte stream to the settings contents, never {@code null}.
     */
    InputStream getInputStream()
        throws IOException;
6318#/**
     * Provides a user-friendly hint about the location of the settings. This could be a local file path, a URI or just
     * an empty string. The intention is to assist users during error reporting.
     * 
     * @return A user-friendly hint about the location of the settings, never {@code null}.
     */
    String getLocation();
6319#/**
     * Creates a new settings source backed by the specified string.
     * 
     * @param settings The settings' string representation, may be empty or {@code null}.
     */
    public StringSettingsSource( CharSequence settings )
    {
        this( settings, null );
    }
6320#/**
     * Creates a new settings source backed by the specified string.
     * 
     * @param settings The settings' string representation, may be empty or {@code null}.
     * @param location The location to report for this use, may be {@code null}.
     */
    public StringSettingsSource( CharSequence settings, String location )
    {
        this.settings = ( settings != null ) ? settings.toString() : "";
        this.location = ( location != null ) ? location : "(memory)";
    }
6321#public InputStream getInputStream()
        throws IOException
    {
        return new ByteArrayInputStream( settings.getBytes( "UTF-8" ) );
    }
6322#public String getLocation()
    {
        return location;
    }
6323#/**
     * Gets the character sequence of this settings source.
     * 
     * @return The underlying character stream, never {@code null}.
     */
    public String getSettings()
    {
        return settings;
    }
6324#@Override
    public String toString()
    {
        return getLocation();
    }
6325#/**
     * Creates a new problem with the specified message and exception.
     * 
     * @param message The message describing the problem, may be {@code null}.
     * @param severity The severity level of the problem, may be {@code null} to default to
     *            {@link SettingsProblem.Severity#ERROR}.
     * @param source A hint about the source of the problem like a file path, may be {@code null}.
     * @param lineNumber The one-based index of the line containing the problem or {@code -1} if unknown.
     * @param columnNumber The one-based index of the column containing the problem or {@code -1} if unknown.
     * @param exception The exception that caused this problem, may be {@code null}.
     */
    public DefaultSettingsProblem( String message, Severity severity, String source, int lineNumber, int columnNumber,
                                   Exception exception )
    {
        this.message = message;
        this.severity = ( severity != null ) ? severity : Severity.ERROR;
        this.source = ( source != null ) ? source : "";
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
        this.exception = exception;
    }
6326#public String getSource()
    {
        return source;
    }
6327#public int getLineNumber()
    {
        return lineNumber;
    }
6328#public int getColumnNumber()
    {
        return columnNumber;
    }
6329#public String getLocation()
    {
        StringBuilder buffer = new StringBuilder( 256 );

        if ( getSource().length() > 0 )
        {
            if ( buffer.length() > 0 )
            {
                buffer.append( ", " );
            }
            buffer.append( getSource() );
        }

        if ( getLineNumber() > 0 )
        {
            if ( buffer.length() > 0 )
            {
                buffer.append( ", " );
            }
            buffer.append( "line " ).append( getLineNumber() );
        }

        if ( getColumnNumber() > 0 )
        {
            if ( buffer.length() > 0 )
            {
                buffer.append( ", " );
            }
            buffer.append( "column " ).append( getColumnNumber() );
        }

        return buffer.toString();
    }
6330#public Exception getException()
    {
        return exception;
    }
6331#public String getMessage()
    {
        String msg;

        if ( message != null && message.length() > 0 )
        {
            msg = message;
        }
        else
        {
            msg = exception.getMessage();

            if ( msg == null )
            {
                msg = "";
            }
        }

        return msg;
    }
6332#public Severity getSeverity()
    {
        return severity;
    }
6333#@Override
    public String toString()
    {
        StringBuilder buffer = new StringBuilder( 128 );

        buffer.append( "[" ).append( getSeverity() ).append( "] " );
        buffer.append( getMessage() );
        buffer.append( " @ " ).append( getLocation() );

        return buffer.toString();
    }
6334#/**
     * Gets the assembled settings.
     * 
     * @return The assembled settings, never {@code null}.
     */
    Settings getEffectiveSettings();
6335#/**
     * Gets the problems that were encountered during the settings building. Note that only problems of severity
     * {@link SettingsProblem.Severity#WARNING} and below are reported here. Problems with a higher severity level cause
     * the settings builder to fail with a {@link SettingsBuildingException}.
     * 
     * @return The problems that were encountered during the settings building, can be empty but never {@code null}.
     */
    List<SettingsProblem> getProblems();
6336#public DefaultSettingsBuilder setSettingsReader( SettingsReader settingsReader )
    {
        this.settingsReader = settingsReader;
        return this;
    }
6337#public DefaultSettingsBuilder setSettingsWriter( SettingsWriter settingsWriter )
    {
        this.settingsWriter = settingsWriter;
        return this;
    }
6338#public DefaultSettingsBuilder setSettingsValidator( SettingsValidator settingsValidator )
    {
        this.settingsValidator = settingsValidator;
        return this;
    }
6339#public SettingsBuildingResult build( SettingsBuildingRequest request )
        throws SettingsBuildingException
    {
        DefaultSettingsProblemCollector problems = new DefaultSettingsProblemCollector( null );

        SettingsSource globalSettingsSource =
            getSettingsSource( request.getGlobalSettingsFile(), request.getGlobalSettingsSource() );
        Settings globalSettings = readSettings( globalSettingsSource, request, problems );

        SettingsSource userSettingsSource =
            getSettingsSource( request.getUserSettingsFile(), request.getUserSettingsSource() );
        Settings userSettings = readSettings( userSettingsSource, request, problems );

        settingsMerger.merge( userSettings, globalSettings, TrackableBase.GLOBAL_LEVEL );

        problems.setSource( "" );

        userSettings = interpolate( userSettings, request, problems );

        // for the special case of a drive-relative Windows path, make sure it's absolute to save plugins from trouble
        String localRepository = userSettings.getLocalRepository();
        if ( localRepository != null && localRepository.length() > 0 )
        {
            File file = new File( localRepository );
            if ( !file.isAbsolute() && file.getPath().startsWith( File.separator ) )
            {
                userSettings.setLocalRepository( file.getAbsolutePath() );
            }
        }

        if ( hasErrors( problems.getProblems() ) )
        {
            throw new SettingsBuildingException( problems.getProblems() );
        }

        return new DefaultSettingsBuildingResult( userSettings, problems.getProblems() );
    }
6340#private boolean hasErrors( List<SettingsProblem> problems )
    {
        if ( problems != null )
        {
            for ( SettingsProblem problem : problems )
            {
                if ( SettingsProblem.Severity.ERROR.compareTo( problem.getSeverity() ) >= 0 )
                {
                    return true;
                }
            }
        }

        return false;
    }
6341#private SettingsSource getSettingsSource( File settingsFile, SettingsSource settingsSource )
    {
        if ( settingsSource != null )
        {
            return settingsSource;
        }
        else if ( settingsFile != null && settingsFile.exists() )
        {
            return new FileSettingsSource( settingsFile );
        }
        return null;
    }
6342#private Settings readSettings( SettingsSource settingsSource, SettingsBuildingRequest request,
                                   DefaultSettingsProblemCollector problems )
    {
        if ( settingsSource == null )
        {
            return new Settings();
        }

        problems.setSource( settingsSource.getLocation() );

        Settings settings;

        try
        {
            Map<String, ?> options = Collections.singletonMap( SettingsReader.IS_STRICT, Boolean.TRUE );

            try
            {
                settings = settingsReader.read( settingsSource.getInputStream(), options );
            }
            catch ( SettingsParseException e )
            {
                options = Collections.singletonMap( SettingsReader.IS_STRICT, Boolean.FALSE );

                settings = settingsReader.read( settingsSource.getInputStream(), options );

                problems.add( SettingsProblem.Severity.WARNING, e.getMessage(), e.getLineNumber(), e.getColumnNumber(),
                              e );
            }
        }
        catch ( SettingsParseException e )
        {
            problems.add( SettingsProblem.Severity.FATAL, "Non-parseable settings " + settingsSource.getLocation() + ": "
                + e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e );
            return new Settings();
        }
        catch ( IOException e )
        {
            problems.add( SettingsProblem.Severity.FATAL, "Non-readable settings " + settingsSource.getLocation() + ": "
                + e.getMessage(), -1, -1, e );
            return new Settings();
        }

        settingsValidator.validate( settings, problems );

        return settings;
    }
6343#private Settings interpolate( Settings settings, SettingsBuildingRequest request, SettingsProblemCollector problems )
    {
        StringWriter writer = new StringWriter( 1024 * 4 );

        try
        {
            settingsWriter.write( writer, null, settings );
        }
        catch ( IOException e )
        {
            throw new IllegalStateException( "Failed to serialize settings to memory", e );
        }

        String serializedSettings = writer.toString();

        RegexBasedInterpolator interpolator = new RegexBasedInterpolator();

        interpolator.addValueSource( new PropertiesBasedValueSource( request.getUserProperties() ) );

        interpolator.addValueSource( new PropertiesBasedValueSource( request.getSystemProperties() ) );

        try
        {
            interpolator.addValueSource( new EnvarBasedValueSource() );
        }
        catch ( IOException e )
        {
            problems.add( SettingsProblem.Severity.WARNING, "Failed to use environment variables for interpolation: "
                + e.getMessage(), -1, -1, e );
        }

        interpolator.addPostProcessor( new InterpolationPostProcessor()
        {
            public Object execute( String expression, Object value )
            {
                if ( value != null )
                {
                    // we're going to parse this back in as XML so we need to escape XML markup
                    value = value.toString().replace( "&", "&amp;" ).replace( "<", "&lt;" ).replace( ">", "&gt;" );
                    return value;
                }
                return null;
            }
        } );

        try
        {
            serializedSettings = interpolator.interpolate( serializedSettings, "settings" );
        }
        catch ( InterpolationException e )
        {
            problems.add( SettingsProblem.Severity.ERROR, "Failed to interpolate settings: " + e.getMessage(), -1, -1,
                          e );

            return settings;
        }

        Settings result;
        try
        {
            Map<String, ?> options = Collections.singletonMap( SettingsReader.IS_STRICT, Boolean.FALSE );
            result = settingsReader.read( new StringReader( serializedSettings ), options );
        }
        catch ( IOException e )
        {
            problems.add( SettingsProblem.Severity.ERROR, "Failed to interpolate settings: " + e.getMessage(), -1, -1,
                          e );
            return settings;
        }

        return result;
    }
6344#public File getGlobalSettingsFile()
    {
        return globalSettingsFile;
    }
6345#public DefaultSettingsBuildingRequest setGlobalSettingsFile( File globalSettingsFile )
    {
        this.globalSettingsFile = globalSettingsFile;

        return this;
    }
6346#public SettingsSource getGlobalSettingsSource()
    {
        return globalSettingsSource;
    }
6347#public DefaultSettingsBuildingRequest setGlobalSettingsSource( SettingsSource globalSettingsSource )
    {
        this.globalSettingsSource = globalSettingsSource;

        return this;
    }
6348#public File getUserSettingsFile()
    {
        return userSettingsFile;
    }
6349#public DefaultSettingsBuildingRequest setUserSettingsFile( File userSettingsFile )
    {
        this.userSettingsFile = userSettingsFile;

        return this;
    }
6350#public SettingsSource getUserSettingsSource()
    {
        return userSettingsSource;
    }
6351#public DefaultSettingsBuildingRequest setUserSettingsSource( SettingsSource userSettingsSource )
    {
        this.userSettingsSource = userSettingsSource;

        return this;
    }
6352#public Properties getSystemProperties()
    {
        if ( systemProperties == null )
        {
            systemProperties = new Properties();
        }

        return systemProperties;
    }
6353#public DefaultSettingsBuildingRequest setSystemProperties( Properties systemProperties )
    {
        if ( systemProperties != null )
        {
            this.systemProperties = new Properties();
            this.systemProperties.putAll( systemProperties );
        }
        else
        {
            this.systemProperties = null;
        }

        return this;
    }
6354#public Properties getUserProperties()
    {
        if ( userProperties == null )
        {
            userProperties = new Properties();
        }

        return userProperties;
    }
6355#public DefaultSettingsBuildingRequest setUserProperties( Properties userProperties )
    {
        if ( userProperties != null )
        {
            this.userProperties = new Properties();
            this.userProperties.putAll( userProperties );
        }
        else
        {
            this.userProperties = null;
        }

        return this;
    }
6356#/**
     * Creates a new settings source backed by the specified file.
     * 
     * @param settingsFile The settings file, must not be {@code null}.
     */
    public FileSettingsSource( File settingsFile )
    {
        if ( settingsFile == null )
        {
            throw new IllegalArgumentException( "no settings file specified" );
        }
        this.settingsFile = settingsFile.getAbsoluteFile();
    }
6357#public InputStream getInputStream()
        throws IOException
    {
        return new FileInputStream( settingsFile );
    }
6358#public String getLocation()
    {
        return settingsFile.getPath();
    }
6359#/**
     * Gets the settings file of this model source.
     * 
     * @return The underlying settings file, never {@code null}.
     */
    public File getSettingsFile()
    {
        return settingsFile;
    }
6360#@Override
    public String toString()
    {
        return getLocation();
    }
6361#/**
     * Adds the specified problem.
     * 
     * @param severity The severity of the problem, must not be {@code null}.
     * @param message The detail message of the problem, may be {@code null}.
     * @param line The one-based index of the line containing the problem or {@code -1} if unknown.
     * @param column The one-based index of the column containing the problem or {@code -1} if unknown.
     * @param cause The cause of the problem, may be {@code null}.
     */
    void add( SettingsProblem.Severity severity, String message, int line, int column, Exception cause );
6362#protected SettingsReader newSettingsReader()
    {
        return new DefaultSettingsReader();
    }
6363#protected SettingsWriter newSettingsWriter()
    {
        return new DefaultSettingsWriter();
    }
6364#protected SettingsValidator newSettingsValidator()
    {
        return new DefaultSettingsValidator();
    }
6365#/**
     * Creates a new settings builder instance.
     * 
     * @return The new settings builder instance, never {@code null}.
     */
    public DefaultSettingsBuilder newInstance()
    {
        DefaultSettingsBuilder builder = new DefaultSettingsBuilder();

        builder.setSettingsReader( newSettingsReader() );
        builder.setSettingsWriter( newSettingsWriter() );
        builder.setSettingsValidator( newSettingsValidator() );

        return builder;
    }
6366#/**
     * Builds the effective settings of the specified settings files.
     * 
     * @param request The settings building request that holds the parameters, must not be {@code null}.
     * @return The result of the settings building, never {@code null}.
     * @throws SettingsBuildingException If the effective settings could not be built.
     */
    SettingsBuildingResult build( SettingsBuildingRequest request )
        throws SettingsBuildingException;
6367#public DefaultSettingsProblemCollector( List<SettingsProblem> problems )
    {
        this.problems = ( problems != null ) ? problems : new ArrayList<SettingsProblem>();
    }
6368#public List<SettingsProblem> getProblems()
    {
        return problems;
    }
6369#public void setSource( String source )
    {
        this.source = source;
    }
6370#public void add( SettingsProblem.Severity severity, String message, int line, int column, Exception cause )
    {
        if ( line <= 0 && column <= 0 && ( cause instanceof SettingsParseException ) )
        {
            SettingsParseException e = (SettingsParseException) cause;
            line = e.getLineNumber();
            column = e.getColumnNumber();
        }

        SettingsProblem problem = new DefaultSettingsProblem( message, severity, source, line, column, cause );

        problems.add( problem );
    }
6371#/**
     * Creates a new exception with the specified problems.
     * 
     * @param problems The problems that causes this exception, may be {@code null}.
     */
    public SettingsBuildingException( List<SettingsProblem> problems )
    {
        super( toMessage( problems ) );

        this.problems = new ArrayList<SettingsProblem>();
        if ( problems != null )
        {
            this.problems.addAll( problems );
        }
    }
6372#/**
     * Gets the problems that caused this exception.
     * 
     * @return The problems that caused this exception, never {@code null}.
     */
    public List<SettingsProblem> getProblems()
    {
        return problems;
    }
6373#private static String toMessage( List<SettingsProblem> problems )
    {
        StringWriter buffer = new StringWriter( 1024 );

        PrintWriter writer = new PrintWriter( buffer );

        writer.print( problems.size() );
        writer.print( ( problems.size() == 1 ) ? " problem was " : " problems were " );
        writer.print( "encountered while building the effective settings" );
        writer.println();

        for ( SettingsProblem problem : problems )
        {
            writer.print( "[" );
            writer.print( problem.getSeverity() );
            writer.print( "] " );
            writer.print( problem.getMessage() );
            writer.print( " @ " );
            writer.println( problem.getLocation() );
        }

        return buffer.toString();
    }
6374#/**
     * Creates a new model source backed by the specified URL.
     * 
     * @param settingsUrl The settings URL, must not be {@code null}.
     */
    public UrlSettingsSource( URL settingsUrl )
    {
        if ( settingsUrl == null )
        {
            throw new IllegalArgumentException( "no settings URL specified" );
        }
        this.settingsUrl = settingsUrl;
    }
6375#public InputStream getInputStream()
        throws IOException
    {
        return settingsUrl.openStream();
    }
6376#public String getLocation()
    {
        return settingsUrl.toString();
    }
6377#/**
     * Gets the settings URL of this model source.
     * 
     * @return The underlying settings URL, never {@code null}.
     */
    public URL getSettingsUrl()
    {
        return settingsUrl;
    }
6378#@Override
    public String toString()
    {
        return getLocation();
    }
6379#public DefaultSettingsBuildingResult( Settings effectiveSettings, List<SettingsProblem> problems )
    {
        this.effectiveSettings = effectiveSettings;
        this.problems = ( problems != null ) ? problems : new ArrayList<SettingsProblem>();
    }
6380#public Settings getEffectiveSettings()
    {
        return effectiveSettings;
    }
6381#public List<SettingsProblem> getProblems()
    {
        return problems;
    }
6382#/**
     * Gets the global settings file.
     * 
     * @return The global settings file or {@code null} if none.
     */
    File getGlobalSettingsFile();
6383#/**
     * Sets the global settings file. A non-existent settings file is equivalent to empty settings. If both user
     * settings and global settings are given, the user settings take precedence.
     * 
     * @param globalSettingsFile The global settings file, may be {@code null} to disable global settings.
     * @return This request, never {@code null}.
     */
    SettingsBuildingRequest setGlobalSettingsFile( File globalSettingsFile );
6384#/**
     * Gets the global settings source.
     * 
     * @return The global settings source or {@code null} if none.
     */
    SettingsSource getGlobalSettingsSource();
6385#/**
     * Sets the global settings source. If both user settings and a global settings are given, the user settings take
     * precedence.
     * 
     * @param globalSettingsSource The global settings source, may be {@code null} to disable global settings.
     * @return This request, never {@code null}.
     */
    SettingsBuildingRequest setGlobalSettingsSource( SettingsSource globalSettingsSource );
6386#/**
     * Gets the user settings file.
     * 
     * @return The user settings file or {@code null} if none.
     */
    File getUserSettingsFile();
6387#/**
     * Sets the user settings file. A non-existent settings file is equivalent to empty settings. If both a user
     * settings file and a global settings file are given, the user settings take precedence.
     * 
     * @param userSettingsFile The user settings file, may be {@code null} to disable user settings.
     * @return This request, never {@code null}.
     */
    SettingsBuildingRequest setUserSettingsFile( File userSettingsFile );
6388#/**
     * Gets the user settings source.
     * 
     * @return The user settings source or {@code null} if none.
     */
    SettingsSource getUserSettingsSource();
6389#/**
     * Sets the user settings source. If both user settings and a global settings are given, the user settings take
     * precedence.
     * 
     * @param userSettingsSource The user settings source, may be {@code null} to disable user settings.
     * @return This request, never {@code null}.
     */
    SettingsBuildingRequest setUserSettingsSource( SettingsSource userSettingsSource );
6390#/**
     * Gets the system properties to use for interpolation. The system properties are collected from the runtime
     * environment like {@link System#getProperties()} and environment variables.
     * 
     * @return The system properties, never {@code null}.
     */
    Properties getSystemProperties();
6391#/**
     * Sets the system properties to use for interpolation. The system properties are collected from the runtime
     * environment like {@link System#getProperties()} and environment variables.
     * 
     * @param systemProperties The system properties, may be {@code null}.
     * @return This request, never {@code null}.
     */
    SettingsBuildingRequest setSystemProperties( Properties systemProperties );
6392#/**
     * Gets the user properties to use for interpolation. The user properties have been configured directly by the user
     * on his discretion, e.g. via the {@code -Dkey=value} parameter on the command line.
     * 
     * @return The user properties, never {@code null}.
     */
    Properties getUserProperties();
6393#/**
     * Sets the user properties to use for interpolation. The user properties have been configured directly by the user
     * on his discretion, e.g. via the {@code -Dkey=value} parameter on the command line.
     * 
     * @param userProperties The user properties, may be {@code null}.
     * @return This request, never {@code null}.
     */
    SettingsBuildingRequest setUserProperties( Properties userProperties );
6394#/**
     * Gets the hint about the source of the problem. While the syntax of this hint is unspecified and depends on the
     * creator of the problem, the general expectation is that the hint provides sufficient information to the user to
     * track the problem back to its origin. A concrete example for such a source hint can be the file path or URL from
     * which the settings were read.
     * 
     * @return The hint about the source of the problem or an empty string if unknown, never {@code null}.
     */
    String getSource();
6395#/**
     * Gets the one-based index of the line containing the problem. The line number should refer to some text file that
     * is given by {@link #getSource()}.
     * 
     * @return The one-based index of the line containing the problem or a non-positive value if unknown.
     */
    int getLineNumber();
6396#/**
     * Gets the one-based index of the column containing the problem. The column number should refer to some text file
     * that is given by {@link #getSource()}.
     * 
     * @return The one-based index of the column containing the problem or non-positive value if unknown.
     */
    int getColumnNumber();
6397#/**
     * Gets the location of the problem. The location is a user-friendly combination of the values from
     * {@link #getSource()}, {@link #getLineNumber()} and {@link #getColumnNumber()}. The exact syntax of the returned
     * value is undefined.
     * 
     * @return The location of the problem, never {@code null}.
     */
    String getLocation();
6398#/**
     * Gets the exception that caused this problem (if any).
     * 
     * @return The exception that caused this problem or {@code null} if not applicable.
     */
    Exception getException();
6399#/**
     * Gets the message that describes this problem.
     * 
     * @return The message describing this problem, never {@code null}.
     */
    String getMessage();
6400#/**
     * Gets the severity level of this problem.
     * 
     * @return The severity level of this problem, never {@code null}.
     */
    Severity getSeverity();
6401#/**
     * Gets the decrypted server. This is a convenience method to retrieve the first element from {@link #getServers()}.
     * 
     * @return The decrypted server or {@code null}.
     */
    Server getServer();
6402#/**
     * Gets the decrypted servers.
     * 
     * @return The decrypted server, can be empty but never {@code null}.
     */
    List<Server> getServers();
6403#/**
     * Gets the decrypted proxy. This is a convenience method to retrieve the first element from {@link #getProxies()}.
     * 
     * @return The decrypted proxy or {@code null}.
     */
    Proxy getProxy();
6404#/**
     * Gets the decrypted proxies.
     * 
     * @return The decrypted proxy, can be empty but never {@code null}.
     */
    List<Proxy> getProxies();
6405#/**
     * Gets the problems that were encountered during the settings decryption.
     * 
     * @return The problems that were encountered during the decryption, can be empty but never {@code null}.
     */
    List<SettingsProblem> getProblems();
6406#public DefaultSettingsDecryptionResult( List<Server> servers, List<Proxy> proxies, List<SettingsProblem> problems )
    {
        this.servers = ( servers != null ) ? servers : new ArrayList<Server>();
        this.proxies = ( proxies != null ) ? proxies : new ArrayList<Proxy>();
        this.problems = ( problems != null ) ? problems : new ArrayList<SettingsProblem>();
    }
6407#public Server getServer()
    {
        return servers.isEmpty() ? null : servers.get( 0 );
    }
6408#public List<Server> getServers()
    {
        return servers;
    }
6409#public Proxy getProxy()
    {
        return proxies.isEmpty() ? null : proxies.get( 0 );
    }
6410#public List<Proxy> getProxies()
    {
        return proxies;
    }
6411#public List<SettingsProblem> getProblems()
    {
        return problems;
    }
6412#/**
     * Creates an empty request.
     */
    public DefaultSettingsDecryptionRequest()
    {
        // does nothing
    }
6413#/**
     * Creates a new request to decrypt the specified settings.
     * 
     * @param settings The settings to decrypt, must not be {@code null}.
     */
    public DefaultSettingsDecryptionRequest( Settings settings )
    {
        setServers( settings.getServers() );
        setProxies( settings.getProxies() );
    }
6414#/**
     * Creates a new request to decrypt the specified server.
     * 
     * @param server The server to decrypt, must not be {@code null}.
     */
    public DefaultSettingsDecryptionRequest( Server server )
    {
        this.servers = new ArrayList<Server>( Arrays.asList( server ) );
    }
6415#/**
     * Creates a new request to decrypt the specified proxy.
     * 
     * @param proxy The proxy to decrypt, must not be {@code null}.
     */
    public DefaultSettingsDecryptionRequest( Proxy proxy )
    {
        this.proxies = new ArrayList<Proxy>( Arrays.asList( proxy ) );
    }
6416#public List<Server> getServers()
    {
        if ( servers == null )
        {
            servers = new ArrayList<Server>();
        }

        return servers;
    }
6417#public DefaultSettingsDecryptionRequest setServers( List<Server> servers )
    {
        this.servers = servers;

        return this;
    }
6418#public List<Proxy> getProxies()
    {
        if ( proxies == null )
        {
            proxies = new ArrayList<Proxy>();
        }

        return proxies;
    }
6419#public DefaultSettingsDecryptionRequest setProxies( List<Proxy> proxies )
    {
        this.proxies = proxies;

        return this;
    }
6420#/**
     * Gets the servers whose passwords should be decrypted.
     * 
     * @return The servers to decrypt, never {@code null}.
     */
    List<Server> getServers();
6421#/**
     * Sets the servers whose passwords should be decrypted.
     * 
     * @param servers The servers to decrypt, may be {@code null}.
     * @return This request, never {@code null}.
     */
    SettingsDecryptionRequest setServers( List<Server> servers );
6422#/**
     * Gets the proxies whose passwords should be decrypted.
     * 
     * @return The proxies to decrypt, never {@code null}.
     */
    List<Proxy> getProxies();
6423#/**
     * Sets the proxies whose passwords should be decrypted.
     * 
     * @param proxies The proxies to decrypt, may be {@code null}.
     * @return This request, never {@code null}.
     */
    SettingsDecryptionRequest setProxies( List<Proxy> proxies );
6424#public SettingsDecryptionResult decrypt( SettingsDecryptionRequest request )
    {
        List<SettingsProblem> problems = new ArrayList<SettingsProblem>();

        List<Server> servers = new ArrayList<Server>();

        for ( Server server : request.getServers() )
        {
            server = server.clone();

            servers.add( server );

            try
            {
                server.setPassword( decrypt( server.getPassword() ) );
            }
            catch ( SecDispatcherException e )
            {
                problems.add( new DefaultSettingsProblem( "Failed to decrypt password for server " + server.getId()
                    + ": " + e.getMessage(), Severity.ERROR, "server: " + server.getId(), -1, -1, e ) );
            }

            try
            {
                server.setPassphrase( decrypt( server.getPassphrase() ) );
            }
            catch ( SecDispatcherException e )
            {
                problems.add( new DefaultSettingsProblem( "Failed to decrypt passphrase for server " + server.getId()
                    + ": " + e.getMessage(), Severity.ERROR, "server: " + server.getId(), -1, -1, e ) );
            }
        }

        List<Proxy> proxies = new ArrayList<Proxy>();

        for ( Proxy proxy : request.getProxies() )
        {
            proxy = proxy.clone();

            proxies.add( proxy );

            try
            {
                proxy.setPassword( decrypt( proxy.getPassword() ) );
            }
            catch ( SecDispatcherException e )
            {
                problems.add( new DefaultSettingsProblem( "Failed to decrypt password for proxy " + proxy.getId()
                    + ": " + e.getMessage(), Severity.ERROR, "proxy: " + proxy.getId(), -1, -1, e ) );
            }
        }

        return new DefaultSettingsDecryptionResult( servers, proxies, problems );
    }
6425#private String decrypt( String str )
        throws SecDispatcherException
    {
        return ( str == null ) ? null : securityDispatcher.decrypt( str );
    }
6426#/**
     * Decrypts passwords in the settings.
     * 
     * @param request The settings decryption request that holds the parameters, must not be {@code null}.
     * @return The result of the settings decryption, never {@code null}.
     */
    SettingsDecryptionResult decrypt( SettingsDecryptionRequest request );
6427#/**
     * Writes the supplied settings to the specified file. Any non-existing parent directories of the output file will
     * be created automatically.
     * 
     * @param output The file to serialize the settings to, must not be {@code null}.
     * @param options The options to use for serialization, may be {@code null} to use the default values.
     * @param settings The settings to serialize, must not be {@code null}.
     * @throws IOException If the settings could not be serialized.
     */
    void write( File output, Map<String, Object> options, Settings settings )
        throws IOException;
6428#/**
     * Writes the supplied settings to the specified character writer. The writer will be automatically closed before
     * the method returns.
     * 
     * @param output The writer to serialize the settings to, must not be {@code null}.
     * @param options The options to use for serialization, may be {@code null} to use the default values.
     * @param settings The settings to serialize, must not be {@code null}.
     * @throws IOException If the settings could not be serialized.
     */
    void write( Writer output, Map<String, Object> options, Settings settings )
        throws IOException;
6429#/**
     * Writes the supplied settings to the specified byte stream. The stream will be automatically closed before the
     * method returns.
     * 
     * @param output The stream to serialize the settings to, must not be {@code null}.
     * @param options The options to use for serialization, may be {@code null} to use the default values.
     * @param settings The settings to serialize, must not be {@code null}.
     * @throws IOException If the settings could not be serialized.
     */
    void write( OutputStream output, Map<String, Object> options, Settings settings )
        throws IOException;
6430#/**
     * Reads the settings from the specified file.
     * 
     * @param input The file to deserialize the settings from, must not be {@code null}.
     * @param options The options to use for deserialization, may be {@code null} to use the default values.
     * @return The deserialized settings, never {@code null}.
     * @throws IOException If the settings could not be deserialized.
     * @throws SettingsParseException If the input format could not be parsed.
     */
    Settings read( File input, Map<String, ?> options )
        throws IOException, SettingsParseException;
6431#/**
     * Reads the settings from the specified character reader. The reader will be automatically closed before the method
     * returns.
     * 
     * @param input The reader to deserialize the settings from, must not be {@code null}.
     * @param options The options to use for deserialization, may be {@code null} to use the default values.
     * @return The deserialized settings, never {@code null}.
     * @throws IOException If the settings could not be deserialized.
     * @throws SettingsParseException If the input format could not be parsed.
     */
    Settings read( Reader input, Map<String, ?> options )
        throws IOException, SettingsParseException;
6432#/**
     * Reads the settings from the specified byte stream. The stream will be automatically closed before the method
     * returns.
     * 
     * @param input The stream to deserialize the settings from, must not be {@code null}.
     * @param options The options to use for deserialization, may be {@code null} to use the default values.
     * @return The deserialized settings, never {@code null}.
     * @throws IOException If the settings could not be deserialized.
     * @throws SettingsParseException If the input format could not be parsed.
     */
    Settings read( InputStream input, Map<String, ?> options )
        throws IOException, SettingsParseException;
6433#public void write( File output, Map<String, Object> options, Settings settings )
        throws IOException
    {
        if ( output == null )
        {
            throw new IllegalArgumentException( "output file missing" );
        }

        if ( settings == null )
        {
            throw new IllegalArgumentException( "settings missing" );
        }

        output.getParentFile().mkdirs();

        write( WriterFactory.newXmlWriter( output ), options, settings );
    }
6434#public void write( Writer output, Map<String, Object> options, Settings settings )
        throws IOException
    {
        if ( output == null )
        {
            throw new IllegalArgumentException( "output writer missing" );
        }

        if ( settings == null )
        {
            throw new IllegalArgumentException( "settings missing" );
        }

        try
        {
            SettingsXpp3Writer w = new SettingsXpp3Writer();
            w.write( output, settings );
        }
        finally
        {
            IOUtil.close( output );
        }
    }
6435#public void write( OutputStream output, Map<String, Object> options, Settings settings )
        throws IOException
    {
        if ( output == null )
        {
            throw new IllegalArgumentException( "output stream missing" );
        }

        if ( settings == null )
        {
            throw new IllegalArgumentException( "settings missing" );
        }

        try
        {
            String encoding = settings.getModelEncoding();
            if ( encoding == null || encoding.length() <= 0 )
            {
                encoding = "UTF-8";
            }
            write( new OutputStreamWriter( output, encoding ), options, settings );
        }
        finally
        {
            IOUtil.close( output );
        }
    }
6436#public Settings read( File input, Map<String, ?> options )
        throws IOException
    {
        if ( input == null )
        {
            throw new IllegalArgumentException( "input file missing" );
        }

        Settings settings = read( ReaderFactory.newXmlReader( input ), options );

        return settings;
    }
6437#public Settings read( Reader input, Map<String, ?> options )
        throws IOException
    {
        if ( input == null )
        {
            throw new IllegalArgumentException( "input reader missing" );
        }

        try
        {
            SettingsXpp3Reader r = new SettingsXpp3Reader();
            return r.read( input, isStrict( options ) );
        }
        catch ( XmlPullParserException e )
        {
            throw new SettingsParseException( e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e );
        }
        finally
        {
            IOUtil.close( input );
        }
    }
6438#public Settings read( InputStream input, Map<String, ?> options )
        throws IOException
    {
        if ( input == null )
        {
            throw new IllegalArgumentException( "input stream missing" );
        }

        try
        {
            SettingsXpp3Reader r = new SettingsXpp3Reader();
            return r.read( input, isStrict( options ) );
        }
        catch ( XmlPullParserException e )
        {
            throw new SettingsParseException( e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e );
        }
        finally
        {
            IOUtil.close( input );
        }
    }
6439#private boolean isStrict( Map<String, ?> options )
    {
        Object value = ( options != null ) ? options.get( IS_STRICT ) : null;
        return value == null || Boolean.parseBoolean( value.toString() );
    }
6440#/**
     * Creates a new parser exception with the specified details.
     * 
     * @param message The error message, may be {@code null}.
     * @param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.
     * @param columnNumber The one-based index of the column containing the error or {@code -1} if unknown.
     */
    public SettingsParseException( String message, int lineNumber, int columnNumber )
    {
        super( message );
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }
6441#/**
     * Creates a new parser exception with the specified details.
     * 
     * @param message The error message, may be {@code null}.
     * @param lineNumber The one-based index of the line containing the error or {@code -1} if unknown.
     * @param columnNumber The one-based index of the column containing the error or {@code -1} if unknown.
     * @param cause The nested cause of this error, may be {@code null}.
     */
    public SettingsParseException( String message, int lineNumber, int columnNumber, Throwable cause )
    {
        super( message );
        initCause( cause );
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }
6442#/**
     * Gets the one-based index of the line containing the error.
     * 
     * @return The one-based index of the line containing the error or a non-positive value if unknown.
     */
    public int getLineNumber()
    {
        return lineNumber;
    }
6443#/**
     * Gets the one-based index of the column containing the error.
     * 
     * @return The one-based index of the column containing the error or non-positive value if unknown.
     */
    public int getColumnNumber()
    {
        return columnNumber;
    }
6444#/**
     * @param dominant
     * @param recessive
     * @param recessiveSourceLevel
     */
    public void merge( Settings dominant, Settings recessive, String recessiveSourceLevel )
    {
        if ( dominant == null || recessive == null )
        {
            return;
        }

        recessive.setSourceLevel( recessiveSourceLevel );

        List<String> dominantActiveProfiles = dominant.getActiveProfiles();
        List<String> recessiveActiveProfiles = recessive.getActiveProfiles();

        if ( recessiveActiveProfiles != null )
        {
            if ( dominantActiveProfiles == null )
            {
                dominantActiveProfiles = new ArrayList<String>();
                dominant.setActiveProfiles( dominantActiveProfiles );
            }

            for ( String profileId : recessiveActiveProfiles )
            {
                if ( !dominantActiveProfiles.contains( profileId ) )
                {
                    dominantActiveProfiles.add( profileId );
                }
            }
        }

        List<String> dominantPluginGroupIds = dominant.getPluginGroups();

        List<String> recessivePluginGroupIds = recessive.getPluginGroups();

        if ( recessivePluginGroupIds != null )
        {
            if ( dominantPluginGroupIds == null )
            {
                dominantPluginGroupIds = new ArrayList<String>();
                dominant.setPluginGroups( dominantPluginGroupIds );
            }

            for ( String pluginGroupId : recessivePluginGroupIds )
            {
                if ( !dominantPluginGroupIds.contains( pluginGroupId ) )
                {
                    dominantPluginGroupIds.add( pluginGroupId );
                }
            }
        }

        if ( StringUtils.isEmpty( dominant.getLocalRepository() ) )
        {
            dominant.setLocalRepository( recessive.getLocalRepository() );
        }

        shallowMergeById( dominant.getMirrors(), recessive.getMirrors(), recessiveSourceLevel );
        shallowMergeById( dominant.getServers(), recessive.getServers(), recessiveSourceLevel );
        shallowMergeById( dominant.getProxies(), recessive.getProxies(), recessiveSourceLevel );
        shallowMergeById( dominant.getProfiles(), recessive.getProfiles(), recessiveSourceLevel );

    }
6445#/**
     * @param dominant
     * @param recessive
     * @param recessiveSourceLevel
     */
    private static <T extends IdentifiableBase> void shallowMergeById( List<T> dominant, List<T> recessive,
                                                                       String recessiveSourceLevel )
    {
        Map<String, T> dominantById = mapById( dominant );

        for ( T identifiable : recessive )
        {
            if ( !dominantById.containsKey( identifiable.getId() ) )
            {
                identifiable.setSourceLevel( recessiveSourceLevel );

                dominant.add( identifiable );
            }
        }
    }
6446#/**
     * @param identifiables
     * @return a map
     */
    private static <T extends IdentifiableBase> Map<String, T> mapById( List<T> identifiables )
    {
        Map<String, T> byId = new HashMap<String, T>();

        for ( T identifiable : identifiables )
        {
            byId.put( identifiable.getId(), identifiable );
        }

        return byId;
    }
6447#public void validate( Settings settings, SettingsProblemCollector problems )
    {
        if ( settings.isUsePluginRegistry() )
        {
            addViolation( problems, Severity.WARNING, "usePluginRegistry", null, "is deprecated and has no effect." );
        }

        List<String> pluginGroups = settings.getPluginGroups();

        if ( pluginGroups != null )
        {
            for ( int i = 0; i < pluginGroups.size(); i++ )
            {
                String pluginGroup = pluginGroups.get( i ).trim();

                if ( StringUtils.isBlank( pluginGroup ) )
                {
                    addViolation( problems, Severity.ERROR, "pluginGroups.pluginGroup[" + i + "]", null,
                                  "must not be empty" );
                }
                else if ( !pluginGroup.matches( ID_REGEX ) )
                {
                    addViolation( problems, Severity.ERROR, "pluginGroups.pluginGroup[" + i + "]", null,
                                  "must denote a valid group id and match the pattern " + ID_REGEX );
                }
            }
        }

        List<Server> servers = settings.getServers();

        if ( servers != null )
        {
            Set<String> serverIds = new HashSet<String>();

            for ( int i = 0; i < servers.size(); i++ )
            {
                Server server = servers.get( i );

                validateStringNotEmpty( problems, "servers.server[" + i + "].id", server.getId(), null );

                if ( !serverIds.add( server.getId() ) )
                {
                    addViolation( problems, Severity.WARNING, "servers.server.id", null,
                                  "must be unique but found duplicate server with id " + server.getId() );
                }
            }
        }

        List<Mirror> mirrors = settings.getMirrors();

        if ( mirrors != null )
        {
            for ( Mirror mirror : mirrors )
            {
                validateStringNotEmpty( problems, "mirrors.mirror.id", mirror.getId(), mirror.getUrl() );

                validateBannedCharacters( problems, "mirrors.mirror.id", Severity.WARNING, mirror.getId(), null,
                                          ILLEGAL_REPO_ID_CHARS );

                if ( "local".equals( mirror.getId() ) )
                {
                    addViolation( problems, Severity.WARNING, "mirrors.mirror.id", null, "must not be 'local'"
                        + ", this identifier is reserved for the local repository"
                        + ", using it for other repositories will corrupt your repository metadata." );
                }

                validateStringNotEmpty( problems, "mirrors.mirror.url", mirror.getUrl(), mirror.getId() );

                validateStringNotEmpty( problems, "mirrors.mirror.mirrorOf", mirror.getMirrorOf(), mirror.getId() );
            }
        }

        List<Profile> profiles = settings.getProfiles();

        if ( profiles != null )
        {
            Set<String> profileIds = new HashSet<String>();

            for ( Profile profile : profiles )
            {
                if ( !profileIds.add( profile.getId() ) )
                {
                    addViolation( problems, Severity.WARNING, "profiles.profile.id", null,
                                  "must be unique but found duplicate profile with id " + profile.getId() );
                }

                String prefix = "profiles.profile[" + profile.getId() + "].";

                validateRepositories( problems, profile.getRepositories(), prefix + "repositories.repository" );
                validateRepositories( problems, profile.getPluginRepositories(), prefix
                    + "pluginRepositories.pluginRepository" );
            }
        }
    }
6448#private void validateRepositories( SettingsProblemCollector problems, List<Repository> repositories, String prefix )
    {
        Set<String> repoIds = new HashSet<String>();

        for ( Repository repository : repositories )
        {
            validateStringNotEmpty( problems, prefix + ".id", repository.getId(), repository.getUrl() );

            validateBannedCharacters( problems, prefix + ".id", Severity.WARNING, repository.getId(), null,
                                      ILLEGAL_REPO_ID_CHARS );

            if ( "local".equals( repository.getId() ) )
            {
                addViolation( problems, Severity.WARNING, prefix + ".id", null, "must not be 'local'"
                    + ", this identifier is reserved for the local repository"
                    + ", using it for other repositories will corrupt your repository metadata." );
            }

            if ( !repoIds.add( repository.getId() ) )
            {
                addViolation( problems, Severity.WARNING, prefix + ".id", null,
                              "must be unique but found duplicate repository with id " + repository.getId() );
            }

            validateStringNotEmpty( problems, prefix + ".url", repository.getUrl(), repository.getId() );

            if ( "legacy".equals( repository.getLayout() ) )
            {
                addViolation( problems, Severity.WARNING, prefix + ".layout", repository.getId(),
                              "uses the unsupported value 'legacy', artifact resolution might fail." );
            }
        }
    }
6449#// ----------------------------------------------------------------------
    // Field validation
    // ----------------------------------------------------------------------

    /**
     * Asserts:
     * <p/>
     * <ul>
     * <li><code>string.length != null</code>
     * <li><code>string.length > 0</code>
     * </ul>
     */
    private boolean validateStringNotEmpty( SettingsProblemCollector problems, String fieldName, String string,
                                            String sourceHint )
    {
        if ( !validateNotNull( problems, fieldName, string, sourceHint ) )
        {
            return false;
        }

        if ( string.length() > 0 )
        {
            return true;
        }

        addViolation( problems, Severity.ERROR, fieldName, sourceHint, "is missing" );

        return false;
    }
6450#/**
     * Asserts:
     * <p/>
     * <ul>
     * <li><code>string != null</code>
     * </ul>
     */
    private boolean validateNotNull( SettingsProblemCollector problems, String fieldName, Object object,
                                     String sourceHint )
    {
        if ( object != null )
        {
            return true;
        }

        addViolation( problems, Severity.ERROR, fieldName, sourceHint, "is missing" );

        return false;
    }
6451#private boolean validateBannedCharacters( SettingsProblemCollector problems, String fieldName, Severity severity,
                                              String string, String sourceHint, String banned )
    {
        if ( string != null )
        {
            for ( int i = string.length() - 1; i >= 0; i-- )
            {
                if ( banned.indexOf( string.charAt( i ) ) >= 0 )
                {
                    addViolation( problems, severity, fieldName, sourceHint,
                                  "must not contain any of these characters " + banned + " but found "
                                      + string.charAt( i ) );
                    return false;
                }
            }
        }

        return true;
    }
6452#private void addViolation( SettingsProblemCollector problems, Severity severity, String fieldName,
                               String sourceHint, String message )
    {
        StringBuilder buffer = new StringBuilder( 256 );
        buffer.append( '\'' ).append( fieldName ).append( '\'' );

        if ( sourceHint != null )
        {
            buffer.append( " for " ).append( sourceHint );
        }

        buffer.append( ' ' ).append( message );

        problems.add( severity, buffer.toString(), -1, -1, null );
    }
6453#/**
     * Validate the specified settings.
     * 
     * @param settings The settings to validate, must not be {@code null}.
     * @param problems The container used to collect problems that were encountered, must not be {@code null}.
     */
    void validate( Settings settings, SettingsProblemCollector problems );
6454#private File getSettings( String name )
    {
        return new File( "src/test/resources/settings/factory/" + name + ".xml" ).getAbsoluteFile();
    }
6455#public void testCompleteWiring()
        throws Exception
    {
        SettingsBuilder builder = new DefaultSettingsBuilderFactory().newInstance();
        assertNotNull( builder );

        DefaultSettingsBuildingRequest request = new DefaultSettingsBuildingRequest();
        request.setSystemProperties( System.getProperties() );
        request.setUserSettingsFile( getSettings( "simple" ) );

        SettingsBuildingResult result = builder.build( request );
        assertNotNull( result );
        assertNotNull( result.getEffectiveSettings() );
    }
6456#protected void setUp()
        throws Exception
    {
        super.setUp();

        validator = new DefaultSettingsValidator();
    }
6457#protected void tearDown()
        throws Exception
    {
        validator = null;

        super.tearDown();
    }
6458#private void assertContains( String msg, String substring )
    {
        assertTrue( "\"" + substring + "\" was not found in: " + msg, msg.contains( substring ) );
    }
6459#public void testValidate()
    {
        Settings model = new Settings();
        Profile prof = new Profile();
        prof.setId( "xxx" );
        model.addProfile( prof );
        SimpleProblemCollector problems = new SimpleProblemCollector();
        validator.validate( model, problems );
        assertEquals( 0, problems.messages.size() );

        Repository repo = new Repository();
        prof.addRepository( repo );
        problems = new SimpleProblemCollector();
        validator.validate( model, problems );
        assertEquals( 2, problems.messages.size() );

        repo.setUrl( "http://xxx.xxx.com" );
        problems = new SimpleProblemCollector();
        validator.validate( model, problems );
        assertEquals( 1, problems.messages.size() );

        repo.setId( "xxx" );
        problems = new SimpleProblemCollector();
        validator.validate( model, problems );
        assertEquals( 0, problems.messages.size() );
    }
6460#public void testValidateMirror()
        throws Exception
    {
        Settings settings = new Settings();
        Mirror mirror = new Mirror();
        mirror.setId( "local" );
        settings.addMirror( mirror );
        mirror = new Mirror();
        mirror.setId( "illegal\\:/chars" );
        mirror.setUrl( "http://void" );
        mirror.setMirrorOf( "void" );
        settings.addMirror( mirror );

        SimpleProblemCollector problems = new SimpleProblemCollector();
        validator.validate( settings, problems );
        assertEquals( 4, problems.messages.size() );
        assertContains( problems.messages.get( 0 ), "'mirrors.mirror.id' must not be 'local'" );
        assertContains( problems.messages.get( 1 ), "'mirrors.mirror.url' for local is missing" );
        assertContains( problems.messages.get( 2 ), "'mirrors.mirror.mirrorOf' for local is missing" );
        assertContains( problems.messages.get( 3 ), "'mirrors.mirror.id' must not contain any of these characters" );
    }
6461#public void testValidateRepository()
        throws Exception
    {
        Profile profile = new Profile();
        Repository repo = new Repository();
        repo.setId( "local" );
        profile.addRepository( repo );
        repo = new Repository();
        repo.setId( "illegal\\:/chars" );
        repo.setUrl( "http://void" );
        profile.addRepository( repo );
        Settings settings = new Settings();
        settings.addProfile( profile );

        SimpleProblemCollector problems = new SimpleProblemCollector();
        validator.validate( settings, problems );
        assertEquals( 3, problems.messages.size() );
        assertContains( problems.messages.get( 0 ),
                        "'profiles.profile[default].repositories.repository.id' must not be 'local'" );
        assertContains( problems.messages.get( 1 ),
                        "'profiles.profile[default].repositories.repository.url' for local is missing" );
        assertContains( problems.messages.get( 2 ),
                        "'profiles.profile[default].repositories.repository.id' must not contain any of these characters" );
    }
6462#public void testValidateUniqueServerId()
        throws Exception
    {
        Settings settings = new Settings();
        Server server1 = new Server();
        server1.setId( "test" );
        settings.addServer( server1 );
        Server server2 = new Server();
        server2.setId( "test" );
        settings.addServer( server2 );

        SimpleProblemCollector problems = new SimpleProblemCollector();
        validator.validate( settings, problems );
        assertEquals( 1, problems.messages.size() );
        assertContains( problems.messages.get( 0 ),
                        "'servers.server.id' must be unique but found duplicate server with id test" );
    }
6463#public void testValidateUniqueProfileId()
        throws Exception
    {
        Settings settings = new Settings();
        Profile profile1 = new Profile();
        profile1.setId( "test" );
        settings.addProfile( profile1 );
        Profile profile2 = new Profile();
        profile2.setId( "test" );
        settings.addProfile( profile2 );

        SimpleProblemCollector problems = new SimpleProblemCollector();
        validator.validate( settings, problems );
        assertEquals( 1, problems.messages.size() );
        assertContains( problems.messages.get( 0 ),
                        "'profiles.profile.id' must be unique but found duplicate profile with id test" );
    }
6464#public void testValidateUniqueRepositoryId()
        throws Exception
    {
        Settings settings = new Settings();
        Profile profile = new Profile();
        profile.setId( "pro" );
        settings.addProfile( profile );
        Repository repo1 = new Repository();
        repo1.setUrl( "http://apache.org/" );
        repo1.setId( "test" );
        profile.addRepository( repo1 );
        Repository repo2 = new Repository();
        repo2.setUrl( "http://apache.org/" );
        repo2.setId( "test" );
        profile.addRepository( repo2 );

        SimpleProblemCollector problems = new SimpleProblemCollector();
        validator.validate( settings, problems );
        assertEquals( 1, problems.messages.size() );
        assertContains( problems.messages.get( 0 ), "'profiles.profile[pro].repositories.repository.id' must be unique"
            + " but found duplicate repository with id test" );
    }
6465#public void add( Severity severity, String message, int line, int column, Exception cause )
        {
            messages.add( message );
        }
6466#public RuntimeInfo()
    {
        this.settings = DEFAULT_USER_SETTINGS_FILE;
    }
6467#public RuntimeInfo( File settings )
    {
        this.settings = settings;
    }
6468#public File getFile()
    {
        return settings;
    }
