13600#/** 
     * <p>In this method you can call, for example:
     * <code>Request req=ObjectModelHelper.getRequest(env.getObjectModel());</code>
     * And then, you could use the following:
     * <ul>
     * <li>req.getRequestURI()</li>
     * <li>req.getQueryString()</li>
     * <li>req.getSession().getId()</li>
     * <li>req.getLocale().getLanguage().toString()</li>
     * </ul>
     * <p>
     * @param environment as supplied to {@link Processor#process(Environment)}
     *                    from within {@link Cocoon#process(Environment)}.
     */
    public void onRequestStart(Environment environment);
13601#/** 
     * <p>This method is called when a request has completed. This method is
     * called before the response is committed.
     * @param environment as supplied to {@link Processor#process(Environment)}
     *                    from within {@link Cocoon#process(Environment)}.
     */
    public void onRequestEnd(Environment environment);
13602#/** 
     * <p>This method is called when an exception has occurred processing the request.
     * @param environment as supplied to {@link Processor#process(Environment)}
     *                    from within {@link Cocoon#process(Environment)}.
     * @param throwable the error that occurred processing the request.
     */
    public void onRequestException(Environment environment, Throwable throwable);
13603#public void service(ServiceManager manager) throws ServiceException {
        super.service(manager);
        this.resolver = (SourceResolver)manager.lookup(SourceResolver.ROLE);
    }
13604#public Map act(Redirector redirector, org.apache.cocoon.environment.SourceResolver oldResolver, Map objectModel, String source, Parameters par)
        throws Exception {

        // Get source and destination Sources
        Source src = resolver.resolveURI(source);
        Source dest = resolver.resolveURI(par.getParameter("dest"));

        // Check that dest is writeable
        if (! (dest instanceof ModifiableSource)) {
            throw new IllegalArgumentException("Non-writeable URI : " + dest.getURI());
        }

        if (dest instanceof TraversableSource) {
            TraversableSource trDest = (TraversableSource) dest;
            if (trDest.isCollection()) {
                if (src instanceof TraversableSource) {
                    dest = trDest.getChild(((TraversableSource)src).getName());
                } else if (src instanceof PartSource){
                    // FIXME : quick hack to store "upload://xxx" sources into directories
                    // it would be better for the PartSource to be Traversable, or to
                    // create a new "NamedSource" interface
                    dest = trDest.getChild(((PartSource)src).getPart().getFileName());
                }
            }
        }

        // And transfer all content.
        try {
            SourceUtil.copy(src, dest);
        } finally {
            resolver.release(src);
            resolver.release(dest);
        }
        // Success !
        return EMPTY_MAP;
    }
13605#/**
     * Configure this action.
     *
     * @param config configuration information (if any)
     */
    public void configure(Configuration config)
    throws ConfigurationException {
        this.storeInRequest = config.getChild(STORE_REQUEST).getValueAsBoolean(false);
        this.createSession = config.getChild(CREATE_SESSION).getValueAsBoolean(false);
        this.storeInSession = config.getChild(STORE_SESSION).getValueAsBoolean(false);
        this.storeInCookie = config.getChild(STORE_COOKIE).getValueAsBoolean(false);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug((this.storeInRequest ? "will" : "won't") + " set values in request");
            getLogger().debug((this.createSession ? "will" : "won't") + " create session");
            getLogger().debug((this.storeInSession ? "will" : "won't") + " set values in session");
            getLogger().debug((this.storeInCookie ? "will" : "won't") + " set values in cookies");
        }

        this.localeAttribute = config.getChild(LOCALE_ATTR).getValue(LOCALE);
        this.useLocale = config.getChild("use-locale").getValueAsBoolean(true);

        Configuration child = config.getChild("default-locale", false);
        if (child != null) {
            this.defaultLocale = new Locale(child.getAttribute("language", DEFAULT_DEFAULT_LANG),
                                            child.getAttribute("country", DEFAULT_DEFAULT_COUNTRY),
                                            child.getAttribute("variant", DEFAULT_DEFAULT_VARIANT));
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Locale attribute name is " + this.localeAttribute);
            getLogger().debug((this.useLocale ? "will" : "won't") + " use request locale");
            getLogger().debug("default locale " + this.defaultLocale);
        }
    }
13606#/**
     * Action which obtains the current environments locale information, and
     * places it in the objectModel (and optionally in a session/cookie).
     */
    public Map act(Redirector redirector,
                   SourceResolver resolver,
                   Map objectModel,
                   String source,
                   Parameters params)
    throws Exception {
        // Obtain locale information from request, session, cookies, or params
        Locale locale = I18nUtils.findLocale(objectModel,
                                             localeAttribute,
                                             params,
                                             defaultLocale,
                                             useLocale);

        if (locale == null) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("No locale found.");
            }

            return null;
        }

        String localeStr = locale.toString();
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Found locale: " + localeStr);
        }

        I18nUtils.storeLocale(objectModel,
                              localeAttribute,
                              localeStr,
                              storeInRequest,
                              storeInSession,
                              storeInCookie,
                              createSession);

        // Set up a map for sitemap parameters
        Map map = new HashMap();
        map.put("language", locale.getLanguage());
        map.put("country", locale.getCountry());
        map.put("variant", locale.getVariant());
        map.put("locale", localeStr);
        return map;
    }
13607#/**
     * Helper method to retreive the attribute value containing locale
     * information. See class documentation for locale determination algorythm.
     *
     * @deprecated See I18nUtils.findLocale
     * @param objectModel requesting object's environment
     * @return locale value or <code>null</null> if no locale was found
     */
    public static String getLocaleAttribute(Map objectModel,
                                            String localeAttrName) {
        Locale locale = I18nUtils.findLocale(objectModel,
                                             localeAttrName,
                                             null,
                                             null,
                                             true);
        return locale.toString();
    }
13608#/**
     * Constructor for the SimpleCocoonCrawlerImpl object
     */
    public SimpleCocoonCrawlerImpl() {
        // by default include everything
        includeCrawlingURL = null;
        // by default exclude common image patterns
        excludeCrawlingURL = null;
    }
13609#/**
     * Configure the crawler component.
     * <p>
     *  Configure can specify which URI to include, and which URI to exclude
     *  from crawling. You specify the patterns as regular expressions.
     * </p>
     * <p>
     *  Morover you can configure
     *  the required content-type of crawling request, and the
     *  query-string appended to each crawling request.
     * </p>
     * <pre><tt>
     * &lt;include&gt;.*\.html?&lt;/exclude&gt; or &lt;exclude&gt;.*\.html?, .*\.xsp&lt;/exclude&gt;
     * &lt;exclude&gt;.*\.gif&lt;/exclude&gt; or &lt;exclude&gt;.*\.gif, .*\.jpe?g&lt;/exclude&gt;
     * &lt;link-content-type&gt; application/x-cocoon-links &lt;/link-content-type&gt;
     * &lt;link-view-query&gt; ?cocoon-view=links &lt;/link-view-query&gt;
     * </tt></pre>
     *
     * @param  configuration               XML configuration of this avalon component.
     * @exception  ConfigurationException  is throwing if configuration is invalid.
     */
    public void configure(Configuration configuration)
    throws ConfigurationException {

        Configuration[] children;
        children = configuration.getChildren(INCLUDE_CONFIG);
        if (children.length > 0) {
            includeCrawlingURL = new HashSet();
            for (int i = 0; i < children.length; i++) {
                String pattern = children[i].getValue();
                try {
                    String params[] = StringUtils.split(pattern, ", ");
                    for (int index = 0; index < params.length; index++) {
                        String tokenized_pattern = params[index];
                        this.includeCrawlingURL.add(new RE(tokenized_pattern));
                    }
                } catch (RESyntaxException rese) {
                    getLogger().error("Cannot create including regular-expression for " +
                    pattern, rese);
                }
            }
        } else {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Include all URLs");
            }
        }

        children = configuration.getChildren(EXCLUDE_CONFIG);
        if (children.length > 0) {
            excludeCrawlingURL = new HashSet();
            for (int i = 0; i < children.length; i++) {
                String pattern = children[i].getValue();
                try {
                    String params[] = StringUtils.split(pattern, ", ");
                    for (int index = 0; index < params.length; index++) {
                        String tokenized_pattern = params[index];
                        this.excludeCrawlingURL.add(new RE(tokenized_pattern));
                    }
                } catch (RESyntaxException rese) {
                    getLogger().error("Cannot create excluding regular-expression for " +
                    pattern, rese);
                }
            }
        } else {
            excludeCrawlingURL = new HashSet();
            setDefaultExcludeFromCrawling();
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Exclude default URLs only");
            }
        }

        Configuration child;
        String value;
        child = configuration.getChild(LINK_CONTENT_TYPE_CONFIG, false);
        if (child != null) {
            value = child.getValue();
            if (value != null && value.length() > 0) {
                this.linkContentType = value.trim();
            }
        }
        child = configuration.getChild(LINK_VIEW_QUERY_CONFIG, false);
        if (child != null) {
            value = child.getValue();
            if (value != null && value.length() > 0) {
                this.linkViewQuery = value.trim();
            }
        }

        child = configuration.getChild(USER_AGENT_CONFIG, false);
        if (child != null) {
            value = child.getValue();
            if (value != null && value.length() > 0) {
                this.userAgent = value;
            }
        }

        child = configuration.getChild(ACCEPT_CONFIG, false);
        if (child != null) {
            value = child.getValue();
            if (value != null && value.length() > 0) {
                this.accept = value;
            }
        }
    }
13610#/**
     * dispose at end of life cycle, releasing all resources.
     */
    public void dispose() {
        crawled = null;
        urlsToProcess = null;
        urlsNextDepth = null;
        excludeCrawlingURL = null;
        includeCrawlingURL = null;
    }
13611#/**
     * recylcle this object, relasing resources
     */
    public void recycle() {
        crawled = null;
        urlsToProcess = null;
        urlsNextDepth = null;
        depth = -1;
    }
13612#/**
     * The same as calling crawl(url,-1);
     *
     * @param  url  Crawl this URL, getting all links from this URL.
     */
    public void crawl(URL url) {
        crawl(url, -1);
    }
13613#/**
     * Start crawling a URL.
     *
     * <p>
     *   Use this method to start crawling.
     *   Get the this url, and all its children  by using <code>iterator()</code>.
     *   The Iterator object will return URL objects.
     * </p>
     * <p>
     *  You may use the crawl(), and iterator() methods the following way:
     * </p>
     * <pre><tt>
     *   SimpleCocoonCrawlerImpl scci = ....;
     *   scci.crawl( "http://foo/bar" );
     *   Iterator i = scci.iterator();
     *   while (i.hasNext()) {
     *     URL url = (URL)i.next();
     *     ...
     *   }
     * </tt></pre>
     * <p>
     *   The i.next() method returns a URL, and calculates the links of the
     *   URL before return it.
     * </p>
     *
     * @param  url  Crawl this URL, getting all links from this URL.
     * @param  maxDepth  maximum depth to crawl to. -1 for no maximum.
     */
    public void crawl(URL url, int maxDepth) {
        crawled = new HashSet();
        urlsToProcess = new HashSet();
        urlsNextDepth = new HashSet();
        depth = maxDepth;
        
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("crawl URL " + url + " to depth " + maxDepth);
        }
        urlsToProcess.add(url);
    }
13614#/**
     * Return iterator, iterating over all links of the currently crawled URL.
     * <p>
     *   The Iterator object will return URL objects at its <code>next()</code>
     *   method.
     * </p>
     *
     * @return    Iterator iterator of all links from the crawl URL.
     * @since
     */
    public Iterator iterator() {
        return new CocoonCrawlerIterator(this);
    }
13615#/**
     * Default exclude patterns.
     * <p>
     *   By default URLs matching following patterns are excluded:
     * </p>
     * <ul>
     *   <li>.*\\.gif(\\?.*)?$ - exclude gif images</li>
     *   <li>.*\\.png(\\?.*)?$ - exclude png images</li>
     *   <li>.*\\.jpe?g(\\?.*)?$ - exclude jpeg images</li>
     *   <li>.*\\.js(\\?.*)?$ - exclude javascript </li>
     *   <li>.*\\.css(\\?.*)?$ - exclude cascaded stylesheets</li>
     * </ul>
     *
     * @since
     */
    private void setDefaultExcludeFromCrawling() {
        String[] EXCLUDE_FROM_CRAWLING_DEFAULT = {
            ".*\\.gif(\\?.*)?$",
            ".*\\.png(\\?.*)?$",
            ".*\\.jpe?g(\\?.*)?$",
            ".*\\.js(\\?.*)?$",
            ".*\\.css(\\?.*)?$"
        };

        for (int i = 0; i < EXCLUDE_FROM_CRAWLING_DEFAULT.length; i++) {
            String pattern = EXCLUDE_FROM_CRAWLING_DEFAULT[i];
            try {
                excludeCrawlingURL.add(new RE(pattern));
            } catch (RESyntaxException rese) {
                getLogger().error("Cannot create excluding regular-expression for " +
                pattern, rese);
            }
        }
    }
13616#/**
     * Compute list of links from the url.
     * <p>
     *   Check for include, exclude pattern, content-type, and if url
     *   has been craweled already.
     * </p>
     *
     * @param  url  Crawl this URL
     * @return      List of URLs, which are links from url, asserting the conditions.
     * @since
     */
    private List getLinks(URL url) {
        String sURL = url.toString();
        if (!isIncludedURL(sURL) || isExcludedURL(sURL)) {
            return null;
        }

        // don't try to get links for url which has been crawled already
        if (crawled.contains(sURL)) {
            return null;
        }

        // mark it as crawled
        crawled.add(sURL);

        // get links of url
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Getting links of URL " + sURL);
        }

        ArrayList url_links = null;
        BufferedReader br = null;
        try {
            sURL = url.getFile();
            URL links = new URL(url, sURL
            + ((sURL.indexOf("?") == -1) ? "?" : "&")
            + linkViewQuery);
            URLConnection links_url_connection = links.openConnection();
            links_url_connection.setRequestProperty("Accept", accept);
            links_url_connection.setRequestProperty("User-Agent", userAgent);
            links_url_connection.connect();
            InputStream is = links_url_connection.getInputStream();
            br = new BufferedReader(new InputStreamReader(is));

            String contentType = links_url_connection.getContentType();
            if (contentType == null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Ignoring " + sURL + " (no content type)");
                }
                // there is a check on null in the calling method
                return null;
            }

            int index = contentType.indexOf(';');
            if (index != -1) {
                contentType = contentType.substring(0, index);
            }

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Content-type: " + contentType);
            }

            if (contentType.equals(linkContentType)) {
                url_links = new ArrayList();

                // content is supposed to be a list of links,
                // relative to current URL
                String line;
                while ((line = br.readLine()) != null) {
                    final URL newUrl = new URL(url, line);
                    final String sNewUrl = newUrl.toString();

                    boolean add_url = true;
                    // don't add new_url twice
                    if (add_url) {
                        add_url &= !url_links.contains(sNewUrl);
                    }

                    // don't add new_url if it has been crawled already
                    if (add_url) {
                        add_url &= !crawled.contains(sNewUrl);
                    }

                    // don't add if is not matched by existing include definition
                    if (add_url) {
                        add_url &= isIncludedURL(sNewUrl);
                    }

                    // don't add if is matched by existing exclude definition
                    if (add_url) {
                        add_url &= !isExcludedURL(sNewUrl);
                    }
                    if (add_url) {
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("Add URL: " + sNewUrl);
                        }
                        url_links.add(newUrl);
                    }
                }
                // now we have a list of URL which should be examined
            }
        } catch (IOException ioe) {
            getLogger().warn("Problems get links of " + url, ioe);
        } finally {
            if (br != null) {
                try {
                    br.close();
                } catch (IOException ignored) {
                }
            }
        }
        return url_links;
    }
13617#/**
     * check if URL is a candidate for indexing
     *
     * @param  url  the URL to check
     * @return      The excludedURL value
     */
    private boolean isExcludedURL(String url) {
        // by default do not exclude URL for crawling
        if (excludeCrawlingURL == null) {
            return false;
        }

        Iterator i = excludeCrawlingURL.iterator();
        while (i.hasNext()) {
            RE pattern = (RE) i.next();
            if (pattern.match(url)) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Excluded URL " + url);
                }
                return true;
            }
        }
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Not excluded URL " + url);
        }
        return false;
    }
13618#/**
     * check if URL is a candidate for indexing
     *
     * @param  url  Description of Parameter
     * @return      The includedURL value
     */
    private boolean isIncludedURL(String url) {
        // by default include URL for crawling
        if (includeCrawlingURL == null) {
            return true;
        }

        Iterator i = includeCrawlingURL.iterator();
        while (i.hasNext()) {
            RE pattern = (RE) i.next();
            if (pattern.match(url)) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Included URL " + url);
                }
                return true;
            }
        }
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Not included URL " + url);
        }
        return false;
    }
13619#/**
         * Constructor for the CocoonCrawlerIterator object
         *
         * @param  cocoonCrawler  the containing CocoonCrawler instance.
         */
        CocoonCrawlerIterator(SimpleCocoonCrawlerImpl cocoonCrawler) {
            this.cocoonCrawler = cocoonCrawler;
        }
13620#/**
         * check if crawling is finished.
         *
         * @return    <code>true</code> if crawling has finished,
         * else <code>false</code>.
         */
        public boolean hasNext() {
            return cocoonCrawler.urlsToProcess.size() > 0
            || cocoonCrawler.urlsNextDepth.size() > 0;
        }
13621#/**
         * @return    the next URL
         */
        public Object next() {
            if (cocoonCrawler.urlsToProcess.size() == 0
            && cocoonCrawler.urlsNextDepth.size() > 0) {
                // process queued urls belonging to the next depth level
                cocoonCrawler.urlsToProcess = cocoonCrawler.urlsNextDepth;
                cocoonCrawler.urlsNextDepth = new HashSet();
                // fix Bugzilla Bug 25270
                // only decrease if depth > 0, excluding decreasing
                // if depth is already equal to -1
                if (cocoonCrawler.depth > 0) {
                    cocoonCrawler.depth--;
                }
            }
            URL theNextUrl = null;
            // fix Bugzilla Bug 25270
            // return NextUrl != null only if getLinks() returns non-null
            // list
            for (Iterator i = cocoonCrawler.urlsToProcess.iterator(); 
              i.hasNext() && theNextUrl == null;) {
                // fetch a URL
                URL url = (URL) i.next();

                // remove it from the to-do list
                i.remove();

                if (cocoonCrawler.depth == -1 || cocoonCrawler.depth > 0) {
                    // calc all links from this url
                    List url_links = cocoonCrawler.getLinks(url);
                    if (url_links != null) {
                        // add links of this url to the to-do list
                        cocoonCrawler.urlsNextDepth.addAll(url_links);
                        theNextUrl = url;
                    }
                }
            }
            // finally return url
            return theNextUrl;
        }
13622#/**
         * remove is not implemented
         */
        public void remove() {
            throw new UnsupportedOperationException("remove is not implemented");
        }
13623#/**
     * This is the same as calling crawl(url,-1);
     *
     * @param  url  The URL to start crawling from.
     */
    void crawl(URL url);
13624#/**
     * start crawling the URL.
     * <p>
     *   Calling this method initiates the crawling and tells the
     *   crawler not to crawl beyond a maximum depth.
     * </p>
     * 
	 * @param url  The URL to start crawling from
	 * @param maxDepth  The maximum depth to crawl to. -1 for no maxiumum.
	 */
    void crawl(URL url, int maxDepth);
13625#/**
     * Iterate over crawling URLs.
     * <p>
     *   This iterator will returns URL as result of crawling
     *   the base URL passed via crawling().
     * </p>
     *
     * @return    Iterator iterates over crawling URLs.
     */
    Iterator iterator();
13626#/* (non-Javadoc)
     * @see org.apache.avalon.framework.context.Contextualizable#contextualize(org.apache.avalon.framework.context.Context)
     */
    public void contextualize(Context context) throws ContextException {
        this.context = context;
    }
13627#/* (non-Javadoc)
     * @see org.apache.cocoon.components.persistance.RequestDataStore#getGlobalRequestData(java.lang.String)
     */
    public Object getGlobalRequestData(String key) {
        Object value = null;
        final Map objectModel = ContextHelper.getObjectModel(this.context);
        Map m = (Map)objectModel.get(this.globalRequestDataKey);
        if ( m != null ) {
            value = m.get( key );
        }
        return value;
    }
13628#/* (non-Javadoc)
     * @see org.apache.cocoon.components.persistance.RequestDataStore#getRequestData(java.lang.String)
     */
    public Object getRequestData(String key) {
        Object value = null;
        final Map objectModel = ContextHelper.getObjectModel(this.context);
        Map m = (Map)objectModel.get(this.requestDataKey + ObjectModelHelper.getRequest(objectModel).hashCode());
        if ( m != null ) {
            value = m.get( key );
        }
        return value;
    }
13629#/* (non-Javadoc)
     * @see org.apache.cocoon.components.persistance.RequestDataStore#removeGlobalRequestData(java.lang.String)
     */
    public void removeGlobalRequestData(String key) {
        final Map objectModel = ContextHelper.getObjectModel(this.context);
        Map m = (Map)objectModel.get(this.globalRequestDataKey);
        if ( m != null ) {
            objectModel.remove( key );
        }
    }
13630#/* (non-Javadoc)
     * @see org.apache.cocoon.components.persistance.RequestDataStore#removeRequestData(java.lang.String)
     */
    public void removeRequestData(String key) {
        final Map objectModel = ContextHelper.getObjectModel(this.context);
        Map m = (Map)objectModel.get(this.requestDataKey + ObjectModelHelper.getRequest(objectModel).hashCode());
        if ( m != null ) {
            objectModel.remove( key );
        }
    }
13631#/* (non-Javadoc)
     * @see org.apache.cocoon.components.persistance.RequestDataStore#setGlobalRequestData(java.lang.String, java.lang.Object)
     */
    public void setGlobalRequestData(String key, Object value) {
        final Map objectModel = ContextHelper.getObjectModel(this.context);
        Map m = (Map)objectModel.get(this.globalRequestDataKey);
        if ( m == null ) {
            m = new HashMap();
            objectModel.put(this.globalRequestDataKey, m);
        }
        m.put(key, value);
    }
13632#/* (non-Javadoc)
     * @see org.apache.cocoon.components.persistance.RequestDataStore#setRequestData(java.lang.String, java.lang.Object)
     */
    public void setRequestData(String key, Object value) {
        final Map objectModel = ContextHelper.getObjectModel(this.context);
        Map m = (Map)objectModel.get(this.requestDataKey + ObjectModelHelper.getRequest(objectModel).hashCode());
        if ( m == null ) {
            m = new HashMap();
            objectModel.put(this.requestDataKey + ObjectModelHelper.getRequest(objectModel).hashCode(), m);
        }
        m.put(key, value);
    }
13633#Object getRequestData(String key);
13634#void removeRequestData(String key);
13635#void setRequestData(String key, Object value);
13636#Object getGlobalRequestData(String key);
13637#void removeGlobalRequestData(String key);
13638#void setGlobalRequestData(String key, Object value);
13639#/**
     * @see Contextualizable#contextualize(org.apache.avalon.framework.context.Context)
     */
    public void contextualize(Context context)
    throws ContextException {
        try {
            if (context.get("context-root") instanceof URL) {
                this.baseURL = (URL) context.get("context-root");
            } else {
                this.baseURL = ((File) context.get("context-root")).toURL();
            }
        } catch( ContextException ce ) {
            // set the base URL to the current directory
            try {
                this.baseURL = new File( System.getProperty( "user.dir" ) ).toURL();
                if (this.getLogger().isDebugEnabled()) {
                    this.getLogger().debug("SourceResolver: Using base URL: " + this.baseURL);
                }
            } catch (MalformedURLException mue) {
                throw new ContextException("Malformed URL for user.dir, and no container.rootDir exists", mue);
            }
        } catch (MalformedURLException mue) {
            throw new ContextException("Malformed URL for container.rootDir", mue);
        }
    }
13640#/**
     * @see SourceResolver#resolveURI(java.lang.String, java.lang.String, java.util.Map)
     * @throws MalformedURLException if unable to parse location URI
     */
    public Source resolveURI(String location, String baseURI, Map parameters)
    throws IOException {
        if (baseURI == null) {
            final Processor processor = EnvironmentHelper.getCurrentProcessor();
            if (processor != null) {
                baseURI = processor.getContext();
            }
        }
        if (this.customResolver != null) {
            return this.customResolver.resolveURI(location, baseURI, parameters);
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Resolving '" + location + "' with base '" + baseURI + "' in context '" + this.baseURL + "'");
        }
        if (location == null) {
            throw new MalformedURLException("Invalid System ID");
        }
        if (baseURI != null && org.apache.excalibur.source.SourceUtil.indexOfSchemeColon(baseURI) == -1) {
            throw new MalformedURLException("BaseURI is not valid, it must contain a protocol: " + baseURI);
        }

        if (baseURI == null) {
            baseURI = this.baseURL.toExternalForm();
        }

        String systemID = location;
        // special handling for windows file paths
        if (location.length() > 1 && location.charAt(1) == ':') {
            systemID = "file:/" + location;
        } else if (location.length() > 2 && location.charAt(0) == '/' && location.charAt(2) == ':') {
            systemID = "file:" + location;
        }

        // determine protocol (scheme): first try to get the one of the systemID, if that fails, take the one of the baseURI
        String protocol;
        int protocolPos = org.apache.excalibur.source.SourceUtil.indexOfSchemeColon(systemID);
        if (protocolPos != -1) {
            protocol = systemID.substring(0, protocolPos);
        } else {
            protocolPos = org.apache.excalibur.source.SourceUtil.indexOfSchemeColon(baseURI);
            if (protocolPos != -1) {
                protocol = baseURI.substring(0, protocolPos);
            } else {
                protocol = "*";
            }
        }

        final ServiceManager m = this.getComponentLocator();

        Source source = null;
        // search for a SourceFactory implementing the protocol
        SourceFactory factory = null;
        try {
            factory = this.getSourceFactory(m, protocol);
            systemID = this.absolutize(factory, baseURI, systemID);
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Resolved to systemID : " + systemID);
            }
            source = factory.getSource(systemID, parameters);
        } catch (final ProcessingException ce) {
            // no selector available, use fallback
        } finally {
            m.release(factory);
        }

        if (null == source) {
            try {
                factory = this.getSourceFactory(m, "*");
                systemID = this.absolutize(factory, baseURI, systemID);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Resolved to systemID : " + systemID);
                }
                source = factory.getSource(systemID, parameters);
            } catch (ProcessingException se) {
                throw new SourceException("Unable to select source factory for " + systemID, se);
            } finally {
                m.release(factory);
            }
        }

        return source;
    }
13641#/**
     * @see SourceResolver#resolveURI(java.lang.String)
     * @throws MalformedURLException if unable to parse location URI
     */
    public Source resolveURI(String location) throws IOException {
        return resolveURI(location, null, null);
    }
13642#/** 
     * Obtain a reference to the SourceResolver with "/Cocoon" hint
     * 
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
        if (this.manager.hasService(org.apache.excalibur.source.SourceResolver.ROLE + "/Cocoon")) {
            this.customResolver = (org.apache.excalibur.source.SourceResolver)
                    this.manager.lookup(org.apache.excalibur.source.SourceResolver.ROLE + "/Cocoon");
        }
    }
13643#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        if (this.manager != null) {
            this.manager.release(this.customResolver);
            this.customResolver = null;
            this.manager = null;
        }
    }
13644#/**
     * Get the component locator.
     */
    protected ServiceManager getComponentLocator() {
        ServiceManager l = EnvironmentHelper.getSitemapServiceManager();
        if (l == null) {
            l = this.manager;
        }
        return l;
    }
13645#/**
     * Get the SourceFactory
     */
    protected SourceFactory getSourceFactory(ServiceManager m, String scheme) 
    throws ProcessingException {
        try {
            return (SourceFactory) m.lookup(SourceFactory.ROLE + '/' + scheme);
        } catch (ServiceException se) {
            throw new ProcessingException("Unable to lookup source factory for scheme: " + scheme, se);
        }
    }
13646#/**
     * @see org.apache.excalibur.source.SourceResolver#release(org.apache.excalibur.source.Source)
     */
    public void release(Source source) {
        if (source == null) {
            return;
        }

        if (this.customResolver != null) {
            this.customResolver.release(source);
        } else {
            final ServiceManager m = this.getComponentLocator();

            // search for a SourceFactory implementing the protocol
            final String scheme = source.getScheme();
            SourceFactory factory = null;

            try {
                factory = this.getSourceFactory(m, scheme);
                factory.release(source);
            } catch (ProcessingException se) {
                try {
                    factory = this.getSourceFactory(m, "*");
                    factory.release(source);
                } catch (ProcessingException sse) {
                    throw new SourceFactoryNotFoundException("Unable to select source factory for " + source.getURI(), se);
                }
            } finally {
                m.release(factory);
            }
        }
    }
13647#/**
     * Makes an absolute URI based on a baseURI and a relative URI.
     */
    protected String absolutize(SourceFactory factory, String baseURI, String systemID) {
        if (factory instanceof URIAbsolutizer) {
            systemID = ((URIAbsolutizer) factory).absolutize(baseURI, systemID);
        } else {
            systemID = org.apache.excalibur.source.SourceUtil.absolutize(baseURI, systemID);
        }

        return systemID;
    }
13648#public SourceFactoryNotFoundException(String message)
    {
        super(message, null);
    }
13649#public SourceFactoryNotFoundException(String message, Throwable cause)
    {
        super(message, cause);
    }
13650#/**
     * Get the current sitemap component manager.
     * This method returns the current sitemap component manager. This
     * is the manager that holds all the components of the currently
     * processed (sub)sitemap.
     * @deprecated This method will be removed.
     */
    static private ServiceManager getSitemapServiceManager() {
        return EnvironmentHelper.getSitemapServiceManager(); 
    }
13651#/**
     * Generates SAX events from the given source.
     *
     * <p><b>NOTE</b>: If the implementation can produce lexical events,
     * care should be taken that <code>handler</code> can actually
     * directly implement the LexicalHandler interface!</p>
     *
     * @param  source    the data
     * @throws ProcessingException if no suitable converter is found
     */
    static public void toSAX(Source         source,
                             ContentHandler handler)
    throws SAXException, IOException, ProcessingException {
        toSAX(getSitemapServiceManager(),
              source, null, handler);
    }
13652#/**
     * Generates SAX events from the given source by using XMLizer.
     * Current sitemap manager will be used to lookup XMLizer.
     *
     * <p><b>NOTE</b>: If the implementation can produce lexical events,
     * care should be taken that <code>handler</code> can actually
     * directly implement the LexicalHandler interface!</p>
     *
     * @param  source    the data
     * @throws ProcessingException if no suitable converter is found
     */
    static public void toSAX(Source         source,
                             String         mimeTypeHint,
                             ContentHandler handler)
    throws SAXException, IOException, ProcessingException {
        toSAX(getSitemapServiceManager(),
              source, mimeTypeHint, handler);
    }
13653#/**
     * Generates SAX events from the given source with possible URL rewriting.
     *
     * <p><b>NOTE</b>: If the implementation can produce lexical events,
     * care should be taken that <code>handler</code> can actually
     * directly implement the LexicalHandler interface!</p>
     *
     * @param  source    the data
     * @throws ProcessingException if no suitable converter is found
     */
    static public void toSAX(Source source,
                             ContentHandler handler,
                             Parameters typeParameters,
                             boolean filterDocumentEvent)
    throws SAXException, IOException, ProcessingException {
        // Test for url rewriting
        if (typeParameters != null
                && typeParameters.getParameter(URLRewriter.PARAMETER_MODE, null) != null) {
            handler = new URLRewriter(typeParameters, handler);
        }

        String mimeTypeHint = null;
        if (typeParameters != null) {
            mimeTypeHint = typeParameters.getParameter("mime-type", mimeTypeHint);
        }
        if (filterDocumentEvent) {
            IncludeXMLConsumer filter = new IncludeXMLConsumer(handler);
            toSAX(source, mimeTypeHint, filter);
        } else {
            toSAX(source, mimeTypeHint, handler);
        }
    }
13654#/**
     * Generates a DOM from the given source
     * @param source The data
     *
     * @return Created DOM document.
     *
     * @throws IOException If a io exception occurs.
     * @throws ProcessingException if no suitable converter is found
     * @throws SAXException If a SAX exception occurs.
     */
    static public Document toDOM(Source source)
    throws SAXException, IOException, ProcessingException {
        DOMBuilder builder = new DOMBuilder();

        toSAX(source, builder);

        Document document = builder.getDocument();
        if (document == null) {
            throw new ProcessingException("Could not build DOM for '" +
                                          source.getURI() + "'");
        }

        return document;
    }
13655#/**
     * Add a uri to the SourceRefresher.
     *
     * @param name      Uniquely identifying name for the source.
     * @param uri       The uri to refresh. Every valid protocol can be used.
     * @param params    Additional parameters such as an interval between refresh runs.
     */
    void refresh(String name,
                 String uri,
                 Parameters params)
    throws SourceException;
13656#/**
     * Create a new credential
     *
     * @param principal The user name
     */
    public SourceCredential(String principal) {
        this.principal = principal;
    }
13657#/**
     * Create a new credential
     *
     * @param principal The user name
     * @param password Password
     */
    public SourceCredential(String principal, String password) {
        this.principal = principal;
        this.password  = password;
    }
13658#/**
     * Sets the principal
     *
     * @param principal The user name
     */
    public void setPrincipal(String principal) {
        this.principal = principal;
    }
13659#/**
     * Returns the principal
     * 
     * @return Principal
     */
    public String getPrincipal() {
        return this.principal;
    }
13660#/**
     * Sets the password
     *
     * @param password Password
     */
    public void setPassword(String password) {
        this.password = password;
    }
13661#/**
     * Returns the password
     * 
     * @return Password
     */
    public String getPassword() {
        return this.password;
    }
13662#/**
     * Creates a new property for a source
     *
     * @param namespace The namespace of the property
     * @param name The name of the property
     */
    public SourceProperty(String namespace, String name) {

        this.namespace = namespace;
        this.name = name;

        try {
            DOMBuilder builder = new DOMBuilder();
            builder.startDocument();
            builder.startPrefixMapping(NS_PREFIX, namespace);
            AttributesImpl attrs = new AttributesImpl();
            attrs.addAttribute(URI, NS_PREFIX, "xmlns:"+NS_PREFIX, "NMTOKEN", namespace);
            builder.startElement(namespace, name, D_PREFIX+name, attrs);
            builder.endElement(namespace, name, D_PREFIX+name);
            builder.endPrefixMapping(NS_PREFIX);
            Document doc = builder.getDocument();
            this.value = doc.getDocumentElement();
        } catch (SAXException se) {
            // do nothing
        }
    }
13663#/**
     * Creates a new property for a source
     *
     * @param namespace The namespace of the property
     * @param name The name of the property
     * @param value The value of the property
     */
    public SourceProperty(String namespace, String name, String value) {
        this.namespace = namespace;
        this.name = name;
        setValue(value);
    }
13664#/**
     * Creates a new property for a source
     *
     * @param property The property in DOM representation
     */
    public SourceProperty(Element property) {
        this.namespace = property.getNamespaceURI();
        this.name = property.getLocalName();
        this.value = property;
    }
13665#/**
     * Sets the namespace for this property
     *
     * @param namespace The namespace of the property
     * @deprecated buggy
     */
    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }
13666#/**
     * Return the namespace of the property
     *
     * @return The namespace of the property
     */
    public String getNamespace() {
        return this.namespace;
    }
13667#/**
     * Sets the name of the property
     *
     * @param name Name of the property
     * @deprecated buggy
     */
    public void setName(String name) {
        this.name = name;
    }
13668#/**
     * Return the name of the property
     *
     * @return Name of the property
     */
    public String getName() {
        return this.name;
    }
13669#/**
     * Sets the value of the property
     *
     * @param value Value of the property
     */
    public void setValue(String value) {
        try {
            DOMBuilder builder = new DOMBuilder();
            builder.startDocument();
            builder.startPrefixMapping(NS_PREFIX, namespace);
            AttributesImpl attrs = new AttributesImpl();
            attrs.addAttribute(URI, NS_PREFIX, "xmlns:"+NS_PREFIX, "NMTOKEN", namespace);
            builder.startElement(namespace, name, D_PREFIX+name, attrs);
            builder.characters(value.toCharArray(), 0, value.length());
            builder.endElement(namespace, name, D_PREFIX+name);
            builder.endPrefixMapping(NS_PREFIX);
            builder.endDocument();
            Document doc = builder.getDocument();
            this.value = doc.getDocumentElement();
        } catch (SAXException se) {
            // do nothing
        }
    }
13670#/**
     * Returns the value of the property
     *
     * @return Value of the property
     */
    public String getValueAsString() {
        NodeList nodeslist = this.value.getChildNodes();
        StringBuffer buffer = new StringBuffer();
        for (int i = 0; i<nodeslist.getLength(); i++) {
            if ((nodeslist.item(i).getNodeType()==Node.TEXT_NODE) ||
                (nodeslist.item(i).getNodeType()==Node.CDATA_SECTION_NODE))
            {

                buffer.append(nodeslist.item(i).getNodeValue());
            }
        }

        return buffer.toString();
    }
13671#/**
     * Sets the value of the property
     *
     * @param values
     */
    public void setValue(NodeList values) {
        try {
            DOMBuilder builder = new DOMBuilder();
            builder.startDocument();
            builder.startElement(namespace, name, name, XMLUtils.EMPTY_ATTRIBUTES);
            DOMStreamer stream = new DOMStreamer(builder);
            for (int i = 0; i<values.getLength(); i++) {
                stream.stream(values.item(i));
            }
            builder.endElement(namespace, name, name);
            builder.endDocument();
            Document doc = builder.getDocument();
            this.value = doc.getDocumentElement();
        } catch (SAXException se) {
            // do nothing
        }
    }
13672#/**
     * Get the property value as DOM Element.
     */
    public Element getValue() {
        return this.value;
    }
13673#/**
     * Generates SAX events representing the object's state.<br/>
     * <b>NOTE</b> : if the implementation can produce lexical events, care should be taken
     * that <code>handler</code> can actually be a {@link org.apache.cocoon.xml.XMLConsumer} that accepts such
     * events.
     *
     * @param handler
     */
    public void toSAX(ContentHandler handler) throws SAXException {
        DOMStreamer stream = new DOMStreamer(handler);
        stream.stream(this.value);
    }
13674#public void init() throws ConfigurationException {
        
        if (writeInterval > 0) {
            File workDir = new File(this.settings.getWorkDirectory());
            this.configFile = new File(workDir, fileName);
            if (this.configFile.exists() && !this.configFile.canWrite()) {
                throw new ConfigurationException("Parameter 'write-source' resolves to not modifiable file: " +
                                                 this.configFile);
            }
            if (!this.configFile.getParentFile().exists() && !this.configFile.getParentFile().mkdirs()) {
                throw new ConfigurationException("Can not create parent directory for: " +
                                                 this.configFile);
            }
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Write source location: " + this.configFile);
            }

            setupRefreshJobs(readRefreshJobConfiguration());
            startConfigurationTask(writeInterval);
        } else {
        	if (getLogger().isInfoEnabled()) {
				getLogger().info("Not writing update targets to file.");
        	}
        }
   
    }
13675#public void destroy() {
    	stopConfigurationTask();
    }
13676#// ---------------------------------------------------- SourceRefresher implementation

    /* (non-Javadoc)
     * @see SourceRefresher#refresh
     */
    public void refresh(String name,
                        String uri,
                        Parameters parameters)
    throws SourceException {
		final long interval = parameters.getParameterAsLong(PARAM_CACHE_INTERVAL, -1);
		if (uri != null && interval > 0) {
            addRefreshSource(name, uri, interval, interval);
		} else {
            removeRefreshSource(name);
        }
    }
13677#protected void addRefreshSource(String key, String uri, long delay, long interval) {
        RefresherTask task = (RefresherTask) this.entries.get(key);
        if (task == null) {
            // New source added.
            task = new RefresherTask(key, uri, interval);
            this.entries.put(key, task);
            this.runnable.execute(task, interval, interval);
            this.changed = true;
        } else if (task.interval != interval) {
            // Existing source refresh interval updated.
            task.update(uri, interval);
            this.runnable.remove(task);
            this.runnable.execute(task, interval, interval);
            this.changed = true;
        } else {
            // No change.
        }
    }
13678#protected void removeRefreshSource(String key) {
        RefresherTask task = (RefresherTask) this.entries.get(key);
        if (task != null) {
            this.entries.remove(key);
            this.runnable.remove(task);
            this.changed = true;
        }
    }
13679#// ---------------------------------------------------- Implementation

    /**
     *
     */
    private Configuration readRefreshJobConfiguration() {
        Source source = null;
        SAXConfigurationHandler b = new SAXConfigurationHandler();
        try {
            if (this.configFile.exists()) {
                source = this.resolver.resolveURI(this.configFile.toURL().toString());
                SourceUtil.toSAX(this.manager, source, source.getMimeType(), b);
            }
        } catch (Exception ignore) {
            getLogger().warn("Unable to read configuration from " + this.configFile);
        } finally {
            if (source != null) {
                this.resolver.release(source);
            }
        }
        return b.getConfiguration();
    }
13680#/**
	 * @param conf
	 */
	private void setupRefreshJobs(final Configuration conf) {
        if (conf != null) {
            final Configuration[] children = conf.getChildren(TAGNAME_TARGET);
            if (children != null) {
                for (int i = 0; i < children.length; i++) {
                    try {
                        setupSingleRefreshJob(children[i]);
                    } catch (CascadingException ignore) {
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("Setting up refresh job, ignoring exception:", ignore);
                        }
                    }
                }
            }
        }
    }
13681#/**
	 * @param conf
	 * @throws ConfigurationException
	 */
	private void setupSingleRefreshJob(final Configuration conf) throws ConfigurationException {
		try {
            String key = NetUtils.decode(conf.getAttribute(ATTR_KEY), "utf-8");
            String uri = NetUtils.decode(conf.getAttribute(ATTR_URI), "utf-8");
            long interval = conf.getAttributeAsLong(ATTR_INTERVAL);
            addRefreshSource(key, uri, 10, interval);
        } catch (UnsupportedEncodingException e) {
            /* Won't happen */
        }
	}
13682#/**
     * @param interval
     */
    protected void startConfigurationTask(long interval) {
        configurationTask = new ConfigurationTask();
        runnable.execute(configurationTask, interval, interval);
    }
13683#protected void stopConfigurationTask() {
        if (this.configurationTask != null) {
            this.runnable.remove(this.configurationTask);
            this.configurationTask.run();
            this.configurationTask = null;
        }
    }
13684#// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ set dependencies ~~~~~
    
    public void setServiceManager(ServiceManager manager) {
        this.manager = manager;
    }
13685#public void setSourceResolver(SourceResolver resolver) {
        this.resolver = resolver;
    }
13686#public void setRunnableManager(RunnableManager runnable) {
        this.runnable = runnable;
    }
13687#public void setSettings(Settings settings) {
        this.settings = settings;
    }
13688#public void setWriteFile(String fileName) {
        this.fileName = fileName;
    }
13689#public void setWriteInterval(long interval) {
        this.writeInterval = interval;
    }
13690#public void setAvalonContext(Context context) {
        this.context = context;
    }
13691#public void run() {
            if (changed) {
                // Reset the flag.
                changed = false;

                boolean success = true;
                Writer writer = null;
                try {
                    writer = new OutputStreamWriter(new FileOutputStream(configFile), "utf-8");
                    writer.write("<targets>\n");

                    try {
                        final Iterator i = entries.values().iterator();
                        while (i.hasNext()) {
                            RefresherTask task = (RefresherTask) i.next();
                            writer.write(task.toXML());
                        }
                    } catch (ConcurrentModificationException e) {
                        // List of targets has been changed, unable to save it completely.
                        // Will re-try writing the list next time.
                        success = false;
                    }

                    writer.write("</targets>\n");
                } catch (IOException e) {
                    // Got I/O exception while writing the list.
                    // Will re-try writing the list next time.
                    success = false;
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("Error writing targets to file.", e);
                    }
                } finally {
                    if (writer != null) {
                        try {
                            writer.close();
                        } catch (IOException e) { /* ignored */ }
                    }
                }

                // Set the flag to run next time if failed this time
                if (!success) {
                    changed = true;
                }
            }
        }
13692#public RefresherTask(String key, String uri, long interval) {
            this.key = key;
            this.uri = uri;
            this.interval = interval;
        }
13693#public void run() {
            if (this.uri != null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Refreshing " + this.uri);
                }

                // Setup Environment
                final BackgroundEnvironment env;
                try {
                    org.apache.cocoon.environment.Context ctx =
                            (org.apache.cocoon.environment.Context) context.get(Constants.CONTEXT_ENVIRONMENT_CONTEXT);
                    env = new BackgroundEnvironment(ctx);
                } catch (ContextException e) {
                    throw new CascadingRuntimeException("No context found", e);
                }
                Processor processor;
                try {
                    processor = (Processor) manager.lookup(Processor.ROLE);
                } catch (ServiceException e) {
                    throw new CascadingRuntimeException("No processor found", e);
                }

                env.startingProcessing();
                try {
                    EnvironmentHelper.enterProcessor(processor, env);
                } catch (ProcessingException e) {
                    throw new CascadingRuntimeException("Can not enter processor", e);
                }
                try {
                    // Refresh Source
                    Source source = null;
                    try {
                        source = resolver.resolveURI(uri);
                        source.refresh();
                    } catch (IOException e) {
                        getLogger().error("Error refreshing source", e);
                    } finally {
                        if (source != null) {
                            resolver.release(source);
                        }
                    }
                } finally {
                    EnvironmentHelper.leaveProcessor();
                    env.finishingProcessing();
                    if (manager != null) {
                        manager.release(processor);
                    }
                }
            }
        }
13694#public void update(String uri, long interval) {
            this.uri = uri;
            this.interval = interval;
        }
13695#public String toXML() {
            String key = null;
            String uri = null;
            try {
                key = NetUtils.encode(this.key, "utf-8");
                uri = NetUtils.encode(this.uri, "utf-8");
            } catch (UnsupportedEncodingException e) {
                /* Won't happen */
            }
            StringBuffer s = new StringBuffer();
            s.append('<').append(TAGNAME_TARGET).append(' ');
            s.append(ATTR_KEY).append("=\"").append(key).append("\" ");
            s.append(ATTR_URI).append("=\"").append(uri).append("\" ");
            s.append(ATTR_INTERVAL).append("=\"").append(interval).append("\" />\n");
            return s.toString();
        }
13696#/**
     * Builds a PartSource given an URI.
     * @param uri e.g., upload://formField1
     * @throws SourceException
     * @throws MalformedURLException
     */
    public PartSource(String uri, Map objectModel) throws MalformedURLException, SourceException
    {
        // set the uri for use in getURI()
        this.uri = uri;

        int position = uri.indexOf(':') + 1;
        if (position != 0)
        {
            // set the protocol for use in getScheme()
            this.protocol = uri.substring(0, position-1);
        }
        else
        {
            // if the URI is not correctly formatted then throw an excpetion
            throw new MalformedURLException("No protocol found for part source in " + uri);
        }

        // get the request parameter name: the bit after ://
        String location = uri.substring(position + 2);

        // get the cocoon request from the object model.
        Request request = ObjectModelHelper.getRequest(objectModel);

        // try and cast the request object to a Part
        Object obj = request.get(location);
        if (obj instanceof Part)
        {
             part = (Part) obj;
        }
        else
        {
             throw new SourceException("Request object " + location + " is not an uploaded Part");
        }
    }
13697#/**
     * @see org.apache.excalibur.source.Source#getInputStream()
     */
    public InputStream getInputStream() throws IOException, SourceNotFoundException
    {
        try
        {
            return part.getInputStream();
        }
        catch (Exception ex)
        {
            throw new SourceNotFoundException("The part source can not be found.");
        }
    }
13698#/**
     * @see org.apache.excalibur.source.Source#getMimeType()
     */
    public String getMimeType()
    {
        return part.getMimeType();
    }
13699#/**
      * @return true if the resource exists.
      */
    public boolean exists()
    {
        return part != null;
    }
13700#/*
     * @see org.apache.excalibur.source.Source#getURI()
     */
    public String getURI()
    {
        return uri;
    }
13701#/*
     * @see org.apache.excalibur.source.Source#getScheme()
     */
    public String getScheme()
    {
        return this.protocol;
    }
13702#/*
     * Not used, Parts are not cacheable.
     */
    public SourceValidity getValidity()
    {
        // not sure what happens here.
        return null;
    }
13703#/**
      * @see org.apache.excalibur.source.Source#refresh()
      */
    public void refresh()
    {
    }
13704#/**
     * @see org.apache.excalibur.source.Source#getContentLength()
     */
    public long getContentLength()
    {
        return part.getSize();
    }
13705#/**
     * @see org.apache.excalibur.source.Source#getLastModified()
     */
    public long getLastModified()
    {
        return 0;
    }
13706#public Part getPart() {
        return this.part;
    }
13707#public SourceValidity[] getCacheValidities(CachingSource cachingSource, Source source) {
        return new SourceValidity[] { 
              new ExpiresValidity(cachingSource.getExpiration()), source.getValidity() };
    }
13708#public boolean checkValidity(CachedSourceResponse response, Source source, long expires) {
        final SourceValidity[] validities = response.getValidityObjects();
        boolean valid = true;

        final ExpiresValidity expiresValidity = (ExpiresValidity) validities[0];
        final SourceValidity sourceValidity = validities[1];

        if (expiresValidity.isValid() != SourceValidity.VALID) {
            int validity = sourceValidity != null? sourceValidity.isValid() : SourceValidity.INVALID;
            if (validity == SourceValidity.INVALID ||
                    validity == SourceValidity.UNKNOWN &&
                            sourceValidity.isValid(source.getValidity()) != SourceValidity.VALID) {
                if (logger.isDebugEnabled()) {
                    logger.debug("Response expired, invalid for " + logger);
                }
                valid = false;
            } else {
                if (logger.isDebugEnabled()) {
                    logger.debug("Response expired, still valid for " + logger);
                }
                // set new expiration period
                validities[0] = new ExpiresValidity(expires);
            }
        } else {
            if (logger.isDebugEnabled()) {
                logger.debug("Response not expired for " + logger);
            }
        }

        return valid;
    }
13709#SourceValidity[] getCacheValidities(CachingSource cachingSource, Source source);
13710#boolean checkValidity(CachedSourceResponse response, Source source, long expires);
13711#public CachedSourceResponse(SourceValidity[] validities) {
        super(validities, null);
    }
13712#public byte[] getBinaryResponse() {
        return m_binary;
    }
13713#public void setBinaryResponse(byte[] binary) {
        m_binary = binary;
    }
13714#public byte[] getXMLResponse() {
        return m_xml;
    }
13715#public void setXMLResponse(byte[] xml) {
        m_xml = xml;
    }
13716#public void setExtra(Serializable extra) {
        m_extra = extra;
    }
13717#public Serializable getExtra() {
        return m_extra;
    }
13718#/*
     * Returns a new {@link PartSource} based on the uri.
     *
     * @see org.apache.excalibur.source.SourceFactory#getSource(java.lang.String, java.util.Map)
     */
    public Source getSource(String uri, Map parameters) throws IOException, MalformedURLException
    {
        Map objectModel = ContextHelper.getObjectModel(context);
        return new PartSource(uri, objectModel);
    }
13719#/**
     * Do nothing, {@link PartSource}s don't need to be released.
     *
     * @see org.apache.excalibur.source.SourceFactory#release(org.apache.excalibur.source.Source)
     */
    public void release(Source source)
    {
        // Nothing to do here
    }
13720#/**
     * Get the objectModel from the Context
     */
    public void contextualize(org.apache.avalon.framework.context.Context context)
    throws ContextException {
         this.context = context;
    }
13721#/**
     * @throws IOException 
     * @throws MalformedURLException 
     * 
     */
    public BlockContextSource(String location, Map blockContexts, ServiceManager manager)
    throws MalformedURLException, IOException {
        this.setScheme(location.substring(0, location.indexOf(":/")));
        this.setSystemId(location);
        this.blockContexts = blockContexts;
        this.manager = manager;
        this.children = this.createChildren();
    }
13722#/* (non-Javadoc)
     * @see org.apache.excalibur.source.Source#exists()
     */
    public boolean exists() {
        return true;
    }
13723#/* (non-Javadoc)
     * @see org.apache.excalibur.source.TraversableSource#getChild(java.lang.String)
     */
    public Source getChild(String name) throws SourceException {
        Source child = (Source) this.children.get(name);
        if (child == null)
            throw new SourceException("The block named " + name + "doesn't exist");
        return child;
    }
13724#/* (non-Javadoc)
     * @see org.apache.excalibur.source.TraversableSource#getChildren()
     */
    public Collection getChildren() throws SourceException {
        return this.children.values();
    }
13725#private Map createChildren() throws MalformedURLException, IOException  {
        Map children = new HashedMap(this.blockContexts.size() * 2 + 1);
        SourceResolver resolver = null;
        try {
            resolver = (SourceResolver) this.manager.lookup(SourceResolver.ROLE);
            Iterator i = this.blockContexts.entrySet().iterator();
            while (i.hasNext()) {
                Entry entry = (Entry) i.next();
                String blockName = (String) entry.getKey();
                String contextPath = (String) entry.getValue();
                Source child = resolver.resolveURI(contextPath);
                if (child instanceof TraversableSource)
                    child = adjustName((TraversableSource) child, blockName);
                children.put(blockName, child);
            }
            return children;
        } catch (ServiceException se) {
            throw new CascadingIOException("SourceResolver is not available.", se);
        } finally {
            this.manager.release(resolver);
        }
    }
13726#/*
     * Adjust the traversable source so that it use the block name as name instead of
     * e.g. the directory name from the source that the block name was resolved to.
     */
    private static Source adjustName(final TraversableSource source, final String blockName) {
        TraversableSource adjustedSource =
            (TraversableSource) Proxy.newProxyInstance(source.getClass().getClassLoader(), ClassUtils.getAllInterfaces(source),
                new InvocationHandler() {

                    /* (non-Javadoc)
                     * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
                     */
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        if (method.equals(TraversableSource.class.getMethod("getName", new Class[]{})))
                            return blockName;
                        else
                            return method.invoke(source, args);
                    }
        });
        return adjustedSource;
    }
13727#/* (non-Javadoc)
     * @see org.apache.excalibur.source.TraversableSource#getName()
     */
    public String getName() {
        return ".";
    }
13728#/* (non-Javadoc)
     * @see org.apache.excalibur.source.TraversableSource#getParent()
     */
    public Source getParent() throws SourceException {
        // this is the root node so there is no parent
        return null;
    }
13729#/* (non-Javadoc)
     * @see org.apache.excalibur.source.TraversableSource#isCollection()
     */
    public boolean isCollection() {
        // this source is always a directory
        return true;
    }
13730#public CachingSourceFactory() {
    }
13731#/**
     * Get a <code>Source</code> object.
     * @param parameters This is optional.
     */
    public Source getSource(final String location, final Map parameters)
    throws IOException {

        if (logger.isDebugEnabled() ) {
            logger.debug("Creating source " + location);
        }

        // snip the cache protocol
        int index = location.indexOf(':');
        if (index == -1) {
            throw new MalformedURLException("This Source requires a subprotocol to be specified.");
        }

        String uri = location.substring(index + 1);

        // parse the query string
        SourceParameters sp = null;
        index = uri.indexOf('?');
        if (index != -1) {
            sp = new SourceParameters(uri.substring(index + 1));
            uri = uri.substring(0, index);
        }

        // put caching source specific query string parameters
        // into a Parameters object
        final Parameters params = new Parameters();
        if (sp != null) {
            SourceParameters remainingParameters = (SourceParameters) sp.clone();
            final Iterator names = sp.getParameterNames();
            while (names.hasNext()) {
                String name = (String) names.next();
                if (name.startsWith("cocoon:cache")) {
                    params.setParameter(name.substring("cocoon:".length()), sp.getParameter(name));
                    remainingParameters.removeParameter(name);
                }
            }
            String queryString = remainingParameters.getEncodedQueryString();
            if (queryString != null) {
                uri += "?" + queryString;
            }
        }

        int expires = params.getParameterAsInteger(CachingSource.CACHE_EXPIRES_PARAM, this.defaultExpires);
        String cacheName = params.getParameter(CachingSource.CACHE_NAME_PARAM, null);        
        boolean fail = params.getParameterAsBoolean(CachingSource.CACHE_FAIL_PARAM, false);

        return createCachingSource(location, uri, this.resolver.resolveURI(uri), expires, cacheName, fail);
    }
13732#/**
     * Actually creates a new CachingSource. Can be overriden in subclasses
     */
    protected CachingSource createCachingSource(String uri,
                                                String wrappedUri,
                                                Source wrappedSource,
                                                int expires,
                                                String cacheName,
                                                boolean fail)
    throws SourceException {

        CachingSource source = instantiateSource(uri,
                                                 wrappedUri,
                                                 wrappedSource,
                                                 expires,
                                                 cacheName,
                                                 fail);

        // set the required components directly for speed
        source.cache = this.cache;
        try {
            // call selected avalon lifecycle interfaces. Mmmh.
            ContainerUtil.service(source, this.serviceManager);
            ContainerUtil.initialize(source);
        } catch (ServiceException e) {
            throw new SourceException("Unable to initialize source.", e);
        } catch (Exception e) {
            throw new SourceException("Unable to initialize source.", e);
        }

        if (this.async && expires > 0) {
            // schedule it with the refresher
            final Parameters params = new Parameters();
            params.setParameter(SourceRefresher.PARAM_CACHE_INTERVAL,
                                String.valueOf(source.getExpiration()));
            if(this.refresher == null) {
                String msg = "Make sure that the SourceRefresher is injected correctly when " + 
                "you want to use the source asyncronous and with an expires param > 0.";
                logger.error(msg);
                throw new SourceException(msg);
            }
            this.refresher.refresh(source.getCacheKey(), source.getURI(), params);
        }

        return source;
    }
13733#protected CachingSource instantiateSource(String uri, String wrappedUri, Source wrappedSource, int expires,
                    String cacheName, boolean fail) {

        if (wrappedSource instanceof TraversableSource) {
            return new TraversableCachingSource(
                            this, 
                            this.scheme, 
                            uri, 
                            wrappedUri,
                            (TraversableSource) wrappedSource, 
                            expires, 
                            cacheName, 
                            this.async,
                            this.validityStrategy, 
                            fail);
        } else {
            return new CachingSource(
                            this.scheme, 
                            uri, 
                            wrappedUri, 
                            wrappedSource, 
                            expires, 
                            cacheName, 
                            this.async,
                            this.validityStrategy, 
                            fail);
        }
    }
13734#/**
     * Release a {@link Source} object.
     */
    public void release(Source source) {
        if (source instanceof CachingSource) {
            if (logger.isDebugEnabled() ) {
                logger.debug("Releasing source " + source.getURI());
            }
            CachingSource caching = (CachingSource) source;
            resolver.release(caching.source);
            caching.dispose();
        }
    }
13735#// ---------------------------------------------------- URIAbsolutizer

    /**
     * @see org.apache.excalibur.source.URIAbsolutizer#absolutize(java.lang.String, java.lang.String)
     */
    public String absolutize(String baseURI, String location) {
        return SourceUtil.absolutize(baseURI, location, true);
    }
13736#// ---------------------------------------------------- Set dependencies
    
    /**
     * Mandatory dependency on an implementation of {@link Cache}.
     */
    public void setCache(Cache cache) {
        this.cache = cache;
    }
13737#/**
     * Mandatory dependency on an implementation of {@link CachingSourceValidityStrategy}.
     */
    public void setValidityStrategy(CachingSourceValidityStrategy validityStrategy) {
        this.validityStrategy = validityStrategy;
    }
13738#/**
     * Mandatory dependency on an implementation of {@link ServiceManager}.
     */    
    public void setServiceManager(ServiceManager serviceManager) {
        this.serviceManager = serviceManager;
    }
13739#/**
     * Mandatory dependency on an implementation of {@link SourceResolver}.
     */    
    public void setSourceResolver(SourceResolver resolver) {
        this.resolver = resolver;
    }
13740#/**
     * Optional dependency on an implementation of {@link SourceRefresher}.
     */      
    public void setSourceRefresher(SourceRefresher refresher) {
        this.refresher = refresher;
    }
13741#/**
     * Optional property whether the source is asyncronous. The default value is <code>false</code>.
     */    
    public void setAsync(boolean async) {
        this.async = async;
    }
13742#/**
     * Optional property the default expiry time in seconds. Default is <code>-1</code> which means that is valid forever.
     */       
    public void setDefaultExpires(int expires) {
        this.defaultExpires = expires;
    }
13743#// ---------------------------------------------------- BeanNameAware
    
    public void setBeanName(String beanName) {
        int pos = beanName.lastIndexOf('/');
        this.scheme = beanName.substring(pos + 1);
    }
13744#/**
     * Construct a new object.
     * @param validityStrategy
     */
    public CachingSource(final String protocol,
                         final String uri,
                         final String sourceUri,
                         final Source source,
                         final int expires,
                         final String cacheName,
                         final boolean async,
                         final CachingSourceValidityStrategy validityStrategy, 
                         final boolean fail) {
        this.protocol = protocol;
        this.uri = uri;
        this.sourceUri = sourceUri;
        this.source = source;
        this.expires = expires;
        this.cacheName = cacheName;
        this.async = async;
        this.validityStrategy = validityStrategy;
        this.fail = fail;

        String key = "source:" + getSourceURI();
        if (cacheName != null) {
            key += ":" + cacheName;
        }
        this.cacheKey = new IdentifierCacheKey(key, false);
    }
13745#// ---------------------------------------------------- Lifecycle

    /**
     * Set the ServiceManager.
     */
    public void service(final ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
13746#/**
     * Initialize the Source.
     */
    public void initialize() throws Exception {
        boolean checkValidity = true;
        if (this.async && this.expires > 0 || this.expires == -1) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Using cached response if available.");
            }
            checkValidity = false;
        }

        this.response = (CachedSourceResponse) this.cache.get(this.cacheKey);
        // save response if subsequent request should never fail
        if(!fail) {
            this.previousResponse = this.response;
        }

        if (this.response == null) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("No cached response found.");
            }
            checkValidity = false;
        } else if (this.expires == 0) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Not using cached response.");
            }
            this.response = null;
            checkValidity = false;
        }

        if (checkValidity && !checkValidity()) {
            // remove invalid response
            clearResponse();
        }
    }
13747#/**
     * Cleanup.
     */
    public void dispose() {
        this.response = null;
        this.previousResponse = null;
        this.source = null;
        this.manager = null;
        this.cache = null;
    }
13748#// ---------------------------------------------------- CachedSourceResponse object management

    private CachedSourceResponse getResponse() {
        CachedSourceResponse response = this.response;
        if (response == null) {
            response = new CachedSourceResponse(getCacheValidities());
        }
        return response;
    }
13749#private void setResponse(CachedSourceResponse response) throws IOException {
        this.response = response;
        if (this.expires != 0) {
            try {
                this.cache.store(this.cacheKey, this.response);
            } catch (ProcessingException e) {
                throw new CascadingIOException("Failure storing response.", e);
            }
        }
    }
13750#private void clearResponse() {
        this.response = null;
        if(!fail) {
            this.cache.remove(this.cacheKey);
        }
    }
13751#/**
     * Initialize the cached response with meta info.
     *
     * @throws IOException  if an the binary response could not be initialized
     */
    protected SourceMeta getResponseMeta() throws IOException {
        CachedSourceResponse response = getResponse();

        if (response.getExtra() == null) {
            response.setExtra(readMeta(this.source));
            this.freshMeta = true;
            setResponse(response);
        }

        return (SourceMeta) response.getExtra();
    }
13752#/**
     * Initialize the cached response with meta and binary contents.
     *
     * @throws IOException  if an the binary response could not be initialized
     */
    protected byte[] getBinaryResponse() throws IOException {
        CachedSourceResponse response = getResponse();

        if (response.getBinaryResponse() == null) {
            if (!this.freshMeta) {
                /* always refresh meta in this case */
                response.setExtra(readMeta(this.source));
                this.freshMeta = true;
            }
            if (((SourceMeta) response.getExtra()).exists()) {
                response.setBinaryResponse(readBinaryResponse(this.source));
            }
            setResponse(response);
        }

        return response.getBinaryResponse();
    }
13753#/**
     * Initialize the cached response with meta, binary, and XML contents.
     *
     * @throws SAXException  if something happened during xml processing
     * @throws IOException  if an IO level error occured
     * @throws CascadingIOException  wraps all other exception types
     */
    protected byte[] getXMLResponse() throws SAXException, IOException {
        CachedSourceResponse response = getResponse();

        try {
            if (response.getXMLResponse() == null) {
                if (!this.freshMeta) {
                    /* always refresh meta in this case */
                    response.setExtra(readMeta(this.source));
                    this.freshMeta = true;
                }
                if (((SourceMeta) response.getExtra()).exists()) {
                    if (response.getBinaryResponse() == null) {
                        response.setBinaryResponse(readBinaryResponse(this.source));
                    }
                    response.setXMLResponse(readXMLResponse(this.source, response.getBinaryResponse(), this.manager));
                }
                setResponse(response);
            }
        } catch (Exception e) {
            if (!fail && this.previousResponse != null) {
                response = cloneResponse(this.previousResponse);
                setResponse(cloneResponse(response));
            } else {
                // rethrow exception
                if (e instanceof SAXException) {
                    throw (SAXException) e;
                } else if (e instanceof IOException) {
                    throw (IOException) e;
                }
                throw new CascadingIOException(e);
            }
        }

        return response.getXMLResponse();
    }
13754#private SourceMeta getMeta() {
        try {
            return getResponseMeta();
        } catch (IOException e) {
            // Could not initialize meta. Return default meta values.
            return DUMMY;
        }
    }
13755#private CachedSourceResponse cloneResponse(final CachedSourceResponse orig) {
        CachedSourceResponse c = new CachedSourceResponse(this.getCacheValidities());
        c.setBinaryResponse(orig.getBinaryResponse());
        c.setContentType(orig.getContentType());
        c.setExtra(orig.getExtra());
        c.setXMLResponse(orig.getXMLResponse());
        return c;
    }
13756#// ---------------------------------------------------- Source implementation

    /**
     * Return the protocol identifier.
     */
    public String getScheme() {
        return this.protocol;
    }
13757#/**
     * Get the content length of the source or -1 if it
     * is not possible to determine the length.
     */
    public long getContentLength() {
        return getMeta().getContentLength();
    }
13758#/**
     * Get the last modification date.
     * @return The last modification in milliseconds since January 1, 1970 GMT
     *         or 0 if it is unknown
     */
    public long getLastModified() {
        return getMeta().getLastModified();
    }
13759#/**
     * The mime-type of the content described by this object.
     * If the source is not able to determine the mime-type by itself
     * this can be null.
     */
    public String getMimeType() {
        return getMeta().getMimeType();
    }
13760#/**
     * Return an <code>InputStream</code> object to read from the source.
     */
    public InputStream getInputStream() throws IOException {
        return new ByteArrayInputStream(getBinaryResponse());
    }
13761#/**
     * Return the unique identifer for this source
     */
    public String getURI() {
        return this.uri;
    }
13762#/**
     * @see org.apache.excalibur.source.Source#exists()
     */
    public boolean exists() {
        return getMeta().exists();
    }
13763#/**
     *  Get the Validity object. This can either wrap the last modification
     *  date or the expires information or...
     *  If it is currently not possible to calculate such an information
     *  <code>null</code> is returned.
     */
    public SourceValidity getValidity() {
        long lastModified = getLastModified();
        if (lastModified > 0) {
            return new TimeStampValidity(lastModified);
        }
        return null;
    }
13764#/**
     * Refresh this object and update the last modified date
     * and content length.
     *
     * This method will try to refresh the cached meta data
     * and content only if cached content is expired.
     */
    public void refresh() {
        if (response != null && checkValidity()) {
            return;
        }

        this.source.refresh();

        CachedSourceResponse response = getResponse();
        try {
            // always refresh meta data
            SourceMeta meta = readMeta(source);
            response.setExtra(meta);

            if (meta.exists()) {
                // only create objects that are cached
                if (response.getBinaryResponse() != null) {
                    response.setBinaryResponse(readBinaryResponse(source));
                }
                if (response.getXMLResponse() != null) {
                    response.setXMLResponse(readXMLResponse(source, response.getBinaryResponse(), this.manager));
                }
            } else {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Source " + this.uri + " does not exist.");
                }
                // clear cached data
                response.setBinaryResponse(null);
                response.setXMLResponse(null);
            }

            // Even if source does not exist, cache that fact.
            setResponse(response);
        } catch (Exception e) {
            getLogger().warn("Error refreshing source " + this.uri +
                             ". Cached response (if any) may be stale.", e);
        }
    }
13765#// ---------------------------------------------------- XMLizable implementation

    /**
     * Generates SAX events representing the object's state.
     */
    public void toSAX(ContentHandler contentHandler) throws SAXException {
        try {
            XMLByteStreamInterpreter deserializer = new XMLByteStreamInterpreter();
            if (contentHandler instanceof XMLConsumer) {
                deserializer.setConsumer((XMLConsumer) contentHandler);
            } else {
                deserializer.setConsumer(new ContentHandlerWrapper(contentHandler));
            }
            deserializer.deserialize(getXMLResponse());
        } catch (CascadingIOException e) {
            throw new SAXException(e.getMessage(), (Exception) e.getCause());
        } catch (IOException e) {
            throw new SAXException("Failure reading SAX response.", e);
        }
    }
13766#// ---------------------------------------------------- CachingSource specific accessors

    /**
     * Return the uri of the cached source.
     */
    protected String getSourceURI() {
        return this.sourceUri;
    }
13767#/**
     * Return the used key.
     */
    protected String getCacheKey() {
        return this.cacheKey.getKey();
    }
13768#/**
     * Expires (in milli-seconds)
     */
    protected long getExpiration() {
        return this.expires * 1000;
    }
13769#/**
     * Read XML content from source.
     *
     * @return content from source
     * @throws SAXException
     * @throws IOException
     * @throws CascadingIOException
     */
    protected byte[] readXMLResponse(Source source, byte[] binary, ServiceManager manager)
    throws SAXException, IOException {
        XMLizer xmlizer = null;
        try {
            XMLByteStreamCompiler serializer = new XMLByteStreamCompiler();

            if (source instanceof XMLizable) {
                ((XMLizable) source).toSAX(serializer);
            } else {
                final String mimeType = source.getMimeType();
                if (mimeType != null) {
                    xmlizer = (XMLizer) manager.lookup(XMLizer.ROLE);
                    xmlizer.toSAX(new ByteArrayInputStream(binary),
                                  mimeType,
                                  source.getURI(),
                                  serializer);
                }
            }

            return (byte[]) serializer.getSAXFragment();
        } catch (ServiceException e) {
            throw new CascadingIOException("Missing service dependency.", e);
        } finally {
            if (xmlizer != null) {
                manager.release(xmlizer);
            }
        }
    }
13770#/**
     * Read binary content from source.
     *
     * @return content from source
     * @throws IOException
     * @throws SourceNotFoundException
     */
    protected byte[] readBinaryResponse(Source source)
    throws IOException {
        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
        final byte[] buffer = new byte[2048];
        final InputStream inputStream = source.getInputStream();
        int length;
        while ((length = inputStream.read(buffer)) > -1) {
            baos.write(buffer, 0, length);
        }
        baos.flush();
        inputStream.close();
        return baos.toByteArray();
    }
13771#/**
     * Read meta data from source.
     */
    protected SourceMeta readMeta(Source source) throws SourceException {
        return new SourceMeta(source);
    }
13772#private boolean checkValidity() {
        if (this.response == null) {
            return false;
        }
        return this.validityStrategy.checkValidity(this.response, this.source, getExpiration());
    }
13773#protected SourceValidity[] getCacheValidities() {
        return validityStrategy.getCacheValidities(this, source);
    }
13774#public void setValidityStrategy(CachingSourceValidityStrategy s) {
        this.validityStrategy = s;
    }
13775#public SourceMeta() {
        }
13776#public SourceMeta(Source source) {
            setExists(source.exists());
            if (exists()) {
                setContentLength(source.getContentLength());
                final long lastModified = source.getLastModified();
                if (lastModified > 0) {
                    setLastModified(lastModified);
                } else {
                    setLastModified(System.currentTimeMillis());
                }
                setMimeType(source.getMimeType());
            } else {
                contentLength = -1;
            }
        }
13777#protected boolean exists() {
            return exists;
        }
13778#protected void setExists(boolean exists) {
            this.exists = exists;
        }
13779#protected long getContentLength() {
            return contentLength;
        }
13780#protected void setContentLength(long contentLength) {
            this.contentLength = contentLength;
        }
13781#protected long getLastModified() {
            return lastModified;
        }
13782#protected void setLastModified(long lastModified) {
            this.lastModified = lastModified;
        }
13783#protected String getMimeType() {
            return mimeType;
        }
13784#protected void setMimeType(String mimeType) {
            this.mimeType = mimeType;
        }
13785#/**
     * @see Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager aServiceManager) throws ServiceException {
        this.serviceManager = aServiceManager;
        this.blockResourcesHolder = (BlockResourcesHolder) this.serviceManager.lookup(BlockResourcesHolder.class.getName());
    }
13786#/**
     * @see SourceFactory#getSource(java.lang.String, java.util.Map)
     */
    public Source getSource(String location, Map parameters) throws IOException {
        Map blockContexts = this.blockResourcesHolder.getBlockContexts();

        // the root "directory" of the blocks
        if (location.endsWith(":/")) {
            return new BlockContextSource(location, blockContexts, this.serviceManager);
        }
        
        // Remove the protocol and the first '/'
        int pos = location.indexOf(":/");
        String path = location.substring(pos+2);
        
        pos = path.indexOf('/');
        if (pos != -1) {
            // extract the block name and get the block context path
            String blockName = path.substring(0, pos);
            path = path.substring(pos);
            String blockContext = (String) blockContexts.get(blockName);
            if (blockContext == null) {
                throw new MalformedURLException("Unknown block name " + blockName +
                                                " in block context uri " + location);
            }

            // construct the path relative the block context
            String resolvedPath = blockContext + path;
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("block context source " + location + " is resolved to " + resolvedPath);
            }

            SourceResolver resolver = null;
            try {
                resolver = (SourceResolver) this.serviceManager.lookup(SourceResolver.ROLE);
                return resolver.resolveURI(resolvedPath);
            } catch (ServiceException se) {
                throw new SourceException("SourceResolver is not available.", se);
            } finally {
                this.serviceManager.release(resolver);
            }
        } else {
            throw new MalformedURLException("The block name part of a block context uri must end with a '/' in " + location);
        }
    }
13787#/**
     * @see SourceFactory#release(org.apache.excalibur.source.Source)
     */
    public void release(Source source) {
        // nothing to do
    }
13788#public TraversableCachingSource(final CachingSourceFactory factory,
                                    final String protocol,
                                    final String uri,
                                    final String sourceUri,
                                    TraversableSource source,
                                    int expires,
                                    String cacheName,
                                    boolean async,
                                    CachingSourceValidityStrategy validityStrategy, 
                                    boolean fail) {
        super(protocol, uri, sourceUri, source, expires, cacheName, async, validityStrategy, fail);
        this.factory = factory;
    }
13789#private TraversableSource getTraversableSource() {
        return (TraversableSource) super.source;
    }
13790#private TraversableSourceMeta getTraversableResponseMeta() throws IOException {
        return (TraversableSourceMeta) getResponseMeta();
    }
13791#// ---------------------------------------------------- TraversableSource implementation

    public String getName() {
        try {
            return getTraversableResponseMeta().getName();
        } catch (IOException e) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Failure initializing traversable response", e);
            }
            return null;
        }
    }
13792#public boolean isCollection() {
        try {
            return getTraversableResponseMeta().isCollection();
        } catch (IOException e) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Failure initializing traversable response", e);
            }
            return false;
        }
    }
13793#public Source getChild(String name) throws SourceException {
        if (!isCollection()) {
            throw new SourceException("Source is not a collection");
        }

        Source child;
        try {
            getResponseMeta();
            child = getTraversableSource().getChild(name);
        } catch (SourceException e) {
            throw e;
        } catch (IOException e) {
            throw new SourceException("Failure getting child", e);
        }

        boolean isCollection = false;
        if (child instanceof TraversableSource) {
            isCollection = ((TraversableSource) child).isCollection();
        }

        return createSource(getChildURI(super.uri, isCollection, name), getChildURI(super.sourceUri, isCollection, name), child);
    }
13794#public Collection getChildren() throws SourceException {
        final TraversableSourceMeta meta;
        try {
            meta = getTraversableResponseMeta();
        } catch (SourceException e) {
            throw e;
        } catch (IOException e) {
            throw new SourceException("Failure getting child", e);
        }

        if (!isCollection()) {
            throw new SourceException("Source is not a collection");
        }

        final Collection result = new ArrayList();
        final String[] children = meta.getChildren();
        for (int i = 0; i < children.length; i++) {
            Source child;
            try {
                child = getTraversableSource().getChild(children[i]);
            } catch (IOException e) {
                throw new SourceException("Failure getting child", e);
            }

            boolean isCollection = false;
            if (child instanceof TraversableSource) {
                isCollection = ((TraversableSource) child).isCollection();
            }

            result.add(createSource(getChildURI(super.uri, isCollection, children[i]), getChildURI(super.sourceUri, isCollection, children[i]), child));
        }

        return result;
    }
13795#public Source getParent() throws SourceException {
        Source parent;
        try {
            getResponseMeta();
            parent = getTraversableSource().getParent();
        } catch (SourceException e) {
            throw e;
        } catch (IOException e) {
            throw new SourceException("Failure getting parent", e);
        }

        return createSource(getParentURI(super.uri), getParentURI(super.sourceUri), parent);
    }
13796#// ---------------------------------------------------- helper methods

    protected final TraversableCachingSource createSource(String uri, String wrappedUri, Source wrapped)
    throws SourceException {
        return (TraversableCachingSource) this.factory.createCachingSource(uri, wrappedUri, wrapped, expires, cacheName, fail);
    }
13797#protected SourceMeta readMeta(Source source) throws SourceException {
        return new TraversableSourceMeta(source);
    }
13798#/**
     * Calculate the cached child URI based on a parent URI
     * and a child name.
     */
    private static String getChildURI(String parentURI, boolean isCollection, String childName) {
        // separate query string from rest of parentURI
        String rest, qs;
        int index = parentURI.indexOf('?');
        if (index != -1) {
            rest = parentURI.substring(0,index);
            qs = parentURI.substring(index);
        } else {
            rest = parentURI;
            qs = "";
        }

        // calculate child uri
        StringBuffer childURI = new StringBuffer(rest);
        if (rest.charAt(rest.length()-1) != '/') {
            childURI.append('/');
        }
        childURI.append(childName);
        if (isCollection) {
            childURI.append('/');
        }
        childURI.append(qs);
        return childURI.toString();
    }
13799#/**
     * Calculate the cached parent URI based on a child URI.
     */
    private static String getParentURI(String childURI) {
        // separate query string from rest of uri
        String rest, qs;
        int index = childURI.indexOf('?');
        if (index != -1) {
            rest = childURI.substring(0, index);
            qs = childURI.substring(index);
        } else {
            rest = childURI;
            qs = "";
        }

        // calculate qs-less parent uri
        String parentUri;
        index = rest.lastIndexOf('/', rest.length() - 2);
        if (index != -1) {
            parentUri = rest.substring(0, index + 1);
        } else {
            parentUri = rest;
        }

        return parentUri + qs;
    }
13800#public TraversableSourceMeta() {
            super();
        }
13801#public TraversableSourceMeta(Source source) throws SourceException {
            super(source);

            final TraversableSource tsource = (TraversableSource) source;

            setName(tsource.getName());
            setIsCollection(tsource.isCollection());

            if (isCollection()) {
                final Collection children = tsource.getChildren();
                if (children != null) {
                    final String[] names = new String[children.size()];
                    final Iterator iter = children.iterator();
                    int count = 0;
                    while(iter.hasNext()) {
                        TraversableSource child = (TraversableSource) iter.next();
                        names[count] = child.getName();
                        count++;
                    }
                    setChildren(names);
                }
            }
        }
13802#protected String getName() {
            return m_name;
        }
13803#protected void setName(String name) {
            m_name = name;
        }
13804#protected boolean isCollection() {
            return m_isCollection;
        }
13805#protected void setIsCollection(boolean isCollection) {
            m_isCollection = isCollection;
        }
13806#protected String[] getChildren() {
            return m_children;
        }
13807#protected void setChildren(String[] children) {
            m_children = children;
        }
13808#public DelayedValidity(long delay, SourceValidity validity) {
        this.delay = delay;
        this.expires = System.currentTimeMillis() + delay;
        this.delegate = validity;
    }
13809#public int isValid() {
        final long currentTime = System.currentTimeMillis();
        if (currentTime <= this.expires) {
            // The delay has not passed yet - assuming source is valid.
            return SourceValidity.VALID;
        }

        // The delay has passed, prepare for the next interval.
        this.expires = currentTime + this.delay;

        return this.delegate.isValid();
    }
13810#public int isValid(SourceValidity newValidity) {
        // Always delegate
        return this.delegate.isValid(newValidity);
    }
13811#/**
     * Creates an empty <code>CocoonRunnable</code> and copies the environment context
     * of the calling thread, for later use when calling {@link #doRun()}. Users of this
     * constructor will override the {@link #doRun()} method where the actual job gets done.
     */
    public CocoonRunnable() {
        // Nothing special here
    }
13812#/**
     * Wraps an existing <code>Runnable</code> and copies the environment context of
     * the calling thread, for later use when the <code>Runnable</code>'s <code>run()</code>
     * method is called.
     * 
     * @param target the wrapped <code>Runnable</code>
     */
    public CocoonRunnable(Runnable target) {
        this.target = target;
    }
13813#/**
     * Does the actual job, in the environment of the creating thread. Calls the wrapped
     * <code>Runnable</code> if one was given, and does nothing otherwise.
     */
    protected void doRun() {
        if (target != null) {
            target.run();
        }
    }
13814#public String getCharacterEncoding() { return null; }
13815#public javax.servlet.http.Cookie createCookie(String name, String value) { return null; }
13816#public void addCookie(javax.servlet.http.Cookie cookie) {}
13817#public Cookie createCocoonCookie(String name, String value) { return null; }
13818#public void addCookie(Cookie cookie) {}
13819#public boolean containsHeader(String name) { return false; }
13820#public void setHeader(String name, String value) {}
13821#public void setIntHeader(String name, int value) {}
13822#public void setDateHeader(String name, long date) {}
13823#public String encodeURL (String url) { return url; }
13824#public void setLocale(Locale locale) { }
13825#public Locale getLocale() { return null; }
13826#public void addDateHeader(String name, long date) { }
13827#public void addHeader(String name, String value) { }
13828#public void addIntHeader(String name, int value) { }
13829#public BackgroundRequest(Environment env,
                              String contextPath,
                              String servletPath,
                              String pathInfo) {
        this(env, contextPath, servletPath, pathInfo, null, null, null);
    }
13830#public BackgroundRequest(Environment env,
                              String contextPath,
                              String servletPath,
                              String pathInfo,
                              Map attributes) {
        this(env, contextPath, servletPath, pathInfo, attributes, null, null);
    }
13831#public BackgroundRequest(Environment env,
                              String contextPath,
                              String servletPath,
                              String pathInfo,
                              Map attributes,
                              Map parameters) {
        this(env, contextPath, servletPath, pathInfo, attributes, parameters, null);
    }
13832#public BackgroundRequest(Environment env,
                              String contextPath,
                              String servletPath,
                              String pathInfo,
                              Map attributes,
                              Map parameters,
                              Map headers) {
        this.env = env;
        this.contextPath = contextPath;
        this.servletPath = servletPath;
        this.pathInfo = pathInfo;
        this.globalAttributes = (attributes == null ? new HashMap() : attributes);
        this.attributes = new HashMap();
        this.parameters = parameters;
        this.headers = headers;
    }
13833#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#get(java.lang.String)
     */
    public Object get(String name) {
        String[] values = this.getParameterValues(name);
        if (values == null || values.length == 0) {
            return null;
        } else if (values.length == 1) {
            return values[0];
        } else {
            Vector vect = new Vector(values.length);
            for (int i = 0; i < values.length; i++) {
                vect.add(values[i]);
            }
            return vect;
        }
    }
13834#public String getContextPath() { return contextPath; }
13835#public String getServletPath() { return servletPath; }
13836#public String getPathInfo() { return pathInfo; }
13837#public String getRequestURI() {
        StringBuffer buffer = new StringBuffer();
        if (servletPath != null) buffer.append(servletPath);
        if (contextPath != null) buffer.append(contextPath);
        if (pathInfo != null) buffer.append(pathInfo);
        return buffer.toString();
    }
13838#// FIXME
    public String getSitemapURI() {
        return this.env.getURI();
    }
13839#public String getSitemapURIPrefix() {
        return this.env.getURIPrefix();
    }
13840#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getSitemapPath()
     */
    public String getSitemapPath() {
        return this.env.getURIPrefix();
    }
13841#public String getQueryString() { return null; } // use parameters instead
13842#public String getPathTranslated() { return null; } // FIXME (SM) this is legal but should we do something more?
13843#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getAttribute(java.lang.String)
     */
    public Object getAttribute(String name) {
        return this.globalAttributes.get(name);
    }
13844#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getAttributeNames()
     */
    public Enumeration getAttributeNames() {
        return IteratorUtils.asEnumeration(this.globalAttributes.keySet().iterator());
    }
13845#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#setAttribute(java.lang.String, java.lang.Object)
     */
    public void setAttribute(String name, Object value) {
        this.globalAttributes.put(name, value);
    }
13846#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#removeAttribute(java.lang.String)
     */
    public void removeAttribute(String name) {
        this.globalAttributes.remove(name);
    }
13847#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getLocalAttribute(java.lang.String)
     */
    public Object getLocalAttribute(String name) {
            return this.attributes.get(name);
    }
13848#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getLocalAttributeNames()
     */
    public Enumeration getLocalAttributeNames() {
        return IteratorUtils.asEnumeration(this.attributes.keySet().iterator());
    }
13849#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#setLocalAttribute(java.lang.String, java.lang.Object)
     */
    public void setLocalAttribute(String name, Object value) {
        this.attributes.put(name, value);
    }
13850#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#removeLocalAttribute(java.lang.String)
     */
    public void removeLocalAttribute(String name) {
        this.attributes.remove(name);
    }
13851#public String getParameter(String name) {
        if (this.parameters == null) {
            return null;
        }

        final Object value = this.parameters.get(name);
        if (value instanceof String) {
            return (String)value;
        } else if (value == null) {
            return null;
        } else {
            final String[] values = (String[]) value;
            if (values.length == 0) {
                return null;
            }
            return values[0];
        }
    }
13852#public Enumeration getParameterNames() {
        return (this.parameters != null) ? IteratorUtils.asEnumeration(this.parameters.keySet().iterator()) : null;
    }
13853#public String[] getParameterValues(String name) {
        final Object value = this.parameters.get(name);
        if (value instanceof String) {
            return new String[] { (String)value };
        }
        return (String[]) value;
    }
13854#public String getHeader(String name) {
        return (headers != null) ? (String) headers.get(name.toLowerCase()) : null;
    }
13855#public int getIntHeader(String name) {
        String header = (headers != null) ? (String) headers.get(name.toLowerCase()) : null;
        return (header != null) ? Integer.parseInt(header) : -1;
    }
13856#public long getDateHeader(String name) {
        //FIXME
        return 0;
    }
13857#public Enumeration getHeaders(String name) {
        // FIXME
        return SHARED_EMPTY_ENUMERATION;
    }
13858#public Enumeration getHeaderNames() {
        if (headers != null) {
            return IteratorUtils.asEnumeration(headers.keySet().iterator());
        }
        return SHARED_EMPTY_ENUMERATION;
    }
13859#public String getCharacterEncoding() { return characterEncoding; }
13860#public int getContentLength() { return -1; }
13861#public String getContentType() { return null; }
13862#public String getProtocol()  { return "cli"; }
13863#public String getScheme() { return "cli"; }
13864#public String getServerName() { return Constants.COMPLETE_NAME; }
13865#public int getServerPort() { return -1; }
13866#public String getRemoteAddr() { return "127.0.0.1"; }
13867#public String getRemoteHost() { return "localhost"; }
13868#public String getMethod() { return "get"; }
13869#public String getRemoteUser() { return SystemUtils.USER_NAME; }
13870#public javax.servlet.http.Cookie[] getCookies() { return null; }
13871#public Map getCookieMap() {
        return Collections.unmodifiableMap(new HashMap());
    }
13872#public Cookie[] getCocoonCookies() { return null; }
13873#public Map getCocoonCookieMap() {
        return Collections.unmodifiableMap(new HashMap());
    }
13874#/**
     * Returns the current session associated with this request,
     * or if the request does not have a session, creates one.
     *
     * @return                the <code>Session</code> associated
     *                        with this request
     *
     * @see        #getSession(boolean)
     */
    public HttpSession getSession() {
        return this.getSession(true);
    }
13875#/**
     * Returns the current <code>Session</code>
     * associated with this request or, if if there is no
     * current session and <code>create</code> is true, returns
     * a new session.
     *
     * <p>If <code>create</code> is <code>false</code>
     * and the request has no valid <code>Session</code>,
     * this method returns <code>null</code>.
     *
     * <p>To make sure the session is properly maintained,
     * you must call this method before
     * the response is committed.
     *
     * @param create  <code>true</code> to create a new session for this request
     *                if necessary;
     *                <code>false</code> to return <code>null</code> if there's
     *                no current session
     *
     * @return  the <code>Session</code> associated with this request or
     *          <code>null</code> if <code>create</code> is <code>false</code>
     *          and the request has no valid session
     *
     * @see  #getSession()
     */
    public HttpSession getSession(boolean create) {
        return BackgroundSession.getSession(create);
    }
13876#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getCocoonSession(boolean)
     */
    public Session getCocoonSession(boolean create) {
        return (Session) getSession(create);
    }
13877#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getCocoonSession()
     */
    public Session getCocoonSession() {
        return (Session) getSession();
    }
13878#/**
     * Returns the session ID specified by the client. This may
     * not be the same as the ID of the actual session in use.
     * For example, if the request specified an old (expired)
     * session ID and the server has started a new session, this
     * method gets a new session with a new ID. If the request
     * did not specify a session ID, this method returns
     * <code>null</code>.
     *
     *
     * @return                a <code>String</code> specifying the session
     *                        ID, or <code>null</code> if the request did
     *                        not specify a session ID
     *
     * @see                #isRequestedSessionIdValid()
     */
    public String getRequestedSessionId() {
        return (BackgroundSession.getSession(false) != null) ?
                BackgroundSession.getSession(false).getId() : null;
    }
13879#/**
     * Checks whether the requested session ID is still valid.
     *
     * @return                        <code>true</code> if this
     *                                request has an id for a valid session
     *                                in the current session context;
     *                                <code>false</code> otherwise
     *
     * @see                        #getRequestedSessionId()
     * @see                        #getSession()
     */
    public boolean isRequestedSessionIdValid() {
        return (BackgroundSession.getSession(false) != null);
    }
13880#/**
     * Checks whether the requested session ID came in as a cookie.
     *
     * @return                        <code>true</code> if the session ID
     *                                came in as a
     *                                cookie; otherwise, <code>false</code>
     *
     *
     * @see                        #getSession()
     */
    public boolean isRequestedSessionIdFromCookie() {
        return false;
    }
13881#/**
     * Checks whether the requested session ID came in as part of the
     * request URL.
     *
     * @return                        <code>true</code> if the session ID
     *                                came in as part of a URL; otherwise,
     *                                <code>false</code>
     *
     *
     * @see                        #getSession()
     */
    public boolean isRequestedSessionIdFromURL() {
        return false;
    }
13882#public Locale getLocale() { return Locale.getDefault(); }
13883#public Enumeration getLocales() {
        // FIXME
        throw new NotImplementedException (getClass().getName() + ".getLocales() method not yet implemented!");
    }
13884#public String getAuthType() { return null; }
13885#public boolean isSecure() { return false; }
13886#public boolean isUserInRole(String role) { return false; }
13887#public java.security.Principal getUserPrincipal() { return null; }
13888#public java.util.Map getParameterMap() { return parameters; }
13889#public void setCharacterEncoding(java.lang.String env)
                          throws java.io.UnsupportedEncodingException { characterEncoding = env; }
13890#public StringBuffer getRequestURL() { return null; }
13891#/*
	 * @see org.apache.cocoon.environment.Request#getInputStream()
	 */
	public ServletInputStream getInputStream() throws UnsupportedOperationException {
		throw new UnsupportedOperationException();
	}
13892#/**
     * @see org.apache.cocoon.environment.Request#searchAttribute(java.lang.String)
     */
    public Object searchAttribute(String name) {
        Object result = this.getLocalAttribute(name);
        if ( result == null ) {
            result = this.getAttribute(name);
        }
        return result;
    }
13893#public EmptyEnumeration() {
            // nothing to do};
        }
13894#public boolean hasMoreElements() {
            return false;
        }
13895#public Object nextElement() {
            return null;
        }
13896#public BackgroundEnvironment(Context ctx) {
        super("", null, null);
        this.outputStream = new NullOutputStream();

        // TODO Would special Background*-objects have advantages?
        Request request = new BackgroundRequest(
                this,                  // environment
                "",                    // context path
                "",                    // servlet path
                "",                    // path info
                new HashMap(),         // attributes
                Collections.EMPTY_MAP, // parameters
                Collections.EMPTY_MAP  // headers
        );
        this.objectModel.put(ObjectModelHelper.REQUEST_OBJECT, request);
        this.objectModel.put(ObjectModelHelper.RESPONSE_OBJECT,
                             new BackgroundResponse());
        this.objectModel.put(ObjectModelHelper.CONTEXT_OBJECT, ctx);
    }
13897#/**
     * @see org.apache.cocoon.environment.Environment#redirect(java.lang.String, boolean, boolean)
     */
    public void redirect(String newURL, boolean global, boolean permanent) throws IOException {

    }
13898#/**
     * @see org.apache.cocoon.environment.Environment#setContentType(java.lang.String)
     */
    public void setContentType(String mimeType) {
    }
13899#/**
     * @see org.apache.cocoon.environment.Environment#getContentType()
     */
    public String getContentType() {
        return null;
    }
13900#/**
     * @see org.apache.cocoon.environment.Environment#setContentLength(int)
     */
    public void setContentLength(int length) {
    }
13901#/**
     * Always return false
     *
     * @see org.apache.cocoon.environment.Environment#isExternal()
     */
    public boolean isExternal() {
        return false;
    }
13902#public BackgroundSession() {
    }
13903#public long getCreationTime() {
        return this.creationTime;
    }
13904#public String getId() {
        return "1";
    }
13905#public long getLastAccessedTime() {
        return this.creationTime;
    }
13906#public void setMaxInactiveInterval(int interval) {
        // ignored
    }
13907#public int getMaxInactiveInterval() {
        return -1;
    }
13908#public Object getAttribute(String name) {
        return this.attributes.get(name);
    }
13909#public Enumeration getAttributeNames() {
        return this.attributes.keys();
    }
13910#public void setAttribute(String name, Object value) {
        this.attributes.put(name, value);
    }
13911#public void removeAttribute(String name) {
        this.attributes.remove(name);
    }
13912#public void invalidate() {
        this.attributes.clear();
        invalidateSession();
    }
13913#public boolean isNew() {
        return false;
    }
13914#/**
     * Get the current session object - if available
     */
    public static Session getSession(boolean create) {
        if (create && session == null) {
            session = new BackgroundSession();
        }
        return session;
    }
13915#/**
     * Invalidate the current session
     */
    public static void invalidateSession() {
        session = null;
    }
13916#/**
     * Generate XML data out of request InputStream.
     */
    public void generate()
    throws IOException, SAXException, ProcessingException {
        SAXParser parser = null;
        int len = 0;
        String contentType;

        Request request = ObjectModelHelper.getRequest(this.objectModel);
        try {
            contentType = request.getContentType();
            if (contentType == null) {
                contentType = parameters.getParameter("defaultContentType", null);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("no Content-Type header - using contentType parameter: " + contentType);
                }
                if (contentType == null) {
                    throw new IOException("Both Content-Type header and defaultContentType parameter are not set");
                }
            }

            InputSource source;
            if (contentType.startsWith("application/x-www-form-urlencoded") ||
                    contentType.startsWith("multipart/form-data")) {
                String parameter = parameters.getParameter(FORM_NAME, null);
                if (parameter == null) {
                    throw new ProcessingException("StreamGenerator expects a sitemap parameter called '" +
                                                  FORM_NAME + "' for handling form data");
                }

                Object xmlObject = request.get(parameter);
                Reader xmlReader;
                if (xmlObject instanceof String) {
                    xmlReader = new StringReader((String) xmlObject);
                } else if (xmlObject instanceof Part) {
                    xmlReader = new InputStreamReader(((Part) xmlObject).getInputStream());
                } else {
                    throw new ProcessingException("Unknown request object encountered named " + 
                                                  parameter + " : " + xmlObject);
                }

                source = new InputSource(xmlReader);
            } else if (contentType.startsWith("text/plain") ||
                    contentType.startsWith("text/xml") ||
                    contentType.startsWith("application/xhtml+xml") ||
                    contentType.startsWith("application/xml")) {

                HttpServletRequest httpRequest = (HttpServletRequest) objectModel.get(HttpEnvironment.HTTP_REQUEST_OBJECT);
                if (httpRequest == null) {
                    throw new ProcessingException("This feature is only available in an http environment.");
                }
                len = request.getContentLength();
                if (len <= 0) {
                    throw new IOException("getContentLen() == 0");
                }

                PostInputStream anStream = new PostInputStream(httpRequest.getInputStream(), len);
                source = new InputSource(anStream);
            } else {
                throw new IOException("Unexpected getContentType(): " + request.getContentType());
            }

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Processing stream ContentType=" + contentType + " ContentLength=" + len);
            }
            String charset = getCharacterEncoding(request, contentType);
            if (charset != null) {
                source.setEncoding(charset);
            }

            parser = (SAXParser) this.manager.lookup(SAXParser.ROLE);
            parser.parse(source, super.xmlConsumer);
        } catch (IOException e) {
            getLogger().error("StreamGenerator.generate()", e);
            throw new ResourceNotFoundException("StreamGenerator could not find resource", e);
        } catch (SAXException e) {
            getLogger().error("StreamGenerator.generate()", e);
            throw(e);
        } catch (ServiceException e) {
            getLogger().error("Could not get parser", e);
            throw new ProcessingException("Exception in StreamGenerator.generate()", e);
        } finally {
            this.manager.release(parser);
        }
    }
13917#/**
     * Content type HTTP header can contain character encoding information,
     * for example: <code>Content-Type: text/xml; charset=UTF-8</code>.
     *
     * <p>If the servlet is following spec 2.3 and higher, the servlet API can
     * be used to retrieve character encoding part of Content-Type header. Some
     * containers can choose to not unpack charset info - the spec is not strong
     * about it. In any case, this method can be used as a last resort to
     * retrieve the passed charset value.
     *
     * <p>It is very common mistake to send : <code>Content-Type: text/xml; charset="UTF-8"</code>.
     * Some containers are not filtering this mistake and the processing results in exception.
     * This method compensates for the above mistake.
     *
     * <p>If contentType is null or has no charset part, <code>null</code> is returned.
     *
     * @param contentType value associated with Content-Type HTTP header.
     */
    public String getCharacterEncoding(Request req, String contentType) {
        if (contentType == null) {
            return null;
        }

        int idx = contentType.indexOf("charset=");
        if (idx == -1) {
            return null;
        }

        String encoding;
        try {
            encoding = req.getCharacterEncoding();
            if (encoding != null) {
                encoding = cleanup(encoding);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Using charset from container: " + encoding);
                }

                return encoding;
            }
        } catch (Throwable e) {
            // We will be there if the container did not implement getCharacterEncoding() method
        }

        encoding = contentType.substring(idx + "charset=".length());
        int idxEnd = encoding.indexOf(";");
        if (idxEnd != -1) {
            encoding = encoding.substring(0, idxEnd);
        }

        encoding = cleanup(encoding);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Using charset from header: " + encoding);
        }

        return encoding;
    }
13918#private String cleanup(String encoding) {
        encoding = encoding.trim();
        if (encoding.length() > 2 && encoding.startsWith("\"") && encoding.endsWith("\"")) {
            encoding = encoding.substring(1, encoding.length() - 1);
        }

        return encoding;
    }
13919#//
    // Lifecycle
    //

    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
        this.resolver = (SourceResolver) this.manager.lookup(SourceResolver.ROLE);
    }
13920#/**
     * Configure the component.
     *
     * @param configuration the configuration
     */
    public void configure(Configuration configuration) throws ConfigurationException {
        this.directory = configuration.getChild(ConfigurationKeys.ROOT_DIRECTORY).getValue("");

        String cacheRole = configuration.getChild(ConfigurationKeys.STORE_ROLE).getValue(Store.TRANSIENT_STORE);
        try {
            this.cache = (Store) this.manager.lookup(cacheRole);
        } catch (ServiceException e) {
            throw new ConfigurationException("Unable to lookup store '" + cacheRole + "'");
        }

        this.interval = configuration.getChild(ConfigurationKeys.RELOAD_INTERVAL).getValueAsLong(60000L);

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Bundle directory '" + this.directory + "'");
            getLogger().debug("Store role '" + cacheRole + "'");
        }
    }
13921#/**
     * Disposes this component.
     */
    public void dispose() {
        this.manager.release(this.resolver);
        this.manager.release(this.cache);
        this.resolver = null;
        this.cache = null;
        this.manager = null;
    }
13922#//
    // BundleFactory Interface
    //

    /**
     * Returns the root directory to all bundles.
     *
     * @return the directory path
     */
    protected String getDirectory() {
        return this.directory;
    }
13923#/**
     * Select a bundle based on the bundle name and the locale name.
     *
     * @param name        bundle name
     * @param locale      locale name
     * @return            the bundle
     * @exception         Exception if a bundle is not found
     */
    public Bundle select(String name, String locale) throws Exception {
        return select(getDirectory(), name, locale);
    }
13924#/**
     * Select a bundle based on the bundle name and the locale.
     *
     * @param name        bundle name
     * @param locale      locale
     * @return            the bundle
     * @exception         Exception if a bundle is not found
     */
    public Bundle select(String name, Locale locale) throws Exception {
        return select(getDirectory(), name, locale);
    }
13925#/**
     * Select a bundle based on the catalogue base location, bundle name,
     * and the locale name.
     *
     * @param directory   catalogue base location (URI)
     * @param name        bundle name
     * @param localeName  locale name
     * @return            the bundle
     * @exception         Exception if a bundle is not found
     */
    public Bundle select(String directory, String name, String localeName)
    throws Exception {
        return select(directory, name, new Locale(localeName, localeName));
    }
13926#/**
     * Select a bundle based on the catalogue base location, bundle name,
     * and the locale.
     *
     * @param directory   catalogue base location (URI)
     * @param name        bundle name
     * @param locale      locale
     * @return            the bundle
     * @exception         Exception if a bundle is not found
     */
    public Bundle select(String directory, String name, Locale locale)
    throws Exception {
        return select(new String[] { directory }, name, locale);
    }
13927#/**
     * Select a bundle based on the catalogue base location, bundle name,
     * and the locale.
     *
     * @param directories catalogue base location (URI)
     * @param name        bundle name
     * @param locale      locale
     * @return            the bundle
     * @exception         Exception if a bundle is not found
     */
    public Bundle select(String[] directories, String name, Locale locale)
    throws Exception {
        Bundle bundle = _select(directories, 0, name, locale);
        if (bundle == null) {
            throw new Exception("Unable to locate resource: " + name);
        }
        return bundle;
    }
13928#public void release(Bundle bundle) {
        // Do nothing
    }
13929#//
    // Implementation
    //

    /**
     * Select a bundle based on bundle name and locale.
     *
     * @param directories       catalogue location(s)
     * @param name              bundle name
     * @param locale            locale
     * @return                  the bundle
     */
    private XMLResourceBundle _select(String[] directories, int index, String name,
                                      Locale locale)
    throws Exception {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Selecting from: " + name + ", locale: " + locale +
                              ", directory: " + directories[index]);
        }

        final String cacheKey = "XRB" + getCacheKey(directories, index, name, locale);

        XMLResourceBundle bundle = selectCached(cacheKey);
        if (bundle == null) {
            synchronized (this) {
                bundle = selectCached(cacheKey);
                if (bundle == null) {
                    boolean localeAvailable = (locale != null && !locale.getLanguage().equals(""));
                    index++;

                    // Find parent bundle first
                    XMLResourceBundle parent = null;
                    if (localeAvailable && index == directories.length) {
                        // all directories have been searched with this locale,
                        // now start again with the first directory and the parent locale
                        parent = _select(directories, 0, name, getParentLocale(locale));
                    } else if (index < directories.length) {
                        // there are directories left to search for with this locale
                        parent = _select(directories, index, name, locale);
                    }

                    // Create this bundle (if source exists) and pass parent to it.
                    final String sourceURI = getSourceURI(directories[index - 1], name, locale);
                    bundle = _create(sourceURI, locale, parent);
                    updateCache(cacheKey, bundle);
                }
            }
        }
        return bundle;
    }
13930#/**
     * Constructs new bundle.
     *
     * <p>
     * If there is a problem loading the bundle, created bundle will be empty.
     *
     * @param sourceURI   source URI of the XML resource bundle
     * @param locale      locale of the bundle
     * @param parent      parent bundle, if any
     * @return            the bundle
     */
    private XMLResourceBundle _create(String sourceURI,
                                      Locale locale,
                                      XMLResourceBundle parent) {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Creating bundle <" + sourceURI + ">");
        }

        XMLResourceBundle bundle = new XMLResourceBundle(sourceURI, locale, parent);
        bundle.reload(this.resolver, this.interval);
        return bundle;
    }
13931#/**
     * Returns the next locale up the parent hierarchy.
     * E.g. the parent of new Locale("en","us","mac") would be
     * new Locale("en", "us", "").
     *
     * @param locale      the locale
     * @return            the parent locale
     */
    protected Locale getParentLocale(Locale locale) {
        Locale newloc;
        if (locale.getVariant().equals("")) {
            if (locale.getCountry().equals("")) {
                newloc = new Locale("", "", "");
            } else {
                newloc = new Locale(locale.getLanguage(), "", "");
            }
        } else {
            newloc = new Locale(locale.getLanguage(), locale.getCountry(), "");
        }
        return newloc;
    }
13932#/**
     * Creates a cache key for the bundle.
     * @return the cache key
     */
    protected String getCacheKey(String[] directories, int index, String name, Locale locale)
    throws SourceException {
        StringBuffer cacheKey = new StringBuffer();
        if (index < directories.length) {
            cacheKey.append(":");
            cacheKey.append(getSourceURI(directories[index], name, locale));
            index++;
            cacheKey.append(getCacheKey(directories, index, name, locale));
        } else if ((locale != null && !locale.getLanguage().equals(""))) {
            cacheKey.append(getCacheKey(directories, 0, name, getParentLocale(locale)));
        }
        return cacheKey.toString();
    }
13933#/**
     * Maps a bundle name and locale to a bundle source URI.
     * If you need a different mapping, then just override this method.
     *
     * @param base    the base URI for the catalogues
     * @param name    the name of the catalogue
     * @param locale  the locale of the bundle
     * @return        the source URI for the bundle
     */
    protected String getSourceURI(String base, String name, Locale locale)
    throws SourceException {
        // If base is null default to the current location
        if (base == null) {
            base = "";
        }

        // Resolve base URI
        Source src = null;
        Map parameters = Collections.EMPTY_MAP;
        StringBuffer sb = new StringBuffer();
        try {
            src = this.resolver.resolveURI(base);

            // Deparameterize base URL before adding catalogue name
            String uri = NetUtils.deparameterize(src.getURI(),
                                                 parameters = new HashMap(7));

            // Append trailing slash
            sb.append(uri);
            if (!uri.endsWith("/")) {
                sb.append('/');
            }

        } catch (IOException e) {
            throw new SourceNotFoundException("Cannot resolve catalogue base URI <" + base + ">", e);
        } finally {
            this.resolver.release(src);
        }

        // Append catalogue name
        sb.append(name);

        // Append catalogue locale
        if (locale != null) {
            if (!locale.getLanguage().equals("")) {
                sb.append("_");
                sb.append(locale.getLanguage());
            }
            if (!locale.getCountry().equals("")) {
                sb.append("_");
                sb.append(locale.getCountry());
            }
            if (!locale.getVariant().equals("")) {
                sb.append("_");
                sb.append(locale.getVariant());
            }
        }
        sb.append(".xml");

        // Reconstruct complete bundle URI with parameters
        String uri = NetUtils.parameterize(sb.toString(), parameters);

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Resolved name: " + name +
                              ", locale: " + locale + " --> " + uri);
        }
        return uri;
    }
13934#/**
     * Selects a bundle from the cache, and reloads it if needed.
     *
     * @param cacheKey    caching key of the bundle
     * @return            the cached bundle; null, if not found
     */
    protected XMLResourceBundle selectCached(String cacheKey) {
        XMLResourceBundle bundle = (XMLResourceBundle) this.cache.get(cacheKey);

        if (bundle != null && this.interval != -1) {
            // Reload this bundle and all parent bundles, as necessary
            for (XMLResourceBundle b = bundle; b != null; b = (XMLResourceBundle) b.parent) {
                b.reload(this.resolver, this.interval);
            }
        }

        return bundle;
    }
13935#/**
     * Stores bundle in the cache.
     *
     * @param cacheKey    caching key of the bundle
     * @param bundle      bundle to be placed in the cache
     */
    protected void updateCache(String cacheKey, XMLResourceBundle bundle) {
        try {
            this.cache.store(cacheKey, bundle);
        } catch (IOException e) {
            getLogger().error("Bundle <" + bundle.getSourceURI() + ">: unable to store.", e);
        }
    }
13936#/**
     * Select a bundle based on the catalogue base location, bundle name,
     * and the locale name.
     *
     * @param base    catalogue base location (URI)
     * @param bundleName    bundle name
     * @param locale  locale name
     * @return        the bundle
     * @exception     Exception if a bundle is not found
     */
    Bundle select(String base, String bundleName, String locale) throws Exception;
13937#/**
     * Select a bundle based on the catalogue base location, bundle name,
     * and the locale.
     *
     * @param base    catalogue base location (URI)
     * @param bundleName    bundle name
     * @param locale  locale
     * @return        the bundle
     * @exception     Exception if a bundle is not found
     */
    Bundle select(String base, String bundleName, Locale locale) throws Exception;
13938#/**
     * Select a bundle based on the catalogue base location, bundle name,
     * and the locale.
     *
     * @param directories    catalogue base location (URI)
     * @param bundleName    bundle name
     * @param locale  locale
     * @return        the bundle
     * @exception     Exception if a bundle is not found
     */
    Bundle select(String[] directories, String bundleName, Locale locale) throws Exception;
13939#/**
     * Select a bundle based on the bundle name and the locale name from
     * the default catalogue.
     *
     * @param bundleName    bundle name
     * @param locale  locale name
     * @return        the bundle
     * @exception     Exception if a bundle is not found
     */
    Bundle select(String bundleName, String locale) throws Exception;
13940#/**
     * Select a bundle based on the bundle name and the locale from
     * the default catalogue.
     *
     * @param bundleName    bundle name
     * @param locale  locale
     * @return        the bundle
     * @exception     Exception if a bundle is not found
     */
    Bundle select(String bundleName, Locale locale) throws Exception;
13941#/**
     * Releases a bundle back to the bundle factory when it's not needed
     * anymore.
     * @param bundle the bundle
     */
    void release(Bundle bundle);
13942#/**
     * Get string value by key.
     *
     * @param key
     * @return Resource as string.
     * @exception MissingResourceException if resource was not found
     */
    String getString(String key) throws MissingResourceException;
13943#/**
     * Get object value by key.
     *
     * @param key The resource key.
     * @return The resource as object.
     * @exception MissingResourceException if resource was not found
     */
    Object getObject(String key) throws MissingResourceException;
13944#/**
     * Construct a bundle.
     * @param sourceURI source URI of the XML bundle
     * @param locale locale
     * @param parent parent bundle of this bundle
     */
    public XMLResourceBundle(String sourceURI, Locale locale, Bundle parent) {
        this.sourceURI = sourceURI;
        this.locale = locale;
        this.parent = parent;
        this.values = Collections.EMPTY_MAP;
    }
13945#/**
     * (Re)Loads the XML bundle if necessary, based on the source URI.
     * @return true if reloaded successfully
     */
    protected boolean reload(SourceResolver resolver, long interval) {
        Source newSource = null;
        Map newValues;

        try {
            int valid = this.validity == null ? SourceValidity.INVALID : this.validity.isValid();
            if (valid != SourceValidity.VALID) {
                // Saved validity is not valid, get new source and validity
                newSource = resolver.resolveURI(this.sourceURI);
                SourceValidity newValidity = newSource.getValidity();

                if (valid == SourceValidity.INVALID || this.validity.isValid(newValidity) != SourceValidity.VALID) {
                    newValues = new HashMap();
                    SourceUtil.toSAX(newSource, new SAXContentHandler(newValues));
                    synchronized (this) {
                        // Update source validity and values
                        if (interval > 0 && newValidity != null) {
                            this.validity = new DelayedValidity(interval, newValidity);
                        } else {
                            this.validity = newValidity;
                        }
                        this.values = newValues;
                    }
                }
            }

            // Success
            return true;

        } catch (MalformedURLException e) {
            getLogger().error("Bundle <" + this.sourceURI + "> not loaded: Invalid URI", e);
            newValues = Collections.EMPTY_MAP;

        } catch (ResourceNotFoundException e) {
            if (getLogger().isDebugEnabled()) {
                getLogger().info("Bundle <" + sourceURI + "> not loaded: Source URI not found", e);
            } else if (getLogger().isInfoEnabled()) {
                getLogger().info("Bundle <" + sourceURI + "> not loaded: Source URI not found");
            }
            newValues = Collections.EMPTY_MAP;

        } catch (SourceNotFoundException e) {
            // Nominal case where a bundle doesn't exist
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Bundle <" + sourceURI + "> not loaded: Source URI not found");
            }
            newValues = Collections.EMPTY_MAP;

        } catch (CascadingIOException e) {
            // Nominal case where a bundle doesn't exist
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Bundle <" + sourceURI + "> not loaded: Source URI not found");
            }
            newValues = Collections.EMPTY_MAP;

        } catch (SAXException e) {
            getLogger().error("Bundle <" + sourceURI + "> not loaded: Invalid XML", e);
            // Keep existing loaded values
            newValues = this.values;

        } catch (Exception e) {
            getLogger().error("Bundle <" + sourceURI + "> not loaded: Exception", e);
            // Keep existing loaded values
            newValues = this.values;

        } finally {
            if (newSource != null) {
                resolver.release(newSource);
            }
        }

        synchronized (this) {
            // Use expires validity to delay next reloading.
            if (interval > 0) {
                this.validity = new ExpiresValidity(interval);
            } else {
                this.validity = null;
            }
            this.values = newValues;
        }

        // Failure
        return false;
    }
13946#/**
     * Gets the locale of the bundle.
     *
     * @return the locale
     */
    public Locale getLocale() {
        return this.locale;
    }
13947#/**
     * Gets the source URI of the bundle.
     *
     * @return the source URI
     */
    public String getSourceURI() {
        return this.sourceURI;
    }
13948#/**
     * Gets the validity of the bundle.
     *
     * @return the validity
     */
    public SourceValidity getValidity() {
        return this.validity;
    }
13949#/**
     * Get an instance of the {@link ParamSaxBuffer} associated with the key.
     *
     * @param key the key
     * @return the value, or null if no value associated with the key.
     */
    public Object getObject(String key) {
        if (key == null) {
            return null;
        }

        Object value = this.values.get(key);
        if (value != null) {
            return value;
        }

        if (this.parent != null) {
            return this.parent.getObject(key);
        }

        return null;
    }
13950#/**
     * Get a string representation of the value object by key.
     *
     * @param key the key
     * @return the string value, or null if no value associated with the key.
     */
    public String getString(String key) {
        if (key == null) {
            return null;
        }

        Object value = this.values.get(key);
        if (value != null) {
            return value.toString();
        }

        if (this.parent != null) {
            return this.parent.getString(key);
        }

        return null;
    }
13951#public SAXContentHandler(Map values) {
            this.values = values;
        }
13952#public void setDocumentLocator(Locator arg0) {
            // Ignore
        }
13953#public void startDocument() throws SAXException {
            // Ignore
        }
13954#public void endDocument() throws SAXException {
            // Ignore
        }
13955#public void processingInstruction(String arg0, String arg1) throws SAXException {
            // Ignore
        }
13956#public void skippedEntity(String arg0) throws SAXException {
            // Ignore
        }
13957#public void startElement(String ns, String localName, String qName, Attributes atts) throws SAXException {
            switch (this.state) {
                case 0:
                    // <i18n:catalogue>
                    if (!"".equals(ns) && !I18nUtils.matchesI18nNamespace(ns)) {
                        throw new SAXException("Root element <" + EL_CATALOGUE +
                                               "> must be non-namespaced or in i18n namespace.");
                    }
                    if (!EL_CATALOGUE.equals(localName)) {
                        throw new SAXException("Root element must be <" + EL_CATALOGUE + ">.");
                    }
                    this.namespace = ns;
                    this.state++;
                    break;

                case 1:
                    // <i18n:message>
                    if (!EL_MESSAGE.equals(localName)) {
                        throw new SAXException("<" + EL_CATALOGUE + "> must contain <" +
                                               EL_MESSAGE + "> elements only.");
                    }
                    if (!this.namespace.equals(ns)) {
                        throw new SAXException("<" + EL_MESSAGE + "> element must be in '" +
                                               this.namespace + "' namespace.");
                    }
                    String key =  atts.getValue(AT_KEY);
                    if (key == null) {
                        throw new SAXException("<" + EL_MESSAGE + "> must have '" +
                                               AT_KEY + "' attribute.");
                    }
                    this.buffer = new ParamSaxBuffer();
                    this.values.put(key, this.buffer);
                    this.state++;
                    break;

                case 2:
                    this.buffer.startElement(ns, localName, qName, atts);
                    break;

                default:
                    throw new SAXException("Internal error: Invalid state");
            }
        }
13958#public void endElement(String ns, String localName, String qName) throws SAXException {
            switch (this.state) {
                case 0:
                    break;

                case 1:
                    // </i18n:catalogue>
                    this.state--;
                    break;

                case 2:
                    if (this.namespace.equals(ns) && EL_MESSAGE.equals(localName)) {
                        // </i18n:message>
                        this.buffer = null;
                        this.state--;
                    } else {
                        this.buffer.endElement(ns, localName, qName);
                    }
                    break;

                default:
                    throw new SAXException("Internal error: Invalid state");
            }
        }
13959#public void startPrefixMapping(String prefix, String uri) throws SAXException {
            if (this.buffer != null) {
                this.buffer.startPrefixMapping(prefix, uri);
            }
        }
13960#public void endPrefixMapping(String prefix) throws SAXException {
            if (this.buffer != null) {
                this.buffer.endPrefixMapping(prefix);
            }
        }
13961#public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
            if (this.buffer != null) {
                this.buffer.ignorableWhitespace(ch, start, length);
            }
        }
13962#public void characters(char[] ch, int start, int length) throws SAXException {
            if (this.buffer != null) {
                this.buffer.characters(ch, start, length);
            }
        }
13963#private I18nUtils() {
        // Disable instantiation
    }
13964#/**
     * Parses given locale string to Locale object. If the string is null
     * or empty then the given locale is returned.
     *
     * @param localeString - a string containing locale in
     *        <code>language_country_variant</code> format.
     * @param defaultLocale - returned if localeString is <code>null</code>
     *        or <code>""</code>
     */
    public static Locale parseLocale(String localeString, Locale defaultLocale) {
        if (localeString != null && localeString.length() > 0) {
            StringTokenizer st = new StringTokenizer(localeString, LOCALE_DELIMITER);
            String l = st.hasMoreElements() ? st.nextToken() : defaultLocale.getLanguage();
            String c = st.hasMoreElements() ? st.nextToken() : "";
            String v = st.hasMoreElements() ? st.nextToken() : "";
            return new Locale(l, c, v);
        }
        return defaultLocale;
    }
13965#/**
     * Parses given locale string to Locale object. If the string is null
     * then the VM default locale is returned.
     *
     * @param localeString a string containing locale in
     * <code>language_country_variant</code> format.
     *
     * @see #parseLocale(String, Locale)
     * @see java.util.Locale#getDefault()
     */
    public static Locale parseLocale(String localeString) {
        return parseLocale(localeString, Locale.getDefault());
    }
13966#/**
     * Find a suitable locale from an objectModel.
     * @since 2.1.6
     * @return locale found, or null if none found.
     */
    public static Locale findLocale(Map objectModel,
                                    String attribute,
                                    Parameters parameters,
                                    Locale defaultLocale,
                                    boolean useLocale,
                                    boolean useLocales,
                                    boolean useBlankLocale,
                                    LocaleValidator test) {
        String localeStr;
        Locale locale;

        Request request = ObjectModelHelper.getRequest(objectModel);

        // 1. Request parameter 'locale'
        localeStr = request.getParameter(attribute);
        if (localeStr != null) {
            locale = parseLocale(localeStr);
            if (test == null || test.test("request", locale)) {
                return locale;
            }
        }

        // 2. Session attribute 'locale'
        HttpSession session = request.getSession(false);
        if (session != null &&
                ((localeStr = (String) session.getAttribute(attribute)) != null)) {
            locale = parseLocale(localeStr);
            if (test == null || test.test("session", locale)) {
                return locale;
            }
        }

        // 3. First matching cookie parameter 'locale' within each cookie sent
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (int i = 0; i < cookies.length; i++) {
                Cookie cookie = cookies[i];
                if (cookie.getName().equals(attribute)) {
                    localeStr = cookie.getValue();
                    locale = parseLocale(localeStr);
                    if (test == null || test.test("cookie", locale)) {
                        return locale;
                    }
                    break;
                }
            }
        }

        // 4. Sitemap parameter "locale"
        if (parameters != null) {
            localeStr = parameters.getParameter("locale", null);
            if (localeStr != null) {
                locale = parseLocale(localeStr);
                if (test == null || test.test("sitemap", locale)) {
                    return locale;
                }
            }
        }

        // 5. Locale setting of the requesting browser or server default
        if (useLocale && !useLocales) {
            locale = request.getLocale();
            if (test == null || test.test("request", locale)) {
                return locale;
            }
        }
        if (useLocales) {
            Enumeration locales = request.getLocales();
            while (locales.hasMoreElements()) {
                locale = (Locale)locales.nextElement();
                if (test == null || test.test("request", locale)) {
                    return locale;
                }
            }
        }

        // 6. Default
        if (defaultLocale != null) {
            locale = defaultLocale;
            if (test == null || test.test("default", locale)) {
                return locale;
            }
        }

        // 7. Blank
        if (useBlankLocale) {
            locale = new Locale("", "");
            if (test == null || test.test("blank", locale)) {
                return locale;
            }
        }

        // 8. Fail
        return null;
    }
13967#/**
     * Find a suitable locale from an objectModel.
     * @since 2.1.6
     * @return locale found, or server default (never null).
     */
    public static Locale findLocale(Map objectModel,
                                    String attribute,
                                    Parameters parameters,
                                    Locale defaultLocale,
                                    boolean useLocale) {
        return findLocale(objectModel, attribute, parameters, defaultLocale, useLocale, false, false, null);
    }
13968#/**
     * Store locale in request, session, or cookie.
     * @since 2.1.6
     */
    public static void storeLocale(Map objectModel,
                                   String attribute,
                                   String locale,
                                   boolean storeInRequest,
                                   boolean storeInSession,
                                   boolean storeInCookie,
                                   boolean createSession) {
        // store in a request if so configured
        if (storeInRequest) {
            Request request = ObjectModelHelper.getRequest(objectModel);
            request.setAttribute(attribute, locale);
        }

        // store in session if so configured
        if (storeInSession) {
            Request request = ObjectModelHelper.getRequest(objectModel);
            HttpSession session = request.getSession(createSession);
            if (session != null) {
                session.setAttribute(attribute, locale);
            }
        }

        // store in a cookie if so configured
        if (storeInCookie) {
            Response response = ObjectModelHelper.getResponse(objectModel);
            response.addCookie(response.createCookie(attribute, locale));
        }
    }
13969#public static boolean matchesI18nNamespace(String uri) {
        if (NAMESPACE_URI.equals(uri)) {
            return true;
        } else if (OLD_NAMESPACE_URI.equals(uri)) {
            if (!deprecationFound) {
                deprecationFound = true;
                Deprecation.logger.warn("The namespace <" + OLD_NAMESPACE_URI +
                                        "> is deprecated, use: <" + NAMESPACE_URI + ">");
            }
            return true;
        }
        return false;
    }
13970#/**
         * @param name of the locale (for debugging)
         * @param locale to test
         * @return true if locale satisfies validator's criteria
         */
        public boolean test(String name, Locale locale);
13971#public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
        this.resolver = (SourceResolver)this.manager.lookup(SourceResolver.ROLE);
    }
13972#public void configure(Configuration config) {
        this.storeInRequest = config.getChild("store-in-request").getValueAsBoolean(false);
        this.createSession = config.getChild("create-session").getValueAsBoolean(false);
        this.storeInSession = config.getChild("store-in-session").getValueAsBoolean(false);
        this.storeInCookie = config.getChild("store-in-cookie").getValueAsBoolean(false);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug((this.storeInRequest ? "will" : "won't") + " set values in request");
            getLogger().debug((this.createSession ? "will" : "won't") + " create session");
            getLogger().debug((this.storeInSession ? "will" : "won't") + " set values in session");
            getLogger().debug((this.storeInCookie ? "will" : "won't") + " set values in cookies");
        }

        this.localeAttribute = config.getChild("locale-attribute").getValue(DEFAULT_LOCALE_ATTRIBUTE);
        this.testResourceExists = config.getChild("negotiate").getValueAsBoolean(false);

        this.useLocale = config.getChild("use-locale").getValueAsBoolean(true);
        this.useLocales = config.getChild("use-locales").getValueAsBoolean(false);
        this.useBlankLocale = config.getChild("use-blank-locale").getValueAsBoolean(true);

        Configuration child = config.getChild("default-locale", false);
        if (child != null) {
            this.defaultLocale = new Locale(child.getAttribute("language", DEFAULT_DEFAULT_LANG),
                                            child.getAttribute("country", DEFAULT_DEFAULT_COUNTRY),
                                            child.getAttribute("variant", DEFAULT_DEFAULT_VARIANT));
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Locale attribute name is " + this.localeAttribute);
            getLogger().debug((this.testResourceExists ? "will" : "won't") + " negotiate locale");
            getLogger().debug((this.useLocale ? "will" : "won't") + " use request locale");
            getLogger().debug((this.useLocales ? "will" : "won't") + " use request locales");
            getLogger().debug((this.useBlankLocale ? "will" : "won't") + " blank locales");
            getLogger().debug("default locale " + this.defaultLocale);
        }
    }
13973#public void dispose() {
        this.manager.release(this.resolver);
        this.resolver = null;
        this.manager = null;
    }
13974#public Map match(final String pattern, Map objectModel, Parameters parameters)
    throws PatternException {
        final Map map = new HashMap();

        I18nUtils.LocaleValidator validator = new I18nUtils.LocaleValidator() {
            public boolean test(String name, Locale locale) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Testing " + name + " locale: '" + locale + "'");
                }
                return isValidResource(pattern, locale, map);
            }
        };

        Locale locale = I18nUtils.findLocale(objectModel,
                                             localeAttribute,
                                             parameters,
                                             defaultLocale,
                                             useLocale,
                                             useLocales,
                                             useBlankLocale,
                                             validator);

        if (locale == null) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("No locale found for resource: " + pattern);
            }
            return null;
        }

        String localeStr = locale.toString();
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Locale " + localeStr + " found for resource: " + pattern);
        }

        I18nUtils.storeLocale(objectModel,
                              localeAttribute,
                              localeStr,
                              storeInRequest,
                              storeInSession,
                              storeInCookie,
                              createSession);

        return map;
    }
13975#private boolean isValidResource(String pattern, Locale locale, Map map) {
        Locale testLocale;

        // Test "language, country, variant" locale
        if (locale.getVariant().length() > 0) {
            if (isValidResource(pattern, locale, locale, map)) {
                return true;
            }
        }

        // Test "language, country" locale
        if (locale.getCountry().length() > 0) {
            testLocale = new Locale(locale.getLanguage(), locale.getCountry());
            if (isValidResource(pattern, locale, testLocale, map)) {
                return true;
            }
        }

        // Test "language" locale (or empty - if language is "")
        testLocale = new Locale(locale.getLanguage(), "");
        return isValidResource(pattern, locale, testLocale, map);

    }
13976#private boolean isValidResource(String pattern, Locale locale, Locale testLocale, Map map) {
        String url;

        String testLocaleStr = testLocale.toString();
        if ("".equals(testLocaleStr)) {
            // If same character found before and after the '*', leave only one.
            int starPos = pattern.indexOf("*");
            if (starPos < pattern.length() - 1 && starPos > 1 &&
                    pattern.charAt(starPos - 1) == pattern.charAt(starPos + 1)) {
                url = pattern.substring(0, starPos - 1) + pattern.substring(starPos + 1);
            } else {
                url = StringUtils.replace(pattern, "*", "");
            }
        } else {
            url = StringUtils.replace(pattern, "*", testLocaleStr);
        }

        boolean result = true;
        if (testResourceExists) {
            Source source = null;
            try {
                source = resolver.resolveURI(url);
                result = source.exists();
            } catch (IOException e) {
                result = false;
            } finally {
                if (source != null) {
                    resolver.release(source);
                }
            }
        }

        if (result) {
            map.put("source", url);
            map.put("matched-locale", testLocaleStr);
            if (locale != null) {
                map.put("locale", locale.toString());
                map.put("language", locale.getLanguage());
                map.put("country", locale.getCountry());
                map.put("variant", locale.getVariant());
            }
        }

        return result;
    }
13977#public ServletSettings(Settings s) {
        // set defaults
        this.showTime = SHOW_TIME;
        this.hideShowTime = HIDE_SHOW_TIME;
        this.showCocoonVersion = SHOW_COCOON_VERSION;
        this.manageExceptions = MANAGE_EXCEPTIONS;

        if (s != null) {
            String value;
            value = s.getProperty(KEY_SHOWTIME);
            if (value != null) {
                this.setShowTime(BooleanUtils.toBoolean(value));
            }
            value = s.getProperty(KEY_HIDE_SHOWTIME);
            if (value != null) {
                this.setHideShowTime(BooleanUtils.toBoolean(value));
            }
            value = s.getProperty(KEY_SHOW_VERSION);
            if (value != null) {
                this.setShowCocoonVersion(BooleanUtils.toBoolean(value));
            }
            value = s.getProperty(KEY_MANAGE_EXCEPTIONS);
            if (value != null) {
                this.setManageExceptions(BooleanUtils.toBoolean(value));
            }
        }
    }
13978#/**
     * @return Returns the hideShowTime.
     * @see #KEY_HIDE_SHOWTIME
     */
    public boolean isHideShowTime() {
        return this.hideShowTime;
    }
13979#/**
     * @return Returns the manageExceptions.
     * @see #KEY_MANAGE_EXCEPTIONS
     */
    public boolean isManageExceptions() {
        return this.manageExceptions;
    }
13980#/**
     * @return Returns the showTime.
     * @see #KEY_SHOWTIME
     */
    public boolean isShowTime() {
        return this.showTime;
    }
13981#/**
     * @return Returns the showCocoonVersion.
     * @see #KEY_SHOW_VERSION
     */
    public boolean isShowVersion() {
        return this.showCocoonVersion;
    }
13982#/**
     * @param hideShowTime The hideShowTime to set.
     */
    public void setHideShowTime(boolean hideShowTime) {
        this.hideShowTime = hideShowTime;
    }
13983#/**
     * @param manageExceptions The manageExceptions to set.
     */
    public void setManageExceptions(boolean manageExceptions) {
        this.manageExceptions = manageExceptions;
    }
13984#/**
     * @param showTime The showTime to set.
     */
    public void setShowTime(boolean showTime) {
        this.showTime = showTime;
    }
13985#/**
     * @param showCocoonVersion The showCocoonVersion flag to set.
     */
    public void setShowCocoonVersion(boolean showCocoonVersion) {
        this.showCocoonVersion = showCocoonVersion;
    }
13986#public static String getCompleteUri(HttpServletRequest request,
                                        HttpServletResponse response)
    throws IOException {
        // Start with servlet path
        String uri = request.getServletPath();
        // uri should never be null, but we check it anyway
        if (uri == null) {
            uri = "";
        }

        String pathInfo = request.getPathInfo();
        if (pathInfo != null) {
            // VG: WebLogic fix: Both uri and pathInfo starts with '/'
            // This problem exists only in WL6.1sp2, not in WL6.0sp2 or WL7.0b.
            // Comment: The servletPath always starts with '/', so it seems
            //          that the above mentioned bug is only occuring if the servlet path
            //          is just a "/".
            if (uri.length() > 0 && uri.charAt(0) == '/') {
                uri = uri.substring(1);
            }
            uri += pathInfo;
        }

        if (uri.length() == 0) {
            /*
             * Empty relative URI. Issue HTTP redirect from '/block' to '/block/' to
             * avoid breaking relative URIs in the response generated by the sitemap
             * which expects to be mounted at '.../'.
             */
            String serverAbsoluteUri = request.getRequestURI();
            if (serverAbsoluteUri == null) {
                serverAbsoluteUri = "/";
            } else {
                serverAbsoluteUri += "/";
            }

            response.sendRedirect(response.encodeRedirectURL(serverAbsoluteUri));
            return null;
        }

        if (uri.charAt(0) == '/') {
            uri = uri.substring(1);
        }
        return uri;
    }
13987#/**
     * Same as {@link #getCompleteUri(HttpServletRequest, HttpServletResponse)} but
     * disregards {@link HttpServletRequest#getServletPath()}.
     *
     * <br>Used by {@link SitemapServlet}.
     */
    public static String getCompleteBlockUri(HttpServletRequest request,
                                             HttpServletResponse response)
    throws IOException {
        // The original implementation prepend the servlet context path which doesn't work
        // in the tree processor if there actually is a servlet context path
        // VG: ...but still need to know if servlet path had a '/' at the end
        //     (in case if path info is empty, need to know whether to issue a redirect or not)
        String servletPath = request.getServletPath();
        if (servletPath == null) {
            servletPath = "";
        }

        String uri = request.getPathInfo();
        if (uri == null) {
            uri = "";
        }

        if (uri.length() == 0 && !servletPath.endsWith("/")) {
            /*
             * Empty relative URI. Issue HTTP redirect from '/block' to '/block/' to
             * avoid breaking relative URIs in the response generated by the sitemap
             * which expects to be mounted at '.../'.
             */
            String serverAbsoluteUri = request.getRequestURI();
            if (serverAbsoluteUri == null) {
                serverAbsoluteUri = "/";
            } else {
                serverAbsoluteUri += "/";
            }

            response.sendRedirect(response.encodeRedirectURL(serverAbsoluteUri));
            return null;
        }

        if (uri.length() > 0 && uri.charAt(0) == '/') {
            return uri.substring(1);
        }

        return uri;
    }
13988#public static HttpServletRequest createRequestForUri(HttpServletRequest request, String servletPath, String pathInfo) {
        return new UriHttpServletRequestWrapper(request, servletPath, pathInfo);
    }
13989#public static HttpServletRequest createRequestByRemovingPrefixFromUri(HttpServletRequest request, String prefix) {
        String servletPath = request.getServletPath();
        String pathInfo = request.getPathInfo();
        String newPathInfo = pathInfo.substring(prefix.length()+1);

        String newServletPath;
        if (servletPath == null) {
            newServletPath = pathInfo.substring(0, prefix.length() + 1);
        } else {
            newServletPath = servletPath + pathInfo.substring(0, prefix.length() + 1);
        }

        return new UriHttpServletRequestWrapper(request, newServletPath, newPathInfo);
    }
13990#public static void manageException(HttpServletRequest  req,
                                       HttpServletResponse res,
                                       Environment         env,
                                       String              uri,
                                       int                 errorStatus,
                                       String              title,
                                       String              message,
                                       String              description,
                                       Exception           e,
                                       ServletSettings     settings,
                                       Log                 logger,
                                       Object              sender)
    throws IOException {
        manageException(req, res, env, uri, errorStatus, title, message, description, e, settings, logger.isInfoEnabled(), sender);
    }
13991#private static void manageException(HttpServletRequest  req,
                                        HttpServletResponse res,
                                        Environment         env,
                                        String              uri,
                                        int                 errorStatus,
                                        String              title,
                                        String              message,
                                        String              description,
                                        Exception           e,
                                        ServletSettings     settings,
                                        boolean             verbose,
                                        Object              sender)
    throws IOException {
        if (settings.isManageExceptions()) {
            if (env != null) {
                env.tryResetResponse();
            } else {
                res.reset();
            }

            String type = Notifying.FATAL_NOTIFICATION;
            Map extraDescriptions = null;

            if (errorStatus == HttpServletResponse.SC_NOT_FOUND) {
                type = "resource-not-found";
                // Do not show the exception stacktrace for such common errors.
                e = null;
            } else {
                extraDescriptions = new HashMap(2);
                extraDescriptions.put(Notifying.EXTRA_REQUESTURI, req.getRequestURI());
                if (uri != null) {
                    extraDescriptions.put("Request URI", uri);
                }

                // Do not show exception stack trace when log level is WARN or above. Show only message.
                if (verbose) {
                    Throwable t = DefaultNotifyingBuilder.getRootCause(e);
                    if (t != null) {
                        extraDescriptions.put(Notifying.EXTRA_CAUSE, t.getMessage());
                    }

                    e = null;
                }
            }

            Notifying n = new DefaultNotifyingBuilder().build(sender,
                                                              e,
                                                              type,
                                                              title,
                                                              "Cocoon Servlet",
                                                              message,
                                                              description,
                                                              extraDescriptions);
            
            res.setContentType("text/html");
            res.setStatus(errorStatus);
            Notifier.notify(n, res.getOutputStream(), "text/html");
        } else {
            res.sendError(errorStatus, title);
            res.flushBuffer();
        }
    }
13992#public UriHttpServletRequestWrapper(HttpServletRequest request, String servletPath, String pathInfo) {
        super(request);
        this.servletPath = servletPath;
        this.pathInfo = pathInfo;
        final StringBuffer buffer = new StringBuffer();
        if ( request.getContextPath() != null ) {
            buffer.append(request.getContextPath());
        }
        if ( buffer.length() == 1 && buffer.charAt(0) == '/' ) {
            buffer.deleteCharAt(0);
        }
        if ( servletPath != null ) {
            buffer.append(servletPath);
        }
        if ( pathInfo != null ) {
            buffer.append(pathInfo);
        }
        if ( buffer.charAt(0) != '/' ) {
            buffer.insert(0, '/');
        }
        this.uri = buffer.toString();
        
    }
13993#/**
     * @see javax.servlet.http.HttpServletRequestWrapper#getPathInfo()
     */
    public String getPathInfo() {
        return this.pathInfo;
    }
13994#/**
     * @see javax.servlet.http.HttpServletRequestWrapper#getRequestURI()
     */
    public String getRequestURI() {
        return this.uri;
    }
13995#/**
     * @see javax.servlet.http.HttpServletRequestWrapper#getRequestURL()
     */
    public StringBuffer getRequestURL() {
        final StringBuffer buffer = new StringBuffer();
        buffer.append(this.getProtocol());
        buffer.append("://");
        buffer.append(this.getServerName());
        boolean appendPort = true;
        if ( this.getScheme().equals("http") && this.getServerPort() == 80 ) {
            appendPort = false;
        }
        if ( this.getScheme().equals("https") && this.getServerPort() == 443) {
            appendPort = false;
        }
        if ( appendPort ) {
            buffer.append(':');
            buffer.append(this.getServerPort());
        }
        buffer.append(this.uri);
        return buffer;
    }
13996#/**
     * @see javax.servlet.http.HttpServletRequestWrapper#getServletPath()
     */
    public String getServletPath() {
        return this.servletPath;
    }
13997#/**
     * @see javax.servlet.Filter#init(javax.servlet.FilterConfig)
     */
    public void init(FilterConfig config) throws ServletException {
    }
13998#/**
     * @see javax.servlet.Filter#destroy()
     */
    public void destroy() {
        // nothing to do here
    }
13999#/**
     * Log debug information about the current environment.
     * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)
     */
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain filterChain)
    throws IOException, ServletException {
        // we don't do debug msgs if this is not a http servlet request
        if ( ! (req instanceof HttpServletRequest) ) {
            filterChain.doFilter(req, res);
            return;
        }
        try {
            ++activeRequestCount;
            final HttpServletRequest request = (HttpServletRequest) req;

            if (getLogger().isDebugEnabled()) {
                final StringBuffer msg = new StringBuffer();

                msg.append("DEBUGGING INFORMATION:").append(lineSeparator);
                msg.append("REQUEST: ").append(request.getRequestURI()).append(lineSeparator).append(
                        lineSeparator);
                msg.append("CONTEXT PATH: ").append(request.getContextPath()).append(lineSeparator);
                msg.append("SERVLET PATH: ").append(request.getServletPath()).append(lineSeparator);
                msg.append("PATH INFO: ").append(request.getPathInfo()).append(lineSeparator).append(
                        lineSeparator);

                msg.append("REMOTE HOST: ").append(request.getRemoteHost()).append(lineSeparator);
                msg.append("REMOTE ADDRESS: ").append(request.getRemoteAddr()).append(lineSeparator);
                msg.append("REMOTE USER: ").append(request.getRemoteUser()).append(lineSeparator);
                msg.append("REQUEST SESSION ID: ").append(request.getRequestedSessionId()).append(
                        lineSeparator);
                msg.append("REQUEST PREFERRED LOCALE: ").append(request.getLocale().toString()).append(
                        lineSeparator);
                msg.append("SERVER HOST: ").append(request.getServerName()).append(lineSeparator);
                msg.append("SERVER PORT: ").append(request.getServerPort()).append(lineSeparator).append(
                        lineSeparator);

                msg.append("METHOD: ").append(request.getMethod()).append(lineSeparator);
                msg.append("CONTENT LENGTH: ").append(request.getContentLength()).append(lineSeparator);
                msg.append("PROTOCOL: ").append(request.getProtocol()).append(lineSeparator);
                msg.append("SCHEME: ").append(request.getScheme()).append(lineSeparator);
                msg.append("AUTH TYPE: ").append(request.getAuthType()).append(lineSeparator).append(
                        lineSeparator);
                msg.append("CURRENT ACTIVE REQUESTS: ").append(activeRequestCount).append(lineSeparator);

                // log all of the request parameters
                final Enumeration e = request.getParameterNames();

                msg.append("REQUEST PARAMETERS:").append(lineSeparator).append(lineSeparator);

                while (e.hasMoreElements()) {
                    String p = (String) e.nextElement();

                    msg.append("PARAM: '").append(p).append("' ").append("VALUES: '");
                    String[] params = request.getParameterValues(p);
                    for (int i = 0; i < params.length; i++) {
                        msg.append("[" + params[i] + "]");
                        if (i != (params.length - 1)) {
                            msg.append(", ");
                        }
                    }

                    msg.append("'").append(lineSeparator);
                }

                // log all of the header parameters
                final Enumeration e2 = request.getHeaderNames();

                msg.append("HEADER PARAMETERS:").append(lineSeparator).append(lineSeparator);

                while (e2.hasMoreElements()) {
                    String p = (String) e2.nextElement();

                    msg.append("PARAM: '").append(p).append("' ").append("VALUES: '");
                    Enumeration e3 = request.getHeaders(p);
                    while (e3.hasMoreElements()) {
                        msg.append("[" + e3.nextElement() + "]");
                        if (e3.hasMoreElements()) {
                            msg.append(", ");
                        }
                    }

                    msg.append("'").append(lineSeparator);
                }

                msg.append(lineSeparator).append("SESSION ATTRIBUTES:").append(lineSeparator).append(
                        lineSeparator);

                // log all of the session attributes
                final HttpSession session = ((HttpServletRequest) req).getSession(false);
                if (session != null) {
                    // Fix bug #12139: Session can be modified while still
                    // being enumerated here
                    synchronized (session) {
                        final Enumeration se = session.getAttributeNames();
                        while (se.hasMoreElements()) {
                            String p = (String) se.nextElement();
                            msg.append("PARAM: '").append(p).append("' ").append("VALUE: '").append(
                                    session.getAttribute(p)).append("'").append(lineSeparator);
                        }
                    }
                }
                getLogger().debug(msg.toString());
            }

            // Delegate
            filterChain.doFilter(request, res);
        } finally {
            --activeRequestCount;
        }
    }
14000#public void service(HttpServletRequest req, HttpServletResponse res)
    throws ServletException, IOException {
        this.processor.service(req, res);
    }
14001#/**
     * @see javax.servlet.GenericServlet#init()
     */
    public void init() throws ServletException {
        super.init();
        this.processor = new RequestProcessor(getServletContext());
    }
14002#public RequestProcessor(ServletContext servletContext) {
        this.servletContext = servletContext;
        this.cocoonBeanFactory = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);

        this.settings = (Settings) this.cocoonBeanFactory.getBean(Settings.ROLE);
        this.servletSettings = new ServletSettings(this.settings);

        final String encoding = this.settings.getContainerEncoding();
        if (encoding == null) {
            this.containerEncoding = "ISO-8859-1";
        } else {
            this.containerEncoding = encoding;
        }

        // Obtain access logger
        String category = servletContext.getInitParameter("org.apache.cocoon.servlet.logger.access");
        if (category == null || category.length() == 0) {
            category = "access";
        }
        setLogger(LoggerUtils.getChildLogger(this.cocoonBeanFactory, category));

        this.processor = getProcessor();
        this.environmentContext = new HttpContext(this.servletContext);

        // get the optional request listener
        if (this.cocoonBeanFactory.containsBean(RequestListener.ROLE)) {
            this.requestListener = (RequestListener) this.cocoonBeanFactory.getBean(RequestListener.ROLE);
        }
    }
14003#protected Processor getProcessor() {
        return (Processor) this.cocoonBeanFactory.getBean(Processor.ROLE);
    }
14004#protected boolean rethrowExceptions() {
        return false;
    }
14005#/**
     * Process the specified <code>HttpServletRequest</code> producing output
     * on the specified <code>HttpServletResponse</code>.
     */
    public void service(HttpServletRequest request, HttpServletResponse res)
    throws ServletException, IOException {
        // used for timing the processing
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();

        // add the cocoon version header stamp
        if (this.servletSettings.isShowVersion()) {
            res.addHeader("X-Cocoon-Version", Constants.VERSION);
        }

        // We got it... Process the request
        final String uri = getURI(request, res);
        if (uri == null) {
            // a redirect occured, so we are finished
            return;
        }

        Environment env;
        try{
            // Pass uri into environment without URLDecoding, as it is already decoded.
            env = getEnvironment(uri, request, res);
        } catch (Exception e) {
            if (getLogger().isErrorEnabled()) {
                getLogger().error("Problem with Cocoon servlet", e);
            }

            if (rethrowExceptions()) {
                throw new ServletException(e);
            }

            RequestUtil.manageException(request, res, null, uri,
                                        HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                                        "Problem in creating the Environment", null, null, e,
                                        this.servletSettings, getLogger(), this);
            return;
        }

        String contentType = null;
        try {
            if (process(env)) {
                contentType = env.getContentType();
            } else {
                // We reach this when there is nothing in the processing chain that matches
                // the request. For example, no matcher matches.
                getLogger().fatal("The Cocoon engine failed to process the request.");

                if (rethrowExceptions()) {
                    throw new ServletException("The Cocoon engine failed to process the request.");
                }

                RequestUtil.manageException(request, res, env, uri,
                                            HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                                            "Request Processing Failed",
                                            "Cocoon engine failed in processing the request",
                                            "The processing engine failed to process the request. This could be due to lack of matching or bugs in the pipeline engine.",
                                            null,
                                            this.servletSettings, getLogger(), this);
                return;
            }
        } catch (ResourceNotFoundException e) {
            if (getLogger().isDebugEnabled()) {
                getLogger().warn(e.getMessage(), e);
            } else if (getLogger().isWarnEnabled()) {
                getLogger().warn(e.getMessage());
            }

            if (rethrowExceptions()) {
                throw new ServletException(e);
            }

            RequestUtil.manageException(request, res, env, uri,
                                        HttpServletResponse.SC_NOT_FOUND,
                                        "Resource Not Found",
                                        "Resource Not Found",
                                        "The requested resource \"" + request.getRequestURI() + "\" could not be found",
                                        e,
                                        this.servletSettings, getLogger(), this);
            return;

        } catch (ConnectionResetException e) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug(e.toString(), e);
            } else if (getLogger().isWarnEnabled()) {
                getLogger().warn(e.toString());
            }

        } catch (IOException e) {
            // Tomcat5 wraps SocketException into ClientAbortException which extends IOException.
            if (getLogger().isDebugEnabled()) {
                getLogger().debug(e.toString(), e);
            } else if (getLogger().isWarnEnabled()) {
                getLogger().warn(e.toString());
            }

        } catch (Exception e) {
            if (getLogger().isErrorEnabled()) {
                getLogger().error("Internal Cocoon Problem", e);
            }

            if (rethrowExceptions()) {
                throw new ServletException(e);
            }

            RequestUtil.manageException(request, res, env, uri,
                                        HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                                        "Internal Server Error", null, null, e,
                                        this.servletSettings, getLogger(), this);
            return;
        }

        stopWatch.stop();
        String timeString = null;
        if (getLogger().isInfoEnabled()) {
            timeString = processTime(stopWatch.getTime());
            getLogger().info("'" + uri + "' " + timeString);
        }

        if (contentType != null && contentType.equals("text/html")) {
            String showTime = request.getParameter(Constants.SHOWTIME_PARAM);
            boolean show = this.servletSettings.isShowTime();
            if (showTime != null) {
                show = !showTime.equalsIgnoreCase("no");
            }
            if (show) {
                if (timeString == null) {
                    timeString = processTime(stopWatch.getTime());
                }
                boolean hide = this.servletSettings.isHideShowTime();
                if (showTime != null) {
                    hide = showTime.equalsIgnoreCase("hide");
                }
                ServletOutputStream out = res.getOutputStream();
                out.print((hide) ? "<!-- " : "<p>");
                out.print(timeString);
                out.println((hide) ? " -->" : "</p>");
            }
        }

        /*
         * Servlet Specification 2.2, 6.5 Closure of Response Object:
         *
         *   A number of events can indicate that the servlet has provided all of the
         *   content to satisfy the request and that the response object can be
         *   considered to be closed. The events are:
         *     o The termination of the service method of the servlet.
         *     o When the amount of content specified in the setContentLength method
         *       of the response has been written to the response.
         *     o The sendError method is called.
         *     o The sendRedirect method is called.
         *   When a response is closed, all content in the response buffer, if any remains,
         *   must be immediately flushed to the client.
         *
         * Due to the above, out.flush() and out.close() are not necessary, and sometimes
         * (if sendError or sendRedirect were used) request may be already closed.
         */
    }
14006#protected String getURI(HttpServletRequest request, HttpServletResponse res) throws IOException {
        return RequestUtil.getCompleteUri(request, res);
    }
14007#/**
     * Create the environment for the request
     */
    protected Environment getEnvironment(String uri,
                                         HttpServletRequest req,
                                         HttpServletResponse res)
    throws Exception {

        String formEncoding = req.getParameter("cocoon-form-encoding");
        if (formEncoding == null) {
            formEncoding = this.settings.getFormEncoding();
        }

        HttpEnvironment env;
        env = new HttpEnvironment(uri,
                                  req,
                                  res,
                                  this.servletContext,
                                  this.environmentContext,
                                  this.containerEncoding,
                                  formEncoding);
        return env;
    }
14008#private String processTime(long time) {
        StringBuffer out = new StringBuffer(PROCESSED_BY);
        if (time <= SECOND) {
            out.append(time);
            out.append(" milliseconds.");
        } else if (time <= MINUTE) {
            out.append(time / SECOND);
            out.append(" seconds.");
        } else if (time <= HOUR) {
            out.append(time / MINUTE);
            out.append(" minutes.");
        } else {
            out.append(time / HOUR);
            out.append(" hours.");
        }
        return out.toString();
    }
14009#/**
     * @see org.apache.cocoon.Processor#process(org.apache.cocoon.environment.Environment)
     */
    protected boolean process(Environment environment) throws Exception {
        environment.startingProcessing();
        final int environmentDepth = EnvironmentHelper.markEnvironment();
        EnvironmentHelper.enterProcessor(this.processor, environment);
        try {
            boolean result;

            if (this.requestListener != null) {
                try {
                    requestListener.onRequestStart(environment);
                } catch (Exception e) {
                    getLogger().error("Error encountered monitoring request start", e);
                }
            }

            result = this.processor.process(environment);

            if (this.requestListener != null) {
                try {
                    requestListener.onRequestEnd(environment);
                } catch (Exception e) {
                    getLogger().error("Error encountered monitoring request end",  e);
                }
            }

            // commit response on success
            environment.commitResponse();

            return result;
        } catch (Exception any) {
            if (this.requestListener != null) {
                try {
                    requestListener.onRequestException(environment, any);
                } catch (Exception e) {
                    getLogger().error("Error encountered monitoring request exception", e);
                }
            }

            // reset response on error
            environment.tryResetResponse();
            throw any;
        } finally {
            EnvironmentHelper.leaveProcessor();
            environment.finishingProcessing();
            EnvironmentHelper.checkEnvironment(environmentDepth);
        }
    }
14010#/**
     * Creates a new pushback token stream from in.
     *
     * @param in The input stream
     */
    public TokenStream(PushbackInputStream in) {
        this(in,1);
    }
14011#/**
     * Creates a new pushback token stream from in.
     *
     * @param in The input stream
     * @param size Size (in bytes) of the pushback buffer
     */
    public TokenStream(PushbackInputStream in, int size) {
        super(in,size);
        this.in = in;
    }
14012#/**
     * Sets the boundary to scan for
     *
     * @param boundary A byte array containg the boundary
     *
     * @throws MultipartException
     */
    public void setBoundary(byte[] boundary) throws MultipartException {
        this.boundary = boundary;
        if (state == STATE_NOBOUNDARY) {
            state = STATE_READING;
        }
    }
14013#/**
     * Start reading the next part in the stream. This method may only be called
     * if state is STATE_NEXTPART. It will throw a MultipartException if not.
     *
     * @throws MultipartException
     */
    public void nextPart() throws MultipartException {
        if (state != STATE_NEXTPART) {
            throw new MultipartException("Illegal state");
        }
        state = STATE_READING;
    }
14014#/**
     * Return the stream state
     *
     */
    public int getState() {
        return state;
    }
14015#/**
     * Fill the ouput buffer until either it's full, the boundary has been reached or
     * the end of the inputstream has been reached.
     * When a boundary is reached it is entirely read away including trailing \r's and \n's.
     * It will not be written to the output buffer.
     * The stream state is updated after each call.
     *
     * @param out The output buffer
     *
     * @throws IOException
     */
    private int readToBoundary(byte[] out) throws IOException {
        if (state != STATE_READING) {
            return 0;
        }
        int boundaryIndex = 0;
        int written = 0;
        int b = in.read();

        while (true) {
            while ((byte) b != boundary[0]) {
                if (b == -1) {
                    state = STATE_ENDOFSTREAM;
                    return written;
                }
                out[written++] = (byte) b;

                if (written == out.length) {
                    return written;
                }
                b = in.read();
            }
            boundaryIndex = 0;                         // we know the first byte matched
            // check for boundary
            while ((boundaryIndex < boundary.length)
                    && ((byte) b == boundary[boundaryIndex])) {
                b = in.read();
                boundaryIndex++;
            }

            if (boundaryIndex == boundary.length) {    // matched boundary
                if (b != -1) {
                    if (b == '\r') {                   // newline, another part follows
                        state = STATE_NEXTPART;
                        in.read();
                    } else if (b == '-') {             // hyphen, end of multipart
                        state = STATE_ENDMULTIPART;
                        in.read();                     // read next hyphen
                        in.read();                     // read \r
                        in.read();                     // read \n
                    } else {                           // something else, error
                        throw new IOException(
                                "Unexpected character after boundary");
                    }
                } else {    // nothing after boundary, this shouldn't happen either
                    state = STATE_ENDOFSTREAM;
                }
                return written;
            }
            // did not match boundary
            // bytes skipped, write first skipped byte, push back the rest
            if (b != -1) {                         // b may be -1
                in.unread(b);                      // the non-matching byte
            }
            in.unread(boundary, 1,
                    boundaryIndex - 1);          // unread skipped boundary data
            out[written++] = boundary[0];
            if (written == out.length) {
                return written;
            }
            b = in.read();
        }
    }
14016#/**
     * @see java.io.InputStream#read(byte[])
     *
     * @param out
     *
     * @throws IOException
     */
    public int read(byte[] out) throws IOException {
        if (state != STATE_READING) {
            return 0;
        }
        return readToBoundary(out);
    }
14017#/**
     * @see java.io.InputStream#read(byte[],int,int)
     *
     * @param out
     * @param off
     * @param len
     *
     * @throws IOException
     */
    public int read(byte[] out, int off, int len) throws IOException {
        if ((off < 0) || (off >= out.length)) {
            throw new IOException("Buffer offset outside buffer");
        }
        if (off + len >= out.length) {
            throw new IOException("Buffer end outside buffer");
        }
        if (len < 0) {
            throw new IOException("Length must be a positive integer");
        }
        byte[] buf = new byte[len];
        int read = read(buf);
        if (read > 0) {
            System.arraycopy(buf, 0, out, off, read);
        }
        return read;
    }
14018#/**
     * @see java.io.InputStream#read()
     *
     * @throws IOException
     */
    public int read() throws IOException {
        byte[] buf = new byte[1];
        int read = read(buf);

        if (read == 0) {
            return -1;
        }
        return buf[0];
    }
14019#/**
     * Constructor PartOnDisk
     *
     * @param headers
     * @param file
     */
    public PartOnDisk(Map headers, File file) {
        super(headers);
        this.file = file;

        // Ensure the file will be deleted when we exit the JVM
        this.file.deleteOnExit();

        this.size = (int) file.length();
    }
14020#/**
     * Returns the file name
     */
    public String getFileName() {
        return file.getName();
    }
14021#/**
     * Returns the file size in bytes
     */
    public int getSize() {
        return this.size;
    }
14022#/**
     * Returns the file
     */
    public File getFile() {
        return file;
    }
14023#/**
     * Returns a (ByteArray)InputStream containing the file data
     *
     * @throws IOException
     */
    public InputStream getInputStream() throws IOException {
        if (this.file != null) {
            return new FileInputStream(file);
        }
        throw new IllegalStateException("This part has already been disposed.");
    }
14024#/**
     * Returns the filename
     */
    public String toString() {
        return file.getPath();
    }
14025#/**
     * Delete the underlying file.
     */
    public void dispose() {
        if (this.file != null) {
            this.file.delete();
            this.file = null;
        }
    }
14026#/**
     * Ensures the underlying file has been deleted
     */
    public void finalize() throws Throwable {
        // Ensure the file has been deleted
        dispose();
        super.finalize();
    }
14027#/**
     * Constructor, parses given request
     *
     * @param saveUploadedFilesToDisk Write fileparts to the uploadDirectory. If true the corresponding object
     *              in the hashtable will contain a FilePartFile, if false a FilePartArray
     * @param uploadDirectory The directory to write to if saveUploadedFilesToDisk is true.
     * @param allowOverwrite Allow existing files to be overwritten.
     * @param silentlyRename If file exists rename file (using filename+number).
     * @param maxUploadSize The maximum content length accepted.
     * @param characterEncoding The character encoding to be used.
     */
    public MultipartParser(boolean saveUploadedFilesToDisk,
                           File uploadDirectory,
                           boolean allowOverwrite,
                           boolean silentlyRename,
                           int maxUploadSize,
                           String characterEncoding)
    {
        this.saveUploadedFilesToDisk = saveUploadedFilesToDisk;
        this.uploadDirectory = uploadDirectory;
        this.allowOverwrite = allowOverwrite;
        this.silentlyRename = silentlyRename;
        this.maxUploadSize = maxUploadSize;
        this.characterEncoding = characterEncoding;
    }
14028#private void parseParts(int contentLength, String contentType, InputStream requestStream)
    throws IOException, MultipartException {
        this.contentLength = contentLength;
        if (contentLength > this.maxUploadSize) {
            this.oversized = true;
        }

        BufferedInputStream bufferedStream = new BufferedInputStream(requestStream);
        PushbackInputStream pushbackStream = new PushbackInputStream(bufferedStream, MAX_BOUNDARY_SIZE);
        TokenStream stream = new TokenStream(pushbackStream);

        parseMultiPart(stream, getBoundary(contentType));
    }
14029#public Hashtable getParts(int contentLength, String contentType, InputStream requestStream)
    throws IOException, MultipartException {
        this.parts = new Hashtable();
        parseParts(contentLength, contentType, requestStream);
        return this.parts;
    }
14030#public Hashtable getParts(HttpServletRequest request) throws IOException, MultipartException {
        this.parts = new Hashtable();

        // Copy all parameters coming from the request URI to the parts table.
        // This happens when a form's action attribute has some parameters
        Enumeration names = request.getParameterNames();
        while(names.hasMoreElements()) {
            String name = (String)names.nextElement();
            String[] values = request.getParameterValues(name);
            Vector v = new Vector(values.length);
            for (int i = 0; i < values.length; i++) {
                v.add(values[i]);
            }
            this.parts.put(name, v);
        }

        // upload progress bar support
        this.session = request.getSession();
        this.hasSession = this.session != null;
        if (this.hasSession) {
            this.uploadStatus = new Hashtable();
            this.uploadStatus.put("started", Boolean.FALSE);
            this.uploadStatus.put("finished", Boolean.FALSE);
            this.uploadStatus.put("sent", new Integer(0));
            this.uploadStatus.put("total", new Integer(request.getContentLength()));
            this.uploadStatus.put("filename", "");
            this.uploadStatus.put("error", Boolean.FALSE);
            this.uploadStatus.put("uploadsdone", new Integer(0));
            this.session.setAttribute(UPLOAD_STATUS_SESSION_ATTR, this.uploadStatus);
        }

        parseParts(request.getContentLength(), request.getContentType(), request.getInputStream());

        if (this.hasSession) {
            this.uploadStatus.put("finished", Boolean.TRUE);
        }

        return this.parts;
    }
14031#/**
     * Parse a multipart block
     *
     * @param ts
     * @param boundary
     *
     * @throws IOException
     * @throws MultipartException
     */
    private void parseMultiPart(TokenStream ts, String boundary)
            throws IOException, MultipartException {

        ts.setBoundary(boundary.getBytes());
        ts.read();    // read first boundary away
        ts.setBoundary(("\r\n" + boundary).getBytes());

        while (ts.getState() == TokenStream.STATE_NEXTPART) {
            ts.nextPart();
            parsePart(ts);
        }

        if (ts.getState() != TokenStream.STATE_ENDMULTIPART) {    // sanity check
            throw new MultipartException("Malformed stream");
        }
    }
14032#/**
     * Parse a single part
     *
     * @param ts
     *
     * @throws IOException
     * @throws MultipartException
     */
    private void parsePart(TokenStream ts)
            throws IOException, MultipartException {

        Hashtable headers = new Hashtable();
        headers = readHeaders(ts);
        try {
            if (headers.containsKey("filename")) {
                if (!"".equals(headers.get("filename"))) {
                    parseFilePart(ts, headers);
                } else {
                    // IE6 sends an empty part with filename="" for
                    // empty upload fields. Just parse away the part
                    byte[] buf = new byte[32];
                    while(ts.getState() == TokenStream.STATE_READING)
                        ts.read(buf);
                }
            } else if (((String) headers.get("content-disposition"))
                    .toLowerCase().equals("form-data")) {
                parseInlinePart(ts, headers);
            }

            // FIXME: multipart/mixed parts are untested.
            else if (((String) headers.get("content-disposition")).toLowerCase()
                    .indexOf("multipart") > -1) {
                parseMultiPart(new TokenStream(ts, MAX_BOUNDARY_SIZE),
                        "--" + (String) headers.get("boundary"));
                ts.read();    // read past boundary
            } else {
                throw new MultipartException("Unknown part type");
            }
        } catch (IOException e) {
            throw new MultipartException("Malformed stream: " + e.getMessage());
        } catch (NullPointerException e) {
            e.printStackTrace();
            throw new MultipartException("Malformed header");
        }
    }
14033#/**
     * Parse a file part
     *
     * @param in
     * @param headers
     *
     * @throws IOException
     * @throws MultipartException
     */
    private void parseFilePart(TokenStream in, Hashtable headers)
            throws IOException, MultipartException {

        byte[] buf = new byte[FILE_BUFFER_SIZE];
        OutputStream out;
        File file = null;

        if (oversized) {
            out = new NullOutputStream();
        } else if (!saveUploadedFilesToDisk) {
            out = new ByteArrayOutputStream();
        } else {
            String fileName = (String) headers.get("filename");
            if(File.separatorChar == '\\')
                fileName = fileName.replace('/','\\');
            else
                fileName = fileName.replace('\\','/');

            String filePath = uploadDirectory.getPath() + File.separator;
            fileName = new File(fileName).getName();
            file = new File(filePath + fileName);

            if (!allowOverwrite && !file.createNewFile()) {
                if (silentlyRename) {
                    int c = 0;
                    do {
                        file = new File(filePath + c++ + "_" + fileName);
                    } while (!file.createNewFile());
                } else {
                    throw new MultipartException("Duplicate file '" + file.getName()
                        + "' in '" + file.getParent() + "'");
                }
            }

            out = new FileOutputStream(file);
        }

        if (hasSession) { // upload widget support
            this.uploadStatus.put("finished", Boolean.FALSE);
            this.uploadStatus.put("started", Boolean.TRUE);
            this.uploadStatus.put("widget", headers.get("name"));
            this.uploadStatus.put("filename", headers.get("filename"));
        }

        int length = 0; // Track length for OversizedPart
        try {
            int read = 0;
            while (in.getState() == TokenStream.STATE_READING) {
                // read data
                read = in.read(buf);
                length += read;
                out.write(buf, 0, read);

                if (this.hasSession) {
                    this.uploadStatus.put("sent",
                        new Integer(((Integer)this.uploadStatus.get("sent")).intValue() + read)
                    );
                }
            }
            if (this.hasSession) { // upload widget support
                this.uploadStatus.put("uploadsdone",
                    new Integer(((Integer)this.uploadStatus.get("uploadsdone")).intValue() + 1)
                );
                this.uploadStatus.put("error", Boolean.FALSE);
            }
        } catch (IOException ioe) {
            // don't let incomplete file uploads pile up in the upload dir.
            // this usually happens with aborted form submits containing very large files.
            out.close();
            out = null;
            if ( file!=null ) file.delete();
            if (this.hasSession) { // upload widget support
                this.uploadStatus.put("error", Boolean.TRUE);
            }
            throw ioe;
        } finally {
            if ( out!=null ) out.close();
        }

        String name = (String)headers.get("name");
        if (oversized) {
            this.parts.put(name, new RejectedPart(headers, length, this.contentLength, this.maxUploadSize));
        } else if (file == null) {
            byte[] bytes = ((ByteArrayOutputStream) out).toByteArray();
            this.parts.put(name, new PartInMemory(headers, bytes));
        } else {
            this.parts.put(name, new PartOnDisk(headers, file));
        }
    }
14034#/**
     * Parse an inline part
     *
     * @param in
     * @param headers
     *
     * @throws IOException
     */
    private void parseInlinePart(TokenStream in, Hashtable headers)
            throws IOException {

        // Buffer incoming bytes for proper string decoding (there can be multibyte chars)
        ByteArrayOutputStream bos = new ByteArrayOutputStream();

        while (in.getState() == TokenStream.STATE_READING) {
            int c = in.read();
            if (c != -1) bos.write(c);
        }

        String field = (String) headers.get("name");
        Vector v = (Vector) this.parts.get(field);

        if (v == null) {
            v = new Vector();
            this.parts.put(field, v);
        }

        v.add(new String(bos.toByteArray(), this.characterEncoding));
    }
14035#/**
     * Read part headers
     *
     * @param in
     *
     * @throws IOException
     */
    private Hashtable readHeaders(TokenStream in) throws IOException {

        Hashtable headers = new Hashtable();
        String hdrline = readln(in);

        while (!"".equals(hdrline)) {
            StringTokenizer tokenizer = new StringTokenizer(hdrline);

            headers.put(tokenizer.nextToken(" :").toLowerCase(),
                    tokenizer.nextToken(" :;"));

            // The extra tokenizer.hasMoreTokens() in headers.put
            // handles the filename="" case IE6 submits for an empty
            // upload field.
            while (tokenizer.hasMoreTokens()) {
                headers.put(tokenizer.nextToken(" ;=\""),
                        tokenizer.hasMoreTokens()?tokenizer.nextToken("=\""):"");
            }

            hdrline = readln(in);
        }

        return headers;
    }
14036#/**
     * Get boundary from contentheader
     */
    private String getBoundary(String hdr) {

        int start = hdr.toLowerCase().indexOf("boundary=");
        if (start > -1) {
            return "--" + hdr.substring(start + 9);
        }
        return null;
    }
14037#/**
     * Read string until newline or end of stream
     *
     * @param in
     *
     * @throws IOException
     */
    private String readln(TokenStream in) throws IOException {

        ByteArrayOutputStream bos = new ByteArrayOutputStream();

        int b = in.read();

        while ((b != -1) && (b != '\r')) {
            bos.write(b);
            b = in.read();
        }

        if (b == '\r') {
            in.read();    // read '\n'
        }

        return new String(bos.toByteArray(), this.characterEncoding);
    }
14038#public MultipartConfigurationHelper() {
        this.enableUploads = ENABLE_UPLOADS;
        this.autosaveUploads = SAVE_UPLOADS_TO_DISK;
        this.maxUploadSize = MAX_UPLOAD_SIZE;        
    }
14039#/**
     * Configure this from the settings object.
     * @param settings
     */
    public void configure(Settings settings, Log logger) {
        String value;

        value = settings.getProperty(KEY_UPLOADS_ENABLE);
        if (value != null) {
            setEnableUploads(BooleanUtils.toBoolean(value));
        }
        value = settings.getProperty(KEY_UPLOADS_DIRECTORY);
        if (value != null) {
            setUploadDirectory(value);
        }
        value = settings.getProperty(KEY_UPLOADS_AUTOSAVE);
        if (value != null) {
            setAutosaveUploads(BooleanUtils.toBoolean(value));
        }
        value = settings.getProperty(KEY_UPLOADS_OVERWRITE);
        if (value != null) {
            setOverwriteUploads(value);
        }
        value = settings.getProperty(KEY_UPLOADS_MAXSIZE);
        if (value != null) {
            setMaxUploadSize(Integer.valueOf(value).intValue());
        }

        final String uploadDirParam = getUploadDirectory();
        File uploadDir;
        if (uploadDirParam != null) {
            uploadDir = new File(uploadDirParam);
            if (logger.isDebugEnabled()) {
                logger.debug("Using upload-directory " + uploadDir);
            }
        } else {
            uploadDir = new File(settings.getWorkDirectory(), "upload-dir" + File.separator);
            if (logger.isDebugEnabled()) {
                logger.debug("Using default upload-directory " + uploadDir);
            }
        }

        uploadDir.mkdirs();
        setUploadDirectory(uploadDir.getAbsolutePath());
    }
14040#/**
     * @return Returns the autosaveUploads.
     * @see #KEY_UPLOADS_AUTOSAVE
     */
    public boolean isAutosaveUploads() {
        return this.autosaveUploads;
    }
14041#/**
     * @return Returns the enableUploads.
     * @see #KEY_UPLOADS_ENABLE
     */
    public boolean isEnableUploads() {
        return this.enableUploads;
    }
14042#/**
     * @return Returns the maxUploadSize.
     * @see #KEY_UPLOADS_MAXSIZE
     */
    public int getMaxUploadSize() {
        return this.maxUploadSize;
    }
14043#/**
     * @return Returns the overwriteUploads.
     * @see #KEY_UPLOADS_OVERWRITE
     */
    public String getOverwriteUploads() {
        return this.overwriteUploads;
    }
14044#/**
     * @return Returns the uploadDirectory.
     * @see #KEY_UPLOADS_DIRECTORY
     */
    public String getUploadDirectory() {
        return this.uploadDirectory;
    }
14045#public boolean isAllowOverwrite() {
        final String value = this.getOverwriteUploads();
        if ("deny".equalsIgnoreCase(value)) {
            return false;
        } else if ("allow".equalsIgnoreCase(value)) {
            return true;
        } else {
            // either rename is specified or unsupported value - default to rename.
            return false;
        }
    }
14046#public boolean isSilentlyRename() {
        final String value = getOverwriteUploads();
        if ("deny".equalsIgnoreCase(value)) {
            return false;
        } else if ("allow".equalsIgnoreCase(value)) {
            return false; // ignored in this case
        } else {
            // either rename is specified or unsupported value - default to rename.
            return true;
        }
    }
14047#/**
     * @param autosaveUploadsValue The autosaveUploads to set.
     */
    public void setAutosaveUploads(boolean autosaveUploadsValue) {
        this.autosaveUploads = autosaveUploadsValue;
    }
14048#/**
     * @param enableUploads The enableUploads to set.
     */
    public void setEnableUploads(boolean enableUploads) {
        this.enableUploads = enableUploads;
    }
14049#/**
     * @param maxUploadSize The maxUploadSize to set.
     */
    public void setMaxUploadSize(int maxUploadSize) {
        this.maxUploadSize = maxUploadSize;
    }
14050#/**
     * @param overwriteUploads The overwriteUploads to set.
     */
    public void setOverwriteUploads(String overwriteUploads) {
        this.overwriteUploads = overwriteUploads;
    }
14051#/**
     * @param uploadDirectory The uploadDirectory to set.
     */
    public void setUploadDirectory(String uploadDirectory) {
        this.uploadDirectory = uploadDirectory;
    }
14052#public RequestFactory (boolean saveUploadedFilesToDisk, 
                           File uploadDirectory, 
                           boolean allowOverwrite, 
                           boolean silentlyRename, 
                           int maxUploadSize,
                           String defaultCharEncoding) {
       this.saveUploadedFilesToDisk = saveUploadedFilesToDisk;
       this.uploadDirectory = uploadDirectory;
       this.allowOverwrite = allowOverwrite;
       this.silentlyRename = silentlyRename;
       this.maxUploadSize = maxUploadSize;
       this.defaultCharEncoding = defaultCharEncoding;
       
       if (saveUploadedFilesToDisk) {
           // Empty the contents of the upload directory
           File[] files = uploadDirectory.listFiles();
           for (int i = 0; i < files.length; i++) {
               files[i].delete();
           }
       }
    }
14053#/**
     * If the request includes a "multipart/form-data", then wrap it with
     * methods that allow easier connection to those objects since the servlet
     * API doesn't provide those methods directly.
     */
    public HttpServletRequest getServletRequest(HttpServletRequest request) throws IOException, MultipartException {
        HttpServletRequest req = request;
        String contentType = request.getContentType();
        
        if ((contentType != null) && (contentType.toLowerCase().indexOf("multipart/form-data") > -1)) {
 
            String charEncoding = request.getCharacterEncoding();
            if (charEncoding == null || charEncoding.equals("")) {
                charEncoding = this.defaultCharEncoding;
            }
            
            MultipartParser parser = new MultipartParser(
                    this.saveUploadedFilesToDisk, 
                    this.uploadDirectory, 
                    this.allowOverwrite, 
                    this.silentlyRename, 
                    this.maxUploadSize,
                    charEncoding);
                    
            Hashtable parts = parser.getParts(request);
            
            req = new MultipartHttpServletRequest(request,parts);
        }

        return req;
    }
14054#protected Part(Map headers) {
	    this.headers = headers;
    }
14055#/**
     * Returns the part headers
     */
    public Map getHeaders() {
        return headers;
    }
14056#/**
     * Returns the filename
     */
    public abstract String getFileName();
14057#/**
     * Returns the original filename
     */
    public String getUploadName(){
        return (String) headers.get("filename");
    }
14058#/**
     * Returns the length of the file content
     */
    public abstract int getSize();
14059#/**
     * Is this part a rejected part? Provided as an alternative to <code>instanceof RejectedPart</code>
     * in places where it's not convenient such as flowscript.
     * 
     * @return <code>true</code> if this part was rejected
     */
    public boolean isRejected() {
        return false;
    }
14060#/**
     * Returns the mime type (or null if unknown)
     */
    public String getMimeType() {
        return (String) headers.get("content-type");
    }
14061#/**
     * Do we want any temporary resource held by this part to be cleaned up when processing of
     * the request that created it is finished? Default is <code>true</code>.
     * 
     * @return <code>true</code> if the part should be disposed with the request.
     */
    public boolean disposeWithRequest() {
        return this.disposeWithRequest;
    }
14062#/**
     * Set the value of the <code>disposeWithRequest</code> flag (default is <code>true</code>).
     * 
     * @param dispose <code>true</code> if the part should be disposed after request processing
     */
    public void setDisposeWithRequest(boolean dispose) {
        this.disposeWithRequest = dispose;
    }
14063#/**
     * Returns an InputStream containing the file data
     * @throws IOException
     */
    public abstract InputStream getInputStream() throws IOException;
14064#/**
     * Convenience method to copy a part to a modifiable source.
     * 
     * @param source the modifiable source to write to
     * @throws IOException
     * @since 2.1.8
     */
    public void copyToSource(ModifiableSource source) throws IOException {
        InputStream is = getInputStream();
        try {
            OutputStream os = source.getOutputStream();
            try {
                IOUtils.copy(is, os);
            } finally {
                os.close();
            }
        } finally {
            is.close();
        }
    }
14065#/**
     * Convenience method to copy a part to a file.
     * 
     * @param filename name of the file to write to
     * @throws IOException
     * @since 2.1.8
     */
    public void copyToFile(String filename) throws IOException {
        InputStream is = getInputStream();
        try {
            OutputStream os = new FileOutputStream(filename);
            try {
                IOUtils.copy(is, os);
            } finally {
                os.close();
            }
        } finally {
            is.close();
        }
    }
14066#/**
     * Dispose any resources held by this part, such as a file or memory buffer.
     * <p>
     * Disposal occurs in all cases when the part is garbage collected, but calling it explicitely
     * allows to cleanup resources more quickly.
     */
    public abstract void dispose();
14067#/**
     * Create this wrapper around the given request and including the given
     * parts.
     */
    public MultipartHttpServletRequest(HttpServletRequest request, Hashtable values) {
        super(request);
        this.values = values;
    }
14068#/**
     * Cleanup eventually uploaded parts that were saved on disk
     */
    public void cleanup() throws IOException {
        Enumeration e = getParameterNames();
        while (e.hasMoreElements()) {
            Object o = get( (String)e.nextElement() );
            if (o instanceof Part) {
                Part part = (Part)o;
                if (part.disposeWithRequest()) {
                    part.dispose();
                }
            }
        }
    }
14069#/**
     * @see org.apache.cocoon.environment.ValueHolder#get(java.lang.String)
     */
    public Object get(String name) {
        Object result = null;

        if (values != null) {
            result = values.get(name);

            if (result instanceof Vector) {
                if (((Vector) result).size() == 1) {
                    return ((Vector) result).elementAt(0);
                }
                return result;
            }
        } else {
            String[] array = this.getRequest().getParameterValues(name);
            Vector vec = new Vector();

            if (array != null) {
                for (int i = 0; i < array.length; i++) {
                    vec.addElement(array[i]);
                }

                if (vec.size() == 1) {
                    result = vec.elementAt(0);
                } else {
                    result = vec;
                }
            }
        }

        return result;
    }
14070#/**
     * Method getParameterNames
     *
     */
    public Enumeration getParameterNames() {
        if (values != null) {
            return values.keys();
        }
        return this.getRequest().getParameterNames();
    }
14071#/**
     * Method getParameter
     *
     * @param name
     *
     */
    public String getParameter(String name) {
        if (values != null) {
            Object value = get(name);
            String result = null;
    
            if (value != null) {
                if (value instanceof Vector) {
                    value = ((Vector) value).elementAt(0);
                }
    
                result = value.toString();
            }
            return result;
        } else {
            return super.getParameter(name);
        }
    }
14072#/**
     * Method getParameterValues
     *
     * @param name
     *
     */
    public String[] getParameterValues(String name) {
        if (values != null) {
            Object value = get(name);

            if (value != null) {
                if (value instanceof Vector) {
                    String[] results = new String[((Vector)value).size()];
                    for (int i=0;i<((Vector)value).size();i++) {
                        results[i] = ((Vector)value).elementAt(i).toString();
                    }
                    return results;

                }
                return new String[]{value.toString()};
            }

            return null;
        }
        return this.getRequest().getParameterValues(name);
    }
14073#/**
     * Constructor MultipartException
     */
    public MultipartException() {
        super();
    }
14074#/**
     * Constructor MultipartException
     *
     * @param text
     */
    public MultipartException(String text) {
        super(text);
    }
14075#public RejectedPart(Map headers, int partSize, int contentLength, int maxContentLength) {
        super(headers);
        this.size = partSize;
        this.contentLength = contentLength;
        this.maxContentLength = maxContentLength;
    }
14076#public String getFileName() {
        return (String) headers.get("filename");
    }
14077#/**
     * Get the size of this part.
     * 
     * @return the size in bytes
     */
    public int getSize() {
        return this.size;
    }
14078#/**
     * Get the maximum allowed upload size. Not that this applies to the full request content length,
     * including multipart boundaries and other form data values.
     * <p>
     * This means that an upload part can be rejected although it's individual size is (a bit) smaller
     * than the maximum size. It is therefore advisable to use {@link #getContentLength()} to build
     * error messages rather than {@link #getSize()}.
     * 
     * @return the maximum content length in bytes
     */
    public int getMaxContentLength() {
        return this.maxContentLength;
    }
14079#/**
     * Get the content length of the request that cause this part to be rejected.
     * 
     * @return the content length in bytes
     */
    public int getContentLength() {
        return this.contentLength;
    }
14080#/**
     * Always throw an <code>IOException</code> as this part was rejected.
     */
    public InputStream getInputStream() throws IOException {
        throw new IOException("Multipart element '" + getFileName() + "' is too large (" +
                this.size + " bytes) and was discarded.");
    }
14081#/**
     * Always return <code>true</code>
     */
    public boolean isRejected() {
        return true;
    }
14082#public void dispose() {
        // nothing
    }
14083#/**
     * @see javax.servlet.Filter#init(javax.servlet.FilterConfig)
     */
    public void init(FilterConfig config) throws ServletException {
        this.servletContext = config.getServletContext();
    }
14084#/**
     * @see javax.servlet.Filter#destroy()
     */
    public void destroy() {
        // nothing to do
    }
14085#protected synchronized void configure() {
        if (this.cocoonBeanFactory == null) {
            this.cocoonBeanFactory = WebApplicationContextUtils.getRequiredWebApplicationContext(this.servletContext);
            this.settings = (Settings) this.cocoonBeanFactory.getBean(Settings.ROLE);
            this.servletSettings = new ServletSettings(this.settings);
            String containerEncoding;
            final String encoding = this.settings.getContainerEncoding();
            if (encoding == null) {
                containerEncoding = "ISO-8859-1";
            } else {
                containerEncoding = encoding;
            }

            final MultipartConfigurationHelper config = new MultipartConfigurationHelper();
            config.configure(this.settings, getLogger());

            this.requestFactory = new RequestFactory(config.isAutosaveUploads(),
                                                     new File(config.getUploadDirectory()),
                                                     config.isAllowOverwrite(),
                                                     config.isSilentlyRename(),
                                                     config.getMaxUploadSize(),
                                                     containerEncoding);
        }
    }
14086#/**
     * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)
     */
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain filterChain)
    throws IOException, ServletException {
        if (this.cocoonBeanFactory == null) {
            this.configure();
        }

        // get the request (wrapped if contains multipart-form data)
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;
        try{

            try {
                request = this.requestFactory.getServletRequest(request);
            } catch (Exception e) {
                if (getLogger().isErrorEnabled()) {
                    getLogger().error("Problem in multipart filter. Unable to create request.", e);
                }

                RequestUtil.manageException(request, response, null, null,
                                            HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                                            "Problem in creating the Request",
                                            null, null, e, this.servletSettings, getLogger(), this);
            }

            filterChain.doFilter(request, response);

        } finally {
            try {
                if (request instanceof MultipartHttpServletRequest) {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("Deleting uploaded file(s).");
                    }
                    ((MultipartHttpServletRequest) request).cleanup();
                }
            } catch (IOException e) {
                getLogger().error("MultipartFilter got an exception while trying to cleanup the uploaded files.", e);
            }
        }
    }
14087#/**
     * Constructor PartInMemory
     */
    public PartInMemory(Map headers, byte[] bytes) {
        super(headers);
        this.bytes = bytes;
        this.size = bytes.length;
    }
14088#/**
     * Returns the filename
     */
    public String getFileName() {
        return (String) headers.get("filename");
    }
14089#/**
     * Returns the filesize in bytes
     */
    public int getSize() {
        return this.size;
    }
14090#/**
     * Returns a (ByteArray)InputStream containing the file data
     *
     * @throws IOException
     */
    public InputStream getInputStream() throws IOException {
        if (this.bytes != null) {
            return new ByteArrayInputStream(this.bytes);
        } else {
            throw new IllegalStateException("This part has already been disposed.");
        }
    }
14091#/**
     * Clean the byte array content buffer holding part data
     */
    public void dispose() {
        this.bytes = null;
    }
14092#/**
     * Initialize the servlet. The main purpose of this method is creating a
     * configured {@link TreeProcessor}.
     */
    public void init() throws ServletException {
        super.init();
        this.processor = new RequestProcessor(getServletContext());
    }
14093#/**
     * Process the incoming request using the Cocoon tree processor.
     */
    protected void service(HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException {

        this.processor.service(request, response);
    }
14094#/**
     * @see javax.servlet.GenericServlet#destroy()
     */
    public void destroy() {
        if (this.processor != null) {
            this.processor.destroy();
        }
        super.destroy();
    }
14095#public RequestProcessor(ServletContext servletContext) {
            super(servletContext);
        }
14096#protected boolean rethrowExceptions() {
            return true;
        }
14097#protected Processor getProcessor() {
            // read tree processor configuration
            Configuration config;
            try {
                config = createTreeProcessorConfiguration(this.servletContext);
            } catch (IOException e) {
                throw new BeanCreationException("Could not create configuration for TreeProcesoor", e);
            }

            ServiceManager serviceManager =
                (ServiceManager) this.cocoonBeanFactory.getBean(AvalonUtils.SERVICE_MANAGER_ROLE);

            // create the tree processor
            Processor processor;
            try {
                processor = new TreeProcessor();
                ContainerUtil.service(processor, serviceManager);
                ContainerUtil.configure(processor, config);
                ContainerUtil.initialize(processor);
            } catch (Exception e) {
                throw new BeanCreationException("Could not create TreeProcessor", e);
            }

            return processor;
        }
14098#protected void destroy() {
            if (this.processor != null) {
                ContainerUtil.dispose(this.processor);
                this.processor = null;
            }
        }
14099#/**
         * @see org.apache.cocoon.servlet.RequestProcessor#getURI(HttpServletRequest, HttpServletResponse)
         */
        protected String getURI(HttpServletRequest request, HttpServletResponse response) throws IOException {
            return RequestUtil.getCompleteBlockUri(request, response);
        }
14100#/**
         * Create an Avalon Configuration @link {@link Configuration} that configures the tree processor.
         * @throws IOException
         */
        private Configuration createTreeProcessorConfiguration(ServletContext servletContext)
        throws IOException {
            // Get the uri to the sitemap location and resolve it in the curent servlet context.
            // Please note that it is very important that the Treeprocessor receives a resolved
            // uri, simply providing a uri relative to the current context is not enough
            // and doesn't work
            String sitemapPath = getInitParameter(PARAM_SITEMAP_PATH);
            if (sitemapPath == null) {
                sitemapPath = DEFAULT_SITEMAP_PATH;
            }

            URL uri = servletContext.getResource(sitemapPath);
            if (uri == null) {
                throw new IOException("Couldn't find the sitemap " + sitemapPath);
            }
            String sitemapURI = uri.toExternalForm();

            // Create configuration
            DefaultConfiguration config = new DefaultConfiguration("sitemap");
            config.setAttribute("file", sitemapURI);

            // Set check-reload attribute
            String checkReloadStr = getInitParameter(PARAM_CHECK_RELOAD);
            if (checkReloadStr != null) {
                boolean checkReload = BooleanUtils.toBoolean(checkReloadStr);
                config.setAttribute("check-reload", checkReload);
            }

            // Set pass-through attribute
            String passThroughStr = getInitParameter(PARAM_PASS_THROUGH);
            if (passThroughStr != null) {
                boolean passThrough = BooleanUtils.toBoolean(passThroughStr);
                config.setAttribute("pass-through", passThrough);
            }

            // Done
            return config;
        }
14101#/**
     * Set the <code>SourceResolver</code>, objectModel <code>Map</code>,
     * the source and sitemap <code>Parameters</code> used to process the request.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par) throws ProcessingException,
        SAXException, IOException {
            this.links = (List)objectModel.get(Constants.LINK_COLLECTION_OBJECT);
    }
14102#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     *
     * @return The generated key hashes the src
     */
    public java.io.Serializable getKey() {
        return "1";
    }
14103#/**
     * Generate the validity object.
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity() {
//      Whilst the cache does not store gathered links, this component must be non-cacheable
//      return NOPValidity.SHARED_INSTANCE;
        return null;
    }
14104#public void simpleLink(String href, String role, String arcrole, String title, String show, String actuate, String uri,
        String name, String raw, Attributes attr) throws SAXException {
            if (!this.links.contains(href)){
                this.addLink(href);
            }
            super.simpleLink(href, role, arcrole, title, show, actuate, uri, name, raw, attr);
    }
14105#public void startLocator(String href, String role, String title, String label, String uri, String name, String raw,
        Attributes attr) throws SAXException {
            if (!this.links.contains(href)){
                this.addLink(href);
            }
            super.startLocator(href, role, title, label, uri, name, raw, attr);
    }
14106#private void addLink(String href) {
        if (href.length() == 0) return;
        if (href.charAt(0) == '#') return;
        if (href.indexOf("://") != -1) return;
        if (href.startsWith("mailto:")) return;
        if (href.startsWith("news:")) return;
        if (href.startsWith("javascript:")) return;

        int anchorPos = href.indexOf('#');
        if (anchorPos == -1) {
            this.links.add(href);
        } else {
            this.links.add(href.substring(0, anchorPos));
        }
    }
14107#/**
     * Set the <code>SourceResolver</code>, objectModel <code>Map</code>,
     * the source and sitemap <code>Parameters</code> used to process the request.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par) 
    throws ProcessingException, SAXException, IOException {
        this.links = (Map)objectModel.get(Constants.LINK_OBJECT);
    }
14108#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     *
     * @return The generated key hashes the src
     */
    public java.io.Serializable getKey() {
        return "1";
    }
14109#/**
     * Generate the validity object.
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity() {
        return NOPValidity.SHARED_INSTANCE;
    }
14110#public void simpleLink(String href, String role, String arcrole, 
                           String title, String show, String actuate, String uri,
                           String name, String raw, Attributes attr) 
    throws SAXException {
        final String newHref = (String)this.links.get(href);
        super.simpleLink((newHref != null) ? newHref : href, role, arcrole, title, show, actuate, uri, name, raw, attr);
    }
14111#public void startLocator(String href, String role, String title, 
                             String label, String uri, String name, String raw,
                             Attributes attr) 
    throws SAXException {
        final String newHref = (String)this.links.get(href);
        super.startLocator((newHref != null) ? newHref : href, role, title, label, uri, name, raw, attr);
    }
14112#public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        super.setup(resolver, objectModel, src, par);

        Deprecation.logger.warn("NotifyingGenerator is deprecated in favor of ExceptionGenerator, at " +
                                LocationUtils.getLocation(par));

        this.notification = (Notifying) objectModel.get(Constants.NOTIFYING_OBJECT);
        if (this.notification == null) {
            throw new ProcessingException("Expected Constants.NOTIFYING_OBJECT not found in object model.");
        }
    }
14113#/**
     * Generate the notification information in XML format.
     *
     * @throws SAXException when there is a problem creating the
     *      output SAX events.
     */
    public void generate() throws SAXException {
        Notifier.notify(this.notification, this.contentHandler, "text/xml");
    }
14114#/**
     * Recycle
     */
    public void recycle() {
        super.recycle();
        this.notification = null;
    }
14115#public void configure(Configuration config) throws ConfigurationException {
        this.startElement = new ElementData();
        this.startElement.uri = config.getChild("start").getAttribute("uri", "");
        this.startElement.loc = config.getChild("start").getAttribute("local-name", "form-instance");
        this.startElement.raw = config.getChild("start").getAttribute("raw-name", "form-instance");

        this.nameElement = new ElementData();
        this.nameElement.uri = config.getChild("name").getAttribute("uri", "");
        this.nameElement.loc = config.getChild("name").getAttribute("local-name", "form");
        this.nameElement.raw = config.getChild("name").getAttribute("raw-name", "form");
        this.qname = config.getChild("name").getAttribute("name-attribute", "name");

        this.nameAsRoot = config.getChild("name-as-root").getValueAsBoolean(this.nameAsRoot);

        this.outputConf = config.getChild("output");
        this.outputModuleName = this.outputConf.getAttribute("name",this.outputModuleName);
    }
14116#public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
14117#/** Setup the transformer. */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters parameters)
            throws ProcessingException, SAXException, IOException {
        super.setup(resolver, objectModel, src, parameters);
        this.objectModel = objectModel;
    }
14118#public void recycle() {
        super.recycle();
        this.instanceName = null;
    }
14119#/**
     * Receive notification of the beginning of an element.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     * @param a The attributes attached to the element. If there are no
     *          attributes, it shall be an empty Attributes object.
     * @return a <code>boolean</code> value to signal to start extracting
     */
    public boolean startExtracting(String uri, String loc, String raw, Attributes a) {
        if (this.nameElement.equals(uri,loc,raw)) {
            this.instanceName = a.getValue(this.qname);
        }
        boolean res = this.startElement.equals(uri,loc,raw);
        return res;
    }
14120#/**
     * Receive notification of the beginning of an element.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     * @return a <code>boolean</code> value to signal to stop extracting
     */
    public boolean endExtracting(String uri, String loc, String raw) {
        boolean res = this.startElement.equals(uri,loc,raw);
        return res;
    }
14121#/**
     * Start root element and replace it with the instance name.
     * @see org.apache.cocoon.transformation.AbstractExtractionTransformer#startExtractingDocument(String, String, String, Attributes)
     */
    public void startExtractingDocument(String uri, String loc, String raw, Attributes a) throws SAXException {
        if (this.nameAsRoot) {
            loc = this.instanceName;
            if (uri != null && !uri.equals("")) {
                int pos = raw.indexOf(':');
                raw = raw.substring(0, pos+1) + this.instanceName;
            } else {
                raw = loc;
            }
        }
        this.currentBuilder.startElement(uri,loc,raw,a);
    }
14122#/**
     * End root element and replace it with the instance name.
     * @see org.apache.cocoon.transformation.AbstractExtractionTransformer#endExtractingDocument(String, String, String)
     */
    public void endExtractingDocument(String uri, String loc, String raw) throws SAXException{
        if(this.nameAsRoot){
            loc = this.instanceName;
            if (uri != null && !uri.equals("")) {
                int pos = raw.indexOf(':');
                raw = raw.substring(0, pos+1) + this.instanceName;
            } else {
                raw = loc;
            }
        }
        this.currentBuilder.endElement(uri, loc, raw);
    }
14123#/**
     * Receive notification of the end of the extracted Document.
     *
     * @param doc a <code>Document</code> value
     */
    public void handleExtractedDocument(Document doc) {
        
        ServiceSelector outputSelector = null;
        OutputModule output = null;

        try {
            if (getLogger().isDebugEnabled())
                getLogger().debug("wrote ['"+this.instanceName+"'] to "+output+" using "+outputConf);
            outputSelector = (ServiceSelector) this.manager.lookup(OUTPUT_MODULE_SELECTOR);
            if (outputSelector.isSelectable(this.outputModuleName)) {
                output = (OutputModule) outputSelector.select(this.outputModuleName);
            }
            output.setAttribute(outputConf, this.objectModel, this.instanceName, new DocumentWrapper(doc));
            output.commit(outputConf, this.objectModel);
            if (getLogger().isDebugEnabled())
                getLogger().debug("wrote ['"+this.instanceName+"'] to "+output+" using "+outputConf);

        } catch (Exception e) {
            if (getLogger().isWarnEnabled())
                getLogger().warn("Problem writing document data: "+e.getMessage());
        } finally {
            if (outputSelector != null) {
                if (output != null) {
                    outputSelector.release(output);
                    output = null;
                }
                this.manager.release(outputSelector);
            }
        }
        this.instanceName = null;
    }
14124#public ElementData() {
        }
14125#public ElementData(String uri, String loc, String raw) {
            this.uri = uri;
            this.loc = loc;
            this.raw =raw;
        }
14126#public boolean equals(String uri, String loc, String raw) {
            if (!this.uri.equals(uri))
                return false;
            if (!this.loc.equals(loc))
                return false;
            if (!this.raw.equals(raw))
                return false;
            return true;
        }
14127#/**
     * Returns the current locale setting of this transformer instance.
     * @return current Locale object
     */
    public Locale getLocale() {
        return this.locale;
    }
14128#/**
     * Implemenation of CacheableProcessingComponents.
     * Generates unique key for the current locale.
     */
    public java.io.Serializable getKey() {
        // TODO: Key should be composed out of used catalogues locations, and locale.
        //       Right now it is hardcoded only to default catalogue location.
        StringBuffer key = new StringBuffer();
        if (catalogue != null) {
            key.append(catalogue.getLocation()[0]);
        }
        key.append("?");
        if (locale != null) {
            key.append(locale.getLanguage());
            key.append("_");
            key.append(locale.getCountry());
            key.append("_");
            key.append(locale.getVariant());
        }
        return key.toString();
    }
14129#/**
     * Implementation of CacheableProcessingComponent.
     * Generates validity object for this transformer or <code>null</code>
     * if this instance is not cacheable.
     */
    public SourceValidity getValidity() {
        // FIXME (KP): Cache validity should be generated by
        // Bundle implementations.
        return org.apache.excalibur.source.impl.validity.NOPValidity.SHARED_INSTANCE;
    }
14130#/**
     * Look up the {@link BundleFactory} to be used.
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
        try {
            this.factory = (BundleFactory) manager.lookup(BundleFactory.ROLE);
        } catch (ServiceException e) {
            getLogger().debug("Failed to lookup <" + BundleFactory.ROLE + ">", e);
            throw e;
        }
    }
14131#/**
     * Implementation of Configurable interface.
     * Configure this transformer.
     */
    public void configure(Configuration conf) throws ConfigurationException {
        // Read in the config options from the transformer definition
        Configuration cataloguesConf = conf.getChild("catalogues", false);
        if (cataloguesConf == null) {
            throw new ConfigurationException("Required <catalogues> configuration is missing.",
                                             conf);
        }

        // new configuration style
        Configuration[] catalogueConfs = cataloguesConf.getChildren("catalogue");
        catalogues = new HashMap(catalogueConfs.length + 3);
        for (int i = 0; i < catalogueConfs.length; i++) {
            String id = catalogueConfs[i].getAttribute("id");
            String name = catalogueConfs[i].getAttribute("name");

            String[] locations;
            String location = catalogueConfs[i].getAttribute("location", null);
            Configuration[] locationConf = catalogueConfs[i].getChildren("location");
            if (location != null) {
                if (locationConf.length > 0) {
                    String msg = "Location attribute cannot be " +
                                 "specified with location elements";
                    getLogger().error(msg);
                    throw new ConfigurationException(msg, catalogueConfs[i]);
                }

                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("name=" + name + ", location=" +
                                      location);
                }
                locations = new String[1];
                locations[0] = location;
            } else {
                if (locationConf.length == 0) {
                    String msg = "A location attribute or location " +
                                 "elements must be specified";
                    getLogger().error(msg);
                    throw new ConfigurationException(msg, catalogueConfs[i]);
                }

                locations = new String[locationConf.length];
                for (int j=0; j < locationConf.length; ++j) {
                    locations[j] = locationConf[j].getValue();
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("name=" + name + ", location=" +
                                          locations[j]);
                    }
                }
            }

            CatalogueInfo catalogueInfo;
            try {
                catalogueInfo = new CatalogueInfo(name, locations);
            } catch (PatternException e) {
                throw new ConfigurationException("Error in name or location attribute on catalogue " +
                                                 "element with id " + id, catalogueConfs[i], e);
            }
            catalogues.put(id, catalogueInfo);
        }

        String defaultCatalogueId = cataloguesConf.getAttribute("default");
        defaultCatalogue = (CatalogueInfo) catalogues.get(defaultCatalogueId);
        if (defaultCatalogue == null) {
            throw new ConfigurationException("Default catalogue id '" + defaultCatalogueId +
                                             "' denotes a nonexisting catalogue", cataloguesConf);
        }

        // Obtain default text to use for untranslated messages
        defaultUntranslated = conf.getChild(I18N_UNTRANSLATED).getValue(null);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Default untranslated text is '" + defaultUntranslated + "'");
        }

        // Preload specified catalogues (if any)
        Configuration[] preloadConfs = conf.getChildren(I18N_PRELOAD);
        for (int i = 0; i < preloadConfs.length; i++) {
            String localeStr = preloadConfs[i].getValue();
            this.locale = I18nUtils.parseLocale(localeStr);

            String id = preloadConfs[i].getAttribute("catalogue", null);
            if (id != null) {
                CatalogueInfo catalogueInfo = (CatalogueInfo) catalogues.get(id);
                if (catalogueInfo == null) {
                    throw new ConfigurationException("Invalid catalogue id '" + id +
                                                     "' in preload element.", preloadConfs[i]);
                }

                try {
                    catalogueInfo.getCatalogue();
                } finally {
                    catalogueInfo.releaseCatalog();
                }
            } else {
                for (Iterator j = catalogues.values().iterator(); j.hasNext(); ) {
                    CatalogueInfo catalogueInfo = (CatalogueInfo) j.next();
                    try {
                        catalogueInfo.getCatalogue();
                    } finally {
                        catalogueInfo.releaseCatalog();
                    }
                }
            }
        }
        this.locale = null;
    }
14132#/**
     * Setup current instance of transformer.
     */
    public void setup(SourceResolver resolver, Map objectModel, String source,
                      Parameters parameters)
    throws ProcessingException, SAXException, IOException {

        this.objectModel = objectModel;

        untranslated = parameters.getParameter(I18N_UNTRANSLATED, defaultUntranslated);
        if (untranslated != null) {
            untranslatedRecorder = new ParamSaxBuffer();
            untranslatedRecorder.characters(untranslated.toCharArray(), 0, untranslated.length());
        }

        // Get current locale
        String lc = parameters.getParameter(I18N_LOCALE, null);
        Locale locale = I18nUtils.parseLocale(lc);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Using locale '" + locale + "'");
        }

        // Initialize instance state variables
        this.locale             = locale;
        this.current_state      = STATE_OUTSIDE;
        this.prev_state         = STATE_OUTSIDE;
        this.currentKey        = null;
        this.currentCatalogueId = null;
        this.translate_copy     = false;
        this.tr_text_recorder   = null;
        this.text_recorder      = new ParamSaxBuffer();
        this.param_count        = 0;
        this.param_name         = null;
        this.param_value        = null;
        this.param_recorder     = null;
        this.indexedParams      = new HashMap(3);
        this.formattingParams   = null;
        this.strBuffer          = null;

        // give the catalogue variable its value -- first look if it's locally overridden
        // and otherwise use the component-wide defaults.
        String catalogueId = parameters.getParameter(I18N_DEFAULT_CATALOGUE_ID, null);
        if (catalogueId != null) {
            CatalogueInfo catalogueInfo = (CatalogueInfo) catalogues.get(catalogueId);
            if (catalogueInfo == null) {
                throw new ProcessingException("I18nTransformer: '" +
                                              catalogueId +
                                              "' is not an existing catalogue id.");
            }
            catalogue = catalogueInfo;
        } else {
            catalogue = defaultCatalogue;
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Default catalogue is " + catalogue.getName());
        }
    }
14133#//
    // Standard SAX event handlers
    //

    public void startElement(String uri, String name, String raw,
                             Attributes attr)
    throws SAXException {

        // Handle previously buffered characters
        if (current_state != STATE_OUTSIDE && strBuffer != null) {
            i18nCharacters(strBuffer.toString());
            strBuffer = null;
        }

        // Process start element event
        if (I18nUtils.matchesI18nNamespace(uri)) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Starting i18n element: " + name);
            }
            startI18NElement(name, attr);
        } else {
            // We have a non i18n element event
            if (current_state == STATE_OUTSIDE) {
                super.startElement(uri, name, raw,
                                   translateAttributes(name, attr));
            } else if (current_state == STATE_INSIDE_PARAM) {
                param_recorder.startElement(uri, name, raw, attr);
            } else if (current_state == STATE_INSIDE_TEXT) {
                text_recorder.startElement(uri, name, raw, attr);
            } else if ((current_state == STATE_INSIDE_WHEN ||
                    current_state == STATE_INSIDE_OTHERWISE)
                    && translate_copy) {

                super.startElement(uri, name, raw, attr);
            }
        }
    }
14134#public void endElement(String uri, String name, String raw)
    throws SAXException {

        // Handle previously buffered characters
        if (current_state != STATE_OUTSIDE && strBuffer != null) {
            i18nCharacters(strBuffer.toString());
            strBuffer = null;
        }

        if (I18nUtils.matchesI18nNamespace(uri)) {
            endI18NElement(name);
        } else if (current_state == STATE_INSIDE_PARAM) {
            param_recorder.endElement(uri, name, raw);
        } else if (current_state == STATE_INSIDE_TEXT) {
            text_recorder.endElement(uri, name, raw);
        } else if (current_state == STATE_INSIDE_CHOOSE ||
                (current_state == STATE_INSIDE_WHEN ||
                current_state == STATE_INSIDE_OTHERWISE)
                && !translate_copy) {

            // Output nothing
        } else {
            super.endElement(uri, name, raw);
        }
    }
14135#public void characters(char[] ch, int start, int len)
    throws SAXException {

        if (current_state == STATE_OUTSIDE ||
                ((current_state == STATE_INSIDE_WHEN ||
                current_state == STATE_INSIDE_OTHERWISE) && translate_copy)) {

            super.characters(ch, start, len);
        } else {
            // Perform buffering to prevent chunked character data
            if (strBuffer == null) {
                strBuffer = new StringBuffer();
            }
            strBuffer.append(ch, start, len);
        }
    }
14136#//
    // i18n specific event handlers
    //

    private void startI18NElement(String name, Attributes attr)
    throws SAXException {

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Start i18n element: " + name);
        }

        if (I18N_TEXT_ELEMENT.equals(name)) {
            if (current_state != STATE_OUTSIDE
                    && current_state != STATE_INSIDE_PARAM
                    && current_state != STATE_INSIDE_TRANSLATE) {

                throw new SAXException(
                        getClass().getName()
                        + ": nested i18n:text elements are not allowed."
                        + " Current state: " + current_state);
            }

            prev_state = current_state;
            current_state = STATE_INSIDE_TEXT;

            currentKey = attr.getValue("", I18N_KEY_ATTRIBUTE);
            if (currentKey == null) {
                // Try the namespaced attribute
                currentKey = attr.getValue(I18N_NAMESPACE_URI, I18N_KEY_ATTRIBUTE);
                if (currentKey == null) {
                    // Try the old namespace
                    currentKey = attr.getValue(I18N_OLD_NAMESPACE_URI, I18N_KEY_ATTRIBUTE);
                }
            }

            currentCatalogueId = attr.getValue("", I18N_CATALOGUE_ATTRIBUTE);
            if (currentCatalogueId == null) {
                // Try the namespaced attribute
                currentCatalogueId = attr.getValue(I18N_NAMESPACE_URI, I18N_CATALOGUE_ATTRIBUTE);
            }

            if (prev_state != STATE_INSIDE_PARAM) {
                tr_text_recorder = null;
            }

            if (currentKey != null) {
                tr_text_recorder = getMessage(currentKey, (ParamSaxBuffer)null);
            }

        } else if (I18N_TRANSLATE_ELEMENT.equals(name)) {
            if (current_state != STATE_OUTSIDE) {
                throw new SAXException(
                        getClass().getName()
                        + ": i18n:translate element must be used "
                        + "outside of other i18n elements. Current state: "
                        + current_state);
            }

            prev_state = current_state;
            current_state = STATE_INSIDE_TRANSLATE;
        } else if (I18N_PARAM_ELEMENT.equals(name)) {
            if (current_state != STATE_INSIDE_TRANSLATE) {
                throw new SAXException(
                        getClass().getName()
                        + ": i18n:param element can be used only inside "
                        + "i18n:translate element. Current state: "
                        + current_state);
            }

            param_name = attr.getValue(I18N_PARAM_NAME_ATTRIBUTE);
            if (param_name == null) {
                param_name = String.valueOf(param_count++);
            }

            param_recorder = new SaxBuffer();
            setFormattingParams(attr);
            current_state = STATE_INSIDE_PARAM;
        } else if (I18N_CHOOSE_ELEMENT.equals(name)) {
            if (current_state != STATE_OUTSIDE) {
                throw new SAXException(
                        getClass().getName()
                        + ": i18n:choose elements cannot be used"
                        + "inside of other i18n elements.");
            }

            translate_copy = false;
            translate_end = false;
            prev_state = current_state;
            current_state = STATE_INSIDE_CHOOSE;
        } else if (I18N_WHEN_ELEMENT.equals(name) ||
                I18N_IF_ELEMENT.equals(name)) {

            if (I18N_WHEN_ELEMENT.equals(name) &&
                    current_state != STATE_INSIDE_CHOOSE) {
                throw new SAXException(
                        getClass().getName()
                        + ": i18n:when elements are can be used only"
                        + "inside of i18n:choose elements.");
            }

            if (I18N_IF_ELEMENT.equals(name) &&
                    current_state != STATE_OUTSIDE) {
                throw new SAXException(
                        getClass().getName()
                        + ": i18n:if elements cannot be nested.");
            }

            String locale = attr.getValue(I18N_LOCALE_ATTRIBUTE);
            if (locale == null)
                throw new SAXException(
                        getClass().getName()
                        + ": i18n:" + name
                        + " element cannot be used without 'locale' attribute.");

            if ((!translate_end && current_state == STATE_INSIDE_CHOOSE)
                    || current_state == STATE_OUTSIDE) {

                // Perform soft locale matching
                if (this.locale.toString().startsWith(locale)) {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("Locale matching: " + locale);
                    }
                    translate_copy = true;
                }
            }

            prev_state = current_state;
            current_state = STATE_INSIDE_WHEN;

        } else if (I18N_OTHERWISE_ELEMENT.equals(name)) {
            if (current_state != STATE_INSIDE_CHOOSE) {
                throw new SAXException(
                        getClass().getName()
                        + ": i18n:otherwise elements are not allowed "
                        + "only inside i18n:choose.");
            }

            getLogger().debug("Matching any locale");
            if (!translate_end) {
                translate_copy = true;
            }

            prev_state = current_state;
            current_state = STATE_INSIDE_OTHERWISE;

        } else if (I18N_DATE_ELEMENT.equals(name)) {
            if (current_state != STATE_OUTSIDE
                    && current_state != STATE_INSIDE_TEXT
                    && current_state != STATE_INSIDE_PARAM) {
                throw new SAXException(
                        getClass().getName()
                        + ": i18n:date elements are not allowed "
                        + "inside of other i18n elements.");
            }

            setFormattingParams(attr);
            prev_state = current_state;
            current_state = STATE_INSIDE_DATE;
        } else if (I18N_DATE_TIME_ELEMENT.equals(name)) {
            if (current_state != STATE_OUTSIDE
                    && current_state != STATE_INSIDE_TEXT
                    && current_state != STATE_INSIDE_PARAM) {
                throw new SAXException(
                        getClass().getName()
                        + ": i18n:date-time elements are not allowed "
                        + "inside of other i18n elements.");
            }

            setFormattingParams(attr);
            prev_state = current_state;
            current_state = STATE_INSIDE_DATE_TIME;
        } else if (I18N_TIME_ELEMENT.equals(name)) {
            if (current_state != STATE_OUTSIDE
                    && current_state != STATE_INSIDE_TEXT
                    && current_state != STATE_INSIDE_PARAM) {
                throw new SAXException(
                        getClass().getName()
                        + ": i18n:date elements are not allowed "
                        + "inside of other i18n elements.");
            }

            setFormattingParams(attr);
            prev_state = current_state;
            current_state = STATE_INSIDE_TIME;
        } else if (I18N_NUMBER_ELEMENT.equals(name)) {
            if (current_state != STATE_OUTSIDE
                    && current_state != STATE_INSIDE_TEXT
                    && current_state != STATE_INSIDE_PARAM) {
                throw new SAXException(
                        getClass().getName()
                        + ": i18n:number elements are not allowed "
                        + "inside of other i18n elements.");
            }

            setFormattingParams(attr);
            prev_state = current_state;
            current_state = STATE_INSIDE_NUMBER;
        }
    }
14137#// Get all possible i18n formatting attribute values and store in a Map
    private void setFormattingParams(Attributes attr) {
        // average number of attributes is 3
        formattingParams = new HashMap(3);

        String attr_value = attr.getValue(I18N_SRC_PATTERN_ATTRIBUTE);
        if (attr_value != null) {
            formattingParams.put(I18N_SRC_PATTERN_ATTRIBUTE, attr_value);
        }

        attr_value = attr.getValue(I18N_PATTERN_ATTRIBUTE);
        if (attr_value != null) {
            formattingParams.put(I18N_PATTERN_ATTRIBUTE, attr_value);
        }

        attr_value = attr.getValue(I18N_VALUE_ATTRIBUTE);
        if (attr_value != null) {
            formattingParams.put(I18N_VALUE_ATTRIBUTE, attr_value);
        }

        attr_value = attr.getValue(I18N_LOCALE_ATTRIBUTE);
        if (attr_value != null) {
            formattingParams.put(I18N_LOCALE_ATTRIBUTE, attr_value);
        }

        attr_value = attr.getValue(CURRENCY_LOCALE_ATTRIBUTE);
        if (attr_value != null) {
            formattingParams.put(CURRENCY_LOCALE_ATTRIBUTE, attr_value);
        }

        attr_value = attr.getValue(I18N_SRC_LOCALE_ATTRIBUTE);
        if (attr_value != null) {
            formattingParams.put(I18N_SRC_LOCALE_ATTRIBUTE, attr_value);
        }

        attr_value = attr.getValue(I18N_TYPE_ATTRIBUTE);
        if (attr_value != null) {
            formattingParams.put(I18N_TYPE_ATTRIBUTE, attr_value);
        }

        attr_value = attr.getValue(I18N_FRACTION_DIGITS_ATTRIBUTE);
        if (attr_value != null) {
            formattingParams.put(I18N_FRACTION_DIGITS_ATTRIBUTE, attr_value);
        }
    }
14138#private void endI18NElement(String name) throws SAXException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("End i18n element: " + name);
        }

        switch (current_state) {
            case STATE_INSIDE_TEXT:
                endTextElement();
                break;

            case STATE_INSIDE_TRANSLATE:
                endTranslateElement();
                break;

            case STATE_INSIDE_CHOOSE:
                endChooseElement();
                break;

            case STATE_INSIDE_WHEN:
            case STATE_INSIDE_OTHERWISE:
                endWhenElement();
                break;

            case STATE_INSIDE_PARAM:
                endParamElement();
                break;

            case STATE_INSIDE_DATE:
            case STATE_INSIDE_DATE_TIME:
            case STATE_INSIDE_TIME:
                endDate_TimeElement();
                break;

            case STATE_INSIDE_NUMBER:
                endNumberElement();
                break;
        }
    }
14139#private void i18nCharacters(String textValue) throws SAXException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("i18n message text = '" + textValue + "'");
        }

        SaxBuffer buffer;
        switch (current_state) {
            case STATE_INSIDE_TEXT:
                buffer = text_recorder;
                break;

            case STATE_INSIDE_PARAM:
                buffer = param_recorder;
                break;

            case STATE_INSIDE_WHEN:
            case STATE_INSIDE_OTHERWISE:
                // Previously handeld to avoid the String() conversion.
                return;

            case STATE_INSIDE_TRANSLATE:
                if (tr_text_recorder == null) {
                    tr_text_recorder = new ParamSaxBuffer();
                }
                buffer = tr_text_recorder;
                break;

            case STATE_INSIDE_CHOOSE:
                // No characters allowed. Send an exception ?
                if (getLogger().isDebugEnabled()) {
                    textValue = textValue.trim();
                    if (textValue.length() > 0) {
                        getLogger().debug("No characters allowed inside <i18n:choose> tag. Received: " + textValue);
                    }
                }
                return;

            case STATE_INSIDE_DATE:
            case STATE_INSIDE_DATE_TIME:
            case STATE_INSIDE_TIME:
            case STATE_INSIDE_NUMBER:
                // Trim text values to avoid parsing errors.
                textValue = textValue.trim();
                if (textValue.length() > 0) {
                    if (formattingParams.get(I18N_VALUE_ATTRIBUTE) == null) {
                        formattingParams.put(I18N_VALUE_ATTRIBUTE, textValue);
                    } else {
                        // ignore the text inside of date element
                    }
                }
                return;

            default:
                throw new IllegalStateException(getClass().getName() +
                                                " developer's fault: characters not handled. " +
                                                "Current state: " + current_state);
        }

        char[] ch = textValue.toCharArray();
        buffer.characters(ch, 0, ch.length);
    }
14140#// Translate all attributes that are listed in i18n:attr attribute
    private Attributes translateAttributes(final String element, Attributes attr)
    throws SAXException {
        if (attr == null) {
            return null;
        }

        AttributesImpl tempAttr = null;

        // Translate all attributes from i18n:attr="name1 name2 ..."
        // using their values as keys.
        int attrIndex = attr.getIndex(I18N_NAMESPACE_URI, I18N_ATTR_ATTRIBUTE);
        if (attrIndex == -1) {
            // Try the old namespace
            attrIndex = attr.getIndex(I18N_OLD_NAMESPACE_URI, I18N_ATTR_ATTRIBUTE);
        }

        if (attrIndex != -1) {
            StringTokenizer st = new StringTokenizer(attr.getValue(attrIndex));

            // Make a copy which we are going to modify
            tempAttr = new AttributesImpl(attr);
            // Remove the i18n:attr attribute - we don't need it anymore
            tempAttr.removeAttribute(attrIndex);

            // Iterate through listed attributes and translate them
            while (st.hasMoreElements()) {
                final String name = st.nextToken();

                int index = tempAttr.getIndex(name);
                if (index == -1) {
                    getLogger().warn("Attribute " +
                                     name + " not found in element <" + element + ">");
                    continue;
                }

                String value = translateAttribute(element, name, tempAttr.getValue(index));
                if (value != null) {
                    // Set the translated value. If null, do nothing.
                    tempAttr.setValue(index, value);
                }
            }

            attr = tempAttr;
        }

        // Translate all attributes from i18n:expr="name1 name2 ..."
        // using their values as keys.
        attrIndex = attr.getIndex(I18N_NAMESPACE_URI, I18N_EXPR_ATTRIBUTE);
        if (attrIndex != -1) {
            StringTokenizer st = new StringTokenizer(attr.getValue(attrIndex));

            if (tempAttr == null) {
                tempAttr = new AttributesImpl(attr);
            }
            tempAttr.removeAttribute(attrIndex);

            // Iterate through listed attributes and evaluate them
            while (st.hasMoreElements()) {
                final String name = st.nextToken();

                int index = tempAttr.getIndex(name);
                if (index == -1) {
                    getLogger().warn("Attribute " +
                                     name + " not found in element <" + element + ">");
                    continue;
                }

                final StringBuffer translated = new StringBuffer();

                // Evaluate {..} expression
                VariableExpressionTokenizer.TokenReciever tr = new VariableExpressionTokenizer.TokenReciever () {
                    private String catalogueName;

                    public void addToken(int type, String value) {
                        if (type == MODULE) {
                            this.catalogueName = value;
                        } else if (type == VARIABLE) {
                            translated.append(translateAttribute(element, name, value));
                        } else if (type == TEXT) {
                            if (this.catalogueName != null) {
                                translated.append(translateAttribute(element,
                                                                     name,
                                                                     this.catalogueName + ":" + value));
                                this.catalogueName = null;
                            } else if (value != null) {
                                translated.append(value);
                            }
                        }
                    }
                };

                try {
                    VariableExpressionTokenizer.tokenize(tempAttr.getValue(index), tr);
                } catch (PatternException e) {
                    throw new SAXException(e);
                }

                // Set the translated value.
                tempAttr.setValue(index, translated.toString());
            }

            attr = tempAttr;
        }

        // nothing to translate, just return
        return attr;
    }
14141#/**
     * Translate attribute value.
     * Value can be prefixed with catalogue ID and semicolon.
     * @return Translated text, untranslated text, or null.
     */
    private String translateAttribute(String element, String name, String key) {
        // Check if the key contains a colon, if so the text before
        // the colon denotes a catalogue ID.
        int colonPos = key.indexOf(":");
        String catalogueID = null;
        if (colonPos != -1) {
            catalogueID = key.substring(0, colonPos);
            key = key.substring(colonPos + 1, key.length());
        }

        final SaxBuffer text = getMessage(catalogueID, key);
        if (text == null) {
            getLogger().warn("Translation not found for attribute " +
                             name + " in element <" + element + ">");
            return untranslated;
        }
        return text.toString();
    }
14142#private void endTextElement() throws SAXException {
        switch (prev_state) {
            case STATE_OUTSIDE:
                if (tr_text_recorder == null) {
                    if (currentKey == null) {
                        // Use the text as key. Not recommended for large strings,
                        // especially if they include markup.
                        tr_text_recorder = getMessage(text_recorder.toString(), text_recorder);
                    } else {
                        // We have the key, but couldn't find a translation
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("Translation not found for key '" + currentKey + "'");
                        }

                        // Use the untranslated-text only when the content of the i18n:text
                        // element was empty
                        if (text_recorder.isEmpty() && untranslatedRecorder != null) {
                            tr_text_recorder = untranslatedRecorder;
                        } else {
                            tr_text_recorder = text_recorder;
                        }
                    }
                }

                if (tr_text_recorder != null) {
                    tr_text_recorder.toSAX(this.contentHandler);
                }

                text_recorder.recycle();
                tr_text_recorder = null;
                currentKey = null;
                currentCatalogueId = null;
                break;

            case STATE_INSIDE_TRANSLATE:
                if (tr_text_recorder == null) {
                    if (!text_recorder.isEmpty()) {
                        tr_text_recorder = getMessage(text_recorder.toString(), text_recorder);
                        if (tr_text_recorder == text_recorder) {
                            // If the default value was returned, make a copy
                            tr_text_recorder = new ParamSaxBuffer(text_recorder);
                        }
                    }
                }

                text_recorder.recycle();
                break;

            case STATE_INSIDE_PARAM:
                // We send the translated text to the param recorder, after trying to translate it.
                // Remember you can't give a key when inside a param, that'll be nonsense!
                // No need to clone. We just send the events.
                if (!text_recorder.isEmpty()) {
                    getMessage(text_recorder.toString(), text_recorder).toSAX(param_recorder);
                    text_recorder.recycle();
                }
                break;
        }

        current_state = prev_state;
        prev_state = STATE_OUTSIDE;
    }
14143#// Process substitution parameter
    private void endParamElement() throws SAXException {
        String paramType = (String)formattingParams.get(I18N_TYPE_ATTRIBUTE);
        if (paramType != null) {
            // We have a typed parameter

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Param type: " + paramType);
            }
            if (formattingParams.get(I18N_VALUE_ATTRIBUTE) == null && param_value != null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Put param value: " + param_value);
                }
                formattingParams.put(I18N_VALUE_ATTRIBUTE, param_value);
            }

            // Check if we have a date or a number parameter
            if (dateTypes.contains(paramType)) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Formatting date_time param: " + formattingParams);
                }
                param_value = formatDate_Time(formattingParams);
            } else if (numberTypes.contains(paramType)) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Formatting number param: " + formattingParams);
                }
                param_value = formatNumber(formattingParams);
            }
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Added substitution param: " + param_value);
            }
        }

        param_value = null;
        current_state = STATE_INSIDE_TRANSLATE;

        if(param_recorder == null) {
            return;
        }

        indexedParams.put(param_name, param_recorder);
        param_recorder = null;
    }
14144#private void endTranslateElement() throws SAXException {
        if (tr_text_recorder != null) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("End of translate with params. " +
                                  "Fragment for substitution : " + tr_text_recorder);
            }
            tr_text_recorder.toSAX(super.contentHandler, indexedParams);
            tr_text_recorder = null;
            text_recorder.recycle();
        }

        indexedParams.clear();
        param_count = 0;
        current_state = STATE_OUTSIDE;
    }
14145#private void endChooseElement() {
        current_state = STATE_OUTSIDE;
    }
14146#private void endWhenElement() {
        current_state = prev_state;
        if (translate_copy) {
            translate_copy = false;
            translate_end = true;
        }
    }
14147#private void endDate_TimeElement() throws SAXException {
        String result = formatDate_Time(formattingParams);
        switch(prev_state) {
            case STATE_OUTSIDE:
                super.contentHandler.characters(result.toCharArray(), 0,
                                                result.length());
                break;
            case STATE_INSIDE_PARAM:
                param_recorder.characters(result.toCharArray(), 0, result.length());
                break;
            case STATE_INSIDE_TEXT:
                text_recorder.characters(result.toCharArray(), 0, result.length());
                break;
        }
        current_state = prev_state;
    }
14148#// Helper method: creates Locale object from a string value in a map
    private Locale getLocale(Map params, String attribute) {
        // the specific locale value
        String lc = (String)params.get(attribute);
        return I18nUtils.parseLocale(lc, this.locale);
    }
14149#private String formatDate_Time(Map params) throws SAXException {
        // Check that we have not null params
        if (params == null) {
            throw new IllegalArgumentException("Nothing to format");
        }

        // Formatters
        SimpleDateFormat to_fmt;
        SimpleDateFormat from_fmt;

        // Date formatting styles
        int srcStyle = DateFormat.DEFAULT;
        int style = DateFormat.DEFAULT;

        // Date formatting patterns
        boolean realPattern = false;
        boolean realSrcPattern = false;

        // From locale
        Locale srcLoc = getLocale(params, I18N_SRC_LOCALE_ATTRIBUTE);
        // To locale
        Locale loc = getLocale(params, I18N_LOCALE_ATTRIBUTE);

        // From pattern
        String srcPattern = (String)params.get(I18N_SRC_PATTERN_ATTRIBUTE);
        // To pattern
        String pattern = (String)params.get(I18N_PATTERN_ATTRIBUTE);
        // The date value
        String value = (String)params.get(I18N_VALUE_ATTRIBUTE);

        // A src-pattern attribute is present
        if (srcPattern != null) {
            // Check if we have a real pattern
            Integer patternValue = (Integer)datePatterns.get(srcPattern.toUpperCase());
            if (patternValue != null) {
                srcStyle = patternValue.intValue();
            } else {
                realSrcPattern = true;
            }
        }

        // A pattern attribute is present
        if (pattern != null) {
            Integer patternValue = (Integer)datePatterns.get(pattern.toUpperCase());
            if (patternValue != null) {
                style = patternValue.intValue();
            } else {
                realPattern = true;
            }
        }

        // If we are inside of a typed param
        String paramType = (String)formattingParams.get(I18N_TYPE_ATTRIBUTE);

        // Initializing date formatters
        if (current_state == STATE_INSIDE_DATE ||
                I18N_DATE_ELEMENT.equals(paramType)) {

            to_fmt = (SimpleDateFormat)DateFormat.getDateInstance(style, loc);
            from_fmt = (SimpleDateFormat)DateFormat.getDateInstance(
                    srcStyle,
                    srcLoc
            );
        } else if (current_state == STATE_INSIDE_DATE_TIME ||
                I18N_DATE_TIME_ELEMENT.equals(paramType)) {
            to_fmt = (SimpleDateFormat)DateFormat.getDateTimeInstance(
                    style,
                    style,
                    loc
            );
            from_fmt = (SimpleDateFormat)DateFormat.getDateTimeInstance(
                    srcStyle,
                    srcStyle,
                    srcLoc
            );
        } else {
            // STATE_INSIDE_TIME or param type='time'
            to_fmt = (SimpleDateFormat)DateFormat.getTimeInstance(style, loc);
            from_fmt = (SimpleDateFormat)DateFormat.getTimeInstance(
                    srcStyle,
                    srcLoc
            );
        }

        // parsed date object
        Date dateValue;

        // pattern overwrites locale format
        if (realSrcPattern) {
            from_fmt.applyPattern(srcPattern);
        }

        if (realPattern) {
            to_fmt.applyPattern(pattern);
        }

        // get current date and time by default
        if (value == null) {
            dateValue = new Date();
        } else {
            try {
                dateValue = from_fmt.parse(value);
            } catch (ParseException pe) {
                throw new SAXException(
                        this.getClass().getName()
                        + "i18n:date - parsing error.", pe
                );
            }
        }

        // we have all necessary data here: do formatting.
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("### Formatting date: " + dateValue + " with localized pattern " +
                              to_fmt.toLocalizedPattern() + " for locale: " + locale);
        }
        return to_fmt.format(dateValue);
    }
14150#private void endNumberElement() throws SAXException {
        String result = formatNumber(formattingParams);
        switch(prev_state) {
            case STATE_OUTSIDE:
                super.contentHandler.characters(result.toCharArray(), 0, result.length());
                break;
            case STATE_INSIDE_PARAM:
                param_recorder.characters(result.toCharArray(), 0, result.length());
                break;
            case STATE_INSIDE_TEXT:
                text_recorder.characters(result.toCharArray(), 0, result.length());
                break;
        }
        current_state = prev_state;
    }
14151#private String formatNumber(Map params) throws SAXException {
        if (params == null) {
            throw new SAXException(
                    this.getClass().getName()
                    + ": i18n:number - error in element attributes."
            );
        }

        // from pattern
        String srcPattern = (String)params.get(I18N_SRC_PATTERN_ATTRIBUTE);
        // to pattern
        String pattern = (String)params.get(I18N_PATTERN_ATTRIBUTE);
        // the number value
        String value = (String)params.get(I18N_VALUE_ATTRIBUTE);

        if (value == null) return "";
        // type
        String type = (String)params.get(I18N_TYPE_ATTRIBUTE);

        // fraction-digits
        int fractionDigits = -1;
        try {
            String fd = (String)params.get(I18N_FRACTION_DIGITS_ATTRIBUTE);
            if (fd != null)
                fractionDigits = Integer.parseInt(fd);
        } catch (NumberFormatException nfe) {
            getLogger().warn("Error in number format with fraction-digits", nfe);
        }

        // parsed number
        Number numberValue;

        // locale, may be switched locale
        Locale loc = getLocale(params, I18N_LOCALE_ATTRIBUTE);
        Locale srcLoc = getLocale(params, I18N_SRC_LOCALE_ATTRIBUTE);
        // currency locale
        Locale currencyLoc = getLocale(params, CURRENCY_LOCALE_ATTRIBUTE);
        // decimal and grouping locale
        Locale dgLoc = null;
        if (currencyLoc != null) {
            // the reasoning here is: if there is a currency locale, then start from that
            // one but take certain properties (like decimal and grouping seperation symbols)
            // from the default locale (this happens further on).
            dgLoc = loc;
            loc = currencyLoc;
        }

        // src format
        DecimalFormat from_fmt = (DecimalFormat)NumberFormat.getInstance(srcLoc);
        int int_currency = 0;

        // src-pattern overwrites locale format
        if (srcPattern != null) {
            from_fmt.applyPattern(srcPattern);
        }

        // to format
        DecimalFormat to_fmt;
        char dec = from_fmt.getDecimalFormatSymbols().getDecimalSeparator();
        int decAt = 0;
        boolean appendDec = false;

        if (type == null || type.equals( I18N_NUMBER_ELEMENT )) {
            to_fmt = (DecimalFormat)NumberFormat.getInstance(loc);
            to_fmt.setMaximumFractionDigits(309);
            for (int i = value.length() - 1;
                 i >= 0 && value.charAt(i) != dec; i--, decAt++) {
            }

            if (decAt < value.length())to_fmt.setMinimumFractionDigits(decAt);
            decAt = 0;
            for (int i = 0; i < value.length() && value.charAt(i) != dec; i++) {
                if (Character.isDigit(value.charAt(i))) {
                    decAt++;
                }
            }

            to_fmt.setMinimumIntegerDigits(decAt);
            if (value.charAt(value.length() - 1) == dec) {
                appendDec = true;
            }
        } else if (type.equals( I18N_CURRENCY_ELEMENT )) {
            to_fmt = (DecimalFormat)NumberFormat.getCurrencyInstance(loc);
        } else if (type.equals( I18N_INT_CURRENCY_ELEMENT )) {
            to_fmt = (DecimalFormat)NumberFormat.getCurrencyInstance(loc);
            int_currency = 1;
            for (int i = 0; i < to_fmt.getMaximumFractionDigits(); i++) {
                int_currency *= 10;
            }
        } else if ( type.equals( I18N_CURRENCY_NO_UNIT_ELEMENT ) ) {
            DecimalFormat tmp = (DecimalFormat) NumberFormat.getCurrencyInstance( loc );
            to_fmt = (DecimalFormat) NumberFormat.getInstance( loc );
            to_fmt.setMinimumFractionDigits(tmp.getMinimumFractionDigits());
            to_fmt.setMaximumFractionDigits(tmp.getMaximumFractionDigits());
        } else if ( type.equals( I18N_INT_CURRENCY_NO_UNIT_ELEMENT ) ) {
            DecimalFormat tmp = (DecimalFormat) NumberFormat.getCurrencyInstance( loc );
            int_currency = 1;
            for ( int i = 0; i < tmp.getMaximumFractionDigits(); i++ )
                int_currency *= 10;
            to_fmt = (DecimalFormat) NumberFormat.getInstance( loc );
            to_fmt.setMinimumFractionDigits(tmp.getMinimumFractionDigits());
            to_fmt.setMaximumFractionDigits(tmp.getMaximumFractionDigits());
        } else if (type.equals( I18N_PERCENT_ELEMENT )) {
            to_fmt = (DecimalFormat)NumberFormat.getPercentInstance(loc);
        } else {
            throw new SAXException("&lt;i18n:number>: unknown type: " + type);
        }

        if(fractionDigits > -1) {
            to_fmt.setMinimumFractionDigits(fractionDigits);
            to_fmt.setMaximumFractionDigits(fractionDigits);
        }

        if(dgLoc != null) {
            DecimalFormat df = (DecimalFormat)NumberFormat.getCurrencyInstance(dgLoc);
            DecimalFormatSymbols dfsNew = df.getDecimalFormatSymbols();
            DecimalFormatSymbols dfsOrig = to_fmt.getDecimalFormatSymbols();
            dfsOrig.setDecimalSeparator(dfsNew.getDecimalSeparator());
            dfsOrig.setMonetaryDecimalSeparator(dfsNew.getMonetaryDecimalSeparator());
            dfsOrig.setGroupingSeparator(dfsNew.getGroupingSeparator());
            to_fmt.setDecimalFormatSymbols(dfsOrig);
        }

        // pattern overwrites locale format
        if (pattern != null) {
            to_fmt.applyPattern(pattern);
        }

        try {
            numberValue = from_fmt.parse(value);
            if (int_currency > 0) {
                numberValue = new Double(numberValue.doubleValue() / int_currency);
            } else {
                // what?
            }
        } catch (ParseException pe) {
            throw new SAXException(this.getClass().getName() + "i18n:number - parsing error.", pe);
        }

        // we have all necessary data here: do formatting.
        String result = to_fmt.format(numberValue);
        if (appendDec) result = result + dec;
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("i18n:number result: " + result);
        }
        return result;
    }
14152#//-- Dictionary handling routines

    /**
     * Helper method to retrieve a message from the dictionary.
     *
     * @param catalogueID if not null, this catalogue will be used instead of the default one.
     * @return SaxBuffer containing message, or null if not found.
     */
    protected ParamSaxBuffer getMessage(String catalogueID, String key) {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Getting key " + key + " from catalogue " + catalogueID);
        }

        CatalogueInfo catalogue = this.catalogue;
        if (catalogueID != null) {
            catalogue = (CatalogueInfo)catalogues.get(catalogueID);
            if (catalogue == null) {
                if (getLogger().isWarnEnabled()) {
                    getLogger().warn("Catalogue not found: " + catalogueID +
                                     ", will not translate key " + key);
                }
                return null;
            }
        }

        Bundle bundle = catalogue.getCatalogue();
        if (bundle == null) {
            // Can't translate
            getLogger().debug("Untranslated key: '" + key + "'");
            return null;
        }

        try {
            return (ParamSaxBuffer) bundle.getObject(key);
        } catch (MissingResourceException e)  {
            getLogger().debug("Untranslated key: '" + key + "'");
        }

        return null;
    }
14153#/**
     * Helper method to retrieve a message from the current dictionary.
     * A default value is returned if message is not found.
     *
     * @return SaxBuffer containing message, or defaultValue if not found.
     */
    private ParamSaxBuffer getMessage(String key, ParamSaxBuffer defaultValue) {
        SaxBuffer value = getMessage(currentCatalogueId, key);
        if (value == null) {
        	getLogger().debug("Untranslated key: '" + key + "'");
            return defaultValue;
        }

        return new ParamSaxBuffer(value);
    }
14154#public void recycle() {
        this.untranslatedRecorder = null;
        this.catalogue = null;
        this.objectModel = null;

        // Release catalogues which were selected for current locale
        Iterator i = catalogues.values().iterator();
        while (i.hasNext()) {
            CatalogueInfo catalogueInfo = (CatalogueInfo) i.next();
            catalogueInfo.releaseCatalog();
        }

        super.recycle();
    }
14155#public void dispose() {
        if (manager != null) {
            manager.release(factory);
        }
        factory = null;
        manager = null;
        catalogues = null;
    }
14156#public CatalogueInfo(String name, String[] locations) throws PatternException {
            this.name = VariableResolverFactory.getResolver(name, manager);
            this.locations = new VariableResolver[locations.length];
            for (int i=0; i < locations.length; ++i) {
                this.locations[i] = VariableResolverFactory.getResolver(locations[i], manager);
            }
        }
14157#public String getName() {
            try {
                if (resolvedName == null) {
                    resolve();
                }
            } catch (Exception e) {
                // Ignore the error for now
            }
            return resolvedName;
        }
14158#public String[] getLocation() {
            try {
                if (resolvedName == null) {
                    resolve();
                }
            } catch (Exception e) {
                // Ignore the error for now
            }
            return resolvedLocations;
        }
14159#private void resolve() throws Exception {
            if (resolvedLocations == null) {
                resolvedLocations = new String[locations.length];
                for (int i=0; i < resolvedLocations.length; ++i) {
                    resolvedLocations[i] = locations[i].resolve(null, objectModel);
                }
            }
            if (resolvedName == null) {
                resolvedName = name.resolve(null, objectModel);
            }
        }
14160#public Bundle getCatalogue() {
            if (catalogue == null) {
                try {
                    resolve();
                    catalogue = factory.select(resolvedLocations, resolvedName, locale);
                } catch (Exception e) {
                    getLogger().error("Error obtaining catalogue '" + getName() +
                                      "' from  <" + getLocation() + "> for locale " +
                                      locale, e);
                }
            }

            return catalogue;
        }
14161#public void releaseCatalog() {
            if (catalogue != null) {
                factory.release(catalogue);
            }
            catalogue = null;
            resolvedName = null;
            resolvedLocations = null;
        }
14162#/**
     * <p>Create a new {@link IncludeTransformer} instance.</p>
     */
    public IncludeTransformer() {
        pipe = new IncludeXMLPipe();
    }
14163#/**
     * <p>Setup the {@link ServiceManager} available for this instance.</p>
     *
     * @see Serviceable#service(ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
14164#/* (non-Javadoc)
     * @see Configurable#configure(Configuration)
     */
    public void configure(Configuration configuration) throws ConfigurationException {
        /* Read configuration nodes for recursive, parallel, recursive-parallel */
        this.defaultRecursive = configuration.getChild("recursive").getValueAsBoolean(false);
        this.defaultParallel = configuration.getChild("parallel").getValueAsBoolean(false);
        this.defaultRecursiveParallel = configuration.getChild("recursive-parallel").getValueAsBoolean(false);
        /* Read configuration node for thread pool name */
        this.threadPool = configuration.getChild("thread-pool").getValue("default");
        this.defaultKey = configuration.getChild("key").getValue(null);
    }
14165#/**
     * <p>Setup this component instance in the context of its pipeline and
     * current request.</p>
     *
     * @see Serviceable#service(ServiceManager)
     */
    public void setup(SourceResolver resolver, Map om, String src, Parameters parameters)
    throws ProcessingException, SAXException, IOException {
        /* Read sitemap parameters */
        this.pipe.recursive = parameters.getParameterAsBoolean("recursive", this.defaultRecursive);
        this.pipe.parallel = parameters.getParameterAsBoolean("parallel", this.defaultParallel);
        this.pipe.recursiveParallel = parameters.getParameterAsBoolean("recursive-parallel", this.defaultRecursiveParallel);
        this.key = parameters.getParameter("key", this.defaultKey);

        /* Init transformer state */
        if (this.pipe.parallel) {
            this.attributes = RequestContextHolder.getRequestAttributes();
            this.environment = EnvironmentHelper.getCurrentEnvironment();
            this.processor = EnvironmentHelper.getCurrentProcessor();
        }
        this.namespaces = new NamespacesTable();
        this.resolver = resolver;
        this.validity = null;

        // Set root include pipe as consumer.
        // Won't use setter methods here - they are overridden
        super.xmlConsumer = pipe;
        super.contentHandler = pipe;
        super.lexicalHandler = pipe;
    }
14166#public void setConsumer(XMLConsumer consumer) {
        pipe.setConsumer(consumer);
    }
14167#public void setContentHandler(ContentHandler handler) {
        pipe.setContentHandler(handler);
    }
14168#public void setLexicalHandler(LexicalHandler handler) {
        pipe.setLexicalHandler(handler);
    }
14169#/**
     * <p>Recycle this component instance.</p>
     *
     * @see org.apache.avalon.excalibur.pool.Recyclable#recycle()
     */
    public void recycle() {
        this.namespaces = null;
        this.validity = null;

        /* Make sure all threads completed their work */
        this.pipe.recycle();

        // Resolver can be nulled out when all threads completed processing
        // and released their Sources.
        this.resolver = null;

        this.processor = null;
        this.environment = null;
        this.attributes = null;

        super.recycle();
    }
14170#/**
     * <p>Receive notification of the beginning of an XML document.</p>
     *
     * @see ContentHandler#startDocument
     */
    public void startDocument()
    throws SAXException {
        /* Make sure that we have a validity while processing */
        getValidity();

        super.startDocument();
    }
14171#/**
     * <p>Receive notification of the end of an XML document.</p>
     *
     * @see ContentHandler#startDocument()
     */
    public void endDocument()
    throws SAXException {
        /* Make sure that the validity is "closed" at the end */
        this.validity.close();

        super.endDocument();
    }
14172#/**
     * <p>Receive notification of the start of a prefix mapping.</p>
     *
     * <p>This transformer will remove all prefix mapping declarations for those
     * prefixes associated with the <code>http://apache.org/cocoon/include/1.0</code>
     * namespace.</p>
     *
     * @see org.xml.sax.ContentHandler#startPrefixMapping(String, String)
     */
    public void startPrefixMapping(String prefix, String nsuri)
    throws SAXException {
        if (NS_URI.equals(nsuri)) {
            /* Skipping mapping for the current prefix as it's ours */
            this.namespaces.addDeclaration(prefix, nsuri);
        } else {
            /* Map the current prefix, as we don't know it */
            super.startPrefixMapping(prefix, nsuri);
        }
    }
14173#/**
     * <p>Receive notification of the end of a prefix mapping.</p>
     *
     * <p>This transformer will remove all prefix mapping declarations for those
     * prefixes associated with the <code>http://apache.org/cocoon/include/1.0</code>
     * namespace.</p>
     *
     * @see org.xml.sax.ContentHandler#endPrefixMapping(java.lang.String)
     */
    public void endPrefixMapping(String prefix)
    throws SAXException {
        if (NS_URI.equals(this.namespaces.getUri(prefix))) {
            /* Skipping unmapping for the current prefix as it's ours */
            this.namespaces.removeDeclaration(prefix);
        } else {
            /* Unmap the current prefix, as we don't know it */
            super.endPrefixMapping(prefix);
        }
    }
14174#/**
     * <p>Return the caching key associated with this transformation.</p>
     *
     * <p>When including <code>cocoon://</code> sources with dynamic
     * content depending on environment (request parameters, session attributes,
     * etc), it makes sense to provide such environment values to the transformer
     * to be included into the key using <code>key</code> sitemap parameter.</p>
     *
     * @see CacheableProcessingComponent#getKey()
     */
    public Serializable getKey() {
        /*
         * In case of including "cocoon://" or other dynamic sources key
         * ideally has to include ProcessingPipelineKey of the included
         * "cocoon://" sources, but it's not possible as at this time
         * we don't know yet which sources will get included into the
         * response.
         *
         * Hence, javadoc recommends providing key using sitemap parameter.
         */
        return key == null? "I": "I" + key;
    }
14175#/**
     * <p>Generate (or return) the {@link SourceValidity} instance used to
     * possibly validate cached generations.</p>
     *
     * @return a <b>non null</b> {@link SourceValidity}.
     * @see org.apache.cocoon.caching.CacheableProcessingComponent#getValidity()
     */
    public SourceValidity getValidity() {
        if (validity == null) {
            validity = new MultiSourceValidity(resolver, -1);
        }
        return validity;
    }
14176#/** Create include element */
        private IncludeElement(String base, boolean parallel, boolean recursive, boolean recursiveParallel) {
            this.base = base;
            this.parallel = parallel;
            this.recursive = recursive;
            this.recursiveParallel = recursiveParallel;
        }
14177#/**
         * Process element into the buffer.
         * This can not be shared buffer, as it must be cleaned if fallback is invoked.
         */
        public void process(SaxBuffer buffer)
        throws SAXException {
            try {
                process0(buffer, buffer);
            } catch (SAXException e) {
                buffer.recycle();
                if (this.fallback == null) {
                    throw e;
                }

                if (getLogger().isInfoEnabled()) {
                    getLogger().info("Failed to load <" + this.source + ">, using fallback.", e);
                }
                // Stream fallback through IncludeXMLPipe
                this.fallback.toSAX(new IncludeXMLPipe(buffer, buffer,
                                                       recursive, recursiveParallel && parallel, recursiveParallel));
            }
        }
14178#/** Load URI into the provided handlers, process fallback */
        public void process(ContentHandler contentHandler, LexicalHandler lexicalHandler)
        throws SAXException {
            try {
                if (this.fallback != null) {
                    SaxBuffer buffer = new SaxBuffer();
                    process(buffer);
                    buffer.toSAX(contentHandler);
                } else {
                    process0(contentHandler, lexicalHandler);
                }
            } catch (SAXException e) {
                // source must not be cached if an error occurs
                validity = null;
                throw e;
            }
        }
14179#/** Load URI into the provided handlers. */
        private void process0(ContentHandler contentHandler, LexicalHandler lexicalHandler)
        throws SAXException {
            Source source = null;
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Loading <" + this.source + ">");
            }

            // Setup this thread's environment
            try {
                if (base != null) {
                    source = resolver.resolveURI(this.source, base, null);
                } else {
                    source = resolver.resolveURI(this.source);
                }
                if (validity != null) {
                    //noinspection SynchronizeOnNonFinalField
                    synchronized (validity) {
                        validity.addSource(source);
                    }
                }

                // Include source
                if (this.parse && recursive) {
                    SourceUtil.toSAX(manager, source, this.mimeType,
                                     new IncludeXMLPipe(contentHandler, lexicalHandler,
                                                        recursive, recursiveParallel && parallel, recursiveParallel));
                } else if (this.parse) {
                    IncludeXMLConsumer includeXMLConsumer = new IncludeXMLConsumer(contentHandler, lexicalHandler);
                    includeXMLConsumer.setIgnoreRootElement(stripRoot);
                    SourceUtil.toSAX(manager, source, this.mimeType, includeXMLConsumer);
                } else {
                    SourceUtil.toCharacters(source, "utf-8", contentHandler);
                }

                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Loaded <" + this.source + ">");
                }
            } catch (SAXException e) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Failed to load <" + this.source + ">", e);
                }

                throw e;

            } catch (ProcessingException e) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Failed to load <" + this.source + ">", e);
                }

                throw new SAXException(e);

            } catch (IOException e) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Failed to load <" + this.source + ">", e);
                }

                throw new SAXException(e);

            } finally {
                if (source != null) {
                    resolver.release(source);
                }
            }
        }
14180#/**
         * <p>Create a new {@link IncludeXMLPipe} instance.</p>
         */
        public IncludeXMLPipe() {
            root = true;
        }
14181#/**
         * <p>Create a new {@link IncludeXMLPipe} instance.</p>
         */
        public IncludeXMLPipe(ContentHandler contentHandler, LexicalHandler lexicalHandler,
                              boolean recursive, boolean parallel, boolean recursiveParallel) {
            root = false;
            setContentHandler(contentHandler);
            setLexicalHandler(lexicalHandler);
            this.recursive = recursive;
            this.parallel = parallel;
            this.recursiveParallel = recursiveParallel;
        }
14182#/**
         * Finish processing.
         */
        public void recycle() {
            if (this.buffering) {
                // Wait for threads to complete and release Sources
                waitForThreads();
                this.buffering = false;
                this.buffer = null;
            }
            this.threads = 0;

            this.consumers.clear();
            this.base = null;
            this.element = null;

            super.recycle();
        }
14183#/** Push current consumer into the stack, replace with new one */
        private void push(XMLConsumer consumer) {
            this.consumers.push(new Object[]{ super.xmlConsumer, super.contentHandler, super.lexicalHandler });
            setConsumer(consumer);
        }
14184#/** Pop consumer from the stack, replace current one */
        private void pop() {
            Object[] consumer = (Object[]) this.consumers.pop();
            if (consumer[0] != null) {
                setConsumer((XMLConsumer) consumer[0]);
            } else {
                setContentHandler((ContentHandler) consumer[1]);
                setLexicalHandler((LexicalHandler) consumer[2]);
            }
        }
14185#//
        // ContentHandler interface
        //

        public void setDocumentLocator(Locator locator) {
            try {
                if (locator != null && locator.getSystemId() != null) {
                    Source source = resolver.resolveURI(locator.getSystemId());
                    try {
                        base = source.getURI();
                    } finally {
                        resolver.release(source);
                    }
                }
            } catch (IOException e) {
                getLogger().warn("Unable to resolve document base URI: <" + locator.getSystemId() + ">");
            }

            super.setDocumentLocator(locator);
        }
14186#/**
         * <p>Receive notification of the beginning of an XML document.</p>
         * @see ContentHandler#startDocument
         */
        public void startDocument() throws SAXException {
            if (root) {
                super.startDocument();
            }
        }
14187#/**
         * <p>Receive notification of the end of an XML document.</p>
         * @see ContentHandler#startDocument
         */
        public void endDocument() throws SAXException {
            /* This is the end of the line - process the buffered events */
            if (this.buffering) {
                pop();
                this.buffer.toSAX(super.contentHandler);
            }

            if (root) {
                super.endDocument();
            }
        }
14188#/**
         * <p>Receive notification of the start of an element.</p>
         * @see ContentHandler#startElement
         */
        public void startElement(String uri, String localName, String qName, Attributes atts)
        throws SAXException {

            /* Check the namespace declaration */
            if (NS_URI.equals(uri)) {

                /*
                 * Depth 0: Outside of any include tag
                 * Depth 1: Must be Inside <include> tag
                 * Depth 2: Inside <fallback> tag
                 */
                depth++;

                /* Inclusion will not happen here but when we close this tag */
                if (INCLUDE_ELEMENT.equals(localName) && depth == 1) {
                    /* Check before we include (we don't want nested stuff) */
                    if (element != null) {
                        throw new SAXException("Element " + INCLUDE_ELEMENT + " nested in another one.");
                    }
                    element = new IncludeElement(this.base, this.parallel, this.recursive, this.recursiveParallel);

                    /* Remember the source we are trying to include */
                    element.source = atts.getValue(SRC_ATTRIBUTE);
                    if (element.source == null || element.source.length() == 0) {
                        throw new SAXException("Attribute '" + SRC_ATTRIBUTE + "' empty or missing.");
                    }

                    /* Defaults to 'xml' */
                    String value = atts.getValue(PARSE_ATTRIBUTE);
                    if (value == null || value.equals("xml")) {
                        element.parse = true;
                    } else if (value.equals("text")) {
                        element.parse = false;
                    } else {
                        throw new SAXException("Attribute '" + PARSE_ATTRIBUTE + "' has invalid value.");
                    }

                    /* Defaults to 'text/xml' */
                    element.mimeType = atts.getValue(MIME_ATTRIBUTE);
                    if (!element.parse && element.mimeType != null) {
                        throw new SAXException("Attribute '" + MIME_ATTRIBUTE + "' can't be specified for text inclusions.");
                    } else if (element.mimeType == null) {
                        element.mimeType = "text/xml";
                    }

                    /* Defaults to false */
                    String stripRoot = atts.getValue(STRIP_ROOT_ATTRIBUTE);
                    element.stripRoot = Boolean.valueOf(stripRoot).booleanValue();

                    /* Ignore nested content */
                    push(new NOPRecorder(){});

                    /* Done with this element */
                    return;
                }

                /* If this is a fallback parameter, capture its content. */
                if (FALLBACK_ELEMENT.equals(localName) && depth == 2) {
                    /* Check if we are in the right context */
                    if (element == null) {
                        throw new SAXException("Element " + FALLBACK_ELEMENT + " specified outside of " + INCLUDE_ELEMENT + ".");
                    }
                    if (element.fallback != null) {
                        throw new SAXException("Duplicate element " + FALLBACK_ELEMENT + ".");
                    }

                    /* Buffer fallback content */
                    push(element.fallback = new SaxBuffer());

                    /* Done with this element */
                    return;
                }

                /* If this is a parameter, then make sure we prepare. */
                if (PARAMETER_ELEMENT.equals(localName) && depth == 2) {
                    /* Check if we are in the right context */
                    if (element == null) {
                        throw new SAXException("Element " + PARAMETER_ELEMENT + " specified outside of " + INCLUDE_ELEMENT + ".");
                    }
                    if (element.parameter != null) {
                        throw new SAXException("Element " + PARAMETER_ELEMENT + " nested in another one.");
                    }

                    /* Get and process the parameter name */
                    element.parameter = atts.getValue(NAME_ATTRIBUTE);
                    if (element.parameter == null || element.parameter.length() == 0) {
                        throw new SAXException("Attribute '" + NAME_ATTRIBUTE + "' empty or missing.");
                    }

                    /* Make some room for the parameter value */
                    String value = atts.getValue(VALUE_ATTRIBUTE);
                    if (value != null) {
                        element.value = new StringBuffer(value);
                    }

                    /* Done with this element */
                    return;
                }

                /* We don't have a clue of why we got here (wrong element?) */
                if (depth < 2) {
                    throw new SAXException("Element '" + localName + "' was not expected here.");
                }
            }

            super.startElement(uri, localName, qName, atts);
        }
14189#/**
         * <p>Receive notification of the end of an element.</p>
         * @see ContentHandler#endElement
         */
        public void endElement(String uri, String localName, String qName)
        throws SAXException {
            /* Check the namespace declaration */
            if (NS_URI.equals(uri)) {

                /*
                 * Depth 0: Outside of any include tag
                 * Depth 1: Inside <include> tag
                 * Depth 2: Inside <fallback> tag
                 */
                depth--;

                /* Inclusion will happen here, when we close the include element */
                if (INCLUDE_ELEMENT.equals(localName) && depth == 0) {
                    /* End ignoring nested content */
                    pop();

                    /* Get the source discovered opening the element and include */
                    if (element.parameters != null) {
                        element.source = NetUtils.parameterize(element.source,
                                                               element.parameters);
                        element.parameters = null;
                    }

                    /* Check for parallel processing */
                    if (this.parallel) {
                        if (!this.buffering) {
                            this.buffering = true;
                            buffer = new SaxBuffer();
                            push(buffer);
                        }

                        /* Process include element in separate thread */
                        buffer.xmlizable(new IncludeBuffer(element));

                    } else {
                        /* Process include element inline */
                        element.process(super.contentHandler, super.lexicalHandler);
                    }

                    /* We are done with this include element */
                    this.element = null;
                    return;
                }

                if (FALLBACK_ELEMENT.equals(localName) && depth == 1) {
                    /* End buffering fallback content */
                    pop();

                    /* Done with this element */
                    return;
                }

                /* Addition of parameters happens here (so that we can capture chars) */
                if (PARAMETER_ELEMENT.equals(localName) && depth == 1) {
                    String value = (element.value != null? element.value.toString(): "");

                    /* Store the parameter name and value */
                    try {
                        /*
                         * Note: the parameter name and value are URL encoded, so that
                         * weird characters such as "&" or "=" (have special meaning)
                         * are passed through flawlessly.
                         */
                        if (element.parameters == null) {
                            element.parameters = new HashMap(5);
                        }
                        element.parameters.put(NetUtils.encode(element.parameter, ENCODING),
                                               NetUtils.encode(value, ENCODING));
                    } catch (UnsupportedEncodingException e) {
                        throw new SAXException("Your platform does not support the " +
                                               ENCODING + " encoding", e);
                    }

                    /* We are done with this parameter element */
                    element.value = null;
                    element.parameter = null;
                    return;
                }
            }

            /* This is not our namespace, pass the event on! */
            super.endElement(uri, localName, qName);
        }
14190#/**
         * <p>Receive notification of characters.</p>
         * @see ContentHandler#characters
         */
        public void characters(char[] data, int offset, int length)
        throws SAXException {
            if (element != null && element.parameter != null) {
                /* If we have a parameter value to add to, let's add this chunk */
                if (element.value == null) {
                    element.value = new StringBuffer();
                }
                element.value.append(data, offset, length);
                return;
            }

            /* Forward */
            super.characters(data, offset, length);
        }
14191#//
        // Thread management
        //

        /**
         * Increment active threads counter
         */
        int incrementThreads() {
            //noinspection SynchronizeOnNonFinalField
            synchronized (buffer) {
                return ++threads;
            }
        }
14192#/**
         * Decrement active threads counter
         */
        void decrementThreads() {
            //noinspection SynchronizeOnNonFinalField
            synchronized (buffer) {
                if (--threads <= 0) {
                    buffer.notify();
                }
            }
        }
14193#/**
         * Wait till there is no active threads
         */
        private void waitForThreads() {
            //noinspection SynchronizeOnNonFinalField
            synchronized (buffer) {
                if (threads > 0) {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug(threads + " threads in progress, waiting");
                    }

                    try {
                        buffer.wait();
                    } catch (InterruptedException e) { /* ignored */ }
                    // Don't continue waiting if interrupted.
                }
            }
        }
14194#public IncludeBuffer(IncludeElement element) {
                this.element = element;

                RunnableManager runnable = null;
                try {
                    runnable = (RunnableManager) IncludeTransformer.this.manager.lookup(RunnableManager.ROLE);
                    runnable.execute(IncludeTransformer.this.threadPool, this);
                } catch (final ServiceException e) {
                    // In case we failed to spawn a thread
                    throw new CascadingRuntimeException(e.getMessage(), e);
                } finally {
                    IncludeTransformer.this.manager.release(runnable);
                }

                // Increment active threads counter
                this.thread = incrementThreads();
            }
14195#/**
             * Load content of the source into this buffer.
             */
            public void run() {
                try {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("Thread #" + thread + " loading <" + element.source + ">");
                    }

                    // Setup this thread's environment
                    RequestContextHolder.setRequestAttributes(attributes);
                    EnvironmentHelper.enterProcessor(processor, environment);
                    try {
                        element.process(this);

                    } catch (SAXException e) {
                        this.e = e;

                    } finally {
                        EnvironmentHelper.leaveProcessor();
                        RequestContextHolder.resetRequestAttributes();
                    }
                } catch (ProcessingException e) {
                    /* Unable to set thread's environment */
                    this.e = new SAXException(e);

                } finally {
                    synchronized (this) {
                        this.finished = true;
                        notify();
                    }

                    // Make sure that active threads counter is decremented
                    decrementThreads();
                }

                if (getLogger().isDebugEnabled()) {
                    if (this.e == null) {
                        getLogger().debug("Thread #" + thread + " loaded <" + element.source + ">");
                    } else {
                        getLogger().debug("Thread #" + thread + " failed to load <" + element.source + ">", this.e);
                    }
                }
            }
14196#/**
             * Stream content of this buffer when it is loaded completely.
             * This method blocks if loading is not complete.
             */
            public void toSAX(ContentHandler contentHandler)
            throws SAXException {
                synchronized (this) {
                    if (!this.finished) {
                        try {
                            wait();
                        } catch (InterruptedException e) { /* ignored */ }
                        // Don't continue waiting if interrupted.
                    }
                }

                if (this.e != null) {
                    throw this.e;
                }

                super.toSAX(contentHandler);
            }
14197#/**
     * Constructor. Set namespace.
     */
    public JPathTransformer() {
        super.defaultNamespaceURI = JPATH_NAMESPACE_URI;
    }
14198#/**
     * Initialize this transformer.
     *
     * @exception Exception if an error occurs
     */
    public void initialize() throws Exception {
        m_re = new RE("id");
        m_cache = new HashMap();
    }
14199#/**
     * Setup this transformer
     *
     * @param resolver a {@link SourceResolver} instance
     * @param objectModel the objectModel
     * @param src <code>src</code> parameter
     * @param parameters optional parameters
     * @exception ProcessingException if an error occurs
     * @exception SAXException if an error occurs
     * @exception IOException if an error occurs
     */
    public void setup(SourceResolver resolver, Map objectModel,
                      String src, Parameters parameters)
        throws ProcessingException, SAXException, IOException {

        super.setup(resolver, objectModel, src, parameters);

        // setup the jpath transformer for this thread
        Object bean = FlowHelper.getContextObject(objectModel);
        m_kont = FlowHelper.getWebContinuation(objectModel);
        m_jxpathContext = JXPathContext.newContext(bean);
    }
14200#/**
     * Intercept startElement to ensure all &lt;jpath:action&gt; attributes
     * are modified.
     *
     * @param uri a <code>String</code> value
     * @param loc a <code>String</code> value
     * @param raw a <code>String</code> value
     * @param a an <code>Attributes</code> value
     * @exception SAXException if an error occurs
     */
    public void startElement(String uri, String loc, String raw, Attributes a)
        throws SAXException {

        AttributesImpl impl = new AttributesImpl(a);
        checkJPathAction(impl);

        super.startElement(uri, loc, raw, impl);
    }
14201#/**
     * Entry method for all elements in our namespace
     *
     * @param uri a <code>String</code> value
     * @param name a <code>String</code> value
     * @param raw a <code>String</code> value
     * @param attr an <code>Attributes</code> value
     * @exception ProcessingException if an error occurs
     * @exception IOException if an error occurs
     * @exception SAXException if an error occurs
     */
    public void startTransformingElement(
        String uri, String name, String raw, Attributes attr
    )
        throws ProcessingException ,IOException, SAXException {

        if (JPATH_VALUEOF.equals(name)) {
            doValueOf(attr);
        } else if (JPATH_CONTINUATION.equals(name)) {
            doContinuation(attr);
        } else if (JPATH_IF.equals(name)) {
            doIf(attr);
        } else {
            super.startTransformingElement(uri, name, raw, attr);
        }
    }
14202#/**
     * Exit method for all elements in our namespace
     *
     * @param uri a <code>String</code> value
     * @param name a <code>String</code> value
     * @param raw a <code>String</code> value
     * @exception ProcessingException if an error occurs
     * @exception IOException if an error occurs
     * @exception SAXException if an error occurs
     */
    public void endTransformingElement(
        String uri, String name, String raw
    )
        throws ProcessingException, IOException, SAXException {

        if (JPATH_VALUEOF.equals(name) ||
            JPATH_CONTINUATION.equals(name)) {
            return; // do nothing
        } else if (JPATH_IF.equals(name)) {
            finishIf();
        } else {
            super.endTransformingElement(uri, name, raw);
        }
    }
14203#/**
     * Helper method to check for the existance of an attribute named
     * jpath:action. If existing the string 'id' is replaced with the
     * continuation id.
     *
     * @param a an {@link AttributesImpl} instance
     */
    private void checkJPathAction(final AttributesImpl a) {

        // check for jpath:action attribute
        int idx = a.getIndex(JPATH_ACTION);

        if (idx != -1 && JPATH_NAMESPACE_URI.equals(a.getURI(idx))) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("found jpath:action, adjusting");
            }

            String value = a.getValue(idx);

            // REVISIT(MC): support for continuation level
            String id = m_kont.getContinuation(0).getId();

            a.removeAttribute(idx);
            a.addAttribute(
                "", "action", "action", "CDATA", m_re.subst(value, id)
            );
        }
    }
14204#/**
     * Helper method for obtaining the value of a particular variable.
     *
     * @param variable variable name
     * @return variable value as an <code>Object</code>
     */
    private Object getValue(final String variable) {

        Object value;

        if (m_cache.containsKey(variable)) {
            value = m_cache.get(variable);
        } else {
            value = JXPathContext.compile(variable).getValue(m_jxpathContext);

            if (value == null) {
                if (getLogger().isWarnEnabled()) {
                    final String msg =
                        "Value for jpath variable '" + variable + "' does not exist";
                    getLogger().warn(msg);
                }
            }

            m_cache.put(variable, value);
        }

        return value;
    }
14205#/**
     * Helper method to process a &lt;jpath:value-of select="."&gt; tag
     *
     * @param a an {@link Attributes} instance
     * @exception SAXException if a SAX error occurs
     * @exception ProcessingException if a processing error occurs
     */
    private void doValueOf(final Attributes a)
        throws SAXException, ProcessingException {

        final String select = a.getValue(JPATH_VALUEOF_SELECT);

        if (null != select) {
            sendTextEvent((String)getValue(select));
        } else {
            throw new ProcessingException(
                "jpath:" + JPATH_VALUEOF + " specified without a select attribute"
            );
        }
    }
14206#/**
     * Helper method to process a &lt;jpath:continuation select=""/&gt; element.
     *
     * @param a an <code>Attributes</code> value
     * @exception SAXException if an error occurs
     */
    private void doContinuation(final Attributes a)
        throws SAXException {

        final String level = a.getValue(JPATH_CONTINUATION_SELECT);

        final String id = (level != null)
            ? m_kont.getContinuation(Integer.decode(level).intValue()).getId()
            : m_kont.getContinuation(0).getId();

        sendTextEvent(id);
    }
14207#/**
     * Helper method to process a &lt;jpath:if test="..."&gt; element.
     *
     * @param a an <code>Attributes</code> value
     * @exception SAXException if an error occurs
     */
    private void doIf(final Attributes a)
        throws SAXException {

        // handle nested jpath:if statements, if ignoreEventsCount is > 0, then
        // we are processing a nested jpath:if statement for which the parent
        // jpath:if test resulted in a false (ie. disallow subelements) result.

        if (ignoreEventsCount > 0) {
            ++ignoreEventsCount;
            return;
        }

        // get the test variable
        final Object value = getValue(a.getValue(JPATH_TEST));

        final boolean isTrueBoolean =
            value instanceof Boolean && ((Boolean)value).booleanValue() == true;
        final boolean isNonNullNonBoolean =
            value != null && !(value instanceof Boolean);

        if (isTrueBoolean || isNonNullNonBoolean) {
            // do nothing, allow all subelements
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("jpath:if results in allowing subelements");
            }
        } else {
            // disallow all subelements
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("jpath:if results in disallowing subelements");
            }
            ++ignoreEventsCount;
        }
    }
14208#/**
     * Helper method to process a &lt;/jpath:if&gt; element.
     *
     * @exception SAXException if an error occurs
     */
    private void finishIf()
        throws SAXException {

        // end recording (and dump resulting document fragment) if we've reached
        // the closing jpath:if tag for which the recording was started.
        if (ignoreEventsCount > 0) {
            --ignoreEventsCount;
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("jpath:if closed");
        }
    }
14209#/**
     * Release all held resources.
     */
    public void recycle() {
        m_cache.clear();
        m_kont = null;
        m_jxpathContext = null;

        super.recycle();
    }
14210#/**
     * Constructor
     * Set the namespace
     */
    public CIncludeTransformer() {
        this.defaultNamespaceURI = CINCLUDE_NAMESPACE_URI;
        this.removeOurNamespacePrefixes = true;
    }
14211#/**
     * Setup the component.
     */
    public void setup(SourceResolver resolver, Map objectModel,
                      String source, Parameters parameters)
    throws ProcessingException, SAXException, IOException {
        super.setup(resolver, objectModel, source, parameters);
        this.state = STATE_OUTSIDE;
        if ( null != this.cacheManager ) {
            this.cachingSession = this.cacheManager.getSession( this.parameters );
        }
        this.compiling = false;
        this.supportCaching = parameters.getParameterAsBoolean("support-caching", false);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Starting, session " + this.cachingSession);
            this.startTime = System.currentTimeMillis();
        }
    }
14212#/**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        super.service(manager);
        if (this.manager.hasService(IncludeCacheManager.ROLE)) {
            this.cacheManager = (IncludeCacheManager) this.manager.lookup(IncludeCacheManager.ROLE);
        } else {
            getLogger().warn("The cinclude transformer cannot find the IncludeCacheManager. " +
                             "Therefore caching is turned off for the include transformer.");
        }
    }
14213#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        if (null != this.manager) {
            this.manager.release(this.cacheManager);
            this.manager = null;
        }
        super.dispose();
    }
14214#/**
     * Recycle the component
     */
    public void recycle() {
        if ( null != this.cachingSession ) {
            this.cacheManager.terminateSession( this.cachingSession );
        }
        this.cachingSession = null;

        this.configurationParameters = null;
        this.resourceParameters = null;
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Finishing, time: " +
                              (System.currentTimeMillis() - this.startTime));
            this.startTime = 0;
        }
        this.filter = null;

        super.recycle();
    }
14215#/**
     * @see org.apache.cocoon.transformation.AbstractSAXTransformer#startTransformingElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
     */
    public void startTransformingElement(String uri, String name, String raw, Attributes attr)
    throws ProcessingException ,IOException, SAXException {
        // Element: include
        if (name.equals(CINCLUDE_INCLUDE_ELEMENT)) {
            String stripRootValue = attr.getValue("", CINCLUDE_INCLUDE_ELEMENT_STRIP_ROOT_ATTRIBUTE);
            boolean stripRoot = StringUtils.equals(stripRootValue, "true");

            processCIncludeElement(attr.getValue("", CINCLUDE_INCLUDE_ELEMENT_SRC_ATTRIBUTE),
                                   attr.getValue("", CINCLUDE_INCLUDE_ELEMENT_ELEMENT_ATTRIBUTE),
                                   attr.getValue("", CINCLUDE_INCLUDE_ELEMENT_SELECT_ATTRIBUTE),
                                   attr.getValue("", CINCLUDE_INCLUDE_ELEMENT_NS_ATTRIBUTE),
                                   attr.getValue("", CINCLUDE_INCLUDE_ELEMENT_PREFIX_ATTRIBUTE),
                                   stripRoot,
                                   false);

        // Element: includexml
        } else if (name.equals(CINCLUDE_INCLUDEXML_ELEMENT)
                   && this.state == STATE_OUTSIDE) {
            this.state = STATE_INCLUDE;
            String ignoreErrors = attr.getValue("", CINCLUDE_INCLUDEXML_ELEMENT_IGNORE_ERRORS_ATTRIBUTE);
            if (ignoreErrors == null || ignoreErrors.length() == 0) {
                ignoreErrors = "false";
            }
            this.stack.push(BooleanUtils.toBooleanObject(this.ignoreEmptyCharacters));
            this.stack.push(BooleanUtils.toBooleanObject(this.ignoreWhitespaces));
            this.stack.push(ignoreErrors);

            this.ignoreEmptyCharacters = false;
            this.ignoreWhitespaces = true;

        // target
        } else if (name.equals(CINCLUDE_SRC_ELEMENT)
                   && this.state == STATE_INCLUDE) {
            this.startTextRecording();

        // configparameters
        } else if (name.equals(CINCLUDE_CONFIGURATION_ELEMENT)
                   && this.state == STATE_INCLUDE) {
            stack.push("end");

        // parameters
        } else if (name.equals(CINCLUDE_PARAMETERS_ELEMENT)
                   && this.state == STATE_INCLUDE) {
            stack.push("end");

        // parameter
        } else if (name.equals(CINCLUDE_PARAMETER_ELEMENT)
                   && this.state == STATE_INCLUDE) {

        // parameter name
        } else if (name.equals(CINCLUDE_NAME_ELEMENT)
                   && this.state == STATE_INCLUDE) {
            this.startTextRecording();

        // parameter value
        } else if (name.equals(CINCLUDE_VALUE_ELEMENT)
                   && this.state == STATE_INCLUDE) {
            this.startSerializedXMLRecording(XMLUtils.createPropertiesForXML(true));

       } else if (name.equals(CINCLUDE_CACHED_INCLUDE_ELEMENT)) {

           String src = processCIncludeElement(attr.getValue("", CINCLUDE_INCLUDE_ELEMENT_SRC_ATTRIBUTE),
                                               null,
                                               null,
                                               null,
                                               null,
                                               false,
                                               this.cacheManager != null);
           if (this.compiling) {
               this.srcAttributes.addAttribute("", CINCLUDE_INCLUDE_ELEMENT_SRC_ATTRIBUTE, CINCLUDE_SRC_ELEMENT, "CDATA", src);
               super.startTransformingElement(uri,
                                              CINCLUDE_CACHED_INCLUDE_PLACEHOLDER_ELEMENT,
                                              raw + "p",
                                              this.srcAttributes);
               this.srcAttributes.clear();
           }
        } else {
            super.startTransformingElement(uri, name, raw, attr);
        }
    }
14216#/**
     * @see org.apache.cocoon.transformation.AbstractSAXTransformer#endTransformingElement(java.lang.String, java.lang.String, java.lang.String)
     */
    public void endTransformingElement(String uri, String name, String raw)
    throws ProcessingException, IOException, SAXException {
        if (name.equals(CINCLUDE_INCLUDE_ELEMENT)) {
            // do nothing
            return;

        } else if (name.equals(CINCLUDE_INCLUDEXML_ELEMENT)
                   && this.state == STATE_INCLUDE) {
            // Element: includexml

            this.state = STATE_OUTSIDE;

            final String resource = (String)stack.pop();

            final boolean ignoreErrors = stack.pop().equals("true");

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Processing includexml element: src=" + resource
                              + ", ignoreErrors=" + ignoreErrors
                              + ", configuration=" + this.configurationParameters
                              + ", parameters=" + this.resourceParameters);
            }
            Source source = null;

            try {
                source = SourceUtil.getSource(resource,
                                              this.configurationParameters,
                                              this.resourceParameters,
                                              this.resolver);

                XMLByteStreamCompiler serializer;
                XMLByteStreamInterpreter deserializer;
                try {
                    if ( ignoreErrors ) {
                        serializer = new XMLByteStreamCompiler();
                        deserializer = new XMLByteStreamInterpreter();
                        SourceUtil.toSAX(source, serializer, this.configurationParameters, true);
                        deserializer.setConsumer( this.xmlConsumer );
                        deserializer.deserialize( serializer.getSAXFragment() );
                    } else {
                        SourceUtil.toSAX(source, this.xmlConsumer, this.configurationParameters, true);
                    }
                } catch (ProcessingException pe) {
                    if (!ignoreErrors) {
                        throw pe;
                    }
                }
            } catch (SourceException se) {
                if (!ignoreErrors) throw SourceUtil.handle(se);
            } catch (SAXException se) {
                if (!ignoreErrors) {
                    throw se;
                }
            } catch (IOException ioe) {
                if (!ignoreErrors) {
                    throw ioe;
                }
            } finally {
                this.resolver.release(source);
            }

            // restore values
            this.ignoreWhitespaces = ((Boolean)stack.pop()).booleanValue();
            this.ignoreEmptyCharacters = ((Boolean)stack.pop()).booleanValue();

        // src element
        } else if (name.equals(CINCLUDE_SRC_ELEMENT)
                   && this.state == STATE_INCLUDE) {

            this.stack.push(this.endTextRecording());

        } else if (name.equals(CINCLUDE_PARAMETERS_ELEMENT)
                   && this.state == STATE_INCLUDE) {
            this.resourceParameters = new SourceParameters();
            // Now get the parameters off the stack
            String label = (String)stack.pop();
            String key = null;
            String value = null;
            while (!label.equals("end")) {
                if (label.equals("name")) key = (String)stack.pop();
                if (label.equals("value")) value = (String)stack.pop();
                if (key != null && value != null) {
                    this.resourceParameters.setParameter(key, value);
                    key = null;
                    value = null;
                }
                label = (String)stack.pop();
            }

        } else if (name.equals(CINCLUDE_CONFIGURATION_ELEMENT) == true
                 && this.state == STATE_INCLUDE) {
            this.configurationParameters = new Parameters();
            // Now get the parameters off the stack
            String label = (String)stack.pop();
            String key = null;
            String value = null;
            while (!label.equals("end")) {
                if (label.equals("name")) key = (String)stack.pop();
                if (label.equals("value")) value = (String)stack.pop();
                if (key != null && value != null) {
                    this.configurationParameters.setParameter(key, value);
                    key = null;
                    value = null;
                }
                label = (String)stack.pop();
            }

        } else if (name.equals(CINCLUDE_PARAMETER_ELEMENT) == true
                   && this.state == STATE_INCLUDE) {

        } else if (name.equals(CINCLUDE_NAME_ELEMENT) == true
                   && this.state == STATE_INCLUDE) {
            stack.push(this.endTextRecording());
            stack.push("name");

        // parameter value
        } else if (name.equals(CINCLUDE_VALUE_ELEMENT) == true
                   && this.state == STATE_INCLUDE) {
            stack.push(this.endSerializedXMLRecording());
            stack.push("value");

        } else if (name.equals(CINCLUDE_CACHED_INCLUDE_ELEMENT)) {
            if (this.compiling) {
               super.endTransformingElement(uri,
                                            CINCLUDE_CACHED_INCLUDE_PLACEHOLDER_ELEMENT,
                                            raw + "p");
            }
            // do nothing else
        } else {
            super.endTransformingElement(uri, name, raw);
        }
    }
14217#protected String processCIncludeElement(String src, String element,
                                            String select, String ns, String prefix,
                                            boolean stripRoot,
                                            boolean cache)
    throws SAXException, IOException {

        if (src == null) {
            throw new SAXException("Missing 'src' attribute on cinclude:include element");
        }

        if (element == null) element="";
        if (select == null) select="";
        if (ns == null) ns="";
        if (prefix == null) prefix="";

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Processing include element: src=" + src
                          + ", element=" + element
                          + ", select=" + select
                          + ", ns=" + ns
                          + ", prefix=" + prefix
                          + ", stripRoot=" + stripRoot
                          + ", caching=" + cache);
        }

        if (cache) {
            src = this.cacheManager.load(src, this.cachingSession);

            if (this.cachingSession.isParallel() && !this.cachingSession.isPreemptive()) {
                if (!this.compiling) {
                    this.compiling = true;
                    this.startCompiledXMLRecording();
                }
            } else {
                this.cacheManager.stream(src, this.cachingSession, this.filter);
            }

            return src;
        }

        // usual no caching stuff
        if (!"".equals(element)) {
            if (!ns.equals("")) {
                super.startPrefixMapping(prefix, ns);
            }
            super.startElement(ns,
                               element,
                               (!ns.equals("") && !prefix.equals("") ? prefix+":"+element : element),
                               XMLUtils.EMPTY_ATTRIBUTES);
        }

        Source source = null;
        try {
            source = this.resolver.resolveURI(src);

            if (!"".equals(select)) {


                DOMParser parser = null;
                XPathProcessor processor = null;

                try {
                    parser = (DOMParser)this.manager.lookup(DOMParser.ROLE);
                    processor = (XPathProcessor)this.manager.lookup(XPathProcessor.ROLE);

                    InputSource input = SourceUtil.getInputSource(source);

                    Document document = parser.parseDocument(input);
                    NodeList list = processor.selectNodeList(document, select);
                    int length = list.getLength();
                    for (int i=0; i<length; i++) {
                          IncludeXMLConsumer.includeNode(list.item(i),
                                               this.filter,
                                               this.filter);
                    }
                } finally {
                    this.manager.release(parser);
                    this.manager.release(processor);
                }
            } else {
                String mimeType = null;
                if (null != this.configurationParameters) {
                    mimeType = this.configurationParameters.getParameter("mime-type", mimeType);
                }
                if (this.compiling) {
                    SourceUtil.toSAX(source, mimeType, new IncludeXMLConsumer(this.contentHandler, this.lexicalHandler));
                } else {
                    this.filter.setIgnoreRootElement(stripRoot);
                    SourceUtil.toSAX(source, mimeType, this.filter);
                }
            }

        } catch (SourceException se) {
            throw new SAXException("Exception in CIncludeTransformer",se);
        } catch (IOException e) {
            throw new SAXException("CIncludeTransformer could not read resource", e);
        } catch (ProcessingException e){
            throw new SAXException("Exception in CIncludeTransformer",e);
        } catch(ServiceException e) {
            throw new SAXException(e);
        } finally {
            this.resolver.release(source);
        }

        if (!"".equals(element)) {
            super.endElement(ns, element, (!ns.equals("") && !prefix.equals("") ? prefix+":"+element : element));
            if (!ns.equals("")) {
                super.endPrefixMapping(prefix);
            }
        }
        return src;
    }
14218#/**
     * Start recording of compiled xml.
     * The incomming SAX events are recorded and a compiled representation
     * is created. These events are not forwarded to the next component in
     * the pipeline.
     */
    protected void startCompiledXMLRecording()
    throws SAXException {
        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("BEGIN startCompiledXMLRecording");
        }

        this.addRecorder(new XMLByteStreamCompiler());

        if (this.getLogger().isDebugEnabled()) {
           this.getLogger().debug("END startCompiledXMLRecording");
        }
    }
14219#/**
     * Stop recording of compiled XML.
     * @return The compiled XML.
     */
    protected Object endCompiledXMLRecording()
    throws SAXException {
        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("BEGIN endCompiledXMLRecording");
        }

        XMLByteStreamCompiler recorder = (XMLByteStreamCompiler)this.removeRecorder();
        Object text = recorder.getSAXFragment();

        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("END endCompiledXMLRecording text="+text);
        }
        return text;
    }
14220#/**
     * @see org.xml.sax.ContentHandler#startDocument()
     */
    public void startDocument() throws SAXException {
        this.filter = new MyFilter(this.xmlConsumer,
                                   this);
        super.startDocument();
    }
14221#/**
     * @see org.xml.sax.ContentHandler#endDocument()
     */
    public void endDocument() throws SAXException {
        if ( this.compiling ) {
            Object compiledXML = this.endCompiledXMLRecording();
            XMLByteStreamInterpreter deserializer = new XMLByteStreamInterpreter();
            deserializer.setConsumer(this.filter);
            deserializer.deserialize(compiledXML);
        }
        super.endDocument();
    }
14222#/**
     * @see org.apache.cocoon.caching.CacheableProcessingComponent#getKey()
     */
    public Serializable getKey() {
        if (this.supportCaching
            && null != this.cacheManager
            && this.cachingSession.getExpires() > 0) {
            return "1";
        }
        return null;
    }
14223#/**
     * @see org.apache.cocoon.caching.CacheableProcessingComponent#getValidity()
     */
    public SourceValidity getValidity() {
        if (this.supportCaching
            && null != this.cacheManager
            && this.cachingSession.getExpires() > 0
            && !this.cachingSession.isPurging()) {
            return this.cachingSession.getExpiresValidity();
        }
        return null;
    }
14224#/**
     * This filter class post-processes the parallel fetching
     * @param consumer
     */
    public MyFilter(XMLConsumer consumer,
                    CIncludeTransformer transformer) {
        super(consumer);
        this.transformer = transformer;
    }
14225#/**
     * @see org.xml.sax.ContentHandler#endElement(java.lang.String, java.lang.String, java.lang.String)
     */
    public void endElement(String uri, String local, String qName)
    throws SAXException {
        if (uri != null
            && uri.equals(CIncludeTransformer.CINCLUDE_NAMESPACE_URI)
            && local.equals(CIncludeTransformer.CINCLUDE_CACHED_INCLUDE_PLACEHOLDER_ELEMENT)) {
            // this is the placeholder element: do nothing
        } else {
            super.endElement(uri, local, qName);
        }
    }
14226#/**
     * @see org.xml.sax.ContentHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
     */
    public void startElement(String uri,
                                String local,
                                String qName,
                                Attributes attr)
    throws SAXException {
        if (uri != null
            && uri.equals(CIncludeTransformer.CINCLUDE_NAMESPACE_URI)
            && local.equals(CIncludeTransformer.CINCLUDE_CACHED_INCLUDE_PLACEHOLDER_ELEMENT)) {
            // this is a placeholder
            try {
                final String src = attr.getValue("",CIncludeTransformer.CINCLUDE_INCLUDE_ELEMENT_SRC_ATTRIBUTE);
                this.transformer.cacheManager.stream(src, this.transformer.cachingSession, this);
            } catch (IOException ioe) {
                throw new SAXException("IOException", ioe);
            }
        } else {
            super.startElement(uri, local, qName, attr);
        }
    }
14227#/**
     * Constructor. Set the namespace.
     */
    public SimpleFormTransformer() {
        super.defaultNamespaceURI = "";
    }
14228#/** set per instance variables to defaults */
    private void reset() {
        this.skipChildrenOnly = false;
        this.values = null;
        this.validationResults = null;
        this.documentFixed = false;
        this.fixed = false;
        this.formName = null;
        this.recordingCount = 0;
        this.repeater = new LinkedList();
        this.formValues = new HashMap();

        if (this.inputSelector != null) {
            if (this.input != null)
                this.inputSelector.release(this.input);
            this.manager.release(this.inputSelector);
        }
    }
14229#/**
     * Avalon Configurable Interface
     */
    public void configure(Configuration config) throws ConfigurationException {
        super.configure(config);

        this.defaultInputConf = config.getChild("input-module");
        this.defaultInput = this.defaultInputConf.getAttribute("name", this.defaultInput);
        this.separator = config.getChild("separator").getValue(this.separator);
        this.defaultPrefix = config.getChild("prefix").getValue(this.defaultPrefix);
        this.defaultSuffix = config.getChild("suffix").getValue(this.defaultSuffix);
        this.fixedName = config.getChild("fixed-attribute").getValue(this.fixedName);
        this.useFormName = config.getChild("use-form-name").getValueAsBoolean(this.useFormName);
        this.useFormNameTwice =
            config.getChild("use-form-name-twice").getValueAsBoolean(this.useFormNameTwice);
        this.useFormName = this.useFormName || this.useFormNameTwice;
        if (this.useFormName) {
            this.separator =
                (this.separator == null || this.separator.equals("") ? "/" : this.separator);
            this.defaultPrefix = this.separator;
        }
        this.ignoreValidation =
            config.getChild("ignore-validation").getValueAsBoolean(this.ignoreValidation);
        this.decorationSize = config.getChild("decoration").getValueAsInteger(this.decorationSize);
        this.stripNumber = config.getChild("strip-number").getValueAsBoolean(this.stripNumber);
    }
14230#/**
     * Read sitemap parameters and set properties accordingly.
     */
    private void evaluateParameters() {
        this.documentFixed = this.parameters.getParameterAsBoolean("fixed", false);
        this.fixed = this.documentFixed;
        this.prefix = this.parameters.getParameter("prefix", this.defaultPrefix);
        this.suffix = this.parameters.getParameter("suffix", this.defaultSuffix);
        this.inputName = this.parameters.getParameter("input", null);
        this.decorationSize =
            this.parameters.getParameterAsInteger("decoration", this.decorationSize);
        this.stripNumber = this.parameters.getParameterAsBoolean("strip-number", this.stripNumber);
    }
14231#/**
     * Setup the next round.
     * The instance variables are initialised.
     * @param resolver The current SourceResolver
     * @param objectModel The objectModel of the environment.
     * @param src The value of the src attribute in the sitemap.
     * @param par The parameters from the sitemap.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
        throws ProcessingException, SAXException, IOException {

        this.reset();

        super.setup(resolver, objectModel, src, par);

        if (request == null) {
            getLogger().debug("no request object");
            throw new ProcessingException("no request object");
        }
        this.evaluateParameters();
        this.setupInputModule();

    }
14232#/**
     * Setup and obtain reference to the input module.
     */
    private void setupInputModule() {
        this.inputConf = null;
        if (this.ignoreValidation) {
            this.validationResults = null;
        } else {
            this.validationResults = FormValidatorHelper.getResults(this.objectModel);
        }

        if (this.inputName == null) {
            this.inputName = this.defaultInput;
            this.inputConf = this.defaultInputConf;
        }

        try {
            // obtain input module
            this.inputSelector = (ServiceSelector) this.manager.lookup(INPUT_MODULE_SELECTOR);
            if (this.inputName != null
                && this.inputSelector != null
                && this.inputSelector.isSelectable(this.inputName)) {
                this.input = (InputModule) this.inputSelector.select(this.inputName);
                if (!(this.input instanceof ThreadSafe
                    && this.inputSelector instanceof ThreadSafe)) {
                    this.inputSelector.release(this.input);
                    this.manager.release(this.inputSelector);
                    this.input = null;
                    this.inputSelector = null;
                }
            } else {
                if (this.inputName != null)
                    if (getLogger().isErrorEnabled())
                        getLogger().error(
                            "A problem occurred setting up '"
                                + this.inputName
                                + "': Selector is "
                                + (this.inputSelector != null ? "not " : "")
                                + "null, Component is "
                                + (this.inputSelector != null
                                    && this.inputSelector.isSelectable(this.inputName)
                                        ? "known"
                                        : "unknown"));
            }
        } catch (Exception e) {
            if (getLogger().isWarnEnabled())
                getLogger().warn(
                    "A problem occurred setting up '" + this.inputName + "': " + e.getMessage());
        }
    }
14233#/**
     *  Recycle this component.
     */
    public void recycle() {
        reset();
        super.recycle();
    }
14234#/**
     * Generate string representation of attributes. For debug only.
     */
    protected String printAttributes(Attributes attr) {
        StringBuffer sb = new StringBuffer();
        sb.append('[');
        for (int i = 0; i < attr.getLength(); i++) {
            sb.append('@').append(attr.getLocalName(i)).append("='").append(
                attr.getValue(i)).append(
                "' ");
        }
        sb.append(']');
        return sb.toString();
    }
14235#/**
     * Handle input elements that may have a "checked" attributes,
     * i.e. checkbox and radio.
     */
    protected void startCheckableElement(
        String aName,
        String uri,
        String name,
        String raw,
        AttributesImpl attributes)
        throws SAXException {

        // @fixed and this.fixed already considered in startInputElement
        this.values = this.getValues(aName);
        String checked = attributes.getValue("checked");
        String value = attributes.getValue("value");
        boolean found = false;

        if (getLogger().isDebugEnabled())
            getLogger().debug(
                "startCheckableElement "
                    + name
                    + " attributes "
                    + this.printAttributes(attributes));
        if (this.values != null) {
            if (getLogger().isDebugEnabled())
                getLogger().debug("replacing");
            for (int i = 0; i < this.values.length; i++) {
                if (this.values[i].equals(value)) {
                    found = true;
                    if (checked == null) {
                        attributes.addAttribute("", "checked", "checked", "CDATA", "");
                    }
                    break;
                }
            }
            if (!found && checked != null) {
                attributes.removeAttribute(attributes.getIndex("checked"));
            }
        }
        this.relayStartElement(uri, name, raw, attributes);
    }
14236#/**
     * Handle input elements that may don't have a "checked"
     * attributes, e.g. text, password, button.
     */
    protected void startNonCheckableElement(
        String aName,
        String uri,
        String name,
        String raw,
        AttributesImpl attributes)
        throws SAXException {

        // @fixed and this.fixed already considered in startInputElement
        Object fValue = this.getNextValue(aName);
        String value = attributes.getValue("value");
        if (getLogger().isDebugEnabled())
            getLogger().debug(
                "startNonCheckableElement "
                    + name
                    + " attributes "
                    + this.printAttributes(attributes));
        if (fValue != null) {
            if (getLogger().isDebugEnabled())
                getLogger().debug("replacing");
            if (value != null) {
                attributes.setValue(attributes.getIndex("value"), String.valueOf(fValue));
            } else {
                attributes.addAttribute("", "value", "value", "CDATA", String.valueOf(fValue));
            }
        }
        this.relayStartElement(uri, name, raw, attributes);
    }
14237#/**
     * Handle input elements. Calls startCheckableElement or
     * startNonCheckableElement.
     */
    protected void startInputElement(String uri, String name, String raw, Attributes attr)
        throws SAXException {

        // @value = request.getParameterValues(@name)
        String aName = getName(attr.getValue("name"));
        String fixed = attr.getValue(this.fixedName);

        if (getLogger().isDebugEnabled())
            getLogger().debug(
                "startInputElement " + name + " attributes " + this.printAttributes(attr));
        if (aName == null || this.fixed || (fixed != null && BooleanUtils.toBoolean(fixed))) {
            this.relayStartElement(uri, name, raw, attr);

        } else {
            if (getLogger().isDebugEnabled())
                getLogger().debug("replacing");

            attr = this.normalizeAttributes(attr);

            AttributesImpl attributes = null;
            if (attr instanceof AttributesImpl) {
                attributes = (AttributesImpl) attr;
            } else {
                attributes = new AttributesImpl(attr);
            }
            String type = attributes.getValue("type");
            switch (((Integer) inputTypes.get(type, defaultType)).intValue()) {
                case TYPE_CHECKBOX :
                case TYPE_RADIO :
                    this.startCheckableElement(aName, uri, name, raw, attributes);
                    break;

                case TYPE_DEFAULT :
                    this.startNonCheckableElement(aName, uri, name, raw, attributes);
                    break;
            }
            this.values = null;
        }
    }
14238#/**
     * Handle select elements. Sets up some instance variables for
     * following option elements.
     */
    protected void startSelectElement(String uri, String name, String raw, Attributes attr)
        throws SAXException {

        // this.values = request.getParameterValues(@name)
        String aName = getName(attr.getValue("name"));
        String fixed = attr.getValue(this.fixedName);
        this.values = null;
        if (getLogger().isDebugEnabled())
            getLogger().debug(
                "startSelectElement " + name + " attributes " + this.printAttributes(attr));
        if (aName != null && !(this.fixed || (fixed != null && BooleanUtils.toBoolean(fixed)))) {
            if (attr.getIndex("multiple") > -1) {
                this.values = this.getValues(aName);
            } else {
                Object val = this.getNextValue(aName);
                if (val != null) {
                    this.values = new Object[1];
                    this.values[0] = val;
                } else {
                    this.values = null;
                }
            }
            attr = this.normalizeAttributes(attr);
        }
        this.relayStartElement(uri, name, raw, attr);
    }
14239#/**
     * Handle option elements. Uses instance variables set up by
     * startSelectElement. Relies on option having a "value"
     * attribute, i.e. does not check following characters if "value"
     * is not present.
     */
    protected void startOptionElement(String uri, String name, String raw, Attributes attr)
        throws SAXException {

        // add @selected if @value in request.getParameterValues(@name)
        if (getLogger().isDebugEnabled())
            getLogger().debug(
                "startOptionElement " + name + " attributes " + this.printAttributes(attr));
        if (this.values == null || this.fixed) {
            this.relayStartElement(uri, name, raw, attr);
        } else {
            if (getLogger().isDebugEnabled())
                getLogger().debug("replacing");
            AttributesImpl attributes = null;
            if (attr instanceof AttributesImpl) {
                attributes = (AttributesImpl) attr;
            } else {
                attributes = new AttributesImpl(attr);
            }
            String selected = attributes.getValue("selected");
            String value = attributes.getValue("value");
            boolean found = false;

            for (int i = 0; i < this.values.length; i++) {
                if (this.values[i].equals(value)) {
                    found = true;
                    if (selected == null) {
                        attributes.addAttribute("", "selected", "selected", "CDATA", "");
                    }
                    break;
                }
            }
            if (!found && selected != null) {
                attributes.removeAttribute(attributes.getIndex("selected"));
            }

            this.relayStartElement(uri, name, raw, attributes);
        }
    }
14240#/**
     * Handles textarea elements. Skips nested events if request
     * parameter with same name exists.
     */
    protected void startTextareaElement(String uri, String name, String raw, Attributes attributes)
        throws SAXException {

        String aName = getName(attributes.getValue("name"));
        String fixed = attributes.getValue(this.fixedName);
        Object value = null;
        if (getLogger().isDebugEnabled())
            getLogger().debug(
                "startTextareaElement " + name + " attributes " + this.printAttributes(attributes));
        if (aName != null) {
            value = this.getNextValue(aName);
        }
        if (value == null || this.fixed || (fixed != null && BooleanUtils.toBoolean(fixed))) {
            this.relayStartElement(uri, name, raw, attributes);
        } else {
            if (getLogger().isDebugEnabled())
                getLogger().debug("replacing");
            this.relayStartElement(uri, name, raw, this.normalizeAttributes(attributes));
            String valString = String.valueOf(value);
            this.characters(valString.toCharArray(), 0, valString.length());
            // well, this doesn't really work out nicely. do it the hard way.
            if (this.ignoreEventsCount == 0)
                this.skipChildrenOnly = true;
            this.ignoreEventsCount++;
        }
    }
14241#/**
     * Handle error elements. If validation results are available,
     * compares validation result for parameter with the same name as
     * the "name" attribute with the result names is "when" and
     * "when-ge". Drops element and all nested events when error
     * condition is not met.
     */
    protected void startErrorElement(String uri, String name, String raw, Attributes attr)
        throws SAXException {

        if (getLogger().isDebugEnabled())
            getLogger().debug(
                "startErrorElement " + name + " attributes " + this.printAttributes(attr));
        if (this.ignoreValidation) {
            this.relayStartElement(uri, name, raw, attr);
        } else if (this.validationResults == null || this.fixed) {
            this.relayStartElement(true, false, uri, name, raw, attr);
        } else {
            String aName = attr.getValue("name");
            if (aName == null) {
                this.relayStartElement(uri, name, raw, attr);
            } else {
                ValidatorActionResult validation =
                    FormValidatorHelper.getParamResult(this.objectModel, aName);
                String when = attr.getValue("when");
                String when_ge = attr.getValue("when-ge");

                if ((when != null && when.equals(validatorResults.get(validation)))
                    || (when_ge != null
                        && validation.ge(
                            (ValidatorActionResult) validatorResultLabel.get(
                                when_ge,
                                ValidatorActionResult.MAXERROR)))) {
                    AttributesImpl attributes = null;
                    if (attr instanceof AttributesImpl) {
                        attributes = (AttributesImpl) attr;
                    } else {
                        attributes = new AttributesImpl(attr);
                    }
                    // remove attributes not meant for client
                    attributes.removeAttribute(attributes.getIndex("name"));
                    if (when != null)
                        attributes.removeAttribute(attributes.getIndex("when"));
                    if (when_ge != null)
                        attributes.removeAttribute(attributes.getIndex("when-ge"));
                    this.relayStartElement(uri, name, raw, this.normalizeAttributes(attributes));
                } else {
                    this.relayStartElement(true, true, uri, name, raw, attr);
                }
            }
        }
    }
14242#/**
     * Start processing a form element. Sets protection indicator if attribute
     * "fixed" is present and either "true" or "yes". Removes attribute "fixed"
     * if present.
     * @param uri The namespace of the element.
     * @param name The local name of the element.
     * @param raw The qualified name of the element.
     * @param attr The attributes of the element.
     */
    protected void startFormElement(String uri, String name, String raw, Attributes attr)
        throws SAXException {

        String fixed = attr.getValue(this.fixedName);
        if (this.useFormName) {
            this.formName = attr.getValue("name");
        }
        if (fixed == null) {
            this.relayStartElement(uri, name, raw, attr);
        } else {
            if (!this.fixed && BooleanUtils.toBoolean(fixed)) {
                this.fixed = true;
            }
            // remove attributes not meant for client
            AttributesImpl attributes = null;
            if (attr instanceof AttributesImpl) {
                attributes = (AttributesImpl) attr;
            } else {
                attributes = new AttributesImpl(attr);
            }
            attributes.removeAttribute(attributes.getIndex(this.fixedName));
            this.relayStartElement(uri, name, raw, this.normalizeAttributes(attributes));
        }
    }
14243#/**
     * Start recording repeat element contents and push repeat expression and
     * variable to repeater stack. Only start recording, if no other recorder is
     * currently running.
     *
     * @param uri
     * @param name
     * @param raw
     * @param attr
     * @throws SAXException
     */
    protected void startRepeatElement(String uri, String name, String raw, Attributes attr)
        throws SAXException {

        if (this.recordingCount == 0) {
            if (!(this.fixed || BooleanUtils.toBoolean(attr.getValue(this.fixedName)))) {
                RepeaterStatus status =
                    new RepeaterStatus("${" + attr.getValue("using") + "}", 0, attr.getValue("on"));
                this.repeater.add(status);
                this.startRecording();
                this.recordingCount++;
            } else {
                this.relayStartElement(uri, name, raw, attr);
            }
        } else {
            this.relayStartElement(uri, name, raw, attr);
            this.recordingCount++;
        }
    }
14244#/**
     * Stop recording repeat contents and replay required number of times.
     * Stop only if outmost repeat element is ending.
     *
     * @param uri
     * @param name
     * @param raw
     * @throws SAXException
     */
    protected void endRepeatElement(String uri, String name, String raw) throws SAXException {
        this.recordingCount--;
        if (this.recordingCount == 0) {
            DocumentFragment fragment = this.endRecording();
            RepeaterStatus status = (RepeaterStatus) this.repeater.get(this.repeater.size() - 1);
            Object[] vals = this.getValues(this.getName(status.expr));
            int count = (vals != null ? vals.length : 0);
            for (status.count = 1; status.count <= count; status.count++) {
                DOMStreamer streamer = new DOMStreamer(this, this);
                streamer.stream(fragment);
            }
            this.repeater.remove(this.repeater.size() - 1);
        } else {
            this.relayEndElement(uri, name, raw);
            if (this.recordingCount < 0) {
                this.recordingCount = 0;
            }
        }
    }
14245#/**
     * Start processing elements of our namespace.
     * This hook is invoked for each sax event with our namespace.
     * @param uri The namespace of the element.
     * @param name The local name of the element.
     * @param raw The qualified name of the element.
     * @param attr The attributes of the element.
     */
    public void startTransformingElement(String uri, String name, String raw, Attributes attr)
        throws SAXException {

        if (this.ignoreEventsCount == 0 && this.recordingCount == 0) {
            switch (((Integer) elementNames.get(name, defaultElement)).intValue()) {
                case ELEMENT_INPUT :
                    this.startInputElement(uri, name, raw, attr);
                    break;

                case ELEMENT_SELECT :
                    this.startSelectElement(uri, name, raw, attr);
                    break;

                case ELEMENT_OPTION :
                    this.startOptionElement(uri, name, raw, attr);
                    break;

                case ELEMENT_TXTAREA :
                    this.startTextareaElement(uri, name, raw, attr);
                    break;

                case ELEMENT_ERROR :
                    this.startErrorElement(uri, name, raw, attr);
                    break;

                case ELEMENT_FORM :
                    this.startFormElement(uri, name, raw, attr);
                    break;

                case ELEMENT_REPEAT :
                    this.startRepeatElement(uri, name, raw, attr);
                    break;

                default :
                    this.relayStartElement(uri, name, raw, attr);
            }

        } else if (this.recordingCount > 0) {
            switch (((Integer) elementNames.get(name, defaultElement)).intValue()) {
                case ELEMENT_REPEAT :
                    this.startRepeatElement(uri, name, raw, attr);
                    break;

                default :
                    this.relayStartElement(uri, name, raw, attr);
            }
        } else {
            this.relayStartElement(uri, name, raw, attr);
        }
    }
14246#/**
     * Start processing elements of our namespace.
     * This hook is invoked for each sax event with our namespace.
     * @param uri The namespace of the element.
     * @param name The local name of the element.
     * @param raw The qualified name of the element.
     */
    public void endTransformingElement(String uri, String name, String raw) throws SAXException {

        if (this.ignoreEventsCount > 0) {
            this.relayEndElement(uri, name, raw);
        } else if (this.recordingCount > 0) {
            switch (((Integer) elementNames.get(name, defaultElement)).intValue()) {
                case ELEMENT_REPEAT :
                    this.endRepeatElement(uri, name, raw);
                    break;

                default :
                    this.relayEndElement(uri, name, raw);
            }
        } else {
            switch (((Integer) elementNames.get(name, defaultElement)).intValue()) {
                case ELEMENT_SELECT :
                    this.values = null;
                    this.relayEndElement(uri, name, raw);
                    break;
                case ELEMENT_INPUT :
                case ELEMENT_OPTION :
                case ELEMENT_TXTAREA :
                case ELEMENT_ERROR :
                    this.relayEndElement(uri, name, raw);
                    break;
                case ELEMENT_FORM :
                    this.fixed = this.documentFixed;
                    this.formName = null;
                    this.relayEndElement(uri, name, raw);
                    break;

                case ELEMENT_REPEAT :
                    this.endRepeatElement(uri, name, raw);
                    break;

                default :
                    this.relayEndElement(uri, name, raw);
            }
        }
    }
14247#/**
     * Remove extra information from element's attributes. Currently only removes
     * the repeater variable from the element's name attribute if present.
     *
     * @param attr
     * @return modified attributes
     */
    private Attributes normalizeAttributes(Attributes attr) {
        Attributes result = attr;
        if (this.stripNumber && this.repeater.size() > 0) {
            String name = attr.getValue("name");
            if (name != null) {
                for (Iterator i = this.repeater.iterator(); i.hasNext();) {
                    RepeaterStatus status = (RepeaterStatus) i.next();
                    int pos = name.indexOf(status.var);
                    if (pos >= 0) {
                        AttributesImpl attributes;
                        if (result instanceof AttributesImpl) {
                            attributes = (AttributesImpl) result;
                        } else {
                            attributes = new AttributesImpl(result);
                        }
                        name =
                            name.substring(0, pos - this.decorationSize)
                                + name.substring(pos + status.var.length() + this.decorationSize);
                        attributes.setValue(attributes.getIndex("name"), name);
                        result = attributes;
                    }
                }
            }
        }
        return result;
    }
14248#/**
     * Generate the "real" name of an element for value lookup.
     * @param name
     * @return "real" name.
     */
    private String getName(String name) {
        String result = name;
        if (this.useFormName && this.formName != null) {
            if (this.separator != null) {
                if (this.useFormNameTwice) {
                    result =
                        this.formName + this.separator + this.formName + this.separator + result;
                } else {
                    result = this.formName + this.separator + result;
                }
            } else {
                if (this.useFormNameTwice) {
                    result = this.formName + result;
                } else {
                    // does this make sense ?
                    result = this.formName + this.formName + result;
                }
            }
        }
        if (this.prefix != null) {
            result = this.prefix + result;
        }
        if (this.suffix != null) {
            result = result + this.prefix;
        }
        if (this.repeater.size() > 0) {
            for (Iterator i = this.repeater.iterator(); i.hasNext();) {
                RepeaterStatus status = (RepeaterStatus) i.next();
                int pos = result.indexOf(status.var);
                if (pos != -1) {
                    result =
                        result.substring(0, pos)
                            + status.count
                            + result.substring(pos + status.var.length());
                }
            }
        }
        return result;
    }
14249#/**
     * Obtain values from used InputModule if not done already and return the
     * next value. If no more values exist, returns null.
     *
     * @param name
     */
    private Object getNextValue(String name) {
        Object result = null;
        if (this.formValues.containsKey(name)) {
            ValueList vList = (ValueList) this.formValues.get(name);
            result = vList.getNext();
        } else {
            ValueList vList = new ValueList(this.getValues(name));
            result = vList.getNext();
            this.formValues.put(name, vList);
        }
        return result;
    }
14250#/**
     * Obtain values from the used InputModule.
     */
    private Object[] getValues(String name) {
        Object[] values = null;
        ServiceSelector iputSelector = null;
        InputModule iput = null;
        try {
            if (this.input != null) {
                // input module is thread safe
                // thus we still have a reference to it
                values = input.getAttributeValues(name, this.inputConf, objectModel);
                if (getLogger().isDebugEnabled())
                    getLogger().debug("cached module " + this.input
                                      + " attribute " + name
                                      + " returns " + values);
            } else {
                // input was not thread safe
                // so acquire it again
                iputSelector = (ServiceSelector)this.manager.lookup(INPUT_MODULE_SELECTOR);
                if (this.inputName != null
                    && iputSelector != null
                    && iputSelector.isSelectable(this.inputName)) {

                    iput = (InputModule) iputSelector.select(this.inputName);
                }
                if (iput != null) {
                    values = iput.getAttributeValues(name, this.inputConf, objectModel);
                }
                if (getLogger().isDebugEnabled())
                    getLogger().debug(
                        "fresh module " + iput + " attribute " + name + " returns " + values);
            }
        } catch (Exception e) {
            if (getLogger().isWarnEnabled())
                getLogger().warn(
                    "A problem occurred acquiring a value from '"
                        + this.inputName
                        + "' for '"
                        + name
                        + "': "
                        + e.getMessage());
        } finally {
            // release components if necessary
            if (iputSelector != null) {
                if (iput != null)
                    iputSelector.release(iput);
                this.manager.release(iputSelector);
            }
        }

        return values;
    }
14251#/**
     * Calls the super's method startTransformingElement.
     *
     * @param uri
     * @param name
     * @param raw
     * @param attr
     * @throws SAXException
     */
    protected void relayStartElement(String uri, String name, String raw, Attributes attr)
        throws SAXException {
        this.relayStartElement(false, false, uri, name, raw, attr);
    }
14252#/**
     * Calls the super's method startTransformingElement and increments the
     * ignoreEventsCount if skip is true. Increment can be done either before
     * invoking super's method, so that the element itself is skipped, or afterwards,
     * so that only the children are skipped.
     *
     * @param skip
     * @param skipChildrenOnly
     * @param uri
     * @param name
     * @param raw
     * @param attr
     * @throws SAXException
     */
    protected void relayStartElement(
        boolean skip,
        boolean skipChildrenOnly,
        String uri,
        String name,
        String raw,
        Attributes attr)
        throws SAXException {

        try {
            if (this.ignoreEventsCount > 0) {
                this.ignoreEventsCount++;
                super.startTransformingElement(uri, name, raw, attr);
            } else {
                if (skip)
                    this.skipChildrenOnly = skipChildrenOnly;
                if (skip && !skipChildrenOnly)
                    this.ignoreEventsCount++;
                super.startTransformingElement(uri, name, raw, attr);
                if (skip && skipChildrenOnly)
                    this.ignoreEventsCount++;
            }
        } catch (ProcessingException e) {
            throw new SAXException(e);
        } catch (IOException e) {
            throw new SAXException(e);
        }
    }
14253#/**
     * Calls the super's method endTransformingElement and decrements the
     * ignoreEventsCount if larger than zero.
     *
     * @param uri
     * @param name
     * @param raw
     * @throws SAXException
     */
    protected void relayEndElement(String uri, String name, String raw) throws SAXException {

        if (this.ignoreEventsCount == 1 && this.skipChildrenOnly)
            this.ignoreEventsCount--;
        try {
            super.endTransformingElement(uri, name, raw);
        } catch (ProcessingException e) {
            throw new SAXException(e);
        } catch (IOException e) {
            throw new SAXException(e);
        } catch (Exception e) {
            getLogger().error("exception", e);
        }

        if (this.ignoreEventsCount > 0)
            this.ignoreEventsCount--;
    }
14254#public RepeaterStatus(String var, int count, String expr) {
            this.var = var;
            this.count = count;
            this.expr = expr;
        }
14255#public String toString() {
            return "[" + this.var + "," + this.expr + "," + this.count + "]";
        }
14256#public ValueList(Object[] values) {
            this.values = values;
            this.current = (values != null && values.length > 0 ? 0 : -1);
        }
14257#public Object getNext() {
            Object result = null;
            if (this.values != null) {
                if (this.current < this.values.length) {
                    result = this.values[this.current++];
                }
            }
            return result;
        }
14258#/**
     * Create a session for this request.
     * This should be invoked first and only one per request. It is required
     * to terminate the session with {@link #terminateSession(IncludeCacheManagerSession)}
     * @param pars The configuration
     * @return CacheManagerSession The session that should be used with all other commands.
     */
    IncludeCacheManagerSession getSession(Parameters pars);
14259#/**
     * This informs the manager that a URI should be "loaded".
     * @param uri     The URI to load (maybe relative)
     * @param session The corresponding session created by {@link #getSession(Parameters)}
     * @return String The absolute URI that must be used for {@link #stream(String, IncludeCacheManagerSession, XMLConsumer)}
     * @throws IOException
     * @throws SourceException
     */
    String load(String  uri, 
                IncludeCacheManagerSession session)
    throws IOException, SourceException;
14260#/**
     * Stream the content of the absolute URI.
     * Depending on the configuration and state of the cache, the
     * content is either taken from the cache, fetched etc.
     * @param uri     The absolute URI returned by {@link #load(String, IncludeCacheManagerSession)}
     * @param session The current session
     * @param handler The receiver of the SAX events
     * @throws IOException
     * @throws SourceException
     * @throws SAXException
     */
    void stream(String uri,
                 IncludeCacheManagerSession session,
                 XMLConsumer handler)
    throws IOException, SourceException, SAXException;
14261#/**
     * Terminate the session. This method must be executed at the end of the
     * request.
     * @param session The caching session.
     */
    void terminateSession(IncludeCacheManagerSession session);
14262#public FormValidatorHelper(String descriptor, boolean reloadable,
                               Log logger, SourceResolver resolver) {
        current_descriptor = descriptor;
        current_reloadable = reloadable;
        current_logger = logger;
        current_resolver = resolver;
    }
14263#public FormValidatorHelper(String descriptor, boolean reloadable,
                               Log logger, SourceResolver resolver,
                               String constraintset) {
        current_descriptor = descriptor;
        current_reloadable = reloadable;
        current_logger = logger;
        current_resolver = resolver;
        current_constraint_set = constraintset;
    }
14264#/**
     * keep track of current parameter context
     */
    public void setParameter(String parameter) {
        current_parameter = parameter;
    }
14265#/**
     * keep track of current constraint-set context
     * (probably this is not needed?)
     */
    public void setConstraintSet(String constraintset) {
        current_constraint_set = constraintset;
    }
14266#/**
     * Get the specified attribute
     *
     * @param objectModel The Map objectModel
     * @param name The parameter name
     */
    public static Object getAttribute(Map objectModel, String name) {
        Request request = ObjectModelHelper.getRequest(objectModel);
        return request.getAttribute(name);
    }
14267#/**
     * Extracts the validation results from the request attribute
     *
     * @param objectModel The Map objectModel
     * @return Map with ValidatorActionResults
     * @see org.apache.cocoon.acting.ValidatorActionResult
     */
    public static Map getResults(Map objectModel) {
        Request request = ObjectModelHelper.getRequest(objectModel);
        return (Map) request.getAttribute(AbstractValidatorAction.FORMVALIDATOR_PATH);
    }
14268#/**
     * Extracts the validation results from the request attribute
     * for a specific request parameter
     *
     * @param objectModel The Map objectModel
     * @param name Request parameter's name
     * @see org.apache.cocoon.acting.ValidatorActionResult
     */
    public static ValidatorActionResult getParamResult(Map objectModel,
                                                       String name) {
        ValidatorActionResult result = ValidatorActionResult.NOTPRESENT;
        Map param_result = getResults(objectModel);
        if (param_result != null) {
            result = (ValidatorActionResult) param_result.get(name);
        }
        return (result != null? result : ValidatorActionResult.NOTPRESENT);
    }
14269#/**
     * Extracts the validation results from the request attribute
     * for the context's current request parameter
     *
     * @param objectModel The Map objectModel
     * @see org.apache.cocoon.acting.ValidatorActionResult
     */
    public ValidatorActionResult getParamResult(Map objectModel) {
        ValidatorActionResult result = ValidatorActionResult.NOTPRESENT;
        Map param_result = getResults(objectModel);
        if (param_result != null) {
            result = (ValidatorActionResult) param_result.get(current_parameter);
        }
        return (result != null? result : ValidatorActionResult.NOTPRESENT);
    }
14270#/**
     * Test whether the validation returned no error for this
     * parameter.
     *
     * @param objectModel The Map objectModel
     * @param name Request parameter's name
     * @return true only if the parameter was validated and the validation
     * did not return an error.
     */
    public static boolean isOK(Map objectModel, String name) {
        return getParamResult(objectModel, name).equals(ValidatorActionResult.OK);
    }
14271#/**
     * Test whether the validation returned no error for the
     * context's current parameter.
     *
     * @param objectModel The Map objectModel
     * @return true only if the parameter was validated and the validation
     * did not return an error.
     */
    public boolean isOK(Map objectModel) {
        return isOK(objectModel, current_parameter);
    }
14272#/**
     * Test whether the validation returned an error for this
     * parameter.
     *
     * @param objectModel The Map objectModel
     * @param name Request parameter's name
     * @return true if the parameter was either not validated or the validation
     * returned an error.
     */
    public static boolean isError(Map objectModel, String name) {
        return getParamResult(objectModel, name).ge(ValidatorActionResult.ERROR);
    }
14273#/**
     * Test whether the validation returned an error for the
     * context's current parameter.
     *
     * @param objectModel The Map objectModel
     * @return true if the parameter was either not validated or the validation
     * returned an error.
     */
    public boolean isError(Map objectModel) {
        return isError(objectModel, current_parameter);
    }
14274#/**
     * Test whether the validated parameter was null but wasn't allowed to.
     *
     * @param objectModel The Map objectModel
     * @param name Request parameter's name
     * @return true if the parameter was validated and the validation
     * returned an error because the parameter was null but wasn't allowd to.
     */
    public static boolean isNull(Map objectModel, String name) {
        return getParamResult(objectModel, name).equals(ValidatorActionResult.ISNULL);
    }
14275#/**
     * Test whether the context's current parameter as validated was null but
     * wasn't allowed to.
     *
     * @param objectModel The Map objectModel
     * @return true if the parameter was validated and the validation
     * returned an error because the parameter was null but wasn't allowd to.
     */
    public boolean isNull(Map objectModel) {
        return isNull(objectModel, current_parameter);
    }
14276#/**
     * Test whether the validated parameter was too small.
     *
     * @param objectModel The Map objectModel
     * @param name Request parameter's name
     * @return true if the parameter was validated and the validation
     * returned an error because either its value or its length was
     * too small.
     */
    public static boolean isTooSmall(Map objectModel, String name) {
        boolean ok = getParamResult(objectModel, name).equals(ValidatorActionResult.TOOSMALL);

        if (!ok) {
            ok = isNull(objectModel, name);
        }

        return ok;
    }
14277#/**
     * Test whether the context's current parameter was too small.
     *
     * @param objectModel The Map objectModel
     * @return true if the parameter was validated and the validation
     * returned an error because either its value or its length was
     * too small.
     */
    public boolean isTooSmall(Map objectModel) {
        return isTooSmall(objectModel, current_parameter);
    }
14278#/**
     * Test whether the validated parameter was too large.
     *
     * @param objectModel The Map objectModel
     * @param name Request parameter's name
     * @return true if the parameter was validated and the validation
     * returned an error because either its value or its length was
     * too large.
     */
    public static boolean isTooLarge(Map objectModel, String name) {
        return (getParamResult(objectModel, name) == ValidatorActionResult.TOOLARGE);
    }
14279#/**
     * Test whether the context's current parameter was too large.
     *
     * @param objectModel The Map objectModel
     * @return true if the parameter was validated and the validation
     * returned an error because either its value or its length was
     * too large.
     */
    public boolean isTooLarge(Map objectModel) {
        return isTooLarge(objectModel, current_parameter);
    }
14280#/**
     * Test whether the validated parameter wasn't matched by the requested
     * regular expression.
     *
     * @param objectModel The Map objectModel
     * @param name Request parameter's name
     * @return true if the parameter was validated and the validation
     * returned an error because its value wasn't matched by the requested
     * regular expression.
     */
    public static boolean isNoMatch(Map objectModel, String name) {
        return getParamResult(objectModel, name).equals(ValidatorActionResult.NOMATCH);
    }
14281#/**
     * Test whether the context's current parameter wasn't matched by the requested
     * regular expression.
     *
     * @param objectModel The Map objectModel
     * @return true if the parameter was validated and the validation
     * returned an error because its value wasn't matched by the requested
     * regular expression.
     */
    public boolean isNoMatch(Map objectModel) {
        return isNoMatch(objectModel, current_parameter);
    }
14282#/**
     * Test whether the validated parameter wasn't validated
     *
     * @param objectModel The Map objectModel
     * @param name Request parameter's name
     * @return true if the parameter was not validated.
     */
    public static boolean isNotPresent(Map objectModel, String name) {
        return getParamResult(objectModel, name).equals(ValidatorActionResult.NOTPRESENT);
    }
14283#/**
     * Test whether the context's current parameter wasn't validated
     *
     * @param objectModel The Map objectModel
     * @return true if the parameter was not validated.
     */
    public boolean isNotPresent(Map objectModel) {
        return isNotPresent(objectModel, current_parameter);
    }
14284#/**
     * Set up the complementary configuration file.  Please note that
     * multiple Actions can share the same configurations.  By using
     * this approach, we can limit the number of config files.
     * Also note that the configuration file does not have to be a file.
     *
     * This is based on the similar named functions in
     * org.apache.cocoon.acting.AbstractComplimentaryConfigurableAction
     * with the addition of reloadable configuration files, reloadable
     * flagg, manager, and logger  parameter.
     *
     * @param descriptor URL of descriptor.xml file @see org.apache.cocoon.acting.AbstractComplimentaryConfigurableAction
     * @param resolver
     * @param reloadable set to <code>true</code> if changes of
     * <code>descriptor</code> should trigger a reload. Note that this
     * only works if <code>Source</code> is able to determine the
     * modification time @see org.apache.cocoon.environment.Source
     * @param logger used to send debug and error messages to
     * @return up-to-date configuration, either (re)loaded or cached.
     */

    protected static Configuration getConfiguration(String descriptor, SourceResolver resolver,
                                                    boolean reloadable, Log logger)
            throws ConfigurationException {

        if (descriptor == null) {
            throw new ConfigurationException("The form descriptor is not set!");
        }

        ConfigurationHelper conf = null;
        synchronized (FormValidatorHelper.configurations) {
            Source source = null;
            try {
                source = resolver.resolveURI(descriptor);
                conf = (ConfigurationHelper) FormValidatorHelper.configurations.get(source.getURI());
                if (conf == null || (reloadable && conf.lastModified != source.getLastModified())) {
                    logger.debug("(Re)Loading " + descriptor);

                    if (conf == null) {
                        conf = new ConfigurationHelper();
                    }

                    SAXConfigurationHandler builder = new SAXConfigurationHandler();
                    SourceUtil.toSAX(source, builder);

                    conf.lastModified = source.getLastModified();
                    conf.configuration = builder.getConfiguration();

                    FormValidatorHelper.cacheConfiguration(source.getURI(), conf);
                } else {
                    logger.debug("Using cached configuration for " + descriptor);
                }
            } catch (Exception e) {
                logger.error("Could not configure Database mapping environment", e);
                throw new ConfigurationException("Error trying to load configurations for resource: " + source.getURI());
            } finally {
                resolver.release(source);
            }
        }

        return conf.configuration;
    }
14285#/**
     * Cache the configuration so that we can use it later.
     */
    private static void cacheConfiguration(String descriptor, ConfigurationHelper conf) {
        synchronized (FormValidatorHelper.configurations) {
            FormValidatorHelper.configurations.put(descriptor, conf);
        }
    }
14286#/**
     * Iterate over a set of configurations and return the one whose
     * name matches the given one.
     *
     * @param conf set of configurations
     * @param name name of configuration
     * @param logger
     * @return specified configuration or <code>null</code> if not found.
     */
    protected static Configuration getConfigurationByName(Configuration[] conf,
                                                          String name,
                                                          Log logger) {
        int j = 0;
        boolean found = false;
        String setname = null;
        for (j = 0; j < conf.length; j++) {
            setname = conf[j].getAttribute("name", "");
            if (name.trim().equals(setname.trim())) {
                found = true;
                break;
            }
        }
        if (!found) {
            logger.debug("FormValidatorHelper.getConfigurationByName: configuration " + name + " not found.");
            return null;
        }
        return conf[j];
    }
14287#/**
     * Get an attribute for a parameter as specified in
     * descriptor.xml.
     *
     * @param descriptor URL of descriptor.xml file @see org.apache.cocoon.acting.AbstractComplimentaryConfigurableAction
     * @param resolver
     * @param reloadable set to <code>true</code> if changes of
     * <code>descriptor</code> should trigger a reload. Note that this
     * only works if <code>Source</code> is able to determine the
     * modification time @see org.apache.cocoon.environment.Source
     * @param logger used to send debug and error messages to
     * @param attribute attribute name
     * @return attribute value or <code>null</code>
     */
    public static String getParameterAttributes(String descriptor,
                                                SourceResolver resolver,
                                                boolean reloadable,
                                                String constraintset,
                                                String parameter,
                                                String attribute,
                                                Log logger) {
        try {
            Configuration conf = getConfiguration(descriptor, resolver, reloadable, logger);
            Configuration[] desc = conf.getChildren("parameter");
            Configuration[] csets = conf.getChildren("constraint-set");

            Configuration cset = getConfigurationByName(csets, constraintset, logger);

            Configuration[] set = cset.getChildren("validate");
            Configuration constraints = getConfigurationByName(set, parameter, logger);
            Configuration descr = getConfigurationByName(desc, parameter, logger);
            return constraints.getAttribute(attribute, descr.getAttribute(attribute, ""));
        } catch (Exception e) {
            logger.debug("FormValidatorHelper.getParameterAttributes Exception " + e);
        }
        
        return "";
    }
14288#/**
     * Get an attribute for the context's current parameter as specified in
     * descriptor.xml.
     *
     * @param attribute attribute name
     * @return attribute value or <code>null</code>
     */
    public String getParameterAttribute(String attribute) {
        return FormValidatorHelper.getParameterAttributes(current_descriptor,
                current_resolver,
                current_reloadable,
                current_constraint_set,
                current_parameter,
                attribute,
                current_logger);
    }
14289#/**
     * Get an attribute for a parameter as specified in
     * descriptor.xml.
     *
     * @param attribute attribute name
     * @return attribute value or <code>null</code>
     */
    public String getParameterAttribute(String parameter, String attribute) {
        return FormValidatorHelper.getParameterAttributes(current_descriptor,
                current_resolver,
                current_reloadable,
                current_constraint_set,
                parameter,
                attribute,
                current_logger);
    }
14290#/**
     * Constructor.
     *
     * @param resolver   For source resolving
     * @param parentURI  The "directory"
     */
    public ModifiableSourceIncludeCacheStorageProxy(SourceResolver resolver,
                                             String         parentURI) {
        this.resolver = resolver;
        this.parentURI= parentURI;
    }
14291#/**
     * Calculate the URI for a child
     * @param uri     Child URI
     * @return String Absolute URI
     */
    private String getURI(String uri) {
        final long hash = HashUtil.hash(uri);
        final StringBuffer buffer = new StringBuffer(this.parentURI);
        buffer.append('/');
        if (hash < 0) {
            buffer.append('M').append(hash * -1);
        } else {
            buffer.append(hash);
        }
        buffer.append(".cxml");
        return buffer.toString();
    }
14292#/**
     * @see IncludeCacheStorageProxy#get(java.lang.String)
     */
    public Serializable get(String uri) {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("WSCProxy: Getting content for " + uri);
        }

        Source child = null;
        Serializable result = null;
        try {
            child = this.resolver.resolveURI(this.getURI(uri));
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("WSCProxy: Resolved to " + child.getURI());
            }

            if (child.exists()) {
                InputStream is = child.getInputStream();
                ObjectInputStream ois = new ObjectInputStream(is);
                result = (Serializable)ois.readObject();
                ois.close();
            }
        } catch (Exception ignore) {
        } finally {
            this.resolver.release( child );
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("WSCProxy: Result for " + uri + " : " + (result == null ? "Not in cache" : "Found"));
        }
        return result;
    }
14293#/**
     * @see IncludeCacheStorageProxy#put(java.lang.String, java.io.Serializable)
     */
    public void put(String uri, Serializable object) 
    throws IOException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("WSCProxy: Storing content for " + uri);
        }

        Source child = null;
        try {
            child = this.resolver.resolveURI(this.getURI(uri));
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("WSCProxy: Resolved to " + child.getURI());
            }

            OutputStream os;
            if (child instanceof ModifiableSource) {
                os = ((ModifiableSource)child).getOutputStream();
            } else {
                throw new IOException("Source " + uri + " is not writeable.");
            }
            ObjectOutputStream oos = new ObjectOutputStream(os);
            oos.writeObject(object);
            oos.flush();
            oos.close();
        } catch (IOException io) {
            throw io;
        } catch (Exception ignore) {
            throw new CascadingIOException("Exception.", ignore);
        } finally {
            this.resolver.release( child );
        }
    }
14294#/**
     * @see IncludeCacheStorageProxy#remove(java.lang.String)
     */
    public void remove(String uri) {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("WSCProxy: Removing content for " + uri);
        }

        Source child = null;
        try {
            child = this.resolver.resolveURI(this.getURI(uri));
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("WSCProxy: Resolved to " + child.getURI());
            }

            if (child instanceof ModifiableSource) {
                ((ModifiableSource) child).delete();
            } else {
                throw new IOException("Source " + uri + " is not writeable.");
            }
        } catch (Exception ignore) {
        } finally {
            this.resolver.release( child );
        }
    }
14295#/**
     * Compare
     */
    public boolean equals(Object object) {
        if (object instanceof ModifiableSourceIncludeCacheStorageProxy) {
            return this.parentURI.equals(((ModifiableSourceIncludeCacheStorageProxy) object).parentURI);
        }
        return false;
    }
14296#/**
     * Generate a hash code
     */
    public int hashCode() {
        return this.parentURI.hashCode();
    }
14297#/**
     * This action starts the preemptive loading
     * It runs forever and is stopped by the {@link DefaultIncludeCacheManager}.
     * @see org.apache.cocoon.acting.Action#act(Redirector, SourceResolver, Map, String, Parameters)
     */
    public Map act(Redirector redirector,
                    SourceResolver resolver,
                    Map objectModel,
                    String source,
                    Parameters parameters)
    throws Exception {
        PreemptiveLoader loader = PreemptiveLoader.getInstance();
        if (!loader.alive) {
            loader.process(resolver);
            return EMPTY_MAP;
        }

        return null;
    }
14298#/**
     * Get the cached content for the given URI.
     * @param uri Absolute URI specifying the content
     * @return Serializable
     */
    Serializable get(String uri);
14299#/**
     * Put the content into the cache for the given URI.
     * @param uri Absolute URI specifying the content
     * @param object The content
     * @throws IOException
     */
    void put(String uri, Serializable object)
    throws IOException;
14300#/**
     * Remove the cached content for the given URI
     * @param uri Absolute URI specifying the content
     */
    void remove(String uri);
14301#/**
     * Constructor
     * @param configuration The parameters configuring this session
     * @param proxy         The proxy used to cache the data
     */
    IncludeCacheManagerSession(Parameters configuration, 
                        IncludeCacheStorageProxy proxy) {
        this.expires = configuration.getParameterAsLong("expires", 0);
        this.purge = configuration.getParameterAsBoolean("purge", false);    
        this.preemptive = configuration.getParameterAsBoolean("preemptive", false);
        this.parallel = configuration.getParameterAsBoolean("parallel", false);
        this.storage = proxy;    
    }
14302#/**
     * Get the used storage proxy
     */
    IncludeCacheStorageProxy getCacheStorageProxy() {
        return this.storage;
    }
14303#/**
     * Get the expiration information
     */
    public long getExpires() {
        return this.expires;
    }
14304#public SourceValidity getExpiresValidity() {
        if ( this.expires > 0 && this.validity == null) {
            this.validity = new ExpiresValidity( this.expires * 1000 ); // milliseconds
        }
        return this.validity;
    }
14305#/**
     * Is the cache purged?
     */
    public boolean isPurging() {
        return this.purge;
    }
14306#/**
     * Do we use preemptive caching?
     */
    public boolean isPreemptive() {
        return this.preemptive;
    }
14307#/**
     * Do we process the includes in parallel?
     */
    public boolean isParallel() {
        return this.parallel;
    }
14308#/**
     * Add another object to the thread list
     * @param uri    The absolute URI
     * @param object The thread
     */
    void add(String uri, Object object) {
        if ( null == this.threadList ) {
            this.threadList = new HashMap(10);
        }
        this.threadList.put(uri, object);
    }
14309#/**
     * Get the thread object.
     * @param uri     The URI
     * @return Object The thread.
     */
    Object get(String uri) {
        if ( null != this.threadList ) {
            return this.threadList.get( uri );
        }
        return null;
    }
14310#/**
     * Turn off/on preemptive caching
     */
    void setPreemptive(boolean value) {
        this.preemptive = value;
    }
14311#/**
     * Lookup a source object and cache it
     * @param uri     Absolute URI
     * @return Source The source obejct
     */
    public Source resolveURI(String uri, SourceResolver resolver) 
    throws IOException {
        Source source = (Source)this.sourceList.get(uri);
        if ( null == source ) {
            source = resolver.resolveURI( uri );
            this.sourceList.put( source.getURI(), source );
        }
        return source;
    }
14312#/**
     * Cleanup
     * @param resolver The source resolver to release cached sources
     */
    void cleanup(SourceResolver resolver) {
        Iterator iter = this.sourceList.values().iterator();
        while ( iter.hasNext() ) {
            final Source source = (Source) iter.next();
            resolver.release( source );   
        }
    }
14313#/**
     * Print a representation of this object
     */
    public String toString() {
        return "CacheManagerSession(" + this.hashCode() + ") -" +
                " expires: " + this.expires +
                " parallel: " + this.parallel + 
                " preemptive: " + this.preemptive +
                " purge: " + this.purge;
    }
14314#/**
     * Constructor
     * @param store  The store for the cached content
     */
    public StoreIncludeCacheStorageProxy(Store store) {
        this.store = store;
    }
14315#/** A string representation for a key */
    private String getKey(String uri) {
        return "DCS:" + uri;
    }
14316#/**
     * @see IncludeCacheStorageProxy#get(java.lang.String)
     */
    public Serializable get(String uri) {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("StoreProxy: Getting content for " + uri);
        }

        Serializable result = (Serializable) this.store.get(getKey(uri));

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("StoreProxy: Result for " + uri + " : " + (result == null ? "Not in cache" : "Found"));
        }
        return result;
    }
14317#/**
     * @see IncludeCacheStorageProxy#put(java.lang.String, java.io.Serializable)
     */
    public void put(String uri, Serializable object) 
    throws IOException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("StoreProxy: Storing content for " + uri);
        }
        this.store.store(getKey(uri), object);
    }
14318#/**
     * @see IncludeCacheStorageProxy#remove(java.lang.String)
     */
    public void remove(String uri) {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("StoreProxy: Removing content for " + uri);
        }
        this.store.remove(getKey(uri));
    }
14319#/**
     * Return singleton.
     *
     * @return PreemptiveLoader
     */
    static PreemptiveLoader getInstance() {
        return INSTANCE;
    }
14320#/**
     * Add a new task
     * @param proxy   The cache to store the content
     * @param uri     The absolute URI to load
     * @param expires The expires information used for the cache
     */
    public void add(IncludeCacheStorageProxy proxy, String uri, long expires) {
        boolean addItem = true;
        List uriList = (List)this.cacheStorageProxyMap.get(proxy);
        if ( null == uriList ) {
             uriList = new ArrayList(50);
             this.cacheStorageProxyMap.put(proxy, uriList);
        } else {
            synchronized (uriList) {
                // nothing to do: uri is alredy in list
               if (uriList.contains(uri)) {
                   addItem = false;
               } 
            }
        }
        if ( addItem ) {
            uriList.add(uri);
            this.loadList.add(new Object[] {proxy, uri, new Long(expires), uriList});
        }

        synchronized (this.cacheStorageProxyMap) {
            this.cacheStorageProxyMap.notify();
        }
    }
14321#/**
     * Start the preemptive loading
     * @param resolver  A source resolver
     */
    public void process(SourceResolver resolver) {
        process(resolver, getLogger());
    }
14322#/**
     * Start the preemptive loading
     * @param resolver  A source resolver
     * @param logger    A logger
     */
    public void process(SourceResolver resolver,
                        Log logger) {
        this.alive = true;
        if (logger.isDebugEnabled()) {
            logger.debug("PreemptiveLoader: Starting preemptive loading");
        }

        while (this.alive) {
            while (this.loadList.size() > 0) {
                Object[] object = (Object[])this.loadList.get(0);
                final String uri = (String)object[1];
                this.loadList.remove(0);
                synchronized (object[3]) {
                    ((List)object[3]).remove(uri);
                }
                
                Source source = null;
                XMLByteStreamCompiler serializer;

                try {
                    if (logger.isDebugEnabled()) {
                        logger.debug("PreemptiveLoader: Loading " + uri);
                    }

                    source = resolver.resolveURI(uri);
                    serializer = new XMLByteStreamCompiler();
                
                    SourceUtil.toSAX(source, serializer);
                
                    SourceValidity[] validities = new SourceValidity[1];
                    validities[0] = new ExpiresValidity(((Long)object[2]).longValue() * 1000); // milliseconds!
                    CachedResponse response = new CachedResponse(validities,
                                                                 (byte[])serializer.getSAXFragment());
                    ((IncludeCacheStorageProxy)object[0]).put(uri, response);
                     
                } catch (Exception ignore) {
                    // all exceptions are ignored!
                } finally {
                    resolver.release( source );
                }
                if (logger.isDebugEnabled()) {
                    logger.debug("PreemptiveLoader: Finished loading " + uri);
                }
            }
            synchronized (this.cacheStorageProxyMap) {
                try {
                    this.cacheStorageProxyMap.wait();
                } catch (InterruptedException e) {
                }
            }
        }
        if (logger.isDebugEnabled()) {
            logger.debug("PreemptiveLoader: Finished preemptive loading");
        }
    }
14323#/**
     * Stop the loading. 
     * The loader stops when all tasks from the queue are processed.
     */
    synchronized public void stop() {
        this.alive = false;
        synchronized (this.cacheStorageProxyMap) {
            this.cacheStorageProxyMap.notify();
        }
    }
14324#/**
     * @see IncludeCacheManager#getSession(org.apache.avalon.framework.parameters.Parameters)
     */
    public IncludeCacheManagerSession getSession(Parameters pars) {
        String sourceURI = pars.getParameter("source", null);
        IncludeCacheManagerSession session;
        if ( null == sourceURI ) {
            session = new IncludeCacheManagerSession(pars, this.defaultCacheStorage);
        } else {
            Source source = null;
            try {
                source = this.resolver.resolveURI(sourceURI);
                IncludeCacheStorageProxy proxy = new ModifiableSourceIncludeCacheStorageProxy(this.resolver, source.getURI());
                session = new IncludeCacheManagerSession(pars, proxy);
            } catch (Exception local) {
                session = new IncludeCacheManagerSession(pars, this.defaultCacheStorage);
                this.getLogger().warn("Error creating writeable source.", local);
            } finally {
                this.resolver.release(source);
            }
        }
        if (session.isPreemptive()) {
            if ( null == this.preemptiveLoaderURI ) {
                this.getLogger().error("Preemptive loading is turned off because the preemptive-loader-url is not configured.");
                session.setPreemptive(false);
            } else {
                if ( !PreemptiveLoader.getInstance().alive ) {

                    if (this.getLogger().isDebugEnabled()) {
                        this.getLogger().debug("Booting preemptive loader: " + this.preemptiveLoaderURI);
                    }
                    PreemptiveBooter thread = new PreemptiveBooter( this.preemptiveLoaderURI );
                    try
                    {
                        final RunnableManager runnableManager = (RunnableManager)this.manager.lookup( RunnableManager.ROLE );
                        runnableManager.execute( thread );
                        this.manager.release( runnableManager );
                    }
                    catch( final ServiceException se )
                    {
                        getLogger().error( "Cannot lookup RunnableManager", se );
                    }
                }
            }
        } 
        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("Creating cache manager session: " + session);
        }
        return session;
    }
14325#/**
     * @see IncludeCacheManager#load(java.lang.String, IncludeCacheManagerSession)
     */
    public String load(String uri, IncludeCacheManagerSession session) throws IOException {
        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("Load " + uri + " for session " + session);
        }
        
        // first make the URI absolute
        if ( uri.indexOf("://") == -1) {
            final Source source = session.resolveURI(uri, this.resolver);
            uri = source.getURI();
        }
        
        // if we are not processing in parallel (or do preemptive)
        // then we don't have to do anything in this method - everything
        // is done in the stream method.
        
        // if we are processing in parallel (and not preemptive) then....
        if ( session.isParallel() && !session.isPreemptive()) {
            
            // first look-up if we have a valid stored response
            IncludeCacheStorageProxy storage = session.getCacheStorageProxy();
            CachedResponse response = (CachedResponse)storage.get(uri);
            if ( null != response) {
                SourceValidity[] validities = response.getValidityObjects();
                
                // if we are valid and do not purging
                if ( !session.isPurging() 
                      && validities[0].isValid() == SourceValidity.VALID) {
                    if (this.getLogger().isDebugEnabled()) {
                        this.getLogger().debug("Using cached response for parallel processing.");
                    }
                    session.add(uri, response.getResponse());
                    return uri;
                } else {
                    // response is not used
                    storage.remove(uri);
                }
            }

            if (this.getLogger().isDebugEnabled()) {
                this.getLogger().debug("Starting parallel thread for loading " + uri);
            }
            // now we start a parallel thread, this thread gets all required avalon components
            // so it does not have to lookup them by itself
            try {
                XMLByteStreamCompiler serializer = new XMLByteStreamCompiler();
                Source source = session.resolveURI(uri, this.resolver);

                LoaderThread loader = new LoaderThread(source, serializer);
                final RunnableManager runnableManager = (RunnableManager)this.manager.lookup( RunnableManager.ROLE );
                session.add(uri, loader);
                runnableManager.execute( new CocoonRunnable(loader) );
                this.manager.release( runnableManager );
                if (this.getLogger().isDebugEnabled()) {
                    this.getLogger().debug("Thread started for " + uri);
                }
            } catch (ServiceException ce) {
                throw new SourceException("Unable to lookup thread pool, RunnableManager, or xml serializer.", ce);
            } catch (Exception e) {
                throw new SourceException("Unable to get pooled thread.", e);
            }
        }
        return uri;
    }
14326#/**
     * @see IncludeCacheManager#stream(java.lang.String, IncludeCacheManagerSession, XMLConsumer)
     */
    public void stream(String uri,
                        IncludeCacheManagerSession session,
                        XMLConsumer handler) 
    throws IOException, SAXException {

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Stream " + uri + " for session " + session);
        }

        // if we are processing in parallel (and not preemptive) then....
        if (session.isParallel() && !session.isPreemptive()) {

            // get either the cached content or the pooled thread
            Object object = session.get(uri);
            if (object == null) {
                // this should never happen!
                throw new SAXException("No pooled thread found for " + uri);
            }
            byte[] result;
            
            // is this a pooled thread?
            if (object instanceof LoaderThread) {
                LoaderThread loader = (LoaderThread)object;
                
                if (this.getLogger().isDebugEnabled()) {
                    this.getLogger().debug("Waiting for pooled thread to finish loading.");
                }

                // wait for it
                loader.join();

                if (this.getLogger().isDebugEnabled()) {
                    this.getLogger().debug("Pooled thread finished loading.");
                }
                
                // did an exception occur? Then reraise it
                if ( null != loader.exception) {
                    if ( loader.exception instanceof SAXException ) {
                        throw (SAXException)loader.exception;
                    } else if (loader.exception instanceof SourceException ) {
                        throw (SourceException)loader.exception;
                    } else if (loader.exception instanceof IOException) {
                        throw (IOException)loader.exception;
                    } else {
                        throw new SAXException("Exception.", loader.exception);
                    }
                }
                
                if (this.getLogger().isDebugEnabled()) {
                    this.getLogger().debug("Streaming from pooled thread.");
                }
                result = loader.content;

                // cache the response (remember preemptive is off)
                if (session.getExpires() > 0) {
                    SourceValidity[] validities = new SourceValidity[1];
                    validities[0] = session.getExpiresValidity();
                    CachedResponse response = new CachedResponse(validities, result);
                    session.getCacheStorageProxy().put(uri, response);
                }
            } else {
                if (this.getLogger().isDebugEnabled()) {
                    this.getLogger().debug("Streaming from cached response.");
                }

                // use the response from the cache
                result = (byte[])object;
            }
            
            // stream the content
            XMLByteStreamInterpreter deserializer = new XMLByteStreamInterpreter();
            deserializer.setConsumer(handler);
            deserializer.deserialize(result);
            return;
            
        } else {
            // we are not processing parallel
            
            // first: test for a cached response
            IncludeCacheStorageProxy storage = session.getCacheStorageProxy();
            CachedResponse response = (CachedResponse)storage.get(uri);
            if ( null != response) {
                SourceValidity[] validities = response.getValidityObjects();
                // if purging is turned off and either the cached response is valid or
                // we are loading preemptive, then use the cached response
                if ( !session.isPurging() 
                      && (session.isPreemptive() || validities[0].isValid() == SourceValidity.VALID)) {

                    // stream the content                    
                    if (this.getLogger().isDebugEnabled()) {
                        this.getLogger().debug("Streaming from cached response.");
                    }
                    XMLByteStreamInterpreter deserializer =  new XMLByteStreamInterpreter();
                    deserializer.setConsumer(handler);
                    deserializer.deserialize(response.getResponse());
                    
                    // load preemptive if the response is not valid
                    if ( session.getExpires() > 0
                         && session.isPreemptive() 
                         && validities[0].isValid() != SourceValidity.VALID) {
                        if (this.getLogger().isDebugEnabled()) {
                            this.getLogger().debug("Add uri to preemptive loader list " + uri);
                        }
                        if (!PreemptiveLoader.getInstance().alive) {
                            this.getLogger().error("Preemptive loader has not started yet.");
                        }
                        PreemptiveLoader.getInstance().add(session.getCacheStorageProxy(), uri, session.getExpires());
                    }
                    return;
 
                } else {
                    // cached response is not valid
                    storage.remove(uri);
                }
            }
        }

        // we are not processing in parallel and have no (valid) cached response
        XMLByteStreamCompiler serializer;
        try {
            final Source source = session.resolveURI(uri, this.resolver);
            
            // stream directly (and cache the response)
            if (this.getLogger().isDebugEnabled()) {
                this.getLogger().debug("Streaming directly from source.");
            }
            if (session.getExpires() > 0) {
                serializer = new XMLByteStreamCompiler();
                XMLTeePipe tee = new XMLTeePipe(handler, serializer);
                
                SourceUtil.toSAX(source, tee);
                
                SourceValidity[] validities = new SourceValidity[1];
                validities[0] = session.getExpiresValidity();
                CachedResponse response = new CachedResponse(validities,
                                                             (byte[])serializer.getSAXFragment());
                session.getCacheStorageProxy().put(uri, response);
            } else {
                SourceUtil.toSAX(source, handler);
            }
            
        } catch (ProcessingException pe) {
            throw new SAXException("ProcessingException", pe);
        }
    }
14327#/**
     * @see IncludeCacheManager#terminateSession(IncludeCacheManagerSession)
     */
    public void terminateSession(IncludeCacheManagerSession session) {
        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("Terminating cache manager session " + session);
        }
        session.cleanup(this.resolver);
    }
14328#/**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
        this.resolver = (SourceResolver)this.manager.lookup(SourceResolver.ROLE);
    }
14329#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        // stop preemptive loader (if running)
        PreemptiveLoader.getInstance().stop();
        if ( null != this.manager ) {
            this.manager.release( this.resolver);
            this.manager.release(this.store);
            this.store = null;
            this.resolver = null;
            this.manager = null;
            this.defaultCacheStorage = null;
        }
    }
14330#/**
     * @see org.apache.avalon.framework.parameters.Parameterizable#parameterize(org.apache.avalon.framework.parameters.Parameters)
     */
    public void parameterize(Parameters parameters) throws ParameterException {
        this.preemptiveLoaderURI = parameters.getParameter("preemptive-loader-url", null);
        if ( null != this.preemptiveLoaderURI 
             && this.preemptiveLoaderURI.indexOf("://") == -1) {
            throw new ParameterException("The preemptive-loader-url must be absolute: " + this.preemptiveLoaderURI);
        }
        final String storeRole = parameters.getParameter("use-store", Store.ROLE);
        try {
            this.store = (Store)this.manager.lookup(storeRole);
        } catch (ServiceException e) {
            throw new ParameterException("Unable to lookup store with role " + storeRole, e);
        }
        this.defaultCacheStorage = new StoreIncludeCacheStorageProxy(this.store);
    }
14331#public LoaderThread(Source source, 
                            XMLByteStreamCompiler serializer) {
            this.source = source;
            this.serializer = serializer;
            this.finished = new CountDown( 1 );
        }
14332#public void run() {
            try {
                SourceUtil.toSAX(this.source, this.serializer);
                this.content = (byte[])this.serializer.getSAXFragment();
            } catch (Exception local) {
                this.exception = local;
            } finally {
                this.finished.release();
            }
        }
14333#void join() {
            try {
                this.finished.acquire();
            } catch ( final InterruptedException ie) {
                // ignore
            }
        }
14334#public PreemptiveBooter(final String uri) {
            this.uri = uri;
        }
14335#public void run() {
            try {
                URL url = new URL(this.uri);
                url.getContent();
            } catch (Exception ignore) {
            }
        }
14336#public LoggingEntityResolver(EntityResolver resolver) {
        this.resolver = resolver;
        dependencies = new HashSet();
    }
14337#public InputSource resolveEntity(String public_id, String system_id) throws SAXException, IOException {
        InputSource input_source = resolver.resolveEntity(public_id, system_id);
        dependencies.add(input_source);
        getLogger().debug("Dependency: " + input_source.getSystemId());
        return input_source;
    }
14338#public Set getDependencies() {
        return Collections.unmodifiableSet(dependencies);
    }
14339#/**
     * Creates new <code>LoggingContentHandler</code> with specified
     * <code>id</code> and destination <code>contentHandler</code>.
     */
    public LoggingContentHandler(String id, ContentHandler contentHandler) {
        this.id = id;
        this.contentHandler = contentHandler;
    }
14340#public void setDocumentLocator(Locator locator) {
        log("setDocumentLocator", "");
        contentHandler.setDocumentLocator(locator);
    }
14341#public void startDocument() throws SAXException {
        log("startDocument", "");
        this.contentHandler.startDocument();
    }
14342#public void endDocument() throws SAXException {
        log("endDocument", "");
        this.contentHandler.endDocument();
    }
14343#public void startPrefixMapping(String prefix, String uri) throws SAXException {
        log("startPrefixMapping", "prefix=" + prefix + ",uri=" + uri);
        this.contentHandler.startPrefixMapping(prefix, uri);
    }
14344#public void endPrefixMapping(String prefix) throws SAXException {
        log("endPrefixMapping", "prefix=" + prefix);
        this.contentHandler.endPrefixMapping(prefix);
    }
14345#public void startElement(String uri, String loc, String raw, Attributes a)
    throws SAXException {
        log("startElement", "uri=" + uri + ",local=" + loc + ",raw=" + raw);
        for (int i = 0; i < a.getLength(); i++) {
            log("            ", Integer.toString(i + 1)
                                + ". uri=" + a.getURI(i)
                                + ",local=" + a.getLocalName(i)
                                + ",qname=" + a.getQName(i)
                                + ",type=" + a.getType(i)
                                + ",value=" + a.getValue(i));
        }
        this.contentHandler.startElement(uri, loc, raw, a);
    }
14346#public void endElement(String uri, String loc, String qname) throws SAXException {
        log("endElement", "uri=" + uri + ",local=" + loc + ",qname=" + qname);
        this.contentHandler.endElement(uri, loc, qname);
    }
14347#public void characters(char ch[], int start, int len) throws SAXException {
        log("characters", new String(ch, start, len));
        this.contentHandler.characters(ch, start, len);
    }
14348#public void ignorableWhitespace(char ch[], int start, int len) throws SAXException {
        log("ignorableWhitespace", new String(ch, start, len));
        this.contentHandler.ignorableWhitespace(ch, start, len);
    }
14349#public void processingInstruction(String target, String data) throws SAXException {
        log("processingInstruction", "target=" + target + ",data=" + data);
        this.contentHandler.processingInstruction(target, data);
    }
14350#public void skippedEntity(String name) throws SAXException {
        log("skippedEntity", "name=" + name);
        this.contentHandler.skippedEntity(name);
    }
14351#private void log(String location, String description) {
        getLogger().debug(id + "[" + location + "] " + description + "\n");
    }
14352#/**
     * Create a new <code>DocumentHandlerWrapper</code> instance.
     */
    public DocumentHandlerWrapper() {
        super();
     }
14353#/**
     * Create a new <code>DocumentHandlerWrapper</code> instance.
     */
    public DocumentHandlerWrapper(DocumentHandler document) {
        this();
        setDocumentHandler(document);
    }
14354#/**
     * Implementation of the recycle method
     */
    public void recycle() {
        this.documentHandler = null;
    }
14355#/**
     * Set the <code>DocumentHandler</code> that will receive XML data.
     *
     * @exception IllegalStateException If the <code>DocumentHandler</code>
     *                                  was already set.
     */
    public void setDocumentHandler(DocumentHandler document)
    throws IllegalStateException {
        if (this.documentHandler!=null) throw new IllegalStateException();
        this.documentHandler=document;
    }
14356#/**
     * Receive an object for locating the origin of SAX document events.
     */
    public void setDocumentLocator (Locator locator) {
        if (this.documentHandler==null) return;
        else this.documentHandler.setDocumentLocator(locator);
    }
14357#/**
     * Receive notification of the beginning of a document.
     */
    public void startDocument ()
    throws SAXException {
        if (this.documentHandler==null)
            throw new SAXException("DocumentHandler not set");
        this.documentHandler.startDocument();
    }
14358#/**
     * Receive notification of the end of a document.
     */
    public void endDocument ()
    throws SAXException {
        if (this.documentHandler==null)
            throw new SAXException("DocumentHandler not set");
        this.documentHandler.endDocument();
    }
14359#/**
     * Begin the scope of a prefix-URI Namespace mapping.
     */
    public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
        this.undecl.addElement(this.namespaces.addDeclaration(prefix,uri));
    }
14360#/**
     * End the scope of a prefix-URI mapping.
     */
    public void endPrefixMapping(String prefix)
    throws SAXException {
        if (namespaces.removeDeclaration(prefix)==null)
            throw new SAXException("Namespace prefix \""+prefix+
                                   "\" never declared");
    }
14361#/**
     * Receive notification of the beginning of an element.
     */
    public void startElement(String uri, String loc, String raw, Attributes a)
    throws SAXException {
        if (this.documentHandler==null)
            throw new SAXException("DocumentHandler not set");
        NamespacesTable.Name name=this.namespaces.resolve(uri,raw,null,loc);
        // Create the AttributeList
        AttributeListImpl a2=new AttributeListImpl();
        // Set the xmlns:...="..." attributes
        if (this.undecl.size()>0) {
            for (int x=0; x<this.undecl.size(); x++) {
                NamespacesTable.Declaration dec=null;
                dec=(NamespacesTable.Declaration)this.undecl.elementAt(x);
                String aname="xmlns";
                if (dec.getPrefix().length()>0) aname="xmlns:"+dec.getPrefix();
                a2.addAttribute(aname,"CDATA",dec.getUri());
            }
            this.undecl.clear();
        }
        // Set the real attributes
        for (int x=0; x<a.getLength(); x++) {
            NamespacesTable.Name aname=namespaces.resolve(a.getURI(x),
                                                          a.getQName(x),
                                                          null,
                                                          a.getLocalName(x));
            a2.addAttribute(aname.getQName(),a.getType(x),a.getValue(x));
        }
        // Call the document handler startElement() method.
        this.documentHandler.startElement(name.getQName(),a2);
    }
14362#/**
     * Receive notification of the end of an element.
     */
    public void endElement(String uri, String loc, String raw)
    throws SAXException {
        if (this.documentHandler==null)
            throw new SAXException("DocumentHandler not set");
        NamespacesTable.Name name=this.namespaces.resolve(uri,raw,null,loc);
        this.documentHandler.endElement(name.getQName());
    }
14363#/**
     * Receive notification of character data.
     */
    public void characters(char ch[], int start, int len)
    throws SAXException {
        if (this.documentHandler==null)
            throw new SAXException("DocumentHandler not set");
        this.documentHandler.characters(ch,start,len);
    }
14364#/**
     * Receive notification of ignorable whitespace in element content.
     */
    public void ignorableWhitespace(char ch[], int start, int len)
    throws SAXException {
        if (this.documentHandler==null)
            throw new SAXException("DocumentHandler not set");
        this.documentHandler.ignorableWhitespace(ch,start,len);
    }
14365#/**
     * Receive notification of a processing instruction.
     */
    public void processingInstruction(String target, String data)
    throws SAXException {
        if (this.documentHandler==null)
            throw new SAXException("DocumentHandler not set");
        this.documentHandler.processingInstruction(target,data);
    }
14366#public StringXMLizable(final String data) {
        this.data = data;
    }
14367#private Context getContext() throws SAXException {
        if (context.get() == null) {
            context.set(new Context());
        }
        return (Context) context.get();
    }
14368#public void toSAX(ContentHandler contentHandler) throws SAXException {
        final SAXParser parser = getContext().parser;
        parser.getXMLReader().setContentHandler(contentHandler);
        InputSource is = new InputSource(new StringReader(data));
        try {
            parser.getXMLReader().parse(is);
        } catch (IOException e) {
            throw new SAXException(e);
        }
    }
14369#Context() throws SAXException {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parser = null;
            try {
                parser = parserFactory.newSAXParser();
            } catch (ParserConfigurationException e) {
                throw new SAXException("Error creating SAX parser.", e);
            }
        }
14370#/**
     * No-arg constructor. Requires an explicit call to
     * <code>setConsumer()</code>.
     */
    public RedundantNamespacesFilter() {
        // Nothing
    }
14371#/**
     * Creates a filter directly linked to its consumer
     *
     * @param consumer
     *            the SAX stream consumer
     */
    public RedundantNamespacesFilter(XMLConsumer consumer) {
        setConsumer(consumer);
    }
14372#public void startPrefixMapping(String prefix, String uri) throws SAXException {
        // Just declare it: duplicate declarations are ignorede by NamespacesTable
        ns.addDeclaration(prefix, uri);
    }
14373#public void startElement(String uri, String loc, String raw, Attributes a) throws SAXException {
        // Declare namespaces for this scope, if any
        ns.enterScope(this.contentHandler);
        super.startElement(uri, loc, raw, a);
    }
14374#public void endElement(String uri, String loc, String raw) throws SAXException {
        super.endElement(uri, loc, raw);
        ns.leaveScope(this.contentHandler);
    }
14375#public void endPrefixMapping(String prefix) throws SAXException {
        ns.removeDeclaration(prefix);
    }
14376#/**
     * Create a new <code>DocumentHandlerAdapter</code> instance.
     */
    public DocumentHandlerAdapter() {
        super();
    }
14377#/**
     * Create a new <code>DocumentHandlerAdapter</code> instance.
     */
    public DocumentHandlerAdapter(XMLConsumer consumer) {
        this();
        super.setConsumer(consumer);
    }
14378#/**
     * Create a new <code>DocumentHandlerAdapter</code> instance.
     */
    public DocumentHandlerAdapter(ContentHandler content) {
        this();
        super.setContentHandler(content);
    }
14379#/**
     * Receive an object for locating the origin of SAX document events.
     */
    public void setDocumentLocator (Locator locator) {
        if (super.contentHandler==null) return;
        else super.contentHandler.setDocumentLocator(locator);
    }
14380#/**
     * Receive notification of the beginning of a document.
     */
    public void startDocument ()
        throws SAXException {
        if (super.contentHandler==null)
            throw new SAXException("ContentHandler not set");
        super.contentHandler.startDocument();
    }
14381#/**
     * Receive notification of the end of a document.
     */
    public void endDocument ()
        throws SAXException {
        if (super.contentHandler==null)
            throw new SAXException("ContentHandler not set");
        super.contentHandler.endDocument();
    }
14382#/**
     * Receive notification of the beginning of an element.
     */
    public void startElement (String name, AttributeList a)
        throws SAXException {
        if (super.contentHandler==null)
            throw new SAXException("ContentHandler not set");
        // Check for namespace declarations (two loops because we're not sure
        // about attribute ordering.
        AttributesImpl a2=new AttributesImpl();
        Vector nslist=new Vector();
        for (int x=0; x<a.getLength(); x++) {
            String att=a.getName(x);
            String uri=a.getValue(x);
            if (att.equals("xmlns") || att.startsWith("xmlns:")) {
                String pre="";
                if (att.length()>5) pre=att.substring(6);
                this.namespaces.addDeclaration(pre,uri);
                nslist.addElement(pre);
                super.contentHandler.startPrefixMapping(pre,uri);
            }
        }
        if (nslist.size()>0) this.stackedNS.put(new Integer(this.stack),nslist);
        // Resolve the element namespaced name
        NamespacesTable.Name w=this.namespaces.resolve(null,name,null,null);
        // Second loop through attributes to fill AttributesImpl
        for (int x=0; x<a.getLength(); x++) {
            String att=a.getName(x);
            if (att.equals("xmlns") || att.startsWith("xmlns:")) continue;
            // We have something different from a namespace declaration
            NamespacesTable.Name k=this.namespaces.resolve(null,att,null,null);
            String val=a.getValue(x);
            String typ=a.getType(x);
            String uri=k.getPrefix().length()==0?"":k.getUri();
            a2.addAttribute(uri,k.getLocalName(),k.getQName(),typ,val);
        }
        // Notify the contentHandler
        super.contentHandler.startElement(w.getUri(),w.getLocalName(),
                                          w.getQName(),a2);
        // Forward on the stack
        this.stack++;
    }
14383#/**
     * Receive notification of the end of an element.
     */
    public void endElement (String name)
        throws SAXException {
        if (super.contentHandler==null)
            throw new SAXException("ContentHandler not set");
            // Get back on the stack
            this.stack--;
        // Notify the contentHandler
        NamespacesTable.Name w=this.namespaces.resolve(null,name,null,null);
        super.contentHandler.endElement(w.getUri(),w.getLocalName(),
                                        w.getQName());
        // Undeclare namespaces
        Vector nslist=(Vector)this.stackedNS.remove(new Integer(this.stack));
        if (nslist==null) return;
        if (nslist.size()==0) return;
        Enumeration e=nslist.elements();
        while (e.hasMoreElements()) {
            String prefix=(String)e.nextElement();
            NamespacesTable.Declaration d=namespaces.removeDeclaration(prefix);
            super.contentHandler.endPrefixMapping(d.getPrefix());
        }
    }
14384#/**
     * Receive notification of character data.
     */
    public void characters (char ch[], int start, int len)
        throws SAXException {
        if (super.contentHandler==null)
            throw new SAXException("ContentHandler not set");
        super.contentHandler.characters(ch,start,len);
    }
14385#/**
     * Receive notification of ignorable whitespace in element content.
     */
    public void ignorableWhitespace (char ch[], int start, int len)
        throws SAXException {
        if (super.contentHandler==null)
            throw new SAXException("ContentHandler not set");
        super.contentHandler.ignorableWhitespace(ch,start,len);
    }
14386#/**
     * Receive notification of a processing instruction.
     */
    public void processingInstruction (String target, String data)
        throws SAXException {
        if (super.contentHandler==null)
            throw new SAXException("ContentHandler not set");
        super.contentHandler.processingInstruction(target,data);
    }
14387#/**
     * Creates empty SaxBuffer
     */
    public ParamSaxBuffer() {
    }
14388#/**
     * Creates copy of another SaxBuffer
     */
    public ParamSaxBuffer(SaxBuffer saxBuffer) {
        super(saxBuffer);
    }
14389#/**
     * Parses text and extracts <code>{name}</code> parameters for later
     * substitution.
     */
    public void characters(char ch[], int start, int length) throws SAXException {

        if (previous_ch != null) {
            // prepend char's from previous_ch to ch
            char[] buf = new char[length + previous_ch.length];
            System.arraycopy(previous_ch, 0, buf, 0, previous_ch.length);
            System.arraycopy(ch, start, buf, previous_ch.length, length);
            ch = buf;
            start = 0;
            length += previous_ch.length;
            previous_ch = null;
        }

        final int end = start + length;
        for (int i = start; i < end; i++) {
            if (ch[i] == '{') {
                // Send any collected characters so far
                if (i > start) {
                    addBit(new Characters(ch, start, i - start));
                }

                // Find closing brace, and construct parameter name
                StringBuffer name = new StringBuffer();
                int j = i + 1;
                for (; j < end; j++) {
                    if (ch[j] == '}') {
                        break;
                    }
                    name.append(ch[j]);
                }
                if (j == end) {
                    // '{' without a closing '}'
                    // save char's from '{' in previous_ch in case the following call to characters()
                    // provides the '}'
                    previous_ch = new char[end - i];
                    System.arraycopy(ch, i, previous_ch, 0, end - i);
                    return;
                }
                addBit(new Parameter(name.toString()));

                // Continue processing
                i = j;
                start = j + 1;
                continue;
            }
        }

        // Send any tailing characters
        if (start < end) {
            addBit(new Characters(ch, start, end - start));
        }
    }
14390#public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
        flushChars();
        super.endElement(namespaceURI, localName, qName);
    }
14391#public void ignorableWhitespace(char ch[], int start, int length) throws SAXException {
        flushChars();
        super.ignorableWhitespace(ch, start, length);
    }
14392#public void processingInstruction(String target, String data) throws SAXException {
        flushChars();
        super.processingInstruction(target, data);
    }
14393#public void startDocument() throws SAXException {
        flushChars();
        super.startDocument();
    }
14394#public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {
        flushChars();
        super.startElement(namespaceURI, localName, qName, atts);
    }
14395#public void endDocument() throws SAXException {
        flushChars();
        super.endDocument();
    }
14396#public void comment(char ch[], int start, int length) throws SAXException {
        flushChars();
        super.comment(ch, start, length);
    }
14397#public void endDTD() throws SAXException {
        flushChars();
        super.endDTD();
    }
14398#public void startDTD(String name, String publicId, String systemId) throws SAXException {
        flushChars();
        super.startDTD(name, publicId, systemId);
    }
14399#private void flushChars() {
        // Handle saved chars (in case we had a '{' with no matching '}').
        if (previous_ch != null) {
            addBit(new Characters(previous_ch, 0, previous_ch.length));
            previous_ch = null;
        }
    }
14400#/**
     * @param parameters map containing SaxBuffers
     */
    public void toSAX(ContentHandler contentHandler, Map parameters) throws SAXException {
        for (Iterator i = bits(); i.hasNext();) {
            SaxBit saxbit = (SaxBit)i.next();
            if (saxbit instanceof Parameter) {
                ((Parameter)saxbit).send(contentHandler, parameters);
            } else {
                saxbit.send(contentHandler);
            }
        }
    }
14401#/**
     * @param parameters map containing SaxBuffers
     */
    public String toString(Map parameters) throws SAXException {
        final StringBuffer buffer = new StringBuffer();
        for (Iterator i = bits(); i.hasNext();) {
            SaxBit saxbit = (SaxBit)i.next();
            if (saxbit instanceof Parameter) {
                ((Parameter)saxbit).toString(buffer, parameters);
            } else if (saxbit instanceof Characters) {
                ((Characters) saxbit).toString(buffer);
            }
        }
        return buffer.toString();
    }
14402#public Parameter(String name) {
            this.name = name;
        }
14403#public void send(ContentHandler contentHandler) {
        }
14404#public void send(ContentHandler contentHandler, Map parameters) throws SAXException {
            SaxBuffer value = (SaxBuffer)parameters.get(name);
            if (value != null) {
                value.toSAX(contentHandler);
            }
        }
14405#public void toString(StringBuffer result, Map parameters) throws SAXException {
            String value = (String)parameters.get(name);
            if (value != null) {
                result.append(value);
            }
        }
14406#public void dump(Writer writer) throws IOException {
            writer.write("[Parameter] name=" + name);
        }
14407#/**
     * Generates SAX events representing the object's state by serializing the
     * result of <code>toDOM()</code>.
     */
    public void toSAX(ContentHandler handler) throws SAXException {
        // The ServiceManager is unknown here : use JAXP to create a document
        DocumentBuilder builder;
        try {
            builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            throw new SAXException("Couldn't get a DocumentBuilder", e);
        }

        Document doc = builder.newDocument();

        // Create a DocumentFragment that will hold the results of toDOM()
        // (which can create several top-level elements)
        Node df = doc.createDocumentFragment();

        // Build the DOM representation of this object
        try {
            toDOM(df);
        } catch(Exception e) {
            throw new SAXException("Exception while converting object to DOM", e);
        }

        // Stream the document fragment
        handler.startDocument();
        new DOMStreamer(handler).stream(df);
        handler.endDocument();
    }
14408#/**
     * Create a new XMLMulticaster with two consumers
     */
    public XMLMulticaster(XMLConsumer firstConsumer, XMLConsumer secondConsumer) {
        this.contentHandlerList = new ContentHandler[] {firstConsumer, secondConsumer};
        this.lexicalHandlerList = new LexicalHandler[] {firstConsumer, secondConsumer};
    }
14409#/**
     * Create a new XMLMulticaster from two contentHandler/lexicalHandler pairs
     */
    public XMLMulticaster(ContentHandler firstContentHandler,
                          LexicalHandler firstLexicalHandler,
                          ContentHandler secondContentHandler,
                          LexicalHandler secondLexicalHandler) {
        this.contentHandlerList = new ContentHandler[] {firstContentHandler, secondContentHandler};
        this.lexicalHandlerList = new LexicalHandler[] {firstLexicalHandler, secondLexicalHandler};
    }
14410#public XMLMulticaster(ContentHandler[] chList,
                          LexicalHandler[] lhList) {
        this.contentHandlerList = chList;
        this.lexicalHandlerList = lhList;
    }
14411#public void startDocument() throws SAXException {
        for(int i=0; i<this.contentHandlerList.length; i++) {
            this.contentHandlerList[i].startDocument();
        }
    }
14412#public void endDocument() throws SAXException {
        for(int i=0; i<this.contentHandlerList.length; i++) {
                this.contentHandlerList[i].endDocument();
        }
    }
14413#public void startPrefixMapping(java.lang.String prefix, java.lang.String uri) throws SAXException {
        for(int i=0; i<this.contentHandlerList.length; i++)
                this.contentHandlerList[i].startPrefixMapping(prefix, uri);
    }
14414#public void endPrefixMapping(java.lang.String prefix) throws SAXException {
        for(int i=0; i<this.contentHandlerList.length; i++)
                this.contentHandlerList[i].endPrefixMapping(prefix);
    }
14415#public void startElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName, Attributes atts) throws SAXException {
        for(int i=0; i<this.contentHandlerList.length; i++)
                this.contentHandlerList[i].startElement(namespaceURI, localName, qName, atts);
    }
14416#public void endElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName) throws SAXException {
        for(int i=0; i<this.contentHandlerList.length; i++)
                this.contentHandlerList[i].endElement(namespaceURI, localName, qName);
    }
14417#public void characters(char[] ch, int start, int length) throws SAXException {
        for(int i=0; i<this.contentHandlerList.length; i++)
                this.contentHandlerList[i].characters(ch, start, length);
    }
14418#public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        for(int i=0; i<this.contentHandlerList.length; i++)
                this.contentHandlerList[i].ignorableWhitespace(ch, start, length);
    }
14419#public void processingInstruction(java.lang.String target, java.lang.String data) throws SAXException {
        for(int i=0; i<this.contentHandlerList.length; i++)
                this.contentHandlerList[i].processingInstruction(target, data);
    }
14420#public void setDocumentLocator(Locator locator) {
        for(int i=0; i<this.contentHandlerList.length; i++)
                this.contentHandlerList[i].setDocumentLocator(locator);
    }
14421#public void skippedEntity(java.lang.String name) throws SAXException {
        for(int i=0; i<this.contentHandlerList.length; i++)
                this.contentHandlerList[i].skippedEntity(name);
    }
14422#public void startDTD(String name, String public_id, String system_id)
                        throws SAXException {
        for(int i=0; i<this.lexicalHandlerList.length; i++)
            if (this.lexicalHandlerList[i] != null)
                this.lexicalHandlerList[i].startDTD(name, public_id, system_id);
    }
14423#public void endDTD() throws SAXException {
        for(int i=0; i<this.lexicalHandlerList.length; i++)
            if (this.lexicalHandlerList[i] != null)
                this.lexicalHandlerList[i].endDTD();
    }
14424#public void startEntity(String name) throws SAXException {
        for(int i=0; i<this.lexicalHandlerList.length; i++)
            if (this.lexicalHandlerList[i] != null)
                 this.lexicalHandlerList[i].startEntity(name);
    }
14425#public void endEntity(String name) throws SAXException {
        for(int i=0; i<this.lexicalHandlerList.length; i++)
            if (this.lexicalHandlerList[i] != null)
                this.lexicalHandlerList[i].endEntity(name);
    }
14426#public void startCDATA() throws SAXException {
        for(int i=0; i<this.lexicalHandlerList.length; i++)
            if (this.lexicalHandlerList[i] != null)
                this.lexicalHandlerList[i].startCDATA();
    }
14427#public void endCDATA() throws SAXException {
        for(int i=0; i<this.lexicalHandlerList.length; i++)
            if (this.lexicalHandlerList[i] != null)
                this.lexicalHandlerList[i].endCDATA();
    }
14428#public void comment(char ary[], int start, int length)
                        throws SAXException {
        for(int i=0; i<this.lexicalHandlerList.length; i++)
            if (this.lexicalHandlerList[i] != null)
                this.lexicalHandlerList[i].comment(ary, start, length);
    }
14429#/**
     * Create a new Document object.
     */
    Document newDocument();
14430#/**
     * Create a new Document object with a specified DOCTYPE.
     */
    Document newDocument(String name);
14431#/**
     * Create a new Document object with a specified DOCTYPE, public ID and
     * system ID.
     */
    Document newDocument(String name, String publicId, String systemId);
14432#Expression getExpression(String language, String expression) throws ExpressionException;
14433#Expression getExpression(String expression) throws ExpressionException;
14434#Expression compile(String language, String expression)
            throws ExpressionException;
14435#String getLanguage();
14436#String getExpression();
14437#Object evaluate(ObjectModel objectModel)
            throws ExpressionException;
14438#Iterator iterate(ObjectModel objectModel)
            throws ExpressionException;
14439#void assign(ObjectModel objectModel, Object value)
            throws ExpressionException;
14440#/*
     * This method is added to handle that JXPath have two access methods
     * getValue and getNode, where getNode gives direct access to the object
     * while getValue might do some conversion of the object. I would prefer to
     * get rid of the getNode method, but have not yet figured out how to get
     * work in JXTG
     */
    Object getNode(ObjectModel objectModel) throws ExpressionException;
14441#void setProperty(String property, Object value);
14442#/**
     * Construct a new <code>ExpressionException</code> instance.
     *
     * @param message the detail message for this exception.
     */
    public ExpressionException(String message) {
        super(message);
    }
14443#/**
     * Construct a new <code>ExpressionException</code> instance.
     *
     * @param message the detail message for this exception.
     * @param cause the root cause of the exception.
     */
    public ExpressionException(String message, Throwable cause) {
        super(message);
        super.initCause(cause);
    }
14444#Object getObject();
14445#/**
     * @return a {@link MultiMap} that contains all stored values in all context in LIFO-compliant order.
     *         Returned {@link MultiMap} is {@link org.apache.commons.collections.Unmodifiable}.
     */
    MultiMap getAll();
14446#/**
     * Works exactly the same way as {@link Map#put(Object, Object)} but previous value associated to <code>key</code>
     * is not lost in a case {@link #markLocalContext()} was called before. The previous value is stored and can be
     * recovered by calling {@link #markLocalContext()}.
     */
    Object put(Object key, Object value);
14447#/**
     * @see #put(Object, Object)
     */
    void putAll(Map mapToCopy);
14448#/**
     * Marks new local context. Such mark is useful to do a clean up of entries.
     */
    void markLocalContext();
14449#/**
     * Cleans up entries put to ObjectModel since last {@link #markLocalContext()} call.
     */
    void cleanupLocalContext();
14450#/**
     * Puts object at certain <code>path</code>. Each segment of path is separated by "/" symbol. This method
     * supports only traversing through objects implementing {@link Map} interface. If certain segment does not exist it
     * will be created automatically.
     *
     * @param path
     *            where the <code>value</code> should be put at
     * @param value that is going to be put
     */
    void putAt(String path, Object value);
14451#/**
     * <p>
     * Copies properties (both static and dynamic) of current context bean to the Object Model. The method is useful
     * when you want, for example, to access properties of context bean in JEXL expression and omit
     * <code>contextBean.</code> part.
     * </p>
     *
     * @see org.apache.commons.jxpath.JXPathBeanInfo.isDynamic() for description of static and dynamic properties
     */
    void fillContext();
14452#/**
     * <p>Sets parent object model so newly created instance can inherit values from parent but cannot modify it.</p>
     *
     * @param parentObjectModel
     */
    void setParent(ObjectModel parentObjectModel);
14453#/**
     * Compile a boolean expression. Returns either a Compiled Expression or a
     * Boolean literal.
     */
    Subst compileBoolean(String expr, String msg, Locator location) throws SAXException;
14454#/**
     * Compile an integer expression. Returns either a Compiled Expression or an
     * Integer literal.
     */
    Subst compileInt(String expr, String msg, Locator location) throws SAXException;
14455#/**
     * Compile an expression.
     */
    Subst compileExpr(String expr, String msg, Locator location) throws SAXParseException;
14456#/**
     * Parse a set of expressions spaced with literals
     */
    List parseSubstitutions(Reader in, String msg, Locator location) throws SAXParseException;
14457#Object getCompiledExpression();
14458#Object getNode(ObjectModel objectModel) throws Exception;
14459#Iterator getIterator(ObjectModel objectModel) throws Exception;
14460#Boolean getBooleanValue(ObjectModel objectModel) throws Exception;
14461#String getStringValue(ObjectModel objectModel) throws Exception;
14462#Number getNumberValue(ObjectModel objectModel) throws Exception;
14463#int getIntValue(ObjectModel objectModel) throws Exception;
14464#Object getValue(ObjectModel objectModel) throws Exception;
14465#void setLenient(Boolean lenient);
14466#String getRaw();
14467#public AbstractExpression(String language, String expression) {
        this.language = language;
        this.expression = expression;
    }
14468#public String getExpression() {
        return this.expression;
    }
14469#public String getLanguage() {
        return this.language;
    }
14470#public void setProperty(String property, Object value) {
        // has no properties
    }
14471#public Expression getExpression(String language, String expression) throws ExpressionException {
        if (!this.expressionCompilers.containsKey(language))
            throw new ExpressionException("Can't find a compiler for " + language);
        ExpressionCompiler compiler = (ExpressionCompiler) this.expressionCompilers.get(language);
        return compiler.compile(language, expression);
    }
14472#public Expression getExpression(String expression) throws ExpressionException {
        String language = DEFAULT_EXPRESSION_LANGUAGE;
        int end = expression.indexOf(':');
        if (end != -1) {
            language = expression.substring(0, end);
            expression = expression.substring(end + 1);
        }
        return getExpression(language, expression);
    }
14473#public Map getExpressionCompilers() {
        return expressionCompilers;
    }
14474#public void setExpressionCompilers(Map expressionCompilers) {
        this.expressionCompilers = expressionCompilers;
    }
14475#public static Scriptable createRhinoScope() {
        final Scriptable rootScope;

        Context ctx = Context.enter();
        try {
            rootScope = ctx.initStandardObjects(null);
        } finally {
            Context.exit();
        }
        return rootScope;
    }
14476#/**
     * @see org.apache.cocoon.el.ExpressionCompiler#compile(java.lang.String, java.lang.String)
     */
    public Expression compile(String language, String expression) throws ExpressionException {
        return new JavaScriptExpression(language, expression, rootScope);
    }
14477#public Scriptable getRootScope() {
        return rootScope;
    }
14478#public void setRootScope(Scriptable rootScope) {
        this.rootScope = rootScope;
    }
14479#public JavaScriptExpression(String language, String expression, Scriptable rootScope) {
        super(language, expression);
        this.rootScope = rootScope;
        compile();
    }
14480#private void compile() {
        Context ctx = Context.enter();
        try {
            this.script = ctx.compileString(getExpression(), "", 1, null);
        } finally {
            Context.exit();
        }
    }
14481#public Object evaluate(ObjectModel objectModel) throws ExpressionException {
        Context ctx = Context.enter();
        try {
            Scriptable scope = ctx.newObject(getScope(rootScope));

            // Populate the scope
            Iterator iter = objectModel.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry entry = (Map.Entry) iter.next();
                String key = (String) entry.getKey();
                Object value = entry.getValue();
                scope.put(key, scope, Context.toObject(value, scope));
            }

            Object result = this.script.exec(ctx, scope);
            return unwrap(result);
        } finally {
            Context.exit();
        }
    }
14482#public Iterator iterate(ObjectModel objectModel) throws ExpressionException {
        Object result = evaluate(objectModel);
        if (result == null) {
            return EMPTY_ITER;
        }

        if (this.introspector == null) {
            introspector = new JSIntrospector();
        }

        Iterator iter;
        try {
            iter = introspector.getIterator(result, new Info("Unknown", 0, 0));
        } catch (Exception e) {
            throw new ExpressionException("Couldn't get an iterator from expression " + getExpression(), e);
        }

        if (iter == null) {
            iter = EMPTY_ITER;
        }

        return iter;
    }
14483#public void assign(ObjectModel objectModel, Object value) throws ExpressionException {
        throw new UnsupportedOperationException("assignment not implemented for javascript expressions");
    }
14484#public Object getNode(ObjectModel objectModel) throws ExpressionException {
        return evaluate(objectModel);
    }
14485#private Scriptable getScope(Scriptable rootScope) {
        Scriptable scope;
        Context ctx = Context.enter();
        try {
            scope = ctx.newObject(rootScope);
            scope.setPrototype(rootScope);
            scope.setParentScope(null);
        } catch (Exception e) {
            throw new RuntimeException("Exception", e);
        } finally {
            Context.exit();
        }
        return scope;
    }
14486#/**
     * Unwrap a Rhino object (getting the raw java object) and convert undefined to null
     */
    private Object unwrap(Object obj) {
        if (obj instanceof Wrapper) {
            obj = ((Wrapper)obj).unwrap();
        } else if (obj == Undefined.instance) {
            obj = null;
        }
        return obj;
    }
14487#public JexlExpression(String language, String expression) throws ExpressionException {
        super(language, expression);
        try {
            this.compiledExpression = org.apache.commons.jexl.ExpressionFactory.createExpression(expression);
        } catch (Exception e) {
            throw new ExpressionException("Couldn't create expression " + expression, e);
        }
    }
14488#public Object evaluate(ObjectModel objectModel) throws ExpressionException {
        try {
            return this.compiledExpression.evaluate(new ContextAdapter(objectModel));
        } catch (Exception e) {
            throw new ExpressionException("Couldn't evaluate expression " + getExpression(), e);
        }
    }
14489#public Iterator iterate(ObjectModel objectModel) throws ExpressionException {
        Iterator iter = null;
        Object result = evaluate(objectModel);
        if (result != null) {
            /*
             * The Info object is supposed to contain the script location where
             * the expression is invoked and use that in a warning log message
             * if no iterator can be generated. This info is not available in
             * the expression object and might not be relevant either as it can
             * be used from a non script situation.
             */
            try {
                iter = Introspector.getUberspect().getIterator(result, new Info("Unknown", 0, 0));
            } catch (Exception e) {
                throw new ExpressionException("Couldn't get an iterator from expression " + getExpression(), e);
            }
        }
        if (iter == null) {
            iter = EMPTY_ITER;
        }
        return iter;
    }
14490#public void assign(ObjectModel objectModel, Object value) throws ExpressionException {
        throw new UnsupportedOperationException("Assign is not yet implemented for Jexl");
    }
14491#public Object getNode(ObjectModel objectModel) throws ExpressionException {
        return evaluate(objectModel);
    }
14492#public ContextAdapter(Map objectModel) {
            this.objectModel = objectModel;
        }
14493#public Map getVars() {
            return this.objectModel;
        }
14494#public void setVars(Map map) {
            this.objectModel = map;
        }
14495#/**
     * @see org.apache.cocoon.el.ExpressionCompiler#compile(java.lang.String, java.lang.String)
     */
    public Expression compile(String language, String expression) throws ExpressionException {
        return new JexlExpression(language, expression);
    }
14496#public Iterator getIterator(Object obj, Info i) throws Exception {
        if (!(obj instanceof Scriptable)) {
            // support Enumeration
            /*
               Booth Enumeration and Iterator are supported in
               Uberspect. The only difference is that they emit a
               rather long warning message to commons logging, telling
               that Enumerations and Iterator not are resettable and
               cannot be reused.
            */
            if (obj instanceof Enumeration) {
                final Enumeration e = (Enumeration)obj;
                return new Iterator() {

                        public boolean hasNext() {
                            return e.hasMoreElements();
                        }

                        public Object next() {
                            return e.nextElement();
                        }

                        public void remove() {
                            // no action
                        }

                    };
            }
            if (obj instanceof Iterator) {
                // support Iterator
                return (Iterator)obj;
            }
            return super.getIterator(obj, i);
        }
        if (obj instanceof NativeArray) {
            return new NativeArrayIterator((NativeArray)obj);
        }
        return new ScriptableIterator((Scriptable)obj);
    }
14497#public VelMethod getMethod(Object obj, String methodName, Object[] args, Info i) throws Exception {
        return !(obj instanceof Scriptable) ?
                super.getMethod(obj, methodName, args, i) : new JSMethod((Scriptable)obj, methodName);
    }
14498#public VelPropertyGet getPropertyGet(Object obj, String identifier, Info i) throws Exception {
        return !(obj instanceof Scriptable) ?
                super.getPropertyGet(obj, identifier, i) : new JSPropertyGet((Scriptable)obj, identifier);
    }
14499#public VelPropertySet getPropertySet(Object obj, String identifier, Object arg, Info i) throws Exception {
        return !(obj instanceof Scriptable) ?
                super.getPropertySet(obj, identifier, arg, i) : new JSPropertySet((Scriptable)obj, identifier);
    }
14500#private static Object unwrap(Object result) {
        if (result == Undefined.instance || result == Scriptable.NOT_FOUND) {
            return null;
        }

        if (!(result instanceof NativeJavaClass)) {
            Object value;
            while (result instanceof Wrapper) {
                value = ((Wrapper) result).unwrap();
                if (value == result) {
                    break;
                }

                result = value;
            }
        }

        return result;
    }
14501#public JSMethod(Scriptable scope, String name) {
            this.scope = scope;
            this.name = name;
        }
14502#public Object invoke(Object thisArg, Object[] args) throws Exception {
            Context cx = Context.enter();
            try {
                Object result;
                Scriptable thisObj = !(thisArg instanceof Scriptable) ?
                        Context.toObject(thisArg, scope) : (Scriptable)thisArg;
                result = ScriptableObject.getProperty(thisObj, name);
                Object[] newArgs = null;
                if (args != null) {
                    newArgs = new Object[args.length];
                    int len = args.length;
                    for (int i = 0; i < len; i++) {
                        newArgs[i] = args[i];
                        if (args[i] != null &&
                            !(args[i] instanceof Number) &&
                            !(args[i] instanceof Boolean) &&
                            !(args[i] instanceof String) &&
                            !(args[i] instanceof Scriptable)) {
                            newArgs[i] = Context.toObject(args[i], scope);
                        }
                    }
                }
                result = ScriptRuntime.call(cx, result, thisObj, newArgs, scope);

                return unwrap(result);
            } catch (JavaScriptException e) {
                throw new java.lang.reflect.InvocationTargetException(e);
            } finally {
                Context.exit();
            }
        }
14503#public boolean isCacheable() {
            return false;
        }
14504#public String getMethodName() {
            return name;
        }
14505#public Class getReturnType() {
            return Object.class;
        }
14506#public JSPropertyGet(Scriptable scope, String name) {
            this.scope = scope;
            this.name = name;
        }
14507#public Object invoke(Object thisArg) throws Exception {
            Context cx = Context.enter();
            try {
                Scriptable thisObj = !(thisArg instanceof Scriptable) ?
                        Context.toObject(thisArg, scope) : (Scriptable)thisArg;
                Object result = ScriptableObject.getProperty(thisObj, name);
                if (result == Scriptable.NOT_FOUND) {
                    result = ScriptableObject.getProperty(thisObj, "get" + StringUtils.capitalize(name));
                    if (result != Scriptable.NOT_FOUND && result instanceof Function) {
                        try {
                            result = ((Function)result).call(
                                    cx, ScriptableObject.getTopLevelScope(thisObj), thisObj, new Object[] {});
                        } catch (JavaScriptException exc) {
                            exc.printStackTrace();
                            result = null;
                        }
                    }
                }

                return unwrap(result);
            } finally {
                Context.exit();
            }
        }
14508#public boolean isCacheable() {
            return false;
        }
14509#public String getMethodName() {
            return name;
        }
14510#public JSPropertySet(Scriptable scope, String name) {
            this.scope = scope;
            this.name = name;
        }
14511#public Object invoke(Object thisArg, Object rhs) throws Exception {
            Context.enter();
            try {
                Scriptable thisObj;
                Object arg = rhs;
                if (!(thisArg instanceof Scriptable)) {
                    thisObj = Context.toObject(thisArg, scope);
                } else {
                    thisObj = (Scriptable)thisArg;
                }
                if (arg != null &&
                    !(arg instanceof Number) &&
                    !(arg instanceof Boolean) &&
                    !(arg instanceof String) &&
                    !(arg instanceof Scriptable)) {
                    arg = Context.toObject(arg, scope);
                }
                ScriptableObject.putProperty(thisObj, name, arg);
                return rhs;
            } finally {
                Context.exit();
            }
        }
14512#public boolean isCacheable() {
            return false;
        }
14513#public String getMethodName() {
            return name;
        }
14514#public NativeArrayIterator(NativeArray arr) {
            this.arr = arr;
            this.index = 0;
        }
14515#public boolean hasNext() {
            return index < (int) arr.getLength();
        }
14516#public Object next() {
            Context.enter();
            try {
                Object result = arr.get(index++, arr);

                return unwrap(result);
            } finally {
                Context.exit();
            }
        }
14517#public void remove() {
            arr.delete(index);
        }
14518#public ScriptableIterator(Scriptable scope) {
            this.scope = scope;
            this.ids = scope.getIds();
            this.index = 0;
        }
14519#public boolean hasNext() {
            return index < ids.length;
        }
14520#public Object next() {
            Context.enter();
            try {
                Object result = ScriptableObject.getProperty(scope, ids[index++].toString());

                return unwrap(result);
            } finally {
                Context.exit();
            }
        }
14521#public void remove() {
            Context.enter();
            try {
                scope.delete(ids[index].toString());
            } finally {
                Context.exit();
            }
        }
14522#public NamespacesTablePointer(NamespacesTable namespaces) {
        super(null);
        this.namespaces = namespaces;
    }
14523#public String getNamespaceURI(String prefix) {
        return namespaces.getUri(prefix);
    }
14524#protected String getDefaultNamespaceURI() {
        return namespaces.getUri("");
    }
14525#public NodeIterator namespaceIterator() {
        return null;
    }
14526#//-------------------------------------------------------------------------
    // Dummy implementation of abstract methods
    //-------------------------------------------------------------------------

    public boolean isLeaf() {
        return true;
    }
14527#public boolean isCollection() {
        return false;
    }
14528#public int getLength() {
        return 0;
    }
14529#public QName getName() {
        return null;
    }
14530#public Object getBaseValue() {
        return null;
    }
14531#public Object getImmediateNode() {
        return null;
    }
14532#public void setValue(Object value) {
        // ignore
    }
14533#public int compareChildNodePointers(NodePointer arg0, NodePointer arg1) {
        return -1;
    }
14534#public JXPathExpression(String language, String expression)
        throws ExpressionException {
        this.language = language;
        this.expression = expression;
        this.compiledExpression = JXPathContext.compile(expression);
    }
14535#public Object evaluate(ObjectModel objectModel)
        throws ExpressionException{
        return this.compiledExpression.getValue(getContext(objectModel));
    }
14536#public Iterator iterate(ObjectModel objectModel)
        throws ExpressionException {
        final JXPathContext jxpathContext = getContext(objectModel);
        Object val =
            this.compiledExpression.getPointer(jxpathContext, this.expression).getNode();
        // FIXME: workaround for JXPath bug
        if (val instanceof NativeArray)
            return new JSIntrospector.NativeArrayIterator((NativeArray) val);
        else
            return new Iterator() {
                    Iterator iter =
                        compiledExpression.iteratePointers(jxpathContext);
                    
                    public boolean hasNext() {
                        return iter.hasNext();
                    }
                    
                    public Object next() {
                        return ((Pointer)iter.next()).getNode();
                    }
                    
                    public void remove() {
                        iter.remove();
                    }
                };
    }
14537#public void assign(ObjectModel objectModel, Object value)
        throws ExpressionException {
        this.compiledExpression.setValue(getContext(objectModel), value);
    }
14538#public String getExpression() {
        return this.expression;
    }
14539#public String getLanguage() {
        return this.language;
    }
14540#public void setProperty(String property, Object value) {
        if (LENIENT.equals(property))
            this.lenient = ((Boolean)value).booleanValue();
    }
14541#// Hack: try to prevent JXPath from converting result to a String
    public Object getNode(ObjectModel objectModel) throws ExpressionException {
        Iterator iter =
            this.compiledExpression.iteratePointers(getContext(objectModel));
        if (iter.hasNext()) {
            Pointer first = (Pointer)iter.next();
            if (iter.hasNext()) {
                List result = new LinkedList();
                result.add(first.getNode());
                boolean dom = (first.getNode() instanceof Node);
                while (iter.hasNext()) {
                    Object obj = ((Pointer)iter.next()).getNode();
                    dom = dom && (obj instanceof Node);
                    result.add(obj);
                }
                Object[] arr;
                if (dom) {
                    arr = new Node[result.size()];
                } else {
                    arr = new Object[result.size()];
                }
                result.toArray(arr);
                return arr;
            }
            return first.getNode();                    
        }
        return null;
    }
14542#private JXPathContext getContext(ObjectModel objectModel) {
        // This could be made more efficient by caching the
        // JXPathContext within the Context object.
        
        JXPathContext jxobjectModel = JXPathContext.newContext(objectModel.get(ObjectModel.CONTEXTBEAN));
        jxobjectModel.setVariables(new VariableAdapter(objectModel));
        jxobjectModel.setLenient(this.lenient);
        jxobjectModel.setNamespaceContextPointer(new NamespacesTablePointer((NamespacesTable)objectModel.get(ObjectModel.NAMESPACE)));
        return jxobjectModel;
    }
14543#public VariableAdapter(ObjectModel objectModel) {
            this.objectModel = objectModel;
        }
14544#public void declareVariable(String name, Object value) {
            this.objectModel.put(name, value);
        }
14545#public Object getVariable(String name) {
            return this.objectModel.get(name);
        }
14546#public boolean isDeclaredVariable(String name) {
            return this.objectModel.containsKey(name);
        }
14547#public void undeclareVariable(String name) {
            throw new UnsupportedOperationException("Operation undeclareVariable is not supported");
        }
14548#public Expression compile(String language, String expression)
        throws ExpressionException{
        return new JXPathExpression(language, expression);
    }
14549#//FIXME: This method is duplicated in PackagesEntryObjectModelProvider
    private Scriptable getScope() {
        Context ctx = Context.enter();
        try {
            // Create it if never used up to now
            if (rootScope == null) {
                rootScope = ctx.initStandardObjects(null);
            }
            try {
                Scriptable scope = ctx.newObject(rootScope);
                scope.setPrototype(rootScope);
                scope.setParentScope(null);
                return scope;
            } catch (Exception e) {
                throw new RuntimeException("Exception", e);
            }
        } finally {
            Context.exit();
        }
    }
14550#public Object getObject() {
        Object javaPackage;
        Context.enter();
        try {
           javaPackage = ScriptableObject.getProperty( getScope(), "java" );
        } finally {
            Context.exit();
        }
        return javaPackage;
    }
14551#public Scriptable getRootScope() {
        return rootScope;
    }
14552#public void setRootScope(Scriptable rootScope) {
        this.rootScope = rootScope;
    }
14553#//FIXME: This method is duplicated in JavaEntryObjectModelProvider
    private Scriptable getScope() {
        Context ctx = Context.enter();
        try {
            // Create it if never used up to now
            if (rootScope == null) {
                rootScope = ctx.initStandardObjects(null);
            }
            try {
                Scriptable scope = ctx.newObject(rootScope);
                scope.setPrototype(rootScope);
                scope.setParentScope(null);
                return scope;
            } catch (Exception e) {
                throw new RuntimeException("Exception", e);
            }
        } finally {
            Context.exit();
        }
    }
14554#public Object getObject() {
        Scriptable newPackages;
        Context.enter();
        try {
            final String JAVA_PACKAGE = "JavaPackage";
            ClassLoader cl = Thread.currentThread().getContextClassLoader();
            // FIXME - NativeJavaPackage is an internal class which we should not use
            newPackages = new NativeJavaPackage( "", cl );
            newPackages.setParentScope( getScope() );
            newPackages.setPrototype( ScriptableObject.getClassPrototype(   getScope(),
                                                                            JAVA_PACKAGE ) );
            //objectModel.put( "Packages", newPackages );
            //objectModel.put( "java", ScriptableObject.getProperty( getScope(), "java" ) );
        } finally {
            Context.exit();
        }
        return newPackages;
    }
14555#public Scriptable getRootScope() {
        return rootScope;
    }
14556#public void setRootScope(Scriptable rootScope) {
        this.rootScope = rootScope;
    }
14557#public ObjectModelImpl() {
        singleValueMap = new HashMap();
        //FIXME: Not sure if this makes sense
        //super.map = UnmodifiableMap.decorate(singleValueMap);
        super.map = singleValueMap;
        localContexts = new ArrayStack();
        multiValueMap = MultiValueMap.decorate(new HashMap(), StackReversedIteration.class);
        multiValueMapForLocated = MultiValueMap.decorate(new HashMap(), StackReversedIteration.class);
    }
14558#public Object get(Object key) {
        //FIXME: This should be done more elegantly
        if ("this".equals(key)) {
            return this;
        }

        return super.get(key);
    }
14559#public MultiMap getAll() {
        return UnmodifiableMultiMap.decorate(multiValueMap);
    }
14560#public Object put(Object key, Object value) {
        modified = true;
        if (!localContexts.empty()) {
            ((ArrayStack) localContexts.peek()).push(new DefaultKeyValue(key, value));
        }

        singleValueMap.put(key, value);
        multiValueMap.put(key, value);

        return value;
    }
14561#public void putAll(Map mapToCopy) {
        modified = true;
        if (!localContexts.empty()) {
            ArrayStack entries = (ArrayStack)localContexts.peek();
            for (Iterator keysIterator = mapToCopy.keySet().iterator(); keysIterator.hasNext();) {
                Object key = keysIterator.next();
                entries.push(new DefaultKeyValue(key, mapToCopy.get(key)));
            }
        }

        singleValueMap.putAll(mapToCopy);
        multiValueMap.putAll(mapToCopy);
    }
14562#/**
     * Locates map at given path
     * @param path where Map can be found
     * @param createIfNeeded indicates if map(s) should be created if no corresponding found
     * @return located Map or null if <code>createIfNeeded</code> is false and Map cannot be found
     */
    private Map locateMapAt(String path, boolean createIfNeeded) {
        if (path.lastIndexOf(SEGMENT_SEPARATOR) == -1) {
            return this;
        }

        Map map = this;
        int segmentBegin = 0;
        int segmentEnd = path.indexOf(SEGMENT_SEPARATOR);
        while (segmentEnd != -1) {
            String key = path.substring(segmentBegin, segmentEnd);
            if (map.containsKey(key)) {
                Object obj = map.get(key);
                if (!(obj instanceof Map)) {
                    throw new ClassCastException("Object at path " + path.substring(0, segmentEnd) + "is not a Map");
                }

                map = (Map)obj;
            } else {
                if (!createIfNeeded) {
                    return null;
                }

                Map newMap = new HashMap();
                map.put(key, newMap);
                map = newMap;
            }
            segmentBegin = segmentEnd + 1;
            segmentEnd = path.indexOf(SEGMENT_SEPARATOR, segmentBegin);
        }

        return map;
    }
14563#public void putAt(String path, Object value) {
        if (path == null) {
            throw new NullPointerException("Path cannot be null.");
        }
        if (path.length() == 0) {
            throw new IllegalArgumentException("Path cannot be empty");
        }

        Map map = locateMapAt(path, true);
        String key = path.substring(path.lastIndexOf(SEGMENT_SEPARATOR) + 1, path.length());
        if (!localContexts.empty()) {
            ((ArrayStack) localContexts.peek()).push(new PathValue(path, value));
        }
        map.put(key, value);
    }
14564#private void removeAt(String path, Object value) {
        if (path == null) {
            throw new NullPointerException("Path cannot be null.");
        }
        if (path.length() == 0) {
            throw new IllegalArgumentException("Path cannot be empty");
        }

        Map map = locateMapAt(path, false);
        String key = path.substring(path.lastIndexOf(SEGMENT_SEPARATOR) + 1, path.length());
        if (map == null) {
            return;
        }

        multiValueMapForLocated.remove(key, value);
        if (multiValueMap.containsKey(key)) {
            map.put(key, ((StackReversedIteration) multiValueMap.get(key)).peek());
        } else {
            map.remove(key);
        }
    }
14565#public void cleanupLocalContext() {
        if (localContexts.empty()) {
            throw new IllegalStateException("Local contexts stack is empty");
        }

        ArrayStack removeEntries = (ArrayStack)localContexts.pop();
        while (!removeEntries.isEmpty()) {
            if (removeEntries.peek() instanceof PathValue) {
                PathValue entry = (PathValue)removeEntries.pop();
                removeAt(entry.getPath(), entry.getValue());
            } else {
                KeyValue entry = (KeyValue)removeEntries.pop();
                Object key = entry.getKey();
                Object value = entry.getValue();

                multiValueMap.remove(key, value);
                if (multiValueMap.containsKey(key)) {
                    singleValueMap.put(key, ((StackReversedIteration) multiValueMap.get(key)).peek());
                } else {
                    singleValueMap.remove(key);
                }
            }
        }
    }
14566#public void markLocalContext() {
        localContexts.push(new ArrayStack());
    }
14567#public Map getInitialEntries() {
        return initialEntries;
    }
14568#public void setInitialEntries(Map initialEntries) {
        if (this.initialEntries != null) {
            throw new IllegalStateException("Object Model has initial entries set already.");
        }

        this.initialEntries = initialEntries;
        for (Iterator keysIterator = initialEntries.keySet().iterator(); keysIterator.hasNext(); ) {
            Object key = keysIterator.next();
            put(key, ((ObjectModelProvider)initialEntries.get(key)).getObject());
        }

        this.modified = false;
    }
14569#public void fillContext() {
        // Hack: I use jxpath to populate the context object's properties
        // in the jexl context
        Object contextObject = get(CONTEXTBEAN);
        if (contextObject == null) {
            //nothing to do
            return;
        }

        // FIXME Exception Handling
        final JXPathBeanInfo bi =
            JXPathIntrospector.getBeanInfo(contextObject.getClass());
        if (bi.isDynamic()) {
            Class cl = bi.getDynamicPropertyHandlerClass();
            try {
                DynamicPropertyHandler h =
                    (DynamicPropertyHandler) cl.newInstance();
                String[] result = h.getPropertyNames(contextObject);
                int len = result.length;
                for (int i = 0; i < len; i++) {
                    try {
                        put(result[i], h.getProperty(contextObject, result[i]));
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            PropertyDescriptor[] props =  bi.getPropertyDescriptors();
            int len = props.length;
            for (int i = 0; i < len; i++) {
                try {
                    Method read = props[i].getReadMethod();
                    if (read != null) {
                        put(props[i].getName(),
                            read.invoke(contextObject, null));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
14570#/* (non-Javadoc)
     * @see ObjectModel#setParent(ObjectModel)
     */
    public void setParent(ObjectModel parentObjectModel) {
        if (this.modified) {
            throw new IllegalStateException("Setting parent may occur only if Object Model is empty.");
        }

        singleValueMap.putAll(parentObjectModel);
        multiValueMap.putAll(parentObjectModel.getAll());
    }
14571#public Iterator iterator() {
            return new ReverseListIterator(this);
        }
14572#public ListIterator listIterator() {
            throw new UnsupportedOperationException();
        }
14573#public PathValue(String path, Object value) {
            this.path = path;
            this.value = value;
        }
14574#public String getPath() {
            return this.path;
        }
14575#public Object getValue() {
            return this.value;
        }
14576#public static MultiMap decorate(MultiMap map) {
        if (map instanceof UnmodifiableMultiMap)
            return map;
        return new UnmodifiableMultiMap(map);
    }
14577#private UnmodifiableMultiMap(MultiMap map) {
        super(map);
    }
14578#/* (non-Javadoc)
     * @see org.apache.commons.collections.MultiMap#values()
     */
    public Collection values() {
        Collection coll = super.values();
        return UnmodifiableCollection.decorate(coll);
    }
14579#/* (non-Javadoc)
     * @see java.util.Map#entrySet()
     */
    public Set entrySet() {
        Set set = super.entrySet();
        return UnmodifiableEntrySet.decorate(set);
    }
14580#/* (non-Javadoc)
     * @see java.util.Map#keySet()
     */
    public Set keySet() {
        Set set = super.keySet();
        return UnmodifiableSet.decorate(set);
    }
14581#/* (non-Javadoc)
     * @see org.apache.commons.collections.IterableMap#mapIterator()
     */
    public MapIterator mapIterator() {
        if (map instanceof IterableMap) {
            MapIterator it = ((IterableMap) map).mapIterator();
            return UnmodifiableMapIterator.decorate(it);
        } else {
            MapIterator it = new EntrySetMapIterator(map);
            return UnmodifiableMapIterator.decorate(it);
        }
    }
14582#//-----------------------------------------------------------------------
    public void clear() {
        throw new UnsupportedOperationException();
    }
14583#public Object put(Object key, Object value) {
        throw new UnsupportedOperationException();
    }
14584#public void putAll(Map mapToCopy) {
        throw new UnsupportedOperationException();
    }
14585#public Object remove(Object key) {
        throw new UnsupportedOperationException();
    }
14586#public Object remove(Object key, Object item) {
        throw new UnsupportedOperationException();
    }
14587#/**
     * @see AbstractStringTemplateParser#parseSubstitutions(java.io.Reader)
     */
    protected List parseSubstitutions(Reader in) throws Exception {
        LinkedList substitutions = new LinkedList();
        StringBuffer buf = new StringBuffer();

        int ch;
        boolean inExpr = false;
        String lang = null;
        top: while ((ch = in.read()) != -1) {
            // column++;
            char c = (char) ch;
            processChar: while (true) {
                if (inExpr) {
                    if (c == '\\') {
                        ch = in.read();
                        buf.append(ch == -1 ? '\\' : (char) ch);
                    } else if (c == '}') {
                        String str = buf.toString();
                        substitutions.add(compile(str, lang));
                        buf.setLength(0);
                        inExpr = false;
                    } else {
                        buf.append(c);
                    }
                } else if (c == '$' || c == '#' || c == '@') {
                    ch = in.read();
                    if (ch == '{') {
                        lang = (c == '#') ? JXPATH : ((c == '$') ? JEXL : JAVASCRIPT);
                        inExpr = true;
                        if (buf.length() > 0) {
                            substitutions.add(new Literal(buf.toString()));
                            buf.setLength(0);
                        }
                        continue top;
                    }
                    buf.append(c);
                    if (ch != -1) {
                        c = (char) ch;
                        continue processChar;
                    }
                } else {
                    buf.append(c);
                }
                break;
            }
        }

        if (inExpr) {
            throw new Exception("Unterminated {");
        }

        if (buf.length() > 0) {
            substitutions.add(new Literal(buf.toString()));
        }

        return substitutions;
    }
14588#public Literal(String val) {
        this.value = val;
        this.charValue = val.toCharArray();
    }
14589#public Literal(Integer val) {
        this.value = val;
        this.charValue = val.toString().toCharArray();
    }
14590#public Literal(Boolean val) {
        this.value = val;
        this.charValue = val.toString().toCharArray();
    }
14591#public char[] getCharArray() {
        return charValue;
    }
14592#public void setLenient(Boolean lenient) {
        //ignore
    }
14593#public Object getValue(ObjectModel objectModel) throws Exception {
        return value;
    }
14594#public int getIntValue(ObjectModel objectModel) throws Exception {
        return value instanceof Integer ? ((Integer)value).intValue() : Integer.parseInt(getStringValue(objectModel));
    }
14595#public Number getNumberValue(ObjectModel objectModel) throws Exception {
        throw new UnsupportedOperationException();
    }
14596#public String getStringValue(ObjectModel objectModel) throws Exception {
        return value.toString();
    }
14597#public Boolean getBooleanValue(ObjectModel objectModel) throws Exception {
        throw new UnsupportedOperationException();
    }
14598#public Iterator getIterator(ObjectModel objectModel) throws Exception {
        throw new UnsupportedOperationException();
    }
14599#public Object getNode(ObjectModel objectModel) throws Exception {
        return value;
    }
14600#public Object getCompiledExpression() {
        throw new UnsupportedOperationException();
    }
14601#public String getRaw() {
        return value.toString();
    }
14602#/**
     * @see AbstractStringTemplateParser#parseSubstitutions(Reader)
     */
    protected List parseSubstitutions(Reader in) throws Exception {
        LinkedList substitutions = new LinkedList();
        StringBuffer buf = new StringBuffer();

        int ch;
        boolean inExpr = false;
        top: while ((ch = in.read()) != -1) {
            // column++;
            char c = (char) ch;
            processChar: while (true) {
                if (inExpr) {
                    if (c == '\\') {
                        ch = in.read();
                        buf.append(ch == -1 ? '\\' : (char) ch);
                    } else if (c == '}') {
                        String str = buf.toString();
                        substitutions.add(compile(str));
                        buf.setLength(0);
                        inExpr = false;
                    } else {
                        buf.append(c);
                    }
                } else if (c == '{') {
                    ch = in.read();
                    if (ch != '{') {
                        inExpr = true;
                        if (buf.length() > 0) {
                            substitutions.add(new Literal(buf.toString()));
                            buf.setLength(0);
                        }
                        buf.append((char) ch);
                        continue top;
                    }
                    buf.append(c);
                    if (ch != -1) {
                        c = (char) ch;
                        continue processChar;
                    }
                } else {
                    buf.append(c);
                }
                break;
            }
        }

        if (inExpr) {
            throw new Exception("Unterminated {");
        }

        if (buf.length() > 0) {
            substitutions.add(new Literal(buf.toString()));
        }

        return substitutions;
    }
14603#public JXTExpression(String raw, Object expr) {
        this.raw = raw;
        this.compiledExpression = expr;
    }
14604#public Object getCompiledExpression() {
        return compiledExpression;
    }
14605#public void setCompiledExpression(Object compiledExpression) {
        this.compiledExpression = compiledExpression;
    }
14606#public String getRaw() {
        return raw;
    }
14607#// Geting the value of the expression in various forms

    // Hack: try to prevent JXPath from converting result to a String
    public Object getNode(ObjectModel objectModel) throws Exception {
        Object compiled = getCompiledExpression();
        if (compiled instanceof Expression) {
            return ((Expression) compiled).getNode(objectModel);
        }

        return getRaw();
    }
14608#public Iterator getIterator(ObjectModel objectModel) throws Exception {
        Iterator iter;
        if (getCompiledExpression() != null || getRaw() != null) {
            if (getCompiledExpression() instanceof Expression) {
                iter = ((Expression) this.getCompiledExpression()).iterate(objectModel);
            } else {
                // literal value
                iter = new Iterator() {
                    Object val = this;

                    public boolean hasNext() {
                        return val != null;
                    }

                    public Object next() {
                        Object res = val;
                        if (res != null ) {
                            val = null;
                            return res;
                        }
                        throw new NoSuchElementException();
                    }

                    public void remove() {
                        // EMPTY
                    }
                };
            }
        } else {
            iter = NULL_ITER;
        }

        return iter;
    }
14609#public Object getValue(ObjectModel objectModel) throws Exception {
        Object compiled = getCompiledExpression();
        if (compiled != null) {
            if (compiled instanceof Expression) {
                return ((Expression) compiled).evaluate(objectModel);
            }

            return compiled;
        }

        return getRaw();
    }
14610#//
    // FIXME getXXXValue methods are all inconsistent. Is there a reason for this?
    //

    public Boolean getBooleanValue(ObjectModel objectModel) throws Exception {
        Object res = getValue(objectModel);
        return res instanceof Boolean ? (Boolean) res : null;
    }
14611#public String getStringValue(ObjectModel objectModel) throws Exception {
        Object res = getValue(objectModel);
        if (res != null) {
            return res.toString();
        }

        if (getCompiledExpression() == null) {
            return getRaw();
        }

        return null;
    }
14612#public Number getNumberValue(ObjectModel objectModel) throws Exception {
        Object res = getValue(objectModel);
        if (res instanceof Number) {
            return (Number) res;
        }

        if (res != null) {
            return Double.valueOf(res.toString());
        }

        return null;
    }
14613#public int getIntValue(ObjectModel objectModel) throws Exception {
        Object res = getValue(objectModel);
        return res instanceof Number ? ((Number) res).intValue() : 0;
    }
14614#public void setLenient(Boolean lenient) {
        if (this.compiledExpression instanceof Expression) {
            //TODO: hack! bases on particular expression implementation.
            ((Expression) this.compiledExpression).setProperty(JXPathExpression.LENIENT, lenient);
        }
    }
14615#public ExpressionFactory getExpressionFactory() {
        return expressionFactory;
    }
14616#public void setExpressionFactory(ExpressionFactory expressionFactory) {
        this.expressionFactory = expressionFactory;
    }
14617#protected Subst compile(final String expression) throws Exception {
        return new JXTExpression(expression, this.expressionFactory.getExpression(expression));
    }
14618#protected Subst compile(final String expression, String language) throws Exception {
        return new JXTExpression(expression, this.expressionFactory.getExpression(language, expression));
    }
14619#/**
     * @see org.apache.cocoon.el.parsing.StringTemplateParser#compileBoolean(String, String, Locator)
     */
    public Subst compileBoolean(String val, String msg, Locator location) throws SAXException {
        Subst res = compileExpr(val, msg, location);
        if (res instanceof Literal) {
            res = new Literal(Boolean.valueOf(res.getRaw()));
        }

        return res;
    }
14620#/**
     * @see org.apache.cocoon.el.parsing.StringTemplateParser#compileInt(String, String, Locator)
     */
    public Subst compileInt(String val, String msg, Locator location) throws SAXException {
        Subst res = compileExpr(val, msg, location);
        if (res instanceof Literal) {
            res = new Literal(Integer.valueOf(res.getRaw()));
        }

        return res;
    }
14621#/**
     * @see org.apache.cocoon.el.parsing.StringTemplateParser#compileExpr(String, String, Locator)
     */
    public Subst compileExpr(String inStr, String errorPrefix, Locator location) throws SAXParseException {
        if (inStr == null) {
            return null;
        }

        StringReader in = new StringReader(inStr.trim());
        List substitutions = parseSubstitutions(in, errorPrefix, location);
        if (substitutions.size() == 0 || !(substitutions.get(0) instanceof JXTExpression)) {
            return new Literal(inStr);
        }

        return (JXTExpression) substitutions.get(0);
    }
14622#/**
     * @see org.apache.cocoon.el.parsing.StringTemplateParser#parseSubstitutions(Reader, String, Locator)
     */
    public List parseSubstitutions(Reader in, String errorPrefix, Locator location) throws SAXParseException {
        try {
            return parseSubstitutions(in);
        } catch (Exception e) {
            throw new SAXParseException(errorPrefix + e.getMessage(), location, e);
        }
    }
14623#protected abstract List parseSubstitutions(Reader in) throws Exception;
14624#public Substitutions(StringTemplateParser stringTemplateParser, Locator location, String stringTemplate) throws SAXException {
        this(stringTemplateParser, location, new StringReader(stringTemplate));
    }
14625#public Substitutions(StringTemplateParser stringTemplateParser, Locator location, char[] chars, int start, int length)
            throws SAXException {
        this(stringTemplateParser, location, new CharArrayReader(chars, start, length));
    }
14626#private Substitutions(StringTemplateParser stringTemplateParser, Locator location, Reader in) throws SAXException {
        this.substitutions = stringTemplateParser.parseSubstitutions(in, "", location);
        this.hasSubstitutions = !substitutions.isEmpty();
    }
14627#public boolean hasSubstitutions() {
        return this.hasSubstitutions;
    }
14628#public Iterator iterator() {
        return this.substitutions.iterator();
    }
14629#public int size() {
        return this.substitutions.size();
    }
14630#public Object get(int pos) {
        return this.substitutions.get(pos);
    }
14631#public String toString(Locator location, ObjectModel objectModel) throws SAXException {
        StringBuffer buf = new StringBuffer();

        Iterator i = iterator();
        while (i.hasNext()) {
            Subst subst = (Subst) i.next();

            Object val;
            try {
                val = subst.getValue(objectModel);
            } catch (Exception e) {
                throw new SAXParseException(e.getMessage(), location, e);
            //FIXME: Don't catch java.lang.Error
            //} catch (Error err) {
            //    throw new SAXParseException(err.getMessage(), location, new ErrorHolder(err));
            }

            if (val != null) {
                buf.append(val.toString());
            }
        }

        return buf.toString();
    }
14632#/**
     * Construct a new <code>ProcessingException</code> instance.
     */
    public ProcessingException(String message) {
        super(message);
    }
14633#/**
     * Creates a new <code>ProcessingException</code> instance.
     *
     * @param ex an <code>Exception</code> value
     */
    public ProcessingException(Exception ex) {
        super(ex.getMessage(), ex);
    }
14634#/**
     * Construct a new <code>ProcessingException</code> that references
     * a parent Exception.
     */
    public ProcessingException(String message, Throwable t) {
        super(message, t);
    }
14635#/**
     * Construct a new <code>ProcessingException</code> that has an associated location.
     */
    public ProcessingException(String message, Location location) {
        super(message, location);
    }
14636#/**
     * Construct a new <code>ProcessingException</code> that has a parent exception
     * and an associated location.
     * <p>
     * This constructor is protected to enforce the use of {@link #throwLocated(String, Throwable, Location)}
     * which limits exception nesting as far as possible.
     */
    protected ProcessingException(String message, Throwable t, Location location) {
        super(message, t, location);
    }
14637#/**
     * Throw a located exception given an existing exception and the location where
     * this exception was catched.
     * <p>
     * If the exception is already a <code>ProcessingException</code> or a {@link LocatedRuntimeException},
     * the location is added to the original exception's location chain and the original exception
     * is rethrown (<code>description</code> is ignored) to limit exception nesting. Otherwise, a new
     * <code>ProcessingException</code> is thrown, wrapping the original exception.
     * <p>
     * Note: this method returns an exception as a convenience if you want to keep the <code>throw</code>
     * semantics in the caller code, i.e. write<br>
     * <code>&nbsp;&nbsp;throw ProcessingException.throwLocated(...);</code><br>
     * instead of<br>
     * <code>&nbsp;&nbsp;ProcessingException.throwLocated(...);</code><br>
     * <code>&nbsp;&nbsp;return;</code>
     * 
     * @param message a message (can be <code>null</code>)
     * @param thr the original exception (can be <code>null</code>)
     * @param location the location (can be <code>null</code>)
     * @return a (fake) located exception
     * @throws ProcessingException or <code>LocatedRuntimeException</code>
     */
    public static ProcessingException throwLocated(String message, Throwable thr, Location location) throws ProcessingException {
        if (thr instanceof ProcessingException) {
            ProcessingException pe = (ProcessingException)thr;
            pe.addLocation(location);
            throw pe;

        } else if (thr instanceof LocatedRuntimeException) {
            LocatedRuntimeException re = (LocatedRuntimeException)thr;
            re.addLocation(location);
            // Rethrow
            throw re;
        }
        
        throw new ProcessingException(message, thr, location);
    }
14638#/**
     * Throw a located exception given an existing exception and the locations where
     * this exception was catched.
     * <p>
     * If the exception is already a <code>ProcessingException</code> or a {@link LocatedRuntimeException},
     * the locations are added to the original exception's location chain and the original exception
     * is rethrown (<code>description</code> is ignored) to limit exception nesting. Otherwise, a new
     * <code>ProcessingException</code> is thrown, wrapping the original exception.
     * <p>
     * Note: this method returns an exception as a convenience if you want to keep the <code>throw</code>
     * semantics in the caller code, i.e. write<br>
     * <code>&nbsp;&nbsp;throw ProcessingException.throwLocated(...);</code><br>
     * instead of<br>
     * <code>&nbsp;&nbsp;ProcessingException.throwLocated(...);</code><br>
     * <code>&nbsp;&nbsp;return;</code>
     * 
     * @param message a message (can be <code>null</code>)
     * @param thr the original exception (can be <code>null</code>)
     * @param locations the locations (can be <code>null</code>)
     * @return a (fake) located exception
     * @throws ProcessingException or <code>LocatedRuntimeException</code>
     */
    public static ProcessingException throwLocated(String message, Throwable thr, List locations) throws ProcessingException {
        MultiLocatable multiloc;
        if (thr instanceof ProcessingException) {
            multiloc = (ProcessingException)thr;
        } else if (thr instanceof LocatedRuntimeException) {
            multiloc = (LocatedRuntimeException)thr;
        } else {
            multiloc = new ProcessingException(message, thr);
        }
        
        if (locations != null) {
            for (int i = 0; i < locations.size(); i++) {
                multiloc.addLocation((Location)locations.get(i));
            }
        }
        
        if (multiloc instanceof LocatedRuntimeException) {
            throw (LocatedRuntimeException)multiloc;
        } else {
            throw (ProcessingException)multiloc;
        }
    }
14639#/**
     * Construct a new <code>ProcessingException</code> instance.
     */
    public CascadingIOException(String message) {
        this(message, null);
    }
14640#/**
     * Creates a new <code>ProcessingException</code> instance.
     *
     * @param ex an <code>Exception</code> value
     */
    public CascadingIOException(Exception ex) {
        this(ex.getMessage(), ex);
    }
14641#/**
     * Construct a new <code>ProcessingException</code> that references
     * a parent Exception.
     */
    public CascadingIOException(String message, Throwable t) {
        super( message );
        this.m_throwable = t;
    }
14642#/**
     * Retrieve root cause of the exception.
     *
     * @return the root cause
     */
    public final Throwable getCause()
    {
        return this.m_throwable;
    }
14643#public String toString() {
        StringBuffer s = new StringBuffer();
        s.append(super.toString());
        final Throwable t = getCause();
        if(t!=null) {
            s.append(": ");
            // be more verbose try to get location info
            s.append( extraInfo(t) );
            s.append(t.toString());
        }
        return s.toString();
    }
14644#/**
     * Examine Throwable and try to figure out location information.
     * <p>
     *   At the moment only SAXParseException, and TransformerException
     *   are considered.
     * </p>
     *
     * @return String containing location information of the format
     *  <code>{file-name}:{line}:{column}:</code>, if no location info is 
     *  available return empty string
     */
    private String extraInfo( Throwable t ) {
        StringBuffer sb = new StringBuffer();
        if (t instanceof SAXParseException) {
            SAXParseException spe = (SAXParseException)t;
            sb.append( String.valueOf(spe.getSystemId()));
            sb.append( ":" );
            sb.append( String.valueOf(spe.getLineNumber()));
            sb.append( ":" );
            sb.append( String.valueOf(spe.getColumnNumber()));
            sb.append( ":" );
        } else if (t instanceof TransformerException) {
            TransformerException transformerException = (TransformerException) t;
            SourceLocator sourceLocator = transformerException.getLocator();
            
            if( null != sourceLocator ) {
                sb.append( String.valueOf(sourceLocator.getSystemId()));
                sb.append( ":" );
                sb.append( String.valueOf(sourceLocator.getLineNumber()));
                sb.append( ":" );
                sb.append( String.valueOf(sourceLocator.getColumnNumber()));
                sb.append( ":" );
            }
        }
        return sb.toString();
    }
14645#public void printStackTrace() {
        super.printStackTrace();
        if(getCause()!=null)
            getCause().printStackTrace();
    }
14646#public void printStackTrace( PrintStream s ) {
        super.printStackTrace(s);
        if(getCause()!=null)
            getCause().printStackTrace(s);
    }
14647#public void printStackTrace( PrintWriter s ) {
        super.printStackTrace(s);
        if(getCause()!=null)
            getCause().printStackTrace(s);
    }
14648#/**
     * Construct a new <code>ResourceNotFoundException</code> instance.
     */
    public ResourceNotFoundException(String message) {
        super(message);
    }
14649#/**
     * Construct a new <code>ResourceNotFoundException</code> that references
     * a parent Exception.
     */
    public ResourceNotFoundException(String message, Throwable t) {
        super(message, t);
    }
14650#public ResourceNotFoundException(String message, Location location) {
        super(message, location);
    }
14651#public ResourceNotFoundException(String message, Throwable t, Location loc) {
        super(message, t, loc);
    }
14652#/**
     * Construct a new <code>ConnectionResetException</code> instance.
     *
     * @param message a <code>String</code> value
     */
    public ConnectionResetException(String message) {
        super(message);
    }
14653#/**
     * Construct a new <code>ConnectionResetException</code> that references
     * a parent Exception.
     *
     * @param message a <code>String</code> value
     * @param t a <code>Throwable</code> value
     */
    public ConnectionResetException(String message, Throwable t) {
        super(message, t);
    }
14654#/**
     * Queries the class to estimate its ergodic period termination.
     * <br>
     * This method is called to ensure the validity of a cached product. It
     * is the class responsibility to provide the fastest possible
     * implementation of this method or, whether this is not possible and the
     * costs of the change evaluation is comparable to the production costs,
     * to return <b>true</b> directly with no further delay, thus reducing
     * the evaluation overhead to a minimum.
     *
     * @return <b>true</b> if the class ergodic period is over and the class
     *         would behave differently if processed again, <b>false</b> if the
     *         resource is still ergodic so that it doesn't require
     *         reprocessing.
     */
    boolean modifiedSince( long date );
14655#public ConstantsInitializationException(String message)
    {
        super(message, null);
    }
14656#public ConstantsInitializationException(String message, Throwable cause)
    {
        super(message, cause);
    }
14657#/**
     * Generate the unique key for the resource being rendered.
     * <p>
     * The cache key is the single most important part of the caching
     * implementation. If you don't get it right, you can introduce more load
     * on the caching engine than is necessary. It is important that the cache
     * key has the following attributes:
     * </p>
     * <ul>
     * <li>It must be Serializable (part of the contract of this method).</li>
     * <li>It must be Immutable--the key is used as a lookup value.</li>
     * <li>It must be Unique within the space of the component (i.e. the key
     *     "1" for MyCacheableComponent must be for the same resource every
     *     time, but we don't have to worry about the key "1" for
     *     YourCacheableComponent).</li>
     * <li>The equals() and hashCode() methods must be consistent (i.e. if two
     *     keys are equal, the hashCode must also be equal).</li>
     * </ul>
     * <p>
     * Thankfully there is a perfectly suitable object that satisfies these
     * obligations from Java's core: <code>java.lang.String</code>. You can
     * also use your own specific key objects provided they respect the above
     * contracts.
     * </p>
     * <p>
     * <strong>Important:</strong>If the cache key is <code>null</code> then
     * your component will not be cached at all. You can use this to your
     * advantage to cache some things but not others.
     * </p>
     *
     * @return The generated key or <code>null</code> if the component
     *              is currently not cacheable.
     */
    Serializable getKey();
14658#/**
     * Generate the validity object.  This method is invoked after the
     * <code>getKey()</code> method.
     * <p>
     * The caching contracts use the Excalibur <code>SourceValidity</code>
     * interface to determine whether a resource is valid or not. The validity
     * can be a compound check that incorporates time since creation, parameter
     * values, etc. As long as the sitemap can determine whether the cached
     * resource is valid or not. More information is available on the 
     * <a href="http://excalibur.apache.org/sourceresolve/index.html">Apache
     * Excalibur site</a>. 
     * </p>
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    SourceValidity getValidity();
14659#/**
     * Store a cached response
     * @param key         the key used by the caching algorithm to identify the
     *                    request
     * @param response    the cached response
     */
    void store(Serializable     key,
               CachedResponse   response)
    throws ProcessingException;
14660#/**
     * Get a cached response.
     * If it is not available <code>null</code> is returned.
     * @param key         the key used by the caching algorithm to identify the
     *                    request
     */
    CachedResponse get(Serializable key);
14661#/**
     * Remove a cached response.
     * If it is not available no operation is performed.
     * @param key         the key used by the caching algorithm to identify the
     *                    request
     */
    void remove(Serializable key);
14662#/**
     * clear cache of all cached responses 
     */
    void clear();
14663#/**
     * See if a response is cached under this key.
     */
    boolean containsKey(Serializable key);
14664#/**
     * Create a new entry for the cache.
     *
     * @param validityObjects The SourceValidity objects in the order
     *                        they occured in the pipeline
     * @param response        The cached sax stream or character stream
     */
    public CachedResponse(SourceValidity[] validityObjects,
                          byte[]           response) {
        this(validityObjects, response, null);
    }
14665#/**
     * Create a new entry for the cache.
     *
     * @param validityObject  The SourceValidity object 
     * @param response        The cached sax stream or character stream
     */
    public CachedResponse(SourceValidity   validityObject,
                          byte[]           response) {
        this(new SourceValidity[] {validityObject}, response, null);
    }
14666#/**
     * Create a new entry for the cache.
     *
     * @param validityObjects The SourceValidity objects in the order
     *                        they occured in the pipeline
     * @param response        The cached sax stream or character stream
     * @param expires         The configured expires, or null if no
     *                        expires was defined.
     */
    public CachedResponse(SourceValidity[] validityObjects,
                          byte[]           response,
                          Long expires) {
        this.validityObjects = validityObjects;
        this.response = response;
        this.expires = expires;
        this.lastModified = this.setLastModified(System.currentTimeMillis());
    }
14667#/**
     * Get the validity objects
     */
    public SourceValidity[] getValidityObjects() {
        return this.validityObjects;
    }
14668#/**
     * Get the cached response.
     *
     * @return The sax stream or character stream
     */
    public byte[] getResponse() {
        return this.response;
    }
14669#/**
     * Get the configured expires.
     *
     * @return The configured expires, or null if no expires was defined
     */
    public Long getExpires() {
        return this.expires;
    }
14670#/**
     * Set the (newly) configured expires.
     * 
     */
    public void setExpires(Long newExpires) {
        this.expires = newExpires;    
    }
14671#/**
     * Set the (newly) configured last modified.
     * 
     */
    protected long setLastModified(long lastModified) {
        // Return the value rounded to the nearest second.
        return lastModified - (lastModified % 1000);
    }
14672#/**
     * @return the last modified time 
     */
    public long getLastModified() {
        return lastModified;
    }
14673#/**
     * @return Returns the cached content type (or null).
     */
    public String getContentType() {
        return this.contentType;
    }
14674#/**
     * @param value The content type to cache.
     */
    public void setContentType(String value) {
        this.contentType = value;
    }
14675#/**
     * Setup this component.
     */
    void setup(Parameters params);
14676#/**
     * Set the generator that will be used as the initial step in the pipeline.
     * The generator role is given : the actual <code>Generator</code> is fetched
     * from the latest <code>ServiceManager</code>.
     *
     * @param role the generator role in the component manager.
     * @param source the source where to produce XML from, or <code>null</code> if no
     *        source is given.
     * @param param the parameters for the generator.
     * @throws ProcessingException if the generator couldn't be obtained.
     */
    void setGenerator(String role, String source, Parameters param, Parameters hintParam)
    throws ProcessingException;
14677#/**
     * Get the generator - used for content aggregation
     */
    Generator getGenerator();
14678#/**
     * Informs pipeline we have come across a branch point
     */
    void informBranchPoint();
14679#/**
     * Set the <code>ServiceManager</code> where pipeline components have to be searched for.
     * @param manager the processor's service manager.
     */
    void setProcessorManager(ServiceManager manager);
14680#/**
     * Add a transformer at the end of the pipeline.
     * The transformer role is given : the actual <code>Transformer</code> is fetched
     * from the latest <code>ServiceManager</code>.
     *
     * @param role the transformer role in the service manager.
     * @param source the source used to setup the transformer (e.g. XSL file), or
     *        <code>null</code> if no source is given.
     * @param param the parameters for the transfomer.
     * @throws ProcessingException if the generator couldn't be obtained.
     */
    void addTransformer(String role, String source, Parameters param, Parameters hintParam)
    throws ProcessingException;
14681#/**
     * Set the serializer for this pipeline
     * @param mimeType Can be null
     */
    void setSerializer(String role, String source, Parameters param, Parameters hintParam, String mimeType)
    throws ProcessingException;
14682#/**
     * Set the reader for this pipeline
     * @param mimeType Can be null
     */
    void setReader(String role, String source, Parameters param, String mimeType)
    throws ProcessingException;
14683#/**
     * Sets error handler for this pipeline.
     * Used for handling errors in the internal pipelines.
     */
    void setErrorHandler(SitemapErrorHandler errorHandler)
    throws ProcessingException;
14684#/**
     * Process the given <code>Environment</code>, producing the output.
     */
    boolean process(Environment environment)
    throws ProcessingException;
14685#/**
     * Prepare an internal processing
     * @param environment          The current environment.
     * @throws ProcessingException
     */
    void prepareInternal(Environment environment)
    throws ProcessingException;
14686#/**
     * Process the given <code>Environment</code>, but do not use the
     * serializer. Instead the sax events are streamed to the XMLConsumer.
     * Make sure to call {@link #prepareInternal(Environment)} beforehand.
     */
    boolean process(Environment environment, XMLConsumer consumer)
    throws ProcessingException;
14687#/**
     * Return valid validity objects for the event pipeline
     * If the "event pipeline" (= the complete pipeline without the
     * serializer) is cacheable and valid, return all validity objects.
     * Otherwise return <code>null</code>
     */
    SourceValidity getValidityForEventPipeline();
14688#/**
     * Return the key for the event pipeline
     * If the "event pipeline" (= the complete pipeline without the
     * serializer) is cacheable and valid, return a key.
     * Otherwise return <code>null</code>
     */
    String getKeyForEventPipeline();
14689#/**
     * Redirect to the given URL
     */
    void redirect(boolean sessionmode, String url) throws IOException, ProcessingException;
14690#void globalRedirect(boolean sessionmode, String url) throws IOException, ProcessingException;
14691#/**
     * Was one of the redirection methods called ?
     */
    boolean hasRedirected();
14692#/**
     * Send a content-less response with the given status code.
     * 
     * @param sc  an http status code.
     */
    void sendStatus(int sc);
14693#/**
     * Get the URI to process. The prefix is stripped off.
     */
    String getURI();
14694#/**
     * Get the prefix of the URI in progress.
     */
    String getURIPrefix();
14695#/**
     * Set the URI and the prefix to process.
     */
    void setURI(String prefix, String value);
14696#/**
     * Get the view to process
     */
    String getView();
14697#/**
     * Get the action to process
     */
    String getAction();
14698#/**
     * Redirect the client to the given URL
     */
    void redirect(String url, boolean global, boolean permanent) 
    throws IOException;
14699#/**
     * Set the content type of the generated resource
     */
    void setContentType(String mimeType);
14700#/**
     * Get the content type of the resource
     */
    String getContentType();
14701#/**
     * Set the length of the generated content
     */
    void setContentLength(int length);
14702#/**
     * Set the response status code
     */
    void setStatus(int statusCode);
14703#/**
     * Get the output stream where to write the generated resource.
     * The returned stream is buffered by the environment. If the
     * buffer size is -1 then the complete output is buffered.
     * If the buffer size is 0, no buffering takes place.
     */
    OutputStream getOutputStream(int bufferSize) throws IOException;
14704#/**
     * Get the underlying object model
     */
    Map getObjectModel();
14705#/**
     * Check if the response has been modified since the same
     * "resource" was requested.
     * The caller has to test if it is really the same "resource"
     * which is requested.
     * @return true if the response is modified or if the
     *         environment is not able to test it
     */
    boolean isResponseModified(long lastModified);
14706#/**
     * Mark the response as not modified.
     */
    void setResponseIsNotModified();
14707#/**
     * Binds an object to this environment, using the name specified. This allows
     * the pipeline assembly engine to store for its own use objects that souldn't
     * be exposed to other components (generators, selectors, etc) and therefore
     * cannot be put in the object model.
     * <p>
     * If an object of the same name is already bound, the object is replaced.
     *
     * @param name  the name to which the object is bound
     * @param value the object to be bound
     */
    void setAttribute(String name, Object value);
14708#/**
     * Returns the object bound with the specified name, or <code>null</code>
     * if no object is bound under the name.
     *
     * @param name                a string specifying the name of the object
     * @return                    the object with the specified name
     */
    Object getAttribute(String name);
14709#/**
     * Removes the object bound with the specified name from
     * this environment. If the environment does not have an object
     * bound with the specified name, this method does nothing.
     *
     * @param name the name of the object to remove
     */
    void removeAttribute(String name);
14710#/**
     * Returns an <code>Enumeration</code> of <code>String</code> objects
     * containing the names of all the objects bound to this environment.
     *
     * @return an <code>Enumeration</code> of <code>String</code>s.
     */
    Enumeration getAttributeNames();
14711#/**
     * Reset the response if possible. This allows error handlers to have
     * a higher chance to produce clean output if the pipeline that raised
     * the error has already output some data.
     * If a buffered output stream is used, resetting is always successful.
     *
     * @return true if the response was successfully reset
     */
    boolean tryResetResponse() throws IOException;
14712#/**
     * Commit the response
     */
    void commitResponse() throws IOException;
14713#/**
     * Notify that the processing starts.
     */
    void startingProcessing();
14714#/**
     * Notify that the processing is finished
     * This can be used to cleanup the environment object
     */
    void finishingProcessing();
14715#/**
     * Is this environment external ? An external environment is one that 
     * is created in response to an external request (http, commandline, etc.). 
     * Environments created by the "cocoon:" protocol aren't external.
     * 
     * @return true if this environment is external
     */
    boolean isExternal();
14716#/**
     * Is this an internal redirect?
     * An environment is on internal redirect if it is an internal request
     * (via the cocoon: protocol) and used for a redirect.
     */
    boolean isInternalRedirect();
14717#Object getAttribute(String name);
14718#void setAttribute(String name, Object value);
14719#void removeAttribute(String name);
14720#Enumeration getAttributeNames();
14721#/**
     * Utility method for getting a <code>Map</code> view of the context attributes.
     * Returns a <code>Map</code> with context attributes.
     *
     * @return                a <code>Map</code> containing the context attributes.
     * @since 2.2
     */
    Map getAttributes();
14722#URL getResource(String path) throws MalformedURLException;
14723#String getRealPath(String path);
14724#String getMimeType(String file);
14725#String getInitParameter(String name);
14726#InputStream getResourceAsStream(String path);
14727#/**
     *
     * Returns the value of the named parameter as an <code>Object</code>,
     * or <code>null</code> if no parameter of the given name exists.
     * Basically, this method is similar to {@link #getParameter(String)},
     * but it returns an object instead. 
     * This is useful when special processing has been made on these parameters,
     * for example for file uploads. In this case you get an object 
     * representing the uploaded file.
     * If the parameters have not been processed, you either get a String
     * object if the parameter has one value, or a Collection of Strings
     * if the parameter has more than one value.
     * 
     * @param name        a <code>String</code> specifying the name of
     *                        the parameter
     *
     * @return                an <code>Object</code> containing the value
     *                        of the parameter, or <code>null</code> if
     *                        the parameter does not exist
     *
     */

    Object get(String name);
14728#/**
     *
     * Returns the value of the named attribute from the <code>GLOBAL_SCOPE</code>
     * as an <code>Object</code>, or <code>null</code> if no attribute 
     * of the given name exists.
     *
     * @param name        a <code>String</code> specifying the name of
     *                        the attribute
     *
     * @return                an <code>Object</code> containing the value
     *                        of the attribute, or <code>null</code> if
     *                        the attribute does not exist
     *
     */
    Object getAttribute(String name);
14729#/**
     * Returns the value of the named attribute from the <code>LOCAL_SCOPE</code>
     * as an <code>Object</code>, or <code>null</code> if no attribute
     * of the given name exists.
     *
     * @param name        a <code>String</code> specifying the name of
     *                        the attribute
     *
     * @return                an <code>Object</code> containing the value
     *                        of the attribute, or <code>null</code> if
     *                        the attribute does not exist
     *
     * @since 2.2
     */
    Object getLocalAttribute(String name);
14730#/**
     * Returns an <code>Enumeration</code> containing the
     * names of the attributes available to this request globally.
     * This method returns an empty <code>Enumeration</code>
     * if the request has no attributes available to it.
     *
     *
     * @return                an <code>Enumeration</code> of strings
     *                        containing the names
     *                         of the request's attributes
     *
     */
    Enumeration getAttributeNames();
14731#/**
     * Returns an <code>Enumeration</code> containing the
     * names of the attributes available to this request locally.
     * This method returns an empty <code>Enumeration</code>
     * if the request has no attributes available to it.
     *
     *
     * @return                an <code>Enumeration</code> of strings
     *                        containing the names
     *                         of the request's attributes
     *
     */
    Enumeration getLocalAttributeNames();
14732#/**
     *
     * Stores an attribute in this request in the <code>GLOBAL_SCOPE</code>.
     * Attributes are reset between requests.
     *
     * <p>Attribute names should follow the same conventions as
     * package names. Names beginning with <code>java.*</code>,
     * <code>javax.*</code>, and <code>com.sun.*</code>, are
     * reserved for use by Sun Microsystems.
     *
     *
     * @param name                        a <code>String</code> specifying
     *                                        the name of the attribute
     *
     * @param o                                the <code>Object</code> to be stored
     *
     */
    void setAttribute(String name, Object o);
14733#/**
     *
     * Stores an attribute in this request locally.
     * Attributes are reset between requests.
     *
     * <p>Attribute names should follow the same conventions as
     * package names. Names beginning with <code>java.*</code>,
     * <code>javax.*</code>, and <code>com.sun.*</code>, are
     * reserved for use by Sun Microsystems.
     *
     *
     * @param name                        a <code>String</code> specifying
     *                                        the name of the attribute
     *
     * @param o                                the <code>Object</code> to be stored
     *
     */
    void setLocalAttribute(String name, Object o);
14734#/**
     *
     * Removes an attribute from this request globally.
     * This method is not generally needed as attributes only persist as long
     * as the request is being handled.
     *
     * <p>Attribute names should follow the same conventions as
     * package names. Names beginning with <code>java.*</code>,
     * <code>javax.*</code>, and <code>com.sun.*</code>, are
     * reserved for use by Sun Microsystems.
     *
     *
     * @param name                        a <code>String</code> specifying
     *                                        the name of the attribute to remove
     *
     */
    void removeAttribute(String name);
14735#/**
     *
     * Removes an attribute from this request in the <code>GLOBAL_SCOPE</code>.
     * This method is not
     * generally needed as attributes only persist as long as the request
     * is being handled.
     *
     * <p>Attribute names should follow the same conventions as
     * package names. Names beginning with <code>java.*</code>,
     * <code>javax.*</code>, and <code>com.sun.*</code>, are
     * reserved for use by Sun Microsystems.
     *
     *
     * @param name                        a <code>String</code> specifying
     *                                        the name of the attribute to remove
     *
     */
    void removeLocalAttribute(String name);
14736#/**
     * Returns the value of the named attribute searching both scopes
     * as an <code>Object</code>, or <code>null</code> if no attribute 
     * of the given name exists. This method first searches in the 
     * request scope and then, if no object is found, in the global scope.
     *
     * @param name        a <code>String</code> specifying the name of
     *                        the attribute
     *
     * @return                an <code>Object</code> containing the value
     *                        of the attribute, or <code>null</code> if
     *                        the attribute does not exist
     *
     * @since 2.2
     */
    Object searchAttribute(String name);
14737#/**
     * Utility method for getting a <code>Map</code> view of the request attributes.
     * Returns a <code>Map</code> with attributes from the <code>GLOBAL_SCOPE</code>.
     *
     * @return                a <code>Map</code> containing the request attributes.
     *
     * @since 2.2
     */
    Map getAttributes();
14738#/**
     *
     * Returns the name of the authentication scheme used to protect
     * the servlet, for example, "BASIC" or "SSL," or null if the servlet was
     * not protected
     *
     * @return                The name of the authentication scheme used to
     *                        protect the servlet, or null if the servlet was
     *                        not protected
     */

    String getAuthType();
14739#/**
     * Returns the name of the character encoding used in the body of this
     * request. This method returns <code>null</code> if the request
     * does not specify a character encoding
     *
     *
     * @return                a <code>String</code> containing the name of
     *                        the chararacter encoding, or <code>null</code>
     *                        if the request does not specify a character encoding
     *
     */

    String getCharacterEncoding();
14740#/**
     * Overrides the charactor encoding of parameters.
     *
     * @throws java.io.UnsupportedEncodingException if this is not a valid encoding.
     *
     */

    void setCharacterEncoding(String enc) throws java.io.UnsupportedEncodingException;
14741#/**
     * Returns the length, in bytes, of the request body
     *
     * @return                an integer containing the length of the
     *                         request body or -1 if the length is not known
     *
     */

    int getContentLength();
14742#/**
     * Returns the MIME type of the body of the request
     *
     * @return                a <code>String</code> containing the name
     *                        of the MIME type of
     *                         the request, or -1 if the type is not known
     *
     */

    String getContentType();
14743#/**
     * Returns the value of a request parameter as a <code>String</code>,
     *
     * @param name         a <code>String</code> specifying the
     *                        name of the parameter
     *
     * @return                a <code>String</code> representing the
     *                        single value of the parameter
     *
     * @see                 #getParameterValues(String)
     *
     */

    String getParameter(String name);
14744#/**
     *
     * Returns an <code>Enumeration</code> of <code>String</code>
     * objects containing the names of the parameters contained
     * in this request. If the request has
     * no parameters, the method returns an
     * empty <code>Enumeration</code>.
     *
     * @return                an <code>Enumeration</code> of <code>String</code>
     *                        objects, each <code>String</code> containing
     *                         the name of a request parameter; or an
     *                        empty <code>Enumeration</code> if the
     *                        request has no parameters
     *
     */

    Enumeration getParameterNames();
14745#/**
     * Returns an array of <code>String</code> objects containing
     * all of the values the given request parameter has, or
     * <code>null</code> if the parameter does not exist.
     *
     * <p>If the parameter has a single value, the array has a length
     * of 1.
     *
     * @param name        a <code>String</code> containing the name of
     *                        the parameter whose value is requested
     *
     * @return                an array of <code>String</code> objects
     *                        containing the parameter's values
     *
     * @see                #getParameter(String)
     *
     */

    String[] getParameterValues(String name);
14746#/**
     * Utility method for getting a <code>Map</code> view of the request parameters.
     * Returns a <code>Map</code> with request parameters.
     *
     * @return                a <code>Map</code> containing the request parameters.
     *
     * @since 2.2
     */
    Map getParameters();
14747#/**
     * Returns the name and version of the protocol the request uses
     * in the form <i>protocol/majorVersion.minorVersion</i>, for
     * example, HTTP/1.1. For HTTP servlets, the value
     * returned is the same as the value of the CGI variable
     * <code>SERVER_PROTOCOL</code>.
     *
     * @return                a <code>String</code> containing the protocol
     *                        name and version number
     *
     */

    String getProtocol();
14748#/**
     * Returns the name of the scheme used to make this request,
     * for example,
     * <code>http</code>, <code>https</code>, or <code>ftp</code>.
     * Different schemes have different rules for constructing URLs,
     * as noted in RFC 1738.
     *
     * @return                a <code>String</code> containing the name
     *                        of the scheme used to make this request
     *
     */

    String getScheme();
14749#/**
     * Returns the host name of the server that received the request.
     * For HTTP servlets, same as the value of the CGI variable
     * <code>SERVER_NAME</code>.
     *
     * @return                a <code>String</code> containing the name
     *                        of the server to which the request was sent
     */

    String getServerName();
14750#/**
     * Returns the port number on which this request was received.
     * For HTTP servlets, same as the value of the CGI variable
     * <code>SERVER_PORT</code>.
     *
     * @return                an integer specifying the port number
     *
     */

    int getServerPort();
14751#/**
     * Returns the Internet Protocol (IP) address of the client
     * that sent the request.  For HTTP servlets, same as the value of the
     * CGI variable <code>REMOTE_ADDR</code>.
     *
     * @return                a <code>String</code> containing the
     *                        IP address of the client that sent the request
     *
     */

    String getRemoteAddr();
14752#/**
     * Returns the fully qualified name of the client that sent the
     * request, or the IP address of the client if the name cannot be
     * determined. For HTTP servlets, same as the value of the CGI variable
     * <code>REMOTE_HOST</code>.
     *
     * @return                a <code>String</code> containing the fully qualified name
     *                        of the client
     *
     */

    String getRemoteHost();
14753#/**
     *
     * Returns the preferred <code>Locale</code> that the client will
     * accept content in, based on the Accept-Language header.
     * If the client request doesn't provide an Accept-Language header,
     * this method returns the default locale for the server.
     *
     *
     * @return                the preferred <code>Locale</code> for the client
     *
     */

    Locale getLocale();
14754#/**
     *
     * Returns an <code>Enumeration</code> of <code>Locale</code> objects
     * indicating, in decreasing order starting with the preferred locale, the
     * locales that are acceptable to the client based on the Accept-Language
     * header.
     * If the client request doesn't provide an Accept-Language header,
     * this method returns an <code>Enumeration</code> containing one
     * <code>Locale</code>, the default locale for the server.
     *
     *
     * @return                an <code>Enumeration</code> of preferred
     *                  <code>Locale</code> objects for the client
     *
     */

    Enumeration getLocales();
14755#/**
     *
     * Returns a boolean indicating whether this request was made using a
     * secure channel, such as HTTPS.
     *
     *
     * @return                a boolean indicating if the request was made using a
     *                  secure channel
     *
     */

    boolean isSecure();
14756#/**
     *
     * Returns an array containing all of the {@link javax.servlet.http.Cookie}
     * objects the client sent with this request.
     * This method returns <code>null</code> if no cookies were sent.
     *
     * @return                an array of all the {@link javax.servlet.http.Cookie}
     *                        included with this request, or <code>null</code>
     *                        if the request has no cookies
     *
     *
     */

    javax.servlet.http.Cookie[] getCookies();
14757#/**
     * Returns a map of the {@link javax.servlet.http.Cookie} objects the client sent
     * with this request, indexed by name. This method returns an empty
     * map if no cookies were sent.
     *
     * @return a Map of {@link javax.servlet.http.Cookie} objects
     */
    Map getCookieMap();
14758#/**
    *
    * Returns an array containing all of the <code>Cookie</code>
    * objects the client sent with this request.
    * This method returns <code>null</code> if no cookies were sent.
    *
    * @return                an array of all the <code>Cookies</code>
    *                        included with this request, or <code>null</code>
    *                        if the request has no cookies
    *
    * @deprecated use {@link #getCookies()} instead.
    */

   Cookie[] getCocoonCookies();
14759#/**
    * Returns a map of the <code>Cookie</code> objects the client sent
    * with this request, indexed by name. This method returns an empty
    * map if no cookies were sent.
    *
    * @return a Map of <code>Cookie</code> objects
    * 
    * @deprecated use {@link #getCookieMap()} instead.
    */
   Map getCocoonCookieMap();
14760#/**
     *
     * Returns the value of the specified request header
     * as a <code>long</code> value that represents a
     * <code>Date</code> object. Use this method with
     * headers that contain dates, such as
     * <code>If-Modified-Since</code>.
     *
     * <p>The date is returned as
     * the number of milliseconds since January 1, 1970 GMT.
     * The header name is case insensitive.
     *
     * <p>If the request did not have a header of the
     * specified name, this method returns -1. If the header
     * can't be converted to a date, the method throws
     * an <code>IllegalArgumentException</code>.
     *
     * @param name                a <code>String</code> specifying the
     *                                name of the header
     *
     * @return                        a <code>long</code> value
     *                                representing the date specified
     *                                in the header expressed as
     *                                the number of milliseconds
     *                                since January 1, 1970 GMT,
     *                                or -1 if the named header
     *                                was not included with the
     *                                reqest
     *
     * @exception        IllegalArgumentException        If the header value
     *                                                        can't be converted
     *                                                        to a date
     *
     */

    long getDateHeader(String name);
14761#/**
     *
     * Returns the value of the specified request header
     * as a <code>String</code>. If the request did not include a header
     * of the specified name, this method returns <code>null</code>.
     * The header name is case insensitive. You can use
     * this method with any request header.
     *
     * @param name                a <code>String</code> specifying the
     *                                header name
     *
     * @return                        a <code>String</code> containing the
     *                                value of the requested
     *                                header, or <code>null</code>
     *                                if the request does not
     *                                have a header of that name
     *
     */

    String getHeader(String name);
14762#/**
     *
     * Returns all the values of the specified request header
     * as an <code>Enumeration</code> of <code>String</code> objects.
     *
     * <p>Some headers, such as <code>Accept-Language</code> can be sent
     * by clients as several headers each with a different value rather than
     * sending the header as a comma separated list.
     *
     * <p>If the request did not include any headers
     * of the specified name, this method returns an empty
     * <code>Enumeration</code>.
     * The header name is case insensitive. You can use
     * this method with any request header.
     *
     * @param name                a <code>String</code> specifying the
     *                                header name
     *
     * @return                        a <code>Enumeration</code> containing the
     *                                values of the requested
     *                                header, or <code>null</code>
     *                                if the request does not
     *                                have any headers of that name
     *
     */

    Enumeration getHeaders(String name);
14763#/**
     *
     * Returns an enumeration of all the header names
     * this request contains. If the request has no
     * headers, this method returns an empty enumeration.
     *
     * <p>Some servlet containers do not allow do not allow
     * servlets to access headers using this method, in
     * which case this method returns <code>null</code>
     *
     * @return                        an enumeration of all the
     *                                header names sent with this
     *                                request; if the request has
     *                                no headers, an empty enumeration;
     *                                if the servlet container does not
     *                                allow servlets to use this method,
     *                                <code>null</code>
     *
     */

    Enumeration getHeaderNames();
14764#/**
     * Utility method for getting a <code>Map</code> view of the request headers.
     * Returns a <code>Map</code> with request headers.
     *
     * @return                a <code>Map</code> containing the request headers.
     *
     * @since 2.2
     */
    Map getHeaders();
14765#/**
     * Retrieves the body of the request as binary data using 
     * an <code>InputStream</code>.
     * 
     * @return                        an <code>InputStream</code>
     *                                containing the body of the request.
     * 
     * @throws IOException            if an input or output exception occurred
     * @throws UnsupportedOperationException
     */
    ServletInputStream getInputStream() throws IOException, UnsupportedOperationException;
14766#/**
     *
     * Returns the name of the HTTP method with which this
     * request was made, for example, GET, POST, or PUT.
     * Same as the value of the CGI variable REQUEST_METHOD.
     *
     * @return                        a <code>String</code>
     *                                specifying the name
     *                                of the method with which
     *                                this request was made
     *
     */

    String getMethod();
14767#/**
     *
     * Returns any extra path information associated with
     * the URL the client sent when it made this request.
     * The extra path information follows the servlet path
     * but precedes the query string.
     * This method returns <code>null</code> if there
     * was no extra path information.
     *
     * <p>Same as the value of the CGI variable PATH_INFO.
     *
     *
     * @return                a <code>String</code> specifying
     *                        extra path information that comes
     *                        after the servlet path but before
     *                        the query string in the request URL;
     *                        or <code>null</code> if the URL does not have
     *                        any extra path information
     *
     */

    String getPathInfo();
14768#/**
     *
     * Returns any extra path information after the servlet name
     * but before the query string, and translates it to a real
     * path. Same as the value of the CGI variable PATH_TRANSLATED.
     *
     * <p>If the URL does not have any extra path information,
     * this method returns <code>null</code>.
     *
     *
     * @return                a <code>String</code> specifying the
     *                        real path, or <code>null</code> if
     *                        the URL does not have any extra path
     *                        information
     *
     *
     */

    String getPathTranslated();
14769#/**
     *
     * Returns the portion of the request URI that indicates the context
     * of the request.  The context path always comes first in a request
     * URI.  The path starts with a "/" character but does not end with a "/"
     * character.  For servlets in the default (root) context, this method
     * returns "".
     *
     *
     * @return                a <code>String</code> specifying the
     *                        portion of the request URI that indicates the context
     *                        of the request
     *
     *
     */

    String getContextPath();
14770#/**
     *
     * Returns the query string that is contained in the request
     * URL after the path. This method returns <code>null</code>
     * if the URL does not have a query string. Same as the value
     * of the CGI variable QUERY_STRING.
     *
     * @return                a <code>String</code> containing the query
     *                        string or <code>null</code> if the URL
     *                        contains no query string
     *
     */

    String getQueryString();
14771#/**
     *
     * Returns the login of the user making this request, if the
     * user has been authenticated, or <code>null</code> if the user
     * has not been authenticated.
     * Whether the user name is sent with each subsequent request
     * depends on the browser and type of authentication. Same as the
     * value of the CGI variable REMOTE_USER.
     *
     * @return                a <code>String</code> specifying the login
     *                        of the user making this request, or <code>null</code
     *                        if the user login is not known
     *
     */

    String getRemoteUser();
14772#/**
     *
     * Returns the login of the user making this request, if the
     * user has been authenticated, or <code>null</code> if the user
     * has not been authenticated.
     * Whether the user name is sent with each subsequent request
     * depends on the browser and type of authentication. Same as the
     * value of the CGI variable REMOTE_USER.
     *
     * @return                a <code>String</code> specifying the login
     *                        of the user making this request, or <code>null</code
     *                        if the user login is not known
     *
     */

    Principal getUserPrincipal();
14773#/**
     *
     * Checks whether the currently logged in user is in a specified role.
     *
     * @return                        <code>true</code> if the user is
     *                                authenticated and in the role;
     *                                otherwise, <code>false</code>
     *
     *
     * @see                        #getRemoteUser()
     *
     */

    boolean isUserInRole(String role);
14774#/**
     *
     * Returns the session ID specified by the client. This may
     * not be the same as the ID of the actual session in use.
     * For example, if the request specified an old (expired)
     * session ID and the server has started a new session, this
     * method gets a new session with a new ID. If the request
     * did not specify a session ID, this method returns
     * <code>null</code>.
     *
     *
     * @return                a <code>String</code> specifying the session
     *                        ID, or <code>null</code> if the request did
     *                        not specify a session ID
     *
     * @see                #isRequestedSessionIdValid()
     *
     */

    String getRequestedSessionId();
14775#/**
     *
     * Returns the part of this request's URL from the protocol
     * name up to the query string in the first line of the HTTP request.
     * For example:
     *
     * <blockquote>
     * <table>
     * <tr align=left><th>First line of HTTP request<th>
     * <th>Returned Value
     * <tr><td>POST /some/path.html HTTP/1.1<td><td>/some/path.html
     * <tr><td>GET http://foo.bar/a.html HTTP/1.0
     * <td><td>http://foo.bar/a.html
     * <tr><td>HEAD /xyz?a=b HTTP/1.1<td><td>/xyz
     * </table>
     * </blockquote>
     * 
     * For internal requests, this method returns
     * the information for the original/external request!
     *
     * @return                a <code>String</code> containing
     *                        the part of the URL from the
     *                        protocol name up to the query string
     */
    String getRequestURI();
14776#/**
     * <p>
     * Returns the URI of the requested resource as interpreted by the sitemap.
     * For example, if your webapp is mounted at "/webapp" and the HTTP request
     * is for "/webapp/foo", this method returns "foo". Consequently, if the
     * request is for "/webapp", this method returns an empty string.
     * </p>
     * <p>
     * Note that if the request is mapped to a pipeline that contains
     * aggregated content, and if this method is called in the context of
     * one of the aggregated parts (e.g. a server page), this method will
     * return the URI of the aggregated part, not the original requested URI.
     * </p>
     *
     * @return a <code>String</code> containing the URL as mangled by the
     *         sitemap
     */
    String getSitemapURI();
14777#/**
     * <p>
     * Returns the URI Prefix of the requested resource where the sitemap is mounted.
     * For example, if your webapp is mounted at "/webapp" and the HTTP request
     * is for "/webapp/foo", this method returns "webapp/".
     * </p>
     *
     * @return a <code>String</code> containing the URI prefix as mangled by the
     *         sitemap
     */

    String getSitemapURIPrefix();
14778#/**
     * <p>
     * Returns the path to the sitemap of the requested resource as interpreted 
     * by the sitemap.
     * For example, if your webapp is mounted at "webapp" and the HTTP request
     * is for "webapp/foo", this method returns "webapp/". Consequently, if the
     * request is for "foo", this method returns the empty string.
     * </p>
     *
     * @return a <code>String</code> containing the path to the sitemap
     * @since 2.2
     */

    String getSitemapPath();
14779#/**
     *
     * Returns the part of this request's URL that calls
     * the servlet. This includes either the servlet name or
     * a path to the servlet, but does not include any extra
     * path information or a query string. Same as the value
     * of the CGI variable SCRIPT_NAME.
     *
     *
     * @return                a <code>String</code> containing
     *                        the name or path of the servlet being
     *                        called, as specified in the request URL
     *
     *
     */

    String getServletPath();
14780#/**
     *
     * Returns the current {@link HttpSession}
     * associated with this request or, if if there is no
     * current session and <code>create</code> is true, returns
     * a new session.
     *
     * <p>If <code>create</code> is <code>false</code>
     * and the request has no valid <code>Session</code>,
     * this method returns <code>null</code>.
     *
     * <p>To make sure the session is properly maintained,
     * you must call this method before
     * the response is committed.
     *
     *
     *
     *
     * @param create          <code>true</code> to create
     *                        a new session for this request if necessary;
     *                        <code>false</code> to return <code>null</code>
     *                        if there's no current session
     *
     *
     * @return                 the {@link HttpSession} associated
     *                        with this request or <code>null</code> if
     *                         <code>create</code> is <code>false</code>
     *                        and the request has no valid session
     *
     * @see        #getSession()
     *
     *
     */

    HttpSession getSession(boolean create);
14781#/**
     *
     * Returns the current session associated with this request,
     * or if the request does not have a session, creates one.
     *
     * @return                the {@link HttpSession} associated
     *                        with this request
     *
     * @see        #getSession(boolean)
     *
     */

     HttpSession getSession();
14782#/**
     *
     * Returns the current <code>Session</code>
     * associated with this request or, if if there is no
     * current session and <code>create</code> is true, returns
     * a new session.
     *
     * <p>If <code>create</code> is <code>false</code>
     * and the request has no valid <code>Session</code>,
     * this method returns <code>null</code>.
     *
     * <p>To make sure the session is properly maintained,
     * you must call this method before
     * the response is committed.
     *
     *
     *
     *
     * @param create          <code>true</code> to create
     *                        a new session for this request if necessary;
     *                        <code>false</code> to return <code>null</code>
     *                        if there's no current session
     *
     *
     * @return                 the <code>Session</code> associated
     *                        with this request or <code>null</code> if
     *                         <code>create</code> is <code>false</code>
     *                        and the request has no valid session
     *
     * @see        #getSession()
     *
     * @deprecated use {@link #getSession(boolean)} instead.
     */

    Session getCocoonSession(boolean create);
14783#/**
     *
     * Returns the current session associated with this request,
     * or if the request does not have a session, creates one.
     *
     * @return                the <code>Session</code> associated
     *                        with this request
     *
     * @see        #getSession(boolean)
     *
     * @deprecated use {@link #getSession()} instead.
     */

     Session getCocoonSession();
14784#/**
     *
     * Checks whether the requested session ID is still valid.
     *
     * @return                        <code>true</code> if this
     *                                request has an id for a valid session
     *                                in the current session context;
     *                                <code>false</code> otherwise
     *
     * @see                        #getRequestedSessionId()
     * @see                        #getSession()
     *
     */

    boolean isRequestedSessionIdValid();
14785#/**
     *
     * Checks whether the requested session ID came in as a cookie.
     *
     * @return                        <code>true</code> if the session ID
     *                                came in as a
     *                                cookie; otherwise, <code>false</code>
     *
     *
     * @see                        #getSession()
     *
     */

    boolean isRequestedSessionIdFromCookie();
14786#/**
     *
     * Checks whether the requested session ID came in as part of the
     * request URL.
     *
     * @return                        <code>true</code> if the session ID
     *                                came in as part of a URL; otherwise,
     *                                <code>false</code>
     *
     *
     * @see                        #getSession()
     *
     */

    boolean isRequestedSessionIdFromURL();
14787#/**
     * Redirect to the given URL
     */
    void permanentRedirect(boolean sessionmode, String url) throws IOException, ProcessingException;
14788#/**
	 * Gets the value assigned to a key.
	 * @param key the key to lookup a stored object
	 * @return the value assigned to the key or null if no object can be found
	 */
	public Object get(String key);
14789#/**
     *
     * Returns the time when this session was created, measured
     * in milliseconds since midnight January 1, 1970 GMT.
     *
     * @return                                a <code>long</code> specifying
     *                                         when this session was created,
     *                                        expressed in
     *                                        milliseconds since 1/1/1970 GMT
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     *
     */
    long getCreationTime();
14790#/**
     *
     * Returns a string containing the unique identifier assigned
     * to this session. The identifier is assigned
     * by the context container and is implementation dependent.
     *
     * @return                                a string specifying the identifier
     *                                        assigned to this session
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     *
     */
    String getId();
14791#/**
     *
     * Returns the last time the client sent a request associated with
     * this session, as the number of milliseconds since midnight
     * January 1, 1970 GMT.
     *
     * <p>Actions that your application takes, such as getting or setting
     * a value associated with the session, do not affect the access
     * time.
     *
     * @return                                a <code>long</code>
     *                                        representing the last time
     *                                        the client sent a request associated
     *                                        with this session, expressed in
     *                                        milliseconds since 1/1/1970 GMT
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     *
     */

    long getLastAccessedTime();
14792#/**
     *
     * Specifies the time, in seconds, between client requests before the
     * contextcontainer will invalidate this session.  A negative time
     * indicates the session should never timeout.
     *
     * @param interval                An integer specifying the number
     *                                 of seconds
     *
     */
    void setMaxInactiveInterval(int interval);
14793#/**
    * Returns the maximum time interval, in seconds, that
    * the context container will keep this session open between
    * client accesses. After this interval, the context container
    * will invalidate the session.  The maximum time interval can be set
    * with the <code>setMaxInactiveInterval</code> method.
    * A negative time indicates the session should never timeout.
    *
    *
    * @return                an integer specifying the number of
    *                        seconds this session remains open
    *                        between client requests
    *
    * @see                #setMaxInactiveInterval(int)
    *
    *
    */
    int getMaxInactiveInterval();
14794#/**
     *
     * Returns the object bound with the specified name in this session, or
     * <code>null</code> if no object is bound under the name.
     *
     * @param name                a string specifying the name of the object
     *
     * @return                        the object with the specified name
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     *
     */
    Object getAttribute(String name);
14795#/**
     *
     * Returns an <code>Enumeration</code> of <code>String</code> objects
     * containing the names of all the objects bound to this session.
     *
     * @return                        an <code>Enumeration</code> of
     *                                <code>String</code> objects specifying the
     *                                names of all the objects bound to
     *                                this session
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     *
     */
    Enumeration getAttributeNames();
14796#/**
     * Binds an object to this session, using the name specified.
     * If an object of the same name is already bound to the session,
     * the object is replaced.
     *
     *
     * @param name                        the name to which the object is bound;
     *                                        cannot be null
     *
     * @param value                        the object to be bound; cannot be null
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     *
     */
    void setAttribute(String name, Object value);
14797#/**
     *
     * Removes the object bound with the specified name from
     * this session. If the session does not have an object
     * bound with the specified name, this method does nothing.
     *
     *
     * @param name                                the name of the object to
     *                                                remove from this session
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     */
    void removeAttribute(String name);
14798#/**
     * Utility method for getting a <code>Map</code> view of the request attributes.
     * Returns a <code>Map</code> with attributes.
     *
     * @return                a <code>Map</code> containing the request attributes.
     *
     * @since 2.2
     */
    Map getAttributes();
14799#/**
     *
     * Invalidates this session
     * to it.
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        already invalidated session
     *
     */
    void invalidate();
14800#/**
     *
     * Returns <code>true</code> if the client does not yet know about the
     * session or if the client chooses not to join the session.  For
     * example, if the server used only cookie-based sessions, and
     * the client had disabled the use of cookies, then a session would
     * be new on each request.
     *
     * @return                                 <code>true</code> if the
     *                                        server has created a session,
     *                                        but the client has not yet joined
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        already invalidated session
     *
     */
    boolean isNew();
14801#private ObjectModelHelper() {
        // Forbid instantiation
    }
14802#/**
     * Return {@link Request} object stored in the provided
     * <code>objectModel</code> map.
     *
     * @param objectModel current objectModel map
     * @return request retrieved from the objectModel map
     */
    public static Request getRequest(Map objectModel) {
        return (Request) objectModel.get(REQUEST_OBJECT);
    }
14803#/**
     * Return {@link Response} object stored in the provided
     * <code>objectModel</code> map.
     *
     * @param objectModel current objectModel map
     * @return response retrieved from the objectModel map
     */
    public static Response getResponse(Map objectModel) {
        return (Response) objectModel.get(RESPONSE_OBJECT);
    }
14804#/**
     * Return {@link Context} object stored in the provided
     * <code>objectModel</code> map.
     *
     * @param objectModel current objectModel map
     * @return context retrieved from the objectModel map
     */
    public static Context getContext(Map objectModel) {
        return (Context) objectModel.get(CONTEXT_OBJECT);
    }
14805#/**
     * Return <code>expires</code> object stored in the provided
     * <code>objectModel</code> map.
     *
     * <p>
     * <code>expires</code> is an expiration timestamp. This object
     * is present in the <code>objectModel</code> only in the context
     * of a pipeline with configured expires parameter.
     *
     * @param objectModel current objectModel map
     * @return expiration timestamp retrieved from the objectModel map
     */
    public static Long getExpires(Map objectModel) {
        return (Long) objectModel.get(EXPIRES_OBJECT);
    }
14806#/**
     * Return {@link Throwable} object stored in the provided
     * <code>objectModel</code> map.
     *
     * <p>
     * <code>Throwable</code> object is present in the objectModel
     * only within a <code>&lt;map:handle-errors&gt;</code> section
     * of the sitemap. When outside of this section, null is returned.
     *
     * @param objectModel current objectModel map
     * @return throwable retrieved from the objectModel map
     */
    public static Throwable getThrowable(Map objectModel) {
        return (Throwable) objectModel.get(THROWABLE_OBJECT);
    }
14807#/**
     *
     * Specifies a comment that describes a cookie's purpose.
     * The comment is useful if the browser presents the cookie
     * to the user. Comments
     * are not supported by Netscape Version 0 cookies.
     *
     * @param purpose		a <code>String</code> specifying the comment
     *				to display to the user
     *
     * @see #getComment()
     *
     */

    void setComment(String purpose);
14808#/**
     * Returns the comment describing the purpose of this cookie, or
     * <code>null</code> if the cookie has no comment.
     *
     * @return			a <code>String</code> containing the comment,
     *				or <code>null</code> if none
     *
     * @see #setComment(String)
     *
     */

    String getComment();
14809#/**
     *
     * Specifies the domain within which this cookie should be presented.
     *
     * <p>The form of the domain name is specified by RFC 2109. A domain
     * name begins with a dot (<code>.foo.com</code>) and means that
     * the cookie is visible to servers in a specified Domain Name System
     * (DNS) zone (for example, <code>www.foo.com</code>, but not
     * <code>a.b.foo.com</code>). By default, cookies are only returned
     * to the server that sent them.
     *
     *
     * @param pattern		a <code>String</code> containing the domain name
     *				within which this cookie is visible;
     *				form is according to RFC 2109
     *
     * @see #getDomain()
     *
     */

    void setDomain(String pattern);
14810#/**
     * Returns the domain name set for this cookie. The form of
     * the domain name is set by RFC 2109.
     *
     * @return			a <code>String</code> containing the domain name
     *
     * @see #setDomain(String)
     *
     */

    String getDomain();
14811#/**
     * Sets the maximum age of the cookie in seconds.
     *
     * <p>A positive value indicates that the cookie will expire
     * after that many seconds have passed. Note that the value is
     * the <i>maximum</i> age when the cookie will expire, not the cookie's
     * current age.
     *
     * <p>A negative value means
     * that the cookie is not stored persistently and will be deleted
     * when the Web browser exits. A zero value causes the cookie
     * to be deleted.
     *
     * @param expiry		an integer specifying the maximum age of the
     * 				cookie in seconds; if negative, means
     *				the cookie is not stored; if zero, deletes
     *				the cookie
     *
     *
     * @see #getMaxAge()
     *
     */

    void setMaxAge(int expiry);
14812#/**
     * Returns the maximum age of the cookie, specified in seconds,
     * By default, <code>-1</code> indicating the cookie will persist
     * until browser shutdown.
     *
     *
     * @return			an integer specifying the maximum age of the
     *				cookie in seconds; if negative, means
     *				the cookie persists until browser shutdown
     *
     *
     * @see #setMaxAge(int)
     *
     */

    int getMaxAge();
14813#/**
     * Specifies a path for the cookie
     * to which the client should return the cookie.
     *
     * <p>The cookie is visible to all the pages in the directory
     * you specify, and all the pages in that directory's subdirectories.
     * A cookie's path must include the servlet that set the cookie,
     * for example, <i>/catalog</i>, which makes the cookie
     * visible to all directories on the server under <i>/catalog</i>.
     *
     * <p>Consult RFC 2109 (available on the Internet) for more
     * information on setting path names for cookies.
     *
     *
     * @param uri		a <code>String</code> specifying a path
     *
     *
     * @see #getPath()
     *
     */

    void setPath(String uri);
14814#/**
     * Returns the path on the server
     * to which the browser returns this cookie. The
     * cookie is visible to all subpaths on the server.
     *
     *
     * @return		a <code>String</code> specifying a path that contains
     *			a servlet name, for example, <i>/catalog</i>
     *
     * @see #setPath(String)
     *
     */

    String getPath();
14815#/**
     * Indicates to the browser whether the cookie should only be sent
     * using a secure protocol, such as HTTPS or SSL.
     *
     * <p>The default value is <code>false</code>.
     *
     * @param flag	if <code>true</code>, sends the cookie from the browser
     *			to the server using only when using a secure protocol;
     *			if <code>false</code>, sent on any protocol
     *
     * @see #getSecure()
     *
     */

    void setSecure(boolean flag);
14816#/**
     * Returns <code>true</code> if the browser is sending cookies
     * only over a secure protocol, or <code>false</code> if the
     * browser can send cookies using any protocol.
     *
     * @return		<code>true</code> if the browser can use
     *			any standard protocol; otherwise, <code>false</code>
     *
     * @see #setSecure(boolean)
     *
     */

    boolean getSecure();
14817#/**
     * Returns the name of the cookie. The name cannot be changed after
     * creation.
     *
     * @return		a <code>String</code> specifying the cookie's name
     *
     */

    String getName();
14818#/**
     *
     * Assigns a new value to a cookie after the cookie is created.
     * If you use a binary value, you may want to use BASE64 encoding.
     *
     * <p>With Version 0 cookies, values should not contain white
     * space, brackets, parentheses, equals signs, commas,
     * double quotes, slashes, question marks, at signs, colons,
     * and semicolons. Empty values may not behave the same way
     * on all browsers.
     *
     * @param newValue		a <code>String</code> specifying the new value
     *
     *
     * @see #getValue()
     * @see Cookie
     *
     */

    void setValue(String newValue);
14819#/**
     * Returns the value of the cookie.
     *
     * @return			a <code>String</code> containing the cookie's
     *				present value
     *
     * @see #setValue(String)
     * @see Cookie
     *
     */

    String getValue();
14820#/**
     * Returns the version of the protocol this cookie complies
     * with. Version 1 complies with RFC 2109,
     * and version 0 complies with the original
     * cookie specification drafted by Netscape. Cookies provided
     * by a browser use and identify the browser's cookie version.
     *
     *
     * @return			0 if the cookie complies with the
     *				original Netscape specification; 1
     *				if the cookie complies with RFC 2109
     *
     * @see #setVersion(int)
     *
     */

    int getVersion();
14821#/**
     * Sets the version of the cookie protocol this cookie complies
     * with. Version 0 complies with the original Netscape cookie
     * specification. Version 1 complies with RFC 2109.
     *
     * <p>Since RFC 2109 is still somewhat new, consider
     * version 1 as experimental; do not use it yet on production sites.
     *
     *
     * @param v			0 if the cookie should comply with
     *				the original Netscape specification;
     *				1 if the cookie should comply with RFC 2109
     *
     * @see #getVersion()
     *
     */

    void setVersion(int v);
14822#/**
     * Returns the name of the charset used for
     * the MIME body sent in this response.
     *
     * <p>If no charset has been assigned, it is implicitly
     * set to <code>ISO-8859-1</code> (<code>Latin-1</code>).
     *
     * <p>See RFC 2047 (http://ds.internic.net/rfc/rfc2045.txt)
     * for more information about character encoding and MIME.
     *
     * @return                a <code>String</code> specifying the
     *                        name of the charset, for
     *                        example, <code>ISO-8859-1</code>
     *
     */

    String getCharacterEncoding();
14823#/**
     * Sets the locale of the response, setting the headers (including the
     * Content-Type's charset) as appropriate.  By default, the response locale
     * is the default locale for the server.
     *
     * @param loc  the locale of the response
     *
     * @see                 #getLocale()
     *
     */

    void setLocale(Locale loc);
14824#/**
     * Returns the locale assigned to the response.
     *
     *
     * @see                 #setLocale(Locale)
     *
     */

    Locale getLocale();
14825#/**
     * Constructs a cookie with a specified name and value.
     *
     * <p>The name must conform to RFC 2109. That means it can contain
     * only ASCII alphanumeric characters and cannot contain commas,
     * semicolons, or white space or begin with a $ character. The cookie's
     * name cannot be changed after creation.
     *
     * <p>The value can be anything the server chooses to send. Its
     * value is probably of interest only to the server. The cookie's
     * value can be changed after creation with the
     * <code>setValue</code> method.
     *
     * <p>By default, cookies are created according to the Netscape
     * cookie specification. The version can be changed with the
     * <code>setVersion</code> method.
     *
     *
     * @param name                         a <code>String</code> specifying the name of the cookie
     *
     * @param value                        a <code>String</code> specifying the value of the cookie
     *
     * @throws IllegalArgumentException        if the cookie name contains illegal characters
     *                                        (for example, a comma, space, or semicolon)
     *                                        or it is one of the tokens reserved for use
     *                                        by the cookie protocol
     *
     */
    javax.servlet.http.Cookie createCookie(String name, String value);
14826#/**
     * Adds the specified cookie to the response.  This method can be called
     * multiple times to set more than one cookie.
     *
     * @param cookie the Cookie to return to the client
     *
     */

    void addCookie(javax.servlet.http.Cookie cookie);
14827#/**
     * Constructs a cookie with a specified name and value.
     *
     * <p>The name must conform to RFC 2109. That means it can contain
     * only ASCII alphanumeric characters and cannot contain commas,
     * semicolons, or white space or begin with a $ character. The cookie's
     * name cannot be changed after creation.
     *
     * <p>The value can be anything the server chooses to send. Its
     * value is probably of interest only to the server. The cookie's
     * value can be changed after creation with the
     * <code>setValue</code> method.
     *
     * <p>By default, cookies are created according to the Netscape
     * cookie specification. The version can be changed with the
     * <code>setVersion</code> method.
     *
     *
     * @param name                         a <code>String</code> specifying the name of the cookie
     *
     * @param value                        a <code>String</code> specifying the value of the cookie
     *
     * @throws IllegalArgumentException        if the cookie name contains illegal characters
     *                                        (for example, a comma, space, or semicolon)
     *                                        or it is one of the tokens reserved for use
     *                                        by the cookie protocol
     *
     * @deprecated use {@link #createCookie(String, String)} instead.
     */
    Cookie createCocoonCookie(String name, String value);
14828#/**
     * Adds the specified cookie to the response.  This method can be called
     * multiple times to set more than one cookie.
     *
     * @param cookie the Cookie to return to the client
     *
     * @deprecated use {@link #addCookie(javax.servlet.http.Cookie)} instead.
     */

    void addCookie(Cookie cookie);
14829#/**
     * Returns a boolean indicating whether the named response header
     * has already been set.
     *
     * @param        name        the header name
     * @return                <code>true</code> if the named response header
     *                        has already been set;
     *                         <code>false</code> otherwise
     */

    boolean containsHeader(String name);
14830#/**
     * Encodes the specified URL by including the session ID in it,
     * or, if encoding is not needed, returns the URL unchanged.
     * The implementation of this method includes the logic to
     * determine whether the session ID needs to be encoded in the URL.
     * For example, if the browser supports cookies, or session
     * tracking is turned off, URL encoding is unnecessary.
     *
     * <p>For robust session tracking, all URLs emitted by a servlet
     * should be run through this
     * method.  Otherwise, URL rewriting cannot be used with browsers
     * which do not support cookies.
     *
     * @param        url        the url to be encoded.
     * @return                the encoded URL if encoding is needed;
     *                         the unchanged URL otherwise.
     */

    String encodeURL(String url);
14831#/**
     *
     * Sets a response header with the given name and
     * date-value.  The date is specified in terms of
     * milliseconds since the epoch.  If the header had already
     * been set, the new value overwrites the previous one.  The
     * <code>containsHeader</code> method can be used to test for the
     * presence of a header before setting its value.
     *
     * @param        name        the name of the header to set
     * @param        date        the assigned date value
     *
     * @see #containsHeader(String)
     * @see #addDateHeader(String, long)
     */

    void setDateHeader(String name, long date);
14832#/**
     *
     * Adds a response header with the given name and
     * date-value.  The date is specified in terms of
     * milliseconds since the epoch.  This method allows response headers
     * to have multiple values.
     *
     * @param        name        the name of the header to set
     * @param        date        the additional date value
     *
     * @see #setDateHeader(String, long)
     */

    void addDateHeader(String name, long date);
14833#/**
     *
     * Sets a response header with the given name and value.
     * If the header had already been set, the new value overwrites the
     * previous one.  The <code>containsHeader</code> method can be
     * used to test for the presence of a header before setting its
     * value.
     *
     * @param        name        the name of the header
     * @param        value        the header value
     *
     * @see #containsHeader(String)
     * @see #addHeader(String, String)
     */

    void setHeader(String name, String value);
14834#/**
     * Adds a response header with the given name and value.
     * This method allows response headers to have multiple values.
     *
     * @param        name        the name of the header
     * @param        value        the additional header value
     *
     * @see #setHeader(String, String)
     */

    void addHeader(String name, String value);
14835#/**
     * Sets a response header with the given name and
     * int value. If the header had already
     * been set, the new value overwrites the previous one.  The
     * <code>containsHeader</code> method can be used to test for the
     * presence of a header before setting its value.
     *
     * @param        name        the name of the header to set
     * @param        value       the assigned int value
     *
     * @see #containsHeader(String)
     * @see #addIntHeader(String, int)
     */

    void setIntHeader(String name, int value);
14836#/**
     * Adds a response header with the given name and
     * int value. This method allows response headers
     * to have multiple values.
     *
     * @param        name        the name of the header to set
     * @param        value       the additional int value
     *
     * @see #setIntHeader(String, int)
     */

    void addIntHeader(String name, int value);
14837#/**
     * Generate the XML and stream it into the pipeline
     */
    void generate()
    throws IOException, SAXException, ProcessingException;
14838#/**
     * Generate the response.
     */
    void generate()
    throws IOException, SAXException, ProcessingException;
14839#/**
     * @return the time the read source was last modified or 0 if it is not
     *         possible to detect
     */
    long getLastModified();
14840#/**
     * Clean up the component.
     */
    void dispose();
14841#/**
     * Set the {@link OutputStream} where the requested resource should
     * be serialized.
     *
     * @param out  The <code>OutputStream</code> target for the rendered results.
     *
     * @throws IOException if the stream can't be used.
     */
    void setOutputStream(OutputStream out) throws IOException;
14842#/**
     * Obtain the media type for the results being serialized. The
     * returned value is used to set <code>Content-Type</code> header
     * in the response, unless it was overwritten in the sitemap.
     * It helps responsible browsers to identify how to show the
     * information to the user.
     *
     * <p>
     * Example content type value: <code>text/html; charset=utf-8</code>.
     * </p>
     *
     * <p>
     * <strong>Warning:</strong>Microsoft Internet Explorer is a poor
     * netizen and does not always respect this information.  I am talking
     * about Microsoft's InternetExplorer.  It will first try to use the file
     * extension of the resource to determine the mime type, and then if that
     * fails it will fall back to respecting the mime type.  For that reason it
     * is essential that you also practice good netizen habits and make the
     * file extension and the mime type agree.  One example is the PDF
     * document.  In order for Microsoft to treat a result set as a PDF
     * document you must have the url end with ".pdf" as well as set the mime
     * type to "application/pdf".  Internet Explorer will fail if you try to
     * send the document "badhabit.xml?view=pdf" rendered as a PDF document.
     * It is because the file extension ".xml" will be remapped to "text/xml"
     * even if you set the mime type correctly.
     * </p>
     *
     * <p>
     * You may have some incorrectly configured servers that will work for one
     * browser and not the other because the mime-type and file extension do
     * not agree.  The world would be much simpler if all browsers blindly
     * accepted the mime type.  Just be aware of this issue when you are
     * creating your sitemap and serializing your results.
     *
     * @return the media type for the results.
     */
    String getMimeType();
14843#/**
     * Test if the component needs the content length set.
     * <p>
     * Most types of documents don't really care what the content length is,
     * so it is usually safe to leave the results of this method to false.  It
     * should be noted that the Adobe Acrobat Reader plugin for Microsoft
     * Internet Explorer has a bug that wasn't fixed until version 7.  The bug
     * prevents the PDF document from displaying correctly.  It will look like
     * an empty document or something similar.  So the general rule of thumb
     * for explicitly setting the content length is:
     * </p>
     * <ul>
     * <li>If it is a PDF document, always set content length (might require
     *     the document to be cached to get the number of bytes)</li>
     * <li>If you are writing a Reader and you have the content length, set
     *     it.</li>
     * <li>Otherwise it is safe to return false here.</li>
     * </ul>
     *
     * @return <code>true</code> if the content length needs to be set.
     */
    boolean shouldSetContentLength();
14844#/**
     * The Sitemap will call the setup() method to prepare the component for
     * use.  This is where you start the process of getting your information
     * ready to generate your results.  See {@link org.apache.cocoon.environment.ObjectModelHelper} for help with the <code>objectModel</code>.
     *
     * @param resolver     The <code>SourceResolver</code> to find resources within your context.
     * @param objectModel  A <code>java.util.Map</code> that contains the request and session information.
     * @param src          The value of the "src" attribute in the sitemap.
     * @param par          The sitemap parameters passed into your component.
     *
     * @throws SAXException if there is a problem reading a SAX stream.
     * @throws IOException  if there is a problem reading files.
     * @throws ProcessingException if there is any other unexpected problem.
     */
    void setup(SourceResolver resolver, Map objectModel, String src, Parameters par) 
    throws ProcessingException, SAXException, IOException;
14845#/**
     * Handle an error.
     * @return true if error was handled.
     */
    public boolean handleError(Exception e) throws Exception;
14846#/**
     * Build error handling pipeline.
     * @return error handling pipeline, or null if error was not handled.
     */
    public ProcessingPipeline prepareErrorPipeline(Exception e) throws Exception;
14847#/**
     * Return the list of locations.
     *
     * @return a list of locations, possibly empty but never null.
     */
    public List getLocations();
14848#/**
     * Add a location to the current list of locations.
     * <p>
     * Implementations are free to filter locations that can be added (e.g. {@link Location#UNKNOWN}),
     * and there is therefore no guarantee that the given location will actually be added to the list.
     * Filtered locations are silently ignored.
     *
     * @param location the location to be added.
     */
    public void addLocation(Location location);
14849#/**
     * Get the description of this location
     *
     * @return the description (can be <code>null</code>)
     */
    public String getDescription();
14850#/**
     * Get the URI of this location
     *
     * @return the URI (<code>null</code> if unknown).
     */
    public String getURI();
14851#/**
     * Get the line number of this location
     *
     * @return the line number (<code>-1</code> if unknown)
     */
    public int getLineNumber();
14852#/**
     * Get the column number of this location
     *
     * @return the column number (<code>-1</code> if unknown)
     */
    public int getColumnNumber();
14853#/**
     * Build a location for a given URI, with unknown line and column numbers.
     *
     * @param uri the resource URI
     */
    public LocationImpl(String description, String uri) {
        this(description, uri, -1, -1);
    }
14854#/**
     * Build a location for a given URI and line and columb numbers.
     *
     * @param uri the resource URI
     * @param line the line number (starts at 1)
     * @param column the column number (starts at 1)
     */
    public LocationImpl(String description, String uri, int line, int column) {
        if (uri == null || uri.length() == 0) {
            this.uri = null;
            this.line = -1;
            this.column = -1;
        } else {
            this.uri = uri;
            this.line = line;
            this.column = column;
        }

        if (description != null && description.length() == 0) {
            description = null;
        }
        this.description = description;
    }
14855#/**
     * Copy constructor.
     *
     * @param location the location to be copied
     */
    public LocationImpl(Location location) {
        this(location.getDescription(), location.getURI(), location.getLineNumber(), location.getColumnNumber());
    }
14856#/**
     * Create a location from an existing one, but with a different description
     */
    public LocationImpl(String description, Location location) {
        this(description, location.getURI(), location.getLineNumber(), location.getColumnNumber());
    }
14857#/**
     * Obtain a <code>LocationImpl</code> from a {@link Location}. If <code>location</code> is
     * already a <code>LocationImpl</code>, it is returned, otherwise it is copied.
     * <p>
     * This method is useful when an immutable and serializable location is needed, such as in locatable
     * exceptions.
     *
     * @param location the location
     * @return an immutable and serializable version of <code>location</code>
     */
    public static LocationImpl get(Location location) {
        if (location instanceof LocationImpl) {
            return (LocationImpl)location;
        } else if (location == null) {
            return UNKNOWN;
        } else {
            return new LocationImpl(location);
        }
    }
14858#/**
     * Get the description of this location
     *
     * @return the description (can be <code>null</code>)
     */
    public String getDescription() {
        return this.description;
    }
14859#/**
     * Get the URI of this location
     *
     * @return the URI (<code>null</code> if unknown).
     */
    public String getURI() {
        return this.uri;
    }
14860#/**
     * Get the line number of this location
     *
     * @return the line number (<code>-1</code> if unknown)
     */
    public int getLineNumber() {
        return this.line;
    }
14861#/**
     * Get the column number of this location
     *
     * @return the column number (<code>-1</code> if unknown)
     */
    public int getColumnNumber() {
        return this.column;
    }
14862#public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }

        if (obj instanceof Location) {
            Location other = (Location) obj;
            return this.line == other.getLineNumber() &&
                    this.column == other.getColumnNumber() &&
                    ObjectUtils.equals(this.uri, other.getURI()) &&
                    ObjectUtils.equals(this.description, other.getDescription());
        }

        return false;
    }
14863#public int hashCode() {
        int hash = line ^ column;
        if (uri != null) hash ^= uri.hashCode();
        if (description != null) hash ^= description.hashCode();

        return hash;
    }
14864#public String toString() {
        return LocationUtils.toString(this);
    }
14865#/**
     * Ensure serialized unknown location resolve to {@link Location#UNKNOWN}.
     */
    private Object readResolve() {
        return this.equals(Location.UNKNOWN) ? Location.UNKNOWN : this;
    }
14866#// Private constructor, we only have static methods
    private LocationAttributes() {
        // Nothing
    }
14867#/**
     * Add location attributes to a set of SAX attributes.
     *
     * @param locator the <code>Locator</code> (can be null)
     * @param attrs the <code>Attributes</code> where locator information should be added
     */
    public static Attributes addLocationAttributes(Locator locator, Attributes attrs) {
        if (locator == null || attrs.getIndex(URI, SRC_ATTR) != -1) {
            // No location information known, or already has it
            return attrs;
        }

        // Get an AttributeImpl so that we can add new attributes.
        AttributesImpl newAttrs = attrs instanceof AttributesImpl ?
            (AttributesImpl)attrs : new AttributesImpl(attrs);

        newAttrs.addAttribute(URI, SRC_ATTR, Q_SRC_ATTR, "CDATA", locator.getSystemId());
        newAttrs.addAttribute(URI, LINE_ATTR, Q_LINE_ATTR, "CDATA", Integer.toString(locator.getLineNumber()));
        newAttrs.addAttribute(URI, COL_ATTR, Q_COL_ATTR, "CDATA", Integer.toString(locator.getColumnNumber()));

        return newAttrs;
    }
14868#/**
     * Returns the {@link Location} of an element (SAX flavor).
     *
     * @param attrs the element's attributes that hold the location information
     * @param description a description for the location (can be null)
     * @return a {@link Location} object
     */
    public static Location getLocation(Attributes attrs, String description) {
        String src = attrs.getValue(URI, SRC_ATTR);
        if (src == null) {
            return Location.UNKNOWN;
        }

        return new LocationImpl(description, src, getLine(attrs), getColumn(attrs));
    }
14869#/**
     * Returns the location of an element (SAX flavor). If the location is to be kept
     * into an object built from this element, consider using {@link #getLocation(Attributes, String)}
     * and the {@link Locatable} interface.
     *
     * @param attrs the element's attributes that hold the location information
     * @return a location string as defined by {@link Location#toString()}.
     */
    public static String getLocationString(Attributes attrs) {
        String src = attrs.getValue(URI, SRC_ATTR);
        if (src == null) {
            return LocationUtils.UNKNOWN_STRING;
        }

        return src + ":" + attrs.getValue(URI, LINE_ATTR) + ":" + attrs.getValue(URI, COL_ATTR);
    }
14870#/**
     * Returns the URI of an element (SAX flavor)
     *
     * @param attrs the element's attributes that hold the location information
     * @return the element's URI or "<code>[unknown location]</code>" if <code>attrs</code>
     *         has no location information.
     */
    public static String getURI(Attributes attrs) {
        String src = attrs.getValue(URI, SRC_ATTR);
        return src != null ? src : LocationUtils.UNKNOWN_STRING;
    }
14871#/**
     * Returns the line number of an element (SAX flavor)
     *
     * @param attrs the element's attributes that hold the location information
     * @return the element's line number or <code>-1</code> if <code>attrs</code>
     *         has no location information.
     */
    public static int getLine(Attributes attrs) {
        String line = attrs.getValue(URI, LINE_ATTR);
        return line != null ? Integer.parseInt(line) : -1;
    }
14872#/**
     * Returns the column number of an element (SAX flavor)
     *
     * @param attrs the element's attributes that hold the location information
     * @return the element's column number or <code>-1</code> if <code>attrs</code>
     *         has no location information.
     */
    public static int getColumn(Attributes attrs) {
        String col = attrs.getValue(URI, COL_ATTR);
        return col != null ? Integer.parseInt(col) : -1;
    }
14873#/**
     * Returns the {@link Location} of an element (DOM flavor).
     *
     * @param elem the element that holds the location information
     * @param description a description for the location (if <code>null</code>, the element's name is used)
     * @return a {@link Location} object
     */
    public static Location getLocation(Element elem, String description) {
        Attr srcAttr = elem.getAttributeNodeNS(URI, SRC_ATTR);
        if (srcAttr == null) {
            return Location.UNKNOWN;
        }

        return new LocationImpl(description == null ? "<" + elem.getNodeName() + ">" : description,
                                srcAttr.getValue(), getLine(elem), getColumn(elem));
    }
14874#/**
     * Same as <code>getLocation(elem, null)</code>.
     */
    public static Location getLocation(Element elem) {
        return getLocation(elem, null);
    }
14875#/**
     * Returns the location of an element that has been processed by this pipe (DOM flavor).
     * If the location is to be kept into an object built from this element, consider using
     * {@link #getLocation(Element)} and the {@link Locatable} interface.
     *
     * @param elem the element that holds the location information
     * @return a location string as defined by {@link Location#toString()}.
     */
    public static String getLocationString(Element elem) {
        Attr srcAttr = elem.getAttributeNodeNS(URI, SRC_ATTR);
        if (srcAttr == null) {
            return LocationUtils.UNKNOWN_STRING;
        }

        return srcAttr.getValue() + ":" + elem.getAttributeNS(URI, LINE_ATTR) + ":" + elem.getAttributeNS(URI, COL_ATTR);
    }
14876#/**
     * Returns the URI of an element (DOM flavor)
     *
     * @param elem the element that holds the location information
     * @return the element's URI or "<code>[unknown location]</code>" if <code>elem</code>
     *         has no location information.
     */
    public static String getURI(Element elem) {
        Attr attr = elem.getAttributeNodeNS(URI, SRC_ATTR);
        return attr != null ? attr.getValue() : LocationUtils.UNKNOWN_STRING;
    }
14877#/**
     * Returns the line number of an element (DOM flavor)
     *
     * @param elem the element that holds the location information
     * @return the element's line number or <code>-1</code> if <code>elem</code>
     *         has no location information.
     */
    public static int getLine(Element elem) {
        Attr attr = elem.getAttributeNodeNS(URI, LINE_ATTR);
        return attr != null ? Integer.parseInt(attr.getValue()) : -1;
    }
14878#/**
     * Returns the column number of an element (DOM flavor)
     *
     * @param elem the element that holds the location information
     * @return the element's column number or <code>-1</code> if <code>elem</code>
     *         has no location information.
     */
    public static int getColumn(Element elem) {
        Attr attr = elem.getAttributeNodeNS(URI, COL_ATTR);
        return attr != null ? Integer.parseInt(attr.getValue()) : -1;
    }
14879#/**
     * Remove the location attributes from a DOM element.
     *
     * @param elem the element to remove the location attributes from.
     * @param recurse if <code>true</code>, also remove location attributes on descendant elements.
     */
    public static void remove(Element elem, boolean recurse) {
        elem.removeAttributeNS(URI, SRC_ATTR);
        elem.removeAttributeNS(URI, LINE_ATTR);
        elem.removeAttributeNS(URI, COL_ATTR);
        if (recurse) {
            NodeList children = elem.getChildNodes();
            for (int i = 0; i < children.getLength(); i++) {
                Node child = children.item(i);
                if (child.getNodeType() == Node.ELEMENT_NODE) {
                    remove((Element)child, recurse);
                }
            }
        }
    }
14880#/**
         * Create a filter. It has to be chained to another handler to be really useful.
         */
        public Pipe() {
        }
14881#/**
         * Create a filter that is chained to another handler.
         * @param next the next handler in the chain.
         */
        public Pipe(ContentHandler next) {
            nextHandler = next;
        }
14882#public void setDocumentLocator(Locator locator) {
            this.locator = locator;
            nextHandler.setDocumentLocator(locator);
        }
14883#public void startDocument() throws SAXException {
            nextHandler.startDocument();
            nextHandler.startPrefixMapping(LocationAttributes.PREFIX, LocationAttributes.URI);
        }
14884#public void endDocument() throws SAXException {
            endPrefixMapping(LocationAttributes.PREFIX);
            nextHandler.endDocument();
        }
14885#public void startElement(String uri, String loc, String raw, Attributes attrs) throws SAXException {
            // Add location attributes to the element
            nextHandler.startElement(uri, loc, raw, LocationAttributes.addLocationAttributes(locator, attrs));
        }
14886#public void endElement(String arg0, String arg1, String arg2) throws SAXException {
            nextHandler.endElement(arg0, arg1, arg2);
        }
14887#public void startPrefixMapping(String arg0, String arg1) throws SAXException {
            nextHandler.startPrefixMapping(arg0, arg1);
        }
14888#public void endPrefixMapping(String arg0) throws SAXException {
            nextHandler.endPrefixMapping(arg0);
        }
14889#public void characters(char[] arg0, int arg1, int arg2) throws SAXException {
            nextHandler.characters(arg0, arg1, arg2);
        }
14890#public void ignorableWhitespace(char[] arg0, int arg1, int arg2) throws SAXException {
            nextHandler.ignorableWhitespace(arg0, arg1, arg2);
        }
14891#public void processingInstruction(String arg0, String arg1) throws SAXException {
            nextHandler.processingInstruction(arg0, arg1);
        }
14892#public void skippedEntity(String arg0) throws SAXException {
            nextHandler.skippedEntity(arg0);
        }
14893#/**
     * Get the raw message of the exception (the one used in the constructor)
     *
     * @return the raw message
     */
    public String getRawMessage();
14894#public LocatedException(String message) {
        this(message, null, null);
    }
14895#public LocatedException(String message, Throwable cause) {
        this(message, cause, null);
    }
14896#public LocatedException(String message, Location location) {
        this(message, null, location);
    }
14897#public LocatedException(String message, Throwable cause, Location location) {
        super(message, cause);
        ensureCauseChainIsSet(cause);
        addCauseLocations(this, cause);
        addLocation(location);
    }
14898#/**
     * Crawl the cause chain and ensure causes are properly set using {@link Throwable#initCause}.
     * This is needed because some exceptions (e.g. SAXException) don't have a {@link Throwable#getCause}
     * that is used to print stacktraces.
     */
    public static void ensureCauseChainIsSet(Throwable thr) {
        // Loop either until null or encountering exceptions that use this method.
        while (thr != null && !(thr instanceof LocatedRuntimeException) && !(thr instanceof LocatedException)) {
            Throwable parent = ExceptionUtils.getCause(thr);
            if (thr.getCause() == null && parent != null) {
                thr.initCause(parent);
            }
            thr = parent;
        }
    }
14899#/**
     * Add to the location stack all locations of an exception chain. This allows to have all possible
     * location information in the stacktrace, as some exceptions like SAXParseException don't output
     * their location in printStackTrace().
     * <p>
     * Traversal of the call chain stops at the first <code>Locatable</code> exception which is supposed
     * to handle the loction of its causes by itself.
     * <p>
     * This method is static as a convenience for {@link LocatedRuntimeException other implementations}
     * of locatable exceptions.
     *
     * @param self the current locatable exception
     * @param cause a cause of <code>self</code>
     */
    public static void addCauseLocations(MultiLocatable self, Throwable cause) {
        if (cause == null || cause instanceof Locatable) {
            // Locatable handles its location itself
            return;
        }

        // Add parent location first
        addCauseLocations(self, ExceptionUtils.getCause(cause));
        // then ourselve's
        Location loc = LocationUtils.getLocation(cause);
        if (LocationUtils.isKnown(loc)) {
            // Get the exception's short name
            String name = cause.getClass().getName();
            int pos = name.lastIndexOf('.');
            if (pos != -1) {
                name = name.substring(pos+1);
            }
            loc = new LocationImpl("[" + name + "]", loc.getURI(), loc.getLineNumber(), loc.getColumnNumber());
            self.addLocation(loc);
        }
    }
14900#public Location getLocation() {
        return locations == null ? null : (Location) locations.get(0);
    }
14901#public List getLocations() {
        return locations == null ? Collections.EMPTY_LIST : locations;
    }
14902#public String getRawMessage() {
        return super.getMessage();
    }
14903#/**
     * Standard way of building the message of a {@link LocatableException}, as a Java-like
     * stack trace of locations.
     *
     * @param message the exception's message, given by <code>super.getMessage()</code> (can be null)
     * @param locations the location list (can be null)
     *
     * @return the message, or <code>null</code> no message and locations were given.
     */
    public static String getMessage(String message, List locations) {
        if (locations == null || locations.isEmpty()) {
            return message;
        }

        // Produce a Java-like stacktrace with locations
        StringBuffer buf = message == null ? new StringBuffer() : new StringBuffer(message);
        for (int i = 0; i < locations.size(); i++) {
            buf.append("\n\tat ").append(LocationUtils.toString((Location)locations.get(i)));
        }
        return buf.toString();
    }
14904#public String getMessage() {
        return getMessage(super.getMessage(), locations);
    }
14905#public void addLocation(Location loc) {
        if (LocationUtils.isUnknown(loc)) {
            return;
        }

        if (locations == null) {
            this.locations = new ArrayList(1); // Start small
        }
        locations.add(LocationImpl.get(loc));
    }
14906#/**
     * Get the location of this object
     *
     * @return the location
     */
    Location getLocation();
14907#public LocatedRuntimeException(String message) {
        this(message, null, null, true);
    }
14908#public LocatedRuntimeException(String message, Throwable cause)
    throws LocatedRuntimeException {
        this(message, cause, null, true);
    }
14909#public LocatedRuntimeException(String message, Location location) {
        this(message, null, location, true);
    }
14910#public LocatedRuntimeException(String message, Throwable cause, Location location)
    throws LocatedRuntimeException {
        this(message, cause, location, true);
    }
14911#public LocatedRuntimeException(String message, Throwable cause, Location location, boolean rethrowLocated)
    throws LocatedRuntimeException {
        super(message, cause);
        if (rethrowLocated && cause instanceof LocatedRuntimeException) {
            LocatedRuntimeException lreCause = (LocatedRuntimeException)cause;
            lreCause.addLocation(location);
            // Rethrow the cause
            throw lreCause;
        }

        LocatedException.ensureCauseChainIsSet(cause);
        LocatedException.addCauseLocations(this, cause);
        addLocation(location);
    }
14912#public Location getLocation() {
        return locations == null ? null : (Location) locations.get(0);
    }
14913#public List getLocations() {
        return locations == null ? Collections.EMPTY_LIST : locations;
    }
14914#public String getRawMessage() {
        return super.getMessage();
    }
14915#public String getMessage() {
        return LocatedException.getMessage(super.getMessage(), locations);
    }
14916#public void addLocation(Location loc) {
        if (LocationUtils.isUnknown(loc)) {
            return;
        }

        if (locations == null) {
            this.locations = new ArrayList(1); // Start small
        }
        locations.add(LocationImpl.get(loc));
    }
14917#private LocationUtils() {
        // Forbid instanciation
    }
14918#/**
     * Builds a string representation of a location, in the
     * "<code><em>descripton</em> - <em>uri</em>:<em>line</em>:<em>column</em></code>"
     * format (e.g. "<code>foo - file://path/to/file.xml:3:40</code>"). For {@link Location#UNKNOWN an unknown location}, returns
     * {@link #UNKNOWN_STRING}.
     *
     * @return the string representation
     */
    public static String toString(Location location) {
        StringBuffer result = new StringBuffer();

        String description = location.getDescription();
        if (description != null) {
            result.append(description).append(" - ");
        }

        String uri = location.getURI();
        if (uri != null) {
            result.append(uri);
            if (location.getLineNumber() != -1) {
                result.append(':').append(location.getLineNumber());
                if (location.getColumnNumber() != -1) {
                    result.append(':').append(location.getColumnNumber());
                }
            }
        } else {
            result.append(UNKNOWN_STRING);
        }

        return result.toString();
    }
14919#/**
     * Parse a location string of the form "<code><em>uri</em>:<em>line</em>:<em>column</em></code>" (e.g.
     * "<code>path/to/file.xml:3:40</code>") to a Location object. Additionally, a description may
     * also optionally be present, separated with an hyphen (e.g. "<code>foo - path/to/file.xml:3.40</code>").
     *
     * @param text the text to parse
     * @return the location (possibly <code>null</code> if text was null or in an incorrect format)
     */
    public static LocationImpl parse(String text) throws IllegalArgumentException {
        if (text == null || text.length() == 0) {
            return null;
        }

        // Do we have a description?
        String description;
        int uriStart = text.lastIndexOf(" - "); // lastIndexOf to allow the separator to be in the description
        if (uriStart > -1) {
            description = text.substring(0, uriStart);
            uriStart += 3; // strip " - "
        } else {
            description = null;
            uriStart = 0;
        }

        try {
            int colSep = text.lastIndexOf(':');
            if (colSep > -1) {
                int column = Integer.parseInt(text.substring(colSep + 1));

                int lineSep = text.lastIndexOf(':', colSep - 1);
                if (lineSep > -1) {
                    int line = Integer.parseInt(text.substring(lineSep + 1, colSep));
                    return new LocationImpl(description, text.substring(uriStart, lineSep), line, column);
                }
            } else {
                // unkonwn?
                if (text.endsWith(UNKNOWN_STRING)) {
                    return LocationImpl.UNKNOWN;
                }
            }
        } catch(Exception e) {
            // Ignore: handled below
        }

        return LocationImpl.UNKNOWN;
    }
14920#/**
     * Checks if a location is known, i.e. it is not null nor equal to {@link Location#UNKNOWN}.
     *
     * @param location the location to check
     * @return <code>true</code> if the location is known
     */
    public static boolean isKnown(Location location) {
        return location != null && !Location.UNKNOWN.equals(location);
    }
14921#/**
     * Checks if a location is unknown, i.e. it is either null or equal to {@link Location#UNKNOWN}.
     *
     * @param location the location to check
     * @return <code>true</code> if the location is unknown
     */
    public static boolean isUnknown(Location location) {
        return location == null || Location.UNKNOWN.equals(location);
    }
14922#/**
     * Add a {@link LocationFinder} to the list of finders that will be queried for an object's
     * location by {@link #getLocation(Object, String)}.
     * <p>
     * <b>Important:</b> LocationUtils internally stores a weak reference to the finder. This
     * avoids creating strong links between the classloader holding this class and the finder's
     * classloader, which can cause some weird memory leaks if the finder's classloader is to
     * be reloaded. Therefore, you <em>have</em> to keep a strong reference to the finder in the
     * calling code, e.g.:
     * <pre>
     *   private static LocationUtils.LocationFinder myFinder =
     *       new LocationUtils.LocationFinder() {
     *           public Location getLocation(Object obj, String desc) {
     *               ...
     *           }
     *       };
     *
     *   static {
     *       LocationUtils.addFinder(myFinder);
     *   }
     * </pre>
     *
     * @param finder the location finder to add
     */
    public static void addFinder(LocationFinder finder) {
        if (finder == null) {
            return;
        }

        synchronized(LocationFinder.class) {
            // Update a clone of the current finder list to avoid breaking
            // any iteration occuring in another thread.
            List newFinders = new ArrayList(finders);
            newFinders.add(new WeakReference(finder));
            finders = newFinders;
        }
    }
14923#/**
     * Get the location of an object. Some well-known located classes built in the JDK are handled
     * by this method. Handling of other located classes can be handled by adding new location finders.
     *
     * @param obj the object of which to get the location
     * @return the object's location, or {@link Location#UNKNOWN} if no location could be found
     */
    public static Location getLocation(Object obj) {
        return getLocation(obj, null);
    }
14924#/**
     * Get the location of an object. Some well-known located classes built in the JDK are handled
     * by this method. Handling of other located classes can be handled by adding new location finders.
     *
     * @param obj the object of which to get the location
     * @param description an optional description of the object's location, used if a Location object
     *        has to be created.
     * @return the object's location, or {@link Location#UNKNOWN} if no location could be found
     */
    public static Location getLocation(Object obj, String description) {
        if (obj instanceof Locatable) {
            return ((Locatable)obj).getLocation();
        }

        // Check some well-known locatable exceptions
        if (obj instanceof SAXParseException) {
            SAXParseException spe = (SAXParseException)obj;
            if (spe.getSystemId() != null) {
                return new LocationImpl(description, spe.getSystemId(), spe.getLineNumber(), spe.getColumnNumber());
            } else {
                return Location.UNKNOWN;
            }
        }

        if (obj instanceof TransformerException) {
            TransformerException ex = (TransformerException)obj;
            SourceLocator locator = ex.getLocator();
            if (locator != null && locator.getSystemId() != null) {
                return new LocationImpl(description, locator.getSystemId(), locator.getLineNumber(), locator.getColumnNumber());
            } else {
                return Location.UNKNOWN;
            }
        }

        if (obj instanceof Locator) {
            Locator locator = (Locator)obj;
            if (locator.getSystemId() != null) {
                return new LocationImpl(description, locator.getSystemId(), locator.getLineNumber(), locator.getColumnNumber());
            } else {
                return Location.UNKNOWN;
            }
        }

        if (obj instanceof Exception) {
            // Many exceptions in Cocoon have a message like "blah blah at file://foo/bar.xml:12:1"
            String msg = ((Exception)obj).getMessage();
            if (msg == null) return null;
            
            int pos = msg.lastIndexOf(" at ");
            if (pos != -1) {
                return LocationUtils.parse(msg.substring(pos + 4));
            }
        }

        List currentFinders = finders; // Keep the current list
        int size = currentFinders.size();
        for (int i = 0; i < size; i++) {
            WeakReference ref = (WeakReference)currentFinders.get(i);
            LocationFinder finder = (LocationFinder)ref.get();
            if (finder == null) {
                // This finder was garbage collected: update finders
                synchronized(LocationFinder.class) {
                    // Update a clone of the current list to avoid breaking current iterations
                    List newFinders = new ArrayList(finders);
                    newFinders.remove(ref);
                    finders = newFinders;
                }
                continue;
            }

            Location result = finder.getLocation(obj, description);
            if (result != null) {
                return result;
            }
        }

        return Location.UNKNOWN;
    }
14925#/**
         * Get the location of an object
         * @param obj the object for which to find a location
         * @param description and optional description to be added to the object's location
         * @return the object's location or <code>null</code> if object's class isn't handled
         *         by this finder.
         */
        Location getLocation(Object obj, String description);
14926#/**
     * Appends children representing the object's state to the given node.
     */
    void toDOM(Node node) throws Exception;
14927#/**
     * Set the <code>XMLConsumer</code> that will receive XML data.
     *
     * @param consumer  The XMLConsumer target for SAX events.
     */
    void setConsumer(XMLConsumer consumer);
14928#void simpleLink(String href, String role, String arcrole, String title, String show, String actuate, String uri, String name, String raw, Attributes attr) throws SAXException;
14929#void startExtendedLink(String role, String title, String uri, String name, String raw, Attributes attr) throws SAXException;
14930#void endExtendedLink(String uri, String name, String raw) throws SAXException;
14931#void startLocator(String href, String role, String title, String label, String uri, String name, String raw, Attributes attr) throws SAXException;
14932#void endLocator(String uri, String name, String raw) throws SAXException;
14933#void startArc(String arcrole, String title, String show, String actuate, String from, String to, String uri, String name, String raw, Attributes attr) throws SAXException;
14934#void endArc(String uri, String name, String raw) throws SAXException;
14935#void linkResource(String role, String title, String label, String uri, String name, String raw, Attributes attr) throws SAXException;
14936#void linkTitle(String uri, String name, String raw, Attributes attr) throws SAXException;
14937#public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
14938#public Source getSource(String location, Map parameters) throws IOException {
        // Checks URL syntax
        int protocolEnd = location.indexOf(":");
        if (protocolEnd == -1) {
            throw new MalformedURLException("Protocol ':' separator is missing in URL: " + location);
        }

        int archiveEnd = location.lastIndexOf("!/");
        if (archiveEnd == -1) {
            throw new MalformedURLException("File path '!/' separator is missing in URL: " + location);
        }

        // Get protocol. Protocol is configurable via cocoon.xconf
        final String protocol = location.substring(0, protocolEnd);

        // Get archive URL
        final String archiveURL = location.substring(protocolEnd + 1, archiveEnd);

        // Get file path
        final String filePath = location.substring(archiveEnd + 2);

        // Resolve archive source
        Source archive;
        SourceResolver resolver = null;
        try {
            resolver = (SourceResolver) this.manager.lookup(SourceResolver.ROLE);
            archive = resolver.resolveURI(archiveURL);
        } catch (ServiceException se) {
            throw new SourceException("SourceResolver is not available.", se);
        } finally {
            this.manager.release(resolver);
        }

        return new ZipSource(protocol, archive, filePath);
    }
14939#public void release(Source source) {
        SourceResolver resolver = null;
        try {
            resolver = (SourceResolver) this.manager.lookup(SourceResolver.ROLE);
            ((ZipSource) source).dispose(resolver);
        } catch (ServiceException e) {
            // Ignored
            getLogger().error("ServiceException while looking up SourceResolver in release()", e);
        } finally {
            this.manager.release(resolver);
        }
    }
14940#public ZipSource(String protocol, Source archive, String filePath) {
        this.protocol = protocol;
        this.archive = archive;
        this.filePath = filePath;
    }
14941#private ZipEntry findEntry(ZipInputStream zipStream)
    throws IOException {
        ZipEntry entry;
        while ((entry = zipStream.getNextEntry()) != null) {
            if (entry.getName().equals(this.filePath)) {
                return entry;
            }
            zipStream.closeEntry();
        }

        return null;
    }
14942#/* package access */
    void dispose(SourceResolver resolver) {
        resolver.release(this.archive);
        this.archive = null;
    }
14943#public boolean exists() {
        if(!this.archive.exists()) {
            return false;
        }

        ZipInputStream zipStream = null;
        try {
            zipStream = new ZipInputStream(this.archive.getInputStream());
            return findEntry(zipStream) != null;
        } catch (IOException e) {
            return false;
        } finally {
            try {
                if (zipStream != null) {
                    zipStream.close();
                }
            } catch (IOException e) {
                getLogger().error("IOException while closing ZipInputStream: " + this.filePath);
            }
        }
    }
14944#public InputStream getInputStream() throws IOException {
        ZipInputStream zipStream = new ZipInputStream(this.archive.getInputStream());
        try {
            ZipEntry entry = findEntry(zipStream);
            if (entry == null) {
                throw new SourceNotFoundException("File " + this.filePath + " is not found in the archive " +
                                                  this.archive.getURI());
            }

            // Now we will extract the document and write it into a byte array
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            byte[] buffer = new byte[8192];
            int length;
            while (zipStream.available() > 0) {
                length = zipStream.read(buffer, 0, 8192);
                if (length > 0) {
                    baos.write(buffer, 0, length);
                }
            }

            // Return an input stream
            return new ByteArrayInputStream(baos.toByteArray());
        } finally {
            try {
                zipStream.close();
            } catch (IOException e) {
                getLogger().error("IOException while closing ZipInputStream: " + this.filePath);
            }
        }
    }
14945#public String getURI() {
        return this.protocol + ":" + this.archive.getURI() + "!/" + this.filePath;
    }
14946#public String getScheme() {
        return this.protocol;
    }
14947#public SourceValidity getValidity() {
        return this.archive.getValidity();
    }
14948#public void refresh() {
    }
14949#public String getMimeType() {
        String ext = this.filePath.substring(this.filePath.lastIndexOf("."));
        return MIMEUtils.getMIMEType(ext);
    }
14950#public long getContentLength() {
        ZipInputStream zipStream = null;
        try {
            zipStream = new ZipInputStream(this.archive.getInputStream());
            ZipEntry entry = findEntry(zipStream);
            if (entry != null) {
                return entry.getSize();
            }

        } catch (IOException e) {
            // Ignored
        } finally {
            try {
                if (zipStream != null) {
                    zipStream.close();
                }
            } catch (IOException e) {
                getLogger().error("IOException while closing ZipInputStream: " + this.filePath);
            }
        }

        return -1;
    }
14951#public long getLastModified() {
        return this.archive.getLastModified();
    }
14952#/**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
14953#/**
     * @see org.apache.avalon.framework.context.Contextualizable#contextualize(org.apache.avalon.framework.context.Context)
     */
    public void contextualize(org.apache.avalon.framework.context.Context context)
    throws ContextException {
        this.servletContext = (Context) context.get(Constants.CONTEXT_ENVIRONMENT_CONTEXT);
    }
14954#/**
     * @see org.apache.excalibur.source.SourceFactory#getSource(java.lang.String, java.util.Map)
     */
    public Source getSource(String location, Map parameters) throws IOException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Creating source object for " + location);
        }

        // Lookup resolver 
        SourceResolver resolver = null;
        try {
            resolver = (SourceResolver) this.manager.lookup(SourceResolver.ROLE);

            // Remove the protocol and the first '/'
            final int pos = location.indexOf(":/");
            final String scheme = location.substring(0, pos);
            final String path = location.substring(pos + 2);

            // fix for #24093, we don't give access to files outside the context:
            if (path.indexOf("../") != -1) {
                throw new MalformedURLException("Invalid path ('../' is not allowed) : " + path);
            }

            URL u;

            // Try to get a file first and fall back to a resource URL
            String actualPath = this.servletContext.getRealPath(path);
            if (actualPath != null) {
                u = new File(actualPath).toURL();
            } else {
                u = this.servletContext.getResource(path);
            }

            if (u != null) {
                Source source = resolver.resolveURI(u.toExternalForm());
                if ( parameters != null 
                     && BooleanUtils.toBoolean("force-traversable")
                     && this.servletContext != null 
                     && !(source instanceof TraversableSource) ) {
                    final Set children = this.servletContext.getResourcePaths(path + '/');
                    if ( children != null ) {
                        source = new TraversableContextSource(source, children, this, path, scheme);
                    }
                }
                return source;                
            }

            final String message = location + " could not be found. (possible context problem)";
            getLogger().info(message);
            throw new MalformedURLException(message);
        } catch (ServiceException se) {
            throw new SourceException("Unable to lookup source resolver.", se);
        } finally {
            this.manager.release(resolver);
        }
    }
14955#/**
     * @see org.apache.excalibur.source.SourceFactory#release(org.apache.excalibur.source.Source)
     */
    public void release(Source source) {
        // In fact, this method should never be called as this factory
        // returns a source object from a different factory. So that
        // factory should release the source
        if (source != null) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Releasing source " + source.getURI());
            }

            SourceResolver resolver = null;
            try {
                resolver = (SourceResolver) this.manager.lookup(SourceResolver.ROLE);
                if (source instanceof TraversableContextSource) {
                    resolver.release(((TraversableContextSource) source).wrappedSource);
                } else {
                    resolver.release(source);
                }
            } catch (ServiceException ingore) {
                // we ignore this
            } finally {
                this.manager.release(resolver);
            }
        }
    }
14956#/**
     * @see org.apache.excalibur.source.URIAbsolutizer#absolutize(java.lang.String, java.lang.String)
     */
    public String absolutize(String baseURI, String location) {
        return SourceUtil.absolutize(baseURI, location, true);
    }
14957#public EmptySource(String location) {
        this.uri = location;
        final int pos = location.indexOf(':');
        this.scheme = location.substring(0, pos);

        final String rootName = location.substring(pos + 1).trim();
        if (rootName.length() > 0) {
            this.rootElementName = rootName;
            this.xmlDocument = '<' + this.rootElementName + "/>";
        } else {
            this.xmlDocument = "";
        }
    }
14958#/**
     * @see org.apache.excalibur.xml.sax.XMLizable#toSAX(org.xml.sax.ContentHandler)
     */
    public void toSAX(ContentHandler handler) throws SAXException {
        handler.startDocument();
        if (rootElementName != null) {
            XMLUtils.createElement(handler, this.rootElementName);
        }
        handler.endDocument();
    }
14959#/**
     * @see org.apache.excalibur.source.Source#exists()
     */
    public boolean exists() {
        return true;
    }
14960#/**
     * @see org.apache.excalibur.source.Source#getContentLength()
     */
    public long getContentLength() {
        return this.xmlDocument.length();
    }
14961#/**
     * @see org.apache.excalibur.source.Source#getInputStream()
     */
    public InputStream getInputStream() throws IOException, SourceNotFoundException {
        return new ByteArrayInputStream(this.xmlDocument.getBytes("utf-8"));
    }
14962#/**
     * @see org.apache.excalibur.source.Source#getLastModified()
     */
    public long getLastModified() {
        // this document *never* changes
        return 1;
    }
14963#/**
     * @see org.apache.excalibur.source.Source#getMimeType()
     */
    public String getMimeType() {
        return "text/xml";
    }
14964#/**
     * @see org.apache.excalibur.source.Source#getScheme()
     */
    public String getScheme() {
        return this.scheme;
    }
14965#/**
     * @see org.apache.excalibur.source.Source#getURI()
     */
    public String getURI() {
        return this.uri;
    }
14966#/**
     * @see org.apache.excalibur.source.Source#getValidity()
     */
    public SourceValidity getValidity() {
        return NOPValidity.SHARED_INSTANCE;
    }
14967#/**
     * @see org.apache.excalibur.source.Source#refresh()
     */
    public void refresh() {
        // nothing to do here
    }
14968#/**
     * Get an {@link EmptySource} object.
     *
     * @param location   The URI to resolve - this URI includes the scheme.
     * @param parameters this is optional and not used here
     *
     * @see org.apache.excalibur.source.SourceFactory#getSource(java.lang.String, java.util.Map)
     */
    public Source getSource(String location, Map parameters) throws IOException {
        return new EmptySource(location);
    }
14969#/**
     * @see org.apache.excalibur.source.SourceFactory#release(org.apache.excalibur.source.Source)
     */
    public void release(Source source) {
        // Do nothing here
    }
14970#public TraversableContextSource(Source source, 
                                    Set children, 
                                    ContextSourceFactory factory,
                                    String path,
                                    String scheme) {
        this.wrappedSource = source;
        this.children = children;
        this.factory = factory;
        this.path = path;
        this.scheme = scheme;
    }
14971#/**
     * @see org.apache.excalibur.source.Source#exists()
     */
    public boolean exists() {
        return this.wrappedSource.exists();
    }
14972#/**
     * @see org.apache.excalibur.source.Source#getContentLength()
     */
    public long getContentLength() {
        return this.wrappedSource.getContentLength();
    }
14973#/**
     * @see org.apache.excalibur.source.Source#getInputStream()
     */
    public InputStream getInputStream() 
    throws IOException, SourceNotFoundException {
        return this.wrappedSource.getInputStream();
    }
14974#/**
     * @see org.apache.excalibur.source.Source#getLastModified()
     */
    public long getLastModified() {
        return this.wrappedSource.getLastModified();
    }
14975#/**
     * @see org.apache.excalibur.source.Source#getMimeType()
     */
    public String getMimeType() {
        return this.wrappedSource.getMimeType();
    }
14976#/**
     * @see org.apache.excalibur.source.Source#getScheme()
     */
    public String getScheme() {
        return this.scheme;
    }
14977#/**
     * @see org.apache.excalibur.source.Source#getURI()
     */
    public String getURI() {
        return this.wrappedSource.getURI();
    }
14978#/**
     * @see org.apache.excalibur.source.Source#getValidity()
     */
    public SourceValidity getValidity() {
        return this.wrappedSource.getValidity();
    }
14979#/**
     * @see org.apache.excalibur.source.Source#refresh()
     */
    public void refresh() {
        this.wrappedSource.refresh();
    }
14980#/**
     * @see org.apache.excalibur.source.TraversableSource#getChild(java.lang.String)
     */
    public Source getChild(String name) throws SourceException {
        final String postfixOne = '/' + name + '/';
        final String postfixTwo = '/' + name;
        final Iterator i = this.children.iterator();
        while ( i.hasNext() ) {
            String uri = (String)i.next();
            if ( uri.endsWith(postfixOne ) ){
                uri = "context:/" + uri;
                uri = uri.substring(0, uri.length()-1);
                try {
                    return this.factory.getSource(uri, null);
                } catch (IOException ioe) {
                    throw new SourceException("Unable to get source for: " + uri);
                }                
            } else if ( uri.endsWith(postfixTwo) ) {
                uri = "context:/" + uri;
                try {
                    return this.factory.getSource(uri, null);
                } catch (IOException ioe) {
                    throw new SourceException("Unable to get source for: " + uri);
                }                
            }
        }
        return null;
    }
14981#/**
     * @see org.apache.excalibur.source.TraversableSource#getChildren()
     */
    public Collection getChildren() throws SourceException {
        final List l = new ArrayList();
        final Iterator i = this.children.iterator();
        while ( i.hasNext() ) {
            String uri = (String)i.next();
            uri = "context:/" + uri;
            try {
                l.add(this.factory.getSource(uri, null));
            } catch (IOException ioe) {
                final Iterator ci = l.iterator();
                while ( ci.hasNext() ) {
                    this.factory.release((Source)ci.next());
                }
                throw new SourceException("Unable to get source for: " + uri);
            }
        }
        return l;
    }
14982#/**
     * @see org.apache.excalibur.source.TraversableSource#getName()
     */
    public String getName() {
        final String uri = this.wrappedSource.getURI();
        return uri.substring(uri.lastIndexOf('/')+1);
    }
14983#/**
     * @see org.apache.excalibur.source.TraversableSource#getParent()
     */
    public Source getParent() throws SourceException {
        String uri = "context:/" + this.path;
        uri = uri.substring(0, uri.lastIndexOf('/'));
        try {
            return this.factory.getSource(uri, null);
        } catch (IOException ioe) {
            throw new SourceException("Unable to get source for: " + uri);
        }                
    }
14984#/**
     * @see org.apache.excalibur.source.TraversableSource#isCollection()
     */
    public boolean isCollection() {
        return true;
    }
14985#/**
     * If this pointer part successfully identifies any subresources, it should
     * stream them to the XMLConsumer available from the XPointerContext and return true.
     * Otherwise this method should return false.
     */
    public boolean process(XPointerContext xpointerContext) throws SAXException, ResourceNotFoundException;
14986#public ShorthandPart(String shorthand) {
        this.shorthand = shorthand;
    }
14987#public boolean process(XPointerContext xpointerContext) throws SAXException, ResourceNotFoundException {
        Document document = xpointerContext.getDocument();
        Element element = document.getElementById(shorthand);
        if (element != null) {
            DOMStreamer streamer = new DOMStreamer();
            streamer.setConsumer(xpointerContext.getXmlConsumer());
            streamer.stream(element);
            return true;
        } else {
            if (xpointerContext.getLogger().isDebugEnabled())
                xpointerContext.getLogger().debug("XPointer: found no element with id " + shorthand + " in document " + xpointerContext.getSource().getURI());
        }
        return false;
    }
14988#public UnsupportedPart(String schemeName) {
        this.schemeName = schemeName;
    }
14989#public boolean process(XPointerContext xpointerContext) throws SAXException {
        throw new SAXException("Scheme " + schemeName + " not supported by this XPointer implementation, as used in the fragment identifier " + xpointerContext.getXPointer());
    }
14990#public ElementPathPart(String expression) {
        this.expression = expression;
    }
14991#public boolean process(XPointerContext xpointerContext) throws SAXException {
        PathInclusionPipe pipe = new PathInclusionPipe(expression, xpointerContext);
        pipe.setConsumer(xpointerContext.getXmlConsumer());
        try {
            SourceUtil.toSAX(xpointerContext.getServiceManager(), xpointerContext.getSource(), pipe);
        } catch (IOException e) {
            throw new SAXException("Exception while trying to XInclude data: " + e.getMessage(), e);
        } catch (ProcessingException e) {
            throw new SAXException("Exception while trying to XInclude data: " + e.getMessage(), e);
        }
        return true;
    }
14992#public PathInclusionPipe(String expression, XPointerContext xpointerContext) throws SAXException {
            // parse the expression to an array of QName objects
            ArrayList path = new ArrayList();
            StringTokenizer tokenizer = new StringTokenizer(expression, "/");
            while (tokenizer.hasMoreTokens()) {
                String token = tokenizer.nextToken();
                try {
                    path.add(QName.parse(token, xpointerContext));
                } catch (SAXException e) {
                    throw new SAXException("Error in element path xpointer expression \"" + expression + "\": " + e.getMessage());
                }
            }
            if (path.size() < 1)
                throw new SAXException("Invalid element path xpointer expression \"" + expression + "\".");

            this.elementPath = (QName[]) path.toArray(new QName[0]);
            this.level = -1;
            this.include = false;
            this.levelToMatch = 0;
            this.done = false;
        }
14993#public void startElement(String namespaceURI, String localName, String raw, Attributes a)
                throws SAXException {
            level++;

            if (include) {
                super.startElement(namespaceURI, localName, raw, a);
                return;
            }

            if (!done && level == levelToMatch && elementPath[level].matches(namespaceURI, localName)) {
                levelToMatch++;
                if (levelToMatch == elementPath.length) {
                    include = true;
                    done = true;
                    includeLevel = level;
                }
            }
        }
14994#public void endElement(String uri, String loc, String raw)
                throws SAXException {
            if (include && level == includeLevel)
                include = false;

            if (include)
                super.endElement(uri, loc, raw);

            level--;
        }
14995#public void setDocumentLocator(Locator locator) {
            if (include)
                super.setDocumentLocator(locator);
        }
14996#public void startDocument()
                throws SAXException {
            if (include)
                super.startDocument();
        }
14997#public void endDocument()
                throws SAXException {
            if (include)
                super.endDocument();
        }
14998#public void characters(char c[], int start, int len)
                throws SAXException {
            if (include)
                super.characters(c, start, len);
        }
14999#public void ignorableWhitespace(char c[], int start, int len)
                throws SAXException {
            if (include)
                super.ignorableWhitespace(c, start, len);
        }
15000#public void processingInstruction(String target, String data)
                throws SAXException {
            if (include)
                super.processingInstruction(target, data);
        }
15001#public void skippedEntity(String name)
                throws SAXException {
            if (include)
                super.skippedEntity(name);
        }
15002#public void startDTD(String name, String publicId, String systemId)
                throws SAXException {
            if (include)
                super.startDTD(name, publicId, systemId);
        }
15003#public void endDTD()
                throws SAXException {
            if (include)
                super.endDTD();
        }
15004#public void startEntity(String name)
                throws SAXException {
            if (include)
                super.startEntity(name);
        }
15005#public void endEntity(String name)
                throws SAXException {
            if (include)
                super.endEntity(name);
        }
15006#public void startCDATA()
                throws SAXException {
            if (include)
                super.startCDATA();
        }
15007#public void endCDATA()
                throws SAXException {
            if (include)
                super.endCDATA();
        }
15008#public void comment(char ch[], int start, int len)
                throws SAXException {
            if (include)
                super.comment(ch, start, len);
        }
15009#public QName(String namespaceURI, String localName) {
                this.namespaceURI = namespaceURI;
                this.localName = localName;
            }
15010#public static QName parse(String qName, XPointerContext xpointerContext) throws SAXException {
                int pos = qName.indexOf(':');
                if (pos > 0) {
                    String prefix = qName.substring(0, pos);
                    String localName = qName.substring(pos + 1);
                    String namespaceURI = xpointerContext.prefixToNamespace(prefix);
                    if (namespaceURI == null)
                        throw new SAXException("Namespace prefix \"" + prefix + "\" not declared.");
                    return new QName(prefix, localName);
                }
                return new QName("", qName);
            }
15011#public String getNamespaceURI() {
                return namespaceURI;
            }
15012#public String getLocalName() {
                return localName;
            }
15013#public boolean matches(String namespaceURI, String localName) {
                return this.localName.equals(localName) && this.namespaceURI.equals(namespaceURI);
            }
15014#/**
     * Constructs an XPointerContext object.
     *
     * @param xpointer the original fragment identifier string, used for debugging purposes
     * @param source the source into which the xpointer points
     * @param xmlConsumer the consumer to which the result of the xpointer evaluation should be send
     */
    public XPointerContext(String xpointer, Source source, XMLConsumer xmlConsumer, ServiceManager manager) {
        this.source = source;
        this.xmlConsumer = xmlConsumer;
        this.manager = manager;
        this.xpointer = xpointer;

        prefixes.put("xml", "http://www.w3.org/XML/1998/namespace");
    }
15015#public Document getDocument() throws SAXException, ResourceNotFoundException {
        if (document == null) {
            try {
                document = SourceUtil.toDOM(manager, source);
            } catch (ResourceNotFoundException e) {
                throw e;
            } catch (Exception e) {
                throw new SAXException("Error during XPointer evaluation while trying to load " + source.getURI(), e);
            }
        }
        return document;
    }
15016#public Source getSource() {
        return source;
    }
15017#public XMLConsumer getXmlConsumer() {
        return xmlConsumer;
    }
15018#public String getXPointer() {
        return xpointer;
    }
15019#public ServiceManager getServiceManager() {
        return manager;
    }
15020#public void addPrefix(String prefix, String namespace) throws SAXException {
        // according to the xmlns() scheme spec, these should not result to any change in namespace context
        if (prefix.equalsIgnoreCase("xml"))
            return;
        else if (prefix.equals("xmlns"))
            return;
        else if (namespace.equals("http://www.w3.org/XML/1998/namespace"))
            return;
        else if (namespace.equals("http://www.w3.org/2000/xmlns/"))
            return;

        prefixes.put(prefix, namespace);
    }
15021#public String prefixToNamespace(String prefix) {
        return (String)prefixes.get(prefix);
    }
15022#/**
     * Creates an XmlnsPart.
     */
    public XmlnsPart(String prefix, String namespace) {
        this.prefix = prefix;
        this.namespace = namespace;
    }
15023#public boolean process(XPointerContext xpointerContext) throws SAXException {
        xpointerContext.addPrefix(prefix, namespace);
        return false;
    }
15024#public XPointerPart(String expression) {
        this.expression = expression;
    }
15025#public boolean process(XPointerContext ctx) throws SAXException, ResourceNotFoundException {
        Document document = ctx.getDocument();
        ServiceManager manager = ctx.getServiceManager();

        XPathProcessor xpathProcessor = null;
        try {
            try {
                xpathProcessor = (XPathProcessor)manager.lookup(XPathProcessor.ROLE);
            } catch (Exception e) {
                throw new SAXException("XPointerPart: error looking up XPathProcessor.", e);
            }
            NodeList nodeList = xpathProcessor.selectNodeList(document, expression, ctx);
            if (nodeList.getLength() > 0) {
                XMLConsumer consumer = ctx.getXmlConsumer();
                LocatorImpl locator = new LocatorImpl();
                locator.setSystemId(ctx.getSource().getURI());
                consumer.setDocumentLocator(locator);
                for (int i = 0; i < nodeList.getLength(); i++) {
                    DOMStreamer streamer = new DOMStreamer();
                    streamer.setNormalizeNamespaces(true);
                    streamer.setConsumer(consumer);
                    streamer.stream(nodeList.item(i));
                }
                return true;
            } else {
                if (ctx.getLogger().isDebugEnabled())
                    ctx.getLogger().debug("XPointer: expression \"" + expression + "\" gave no results.");
                return false;
            }
        } finally {
            if (xpathProcessor != null)
                manager.release(xpathProcessor);
        }
    }
15026#public void addPart(PointerPart part) {
        pointerParts.add(part);
    }
15027#public void process(XPointerContext context) throws SAXException, ResourceNotFoundException {
        Iterator pointerPartsIt = pointerParts.iterator();
        while (pointerPartsIt.hasNext()) {
            PointerPart part = (PointerPart)pointerPartsIt.next();
            part.process(context);
        }
    }
15028#public void setDebugStream(java.io.PrintStream ds) {
        debugStream = ds;
    }
15029#private final int jjStopAtPos(int pos, int kind) {
        jjmatchedKind = kind;
        jjmatchedPos = pos;
        return pos + 1;
    }
15030#private final int jjMoveStringLiteralDfa0_0() {
        switch (curChar) {
            case 40 :
                return jjStopAtPos(0, 10);
            case 41 :
                return jjStopAtPos(0, 11);
            default :
                return jjMoveNfa_0(0, 0);
        }
    }
15031#private final void jjCheckNAdd(int state) {
        if (jjrounds[state] != jjround) {
            jjstateSet[jjnewStateCnt++] = state;
            jjrounds[state] = jjround;
        }
    }
15032#private final void jjAddStates(int start, int end) {
        do {
            jjstateSet[jjnewStateCnt++] = jjnextStates[start];
        } while (start++ != end);
    }
15033#private final void jjCheckNAddTwoStates(int state1, int state2) {
        jjCheckNAdd(state1);
        jjCheckNAdd(state2);
    }
15034#private final void jjCheckNAddStates(int start, int end) {
        do {
            jjCheckNAdd(jjnextStates[start]);
        } while (start++ != end);
    }
15035#private final int jjMoveNfa_0(int startState, int curPos) {
        int startsAt = 0;
        jjnewStateCnt = 7;
        int i = 1;
        jjstateSet[0] = startState;
        int kind = 0x7fffffff;
        for (;;) {
            if (++jjround == 0x7fffffff)
                ReInitRounds();
            if (curChar < 64) {
                long l = 1L << curChar;
                do {
                    switch (jjstateSet[--i]) {
                        case 0 :
                            if ((0x100002600L & l) != 0L)
                                kind = 8;
                            break;
                        case 2 :
                            if ((0x3ff600000000000L & l) == 0L)
                                break;
                            if (kind > 7)
                                kind = 7;
                            jjstateSet[jjnewStateCnt++] = 2;
                            break;
                        case 3 :
                            if ((0x3ff600000000000L & l) != 0L)
                                jjAddStates(0, 1);
                            break;
                        case 4 :
                            if (curChar == 58)
                                jjstateSet[jjnewStateCnt++] = 5;
                            break;
                        case 6 :
                            if ((0x3ff600000000000L & l) == 0L)
                                break;
                            if (kind > 9)
                                kind = 9;
                            jjstateSet[jjnewStateCnt++] = 6;
                            break;
                        default :
                            break;
                    }
                } while (i != startsAt);
            } else if (curChar < 128) {
                long l = 1L << (curChar & 077);
                do {
                    switch (jjstateSet[--i]) {
                        case 0 :
                            if ((0x7fffffe87fffffeL & l) == 0L)
                                break;
                            if (kind > 7)
                                kind = 7;
                            jjCheckNAddStates(2, 5);
                            break;
                        case 2 :
                            if ((0x7fffffe87fffffeL & l) == 0L)
                                break;
                            if (kind > 7)
                                kind = 7;
                            jjCheckNAdd(2);
                            break;
                        case 3 :
                            if ((0x7fffffe87fffffeL & l) != 0L)
                                jjCheckNAddTwoStates(3, 4);
                            break;
                        case 5 :
                        case 6 :
                            if ((0x7fffffe87fffffeL & l) == 0L)
                                break;
                            if (kind > 9)
                                kind = 9;
                            jjCheckNAdd(6);
                            break;
                        default :
                            break;
                    }
                } while (i != startsAt);
            } else {
                int hiByte = (curChar >> 8);
                int i1 = hiByte >> 6;
                long l1 = 1L << (hiByte & 077);
                int i2 = (curChar & 0xff) >> 6;
                long l2 = 1L << (curChar & 077);
                do {
                    switch (jjstateSet[--i]) {
                        case 0 :
                            if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                                break;
                            if (kind > 7)
                                kind = 7;
                            jjCheckNAddStates(2, 5);
                            break;
                        case 2 :
                            if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                                break;
                            if (kind > 7)
                                kind = 7;
                            jjCheckNAdd(2);
                            break;
                        case 3 :
                            if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                                jjCheckNAddTwoStates(3, 4);
                            break;
                        case 5 :
                            if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                                break;
                            if (kind > 9)
                                kind = 9;
                            jjCheckNAdd(6);
                            break;
                        case 6 :
                            if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                                break;
                            if (kind > 9)
                                kind = 9;
                            jjCheckNAdd(6);
                            break;
                        default :
                            break;
                    }
                } while (i != startsAt);
            }
            if (kind != 0x7fffffff) {
                jjmatchedKind = kind;
                jjmatchedPos = curPos;
                kind = 0x7fffffff;
            }
            ++curPos;
            if ((i = jjnewStateCnt)
                == (startsAt = 7 - (jjnewStateCnt = startsAt)))
                return curPos;
            try {
                curChar = input_stream.readChar();
            } catch (java.io.IOException e) {
                return curPos;
            }
        }
    }
15036#private final int jjStopStringLiteralDfa_1(int pos, long active0) {
        switch (pos) {
            default :
                return -1;
        }
    }
15037#private final int jjStartNfa_1(int pos, long active0) {
        return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
    }
15038#private final int jjMoveStringLiteralDfa0_1() {
        switch (curChar) {
            case 40 :
                return jjStopAtPos(0, 10);
            case 41 :
                return jjStopAtPos(0, 11);
            case 94 :
                return jjMoveStringLiteralDfa1_1(0x7000L);
            default :
                return jjMoveNfa_1(0, 0);
        }
    }
15039#private final int jjMoveStringLiteralDfa1_1(long active0) {
        try {
            curChar = input_stream.readChar();
        } catch (java.io.IOException e) {
            jjStopStringLiteralDfa_1(0, active0);
            return 1;
        }
        switch (curChar) {
            case 40 :
                if ((active0 & 0x1000L) != 0L)
                    return jjStopAtPos(1, 12);
                break;
            case 41 :
                if ((active0 & 0x2000L) != 0L)
                    return jjStopAtPos(1, 13);
                break;
            case 94 :
                if ((active0 & 0x4000L) != 0L)
                    return jjStopAtPos(1, 14);
                break;
            default :
                break;
        }
        return jjStartNfa_1(0, active0);
    }
15040#private final int jjMoveNfa_1(int startState, int curPos) {
        int startsAt = 0;
        jjnewStateCnt = 1;
        int i = 1;
        jjstateSet[0] = startState;
        int kind = 0x7fffffff;
        for (;;) {
            if (++jjround == 0x7fffffff)
                ReInitRounds();
            if (curChar < 64) {
                long l = 1L << curChar;
                do {
                    switch (jjstateSet[--i]) {
                        case 0 :
                            if ((0xfffffcffffffffffL & l) != 0L)
                                kind = 15;
                            break;
                        default :
                            break;
                    }
                } while (i != startsAt);
            } else if (curChar < 128) {
                long l = 1L << (curChar & 077);
                do {
                    switch (jjstateSet[--i]) {
                        case 0 :
                            if ((0xffffffffbfffffffL & l) != 0L)
                                kind = 15;
                            break;
                        default :
                            break;
                    }
                } while (i != startsAt);
            } else {
                int hiByte = (curChar >> 8);
                int i1 = hiByte >> 6;
                long l1 = 1L << (hiByte & 077);
                int i2 = (curChar & 0xff) >> 6;
                long l2 = 1L << (curChar & 077);
                do {
                    switch (jjstateSet[--i]) {
                        case 0 :
                            if (jjCanMove_2(hiByte, i1, i2, l1, l2)
                                && kind > 15)
                                kind = 15;
                            break;
                        default :
                            break;
                    }
                } while (i != startsAt);
            }
            if (kind != 0x7fffffff) {
                jjmatchedKind = kind;
                jjmatchedPos = curPos;
                kind = 0x7fffffff;
            }
            ++curPos;
            if ((i = jjnewStateCnt)
                == (startsAt = 1 - (jjnewStateCnt = startsAt)))
                return curPos;
            try {
                curChar = input_stream.readChar();
            } catch (java.io.IOException e) {
                return curPos;
            }
        }
    }
15041#private static final boolean jjCanMove_0(
        int hiByte,
        int i1,
        int i2,
        long l1,
        long l2) {
        switch (hiByte) {
            case 0 :
                return ((jjbitVec2[i2] & l2) != 0L);
            case 1 :
                return ((jjbitVec3[i2] & l2) != 0L);
            case 2 :
                return ((jjbitVec4[i2] & l2) != 0L);
            case 3 :
                return ((jjbitVec5[i2] & l2) != 0L);
            case 4 :
                return ((jjbitVec6[i2] & l2) != 0L);
            case 5 :
                return ((jjbitVec7[i2] & l2) != 0L);
            case 6 :
                return ((jjbitVec8[i2] & l2) != 0L);
            case 9 :
                return ((jjbitVec9[i2] & l2) != 0L);
            case 10 :
                return ((jjbitVec10[i2] & l2) != 0L);
            case 11 :
                return ((jjbitVec11[i2] & l2) != 0L);
            case 12 :
                return ((jjbitVec12[i2] & l2) != 0L);
            case 13 :
                return ((jjbitVec13[i2] & l2) != 0L);
            case 14 :
                return ((jjbitVec14[i2] & l2) != 0L);
            case 15 :
                return ((jjbitVec15[i2] & l2) != 0L);
            case 16 :
                return ((jjbitVec16[i2] & l2) != 0L);
            case 17 :
                return ((jjbitVec17[i2] & l2) != 0L);
            case 30 :
                return ((jjbitVec18[i2] & l2) != 0L);
            case 31 :
                return ((jjbitVec19[i2] & l2) != 0L);
            case 33 :
                return ((jjbitVec20[i2] & l2) != 0L);
            case 48 :
                return ((jjbitVec21[i2] & l2) != 0L);
            case 49 :
                return ((jjbitVec22[i2] & l2) != 0L);
            case 159 :
                return ((jjbitVec23[i2] & l2) != 0L);
            case 215 :
                return ((jjbitVec24[i2] & l2) != 0L);
            default :
                if ((jjbitVec0[i1] & l1) != 0L)
                    return true;
                return false;
        }
    }
15042#private static final boolean jjCanMove_1(
        int hiByte,
        int i1,
        int i2,
        long l1,
        long l2) {
        switch (hiByte) {
            case 0 :
                return ((jjbitVec25[i2] & l2) != 0L);
            case 1 :
                return ((jjbitVec3[i2] & l2) != 0L);
            case 2 :
                return ((jjbitVec26[i2] & l2) != 0L);
            case 3 :
                return ((jjbitVec27[i2] & l2) != 0L);
            case 4 :
                return ((jjbitVec28[i2] & l2) != 0L);
            case 5 :
                return ((jjbitVec29[i2] & l2) != 0L);
            case 6 :
                return ((jjbitVec30[i2] & l2) != 0L);
            case 9 :
                return ((jjbitVec31[i2] & l2) != 0L);
            case 10 :
                return ((jjbitVec32[i2] & l2) != 0L);
            case 11 :
                return ((jjbitVec33[i2] & l2) != 0L);
            case 12 :
                return ((jjbitVec34[i2] & l2) != 0L);
            case 13 :
                return ((jjbitVec35[i2] & l2) != 0L);
            case 14 :
                return ((jjbitVec36[i2] & l2) != 0L);
            case 15 :
                return ((jjbitVec37[i2] & l2) != 0L);
            case 16 :
                return ((jjbitVec16[i2] & l2) != 0L);
            case 17 :
                return ((jjbitVec17[i2] & l2) != 0L);
            case 30 :
                return ((jjbitVec18[i2] & l2) != 0L);
            case 31 :
                return ((jjbitVec19[i2] & l2) != 0L);
            case 32 :
                return ((jjbitVec38[i2] & l2) != 0L);
            case 33 :
                return ((jjbitVec20[i2] & l2) != 0L);
            case 48 :
                return ((jjbitVec39[i2] & l2) != 0L);
            case 49 :
                return ((jjbitVec22[i2] & l2) != 0L);
            case 159 :
                return ((jjbitVec23[i2] & l2) != 0L);
            case 215 :
                return ((jjbitVec24[i2] & l2) != 0L);
            default :
                if ((jjbitVec0[i1] & l1) != 0L)
                    return true;
                return false;
        }
    }
15043#private static final boolean jjCanMove_2(
        int hiByte,
        int i1,
        int i2,
        long l1,
        long l2) {
        switch (hiByte) {
            case 0 :
                return ((jjbitVec41[i2] & l2) != 0L);
            default :
                if ((jjbitVec40[i1] & l1) != 0L)
                    return true;
                return false;
        }
    }
15044#public XPointerFrameworkParserTokenManager(SimpleCharStream stream) {
        if (SimpleCharStream.staticFlag)
            throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
        input_stream = stream;
    }
15045#public XPointerFrameworkParserTokenManager(
        SimpleCharStream stream,
        int lexState) {
        this(stream);
        SwitchTo(lexState);
    }
15046#public void ReInit(SimpleCharStream stream) {
        jjmatchedPos = jjnewStateCnt = 0;
        curLexState = defaultLexState;
        input_stream = stream;
        ReInitRounds();
    }
15047#private final void ReInitRounds() {
        int i;
        jjround = 0x80000001;
        for (i = 7; i-- > 0;)
            jjrounds[i] = 0x80000000;
    }
15048#public void ReInit(SimpleCharStream stream, int lexState) {
        ReInit(stream);
        SwitchTo(lexState);
    }
15049#public void SwitchTo(int lexState) {
        if (lexState >= 2 || lexState < 0)
            throw new TokenMgrError(
                "Error: Ignoring invalid lexical state : "
                    + lexState
                    + ". State unchanged.",
                TokenMgrError.INVALID_LEXICAL_STATE);
        else
            curLexState = lexState;
    }
15050#protected Token jjFillToken() {
        Token t = Token.newToken(jjmatchedKind);
        t.kind = jjmatchedKind;
        String im = jjstrLiteralImages[jjmatchedKind];
        t.image = (im == null) ? input_stream.GetImage() : im;
        t.beginLine = input_stream.getBeginLine();
        t.beginColumn = input_stream.getBeginColumn();
        t.endLine = input_stream.getEndLine();
        t.endColumn = input_stream.getEndColumn();
        return t;
    }
15051#public Token getNextToken() {
        Token matchedToken;
        int curPos = 0;

        for (;;) {
            try {
                curChar = input_stream.BeginToken();
            } catch (java.io.IOException e) {
                jjmatchedKind = 0;
                matchedToken = jjFillToken();
                return matchedToken;
            }

            switch (curLexState) {
                case 0 :
                    jjmatchedKind = 0x7fffffff;
                    jjmatchedPos = 0;
                    curPos = jjMoveStringLiteralDfa0_0();
                    break;
                case 1 :
                    jjmatchedKind = 0x7fffffff;
                    jjmatchedPos = 0;
                    curPos = jjMoveStringLiteralDfa0_1();
                    break;
            }
            if (jjmatchedKind != 0x7fffffff) {
                if (jjmatchedPos + 1 < curPos)
                    input_stream.backup(curPos - jjmatchedPos - 1);
                matchedToken = jjFillToken();
                if (jjnewLexState[jjmatchedKind] != -1)
                    curLexState = jjnewLexState[jjmatchedKind];
                return matchedToken;
            }
            int error_line = input_stream.getEndLine();
            int error_column = input_stream.getEndColumn();
            String error_after = null;
            boolean EOFSeen = false;
            try {
                input_stream.readChar();
                input_stream.backup(1);
            } catch (java.io.IOException e1) {
                EOFSeen = true;
                error_after = curPos <= 1 ? "" : input_stream.GetImage();
                if (curChar == '\n' || curChar == '\r') {
                    error_line++;
                    error_column = 0;
                } else
                    error_column++;
            }
            if (!EOFSeen) {
                input_stream.backup(1);
                error_after = curPos <= 1 ? "" : input_stream.GetImage();
            }
            throw new TokenMgrError(
                EOFSeen,
                curLexState,
                error_line,
                error_column,
                error_after,
                curChar,
                TokenMgrError.LEXICAL_ERROR);
        }
    }
15052#protected void ExpandBuff(boolean wrapAround) {
        char[] newbuffer = new char[bufsize + 2048];
        int newbufline[] = new int[bufsize + 2048];
        int newbufcolumn[] = new int[bufsize + 2048];

        try {
            if (wrapAround) {
                System.arraycopy(
                    buffer,
                    tokenBegin,
                    newbuffer,
                    0,
                    bufsize - tokenBegin);
                System.arraycopy(
                    buffer,
                    0,
                    newbuffer,
                    bufsize - tokenBegin,
                    bufpos);
                buffer = newbuffer;

                System.arraycopy(
                    bufline,
                    tokenBegin,
                    newbufline,
                    0,
                    bufsize - tokenBegin);
                System.arraycopy(
                    bufline,
                    0,
                    newbufline,
                    bufsize - tokenBegin,
                    bufpos);
                bufline = newbufline;

                System.arraycopy(
                    bufcolumn,
                    tokenBegin,
                    newbufcolumn,
                    0,
                    bufsize - tokenBegin);
                System.arraycopy(
                    bufcolumn,
                    0,
                    newbufcolumn,
                    bufsize - tokenBegin,
                    bufpos);
                bufcolumn = newbufcolumn;

                maxNextCharInd = (bufpos += (bufsize - tokenBegin));
            } else {
                System.arraycopy(
                    buffer,
                    tokenBegin,
                    newbuffer,
                    0,
                    bufsize - tokenBegin);
                buffer = newbuffer;

                System.arraycopy(
                    bufline,
                    tokenBegin,
                    newbufline,
                    0,
                    bufsize - tokenBegin);
                bufline = newbufline;

                System.arraycopy(
                    bufcolumn,
                    tokenBegin,
                    newbufcolumn,
                    0,
                    bufsize - tokenBegin);
                bufcolumn = newbufcolumn;

                maxNextCharInd = (bufpos -= tokenBegin);
            }
        } catch (Throwable t) {
            throw new Error(t.getMessage());
        }

        bufsize += 2048;
        available = bufsize;
        tokenBegin = 0;
    }
15053#protected void FillBuff() throws java.io.IOException {
        if (maxNextCharInd == available) {
            if (available == bufsize) {
                if (tokenBegin > 2048) {
                    bufpos = maxNextCharInd = 0;
                    available = tokenBegin;
                } else if (tokenBegin < 0)
                    bufpos = maxNextCharInd = 0;
                else
                    ExpandBuff(false);
            } else if (available > tokenBegin)
                available = bufsize;
            else if ((tokenBegin - available) < 2048)
                ExpandBuff(true);
            else
                available = tokenBegin;
        }

        int i;
        try {
            if ((i =
                inputStream.read(
                    buffer,
                    maxNextCharInd,
                    available - maxNextCharInd))
                == -1) {
                inputStream.close();
                throw new java.io.IOException();
            } else
                maxNextCharInd += i;
            return;
        } catch (java.io.IOException e) {
            --bufpos;
            backup(0);
            if (tokenBegin == -1)
                tokenBegin = bufpos;
            throw e;
        }
    }
15054#public char BeginToken() throws java.io.IOException {
        tokenBegin = -1;
        char c = readChar();
        tokenBegin = bufpos;

        return c;
    }
15055#protected void UpdateLineColumn(char c) {
        column++;

        if (prevCharIsLF) {
            prevCharIsLF = false;
            line += (column = 1);
        } else if (prevCharIsCR) {
            prevCharIsCR = false;
            if (c == '\n') {
                prevCharIsLF = true;
            } else
                line += (column = 1);
        }

        switch (c) {
            case '\r' :
                prevCharIsCR = true;
                break;
            case '\n' :
                prevCharIsLF = true;
                break;
            case '\t' :
                column--;
                column += (8 - (column & 07));
                break;
            default :
                break;
        }

        bufline[bufpos] = line;
        bufcolumn[bufpos] = column;
    }
15056#public char readChar() throws java.io.IOException {
        if (inBuf > 0) {
            --inBuf;

            if (++bufpos == bufsize)
                bufpos = 0;

            return buffer[bufpos];
        }

        if (++bufpos >= maxNextCharInd)
            FillBuff();

        char c = buffer[bufpos];

        UpdateLineColumn(c);
        return (c);
    }
15057#public int getEndColumn() {
        return bufcolumn[bufpos];
    }
15058#public int getEndLine() {
        return bufline[bufpos];
    }
15059#public int getBeginColumn() {
        return bufcolumn[tokenBegin];
    }
15060#public int getBeginLine() {
        return bufline[tokenBegin];
    }
15061#public void backup(int amount) {

        inBuf += amount;
        if ((bufpos -= amount) < 0)
            bufpos += bufsize;
    }
15062#public SimpleCharStream(
        java.io.Reader dstream,
        int startline,
        int startcolumn,
        int buffersize) {
        inputStream = dstream;
        line = startline;
        column = startcolumn - 1;

        available = bufsize = buffersize;
        buffer = new char[buffersize];
        bufline = new int[buffersize];
        bufcolumn = new int[buffersize];
    }
15063#public SimpleCharStream(
        java.io.Reader dstream,
        int startline,
        int startcolumn) {
        this(dstream, startline, startcolumn, 4096);
    }
15064#public SimpleCharStream(java.io.Reader dstream) {
        this(dstream, 1, 1, 4096);
    }
15065#public void ReInit(
        java.io.Reader dstream,
        int startline,
        int startcolumn,
        int buffersize) {
        inputStream = dstream;
        line = startline;
        column = startcolumn - 1;

        if (buffer == null || buffersize != buffer.length) {
            available = bufsize = buffersize;
            buffer = new char[buffersize];
            bufline = new int[buffersize];
            bufcolumn = new int[buffersize];
        }
        prevCharIsLF = prevCharIsCR = false;
        tokenBegin = inBuf = maxNextCharInd = 0;
        bufpos = -1;
    }
15066#public void ReInit(
        java.io.Reader dstream,
        int startline,
        int startcolumn) {
        ReInit(dstream, startline, startcolumn, 4096);
    }
15067#public void ReInit(java.io.Reader dstream) {
        ReInit(dstream, 1, 1, 4096);
    }
15068#public SimpleCharStream(
        java.io.InputStream dstream,
        int startline,
        int startcolumn,
        int buffersize) {
        this(
            new java.io.InputStreamReader(dstream),
            startline,
            startcolumn,
            buffersize);
    }
15069#public SimpleCharStream(
        java.io.InputStream dstream,
        int startline,
        int startcolumn) {
        this(dstream, startline, startcolumn, 4096);
    }
15070#public SimpleCharStream(java.io.InputStream dstream) {
        this(dstream, 1, 1, 4096);
    }
15071#public void ReInit(
        java.io.InputStream dstream,
        int startline,
        int startcolumn,
        int buffersize) {
        ReInit(
            new java.io.InputStreamReader(dstream),
            startline,
            startcolumn,
            buffersize);
    }
15072#public void ReInit(java.io.InputStream dstream) {
        ReInit(dstream, 1, 1, 4096);
    }
15073#public void ReInit(
        java.io.InputStream dstream,
        int startline,
        int startcolumn) {
        ReInit(dstream, startline, startcolumn, 4096);
    }
15074#public String GetImage() {
        if (bufpos >= tokenBegin)
            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
        else
            return new String(buffer, tokenBegin, bufsize - tokenBegin)
                + new String(buffer, 0, bufpos + 1);
    }
15075#public char[] GetSuffix(int len) {
        char[] ret = new char[len];

        if ((bufpos + 1) >= len)
            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
        else {
            System.arraycopy(
                buffer,
                bufsize - (len - bufpos - 1),
                ret,
                0,
                len - bufpos - 1);
            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
        }

        return ret;
    }
15076#public void Done() {
        buffer = null;
        bufline = null;
        bufcolumn = null;
    }
15077#/**
     * Method to adjust line and column numbers for the start of a token.<BR>
     */
    public void adjustBeginLineColumn(int newLine, int newCol) {
        int start = tokenBegin;
        int len;

        if (bufpos >= tokenBegin) {
            len = bufpos - tokenBegin + inBuf + 1;
        } else {
            len = bufsize - tokenBegin + bufpos + 1 + inBuf;
        }

        int i = 0, j = 0, k = 0;
        int nextColDiff = 0, columnDiff = 0;

        while (i < len && bufline[j =
            start % bufsize] == bufline[k = ++start % bufsize]) {
            bufline[j] = newLine;
            nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
            bufcolumn[j] = newCol + columnDiff;
            columnDiff = nextColDiff;
            i++;
        }

        if (i < len) {
            bufline[j] = newLine++;
            bufcolumn[j] = newCol + columnDiff;

            while (i++ < len) {
                if (bufline[j = start % bufsize] != bufline[++start % bufsize])
                    bufline[j] = newLine++;
                else
                    bufline[j] = newLine;
            }
        }

        line = bufline[j];
        column = bufcolumn[j];
    }
15078#/**
     * Replaces unprintable characters by their espaced (or unicode escaped)
     * equivalents in the given string
     */
    protected static final String addEscapes(String str) {
        StringBuffer retval = new StringBuffer();
        char ch;
        for (int i = 0; i < str.length(); i++) {
            switch (str.charAt(i)) {
                case 0 :
                    continue;
                case '\b' :
                    retval.append("\\b");
                    continue;
                case '\t' :
                    retval.append("\\t");
                    continue;
                case '\n' :
                    retval.append("\\n");
                    continue;
                case '\f' :
                    retval.append("\\f");
                    continue;
                case '\r' :
                    retval.append("\\r");
                    continue;
                case '\"' :
                    retval.append("\\\"");
                    continue;
                case '\'' :
                    retval.append("\\\'");
                    continue;
                case '\\' :
                    retval.append("\\\\");
                    continue;
                default :
                    if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                        String s = "0000" + Integer.toString(ch, 16);
                        retval.append(
                            "\\u" + s.substring(s.length() - 4, s.length()));
                    } else {
                        retval.append(ch);
                    }
                    continue;
            }
        }
        return retval.toString();
    }
15079#/**
     * Returns a detailed message for the Error when it is thrown by the
     * token manager to indicate a lexical error.
     * Parameters : 
     *    EOFSeen     : indicates if EOF caused the lexicl error
     *    curLexState : lexical state in which this error occured
     *    errorLine   : line number when the error occured
     *    errorColumn : column number when the error occured
     *    errorAfter  : prefix that was seen before this error occured
     *    curchar     : the offending character
     * Note: You can customize the lexical error message by modifying this method.
     */
    protected static String LexicalError(
        boolean EOFSeen,
        int lexState,
        int errorLine,
        int errorColumn,
        String errorAfter,
        char curChar) {
        return (
            "Lexical error at line "
                + errorLine
                + ", column "
                + errorColumn
                + ".  Encountered: "
                + (EOFSeen
                    ? "<EOF> "
                    : ("\"" + addEscapes(String.valueOf(curChar)) + "\"")
                        + " ("
                        + (int) curChar
                        + "), ")
                + "after : \""
                + addEscapes(errorAfter)
                + "\"");
    }
15080#/**
     * You can also modify the body of this method to customize your error messages.
     * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
     * of end-users concern, so you can return something like : 
     *
     *     "Internal Error : Please file a bug report .... "
     *
     * from this method for such cases in the release version of your parser.
     */
    public String getMessage() {
        return super.getMessage();
    }
15081#/*
     * Constructors of various flavors follow.
     */

    public TokenMgrError() {
    }
15082#public TokenMgrError(String message, int reason) {
        super(message);
        errorCode = reason;
    }
15083#public TokenMgrError(
        boolean EOFSeen,
        int lexState,
        int errorLine,
        int errorColumn,
        String errorAfter,
        char curChar,
        int reason) {
        this(
            LexicalError(
                EOFSeen,
                lexState,
                errorLine,
                errorColumn,
                errorAfter,
                curChar),
            reason);
    }
15084#/**
     * Returns the image.
     */
    public String toString() {
        return image;
    }
15085#/**
     * Returns a new Token object, by default. However, if you want, you
     * can create and return subclass objects based on the value of ofKind.
     * Simply add the cases to the switch for all those special cases.
     * For example, if you have a subclass of Token called IDToken that
     * you want to create if ofKind is ID, simlpy add something like :
     *
     *    case MyParserConstants.ID : return new IDToken();
     *
     * to the following switch statement. Then you can cast matchedToken
     * variable to the appropriate type and use it in your lexical actions.
     */
    public static final Token newToken(int ofKind) {
        switch (ofKind) {
            default :
                return new Token();
        }
    }
15086#public static void main(String[] args) throws Exception {
        System.out.println("will parse this: " + args[0]);
        XPointerFrameworkParser xfp =
            new XPointerFrameworkParser(new java.io.StringReader(args[0]));
        xfp.pointer();
    }
15087#public static XPointer parse(String xpointer) throws ParseException {
        XPointerFrameworkParser xfp =
            new XPointerFrameworkParser(new java.io.StringReader(xpointer));
        try {
            xfp.pointer();
        } catch (TokenMgrError e) {
            // Rethrow TokenMgrErrors as ParseExceptions, because errors aren't caught by Cocoon,
            // and mistyping in a xpointer isn't such a grave error
            throw new ParseException(e.getMessage());
        }
        return xfp.getXPointer();
    }
15088#public XPointer getXPointer() {
        return xpointer;
    }
15089#private String unescape(String data) throws ParseException {
        StringBuffer result = new StringBuffer(data.length());
        boolean inCircumflex = false;
        for (int i = 0; i < data.length(); i++) {
            char c = data.charAt(i);
            if (inCircumflex) {
                switch (c) {
                    case '^' :
                    case '(' :
                    case ')' :
                        result.append(c);
                        inCircumflex = false;
                        break;
                    default :
                        throw new ParseException(
                            "Incorrect use of circumflex character at position "
                                + i
                                + " in the string "
                                + data);
                }
            } else if (c == '^') {
                inCircumflex = true;
            } else {
                result.append(c);
            }
        }
        return result.toString();
    }
15090#final public void pointer() throws ParseException {
        if (jj_2_1(2)) {
            schemeBased();
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case NCName :
                    shortHand();
                    break;
                default :
                    jj_la1[0] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }
15091#final public void shortHand() throws ParseException {
        Token x;
        x = jj_consume_token(NCName);
        xpointer.addPart(new ShorthandPart(x.image));
    }
15092#final public void schemeBased() throws ParseException {
        pointerPart();
        label_1 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case NCName :
                case WS :
                case QName :
                    break;
                default :
                    jj_la1[1] = jj_gen;
                    break label_1;
            }
            label_2 : while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case WS :
                        break;
                    default :
                        jj_la1[2] = jj_gen;
                        break label_2;
                }
                jj_consume_token(WS);
            }
            pointerPart();
        }
    }
15093#final public void pointerPart() throws ParseException {
        Token x;
        String schemeName;
        String schemeData;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NCName :
                x = jj_consume_token(NCName);
                break;
            case QName :
                x = jj_consume_token(QName);
                break;
            default :
                jj_la1[3] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        jj_consume_token(LBRACE);
        // when going inside the scheme data, swith to a different lexical state
        token_source.SwitchTo(IN_SCHEME);

        // store the scheme name
        schemeName = x.image;
        schemeData = schemeData();
        jj_consume_token(RBRACE);
        // when going outside the scheme data, swith back to the default lexical state
        token_source.SwitchTo(DEFAULT);

        // parse schemeName in prefix and localName
        String schemeNamespace = null, schemeLocalName = null;
        int colonPos = schemeName.indexOf(':');
        if (colonPos != -1) {
            String schemePrefix = schemeName.substring(0, colonPos);
            schemeNamespace = (String) namespaces.get(schemePrefix);
            schemeLocalName = schemeName.substring(colonPos + 1);
        } else {
            schemeLocalName = schemeName;
        }

        // add the pointer part
        if (schemeNamespace == null && schemeLocalName.equals("xmlns")) {
            int eqPos = schemeData.indexOf("=");
            if (eqPos == -1) {
                if (true)
                    throw new ParseException("xmlns scheme data should contain an equals sign");
            }

            // Note: the trimming below is not entirely correct, since space is only allowed left
            // and right of the equal sign, but not at the beginning and end of the schemeData
            String prefix = schemeData.substring(0, eqPos).trim();
            String namespace =
                schemeData.substring(eqPos + 1, schemeData.length()).trim();
            xpointer.addPart(new XmlnsPart(prefix, namespace));
            namespaces.put(prefix, namespace);
        } else if (
            schemeNamespace == null && schemeLocalName.equals("xpointer")) {
            xpointer.addPart(new XPointerPart(schemeData));
        } else if (
            "http://apache.org/cocoon/xpointer".equals(schemeNamespace)
                && schemeLocalName.equals("elementpath")) {
            xpointer.addPart(new ElementPathPart(schemeData));
        } else {
            xpointer.addPart(new UnsupportedPart(schemeName));
        }
    }
15094#final public String schemeData() throws ParseException {
        String temp;
        StringBuffer schemeData = new StringBuffer();
        label_3 : while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LBRACE :
                case CIRC_LBRACE :
                case CIRC_RBRACE :
                case DOUBLE_CIRC :
                case NormalChar :
                    break;
                default :
                    jj_la1[4] = jj_gen;
                    break label_3;
            }
            temp = escapedData();
            schemeData.append(temp);
        }
        {
            if (true)
                return unescape(schemeData.toString());
        }
        throw new Error("Missing return statement in function");
    }
15095#final public String escapedData() throws ParseException {
        Token x;
        String temp;
        StringBuffer data = new StringBuffer();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NormalChar :
                x = jj_consume_token(NormalChar);
                data.append(x.image);
                break;
            case CIRC_LBRACE :
                x = jj_consume_token(CIRC_LBRACE);
                data.append(x.image);
                break;
            case CIRC_RBRACE :
                x = jj_consume_token(CIRC_RBRACE);
                data.append(x.image);
                break;
            case DOUBLE_CIRC :
                x = jj_consume_token(DOUBLE_CIRC);
                data.append(x.image);
                break;
            case LBRACE :
                x = jj_consume_token(LBRACE);
                data.append(x.image);
                temp = schemeData();
                data.append(temp);
                x = jj_consume_token(RBRACE);
                data.append(x.image);
                break;
            default :
                jj_la1[5] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true)
                return data.toString();
        }
        throw new Error("Missing return statement in function");
    }
15096#final private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        boolean retval = !jj_3_1();
        jj_save(0, xla);
        return retval;
    }
15097#final private boolean jj_3R_6() {
        if (jj_scan_token(NCName))
            return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos)
            return false;
        return false;
    }
15098#final private boolean jj_3R_4() {
        if (jj_3R_5())
            return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos)
            return false;
        return false;
    }
15099#final private boolean jj_3R_5() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_6()) {
            jj_scanpos = xsp;
            if (jj_3R_7())
                return true;
            if (jj_la == 0 && jj_scanpos == jj_lastpos)
                return false;
        } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
            return false;
        if (jj_scan_token(LBRACE))
            return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos)
            return false;
        return false;
    }
15100#final private boolean jj_3R_7() {
        if (jj_scan_token(QName))
            return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos)
            return false;
        return false;
    }
15101#final private boolean jj_3_1() {
        if (jj_3R_4())
            return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos)
            return false;
        return false;
    }
15102#private static void jj_la1_0() {
        jj_la1_0 = new int[] { 0x80, 0x380, 0x100, 0x280, 0xf400, 0xf400, };
    }
15103#public XPointerFrameworkParser(java.io.InputStream stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new XPointerFrameworkParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 6; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }
15104#public void ReInit(java.io.InputStream stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 6; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }
15105#public XPointerFrameworkParser(java.io.Reader stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new XPointerFrameworkParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 6; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }
15106#public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 6; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }
15107#public XPointerFrameworkParser(XPointerFrameworkParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 6; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }
15108#public void ReInit(XPointerFrameworkParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 6; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }
15109#final private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null) {
                        if (c.gen < jj_gen)
                            c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }
15110#final private boolean jj_scan_token(int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos =
                    jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null)
                jj_add_error_token(kind, i);
        }
        return (jj_scanpos.kind != kind);
    }
15111#final public Token getNextToken() {
        if (token.next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }
15112#final public Token getToken(int index) {
        Token t = lookingAhead ? jj_scanpos : token;
        for (int i = 0; i < index; i++) {
            if (t.next != null)
                t = t.next;
            else
                t = t.next = token_source.getNextToken();
        }
        return t;
    }
15113#final private int jj_ntk() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }
15114#private void jj_add_error_token(int kind, int pos) {
        if (pos >= 100)
            return;
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            for (int i = 0; i < jj_endpos; i++) {
                jj_expentry[i] = jj_lasttokens[i];
            }
            boolean exists = false;
            for (java.util.Enumeration enumeration = jj_expentries.elements();
                enumeration.hasMoreElements();
                ) {
                int[] oldentry = (int[]) (enumeration.nextElement());
                if (oldentry.length == jj_expentry.length) {
                    exists = true;
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            exists = false;
                            break;
                        }
                    }
                    if (exists)
                        break;
                }
            }
            if (!exists)
                jj_expentries.addElement(jj_expentry);
            if (pos != 0)
                jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }
15115#public ParseException generateParseException() {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[16];
        for (int i = 0; i < 16; i++) {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 6; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 16; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[]) jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }
15116#final public void enable_tracing() {
    }
15117#final public void disable_tracing() {
    }
15118#final private void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 1; i++) {
            JJCalls p = jj_2_rtns[i];
            do {
                if (p.gen > jj_gen) {
                    jj_la = p.arg;
                    jj_lastpos = jj_scanpos = p.first;
                    switch (i) {
                        case 0 :
                            jj_3_1();
                            break;
                    }
                }
                p = p.next;
            } while (p != null);
        }
        jj_rescan = false;
    }
15119#final private void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }
15120#/**
     * This constructor is used by the method "generateParseException"
     * in the generated parser.  Calling this constructor generates
     * a new object of this type with the fields "currentToken",
     * "expectedTokenSequences", and "tokenImage" set.  The boolean
     * flag "specialConstructor" is also set to true to indicate that
     * this constructor was used to create this object.
     * This constructor calls its super class with the empty string
     * to force the "toString" method of parent class "Throwable" to
     * print the error message in the form:
     *     ParseException: <result of getMessage>
     */
    public ParseException(
        Token currentTokenVal,
        int[][] expectedTokenSequencesVal,
        String[] tokenImageVal) {
        super("");
        specialConstructor = true;
        currentToken = currentTokenVal;
        expectedTokenSequences = expectedTokenSequencesVal;
        tokenImage = tokenImageVal;
    }
15121#/**
     * The following constructors are for use by you for whatever
     * purpose you can think of.  Constructing the exception in this
     * manner makes the exception behave in the normal way - i.e., as
     * documented in the class "Throwable".  The fields "errorToken",
     * "expectedTokenSequences", and "tokenImage" do not contain
     * relevant information.  The JavaCC generated code does not use
     * these constructors.
     */

    public ParseException() {
        super();
        specialConstructor = false;
    }
15122#public ParseException(String message) {
        super(message);
        specialConstructor = false;
    }
15123#/**
     * This method has the standard behavior when this object has been
     * created using the standard constructors.  Otherwise, it uses
     * "currentToken" and "expectedTokenSequences" to generate a parse
     * error message and returns it.  If this object has been created
     * due to a parse error, and you do not catch it (it gets thrown
     * from the parser), then this method is called during the printing
     * of the final stack trace, and hence the correct error message
     * gets displayed.
     */
    public String getMessage() {
        if (!specialConstructor) {
            return super.getMessage();
        }
        String expected = "";
        int maxSize = 0;
        for (int i = 0; i < expectedTokenSequences.length; i++) {
            if (maxSize < expectedTokenSequences[i].length) {
                maxSize = expectedTokenSequences[i].length;
            }
            for (int j = 0; j < expectedTokenSequences[i].length; j++) {
                expected += tokenImage[expectedTokenSequences[i][j]] + " ";
            }
            if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1]
                != 0) {
                expected += "...";
            }
            expected += eol + "    ";
        }
        String retval = "Encountered \"";
        Token tok = currentToken.next;
        for (int i = 0; i < maxSize; i++) {
            if (i != 0)
                retval += " ";
            if (tok.kind == 0) {
                retval += tokenImage[0];
                break;
            }
            retval += add_escapes(tok.image);
            tok = tok.next;
        }
        retval += "\" at line "
            + currentToken.next.beginLine
            + ", column "
            + currentToken.next.beginColumn;
        retval += "." + eol;
        if (expectedTokenSequences.length == 1) {
            retval += "Was expecting:" + eol + "    ";
        } else {
            retval += "Was expecting one of:" + eol + "    ";
        }
        retval += expected;
        return retval;
    }
15124#/**
     * Used to convert raw characters to their escaped version
     * when these raw version cannot be used as part of an ASCII
     * string literal.
     */
    protected String add_escapes(String str) {
        StringBuffer retval = new StringBuffer();
        char ch;
        for (int i = 0; i < str.length(); i++) {
            switch (str.charAt(i)) {
                case 0 :
                    continue;
                case '\b' :
                    retval.append("\\b");
                    continue;
                case '\t' :
                    retval.append("\\t");
                    continue;
                case '\n' :
                    retval.append("\\n");
                    continue;
                case '\f' :
                    retval.append("\\f");
                    continue;
                case '\r' :
                    retval.append("\\r");
                    continue;
                case '\"' :
                    retval.append("\\\"");
                    continue;
                case '\'' :
                    retval.append("\\\'");
                    continue;
                case '\\' :
                    retval.append("\\\\");
                    continue;
                default :
                    if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                        String s = "0000" + Integer.toString(ch, 16);
                        retval.append(
                            "\\u" + s.substring(s.length() - 4, s.length()));
                    } else {
                        retval.append(ch);
                    }
                    continue;
            }
        }
        return retval.toString();
    }
15125#/**
     * <p>Return a <code>TransformerHandler</code> for a given
     * stylesheet {@link Source}. This can be used in a pipeline to
     * handle the transformation of a stream of SAX events. See {@link
     * org.apache.cocoon.transformation.TraxTransformer#setConsumer} for
     * an example of how to use this method.
     *
     * <p>The additional <code>filter</code> argument, if it's not
     * <code>null</code>, is inserted in the chain SAX events as an XML
     * filter during the parsing or the source document.
     *
     * <p>This method caches the Templates object with meta information
     * (modification time and list of included stylesheets) and performs
     * a reparsing only if this changes.
     *
     * @param stylesheet a {@link Source} value
     * @param filter a {@link XMLFilter} value
     * @return a {@link TransformerHandler} value
     * @exception XSLTProcessorException if an error occurs
     */
    TransformerHandler getTransformerHandler( Source stylesheet, XMLFilter filter )
    throws XSLTProcessorException;
15126#/**
     * <p>Return a {@link TransformerHandler} and
     * <code>SourceValidity</code> for a given stylesheet
     * {@link Source}. This can be used in a pipeline to
     * handle the transformation of a stream of SAX events. See {@link
     * org.apache.cocoon.transformation.TraxTransformer#setConsumer} for
     * an example of how to use this method.
     *
     * <p>The additional <code>filter</code> argument, if it's not
     * <code>null</code>, is inserted in the chain SAX events as an XML
     * filter during the parsing or the source document.
     *
     * <p>This method caches the Templates object with meta information
     * (modification time and list of included stylesheets) and performs
     * a reparsing only if this changes.
     *
     * @param stylesheet a {@link Source} value
     * @param filter a {@link XMLFilter} value
     * @return a <code>TransformerHandlerAndValidity</code> value
     * @exception XSLTProcessorException if an error occurs
     */
    TransformerHandlerAndValidity getTransformerHandlerAndValidity( Source stylesheet, XMLFilter filter )
    throws XSLTProcessorException;
15127#/**
     * Same as {@link #getTransformerHandler(Source,XMLFilter)}, with
     * <code>filter</code> set to <code>null</code>.
     *
     * @param stylesheet a {@link Source} value
     * @return a {@link TransformerHandler} value
     * @exception XSLTProcessorException if an error occurs
     */
    TransformerHandler getTransformerHandler( Source stylesheet )
    throws XSLTProcessorException;
15128#/**
     * Same as {@link #getTransformerHandlerAndValidity(Source,XMLFilter)}, with
     * <code>filter</code> set to <code>null</code>.
     *
     * @param stylesheet a {@link Source} value
     * @return a {@link TransformerHandlerAndValidity} value
     * @exception XSLTProcessorException if an error occurs
     */
    TransformerHandlerAndValidity getTransformerHandlerAndValidity( Source stylesheet )
    throws XSLTProcessorException;
15129#/**
     * Applies an XSLT stylesheet to an XML document. The source and
     * stylesheet documents are specified as {@link Source}
     * objects. The result of the transformation is placed in
     * {@link Result}, which should be properly initialized before
     * invoking this method. Any additional parameters passed in
     * {@link Map params} will become arguments to the stylesheet.
     *
     * @param source a {@link Source} value
     * @param stylesheet a {@link Source} value
     * @param params a <code>Map</code>
     * @param result a <code>Result</code> value
     * @exception XSLTProcessorException if an error occurs
     */
    void transform( Source source, Source stylesheet, Map params, Result result )
    throws XSLTProcessorException;
15130#protected TransformerHandlerAndValidity( final TransformerHandler transformerHandler,
                                                 final SourceValidity transformerValidity ) {
            this.transformerHandler = transformerHandler;
            this.transformerValidity = transformerValidity;
        }
15131#public TransformerHandler getTransfomerHandler() {
            return transformerHandler;
        }
15132#public SourceValidity getTransfomerValidity() {
            return transformerValidity;
        }
15133#public TraxErrorListener(String uri) {
        this.uri = uri;
    }
15134#/**
     * Get the exception that was catched by this listener, if any.
     * 
     * @return the exception
     */
    public Throwable getThrowable() {
        if (exception == null) {
            return null;
        }
        
        Location loc = LocationUtils.getLocation(exception);
        if (LocationUtils.isKnown(loc)) {
            // Has a location: don't loose this precious information!
            return exception;
        }
        
        // No location: if it's just a wrapper, consider only the wrapped exception
        if (exception.getCause() != null) {
            return exception.getCause();
        }
        
        // That's the actual exception!
        return exception;
    }
15135#public void warning(TransformerException ex) throws TransformerException {
        // TODO: We may want here to allow some special formatting of the messages, such as
        // "DEBUG:A debug message" or "INFO:Transforming <foo> in mode 'bar'" to use the different
        // log levels. This can include also deprecation logs for system-defined stylesheets
        // using "DEPRECATED:WARN:Styling 'foo' is replaced by 'bar'".    

        if (getLogger().isWarnEnabled()) {
            Location loc = LocationUtils.getLocation(ex);
            getLogger().warn(ex.getMessage() + " at " + (loc == null ? uri : loc.toString()));
        }

        // Keep the warning (see below)
        warningEx = ex;
    }
15136#public void error(TransformerException ex) throws TransformerException {

        // If we had a warning previoulsy, and the current exception has no cause, then use the warning.
        // This is how Xalan behaves on <xsl:message terminate="yes">: it first issues a warning with all
        // the useful information, then a useless "stylesheed directed termination" error.
        if (warningEx != null && ex.getCause() == null) {
            ex = warningEx;
        }
        warningEx = null;

        // Keep the exception for later use.
        exception = ex;
        // and rethrow it
        throw ex;
    }
15137#public void fatalError(TransformerException ex) throws TransformerException {
        if (warningEx != null && ex.getCause() == null) {
            ex = warningEx;
        }
        warningEx = null;

        exception = ex;
        throw ex;
    }
15138#/**
     * Compose. Try to get the store
     *
     * @avalon.service interface="XMLizer"
     * @avalon.service interface="SourceResolver"
     * @avalon.service interface="Store/TransientStore" optional="true"
     */
    public void service(final ServiceManager manager) throws ServiceException {
        m_manager = manager;
        saxParser = (SAXParser) m_manager.lookup(SAXParser.ROLE);
        m_resolver = (SourceResolver) m_manager.lookup(SourceResolver.ROLE);

        if (m_manager.hasService(Store.TRANSIENT_STORE)) {
            m_store = (Store) m_manager.lookup(Store.TRANSIENT_STORE);
        }
    }
15139#/**
     * @see org.apache.avalon.framework.activity.Initializable#initialize()
     */
    public void initialize() throws Exception {
        m_factory = getTransformerFactory(m_transformerFactory);
        m_defaultFactory = m_factory;
    }
15140#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        if (null != m_manager) {
            m_manager.release(m_store);
            m_manager.release(m_resolver);
            m_manager = null;
        }
        saxParser = null;
        m_store = null;
        m_resolver = null;
    }
15141#/**
     * Configure the component
     */
    public void parameterize(final Parameters params) throws ParameterException {
        m_useStore = params.getParameterAsBoolean("use-store", this.m_useStore);
        m_incrementalProcessing = params.getParameterAsBoolean("incremental-processing", this.m_incrementalProcessing);
        m_transformerFactory = params.getParameter("transformer-factory", null);
        m_checkIncludes = params.getParameterAsBoolean("check-includes", true);
        if (!m_useStore) {
            // release the store, if we don't need it anymore
            m_manager.release(m_store);
            m_store = null;
        } else if (null == m_store) {
            final String message = "XSLTProcessor: use-store is set to true, " + "but unable to aquire the Store.";
            throw new ParameterException(message);
        }
    }
15142#/**
     * Set the transformer factory used by this component
     */
    public void setTransformerFactory(final String classname) {
        m_factory = getTransformerFactory(classname);
    }
15143#/**
     * @see org.apache.excalibur.xml.xslt.XSLTProcessor#getTransformerHandler(Source)
     */
    public TransformerHandler getTransformerHandler(final Source stylesheet) throws XSLTProcessorException {
        return getTransformerHandler(stylesheet, null);
    }
15144#/**
     * @see org.apache.excalibur.xml.xslt.XSLTProcessor#getTransformerHandler(Source, XMLFilter)
     */
    public TransformerHandler getTransformerHandler(final Source stylesheet, final XMLFilter filter)
    throws XSLTProcessorException {
        final XSLTProcessor.TransformerHandlerAndValidity validity = getTransformerHandlerAndValidity(stylesheet, filter);
        return validity.getTransfomerHandler();
    }
15145#public TransformerHandlerAndValidity getTransformerHandlerAndValidity(final Source stylesheet)
    throws XSLTProcessorException {
        return getTransformerHandlerAndValidity(stylesheet, null);
    }
15146#public TransformerHandlerAndValidity getTransformerHandlerAndValidity(Source stylesheet, XMLFilter filter)
    throws XSLTProcessorException {

        final String id = stylesheet.getURI();
        TransformerHandlerAndValidity handlerAndValidity;

        try {
            handlerAndValidity = getTemplates(stylesheet, id);
            if (handlerAndValidity != null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Reusing Templates for " + id);
                }
                return handlerAndValidity;
            }
        } catch (Exception e) {
            throw new XSLTProcessorException("Error retrieving template", e);
        }

        TraxErrorListener errorListener = new TraxErrorListener(stylesheet.getURI());
        try {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Creating new Templates for " + id);
            }

            m_factory.setErrorListener(errorListener);

            // Create a Templates ContentHandler to handle parsing of the
            // stylesheet.
            TemplatesHandler templatesHandler = m_factory.newTemplatesHandler();

            // Set the system ID for the template handler since some
            // TrAX implementations (XSLTC) rely on this in order to obtain
            // a meaningful identifier for the Templates instances.
            templatesHandler.setSystemId(id);
            if (filter != null) {
                filter.setContentHandler(templatesHandler);
            }

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Source = " + stylesheet + ", templatesHandler = " + templatesHandler);
            }

            // Initialize List for included validities
            SourceValidity validity = stylesheet.getValidity();
            if (validity != null && m_checkIncludes) {
                m_includesMap.put(id, new ArrayList());
            }

            try {
                // Process the stylesheet.
                sourceToSAX(stylesheet, filter != null ? (ContentHandler) filter : (ContentHandler) templatesHandler);

                // Get the Templates object (generated during the parsing of
                // the stylesheet) from the TemplatesHandler.
                final Templates template = templatesHandler.getTemplates();

                if (null == template) {
                    throw new XSLTProcessorException("Unable to create templates for stylesheet: " + stylesheet.getURI());
                }

                // Must set base for Xalan stylesheet.
                // Otherwise document('') in logicsheet causes NPE.
                Class clazz = template.getClass();
                if (clazz.getName().equals("org.apache.xalan.templates.StylesheetRoot")) {
                    Method method = clazz.getMethod("setHref", new Class[]{String.class});
                    method.invoke(template, new Object[]{id});
                }

                putTemplates(template, stylesheet, id);

                // Create transformer handler
                final TransformerHandler handler = m_factory.newTransformerHandler(template);
                handler.getTransformer().setErrorListener(new TraxErrorListener(stylesheet.getURI()));
                handler.getTransformer().setURIResolver(this);

                // Create aggregated validity
                AggregatedValidity aggregated;
                if (validity != null && m_checkIncludes) {
                    List includes = (List) m_includesMap.get(id);
                    if (includes != null) {
                        aggregated = new AggregatedValidity();
                        aggregated.add(validity);
                        for (int i = includes.size() - 1; i >= 0; i--) {
                            aggregated.add((SourceValidity) ((Object[]) includes.get(i))[1]);
                        }
                        validity = aggregated;
                    }
                }

                // Create result
                handlerAndValidity = new MyTransformerHandlerAndValidity(handler, validity);
            } finally {
                if (m_checkIncludes) {
                    m_includesMap.remove(id);
                }
            }

            return handlerAndValidity;
        } catch (Exception e) {
            Throwable realEx = errorListener.getThrowable();
            if (realEx == null) {
                realEx = e;
            }

            if (realEx instanceof RuntimeException) {
                throw (RuntimeException)realEx;
            }

            if (realEx instanceof XSLTProcessorException) {
                throw (XSLTProcessorException)realEx;
            }

            throw new XSLTProcessorException("Exception when creating Transformer from " + stylesheet.getURI(), realEx);
        }
    }
15147#private void sourceToSAX(Source source, ContentHandler handler)
    throws SAXException, IOException, ProcessingException {
        if (source instanceof XMLizable) {
            ((XMLizable) source).toSAX(handler);
        } else {
            this.saxParser.parse(SourceUtil.getInputSource(source), handler);
        }
    }
15148#public void transform(final Source source, final Source stylesheet, final Parameters params, final Result result)
    throws XSLTProcessorException {
        try {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Transform source = " + source + ", stylesheet = " + stylesheet +
                                  ", parameters = " + params + ", result = " + result);
            }
            final TransformerHandler handler = getTransformerHandler(stylesheet);
            if (params != null) {
                final Transformer transformer = handler.getTransformer();
                transformer.clearParameters();
                String[] names = params.getNames();
                for (int i = names.length - 1; i >= 0; i--) {
                    transformer.setParameter(names[i], params.getParameter(names[i]));
                }
            }

            handler.setResult(result);
            sourceToSAX(source, handler);
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Transform done");
            }
        } catch (SAXException e) {
            // Unwrapping the exception will "remove" the real cause with
            // never Xalan versions and makes the exception message unusable
            final String message = "Error in running Transformation";
            throw new XSLTProcessorException(message, e);
            /*
             * if( e.getException() == null ) { final String message = "Error in
             * running Transformation"; throw new XSLTProcessorException(
             * message, e ); } else { final String message = "Got SAXException.
             * Rethrowing cause exception."; getLogger().debug( message, e );
             * throw new XSLTProcessorException( "Error in running
             * Transformation", e.getException() ); }
             */
        } catch (Exception e) {
            final String message = "Error in running Transformation";
            throw new XSLTProcessorException(message, e);
        }
    }
15149#/**
     * Get the TransformerFactory associated with the given classname. If the
     * class can't be found or the given class doesn't implement the required
     * interface, the default factory is returned.
     */
    private SAXTransformerFactory getTransformerFactory(String factoryName) {
        SAXTransformerFactory _factory;

        if (null == factoryName) {
            _factory = (SAXTransformerFactory) TransformerFactory.newInstance();
        } else {
            try {
                ClassLoader loader = Thread.currentThread().getContextClassLoader();
                if (loader == null) {
                    loader = getClass().getClassLoader();
                }
                _factory = (SAXTransformerFactory) loader.loadClass(factoryName).newInstance();
            } catch (ClassNotFoundException cnfe) {
                getLogger().error("Cannot find the requested TrAX factory '" + factoryName + "'. Using default TrAX Transformer Factory instead.");
                if (m_factory != null)
                    return m_factory;
                _factory = (SAXTransformerFactory) TransformerFactory.newInstance();
            } catch (ClassCastException cce) {
                getLogger().error(
                        "The indicated class '" + factoryName
                                + "' is not a TrAX Transformer Factory. Using default TrAX Transformer Factory instead.");
                if (m_factory != null)
                    return m_factory;
                _factory = (SAXTransformerFactory) TransformerFactory.newInstance();
            } catch (Exception e) {
                getLogger().error(
                        "Error found loading the requested TrAX Transformer Factory '" + factoryName
                                + "'. Using default TrAX Transformer Factory instead.");
                if (m_factory != null)
                    return m_factory;
                _factory = (SAXTransformerFactory) TransformerFactory.newInstance();
            }
        }

        _factory.setErrorListener(new TraxErrorListener(null));
        _factory.setURIResolver(this);

        // FIXME (SM): implementation-specific parameter passing should be
        // made more extensible.
        if (_factory.getClass().getName().equals("org.apache.xalan.processor.TransformerFactoryImpl")) {
            _factory.setAttribute("http://xml.apache.org/xalan/features/incremental", Boolean.valueOf(m_incrementalProcessing));
        }
        // SAXON 8 will not report errors unless version warning is set to false.
        if (_factory.getClass().getName().equals("net.sf.saxon.TransformerFactoryImpl")) {
            _factory.setAttribute("http://saxon.sf.net/feature/version-warning", Boolean.FALSE);
        }

        return _factory;
    }
15150#private TransformerHandlerAndValidity getTemplates(Source stylesheet, String id)
    throws IOException, TransformerException {
        if (!m_useStore) {
            return null;
        }

        // we must augment the template ID with the factory classname since one
        // transformer implementation cannot handle the instances of a
        // template created by another one.
        String key = "XSLTTemplate: " + id + '(' + m_factory.getClass().getName() + ')';

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("getTemplates: stylesheet " + id);
        }

        // Stored is an array of the templates and the caching time and list of
        // includes
        Object[] templateAndValidityAndIncludes = (Object[]) m_store.get(key);
        if (templateAndValidityAndIncludes == null) {
            // Templates not found in cache
            return null;
        }

        // Check template validity
        SourceValidity storedValidity = (SourceValidity) templateAndValidityAndIncludes[1];
        int valid = storedValidity.isValid();
        if (valid == SourceValidity.UNKNOWN) {
            SourceValidity newValidity = stylesheet.getValidity();
            if (newValidity != null) {
                valid = storedValidity.isValid(newValidity);
            }
        }

        // Only valid stylesheets are stored
        if (valid != SourceValidity.VALID) {
            m_store.remove(key);
            return null;
        }

        // Check includes
        if (m_checkIncludes) {
            AggregatedValidity aggregated;
            List includes = (List) templateAndValidityAndIncludes[2];
            if (includes != null) {
                aggregated = new AggregatedValidity();
                aggregated.add(storedValidity);

                for (int i = includes.size() - 1; i >= 0; i--) {
                    // Every include stored as pair of source ID and validity
                    Object[] pair = (Object[]) includes.get(i);
                    storedValidity = (SourceValidity) pair[1];
                    aggregated.add(storedValidity);

                    valid = storedValidity.isValid();
                    if (valid == SourceValidity.UNKNOWN) {
                        Source includedSource = null;
                        try {
                            includedSource = m_resolver.resolveURI((String) pair[0]);
                            SourceValidity included = includedSource.getValidity();
                            if (included != null) {
                                valid = storedValidity.isValid(included);
                            }
                        } finally {
                            m_resolver.release(includedSource);
                        }
                    }
                    if (valid != SourceValidity.VALID) {
                        m_store.remove(key);
                        return null;
                    }
                }
                storedValidity = aggregated;
            }
        }

        TransformerHandler handler = m_factory.newTransformerHandler((Templates) templateAndValidityAndIncludes[0]);
        handler.getTransformer().setErrorListener(new TraxErrorListener(stylesheet.getURI()));
        handler.getTransformer().setURIResolver(this);
        return new MyTransformerHandlerAndValidity(handler, storedValidity);
    }
15151#private void putTemplates(Templates templates, Source stylesheet, String id) throws IOException {
        if (!m_useStore) {
            return;
        }

        // we must augment the template ID with the factory classname since one
        // transformer implementation cannot handle the instances of a
        // template created by another one.
        String key = "XSLTTemplate: " + id + '(' + m_factory.getClass().getName() + ')';

        // only stylesheets with a last modification date are stored
        SourceValidity validity = stylesheet.getValidity();
        if (null != validity) {
            // Stored is an array of the template and the current time
            Object[] templateAndValidityAndIncludes = new Object[3];
            templateAndValidityAndIncludes[0] = templates;
            templateAndValidityAndIncludes[1] = validity;
            if (m_checkIncludes) {
                templateAndValidityAndIncludes[2] = m_includesMap.get(id);
            }
            m_store.store(key, templateAndValidityAndIncludes);
        }
    }
15152#/**
     * Called by the processor when it encounters an xsl:include, xsl:import, or
     * document() function.
     *
     * @param href
     *            An href attribute, which may be relative or absolute.
     * @param base
     *            The base URI in effect when the href attribute was
     *            encountered.
     *
     * @return A Source object, or null if the href cannot be resolved, and the
     *         processor should try to resolve the URI itself.
     *
     * @throws TransformerException
     *             if an error occurs when trying to resolve the URI.
     */
    public javax.xml.transform.Source resolve(String href, String base) throws TransformerException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("resolve(href = " + href + ", base = " + base + "); resolver = " + m_resolver);
        }

        Source xslSource = null;
        try {
            if (base == null || href.indexOf(":") > 1) {
                // Null base - href must be an absolute URL
                xslSource = m_resolver.resolveURI(href);
            } else if (href.length() == 0) {
                // Empty href resolves to base
                xslSource = m_resolver.resolveURI(base);
            } else {
                // is the base a file or a real m_url
                if (!base.startsWith("file:")) {
                    int lastPathElementPos = base.lastIndexOf('/');
                    if (lastPathElementPos == -1) {
                        // this should never occur as the base should
                        // always be protocol:/....
                        return null; // we can't resolve this
                    } else {
                        xslSource = m_resolver.resolveURI(base.substring(0, lastPathElementPos) + "/" + href);
                    }
                } else {
                    File parent = new File(base.substring(5));
                    File parent2 = new File(parent.getParentFile(), href);
                    xslSource = m_resolver.resolveURI(parent2.toURL().toExternalForm());
                }
            }

            InputSource is = getInputSource(xslSource);

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("xslSource = " + xslSource + ", system id = " + xslSource.getURI());
            }

            if (m_checkIncludes) {
                // Populate included validities
                List includes = (List) m_includesMap.get(base);
                if (includes != null) {
                    SourceValidity included = xslSource.getValidity();
                    if (included != null) {
                        includes.add(new Object[] { xslSource.getURI(), xslSource.getValidity() });
                    } else {
                        // One of the included stylesheets is not cacheable
                        m_includesMap.remove(base);
                    }
                }
            }

            return new StreamSource(is.getByteStream(), is.getSystemId());
        } catch (SourceException e) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Failed to resolve " + href + "(base = " + base + "), return null", e);
            }

            // CZ: To obtain the same behaviour as when the resource is
            // transformed by the XSLT Transformer we should return null here.
            return null;
        } catch (java.net.MalformedURLException mue) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Failed to resolve " + href + "(base = " + base + "), return null", mue);
            }

            return null;
        } catch (IOException ioe) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Failed to resolve " + href + "(base = " + base + "), return null", ioe);
            }

            return null;
        } finally {
            m_resolver.release(xslSource);
        }
    }
15153#/**
     * Return a new <code>InputSource</code> object that uses the
     * <code>InputStream</code> and the system ID of the <code>Source</code>
     * object.
     *
     * @throws IOException
     *             if I/O error occured.
     */
    private static InputSource getInputSource(final Source source) throws IOException {
        final InputSource newObject = new InputSource(source.getInputStream());
        newObject.setSystemId(source.getURI());
        return newObject;
    }
15154#/**
     * Recycle the component
     */
    public void recycle() {
        m_includesMap.clear();
        // restore default factory
        if (m_factory != m_defaultFactory) {
            m_factory = m_defaultFactory;
        }
    }
15155#protected MyTransformerHandlerAndValidity(TransformerHandler handler, SourceValidity validity) {
            super(handler, validity);
        }
15156#/**
     * Initialize this component.
     */
    public void init() throws Exception {
        this.factory = getTransformerFactory(this.transformerFactory);
    }
15157#public void setStore(Store store) {
        this.store = store;
    }
15158#public void setIncrementalProcessing(boolean incrementalProcessing) {
        this.incrementalProcessing = incrementalProcessing;
    }
15159#public void setResolver(SourceResolver resolver) {
        this.resolver = resolver;
    }
15160#public void setCheckIncludes(boolean checkIncludes) {
        this.checkIncludes = checkIncludes;
    }
15161#public void setSaxParser(SAXParser saxParser) {
        this.saxParser = saxParser;
    }
15162#/**
     * Set the transformer factory used by this component
     */
    public void setTransformerFactory(final String classname) {
        this.transformerFactory = classname;
    }
15163#/**
     * @see org.apache.excalibur.xml.xslt.XSLTProcessor#getTransformerHandler(org.apache.excalibur.source.Source)
     */
    public TransformerHandler getTransformerHandler(final Source stylesheet) throws XSLTProcessorException {
        return getTransformerHandler(stylesheet, null);
    }
15164#/**
     * @see org.apache.excalibur.xml.xslt.XSLTProcessor#getTransformerHandler(org.apache.excalibur.source.Source,
     *      org.xml.sax.XMLFilter)
     */
    public TransformerHandler getTransformerHandler(final Source stylesheet, final XMLFilter filter) throws XSLTProcessorException {
        final XSLTProcessor.TransformerHandlerAndValidity validity = getTransformerHandlerAndValidity(stylesheet, filter);
        return validity.getTransfomerHandler();
    }
15165#/**
     * @see org.apache.excalibur.xml.xslt.XSLTProcessor#getTransformerHandlerAndValidity(org.apache.excalibur.source.Source)
     */
    public TransformerHandlerAndValidity getTransformerHandlerAndValidity(final Source stylesheet) throws XSLTProcessorException {
        return getTransformerHandlerAndValidity(stylesheet, null);
    }
15166#/**
     * @see org.apache.excalibur.xml.xslt.XSLTProcessor#getTransformerHandlerAndValidity(org.apache.excalibur.source.Source, org.xml.sax.XMLFilter)
     */
    public TransformerHandlerAndValidity getTransformerHandlerAndValidity(Source stylesheet, XMLFilter filter) throws XSLTProcessorException {

        final String id = stylesheet.getURI();
        TransformerHandlerAndValidity handlerAndValidity;

        try {
            handlerAndValidity = getTemplates(stylesheet, id);
            if (handlerAndValidity != null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Reusing Templates for " + id);
                }
                return handlerAndValidity;
            }
        } catch(Exception e) {
            throw new XSLTProcessorException("Error retrieving template", e);
        }

        XSLTProcessorErrorListener errorListener = new XSLTProcessorErrorListener(getLogger(), stylesheet.getURI());
        try{
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Creating new Templates for " + id);
            }

            factory.setErrorListener(errorListener);

            // Create a Templates ContentHandler to handle parsing of the
            // stylesheet.
            TemplatesHandler templatesHandler = factory.newTemplatesHandler();

            // Set the system ID for the template handler since some
            // TrAX implementations (XSLTC) rely on this in order to obtain
            // a meaningful identifier for the Templates instances.
            templatesHandler.setSystemId(id);
            if (filter != null) {
                filter.setContentHandler(templatesHandler);
            }

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Source = " + stylesheet + ", templatesHandler = " + templatesHandler);
            }

            // Initialize List for included validities
            SourceValidity validity = stylesheet.getValidity();
            if (validity != null && checkIncludes) {
                includesMap.put(id, new ArrayList());
            }

            try {
                // Process the stylesheet.
                sourceToSAX(stylesheet, filter != null ? (ContentHandler) filter : (ContentHandler) templatesHandler);

                // Get the Templates object (generated during the parsing of
                // the stylesheet) from the TemplatesHandler.
                final Templates template = templatesHandler.getTemplates();

                if (null == template) {
                    throw new XSLTProcessorException("Unable to create templates for stylesheet: " + stylesheet.getURI());
                }

                // Must set base for Xalan stylesheet.
                // Otherwise document('') in logicsheet causes NPE.
                Class clazz = template.getClass();
                if (clazz.getName().equals("org.apache.xalan.templates.StylesheetRoot")) {
                    Method method = clazz.getMethod("setHref", new Class[]{String.class});
                    method.invoke(template, new Object[]{id});
                }

                putTemplates(template, stylesheet, id);

                // Create transformer handler
                final TransformerHandler handler = factory.newTransformerHandler(template);
                handler.getTransformer().setErrorListener(new XSLTProcessorErrorListener(getLogger(), stylesheet.getURI()));
                handler.getTransformer().setURIResolver(this);

                // Create aggregated validity
                AggregatedValidity aggregated = null;
                if (validity != null && checkIncludes) {
                    List includes = (List) includesMap.get(id);
                    if (includes != null) {
                        aggregated = new AggregatedValidity();
                        aggregated.add(validity);
                        for (int i = includes.size() - 1; i >= 0; i--) {
                            aggregated.add((SourceValidity) ((Object[]) includes.get(i))[1]);
                        }
                        validity = aggregated;
                    }
                }

                // Create result
                handlerAndValidity = new MyTransformerHandlerAndValidity(handler, validity);
            } finally {
                if (checkIncludes)
                    includesMap.remove(id);
            }

            return handlerAndValidity;
        } catch (Exception e) {
            Throwable realEx = errorListener.getThrowable();
            if (realEx == null) realEx = e;

            if (realEx instanceof RuntimeException) {
                throw (RuntimeException)realEx;
            }

            if (realEx instanceof XSLTProcessorException) {
                throw (XSLTProcessorException)realEx;
            }

            throw new XSLTProcessorException("Exception when creating Transformer from " + stylesheet.getURI(), realEx);
        }
    }
15167#private void sourceToSAX(Source source, ContentHandler handler)
    throws SAXException, IOException, SourceException, ProcessingException {
        if (source instanceof XMLizable) {
            ((XMLizable) source).toSAX(handler);
        } else {
            this.saxParser.parse(SourceUtil.getInputSource(source), handler);
        }
    }
15168#/**
     * @see org.apache.cocoon.components.xslt.XSLTProcessor#transform(org.apache.excalibur.source.Source, org.apache.excalibur.source.Source, java.util.Map, javax.xml.transform.Result)
     */
    public void transform(final Source source, final Source stylesheet, final Map params, final Result result) throws XSLTProcessorException {
        try {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug(
                        "Transform source = " + source + ", stylesheet = " + stylesheet + ", parameters = " + params + ", result = " + result);
            }
            final TransformerHandler handler = getTransformerHandler(stylesheet);
            if (params != null) {
                final Transformer transformer = handler.getTransformer();
                transformer.clearParameters();
                final Iterator i = params.entrySet().iterator();
                while ( i.hasNext() ) {
                    final Map.Entry current = (Map.Entry)i.next();
                    transformer.setParameter(current.getKey().toString(), current.getValue());
                }
            }

            handler.setResult(result);
            sourceToSAX(source, handler);
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Transform done");
            }
        } catch (SAXException e) {
            // Unwrapping the exception will "remove" the real cause with
            // never Xalan versions and makes the exception message unusable
            final String message = "Error in running Transformation";
            throw new XSLTProcessorException(message, e);
            /*
             * if( e.getException() == null ) { final String message = "Error in
             * running Transformation"; throw new XSLTProcessorException(
             * message, e ); } else { final String message = "Got SAXException.
             * Rethrowing cause exception."; getLogger().debug( message, e );
             * throw new XSLTProcessorException( "Error in running
             * Transformation", e.getException() ); }
             */
        } catch (Exception e) {
            final String message = "Error in running Transformation";
            throw new XSLTProcessorException(message, e);
        }
    }
15169#/**
     * Get the TransformerFactory associated with the given classname. If the
     * class can't be found or the given class doesn't implement the required
     * interface, the default factory is returned.
     */
    private SAXTransformerFactory getTransformerFactory(String factoryName) {
        SAXTransformerFactory _factory;

        if (null == factoryName) {
            _factory = (SAXTransformerFactory) TransformerFactory.newInstance();
        } else {
            try {
                ClassLoader loader = Thread.currentThread().getContextClassLoader();
                if (loader == null) {
                    loader = getClass().getClassLoader();
                }
                _factory = (SAXTransformerFactory) loader.loadClass(factoryName).newInstance();
            } catch (ClassNotFoundException cnfe) {
                getLogger().error("Cannot find the requested TrAX factory '" + factoryName + "'. Using default TrAX Transformer Factory instead.");
                if (factory != null)
                    return factory;
                _factory = (SAXTransformerFactory) TransformerFactory.newInstance();
            } catch (ClassCastException cce) {
                getLogger().error(
                        "The indicated class '" + factoryName
                                + "' is not a TrAX Transformer Factory. Using default TrAX Transformer Factory instead.");
                if (factory != null)
                    return factory;
                _factory = (SAXTransformerFactory) TransformerFactory.newInstance();
            } catch (Exception e) {
                getLogger().error(
                        "Error found loading the requested TrAX Transformer Factory '" + factoryName
                                + "'. Using default TrAX Transformer Factory instead.");
                if (factory != null)
                    return factory;
                _factory = (SAXTransformerFactory) TransformerFactory.newInstance();
            }
        }

        _factory.setErrorListener(new XSLTProcessorErrorListener(getLogger(), null));
        _factory.setURIResolver(this);

        // FIXME (SM): implementation-specific parameter passing should be
        // made more extensible.
        if (_factory.getClass().getName().equals("org.apache.xalan.processor.TransformerFactoryImpl")) {
            _factory.setAttribute("http://xml.apache.org/xalan/features/incremental", Boolean.valueOf(incrementalProcessing));
        }
        // SAXON 8 will not report errors unless version warning is set to false.
        if (_factory.getClass().getName().equals("net.sf.saxon.TransformerFactoryImpl")) {
            _factory.setAttribute("http://saxon.sf.net/feature/version-warning", Boolean.FALSE);
        }

        return _factory;
    }
15170#private TransformerHandlerAndValidity getTemplates(Source stylesheet, String id)
    throws IOException, TransformerException {
        if (this.store == null) {
            return null;
        }

        // we must augment the template ID with the factory classname since one
        // transformer implementation cannot handle the instances of a
        // template created by another one.
        String key = "XSLTTemplate: " + id + '(' + factory.getClass().getName() + ')';

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("getTemplates: stylesheet " + id);
        }

        SourceValidity newValidity = stylesheet.getValidity();

        // Only stylesheets with validity are stored
        if (newValidity == null) {
            // Remove an old template
            store.remove(key);
            return null;
        }

        // Stored is an array of the templates and the caching time and list of
        // includes
        Object[] templateAndValidityAndIncludes = (Object[]) store.get(key);
        if (templateAndValidityAndIncludes == null) {
            // Templates not found in cache
            return null;
        }

        // Check template modification time
        SourceValidity storedValidity = (SourceValidity) templateAndValidityAndIncludes[1];
        int valid = storedValidity.isValid();
        boolean isValid;
        if (valid == 0) {
            valid = storedValidity.isValid(newValidity);
            isValid = (valid == 1);
        } else {
            isValid = (valid == 1);
        }
        if (!isValid) {
            store.remove(key);
            return null;
        }

        // Check includes
        if (checkIncludes) {
            AggregatedValidity aggregated = null;
            List includes = (List) templateAndValidityAndIncludes[2];
            if (includes != null) {
                aggregated = new AggregatedValidity();
                aggregated.add(storedValidity);

                for (int i = includes.size() - 1; i >= 0; i--) {
                    // Every include stored as pair of source ID and validity
                    Object[] pair = (Object[]) includes.get(i);
                    storedValidity = (SourceValidity) pair[1];
                    aggregated.add(storedValidity);

                    valid = storedValidity.isValid();
                    isValid = false;
                    if (valid == 0) {
                        Source includedSource = null;
                        try {
                            includedSource = resolver.resolveURI((String) pair[0]);
                            SourceValidity included = includedSource.getValidity();
                            if (included != null) {
                                valid = storedValidity.isValid(included);
                                isValid = (valid == 1);
                            }
                        } finally {
                            resolver.release(includedSource);
                        }
                    } else {
                        isValid = (valid == 1);
                    }
                    if (!isValid) {
                        store.remove(key);
                        return null;
                    }
                }
                storedValidity = aggregated;
            }
        }

        TransformerHandler handler = factory.newTransformerHandler((Templates) templateAndValidityAndIncludes[0]);
        handler.getTransformer().setErrorListener(new XSLTProcessorErrorListener(getLogger(), stylesheet.getURI()));
        handler.getTransformer().setURIResolver(this);
        return new MyTransformerHandlerAndValidity(handler, storedValidity);
    }
15171#private void putTemplates(Templates templates, Source stylesheet, String id) throws IOException {
        if (this.store == null) {
            return;
        }
        // we must augment the template ID with the factory classname since one
        // transformer implementation cannot handle the instances of a
        // template created by another one.
        String key = "XSLTTemplate: " + id + '(' + factory.getClass().getName() + ')';

        // only stylesheets with a last modification date are stored
        SourceValidity validity = stylesheet.getValidity();
        if (null != validity) {
            // Stored is an array of the template and the current time
            Object[] templateAndValidityAndIncludes = new Object[3];
            templateAndValidityAndIncludes[0] = templates;
            templateAndValidityAndIncludes[1] = validity;
            if (checkIncludes) {
                templateAndValidityAndIncludes[2] = includesMap.get(id);
            }
            store.store(key, templateAndValidityAndIncludes);
        }
    }
15172#/**
     * Called by the processor when it encounters an xsl:include, xsl:import, or
     * document() function.
     *
     * @param href
     *            An href attribute, which may be relative or absolute.
     * @param base
     *            The base URI in effect when the href attribute was
     *            encountered.
     *
     * @return A Source object, or null if the href cannot be resolved, and the
     *         processor should try to resolve the URI itself.
     *
     * @throws TransformerException
     *             if an error occurs when trying to resolve the URI.
     */
    public javax.xml.transform.Source resolve(String href, String base) throws TransformerException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("resolve(href = " + href + ", base = " + base + "); resolver = " + resolver);
        }

        Source xslSource = null;
        try {
            if (base == null || href.indexOf(":") > 1) {
                // Null base - href must be an absolute URL
                xslSource = resolver.resolveURI(href);
            } else if (href.length() == 0) {
                // Empty href resolves to base
                xslSource = resolver.resolveURI(base);
            } else {
                // is the base a file or a real m_url
                if (!base.startsWith("file:")) {
                    int lastPathElementPos = base.lastIndexOf('/');
                    if (lastPathElementPos == -1) {
                        // this should never occur as the base should
                        // always be protocol:/....
                        return null; // we can't resolve this
                    } else {
                        xslSource = resolver.resolveURI(base.substring(0, lastPathElementPos) + "/" + href);
                    }
                } else {
                    File parent = new File(base.substring(5));
                    File parent2 = new File(parent.getParentFile(), href);
                    xslSource = resolver.resolveURI(parent2.toURL().toExternalForm());
                }
            }

            InputSource is = getInputSource(xslSource);

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("xslSource = " + xslSource + ", system id = " + xslSource.getURI());
            }

            if (checkIncludes) {
                // Populate included validities
                List includes = (List) includesMap.get(base);
                if (includes != null) {
                    SourceValidity included = xslSource.getValidity();
                    if (included != null) {
                        includes.add(new Object[] { xslSource.getURI(), xslSource.getValidity() });
                    } else {
                        // One of the included stylesheets is not cacheable
                        includesMap.remove(base);
                    }
                }
            }

            return new StreamSource(is.getByteStream(), is.getSystemId());
        } catch (SourceException e) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Failed to resolve " + href + "(base = " + base + "), return null", e);
            }

            // CZ: To obtain the same behaviour as when the resource is
            // transformed by the XSLT Transformer we should return null here.
            return null;
        } catch (java.net.MalformedURLException mue) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Failed to resolve " + href + "(base = " + base + "), return null", mue);
            }

            return null;
        } catch (IOException ioe) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Failed to resolve " + href + "(base = " + base + "), return null", ioe);
            }

            return null;
        } finally {
            resolver.release(xslSource);
        }
    }
15173#/**
     * Return a new <code>InputSource</code> object that uses the
     * <code>InputStream</code> and the system ID of the <code>Source</code>
     * object.
     *
     * @throws IOException
     *             if I/O error occured.
     */
    private static InputSource getInputSource(final Source source) throws IOException, SourceException {
        final InputSource newObject = new InputSource(source.getInputStream());
        newObject.setSystemId(source.getURI());
        return newObject;
    }
15174#protected MyTransformerHandlerAndValidity(TransformerHandler handler, SourceValidity validity) {
            super(handler, validity);
        }
15175#public XSLTProcessorException( final String message ) {
        super( message );
    }
15176#public XSLTProcessorException( final String message,
                                   final Throwable throwable ) {
        super( message, throwable );
    }
15177#public XSLTProcessorErrorListener(Log logger, String uri) {
        this.logger = logger;
        this.uri = uri;
    }
15178#/**
     * Get the exception that was catched by this listener, if any.
     *
     * @return the exception
     */
    public Throwable getThrowable() {
        if (exception == null) {
            return null;
        }

        Location loc = LocationUtils.getLocation(exception);
        if (LocationUtils.isKnown(loc)) {
            // Has a location: don't loose this precious information!
            return exception;
        }

        // No location: if it's just a wrapper, consider only the wrapped exception
        if (exception.getCause() != null) {
            return exception.getCause();
        }

        // That's the actual exception!
        return exception;
    }
15179#public void warning(TransformerException ex) throws TransformerException {
        // TODO: We may want here to allow some special formatting of the messages, such as
        // "DEBUG:A debug message" or "INFO:Transforming <foo> in mode 'bar'" to use the different
        // log levels. This can include also deprecation logs for system-defined stylesheets
        // using "DEPRECATED:WARN:Styling 'foo' is replaced by 'bar'".

        if (logger.isWarnEnabled()) {
            Location loc = LocationUtils.getLocation(ex);
            logger.warn(ex.getMessage() + " at "+ loc == null ? uri : loc.toString());
        }
        // Keep the warning (see below)
        warningEx = ex;
    }
15180#public void error(TransformerException ex) throws TransformerException {

        // If we had a warning previoulsy, and the current exception has no cause, then use the warning.
        // This is how Xalan behaves on <xsl:message terminate="yes">: it first issues a warning with all
        // the useful information, then a useless "stylesheed directed termination" error.
        if (warningEx != null && ex.getCause() == null) {
            ex = warningEx;
        }
        warningEx = null;

        // Keep the exception for later use.
        exception = ex;
        // and rethrow it
        throw ex;
    }
15181#public void fatalError(TransformerException ex) throws TransformerException {
        if (warningEx != null && ex.getCause() == null) {
            ex = warningEx;
        }
        warningEx = null;

        exception = ex;
        throw ex;
    }
15182#public void setParser(SAXParser parser) {
        this.parser = parser;
    }
15183#/**
     * @see org.apache.cocoon.sitemap.DisposableSitemapComponent#dispose()
     */
    public void dispose() {
        if (this.inputSource != null) {
            this.resolver.release(this.inputSource);
            this.inputSource = null;
        }
        this.resolver = null;
        this.consumer = null;
    }
15184#/**
     * Setup the file generator.
     * Try to get the last modification date of the source for caching.
     *
     * @see org.apache.cocoon.sitemap.SitemapModelComponent#setup(SourceResolver, Map, String, Parameters)
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        this.resolver = resolver;

        try {
            this.inputSource = this.resolver.resolveURI(src);
        } catch (SourceException se) {
            throw SourceUtil.handle("Error during resolving of '" + src + "'.", se);
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Source " + src +
                              " resolved to " + this.inputSource.getURI());
        }
    }
15185#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     *
     * @return The generated key hashes the src
     */
    public Serializable getKey() {
        return this.inputSource.getURI();
    }
15186#/**
     * Generate the validity object.
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity() {
        return this.inputSource.getValidity();
    }
15187#/**
     * @see org.apache.cocoon.xml.XMLProducer#setConsumer(XMLConsumer)
     */
    public void setConsumer(XMLConsumer consumer) {
        this.consumer = consumer;
    }
15188#/**
     * Generate XML data.
     */
    public void generate()
    throws IOException, SAXException, ProcessingException {
        try {
            SourceUtil.parse(this.parser, this.inputSource, this.consumer);
        } catch (SAXException e) {
            SourceUtil.handleSAXException(this.inputSource.getURI(), e);
        }
    }
15189#public void setParser(DOMParser parser) {
		this.parser = parser;
	}
15190#public void setXPathProcessor(XPathProcessor processor) {
		this.processor = processor;
	}
15191#public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        super.setup(resolver, objectModel, src, par);

        // See if an XPath was specified
        int pointer;
        if ((pointer = this.source.indexOf("#")) != -1) {
            int endpointer = this.source.indexOf('?');
            if (endpointer != -1) {
                this.xpath = source.substring(pointer + 1, endpointer);
            } else {
                this.xpath = source.substring(pointer + 1);
            }
            this.source = src.substring(0, pointer);
            if (endpointer != -1) {
                this.source += src.substring(endpointer);
            }
        } else {
            this.xpath = par.getParameter("xpath", null);
        }

        this.cacheKeyParList.add(this.xpath);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Applying XPath: " + xpath + " to collection " + source);
        }

        String xmlFilesPattern = null;
        try {
            xmlFilesPattern = par.getParameter("xmlFiles", "\\.xml$");
            this.cacheKeyParList.add(xmlFilesPattern);
            this.xmlRE = new RE(xmlFilesPattern);
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("pattern for XML files: " + xmlFilesPattern);
            }
        } catch (RESyntaxException rese) {
            throw new ProcessingException("Syntax error in regexp pattern '" +
                                          xmlFilesPattern + "'", rese);
        }

        String[] params = par.getNames();
        this.prefixResolver = new XPathPrefixResolver(getLogger());
        for (int i = 0; i < params.length; i++) {
            if (params[i].startsWith("xmlns:")) {
                String paramValue = par.getParameter(params[i], "");
                String paramName = params[i].substring(6);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("add param to prefixResolver: " + paramName);
                }
                this.prefixResolver.addPrefix(paramName, paramValue);
            }
        }

        this.context = ObjectModelHelper.getContext(objectModel);
    }
15192#public void service(ServiceManager manager) throws ServiceException {
        super.service(manager);
        this.processor = (XPathProcessor)manager.lookup(XPathProcessor.ROLE);
        this.parser = (DOMParser)manager.lookup(DOMParser.class.getName());
    }
15193#/**
     * Recycle resources
     */
    public void recycle() {
        this.xpath = null;
        this.doc = null;
        this.xmlRE = null;
        this.prefixResolver = null;
        this.context = null;
        super.recycle();
    }
15194#public void dispose() {
        if (this.manager != null) {
            this.manager.release(processor);
            this.processor = null;
        }
        super.dispose();
    }
15195#// ----------------------------------------------------------------------

    protected void addContent(TraversableSource source)
    throws SAXException, ProcessingException {
        super.addContent(source);
        if (!source.isCollection() && isXML(source) && xpath != null) {
            performXPathQuery(source);
        }
    }
15196#/**
     * Determines if a given TraversableSource shall be handled as XML.
     *
     * @param path  the TraversableSource to check
     * @return true  if the given TraversableSource shall handled as XML, false
     * otherwise.
     */
    protected boolean isXML(TraversableSource path) {
        String mimeType = this.context.getMimeType(path.getName());
        return this.xmlRE.match(path.getName()) || "text/xml".equalsIgnoreCase(mimeType);
    }
15197#/**
     * Performs an XPath query on the source.
     * @param in  the Source the XPath is performed on.
     * @throws SAXException  if something goes wrong while adding the XML snippet.
     */
    protected void performXPathQuery(TraversableSource in) throws SAXException {
        doc = null;
        try {
            doc = this.parser.parseDocument(SourceUtil.getInputSource(in));
        } catch (SAXException se) {
            getLogger().error("Warning:" + in.getName() + " is not a valid XML document. Ignoring");
        } catch (Exception e) {
            this.getLogger().error("Unable to resolve and parse document" + e);
        }
        if (doc != null) {
            NodeList nl = processor.selectNodeList(doc.getDocumentElement(), xpath, this.prefixResolver);
            final String id = in.getName();
            AttributesImpl attributes = new AttributesImpl();
            attributes.addAttribute("", RESULT_DOCID_ATTR, RESULT_DOCID_ATTR," CDATA", id);
            attributes.addAttribute("", QUERY_ATTR_NAME, QUERY_ATTR_NAME, "CDATA",xpath);
            super.contentHandler.startElement(URI, XPATH_NODE_NAME, PREFIX + ":" + XPATH_NODE_NAME, attributes);
            DOMStreamer ds = new DOMStreamer(super.xmlConsumer);
            for (int i = 0; i < nl.getLength(); i++) {
                ds.stream(nl.item(i));
            }
            super.contentHandler.endElement(URI, XPATH_NODE_NAME, PREFIX + ":" + XPATH_NODE_NAME);
        }
    }
15198#public XPathPrefixResolver(Log logger) {
            this.params = new HashMap();
            this.logger = logger;
        }
15199#/**
         * Get a namespace URI given a prefix.
         *
         * @see org.apache.excalibur.xml.xpath.PrefixResolver#prefixToNamespace(java.lang.String)
         */
        public String prefixToNamespace(String prefix) {
            if (this.logger.isDebugEnabled()) {
                this.logger.debug("prefix: " + prefix);
            }

            if (this.params.containsKey(prefix)) {
                if(this.logger.isDebugEnabled()) {
                    this.logger.debug("prefix; " + prefix + " - namespace: " + this.params.get(prefix));
                }
                return (String) this.params.get(prefix);
            }

            return null;
        }
15200#public void addPrefix(String prefix, String uri) {
            this.params.put(prefix, uri);
        }
15201#/**
     * Configure the crawler component.
     * <p>
     *  Configure can specify which URI to include, and which URI to exclude
     *  from crawling. You specify the patterns as regular expressions.
     * </p>
     * <p>
     *  Morover you can configure
     *  the required content-type of crawling request, and the
     *  query-string appended to each crawling request.
     * </p>
     * <pre><tt>
     * &lt;include&gt;.*\.html?&lt;/include&gt; or &lt;include&gt;.*\.html?, .*\.xsp&lt;/include&gt;
     * &lt;exclude&gt;.*\.gif&lt;/exclude&gt; or &lt;exclude&gt;.*\.gif, .*\.jpe?g&lt;/exclude&gt;
     * &lt;link-content-type&gt; application/x-cocoon-links &lt;/link-content-type&gt;
     * &lt;link-view-query&gt; ?cocoon-view=links &lt;/link-view-query&gt;
     * &lt;user-agent&gt; Cocoon &lt;/user-agent&gt;
     * &lt;accept&gt; text/xml &lt;/accept&gt;
     * </tt></pre>
     *
     * @param  configuration               XML configuration of this avalon component.
     * @exception  ConfigurationException  is throwing if configuration is invalid.
     * @since
     */
    public void configure(Configuration configuration)
            throws ConfigurationException {

        Configuration[] children;
        children = configuration.getChildren(INCLUDE_CONFIG);
        if (children.length > 0) {
            includeCrawlingURL = new HashSet();
            for (int i = 0; i < children.length; i++) {
                String pattern = children[i].getValue();
                try {
                    String params[] = StringUtils.split(pattern, ", ");
                    for (int index = 0; index < params.length; index++) {
                        String tokenized_pattern = params[index];
                        this.includeCrawlingURL.add(new RE(tokenized_pattern));
                    }
                } catch (RESyntaxException rese) {
                    getLogger().error("Cannot create including regular-expression for " +
                            pattern, rese);
                }
            }
        }

        children = configuration.getChildren(EXCLUDE_CONFIG);
        if (children.length > 0) {
            excludeCrawlingURL = new HashSet();
            for (int i = 0; i < children.length; i++) {
                String pattern = children[i].getValue();
                try {
                    String params[] = StringUtils.split(pattern, ", ");
                    for (int index = 0; index < params.length; index++) {
                        String tokenized_pattern = params[index];
                        this.excludeCrawlingURL.add(new RE(tokenized_pattern));
                    }
                } catch (RESyntaxException rese) {
                    getLogger().error("Cannot create excluding regular-expression for " +
                            pattern, rese);
                }
            }
        } else {
            excludeCrawlingURL = new HashSet();
            setDefaultExcludeFromCrawling();
        }

        Configuration child;
        String value;
        child = configuration.getChild(LINK_CONTENT_TYPE_CONFIG, false);
        if (child != null) {
            value = child.getValue();
            if (value != null && value.length() > 0) {
                this.linkContentType = value.trim();
            }
        }
        child = configuration.getChild(LINK_VIEW_QUERY_CONFIG, false);
        if (child != null) {
            value = child.getValue();
            if (value != null && value.length() > 0) {
                this.linkViewQuery = value.trim();
            }
        }
/*      FIXME: Also delete this if you delete the fields above.
        child = configuration.getChild(USER_AGENT_CONFIG, false);
        if (child != null) {
            value = child.getValue();
            if (value != null && value.length() > 0) {
                this.userAgent = value;
            }
        }

        child = configuration.getChild(ACCEPT_CONFIG, false);
        if (child != null) {
            value = child.getValue();
            if (value != null && value.length() > 0) {
                this.accept = value;
            }
        }
*/
    }
15202#public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {

        super.setup(resolver, objectModel, src, par);

        /* Create a reusable attributes for creating nodes */
        this.attributes = new AttributesImpl();

        // already done in configure...
        //excludeCrawlingURL = new HashSet();
        //this.setDefaultExcludeFromCrawling();
    }
15203#/**
     * Generate XML data.
     *
     * @throws  SAXException
     *      if an error occurs while outputting the document
     * @throws  ProcessingException
     *      if the requsted URI wasn't found
     */
    public void generate()
    throws SAXException, ProcessingException {
        try {

            crawled = new HashSet();
            linksToProcess = new HashSet();

            URL root = new URL(source);
            linksToProcess.add(new Link(root, ""));


            if (getLogger().isDebugEnabled()) {
                getLogger().debug("crawl URL " + root);
            }

            this.contentHandler.startDocument();
            this.contentHandler.startPrefixMapping(PREFIX, URI);

            attributes.clear();
            super.contentHandler.startElement(URI, TOP_NODE_NAME, PREFIX + ':' + TOP_NODE_NAME, attributes);

            while (linksToProcess.size() > 0) {
                Iterator i = linksToProcess.iterator();

                if (i.hasNext()) {
                    // fetch a URL
                    Link link = (Link) i.next();
                    URL url = link.getURL();

                    // remove it from the to-do list
                    linksToProcess.remove(link);

                    String new_url_link = processURL(url, link.getReferrer());

                    // calc all links from this url
                    if (new_url_link != null) {

                        List url_links = getLinksFromConnection(new_url_link, url);
                        if (url_links != null) {
                            // add links of this url to the to-do list
                            linksToProcess.addAll(url_links);
                        }
                    }
                }
            }

            super.contentHandler.endElement(URI, TOP_NODE_NAME, PREFIX + ':' + TOP_NODE_NAME);
            this.contentHandler.endPrefixMapping(PREFIX);
            this.contentHandler.endDocument();
        } catch (IOException ioe) {
            getLogger().warn("Could not read source ", ioe);
            throw new ResourceNotFoundException("Could not read source ", ioe);
        }
    }
15204#/**
     * Default exclude patterns.
     * <p>
     *   By default URLs matching following patterns are excluded:
     * </p>
     * <ul>
     *   <li>.*\\.gif(\\?.*)?$ - exclude gif images</li>
     *   <li>.*\\.png(\\?.*)?$ - exclude png images</li>
     *   <li>.*\\.jpe?g(\\?.*)?$ - exclude jpeg images</li>
     *   <li>.*\\.js(\\?.*)?$ - exclude javascript </li>
     *   <li>.*\\.css(\\?.*)?$ - exclude cascaded stylesheets</li>
     * </ul>
     *
     * @since
     */
    private void setDefaultExcludeFromCrawling() {
        String[] EXCLUDE_FROM_CRAWLING_DEFAULT = {
            ".*\\.gif(\\?.*)?$",
            ".*\\.png(\\?.*)?$",
            ".*\\.jpe?g(\\?.*)?$",
            ".*\\.js(\\?.*)?$",
            ".*\\.css(\\?.*)?$"
        };

        for (int i = 0; i < EXCLUDE_FROM_CRAWLING_DEFAULT.length; i++) {
            String pattern = EXCLUDE_FROM_CRAWLING_DEFAULT[i];
            try {
                excludeCrawlingURL.add(new RE(pattern));
            } catch (RESyntaxException rese) {
                getLogger().error("Cannot create excluding regular-expression for " +
                        pattern, rese);
            }
        }
    }
15205#/**
     * Retrieve a list of links of a url
     *
     * @param url_link_string url for requesting links, it is assumed that
     *   url_link_string queries the cocoon view links, ie of the form
     *   <code>http://host/foo/bar?cocoon-view=links</code>
     * @param url_of_referrer base url of which links are requested, ie of the form
     *   <code>http://host/foo/bar</code>
     * @return List of links from url_of_referrer, as result of requesting url
     *   url_link_string
     */
    protected List getLinksFromConnection(String url_link_string, URL url_of_referrer) {
        List url_links = null;
        BufferedReader br = null;
        try {
            URL url_link = new URL(url_link_string);
            URLConnection conn = url_link.openConnection();
            String content_type = conn.getContentType();

            if (content_type == null) {
                getLogger().warn("No content type available for " + String.valueOf(url_link_string));
                // caller checks if null
                return url_links;
            }

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Content-type: " + content_type);
            }

            if (content_type.equals(linkContentType) ||
                content_type.startsWith(linkContentType + ";")) {
                url_links = new ArrayList();

                InputStream is = conn.getInputStream();
                br = new BufferedReader(new InputStreamReader(is));

                // content is supposed to be a list of links,
                // relative to current URL
                String line;
                String referrer = url_of_referrer.toString();

                while ((line = br.readLine()) != null) {
                    URL new_url = new URL(url_link, line);
                    boolean add_url = true;
                    // don't add new_url twice
                    if (add_url) {
                        add_url &= !url_links.contains(new_url);
                    }

                    // don't add new_url if it has been crawled already
                    if (add_url) {
                        add_url &= !crawled.contains(new_url.toString());
                    }

                    Link new_link = new Link(new_url, referrer);
                    if (add_url) {
                        add_url &= !linksToProcess.contains(new_link);
                    }

                    // don't add if is not matched by existing include definition
                    if (add_url) {
                        add_url &= isIncludedURL(new_url.toString());
                    }

                    if (add_url) {
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("Add URL: " + new_url.toString());
                        }
                        url_links.add(new_link);
                    }
                }
                // now we have a list of URL which should be examined
            }
        } catch (IOException ioe) {
            getLogger().warn("Problems get links of " + url_link_string, ioe);
        } finally {
            // explictly close the stream
            if (br != null) {
                try {
                    br.close();
                    br = null;
                } catch (IOException ignored) {
                }
            }
        }
        return url_links;
    }
15206#/**
     * Generate xml attributes of a url, calculate url for retrieving links
     *
     * @param url to process
     * @param referrer of the url
     * @return String url for retrieving links, or null if url is an excluded-url,
     *   and not an included-url.
     */
    protected String processURL(URL url, String referrer) throws SAXException {

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("getLinks URL " + url);
        }

        String result = null;

        // don't try to investigate a url which has been crawled already
        if (crawled.contains(url.toString())) {
            return null;
        }

        // mark it as crawled
        crawled.add(url.toString());

        attributes.clear();
        attributes.addAttribute("", HREF_ATTR_NAME,
                HREF_ATTR_NAME, "CDATA", url.toString());
        attributes.addAttribute("", REFERRER_ATTR_NAME,
                REFERRER_ATTR_NAME, "CDATA", referrer);

        // Output url, referrer, content-type, status, message for traversable url's
        HttpURLConnection h = null;
        try {

            URLConnection links_url_connection = url.openConnection();
            h = (HttpURLConnection) links_url_connection;
            String content_type = links_url_connection.getContentType();

            attributes.addAttribute("", CONTENT_ATTR_NAME,
                    CONTENT_ATTR_NAME, "CDATA",
                    content_type);

            attributes.addAttribute("", MESSAGE_ATTR_NAME,
                    MESSAGE_ATTR_NAME, "CDATA",
                    h.getResponseMessage());

            attributes.addAttribute("", STATUS_ATTR_NAME,
                    STATUS_ATTR_NAME, "CDATA",
                    String.valueOf(h.getResponseCode()));
        } catch (IOException ioe) {
            attributes.addAttribute("", MESSAGE_ATTR_NAME,
                    MESSAGE_ATTR_NAME, "CDATA",
                    ioe.getMessage());
        } finally {
            if (h != null) {
                h.disconnect();
            }
        }

        // don't try to get links of a url which is excluded from crawling
        // try to get links of a url which is included for crawling
        if (!isExcludedURL(url.toString()) && isIncludedURL(url.toString())) {
            // add prefix and query to get data from the linkserializer.
            result = url.toExternalForm()
                    + ((url.toExternalForm().indexOf("?") == -1) ? "?" : "&")
                    + linkViewQuery;
        }

        super.contentHandler.startElement(URI, LINK_NODE_NAME, PREFIX + ':' + LINK_NODE_NAME, attributes);
        super.contentHandler.endElement(URI, LINK_NODE_NAME, PREFIX + ':' + LINK_NODE_NAME);

        return result;
    }
15207#/**
     * check if URL is a candidate for indexing
     *
     * @param  url  Description of Parameter
     * @return      The excludedURL value
     * @since
     */
    private boolean isExcludedURL(String url) {
        // by default include URL for crawling
        if (excludeCrawlingURL == null) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("exclude no URL " + url);
            }
            return false;
        }

        final String s = url;
        Iterator i = excludeCrawlingURL.iterator();
        while (i.hasNext()) {
            RE pattern = (RE) i.next();
            if (pattern.match(s)) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("exclude URL " + url);
                }
                return true;
            }
        }
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("exclude not URL " + url);
        }
        return false;
    }
15208#/**
     * check if URL is a candidate for indexing
     *
     * @param  url  Description of Parameter
     * @return      The includedURL value
     * @since
     */
    private boolean isIncludedURL(String url) {
        // by default include URL for crawling
        if (includeCrawlingURL == null) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("include all URL " + url);
            }
            return true;
        }

        final String s = url;
        Iterator i = includeCrawlingURL.iterator();
        while (i.hasNext()) {
            RE pattern = (RE) i.next();
            if (pattern.match(s)) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("include URL " + url);
                }
                return true;
            }
        }
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("include not URL " + url);
        }
        return false;
    }
15209#public void recycle() {
        super.recycle();

        this.attributes = null;
    }
15210#public Link(URL url, String referrer) {
            this.url = url;
            this.referrer = referrer;
        }
15211#public URL getURL() {
            return url;
        }
15212#public String getReferrer() {
            return referrer;
        }
15213#public boolean equals(Link l) {
            return url.equals(l.getURL());
        }
15214#public void setParser(DOMParser parser) {
		this.parser = parser;
	}
15215#public void setXPathProcessor(XPathProcessor processor) {
		this.processor = processor;
	}
15216#/**
     * Disposable
     */
    public void dispose() {
        if (this.manager != null) {
            this.manager.release(this.processor);
            this.manager.release(this.parser);
            this.processor = null;
            this.parser = null;
        }

        super.dispose();
    }
15217#/**
     * Recycle resources
     */
    public void recycle() {
        this.xpath = null;
        this.doc = null;

        //this.parser = null;
        //this.processor = null;
        super.recycle();
    }
15218#/* (non-Javadoc)
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager)
    throws ServiceException {
        super.service(manager);
        this.processor = (XPathProcessor)manager.lookup(XPathProcessor.ROLE);
        this.parser = (DOMParser)manager.lookup(DOMParser.class.getName());
    }
15219#/**
     * Setup this sitemap component
     *
     * @param resolver the SourceResolver
     * @param objectModel The environmental object model
     * @param src the source attribute
     * @param par the parameters
     *
     * @throws ProcessingException if processing failes
     * @throws SAXException in case of XML related errors
     * @throws IOException in case of file related errors
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        super.setup(resolver, objectModel, src, par);

        // See if an XPath was specified
        this.xpath = par.getParameter("xpath", null);
        this.cacheKeyParList.add(this.xpath);

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Applying XPath: " + this.xpath + " to directory " + this.source);
        }

        final String mappings = par.getParameter("nsmapping", null);

        if (null != mappings) {
            final boolean mapping_reload = par.getParameterAsBoolean("nsmapping-reload", false);
            final Source mappingSource = resolver.resolveURI(mappings);
            final String mappingKey = mappingSource.getURI();
            final MappingInfo mappingInfo = (MappingInfo)XPathDirectoryGenerator.mappingFiles.get(mappingKey);

            if ((null == mappingInfo) || (mappingInfo.reload == false) ||
                (mappingInfo.mappingSource.getLastModified() < mappingSource.getLastModified())) {
                this.prefixResolver =
                    new MappingInfo(getLogger(), mappingSource, mapping_reload);
                XPathDirectoryGenerator.mappingFiles.put(mappingKey, this.prefixResolver);
            } else {
                this.prefixResolver = mappingInfo;
            }
        }

        String xmlFilesPattern = null;

        try {
            xmlFilesPattern = par.getParameter("xmlFiles", "\\.xml$");
            this.cacheKeyParList.add(xmlFilesPattern);
            this.xmlRE = new RE(xmlFilesPattern);

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("pattern for XML files: " + xmlFilesPattern);
            }
        } catch (RESyntaxException rese) {
            throw new ProcessingException("Syntax error in regexp pattern '" + xmlFilesPattern + "'", rese);
        }
    }
15220#/**
     * Determines if a given File shall be handled as XML.
     *
     * @param path the File to check
     *
     * @return true if the given File shall handled as XML, false otherwise.
     */
    protected boolean isXML(File path) {
        return this.xmlRE.match(path.getName());
    }
15221#/**
     * Performs an XPath query on the file.
     *
     * @param xmlFile the File the XPath is performed on.
     *
     * @throws SAXException if something goes wrong while adding the XML snippet.
     */
    protected void performXPathQuery(File xmlFile)
    throws SAXException {
        this.doc = null;

        Source source = null;

        try {
            source = resolver.resolveURI(xmlFile.toURL().toExternalForm());
            this.doc = this.parser.parseDocument(SourceUtil.getInputSource(source));
        } catch (SAXException e) {
            getLogger().error("Warning:" + xmlFile.getName() + " is not a valid XML file. Ignoring.", e);
        } catch (ProcessingException e) {
            getLogger().error("Warning: Problem while reading the file " + xmlFile.getName() + ". Ignoring.", e);
        } catch (IOException e) {
            getLogger().error("Warning: Problem while reading the file " + xmlFile.getName() + ". Ignoring.", e);
        } finally {
            resolver.release(source);
        }

        if (doc != null) {
            NodeList nl =
                (null == this.prefixResolver)
                ? this.processor.selectNodeList(this.doc.getDocumentElement(), this.xpath)
                : this.processor.selectNodeList(this.doc.getDocumentElement(), this.xpath, this.prefixResolver);
            AttributesImpl attributes = new AttributesImpl();
            attributes.addAttribute("", QUERY_ATTR_NAME, QUERY_ATTR_NAME, "CDATA", xpath);
            super.contentHandler.startElement(URI, XPATH_NODE_NAME, PREFIX + ":" + XPATH_NODE_NAME, attributes);

            DOMStreamer ds = new DOMStreamer(super.xmlConsumer);

            for (int i = 0; i < nl.getLength(); i++) {
                ds.stream(nl.item(i));
            }

            super.contentHandler.endElement(URI, XPATH_NODE_NAME, PREFIX + ":" + XPATH_NODE_NAME);
        }
    }
15222#/**
     * Extends the startNode() method of the DirectoryGenerator by starting a possible XPath query on a file.
     *
     * @param nodeName the node currently processing
     * @param path the file path
     *
     * @throws SAXException in case of errors
     */
    protected void startNode(String nodeName, File path)
    throws SAXException {
        super.startNode(nodeName, path);

        if ((this.xpath != null) && path.isFile() && this.isXML(path)) {
            performXPathQuery(path);
        }
    }
15223#/**
         * Creates a new MappingInfo object.
         *
         * @param logger DOCUMENT ME!
         * @param mappingSource The Source of the mapping file
         * @param reload Whether to reload if mapping file has changed
         *
         * @throws SourceNotFoundException In case the mentioned source is not there
         * @throws IOException in case the source could not be read
         */
        public MappingInfo(final Log logger, final Source mappingSource, final boolean reload)
        throws SourceNotFoundException, IOException {
            this.logger = logger;
            this.mappingSource = mappingSource;
            this.reload = reload;
            prefixMap = new HashMap();
            InputStreamReader input = null;
            BufferedReader br = null;

            try {
                input = new InputStreamReader(mappingSource.getInputStream());
                br = new BufferedReader(input);
    
                for (String line = br.readLine(); line != null; line = br.readLine()) {
                    final int i = line.indexOf('=');
    
                    if (i > 0) {
                        final String prefix = line.substring(0, i);
                        final String namespace = line.substring(i + 1);
                        prefixMap.put(prefix, namespace);
                        logger.debug("added mapping: '" + prefix + "'='" + namespace + "'");
                    }
                }
            } finally {
                if (br != null) {
                    br.close();
                }
                if (input != null) {
                    input.close();
                }
            }
        }
15224#/* (non-Javadoc)
         * @see org.apache.excalibur.xml.xpath.PrefixResolver#prefixToNamespace(java.lang.String)
         */
        public String prefixToNamespace(String prefix) {
            final String namespace = (String)this.prefixMap.get(prefix);

            if (logger.isDebugEnabled()) {
                logger.debug("have to resolve prefix='" + prefix + ", found namespace='" + namespace + "'");
            }

            return namespace;
        }
15225#public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par) throws ProcessingException, SAXException, IOException {
        super.setup(resolver, objectModel, src, par);
        thr = ObjectModelHelper.getThrowable(objectModel);
        if (thr == null) {
            throw new ProcessingException("ExceptionGenerator should be used in <map:handle-errors>");
        }
    }
15226#public void generate() throws IOException, SAXException, ProcessingException {
        this.contentHandler.startDocument();
        toSAX(thr, this.contentHandler);
        this.contentHandler.endDocument();
    }
15227#public static void toSAX(Throwable thr, ContentHandler handler) throws SAXException {
        Throwable cause = ExceptionUtils.getRootCause(thr);
        if (cause == null) {
            cause = thr;
        }

        AttributesImpl attr = new AttributesImpl();
        handler.startPrefixMapping("ex", EXCEPTION_NS);
        attr.addCDATAAttribute("class", cause.getClass().getName());
        handler.startElement(EXCEPTION_NS, "exception-report", "ex:exception-report", attr);

        // Root cause exception location
        Location loc = LocationUtils.getLocation(cause);
        if (LocationUtils.isKnown(loc)) {
            attr.clear();
            dumpLocation(loc, attr, handler);
        }

        // Root cause exception message
        attr.clear();
        String message = cause instanceof LocatableException ? ((LocatableException) cause).getRawMessage() : cause.getMessage();
        simpleElement("message", attr, message, handler);

        // Exception XML content: dump all XMLizable exceptions in the exception cause chain
        for (Throwable current = thr; current != null; current = ExceptionUtils.getCause(current)) {
            handler.startElement(EXCEPTION_NS, "content", "ex:content", attr);
            if (current instanceof XMLizable) {
                ((XMLizable) current).toSAX(handler);
            }
            handler.endElement(EXCEPTION_NS, "content", "ex:content");
        }

        // Cocoon stacktrace: dump all located exceptions in the exception cause chain
        handler.startElement(EXCEPTION_NS, "cocoon-stacktrace", "ex:cocoon-stacktrace", attr);
        for (Throwable current = thr; current != null; current = ExceptionUtils.getCause(current)) {
            loc = LocationUtils.getLocation(current);
            if (LocationUtils.isKnown(loc)) {
                // One or more locations: dump it
                handler.startElement(EXCEPTION_NS, "exception", "ex:exception", attr);

                message = current instanceof LocatableException ? ((LocatableException)current).getRawMessage() : current.getMessage();
                simpleElement("message", attr, message, handler);

                attr.clear();
                handler.startElement(EXCEPTION_NS, "locations", "ex:locations", attr);
                dumpLocation(loc, attr, handler);

                if (current instanceof MultiLocatable) {
                    List locations = ((MultiLocatable) current).getLocations();
                    for (int i = 1; i < locations.size(); i++) { // start at 1 because we already dumped the first one
                        attr.clear();
                        dumpLocation((Location) locations.get(i), attr, handler);
                    }
                }
                handler.endElement(EXCEPTION_NS, "locations", "ex:locations");
                handler.endElement(EXCEPTION_NS, "exception", "ex:exception");
            }
        }
        handler.endElement(EXCEPTION_NS, "cocoon-stacktrace", "ex:cocoon-stacktrace");

        // Root cause exception stacktrace
        attr.clear();
        simpleElement("stacktrace", attr, ExceptionUtils.getStackTrace(cause), handler);

        // Full stack trace (if exception is chained)
        if (thr != cause) {
            String trace = SystemUtils.isJavaVersionAtLeast(140) ?
                    ExceptionUtils.getStackTrace(thr) :
                    ExceptionUtils.getFullStackTrace(thr);

            simpleElement("full-stacktrace", attr, trace, handler);
        }

        handler.endElement(EXCEPTION_NS, "exception-report", "ex:exception-report");
        handler.endPrefixMapping("ex");
    }
15228#private static void dumpLocation(Location loc, AttributesImpl attr, ContentHandler handler) throws SAXException {
        attr.addCDATAAttribute("uri", loc.getURI());
        attr.addCDATAAttribute("line", Integer.toString(loc.getLineNumber()));
        attr.addCDATAAttribute("column", Integer.toString(loc.getColumnNumber()));
        simpleElement("location", attr, loc.getDescription(), handler);
    }
15229#private static void simpleElement(String name, Attributes attr, String value, ContentHandler handler) throws SAXException {
        handler.startElement(EXCEPTION_NS, name, "ex:" + name, attr);
        if (value != null && value.length() > 0) {
            handler.characters(value.toCharArray(), 0, value.length());
        }
        handler.endElement(EXCEPTION_NS, name, "ex:" + name);
    }
15230#/**
     * Set the request parameters. Must be called before the generate method.
     *
     * @param resolver     the SourceResolver object
     * @param objectModel  a <code>Map</code> containing model object
     * @param src          the directory to be XMLized specified as src attribute on &lt;map:generate/>
     * @param par          configuration parameters
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        if (src == null) {
            throw new ProcessingException("No src attribute pointing to a directory to be XMLized specified.");
        }
        super.setup(resolver, objectModel, src, par);

        try {
            this.directorySource = this.resolver.resolveURI(src);
        } catch (SourceException se) {
            throw SourceUtil.handle(se);
        }

        this.cacheKeyParList = new ArrayList();
        this.cacheKeyParList.add(this.directorySource.getURI());

        this.depth = par.getParameterAsInteger("depth", 1);
        this.cacheKeyParList.add(String.valueOf(this.depth));

        String dateFormatString = par.getParameter("dateFormat", null);
        this.cacheKeyParList.add(dateFormatString);
        if (dateFormatString != null) {
            this.dateFormatter = new SimpleDateFormat(dateFormatString);
        } else {
            this.dateFormatter = new SimpleDateFormat();
        }

        this.sort = par.getParameter("sort", "name");
        this.cacheKeyParList.add(this.sort);

        this.reverse = par.getParameterAsBoolean("reverse", false);
        this.cacheKeyParList.add(String.valueOf(this.reverse));

        this.refreshDelay = par.getParameterAsLong("refreshDelay", 1L) * 1000L;
        this.cacheKeyParList.add(String.valueOf(this.refreshDelay));

        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("depth: " + this.depth);
            this.getLogger().debug("dateFormat: " + this.dateFormatter.toPattern());
            this.getLogger().debug("sort: " + this.sort);
            this.getLogger().debug("reverse: " + this.reverse);
            this.getLogger().debug("refreshDelay: " + this.refreshDelay);
        }

        String rePattern = null;
        try {
            rePattern = par.getParameter("root", null);
            this.cacheKeyParList.add(rePattern);
            this.rootRE = (rePattern == null) ? null : new RE(rePattern);
            if (this.getLogger().isDebugEnabled()) {
                this.getLogger().debug("root pattern: " + rePattern);
            }

            rePattern = par.getParameter("include", null);
            this.cacheKeyParList.add(rePattern);
            this.includeRE = (rePattern == null) ? null : new RE(rePattern);
            if (this.getLogger().isDebugEnabled()) {
                this.getLogger().debug("include pattern: " + rePattern);
            }

            rePattern = par.getParameter("exclude", null);
            this.cacheKeyParList.add(rePattern);
            this.excludeRE = (rePattern == null) ? null : new RE(rePattern);
            if (this.getLogger().isDebugEnabled()) {
                this.getLogger().debug("exclude pattern: " + rePattern);
            }
        } catch (RESyntaxException rese) {
            throw new ProcessingException("Syntax error in regexp pattern '"
                                          + rePattern + "'", rese);
        }

        this.isRequestedDirectory = false;
        this.attributes = new AttributesImpl();
    }
15231#/* (non-Javadoc)
     * @see org.apache.cocoon.caching.CacheableProcessingComponent#getKey()
     */
    public Serializable getKey() {
        StringBuffer buffer = new StringBuffer();
        int len = this.cacheKeyParList.size();
        for (int i = 0; i < len; i++) {
            buffer.append(this.cacheKeyParList.get(i)).append(":");
        }
        return buffer.toString();
    }
15232#/**
     * Gets the source validity, using a deferred validity object. The validity
     * is initially empty since the files that define it are not known before
     * generation has occured. So the returned object is kept by the generator
     * and filled with each of the files that are traversed.
     * 
     * @see DirectoryGenerator.DirValidity
     */
    public SourceValidity getValidity() {
        if (this.validity == null) {
            this.validity = new DirValidity(this.refreshDelay);
        }
        return this.validity;
    }
15233#/**
     * Generate XML data.
     * 
     * @throws SAXException  if an error occurs while outputting the document
     * @throws ProcessingException  if the requsted URI isn't a directory on the local filesystem
     */
    public void generate() throws SAXException, ProcessingException {
        try {
            String systemId = this.directorySource.getURI();
            if (!systemId.startsWith(FILE)) {
                throw new ResourceNotFoundException(systemId + " does not denote a directory");
            }
            // This relies on systemId being of the form "file://..."
            File directoryFile = new File(new URL(systemId).getFile());
            if (!directoryFile.isDirectory()) {
                throw new ResourceNotFoundException(super.source + " is not a directory.");
            }

            this.contentHandler.startDocument();
            this.contentHandler.startPrefixMapping(PREFIX, URI);

            Stack ancestors = getAncestors(directoryFile);
            addAncestorPath(directoryFile, ancestors);

            this.contentHandler.endPrefixMapping(PREFIX);
            this.contentHandler.endDocument();
        } catch (IOException ioe) {
            throw new ResourceNotFoundException("Could not read directory " + super.source, ioe);
        }
    }
15234#/**
     * Creates a stack containing the ancestors of File up to specified directory.
     * 
     * @param path the File whose ancestors shall be retrieved
     * @return a Stack containing the ancestors.
     */
    protected Stack getAncestors(File path) {
        File parent = path;
        Stack ancestors = new Stack();

        while ((parent != null) && !isRoot(parent)) {
            parent = parent.getParentFile();
            if (parent != null) {
                ancestors.push(parent);
            } else {
                // no ancestor matched the root pattern
                ancestors.clear();
            }
        }

        return ancestors;
    }
15235#/**
     * Adds recursively the path from the directory matched by the root pattern
     * down to the requested directory.
     * 
     * @param path       the requested directory.
     * @param ancestors  the stack of the ancestors.
     * @throws SAXException
     */
    protected void addAncestorPath(File path, Stack ancestors) throws SAXException {
        if (ancestors.empty()) {
            this.isRequestedDirectory = true;
            addPath(path, depth);
        } else {
            startNode(DIR_NODE_NAME, (File)ancestors.pop());
            addAncestorPath(path, ancestors);
            endNode(DIR_NODE_NAME);
        }
    }
15236#/**
     * Adds a single node to the generated document. If the path is a
     * directory, and depth is greater than zero, then recursive calls
     * are made to add nodes for the directory's children.
     * 
     * @param path   the file/directory to process
     * @param depth  how deep to scan the directory
     * @throws SAXException  if an error occurs while constructing nodes
     */
    protected void addPath(File path, int depth) throws SAXException {
        if (path.isDirectory()) {
            startNode(DIR_NODE_NAME, path);
            if (depth > 0) {
                File contents[] = path.listFiles();

                if (sort.equals("name")) {
                    Arrays.sort(contents, new Comparator() {
                        public int compare(Object o1, Object o2) {
                            if (reverse) {
                                return ((File)o2).getName().compareTo(((File)o1).getName());
                            }
                            return ((File)o1).getName().compareTo(((File)o2).getName());
                        }
                    });
                } else if (sort.equals("size")) {
                    Arrays.sort(contents, new Comparator() {
                        public int compare(Object o1, Object o2) {
                            if (reverse) {
                                return new Long(((File)o2).length()).compareTo(
                                    new Long(((File)o1).length()));
                            }
                            return new Long(((File)o1).length()).compareTo(
                                new Long(((File)o2).length()));
                        }
                    });
                } else if (sort.equals("lastmodified")) {
                    Arrays.sort(contents, new Comparator() {
                        public int compare(Object o1, Object o2) {
                            if (reverse) {
                                return new Long(((File)o2).lastModified()).compareTo(
                                    new Long(((File)o1).lastModified()));
                            }
                            return new Long(((File)o1).lastModified()).compareTo(
                                new Long(((File)o2).lastModified()));
                        }
                    });
                } else if (sort.equals("directory")) {
                    Arrays.sort(contents, new Comparator() {
                        public int compare(Object o1, Object o2) {
                            File f1 = (File)o1;
                            File f2 = (File)o2;

                            if (reverse) {
                                if (f2.isDirectory() && f1.isFile())
                                    return -1;
                                if (f2.isFile() && f1.isDirectory())
                                    return 1;
                                return f2.getName().compareTo(f1.getName());
                            }
                            if (f2.isDirectory() && f1.isFile())
                                return 1;
                            if (f2.isFile() && f1.isDirectory())
                                return -1;
                            return f1.getName().compareTo(f2.getName());
                        }
                    });
                }

                for (int i = 0; i < contents.length; i++) {
                    if (isIncluded(contents[i]) && !isExcluded(contents[i])) {
                        addPath(contents[i], depth - 1);
                    }
                }
            }
            endNode(DIR_NODE_NAME);
        } else {
            if (isIncluded(path) && !isExcluded(path)) {
                startNode(FILE_NODE_NAME, path);
                endNode(FILE_NODE_NAME);
            }
        }
    }
15237#/**
     * Begins a named node and calls setNodeAttributes to set its attributes.
     * 
     * @param nodeName  the name of the new node
     * @param path      the file/directory to use when setting attributes
     * @throws SAXException  if an error occurs while creating the node
     */
    protected void startNode(String nodeName, File path) throws SAXException {
        if (this.validity != null) {
            this.validity.addFile(path);
        }
        setNodeAttributes(path);
        super.contentHandler.startElement(URI, nodeName, PREFIX + ':' + nodeName, attributes);
    }
15238#/**
     * Sets the attributes for a given path. The default method sets attributes
     * for the name of thefile/directory and for the last modification time
     * of the path.
     * 
     * @param path  the file/directory to use when setting attributes
     * @throws SAXException  if an error occurs while setting the attributes
     */
    protected void setNodeAttributes(File path) throws SAXException {
        long lastModified = path.lastModified();
        attributes.clear();
        attributes.addAttribute("", FILENAME_ATTR_NAME, FILENAME_ATTR_NAME,
                                "CDATA", path.getName());
        attributes.addAttribute("", LASTMOD_ATTR_NAME, LASTMOD_ATTR_NAME,
                                "CDATA", Long.toString(path.lastModified()));
        attributes.addAttribute("", DATE_ATTR_NAME, DATE_ATTR_NAME,
                                "CDATA", dateFormatter.format(new Date(lastModified)));
        attributes.addAttribute("", SIZE_ATTR_NAME, SIZE_ATTR_NAME,
                                "CDATA", Long.toString(path.length()));
        if (this.isRequestedDirectory) {
            attributes.addAttribute("", "sort", "sort", "CDATA", this.sort);
            attributes.addAttribute("", "reverse", "reverse", "CDATA",
                                    String.valueOf(this.reverse));
            attributes.addAttribute("", "requested", "requested", "CDATA", "true");
            this.isRequestedDirectory = false;
        }
    }
15239#/**
     * Ends the named node.
     * 
     * @param nodeName  the name of the new node
     * @throws SAXException  if an error occurs while closing the node
     */
    protected void endNode(String nodeName) throws SAXException {
        super.contentHandler.endElement(URI, nodeName, PREFIX + ':' + nodeName);
    }
15240#/**
     * Determines if a given File is the defined root.
     * 
     * @param path  the File to check
     * @return true if the File is the root or the root pattern is not set,
     *         false otherwise.
     */
    protected boolean isRoot(File path) {
        return this.rootRE == null || this.rootRE.match(path.getName());
    }
15241#/**
     * Determines if a given File shall be visible.
     * 
     * @param path  the File to check
     * @return true if the File shall be visible or the include Pattern is <code>null</code>,
     *         false otherwise.
     */
    protected boolean isIncluded(File path) {
        return this.includeRE == null || this.includeRE.match(path.getName());
    }
15242#/**
     * Determines if a given File shall be excluded from viewing.
     * 
     * @param path  the File to check
     * @return false if the given File shall not be excluded or the exclude Pattern is <code>null</code>,
     *         true otherwise.
     */
    protected boolean isExcluded(File path) {
        return this.excludeRE != null && this.excludeRE.match(path.getName());
    }
15243#/**
     * Recycle resources
     */
    public void recycle() {
        if (this.resolver != null) {
            this.resolver.release(this.directorySource);
            this.directorySource = null;
        }
        this.cacheKeyParList = null;
        this.attributes = null;
        this.dateFormatter = null;
        this.rootRE = null;
        this.includeRE = null;
        this.excludeRE = null;
        this.validity = null;
        super.recycle();
    }
15244#public DirValidity(long delay) {
            expiry = System.currentTimeMillis() + delay;
            this.delay = delay;
        }
15245#public int isValid() {
            if (System.currentTimeMillis() <= expiry) {
                return SourceValidity.VALID;
            }

            int len = files.size();
            for (int i = 0; i < len; i++) {
                File f = (File)files.get(i);
                if (!f.exists()) {
                    return SourceValidity.INVALID; // File was removed
                }

                long oldDate = ((Long)fileDates.get(i)).longValue();
                long newDate = f.lastModified();

                if (oldDate != newDate) {
                    // File's last modified date has changed since last check
                    // NOTE: this occurs on directories as well when a file is added
                    return SourceValidity.INVALID;
                }
            }

            // all content is up to date: update the expiry date
            expiry = System.currentTimeMillis() + delay;
            return SourceValidity.VALID;
        }
15246#public int isValid(SourceValidity newValidity) {
            return isValid();
        }
15247#public void addFile(File f) {
            files.add(f);
            fileDates.add(new Long(f.lastModified()));
        }
15248#/**
     * Extends the <code>setNodeAttributes</code> method from the
     * <code>DirectoryGenerator</code> by adding width, height and comment attributes
     * if the path is a GIF or a JPEG file.
     */
    protected void setNodeAttributes(File path) throws SAXException {
        super.setNodeAttributes(path);
        if (path.isDirectory()) {
            return;
        }
        try {
            ImageProperties p = ImageUtils.getImageProperties(path);
            if (p != null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug(String.valueOf(path) + " = " + String.valueOf(p));
                }
                attributes.addAttribute("", IMAGE_WIDTH_ATTR_NAME, IMAGE_WIDTH_ATTR_NAME, "CDATA", String.valueOf(p.width));
                attributes.addAttribute("", IMAGE_HEIGHT_ATTR_NAME, IMAGE_HEIGHT_ATTR_NAME, "CDATA", String.valueOf(p.height));
                if (p.comment != null) attributes.addAttribute("", IMAGE_COMMENT_ATTR_NAME, IMAGE_COMMENT_ATTR_NAME, "CDATA", String.valueOf(p.comment));
            }
        }
        catch (FileFormatException e) {
            throw new SAXException(e);
        }
        catch (FileNotFoundException e) {
            throw new SAXException(e);
        }
        catch (IOException e) {
            throw new SAXException(e);
        }
    }
15249#public void setParser(SAXParser parser) {
        this.parser = parser;
    }
15250#/**
     * Recycle this component.
     * All instance variables are set to <code>null</code>.
     */
    public void recycle() {
        if (this.inputSource != null) {
            super.resolver.release(this.inputSource);
            this.inputSource = null;
        }
        if (this.parser != null) {
            super.manager.release(this.parser);
            this.parser = null;
        }
        super.recycle();
    }
15251#/**
     * Setup the file generator.
     * Try to get the last modification date of the source for caching.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        super.setup(resolver, objectModel, src, par);

        try {
        	// Lookup parser in Avalon contexts
        	if (this.parser == null) {
				this.parser = (SAXParser) this.manager.lookup(SAXParser.class.getName());
            }
        } catch (ServiceException e) {
            throw new ProcessingException("Exception when getting parser.", e);
        }

        try {
            this.inputSource = super.resolver.resolveURI(src);
        } catch (SourceException se) {
            throw SourceUtil.handle("Error during resolving of '" + src + "'.", se);
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Source " + super.source +
                              " resolved to " + this.inputSource.getURI());
        }
    }
15252#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     *
     * @return The generated key hashes the src
     */
    public Serializable getKey() {
        return this.inputSource.getURI();
    }
15253#/**
     * Generate the validity object.
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity() {
        return this.inputSource.getValidity();
    }
15254#/**
     * Generate XML data.
     */
    public void generate()
    throws IOException, SAXException, ProcessingException {
        try {
            SourceUtil.parse(this.parser, this.inputSource, super.xmlConsumer);
        } catch (SAXException e) {
            SourceUtil.handleSAXException(this.inputSource.getURI(), e);
        }
    }
15255#/**
     * Set the request parameters. Must be called before the generate method.
     *
     * @param resolver     the SourceResolver object
     * @param objectModel  a <code>Map</code> containing model object
     * @param src          the source URI (ignored)
     * @param par          configuration parameters
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        super.setup(resolver, objectModel, src, par);
        
        this.cacheKeyParList = new ArrayList();
        this.cacheKeyParList.add(src);

        // Determine the locale
        String langString = par.getParameter("lang", null);
        locale = Locale.getDefault();
        if (langString != null) {
            this.cacheKeyParList.add(langString);
            String countryString = par.getParameter("country", "");
            if (! "".equals(countryString)) {
                this.cacheKeyParList.add(countryString);
            }
            locale = new Locale(langString, countryString);
        }
        
        // Determine year and month. Default is current year and month.
        Calendar now = Calendar.getInstance(locale);
        this.year = par.getParameterAsInteger("year", now.get(Calendar.YEAR));
        this.cacheKeyParList.add(String.valueOf(this.year));
        this.month = par.getParameterAsInteger("month", now.get(Calendar.MONTH) + 1) - 1;
        this.cacheKeyParList.add(String.valueOf(this.month));
        
        String dateFormatString = par.getParameter("dateFormat", null);
        this.cacheKeyParList.add(dateFormatString);
        if (dateFormatString != null) {
            this.dateFormatter = new SimpleDateFormat(dateFormatString, locale);
        } else {
            this.dateFormatter = DateFormat.getDateInstance(DateFormat.LONG, locale);
        }
        this.padWeeks = par.getParameterAsBoolean("padWeeks", false);
        this.cacheKeyParList.add(BooleanUtils.toBooleanObject(this.padWeeks));
        this.monthFormatter = new SimpleDateFormat("MMMM", locale);        
        this.attributes = new AttributesImpl();
    }
15256#/**
     * Generate XML data.
     *
     * @throws  SAXException if an error occurs while outputting the document
     */
    public void generate() throws SAXException, ProcessingException {
        Calendar start = Calendar.getInstance(locale);
        start.clear();
        start.set(Calendar.YEAR, this.year);
        start.set(Calendar.MONTH, this.month);
        start.set(Calendar.DAY_OF_MONTH, 1);
        Calendar end = (Calendar) start.clone();
        end.add(Calendar.MONTH, 1);

        // Determine previous and next months
        Calendar prevMonth = (Calendar) start.clone();
        prevMonth.add(Calendar.MONTH, -1);
        
        this.contentHandler.startDocument();
        this.contentHandler.startPrefixMapping(PREFIX, URI);
        attributes.clear();
        attributes.addAttribute("", YEAR_ATTR_NAME, YEAR_ATTR_NAME, "CDATA", String.valueOf(year));
        attributes.addAttribute("", MONTH_ATTR_NAME, MONTH_ATTR_NAME, "CDATA", 
                monthFormatter.format(start.getTime()));
        
        // Add previous and next month
        attributes.addAttribute("", PREV_YEAR_ATTR_NAME, PREV_YEAR_ATTR_NAME, "CDATA", 
                String.valueOf(prevMonth.get(Calendar.YEAR)));
        attributes.addAttribute("", PREV_MONTH_ATTR_NAME, PREV_MONTH_ATTR_NAME, "CDATA", 
                monthNumberFormatter.format(prevMonth.get(Calendar.MONTH) + 1));
        attributes.addAttribute("", NEXT_YEAR_ATTR_NAME, NEXT_YEAR_ATTR_NAME, "CDATA", 
                String.valueOf(end.get(Calendar.YEAR)));
        attributes.addAttribute("", NEXT_MONTH_ATTR_NAME, NEXT_MONTH_ATTR_NAME, "CDATA", 
                monthNumberFormatter.format(end.get(Calendar.MONTH) + 1));

        this.contentHandler.startElement(URI, CALENDAR_NODE_NAME,
                PREFIX + ':' + CALENDAR_NODE_NAME, attributes);
        int weekNo = start.get(Calendar.WEEK_OF_MONTH);
        int firstDay = start.getFirstDayOfWeek();
        if (start.get(Calendar.DAY_OF_WEEK) != firstDay) {
            attributes.clear();
            attributes.addAttribute("", NUMBER_ATTR_NAME, NUMBER_ATTR_NAME, "CDATA", String.valueOf(weekNo));
            this.contentHandler.startElement(URI, WEEK_NODE_NAME,
                    PREFIX + ':' + WEEK_NODE_NAME, attributes);
            if (padWeeks) {
                Calendar previous = (Calendar) start.clone();
                while (previous.get(Calendar.DAY_OF_WEEK) != firstDay) {
                    previous.add(Calendar.DAY_OF_MONTH, -1);		
                }
                while (previous.before(start)) {
                    attributes.clear();
                    attributes.addAttribute("", NUMBER_ATTR_NAME, NUMBER_ATTR_NAME, "CDATA",
                            String.valueOf(previous.get(Calendar.DAY_OF_MONTH)));
                    attributes.addAttribute("", WEEKDAY_ATTR_NAME, WEEKDAY_ATTR_NAME, "CDATA",
                            weekdays[previous.get(Calendar.DAY_OF_WEEK)]);
                    attributes.addAttribute("", DATE_ATTR_NAME, DATE_ATTR_NAME, "CDATA",
                            dateFormatter.format(previous.getTime()));
                    this.contentHandler.startElement(URI, DAY_NODE_NAME,
                            PREFIX + ':' + DAY_NODE_NAME, attributes);
                    addContent(previous, locale);
                    this.contentHandler.endElement(URI, DAY_NODE_NAME,
                            PREFIX + ':' + DAY_NODE_NAME);
                    previous.add(Calendar.DAY_OF_MONTH, 1); 
                } 
            }
        }
        while (start.before(end)) {
            if (start.get(Calendar.DAY_OF_WEEK) == firstDay) {
                weekNo = start.get(Calendar.WEEK_OF_MONTH);
                attributes.clear();
                attributes.addAttribute("", NUMBER_ATTR_NAME, NUMBER_ATTR_NAME, "CDATA", String.valueOf(weekNo));
                this.contentHandler.startElement(URI, WEEK_NODE_NAME,
                        PREFIX + ':' + WEEK_NODE_NAME, attributes);
            }
            attributes.clear();
            attributes.addAttribute("", NUMBER_ATTR_NAME, NUMBER_ATTR_NAME, "CDATA",
                    String.valueOf(start.get(Calendar.DAY_OF_MONTH)));
            attributes.addAttribute("", WEEKDAY_ATTR_NAME, WEEKDAY_ATTR_NAME, "CDATA",
                    weekdays[start.get(Calendar.DAY_OF_WEEK)]);
            attributes.addAttribute("", DATE_ATTR_NAME, DATE_ATTR_NAME, "CDATA",
                    dateFormatter.format(start.getTime()));
            this.contentHandler.startElement(URI, DAY_NODE_NAME,
                    PREFIX + ':' + DAY_NODE_NAME, attributes);
            addContent(start, locale);
            this.contentHandler.endElement(URI, DAY_NODE_NAME,
                    PREFIX + ':' + DAY_NODE_NAME);
            start.add(Calendar.DAY_OF_MONTH, 1);
            if (start.get(Calendar.DAY_OF_WEEK) == firstDay
                    || (!padWeeks && ! start.before(end))) {
                this.contentHandler.endElement(URI, WEEK_NODE_NAME,
                        PREFIX + ':' + WEEK_NODE_NAME);
            }
        }
        
        if (padWeeks) {
            while (firstDay != end.get(Calendar.DAY_OF_WEEK)) {
                attributes.clear();
                attributes.addAttribute("", NUMBER_ATTR_NAME, NUMBER_ATTR_NAME, "CDATA",
                        String.valueOf(end.get(Calendar.DAY_OF_MONTH)));
                attributes.addAttribute("", WEEKDAY_ATTR_NAME, WEEKDAY_ATTR_NAME, "CDATA",
                        weekdays[end.get(Calendar.DAY_OF_WEEK)]);
                attributes.addAttribute("", DATE_ATTR_NAME, DATE_ATTR_NAME, "CDATA",
                        dateFormatter.format(end.getTime()));
                this.contentHandler.startElement(URI, DAY_NODE_NAME,
                        PREFIX + ':' + DAY_NODE_NAME, attributes);
                addContent(end, locale);
                this.contentHandler.endElement(URI, DAY_NODE_NAME,
                        PREFIX + ':' + DAY_NODE_NAME);
                end.add(Calendar.DAY_OF_MONTH, 1); 		
                if (firstDay == end.get(Calendar.DAY_OF_WEEK)) { 
                        this.contentHandler.endElement(URI, WEEK_NODE_NAME,
	                       PREFIX + ':' + WEEK_NODE_NAME);
                }
            }
        }
        this.contentHandler.endElement(URI, CALENDAR_NODE_NAME,
                PREFIX + ':' + CALENDAR_NODE_NAME);
        this.contentHandler.endPrefixMapping(PREFIX);
        this.contentHandler.endDocument();
    }
15257#/**
     * Add content to a &lt;day&gt; element. This method is intended to be overridden
     * by subclasses that want to add content to one or more days of the calendar.
     * 
     * @param date   The date corresponding to the current element.
     * @param locale The current locale.
     * @throws SAXException if an error occurs while outputting the document
     */
    protected void addContent(Calendar date, Locale locale) throws SAXException {}
15258#/**
     * @see org.apache.cocoon.caching.CacheableProcessingComponent#getKey()
     */
    public Serializable getKey() {
        StringBuffer buffer = new StringBuffer();
        int len = this.cacheKeyParList.size();
        for (int i = 0; i < len; i++) {
            buffer.append(this.cacheKeyParList.get(i)).append(":");
        }

        return buffer.toString();
    }
15259#/**
     * @see org.apache.cocoon.caching.CacheableProcessingComponent#getValidity()
     */
    public SourceValidity getValidity() {
        return NOPValidity.SHARED_INSTANCE;
    }
15260#/**
     * Recycle resources
     * @see org.apache.avalon.excalibur.pool.Recyclable#recycle()
     */
    public void recycle() {
        this.cacheKeyParList = null;
        this.attributes = null;
        this.dateFormatter = null;
        this.monthFormatter = null;
        this.locale = null;
        super.recycle();
    }
15261#/**
     * Set the request parameters. Must be called before the generate method.
     *
     * @param resolver     the SourceResolver object
     * @param objectModel  a <code>Map</code> containing model object
     * @param src          the Traversable Source to be XMLized specified as
     *                     <code>src</code> attribute on &lt;map:generate/>
     * @param par          configuration parameters
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        if (src == null) {
            throw new ProcessingException("No src attribute pointing to a traversable source to be XMLized specified.");
        }
        super.setup(resolver, objectModel, src, par);

        this.cacheKeyParList = new ArrayList();
        this.cacheKeyParList.add(src);

        this.depth = par.getParameterAsInteger("depth", 1);
        this.cacheKeyParList.add(String.valueOf(this.depth));

        String dateFormatString = par.getParameter("dateFormat", null);
        this.cacheKeyParList.add(dateFormatString);
        if (dateFormatString != null) {
            String locale = par.getParameter("locale", null);
            if (locale != null) {
                this.dateFormatter = new SimpleDateFormat(dateFormatString, new Locale(locale, ""));
            } else {
                this.dateFormatter = new SimpleDateFormat(dateFormatString);
            }
        } else {
            this.dateFormatter = new SimpleDateFormat();
        }

        String timeZone = par.getParameter("timeZone", null);
        if (timeZone != null) {
            this.dateFormatter.setTimeZone(TimeZone.getTimeZone(timeZone));
        }

        this.sort = par.getParameter("sort", "name");
        this.cacheKeyParList.add(this.sort);

        this.reverse = par.getParameterAsBoolean("reverse", false);
        this.cacheKeyParList.add(String.valueOf(this.reverse));

        this.refreshDelay = par.getParameterAsLong("refreshDelay", 1L) * 1000L;
        this.cacheKeyParList.add(String.valueOf(this.refreshDelay));

        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("depth: " + this.depth);
            this.getLogger().debug("dateFormat: " + this.dateFormatter.toPattern());
            this.getLogger().debug("timeZone: " + timeZone);
            this.getLogger().debug("sort: " + this.sort);
            this.getLogger().debug("reverse: " + this.reverse);
            this.getLogger().debug("refreshDelay: " + this.refreshDelay);
        }

        String rePattern = null;
        try {
            rePattern = par.getParameter("root", null);
            if (this.getLogger().isDebugEnabled()) {
                this.getLogger().debug("root pattern: " + rePattern);
            }
            this.cacheKeyParList.add(rePattern);
            this.rootRE = (rePattern == null) ? null : new RE(rePattern);

            rePattern = par.getParameter("include", null);
            if (this.getLogger().isDebugEnabled()) {
                this.getLogger().debug("include pattern: " + rePattern);
            }
            this.cacheKeyParList.add(rePattern);
            this.includeRE = (rePattern == null) ? null : new RE(rePattern);

            rePattern = par.getParameter("exclude", null);
            if (this.getLogger().isDebugEnabled()) {
                this.getLogger().debug("exclude pattern: " + rePattern);
            }
            this.cacheKeyParList.add(rePattern);
            this.excludeRE = (rePattern == null) ? null : new RE(rePattern);

        } catch (RESyntaxException rese) {
            throw new ProcessingException("Syntax error in regexp pattern '"
            			                  + rePattern + "'", rese);
        }

        this.isRequestedSource = false;
        this.attributes = new AttributesImpl();
    }
15262#/* (non-Javadoc)
     * @see org.apache.cocoon.caching.CacheableProcessingComponent#getKey()
     */
    public Serializable getKey() {
        StringBuffer buffer = new StringBuffer();
        int len = this.cacheKeyParList.size();
        for (int i = 0; i < len; i++) {
            buffer.append(this.cacheKeyParList.get(i));
            buffer.append(':');
        }
        return buffer.toString();
    }
15263#/**
     * Gets the source validity, using a deferred validity object. The validity
     * is initially empty since the resources that define it are not known
     * before generation has occured. So the returned object is kept by the
     * generator and filled with each of the resources that is traversed.
     *
     * @see org.apache.cocoon.components.source.impl.MultiSourceValidity
     */
    public SourceValidity getValidity() {
        if (this.validity == null) {
            this.validity = new MultiSourceValidity(this.resolver, this.refreshDelay);
        }
        return this.validity;
    }
15264#/**
     * Generate XML data.
     *
     * @throws  SAXException if an error occurs while outputting the document
     * @throws  ProcessingException if something went wrong while traversing
     *                              the source hierarchy
     */
    public void generate() throws SAXException, ProcessingException {
        Source src = null;
        Stack ancestors = null;
        try {
            src = this.resolver.resolveURI(this.source);
            if (!(src instanceof TraversableSource)) {
                throw new SourceException(this.source + " is not a traversable source");
            }
            final TraversableSource inputSource = (TraversableSource) src;

            if (!inputSource.exists()) {
                throw new ResourceNotFoundException(this.source + " does not exist.");
            }

            this.contentHandler.startDocument();
            this.contentHandler.startPrefixMapping(PREFIX, URI);

            ancestors = getAncestors(inputSource);
            addAncestorPath(inputSource, ancestors);

            this.contentHandler.endPrefixMapping(PREFIX);
            this.contentHandler.endDocument();
            if (this.validity != null) {
                this.validity.close();
            }
        } catch (SourceException se) {
            throw SourceUtil.handle(se);
        } catch (IOException ioe) {
            throw new ResourceNotFoundException("Could not read collection "
                                                + this.source, ioe);
        } finally {
            if (src != null) {
                this.resolver.release(src);
            }
            if (ancestors != null) {
                Enumeration enumeration = ancestors.elements();
                while (enumeration.hasMoreElements()) {
                    resolver.release((Source) enumeration.nextElement());
                }
            }
        }
    }
15265#/**
     * Creates a stack containing the ancestors of a traversable source up to
     * specific parent matching the root pattern.
     *
     * @param source the traversable source whose ancestors shall be retrieved
     * @return a Stack containing the ancestors.
     */
    protected Stack getAncestors(TraversableSource source) throws IOException {
        TraversableSource parent = source;
        Stack ancestors = new Stack();

        while ((parent != null) && !isRoot(parent)) {
            parent = (TraversableSource) parent.getParent();
            if (parent != null) {
                ancestors.push(parent);
            } else {
                // no ancestor matched the root pattern
                ancestors.clear();
            }
        }

        return ancestors;
    }
15266#/**
     * Adds recursively the path from the source matched by the root pattern
     * down to the requested source.
     *
     * @param source       the requested source.
     * @param ancestors  the stack of the ancestors.
     * @throws SAXException
     * @throws ProcessingException
     */
    protected void addAncestorPath(TraversableSource source, Stack ancestors)
    throws SAXException, ProcessingException {
        if (ancestors.empty()) {
            this.isRequestedSource = true;
            addPath(source, depth);
        } else {
            startNode(COL_NODE_NAME, (TraversableSource) ancestors.pop());
            addAncestorPath(source, ancestors);
            endNode(COL_NODE_NAME);
        }
    }
15267#/**
     * Adds a single node to the generated document. If the path is a
     * collection and depth is greater than zero, then recursive calls
     * are made to add nodes for the collection's children.
     *
     * @param source  the resource/collection to process
     * @param depth   how deep to scan the collection hierarchy
     *
     * @throws SAXException  if an error occurs while constructing nodes
     * @throws ProcessingException  if a problem occurs with the source
     */
    protected void addPath(TraversableSource source, int depth)
    throws SAXException, ProcessingException {
        if (source.isCollection()) {
            startNode(COL_NODE_NAME, source);
            addContent(source);
            if (depth > 0) {

                Collection contents = null;

                try {
                    contents = source.getChildren();
                    if (sort.equals("name")) {
                        Arrays.sort(contents.toArray(), new Comparator() {
                            public int compare(Object o1, Object o2) {
                                if (reverse) {
                                    return ((TraversableSource) o2).getName().compareTo(((TraversableSource) o1).getName());
                                }
                                return ((TraversableSource) o1).getName().compareTo(((TraversableSource) o2).getName());
                            }
                        });
                    } else if (sort.equals("size")) {
                        Arrays.sort(contents.toArray(), new Comparator() {
                            public int compare(Object o1, Object o2) {
                                if (reverse) {
                                    return new Long(((TraversableSource) o2).getContentLength()).compareTo(new Long(((TraversableSource) o1).getContentLength()));
                                }
                                return new Long(((TraversableSource) o1).getContentLength()).compareTo(new Long(((TraversableSource) o2).getContentLength()));
                            }
                        });
                    } else if (sort.equals("lastmodified")) {
                        Arrays.sort(contents.toArray(), new Comparator() {
                            public int compare(Object o1, Object o2) {
                                if (reverse) {
                                    return new Long(((TraversableSource) o2).getLastModified()).compareTo(new Long(((TraversableSource) o1).getLastModified()));
                                }
                                return new Long(((TraversableSource) o1).getLastModified()).compareTo(new Long(((TraversableSource) o2).getLastModified()));
                            }
                        });
                    } else if (sort.equals("collection")) {
                        Arrays.sort(contents.toArray(), new Comparator() {
                            public int compare(Object o1, Object o2) {
                                TraversableSource ts1 = (TraversableSource) o1;
                                TraversableSource ts2 = (TraversableSource) o2;

                                if (reverse) {
                                    if (ts2.isCollection() && !ts1.isCollection())
                                        return -1;
                                    if (!ts2.isCollection() && ts1.isCollection())
                                        return 1;
                                    return ts2.getName().compareTo(ts1.getName());
                                }
                                if (ts2.isCollection() && !ts1.isCollection())
                                    return 1;
                                if (!ts2.isCollection() && ts1.isCollection())
                                    return -1;
                                return ts1.getName().compareTo(ts2.getName());
                            }
                        });
                    }

                    for (int i = 0; i < contents.size(); i++) {
                        if (isIncluded((TraversableSource) contents.toArray()[i]) && !isExcluded((TraversableSource) contents.toArray()[i])) {
                            addPath((TraversableSource) contents.toArray()[i], depth - 1);
                        }
                    }
    			} catch (SourceException e) {
                    throw new ProcessingException("Error adding paths", e);
                } finally {
                    if (contents != null) {
                        Iterator iter = contents.iterator();
                        while (iter.hasNext()) {
                            resolver.release((Source) iter.next());
                        }
                    }
                }
            }
            endNode(COL_NODE_NAME);
        } else {
            if (isIncluded(source) && !isExcluded(source)) {
                startNode(RESOURCE_NODE_NAME, source);
                addContent(source);
                endNode(RESOURCE_NODE_NAME);
            }
        }
    }
15268#/**
     * Allow subclasses a chance to generate additional elements within collection and resource
     * elements.
     *
     * @param source  the source to generate additional data for.
     */
    protected void addContent(TraversableSource source) throws SAXException, ProcessingException {
    }
15269#/**
     * Begins a named node and calls setNodeAttributes to set its attributes.
     *
     * @param nodeName  the name of the new node
     * @param source    the source a node with its attributes is added for
     *
     * @throws SAXException  if an error occurs while creating the node
     */
    protected void startNode(String nodeName, TraversableSource source)
    throws SAXException, ProcessingException {
        if (this.validity != null) {
            this.validity.addSource(source);
        }
        setNodeAttributes(source);
        super.contentHandler.startElement(URI, nodeName, PREFIX + ':' + nodeName, attributes);
    }
15270#/**
     * Sets the attributes for a given source. For example attributes for the
     * name, the size and the last modification date of the source are added.
     *
     * @param source  the source attributes are added for
     */
    protected void setNodeAttributes(TraversableSource source)
    throws SAXException, ProcessingException {
        long lastModified = source.getLastModified();
        attributes.clear();
        attributes.addAttribute("", RES_NAME_ATTR_NAME,RES_NAME_ATTR_NAME,
                                "CDATA", source.getName());
        attributes.addAttribute("", URI_ATTR_NAME,URI_ATTR_NAME,
                                "CDATA", source.getURI());
        attributes.addAttribute("", LASTMOD_ATTR_NAME, LASTMOD_ATTR_NAME,
                                "CDATA", Long.toString(source.getLastModified()));
        attributes.addAttribute("", DATE_ATTR_NAME, DATE_ATTR_NAME,
                                "CDATA", dateFormatter.format(new Date(lastModified)));
        attributes.addAttribute("", SIZE_ATTR_NAME, SIZE_ATTR_NAME,
                                "CDATA", Long.toString(source.getContentLength()));
        if (this.isRequestedSource) {
            attributes.addAttribute("", "sort", "sort", "CDATA", this.sort);
            attributes.addAttribute("", "reverse", "reverse", "CDATA",
                                    String.valueOf(this.reverse));
            attributes.addAttribute("", "requested", "requested", "CDATA", "true");
            this.isRequestedSource = false;
        }
    }
15271#/**
     * Ends the named node.
     *
     * @param nodeName  the name of the new node
     *
     * @throws SAXException  if an error occurs while closing the node
     */
    protected void endNode(String nodeName) throws SAXException {
        super.contentHandler.endElement(URI, nodeName, PREFIX + ':' + nodeName);
    }
15272#/**
     * Determines if a given source is the defined root.
     *
     * @param source  the source to check
     *
     * @return true if the source is the root or the root pattern is not set,
     *         false otherwise.
     */
    protected boolean isRoot(TraversableSource source) {
        return this.rootRE == null || this.rootRE.match(source.getName());
    }
15273#/**
     * Determines if a given source shall be visible.
     *
     * @param source  the source to check
     *
     * @return true if the source shall be visible or the include Pattern is not set,
     *         false otherwise.
     */
    protected boolean isIncluded(TraversableSource source) {
        return this.includeRE == null || this.includeRE.match(source.getName());
    }
15274#/**
     * Determines if a given source shall be excluded from viewing.
     *
     * @param source  the source to check
     *
     * @return false if the given source shall not be excluded or the exclude Pattern is not set,
     *         true otherwise.
     */
    protected boolean isExcluded(TraversableSource source) {
        return this.excludeRE != null && this.excludeRE.match(source.getName());
    }
15275#/**
     * Recycle resources
     */
    public void recycle() {
        this.cacheKeyParList = null;
        this.attributes = null;
        this.dateFormatter = null;
        this.rootRE = null;
        this.includeRE = null;
        this.excludeRE = null;
        this.validity = null;
        super.recycle();
    }
15276#public RequestParseException(String message)
    {
        super(message, null);
    }
15277#public RequestParseException(String message, Exception cause)
    {
        super(message, cause);
    }
15278#public void parameterize(Parameters parameters)
    throws ParameterException {
        global_container_encoding = parameters.getParameter("container-encoding", "ISO-8859-1");
        global_form_encoding = parameters.getParameter("form-encoding", null);
        global_generate_attributes = parameters.getParameterAsBoolean("generate-attributes", false);
    }
15279#public void setup(SourceResolver resolver, Map objectModel, String src, Parameters parameters)
    throws ProcessingException, SAXException, IOException {
        super.setup(resolver, objectModel, src, parameters);
        container_encoding = parameters.getParameter("container-encoding", global_container_encoding);
        form_encoding = parameters.getParameter("form-encoding", global_form_encoding);
        generate_attributes = parameters.getParameterAsBoolean("generate-attributes", global_generate_attributes);
    }
15280#/**
     * Generate XML data.
     */
    public void generate()
    throws SAXException {
        final Request request = ObjectModelHelper.getRequest(objectModel);
        final AttributesImpl attr = new AttributesImpl();

        this.contentHandler.startDocument();
        this.contentHandler.startPrefixMapping(PREFIX, URI);

        attribute(attr, "target", request.getRequestURI());
        attribute(attr, "sitemap", request.getSitemapURI());
        attribute(attr, "source", (this.source != null ? this.source : ""));
        start("request", attr);

        start("requestHeaders", attr);
        Enumeration headers = request.getHeaderNames();
        if ( headers != null ) {
            while (headers.hasMoreElements()) {
                String header = (String)headers.nextElement();
                attribute(attr, "name", header);
                start("header", attr);
                data(request.getHeader(header));
                end("header");
            }
        }
        end("requestHeaders");

        start("requestParameters", attr);
        Enumeration parameters = request.getParameterNames();
        while (parameters.hasMoreElements()) {
            String parameter = (String)parameters.nextElement();
            attribute(attr, "name", parameter);
            start("parameter", attr);
            String values[] = request.getParameterValues(parameter);
            if (values != null) {
                for (int x = 0; x < values.length; x++) {
                    start("value", attr);
                    if (form_encoding != null) {
                        try {
                            data(values[x], container_encoding, form_encoding);
                        } catch (UnsupportedEncodingException uee) {
                            throw new RequestEncodingException("The suggested encoding is not supported.", uee);
                        }
                    } else if (parameter.startsWith("xml:")) {
                        parse(values[x]);
                    } else {
                        data(values[x]);
                    }
                    end("value");
                }
            }
            end("parameter");
        }
        end("requestParameters");

        if (generate_attributes) {
            start("requestAttributes", attr);
            Enumeration attributes = request.getAttributeNames();
            while (attributes.hasMoreElements()) {
                String attribute = (String)attributes.nextElement();
                attribute(attr, "name", attribute);
                start("attribute", attr);
                Object value = request.getAttribute(attribute);
                if (value != null) {
                    start("value", attr);
                    XMLUtils.valueOf(this.contentHandler, value);
                    end("value");
                }
                end("attribute");
            }
            end("requestAttributes");
        }

        this.start("configurationParameters", attr);
        String[] confparams = super.parameters.getNames();
        for (int i = 0; i < confparams.length; i++) {
            attribute(attr, "name", confparams[i]);
            start("parameter", attr);
            data(super.parameters.getParameter(confparams[i], ""));
            end("parameter");
        }
        end("configurationParameters");

        start("remoteUser", attr);
        if (request.getRemoteUser() != null) {
            data(request.getRemoteUser());
        }
        end("remoteUser");

        end("request");

        this.contentHandler.endPrefixMapping(PREFIX);
        this.contentHandler.endDocument();
    }
15281#private void attribute(AttributesImpl attr, String name, String value) {
        attr.addAttribute("", name, name, "CDATA", value);
    }
15282#private void start(String name, AttributesImpl attr)
    throws SAXException {
        super.contentHandler.startElement(URI, name, PREFIX + ":" + name, attr);
        attr.clear();
    }
15283#private void end(String name)
    throws SAXException {
        super.contentHandler.endElement(URI, name, PREFIX + ":" + name);
    }
15284#private void data(String data)
    throws SAXException {
        super.contentHandler.characters(data.toCharArray(), 0, data.length());
    }
15285#private void data(String data, String container_encoding, String form_encoding) 
    throws SAXException, UnsupportedEncodingException {
        this.data(new String(data.getBytes(container_encoding), form_encoding));
    }
15286#private void parse(String data)
    throws SAXException {
        SAXParser parser = null;
        try {
            parser = (SAXParser) manager.lookup(SAXParser.ROLE);
            InputSource is = new InputSource(new StringReader(data));
            parser.parse(is, new IncludeXMLConsumer(super.xmlConsumer));
	} catch (SAXException se) {
	    // rethrow sax exceptions
	    throw se;
	} catch (Exception e) {
	    // wrap all others
	    throw new RequestParseException("Could not parse the parameters.", e);
        } finally {
            manager.release(parser);
        }
    }
15287#/**
     * <p>Create a new {@link CSVGeneratorBean} instance.</p>
     */
    public CSVGeneratorBean() {
        super();
    }
15288#/**
     * @see org.apache.cocoon.generation.FileGenerator#dispose()
     */
    public void dispose() {
        super.dispose();

        this.encoding = DEFAULT_ENCODING;
        this.separator = DEFAULT_SEPARATOR.charAt(0);
        this.escape = DEFAULT_ESCAPE.charAt(0);
        this.buffersize = DEFAULT_BUFFER_SIZE;
        this.buffer = null;
        this.columns = null;
        this.recordnumber = 1;
        this.fieldnumber = 1;
        this.openrecord = false;
    }
15289#/**
     * <p>Setup this {@link CSVGeneratorBean} instance.</p>
     */
    public void setup(SourceResolver resolver, Map object_model, String source,
                      Parameters parameters)
    throws ProcessingException, SAXException, IOException {
        super.setup(resolver, object_model, source, parameters);

        boolean header = parameters.getParameterAsBoolean("process-headers", false);

        this.encoding = parameters.getParameter("encoding", DEFAULT_ENCODING);
        this.separator = parameters.getParameter("separator", DEFAULT_SEPARATOR).charAt(0);
        this.escape = parameters.getParameter("escape", DEFAULT_ESCAPE).charAt(0);
        this.buffersize = parameters.getParameterAsInteger("buffer-size", DEFAULT_BUFFER_SIZE);
        this.maxrecords = parameters.getParameterAsInteger("max-records", UNLIMITED_MAXRECORDS);
        this.buffer = new CharArrayWriter();
        this.columns =  (header ? new HashMap() : null);
        this.recordnumber = (header ? 0 : 1);
        this.fieldnumber = 1;
        this.openrecord = false;
    }
15290#/**
     * <p>Generate the unique key.</p>
     */
    public Serializable getKey() {
        StringBuffer key = new StringBuffer(this.inputSource.getURI());
        if (this.columns != null) key.append("headers");
        key.append(separator);
        key.append(maxrecords);
        key.append(escape);
        return key;
    }
15291#/**
     * <p>Generate XML data from a Comma Separated Value resource.</p>.
     */
    public void generate()
    throws IOException, SAXException, ProcessingException {

        /* Create a new Reader correctly decoding the source stream */
        CSVReader csv = new CSVReader(this.inputSource, this.encoding, this.buffersize);

        try {
            /* Start the document */
            this.consumer.setDocumentLocator(csv);
            this.consumer.startDocument();
            this.consumer.startPrefixMapping(NAMESPACE_PREFIX, NAMESPACE_URI);
            this.indent(0);
            this.startElement("document");

            /* Allocate buffer and status for parsing */
            boolean unescaped = true;
            int prev = -1;
            int curr = -1;

            /* Parse the file reading characters one-by-one */
            while ((curr = csv.read()) >= 0 && (this.maxrecords == UNLIMITED_MAXRECORDS || recordnumber <= this.maxrecords)) {

                /* Process any occurrence of the escape character */
                if (curr == this.escape) {
                    if ((unescaped) && (prev == this.escape)) {
                        this.buffer.write(this.escape);
                    }
                    unescaped = ! unescaped;
                    prev = curr;
                    continue;
                }

                /* Process any occurrence of the field separator */
                if ((unescaped) && (curr == this.separator)) {
                    this.dumpField();
                    prev = curr;
                    continue;
                }

                /* Process newline characters */
                if ((unescaped) && ((curr == '\r') || (curr == '\n'))) {
                    this.dumpField();
                    this.dumpRecord();

                    /* Record numbering */
                    if (((curr == '\n') && (prev != '\r')) || (curr == '\r')) {
                        this.recordnumber ++;
                    }
                    
                    /* Nothing else to do */
                    prev = curr;
                    continue;
                }

                /* Any other character simply gets added to the buffer */
                this.buffer.write(curr);
                prev = curr;
            }

            /* Terminate any hanging open record element (just in case) */
            this.dumpField();
            this.dumpRecord();

            /* Terminate the document */
            this.indent(0);
            this.endElement("document");
            this.consumer.endPrefixMapping(NAMESPACE_PREFIX);
            this.consumer.endDocument();

        } finally {
            csv.close();
        }
    }
15292#private void dumpField()
    throws SAXException {
        if (this.buffer.size() < 1) {
            this.fieldnumber ++;
            return;
        }

        if (! this.openrecord) {
            this.indent(4);

            if (this.recordnumber > 0) {
                AttributesImpl attributes = new AttributesImpl();
                String value = Integer.toString(this.recordnumber);
                attributes.addCDATAAttribute("number", value);
                this.startElement("record", attributes);
            } else {
                this.startElement("header");
            }
            this.openrecord = true;
        }

        /* Enclode the field in the proper element */
        String element = "field";
        char array[] = this.buffer.toCharArray();
        this.indent(8);

        AttributesImpl attributes = new AttributesImpl();
        String value = Integer.toString(this.fieldnumber);
        attributes.addCDATAAttribute("number", value);

        if (this.recordnumber < 1) {
            this.columns.put(new Integer(this.fieldnumber), new String(array));
            element = "column";
        } else if (this.columns != null) {
            String header = (String) this.columns.get(new Integer(this.fieldnumber));
            if (header != null) {
                attributes.addCDATAAttribute("column", header);
            }
        }

        this.startElement(element, attributes);
        this.consumer.characters(array, 0, array.length);
        this.endElement(element);
        this.buffer.reset();

        this.fieldnumber ++;
    }
15293#private void dumpRecord()
    throws SAXException {
        if (this.openrecord) {
            this.indent(4);
            if (this.recordnumber > 0) {
                this.endElement("record");
            } else {
                this.endElement("header");
            }
            this.openrecord = false;
        }
        this.fieldnumber = 1;
    }
15294#private void indent(int level)
    throws SAXException {
        this.consumer.characters(INDENT_STRING, 0, level + 1);
    }
15295#private void startElement(String name)
    throws SAXException {
        this.startElement(name, XMLUtils.EMPTY_ATTRIBUTES);
    }
15296#private void startElement(String name, Attributes atts)
    throws SAXException {
        if (name == null) throw new NullPointerException("Null name");
        String qual = NAMESPACE_PREFIX + ':' + name;
        this.consumer.startElement(NAMESPACE_URI, name, qual, (atts == null ? XMLUtils.EMPTY_ATTRIBUTES : atts));
    }
15297#private void endElement(String name)
    throws SAXException {
        String qual = NAMESPACE_PREFIX + ':' + name;
        this.consumer.endElement(NAMESPACE_URI, name, qual);
    }
15298#protected CSVReader(Source source, String encoding, int buffer)
        throws IOException {
            InputStream stream = source.getInputStream();
            Reader reader = new InputStreamReader(stream, encoding);
            this.input = new BufferedReader(reader, buffer);
            this.uri = source.getURI();
        }
15299#public String getPublicId() {
            return null;
        }
15300#public String getSystemId() {
            return this.uri;
        }
15301#public int getLineNumber() {
            return this.line;
        }
15302#public int getColumnNumber() {
            return this.column;
        }
15303#public void close()
        throws IOException {
            this.input.close();
        }
15304#public int read()
        throws IOException {
            int c = this.input.read();
            if (c < 0) return c;

            if (((c == '\n') && (this.last != '\r')) || (c == '\r')) {
                this.column = 1;
                this.line ++;
            }

            this.last = c;
            return c;
        }
15305#public int read(char b[], int o, int l)
        throws IOException {
            if (b == null) throw new NullPointerException();
            if ((o<0)||(o>b.length)||(l<0)||((o+l)>b.length)||((o+l)<0)) {
                throw new IndexOutOfBoundsException();
            }
            if (l == 0) return 0;

            int c = read();
            if (c == -1) return -1;
            b[o] = (char)c;

            int i = 1;
            try {
                for (i = 1; i < l ; i++) {
                    c = read();
                    if (c == -1) break;
                    b[o + i] = (char)c;
                }
            } catch (IOException ee) {
                return i;
            }
            return i;
        }
15306#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     *
     * @return The generated key hashes the src
     */
    public Serializable getKey() {
        return this.source;
    }
15307#/**
     * Generate the validity object.
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity() {
        return NOPValidity.SHARED_INSTANCE;
    }
15308#public void generate() throws SAXException, ProcessingException {
        // Obtain the fragmentID  (which is simply the filename portion of the source)
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Retrieving fragment " + source + ".");
        }

        Store store = null;
        Object fragment = null;
        try {
            store = (Store) this.manager.lookup(Store.TRANSIENT_STORE);
            fragment = store.get(source);
            if (fragment == null) {
                throw new ResourceNotFoundException("Could not find fragment " + source + " in store");
            }

            XMLByteStreamInterpreter deserializer = new XMLByteStreamInterpreter();
            deserializer.setConsumer(this.xmlConsumer);
            deserializer.deserialize(fragment);

        } catch (ServiceException ce) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Could not lookup for component.", ce);
            }
            throw new SAXException("Could not lookup for component.", ce);
        } finally {
            this.manager.release(store);
        }
    }
15309#/**
     * <p>Create a new {@link CSVGenerator} instance.</p>
     */
    public CSVGenerator() {
        super();
    }
15310#/**
     * <p>Recycle this component.</p>.
     */
    public void recycle() {
        super.recycle();
        
        this.encoding = DEFAULT_ENCODING;
        this.separator = DEFAULT_SEPARATOR.charAt(0);
        this.escape = DEFAULT_ESCAPE.charAt(0);
        this.buffersize = DEFAULT_BUFFER_SIZE;
        this.buffer = null;
        this.columns = null;
        this.recordnumber = 1;
        this.fieldnumber = 1;
        this.openrecord = false;
    }
15311#/**
     * <p>Setup this {@link CSVGenerator} instance.</p>
     */
    public void setup(SourceResolver resolver, Map object_model, String source,
                      Parameters parameters)
    throws ProcessingException, SAXException, IOException {
        super.setup(resolver, object_model, source, parameters);

        boolean header = parameters.getParameterAsBoolean("process-headers", false);

        this.encoding = parameters.getParameter("encoding", DEFAULT_ENCODING);
        this.separator = parameters.getParameter("separator", DEFAULT_SEPARATOR).charAt(0);
        this.escape = parameters.getParameter("escape", DEFAULT_ESCAPE).charAt(0);
        this.buffersize = parameters.getParameterAsInteger("buffer-size", DEFAULT_BUFFER_SIZE);
        this.maxrecords = parameters.getParameterAsInteger("max-records", UNLIMITED_MAXRECORDS);
        this.buffer = new CharArrayWriter();
        this.columns =  (header ? new HashMap() : null);
        this.recordnumber = (header ? 0 : 1);
        this.fieldnumber = 1;
        this.openrecord = false;
    }
15312#/**
     * <p>Generate the unique key.</p>
     */
    public Serializable getKey() {
        StringBuffer key = new StringBuffer(this.inputSource.getURI());
        if (this.columns != null) key.append("headers");
        key.append(separator);
        key.append(maxrecords);
        key.append(escape);
        return key;
    }
15313#/**
     * <p>Generate XML data from a Comma Separated Value resource.</p>.
     */
    public void generate()
    throws IOException, SAXException, ProcessingException {

        /* Create a new Reader correctly decoding the source stream */
        CSVReader csv = new CSVReader(this.inputSource, this.encoding, this.buffersize);

        try {
            /* Start the document */
            this.contentHandler.setDocumentLocator(csv);
            this.contentHandler.startDocument();
            this.contentHandler.startPrefixMapping(NAMESPACE_PREFIX, NAMESPACE_URI);
            this.indent(0);
            this.startElement("document");

            /* Allocate buffer and status for parsing */
            boolean unescaped = true;
            int prev = -1;
            int curr = -1;

            /* Parse the file reading characters one-by-one */
            while ((curr = csv.read()) >= 0 && (this.maxrecords == UNLIMITED_MAXRECORDS || recordnumber <= this.maxrecords)) {

                /* Process any occurrence of the escape character */
                if (curr == this.escape) {
                    if ((unescaped) && (prev == this.escape)) {
                        this.buffer.write(this.escape);
                    }
                    unescaped = ! unescaped;
                    prev = curr;
                    continue;
                }

                /* Process any occurrence of the field separator */
                if ((unescaped) && (curr == this.separator)) {
                    this.dumpField();
                    prev = curr;
                    continue;
                }

                /* Process newline characters */
                if ((unescaped) && ((curr == '\r') || (curr == '\n'))) {
                    this.dumpField();
                    this.dumpRecord();

                    /* Record numbering */
                    if (((curr == '\n') && (prev != '\r')) || (curr == '\r')) {
                        this.recordnumber ++;
                    }
                    
                    /* Nothing else to do */
                    prev = curr;
                    continue;
                }

                /* Any other character simply gets added to the buffer */
                this.buffer.write(curr);
                prev = curr;
            }

            /* Terminate any hanging open record element (just in case) */
            this.dumpField();
            this.dumpRecord();

            /* Terminate the document */
            this.indent(0);
            this.endElement("document");
            this.contentHandler.endPrefixMapping(NAMESPACE_PREFIX);
            this.contentHandler.endDocument();

        } finally {
            csv.close();
        }
    }
15314#private void dumpField()
    throws SAXException {
        if (this.buffer.size() < 1) {
            this.fieldnumber ++;
            return;
        }

        if (! this.openrecord) {
            this.indent(4);

            if (this.recordnumber > 0) {
                AttributesImpl attributes = new AttributesImpl();
                String value = Integer.toString(this.recordnumber);
                attributes.addCDATAAttribute("number", value);
                this.startElement("record", attributes);
            } else {
                this.startElement("header");
            }
            this.openrecord = true;
        }

        /* Enclode the field in the proper element */
        String element = "field";
        char array[] = this.buffer.toCharArray();
        this.indent(8);

        AttributesImpl attributes = new AttributesImpl();
        String value = Integer.toString(this.fieldnumber);
        attributes.addCDATAAttribute("number", value);

        if (this.recordnumber < 1) {
            this.columns.put(new Integer(this.fieldnumber), new String(array));
            element = "column";
        } else if (this.columns != null) {
            String header = (String) this.columns.get(new Integer(this.fieldnumber));
            if (header != null) {
                attributes.addCDATAAttribute("column", header);
            }
        }

        this.startElement(element, attributes);
        this.contentHandler.characters(array, 0, array.length);
        this.endElement(element);
        this.buffer.reset();

        this.fieldnumber ++;
    }
15315#private void dumpRecord()
    throws SAXException {
        if (this.openrecord) {
            this.indent(4);
            if (this.recordnumber > 0) {
                this.endElement("record");
            } else {
                this.endElement("header");
            }
            this.openrecord = false;
        }
        this.fieldnumber = 1;
    }
15316#private void indent(int level)
    throws SAXException {
        this.contentHandler.characters(INDENT_STRING, 0, level + 1);
    }
15317#private void startElement(String name)
    throws SAXException {
        this.startElement(name, new AttributesImpl());
    }
15318#private void startElement(String name, Attributes atts)
    throws SAXException {
        if (name == null) throw new NullPointerException("Null name");
        if (atts == null) atts = new AttributesImpl();
        String qual = NAMESPACE_PREFIX + ':' + name;
        this.contentHandler.startElement(NAMESPACE_URI, name, qual, atts);
    }
15319#private void endElement(String name)
    throws SAXException {
        String qual = NAMESPACE_PREFIX + ':' + name;
        this.contentHandler.endElement(NAMESPACE_URI, name, qual);
    }
15320#protected CSVReader(Source source, String encoding, int buffer)
        throws IOException {
            InputStream stream = source.getInputStream();
            Reader reader = new InputStreamReader(stream, encoding);
            this.input = new BufferedReader(reader, buffer);
            this.uri = source.getURI();
        }
15321#public String getPublicId() {
            return null;
        }
15322#public String getSystemId() {
            return this.uri;
        }
15323#public int getLineNumber() {
            return this.line;
        }
15324#public int getColumnNumber() {
            return this.column;
        }
15325#public void close()
        throws IOException {
            this.input.close();
        }
15326#public int read()
        throws IOException {
            int c = this.input.read();
            if (c < 0) return c;

            if (((c == '\n') && (this.last != '\r')) || (c == '\r')) {
                this.column = 1;
                this.line ++;
            }

            this.last = c;
            return c;
        }
15327#public int read(char b[], int o, int l)
        throws IOException {
            if (b == null) throw new NullPointerException();
            if ((o<0)||(o>b.length)||(l<0)||((o+l)>b.length)||((o+l)<0)) {
                throw new IndexOutOfBoundsException();
            }
            if (l == 0) return 0;

            int c = read();
            if (c == -1) return -1;
            b[o] = (char)c;

            int i = 1;
            try {
                for (i = 1; i < l ; i++) {
                    c = read();
                    if (c == -1) break;
                    b[o + i] = (char)c;
                }
            } catch (IOException ee) {
                return i;
            }
            return i;
        }
15328#/**
     * Extends the <code>setNodeAttributes</code> method from the
     * <code>DirectoryGenerator</code> by adding MP3 tag attributes
     * if the path is a MP3 file with valid tag.
     */
    protected void setNodeAttributes(File path) throws SAXException {
        super.setNodeAttributes(path);
        if (path.isDirectory()) {
            return;
        }

        RandomAccessFile in = null;
        try {
            in = new RandomAccessFile(path, "r");
            setID3HeaderAttributes(in);
            setID3TagAttributes(in);
        } catch (IOException e) {
            getLogger().debug("Could not set attributes for " + path, e);
        } finally {
            if(in != null) try{ in.close(); }catch(IOException ignored){}
        }
    }
15329#/**
     * Read ID3 Tag
     */
    private void setID3TagAttributes(RandomAccessFile in) throws IOException  {
        String s;

        // TAG takes 128 bytes
        if (in.length() < 128) return;
        in.seek(in.length() - 128);
        byte [] buf = new byte[128];
        // Read TAG
        if (in.read(buf,0, 128) != 128) return;
        // Check TAG presence
        if(buf[0] != 'T' || buf[1] != 'A' || buf[2] != 'G') return;

        s = getID3TagValue(buf, 3, 30);
        if(s.length() > 0)
            attributes.addAttribute("", MP3_TITLE_ATTR_NAME, MP3_TITLE_ATTR_NAME, "CDATA", s);
        s = getID3TagValue(buf, 33,30);
        if(s.length() > 0)
            attributes.addAttribute("", MP3_ARTIST_ATTR_NAME, MP3_ARTIST_ATTR_NAME, "CDATA", s);
        s = getID3TagValue(buf, 63,30);
        if(s.length() > 0)
            attributes.addAttribute("", MP3_ALBUM_ATTR_NAME, MP3_ALBUM_ATTR_NAME, "CDATA", s);
        s = getID3TagValue(buf, 93, 4);
        if(s.length() > 0)
            attributes.addAttribute("", MP3_YEAR_ATTR_NAME, MP3_YEAR_ATTR_NAME, "CDATA", s);
        s = getID3TagValue(buf, 97,29);
        if(s.length() > 0)
            attributes.addAttribute("", MP3_COMMENT_ATTR_NAME, MP3_COMMENT_ATTR_NAME, "CDATA", s);
        if(buf[126] > 0)
            attributes.addAttribute("", MP3_TRACK_ATTR_NAME, MP3_TRACK_ATTR_NAME, "CDATA",
                Byte.toString(buf[126]));
        if(buf[127] > 0)
            attributes.addAttribute("", MP3_GENRE_ATTR_NAME, MP3_GENRE_ATTR_NAME, "CDATA",
                Byte.toString(buf[127]));
    }
15330#private String getID3TagValue(byte[] buf, int offset, int length) {
        String s = new String(buf, offset, length);
        int index = s.indexOf(0x00);
        if (index != -1) {
            s = s.substring(0, index);
        }
        return s.trim();
    }
15331#private void setID3HeaderAttributes(RandomAccessFile in) throws IOException {
        byte[] buffer = new byte[4];

        // http://floach.pimpin.net/grd/mp3info/frmheader/index.html
        if (in.read(buffer, 0, 3) != 3) {
            return;
        }
        int header = ((buffer[0] << 16) & 0x00FF0000) | ((buffer[1] << 8) & 0x0000FF00) | ((buffer[2] << 0) & 0x000000FF);
        do {
            header <<= 8;
            if (in.read(buffer, 3, 1) != 1) {
                return;
            }
            header |= (buffer[3] & 0x000000FF);
        } while (!isSyncMark(header));

        int version = (header >>> 19) & 3;
        int layer = 4 - (header >>> 17) & 3;
        // int protection = (header >>> 16) & 1;
        int bitrate = (header >>> 12) & 0xF;
        int frequency = (header >>> 10) & 3;
        // Value 3 is reserved
        if (frequency == 3) {
            return;
        }
        // int padding = (header >>> 9) & 1;
        int mode = ((header >>> 6) & 3);

        attributes.addAttribute("", MP3_FREQUENCY_ATTR_NAME, MP3_FREQUENCY_ATTR_NAME, "CDATA",
            frequencyString(version, frequency));
        attributes.addAttribute("", MP3_MODE_ATTR_NAME, MP3_MODE_ATTR_NAME, "CDATA",
            mode(mode));

        int frames = getVBRHeaderFrames(in, version, mode);
        if (frames != -1) {
            // get average frame size by deviding fileSize by the number of frames
            float medFrameSize = (float)in.length() / frames;
            // This does not work properly: (version == VERSION_MPEG1? 12000.0:144000.0)
            bitrate = (int)(medFrameSize * frequency(version, frequency) / 144000.0);
            attributes.addAttribute("", MP3_BITRATE_ATTR_NAME, MP3_BITRATE_ATTR_NAME, "CDATA",
                Integer.toString(bitrate));
        } else {
            attributes.addAttribute("", MP3_BITRATE_ATTR_NAME, MP3_BITRATE_ATTR_NAME, "CDATA",
                bitrate(version, layer, bitrate));
        }
    }
15332#private static boolean isSyncMark(int header) {
        boolean sync = ((header & 0xFFF00000) == 0xFFF00000);
        // filter out invalid sample rate
        if (sync) sync = ((header >>> 10) & 3) != 3;
        // filter out invalid layer
        if (sync) sync = ((header >>> 17) & 3) != 0;
        // filter out invalid version
        if (sync) sync = ((header >>> 19) & 3) != 1;
        return sync;
    }
15333#private int getVBRHeaderFrames(RandomAccessFile in, int version, int mode) throws IOException {
        byte[] buffer = new byte[12];

        // Try to detect VBR header
        int skip;
        if (version == VERSION_MPEG1) {
            if (mode == MODE_SINGLE_CHANNEL) skip = 17;
            else skip = 32;
        } else { // mpeg version 2 or 2.5
            if (mode == MODE_SINGLE_CHANNEL) skip = 9;
            else skip = 17;
        }
        while (skip > 0) {
            if (in.read() == -1) return -1;
            skip --;
        }

        if (in.read(buffer, 0, 12) != 12) {
            return -1;
        }
        if (buffer[0] != 'X' || buffer[1] != 'i' || buffer[2] != 'n' || buffer[3] != 'g'){
            return -1;
        }

        attributes.addAttribute("", MP3_VBR_ATTR_NAME, MP3_VBR_ATTR_NAME, "CDATA",
            "yes");

        int flags =
            ((buffer[4] & 0xFF) << 24) |
            ((buffer[5] & 0xFF) << 16) |
            ((buffer[6] & 0xFF) <<  8) |
             (buffer[7] & 0xFF);

        if ((flags & VBR_FRAMES_FLAG) == VBR_FRAMES_FLAG){
            int frames =
                ((buffer[ 8] & 0xFF) << 24) |
                ((buffer[ 9] & 0xFF) << 16) |
                ((buffer[10] & 0xFF) <<  8) |
                 (buffer[11] & 0xFF);
            return frames;
        } else {
            return -1;
        }
    }
15334#private static String bitrate(int version, int layer, int bitrate_index) {
        return bitrates[version & 1][layer - 1][bitrate_index];
    }
15335#private static String mode(int mode) {
        switch(mode)
        {
        case MODE_STEREO:
            return "Stereo";
        case MODE_JOINT_STEREO:
            return "Joint stereo";
        case MODE_DUAL_CHANNEL:
            return "Dual channel";
        case MODE_SINGLE_CHANNEL:
            return "Single channel";
        }
        return null;
    }
15336#private static int frequency(int version, int frequency) {
        return frequencies[version][frequency];
    }
15337#private static String frequencyString(int version, int frequency) {
        return String.valueOf((float)frequency(version, frequency)/1000);
    }
15338#/**
     * Setup the file generator :try to retrieve the session attribute given as sitemap parameter
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
      throws ProcessingException, SAXException, IOException {

        super.setup(resolver, objectModel, src, par);

        // Get the element name (can be null if the object is a DOM or an XMLizable)
        this.elementName = par.getParameter(ELEMENT_NAME, null);

        // Get the attribute name
        String attrName = par.getParameter(ATTR_NAME, src);
        if (attrName == null) {
            String msg = "SessionAttributeGenerator needs an attribute name !";
            getLogger().error(msg);
            throw new ProcessingException(msg);
        }

        // Get the object to stream
        Request request = ObjectModelHelper.getRequest(objectModel);
        HttpSession session = request.getSession(false);
        if (session != null) {
            this.attrObject = session.getAttribute(attrName);
        }

        // Controls
        if (this.attrObject == null) {
            if (this.elementName == null) {
                // Can't generate nothing...
                String msg = "Session attribute '" + attrName + "' doesn't exist";
                getLogger().error(msg);
                throw new ProcessingException(msg);
            } else {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Session attribute '" + attrName +
                        "' doesn't exist : will generate a single '" + this.elementName +
                        "' element.");
                }
            }
        } else {
            // Need an element name for non-xml objects
            if (this.elementName == null &&
                ! (this.attrObject instanceof XMLizable) &&
                ! (this.attrObject instanceof Node)) {

                String msg = "Session attribute '" + attrName + "' needs an enclosing element : class is " +
                    this.attrObject.getClass().getName();

                getLogger().warn(msg);
                throw new ProcessingException(msg);
            }
        }
    }
15339#/**
     * Generate XML data
     */
    public void generate()
    throws IOException, SAXException, ProcessingException {
        xmlConsumer.startDocument();

        if (this.elementName != null) {
            xmlConsumer.startElement("", this.elementName, this.elementName, XMLUtils.EMPTY_ATTRIBUTES);
            XMLUtils.valueOf(new IncludeXMLConsumer(xmlConsumer), this.attrObject);
            xmlConsumer.endElement("", this.elementName, this.elementName);
        } else {
            XMLUtils.valueOf(new IncludeXMLConsumer(xmlConsumer), this.attrObject);
        }

        xmlConsumer.endDocument();
    }
15340#public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {

        char lastChar;
        String tmpWidth = par.getParameter("width", "0");
        String tmpHeight = par.getParameter("height", "0");

        this.scaleColor[0] = par.getParameterAsFloat("scaleRed", -1.0f);
        this.scaleColor[1] = par.getParameterAsFloat("scaleGreen", -1.0f);
        this.scaleColor[2] = par.getParameterAsFloat("scaleBlue", -1.0f);
        this.offsetColor[0] = par.getParameterAsFloat("offsetRed", 0.0f);
        this.offsetColor[1] = par.getParameterAsFloat("offsetGreen", 0.0f);
        this.offsetColor[2] = par.getParameterAsFloat("offsetBlue", 0.0f);
        this.quality[0] = par.getParameterAsFloat("quality", 0.9f);

        boolean filterColor = false;
        for (int i = 0; i < 3; ++i) {
            if (this.scaleColor[i] != -1.0f) {
                filterColor = true;
            } else {
                this.scaleColor[i] = 1.0f;
            }
            if (this.offsetColor[i] != 0.0f) {
                filterColor = true;
            }
        }

        if (filterColor) {
            this.colorFilter = new RescaleOp(scaleColor, offsetColor, null);
        }

        usePercent = false;
        lastChar = tmpWidth.charAt(tmpWidth.length() - 1);
        if (lastChar == '%') {
            usePercent = true;
            width = Integer.parseInt(tmpWidth.substring(0, tmpWidth.length() - 1));
        } else {
            width = Integer.parseInt(tmpWidth);
        }

        lastChar = tmpHeight.charAt(tmpHeight.length() - 1);
        if(lastChar == '%') {
            usePercent = true;
            height = Integer.parseInt(tmpHeight.substring(0, tmpHeight.length() - 1));
        } else {
            height = Integer.parseInt(tmpHeight);
        }

        if (par.getParameterAsBoolean("grayscale", GRAYSCALE_DEFAULT)) {
            this.grayscaleFilter = new ColorConvertOp(ColorSpace.getInstance(ColorSpace.CS_GRAY), null);
        }

        this.enlarge = par.getParameterAsBoolean("allow-enlarging", ENLARGE_DEFAULT);
        this.fitUniform = par.getParameterAsBoolean("fit-uniform", FIT_DEFAULT);

        super.setup(resolver, objectModel, src, par);
    }
15341#protected void setupHeaders() {
        // Reset byte ranges support for dynamic response
        if (byteRanges && hasTransform()) {
            byteRanges = false;
        }

        super.setupHeaders();
    }
15342#/**
     * @return True if image transform is specified
     */
    private boolean hasTransform() {
        return width > 0 || height > 0 || null != colorFilter || null != grayscaleFilter || (this.quality[0] != 0.9f);
    }
15343#/**
     * Returns the affine transform that implements the scaling.
     * The behavior is the following: if both the new width and height values
     * are positive, the image is rescaled according to these new values and
     * the original aspect ratio is lost.
     * Otherwise, if one of the two parameters is zero or negative, the
     * aspect ratio is maintained and the positive parameter indicates the
     * scaling.
     * If both new values are zero or negative, no scaling takes place (a unit
     * transformation is applied).
     */
    private AffineTransform getTransform(double ow, double oh, double nw, double nh) {
        double wm = 1.0d;
        double hm = 1.0d;

        if (fitUniform) {
            //
            // Compare aspect ratio of image vs. that of the "box"
            // defined by nw and nh
            //
            if (ow/oh > nw/nh) {
                nh = 0;    // Original image is proportionately wider than the box,
                        // so scale to fit width
            } else {
                nw = 0;    // Scale to fit height
            }
        }

        if (nw > 0) {
            wm = nw / ow;
            if (nh > 0) {
                hm = nh / oh;
            } else {
                hm = wm;
            }
        } else {
            if (nh > 0) {
                hm = nh / oh;
                wm = hm;
            }
        }

        if (!enlarge) {
            if ((nw > ow && nh <= 0) || (nh > oh && nw <=0)) {
                wm = 1.0d;
                hm = 1.0d;
            } else if (nw > ow) {
                wm = 1.0d;
            } else if (nh > oh) {
                hm = 1.0d;
            }
        }
        return new AffineTransform(wm, 0.0d, 0.0d, hm, 0.0d, 0.0d);
    }
15344#protected byte[] readFully(InputStream in) throws IOException
    {
        byte tmpbuffer[] = new byte[4096];
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        int i;
        while (-1!=(i = in.read(tmpbuffer)))
        {
            baos.write(tmpbuffer, 0, i);
        }
        baos.flush();
        return baos.toByteArray();
    }
15345#protected void processStream(InputStream inputStream) throws IOException, ProcessingException {
        if (hasTransform()) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("image " + ((width == 0) ? "?" : Integer.toString(width))
                                  + "x"    + ((height == 0) ? "?" : Integer.toString(height))
                                  + " expires: " + expires);
            }

            /*
             * NOTE (SM):
             * Due to Bug Id 4502892 (which is found in *all* JVM implementations from
             * 1.2.x and 1.3.x on all OS!), we must buffer the JPEG generation to avoid
             * that connection resetting by the peer (user pressing the stop button,
             * for example) crashes the entire JVM (yes, dude, the bug is *that* nasty
             * since it happens in JPEG routines which are native!)
             * I'm perfectly aware of the huge memory problems that this causes (almost
             * doubling memory consumption for each image and making the GC work twice
             * as hard) but it's *far* better than restarting the JVM every 2 minutes
             * (since this is the average experience for image-intensive web application
             * such as an image gallery).
             * Please, go to the <a href="http://developer.java.sun.com/developer/bugParade/bugs/4502892.html">Sun Developers Connection</a>
             * and vote this BUG as the one you would like fixed sooner rather than
             * later and all this hack will automagically go away.
             * Many deep thanks to Michael Hartle <mhartle@hartle-klug.com> for tracking
             * this down and suggesting the workaround.
             *
             * UPDATE (SM):
             * This appears to be fixed on JDK 1.4
             */

            try {
                byte content[] = readFully(inputStream);
                ImageIcon icon = new ImageIcon(content);
                BufferedImage original = new BufferedImage(icon.getIconWidth(), icon.getIconHeight(), BufferedImage.TYPE_INT_RGB);
                BufferedImage currentImage = original;
                currentImage.getGraphics().drawImage(icon.getImage(), 0, 0, null);

                if (width > 0 || height > 0) {
                    double ow = icon.getImage().getWidth(null);
                    double oh = icon.getImage().getHeight(null);

                    if (usePercent) {
                        if (width > 0) {
                            width = Math.round((int)(ow * width) / 100);
                        }
                        if (height > 0) {
                            height = Math.round((int)(oh * height) / 100);
                        }
                    }

                    AffineTransformOp filter = new AffineTransformOp(getTransform(ow, oh, width, height), AffineTransformOp.TYPE_BILINEAR);
                    WritableRaster scaledRaster = filter.createCompatibleDestRaster(currentImage.getRaster());

                    filter.filter(currentImage.getRaster(), scaledRaster);

                    currentImage = new BufferedImage(original.getColorModel(), scaledRaster, true, null);
                }

                if (null != grayscaleFilter) {
                    grayscaleFilter.filter(currentImage, currentImage);
                }

                if (null != colorFilter) {
                    colorFilter.filter(currentImage, currentImage);
                }

                // JVM Bug handling
                if (JVMBugFixed) {
                    JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);
                    JPEGEncodeParam p = encoder.getDefaultJPEGEncodeParam(currentImage);
                    p.setQuality(this.quality[0], true);
                    encoder.setJPEGEncodeParam(p);
                    encoder.encode(currentImage);
                } else {
                    ByteArrayOutputStream bstream = new ByteArrayOutputStream();
                    JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(bstream);
                    JPEGEncodeParam p = encoder.getDefaultJPEGEncodeParam(currentImage);
                    p.setQuality(this.quality[0], true);
                    encoder.setJPEGEncodeParam(p);
                    encoder.encode(currentImage);
                    out.write(bstream.toByteArray());
                }

                out.flush();
            } catch (ImageFormatException e) {
                throw new ProcessingException("Error reading the image. " +
                                              "Note that only JPEG images are currently supported.");
            } finally {
              // Bugzilla Bug 25069, close inputStream in finally block
              // this will close inputStream even if processStream throws
              // an exception
              inputStream.close();
            }
        } else {
            // only read the resource - no modifications requested
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("passing original resource");
            }
            super.processStream(inputStream);
        }
    }
15346#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     *
     * @return The generated key consists of the src and width and height,
     *         and the color transform parameters
    */
    public Serializable getKey() {
        return super.getKey().toString()
                + ':' + this.fitUniform
                + ':' + this.enlarge
                + ':' + this.width
                + ':' + this.height
                + ":" + this.scaleColor[0]
                + ":" + this.scaleColor[1]
                + ":" + this.scaleColor[2]
                + ":" + this.offsetColor[0]
                + ":" + this.offsetColor[1]
                + ":" + this.offsetColor[2]
                + ":" + this.quality[0]
                + ":" + (this.grayscaleFilter == null ? "color" : "bw");
    }
15347#public void recycle(){
        super.recycle();
        this.colorFilter = null;
        this.grayscaleFilter = null;
    }
15348#/**
     * @param bufferSize
     */
    public void setBufferSize(int bufferSize) {
        this.configuredBufferSize = bufferSize;
    }
15349#/**
     * This parameter is optional. This boolean parameter controls whether
     * Cocoon should support byterange requests (to allow clients to resume
     * broken/interrupted downloads).
     * Defaults to true.
     *
     * @param byteRanges
     */
    public void setByteRanges(boolean byteRanges) {
        this.configuredByteRanges = byteRanges;
    }
15350#/**
     * This parameter is optional. When specified it determines how long
     * in miliseconds the resources can be cached by any proxy or browser
     * between Cocoon and the requesting visitor. Defaults to -1.
     *
     * @param expires
     */
    public void setExpires(long expires) {
        this.configuredExpires = expires;
    }
15351#/**
     * This parameter is optional. This boolean parameter controls the
     * last modified test. If set to true (default is false), only the
     * last modified of the current source is tested, but not if the
     * same source is used as last time
     * (see http://marc.theaimsgroup.com/?l=xml-cocoon-dev&m=102921894301915 )
     *
     * @param quickTest
     */
    public void setQuickTest(boolean quickTest) {
        this.configuredQuickTest = quickTest;
    }
15352#/**
     * Read reader configuration
     *
     * @deprecated use property injection instead
     */
    public void configure(Configuration configuration) throws ConfigurationException {
        // VG Parameters are deprecated as of 2.2.0-Dev/2.1.6-Dev
        final Parameters parameters = Parameters.fromConfiguration(configuration);
        this.setExpires(parameters.getParameterAsLong("expires", CONFIGURED_EXPIRES_DEFAULT));
        this.setQuickTest(parameters.getParameterAsBoolean("quick-modified-test", CONFIGURED_QUICK_TEST_DEFAULT));
        this.setBufferSize(parameters.getParameterAsInteger("buffer-size", CONFIGURED_BUFFER_SIZE_DEFAULT));
        this.setByteRanges(parameters.getParameterAsBoolean("byte-ranges", CONFIGURED_BYTE_RANGES_DEFAULT));

        // Configuration has precedence over parameters.
        setExpires(configuration.getChild("expires").getValueAsLong(configuredExpires));
        setQuickTest(configuration.getChild("quick-modified-test").getValueAsBoolean(configuredQuickTest));
        setBufferSize(configuration.getChild("buffer-size").getValueAsInteger(configuredBufferSize));
        setByteRanges(configuration.getChild("byte-ranges").getValueAsBoolean(configuredByteRanges));
    }
15353#/**
     * Setup the reader.
     * The resource is opened to get an <code>InputStream</code>,
     * the length and the last modification date
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        super.setup(resolver, objectModel, src, par);

        this.request = ObjectModelHelper.getRequest(objectModel);
        this.response = ObjectModelHelper.getResponse(objectModel);

        this.expires = par.getParameterAsLong("expires", this.configuredExpires);
        this.quickTest = par.getParameterAsBoolean("quick-modified-test", this.configuredQuickTest);
        this.bufferSize = par.getParameterAsInteger("buffer-size", this.configuredBufferSize);
        this.byteRanges = par.getParameterAsBoolean("byte-ranges", this.configuredByteRanges);

        try {
            this.inputSource = resolver.resolveURI(src);
        } catch (SourceException e) {
            throw SourceUtil.handle("Error during resolving of '" + src + "'.", e);
        }

        setupHeaders();
    }
15354#/**
     * Setup the response headers: Accept-Ranges, Expires, Last-Modified
     */
    protected void setupHeaders() {
        // Tell the client whether we support byte range requests or not
        if (byteRanges) {
            response.setHeader("Accept-Ranges", "bytes");
        } else {
            response.setHeader("Accept-Ranges", "none");
        }

        if (expires > 0) {
            response.setDateHeader("Expires", System.currentTimeMillis() + expires);
        } else if (expires == 0) {
            response.setDateHeader("Expires", 0);
        }

        long lastModified = getLastModified();
        if (lastModified > 0) {
            response.setDateHeader("Last-Modified", lastModified);
        }
    }
15355#/**
     * Recyclable
     */
    public void recycle() {
        this.request = null;
        this.response = null;
        if (this.inputSource != null) {
            super.resolver.release(this.inputSource);
            this.inputSource = null;
        }
        super.recycle();
    }
15356#/**
     * @return True if byte ranges support is enabled and request has range header.
     */
    protected boolean hasRanges() {
        return this.byteRanges && this.request.getHeader("Range") != null;
    }
15357#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     *
     * @return The generated key hashes the src
     */
    public Serializable getKey() {
        return inputSource.getURI();
    }
15358#/**
     * Generate the validity object.
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity() {
        if (hasRanges()) {
            // This is a byte range request so we can't use the cache, return null.
            return null;
        } else {
            return inputSource.getValidity();
        }
    }
15359#/**
     * @return the time the read source was last modified or 0 if it is not
     *         possible to detect
     */
    public long getLastModified() {
        if (hasRanges()) {
            // This is a byte range request so we can't use the cache, return null.
            return 0;
        }

        if (quickTest) {
            return inputSource.getLastModified();
        }

        final String systemId = (String) documents.get(request.getRequestURI());
        // Note: getURI() might be null in some incomplete implementations
        final String sourceURI = inputSource.getURI();
        if (systemId == null || (sourceURI != null && sourceURI.equals(systemId))) {
            return inputSource.getLastModified();
        }

        documents.remove(request.getRequestURI());
        return 0;
    }
15360#protected void processStream(InputStream inputStream)
            throws IOException, ProcessingException {
        byte[] buffer = new byte[bufferSize];
        int length;

        String ranges = request.getHeader("Range");

        ByteRange byteRange;
        if (byteRanges && ranges != null) {
            try {
                ranges = ranges.substring(ranges.indexOf('=') + 1);
                byteRange = new ByteRange(ranges);
            } catch (NumberFormatException e) {
                byteRange = null;

                // TC: Hm.. why don't we have setStatus in the Response interface ?
                if (response instanceof HttpResponse) {
                    // Respond with status 416 (Request range not satisfiable)
                    response.setStatus(416);
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("malformed byte range header [" + String.valueOf(ranges) + "]");
                    }
                }
            }
        } else {
            byteRange = null;
        }

        long contentLength = inputSource.getContentLength();

        if (byteRange != null) {
            String entityLength;
            String entityRange;
            if (contentLength != -1) {
                entityLength = "" + contentLength;
                entityRange = byteRange.intersection(new ByteRange(0, contentLength)).toString();
            } else {
                entityLength = "*";
                entityRange = byteRange.toString();
            }

            response.setHeader("Content-Range", entityRange + "/" + entityLength);
            if (response instanceof HttpResponse) {
                // Response with status 206 (Partial content)
                response.setStatus(206);
            }

            int pos = 0;
            int posEnd;
            while ((length = inputStream.read(buffer)) > -1) {
                posEnd = pos + length - 1;
                ByteRange intersection = byteRange.intersection(new ByteRange(pos, posEnd));
                if (intersection != null) {
                    out.write(buffer, (int) intersection.getStart() - pos, (int) intersection.length());
                }
                pos += length;
            }
        } else {
            if (contentLength != -1) {
                response.setHeader("Content-Length", Long.toString(contentLength));
            }

            while ((length = inputStream.read(buffer)) > -1) {
                out.write(buffer, 0, length);
            }
        }

        out.flush();
    }
15361#/**
     * Generates the requested resource.
     */
    public void generate() throws IOException, ProcessingException {
        InputStream inputStream;
        try {
            inputStream = inputSource.getInputStream();
        } catch (SourceException e) {
            throw SourceUtil.handle(
                    "Error during resolving of the input stream", e);
        }

        // Bugzilla Bug #25069: Close inputStream in finally block.
        try {
            processStream(inputStream);
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
        }

        if (!quickTest) {
            // if everything is ok, add this to the list of generated documents
            // (see
            // http://marc.theaimsgroup.com/?l=xml-cocoon-dev&m=102921894301915
            // )
            documents.put(request.getRequestURI(), inputSource.getURI());
        }
    }
15362#/**
     * Returns the mime-type of the resource in process.
     */
    public String getMimeType() {
        Context ctx = ObjectModelHelper.getContext(objectModel);
        if (ctx != null) {
            final String mimeType = ctx.getMimeType(source);
            if (mimeType != null) {
                return mimeType;
            }
        }

        return inputSource.getMimeType();
    }
15363#/**
     * @see org.apache.avalon.framework.service.Serviceable#service(ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
        this.resolver = (SourceResolver)this.manager.lookup(SourceResolver.ROLE);
    }
15364#/**
     * Returns default mime type for zip archives, <code>application/zip</code>.
     * Can be overridden in the sitemap.
     * @return application/zip
     */
    public String getMimeType() {
        return "application/zip";
    }
15365#/**
     * @see org.xml.sax.ContentHandler#startDocument()
     */
    public void startDocument() throws SAXException {
        this.state = START_STATE;
        this.zipOutput = new ZipOutputStream(this.output);
    }
15366#/**
     * Begin the scope of a prefix-URI Namespace mapping.
     *
     * @param prefix The Namespace prefix being declared.
     * @param uri The Namespace URI the prefix is mapped to.
     */
    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        if (state == IN_CONTENT_STATE && this.contentDepth > 0) {
            // Pass to the serializer
            super.startPrefixMapping(prefix, uri);

        } else {
            // Register it if it's not our own namespace (useless to content)
            if (!uri.equals(ZIP_NAMESPACE)) {
                this.nsSupport.declarePrefix(prefix, uri);
            }
        }
    }
15367#public void endPrefixMapping(String prefix) throws SAXException {
        if (state == IN_CONTENT_STATE && this.contentDepth > 0) {
            // Pass to the serializer
            super.endPrefixMapping(prefix);
        }
    }
15368#// Note : no need to implement endPrefixMapping() as we just need to pass it through if there
    // is a serializer, which is what the superclass does.

    /**
     * @see org.xml.sax.ContentHandler#startElement(String, String, String, Attributes)
     */
    public void startElement(String namespaceURI, String localName, String qName, Attributes atts)
        throws SAXException {

        // Damage control. Sometimes one exception is just not enough...
        if (this.exception != null) {
            throw this.exception;
        }

        switch (state) {
            case START_STATE:
                // expecting "zip" as the first element
                if (namespaceURI.equals(ZIP_NAMESPACE) && localName.equals("archive")) {
                    this.nsSupport.pushContext();
                    this.state = IN_ZIP_STATE;
                } else {
                    throw this.exception =
                        new SAXException("Expecting 'archive' root element (got '" + localName + "')");
                }
                break;

            case IN_ZIP_STATE:
                // expecting "entry" element
                if (namespaceURI.equals(ZIP_NAMESPACE) && localName.equals("entry")) {
                    this.nsSupport.pushContext();
                    // Get the source
                    addEntry(atts);
                } else {
                    throw this.exception =
                        new SAXException("Expecting 'entry' element (got '" + localName + "')");
                }
                break;

            case IN_CONTENT_STATE:
                if (this.contentDepth == 0) {
                    // Give it any namespaces already declared
                    Enumeration prefixes = this.nsSupport.getPrefixes();
                    while (prefixes.hasMoreElements()) {
                        String prefix = (String) prefixes.nextElement();
                        super.startPrefixMapping(prefix, this.nsSupport.getURI(prefix));
                    }
                }

                this.contentDepth++;
                super.startElement(namespaceURI, localName, qName, atts);
                break;
        }
    }
15369#/**
     * @see org.xml.sax.ContentHandler#characters(char[], int, int)
     */
    public void characters(char[] buffer, int offset, int length) throws SAXException {
        // Propagate text to the serializer only if we have encountered the content's top-level
        // element. Otherwhise, the serializer may be confused by some characters occuring between
        // startDocument() and the first startElement() (e.g. Batik fails hard in that case)
        if (this.state == IN_CONTENT_STATE && this.contentDepth > 0) {
            super.characters(buffer, offset, length);
        }
    }
15370#/**
     * Add an entry in the archive.
     * @param atts the attributes that describe the entry
     */
    protected void addEntry(Attributes atts) throws SAXException {
        String name = atts.getValue("name");
        if (name == null) {
            throw this.exception =
                new SAXException("No name given to the Zip entry");
        }

        String src = atts.getValue("src");
        String serializerType = atts.getValue("serializer");

        if (src == null && serializerType == null) {
            throw this.exception =
                new SAXException("No source nor serializer given for the Zip entry '" + name + "'");
        }

        if (src != null && serializerType != null) {
            throw this.exception =
                new SAXException("Cannot specify both 'src' and 'serializer' on a Zip entry '" + name + "'");
        }

        Source source = null;
        try {
            if (src != null) {
                // Get the source and its data
                source = resolver.resolveURI(src);
                InputStream sourceInput = source.getInputStream();

                // Create a new Zip entry with file modification time.
                ZipEntry entry = new ZipEntry(name);
                long lastModified = source.getLastModified();
                if (lastModified != 0)
                	entry.setTime(lastModified);
                this.zipOutput.putNextEntry(entry);
                
                // Buffer lazily allocated
                if (this.buffer == null)
                    this.buffer = new byte[8192];

                // Copy the source to the zip
                int len;
                while ((len = sourceInput.read(this.buffer)) > 0) {
                    this.zipOutput.write(this.buffer, 0, len);
                }

                // and close the entry
                this.zipOutput.closeEntry();
                // close input stream (to avoid "too many open files" problem)
                sourceInput.close();
            } else {
                // Create a new Zip entry with current time.
                ZipEntry entry = new ZipEntry(name);
                this.zipOutput.putNextEntry(entry);

                // Serialize content
                if (this.selector == null) {
                    this.selector =
                        (ServiceSelector) this.manager.lookup(Serializer.ROLE + "Selector");
                }

                // Get the serializer
                this.serializer = (Serializer) this.selector.select(serializerType);

                // Direct its output to the zip file, filtering calls to close()
                // (we don't want the archive to be closed by the serializer)
                this.serializer.setOutputStream(new FilterOutputStream(this.zipOutput) {
                    public void close() { /* nothing */ }
                });

                // Set it as the current XMLConsumer
                setConsumer(serializer);

                // start its document
                this.serializer.startDocument();

                this.state = IN_CONTENT_STATE;
                this.contentDepth = 0;
            }

        } catch (RuntimeException re) {
            throw re;
        } catch (SAXException se) {
            throw this.exception = se;
        } catch (Exception e) {
            throw this.exception = new SAXException(e);
        } finally {
            this.resolver.release( source );
        }
    }
15371#/**
     * @see org.xml.sax.ContentHandler#endElement(String, String, String)
     */
    public void endElement(String namespaceURI, String localName, String qName)
        throws SAXException {

        // Damage control. Sometimes one exception is just not enough...
        if (this.exception != null) {
            throw this.exception;
        }

        if (state == IN_CONTENT_STATE) {
            super.endElement(namespaceURI, localName, qName);
            this.contentDepth--;

            if (this.contentDepth == 0) {
                // End of this entry

                // close all declared namespaces.
                Enumeration prefixes = this.nsSupport.getPrefixes();
                while (prefixes.hasMoreElements()) {
                    String prefix = (String) prefixes.nextElement();
                    super.endPrefixMapping(prefix);
                }

                super.endDocument();

                try {
                    this.zipOutput.closeEntry();
                } catch (IOException ioe) {
                    throw this.exception = new SAXException(ioe);
                }

                super.setConsumer(null);
                this.selector.release(this.serializer);
                this.serializer = null;

                // Go back to listening for entries
                this.state = IN_ZIP_STATE;
            }
        } else {
            this.nsSupport.popContext();
        }
    }
15372#/**
     * @see org.xml.sax.ContentHandler#endDocument()
     */
    public void endDocument() throws SAXException {
        try {
            // Close the zip archive
            this.zipOutput.finish();

        } catch (IOException ioe) {
            throw new SAXException(ioe);
        }
    }
15373#/**
     * @see org.apache.avalon.excalibur.pool.Recyclable#recycle()
     */
    public void recycle() {
        this.exception = null;
        if (this.serializer != null) {
            this.selector.release(this.serializer);
        }
        if (this.selector != null) {
            this.manager.release(this.selector);
        }

        this.nsSupport.reset();
        super.recycle();
    }
15374#/* (non-Javadoc)
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        if (this.manager != null) {
            this.manager.release(this.resolver);
            this.resolver = null;
            this.manager = null;
        }
    }
15375#/**
     * Set the {@link OutputStream} where the requested resource should
     * be serialized.
     */
    public void setOutputStream(OutputStream out) throws IOException {
        this.out = new PrintStream(out);
    }
15376#/**
     * Get the mime-type of the output of this <code>Component</code>.
     */
    public String getMimeType() {
        return Constants.LINK_CONTENT_TYPE;
    }
15377#public void simpleLink(String href, String role, String arcrole, String title, String show, String actuate, String uri, String name, String raw, Attributes attr)
    throws SAXException {
        if (traversable(href)) {
            print(href);
        }
        super.simpleLink(href, role, arcrole, title, show, actuate, uri, name, raw, attr);
    }
15378#public void startLocator(String href, String role, String title, String label, String uri, String name, String raw, Attributes attr)
    throws SAXException {
        if (traversable(href)) {
            print(href);
        }
        super.startLocator(href, role, title, label, uri, name, raw, attr);
    }
15379#private boolean traversable(String href) {
        if (href.length() == 0) return false;
        if (href.charAt(0) == '#') return false;
        if (href.indexOf("://") != -1) return false;
        if (href.startsWith("mailto:")) return false;
        if (href.startsWith("news:")) return false;
        if (href.startsWith("javascript:")) return false;
        return true;
    }
15380#private void print(String href) {
        int ankerPos = href.indexOf('#');
        if (ankerPos == -1) {
            // TODO: Xalan encodes international characters into URL encoding
            out.println(href);
        } else {
            out.println(href.substring(0, ankerPos));
        }
    }
15381#/**
     * Test if the component wants to set the content length
     */
    public boolean shouldSetContentLength() {
        return false;
    }
15382#/**
     * Recyclable
     */
    public void recycle() {
        super.recycle();
        this.out = null;
    }
15383#/* (non-Javadoc)
     * @see org.apache.cocoon.serialization.AbstractTextSerializer#init()
     */
    public void init() throws Exception {
        super.init();
        this.format.put(OutputKeys.METHOD,"xml");
    }
15384#/**
     * Set the configurations for this serializer.
     */
    public void configure(Configuration conf)
    throws ConfigurationException {
        super.configure( conf );
        this.format.put(OutputKeys.METHOD,"xml");
    }
15385#/**
     * Set the {@link OutputStream} where the requested resource should
     * be serialized.
     */
    public void setOutputStream(OutputStream out) throws IOException {
        super.setOutputStream(out);
        try {
            TransformerHandler handler = this.getTransformerHandler();
            handler.getTransformer().setOutputProperties(this.format);
            handler.setResult(new StreamResult(this.output));
            this.setContentHandler(handler);
            this.setLexicalHandler(handler);
        } catch (Exception e) {
            final String message = "Cannot set XMLSerializer outputstream"; 
            throw new CascadingIOException(message, e);
        }
    }
15386#/* (non-Javadoc)
     * @see org.apache.cocoon.serialization.AbstractTextSerializer#init()
     */
    public void init() throws Exception {
        super.init();
        this.format.put(OutputKeys.METHOD,"html");        
    }
15387#/**
     * Set the configurations for this serializer.
     */
    public void configure(Configuration conf)
    throws ConfigurationException {
        super.configure(conf);
        this.format.put(OutputKeys.METHOD,"html");
    }
15388#/**
     * Set the {@link OutputStream} where the requested resource should
     * be serialized.
     */
    public void setOutputStream(OutputStream out) 
    throws IOException {
        super.setOutputStream(out);
        try {
            TransformerHandler handler = this.getTransformerHandler();
            handler.getTransformer().setOutputProperties(this.format);
            handler.setResult(new StreamResult(this.output));
            this.setContentHandler(handler);
            this.setLexicalHandler(handler);
        } catch (Exception e) {
            final String message = "Cannot set HTMLSerializer outputstream"; 
            throw new CascadingIOException(message, e);
        }
    }
15389#/* (non-Javadoc)
     * @see org.apache.cocoon.serialization.AbstractTextSerializer#init()
     */
    public void init() throws Exception {
        super.init();
        this.format.put(OutputKeys.METHOD, "text");
    }
15390#/**
     * Set the configurations for this serializer.
     */
    public void configure(Configuration conf) throws ConfigurationException {
        super.configure(conf);
        this.format.put(OutputKeys.METHOD, "text");
    }
15391#/**
     * Set the {@link OutputStream} where the requested resource should
     * be serialized.
     */
    public void setOutputStream(OutputStream out) throws IOException {
        super.setOutputStream(out);
        try {
            TransformerHandler handler = this.getTransformerHandler();
            handler.getTransformer().setOutputProperties(format);
            handler.setResult(new StreamResult(this.output));
            this.setContentHandler(handler);
            this.setLexicalHandler(handler);
       } catch (Exception e) {
            final String message = "Cannot set TextSerializer outputstream";
            throw new CascadingIOException(message, e);
        }
    }
15392#public void startElement(String uri, String loc, String raw, Attributes a)
    throws SAXException {
        this.hasRootElement = true;
        super.startElement(uri, loc, raw, a);
    }
15393#public void characters(char c[], int start, int len)
    throws SAXException {
        if (!this.hasRootElement) {
            this.hasRootElement = this.hadNoRootElement = true;
            getLogger().warn("Encountered text before root element. Creating <text> wrapper element.");
            super.startElement("", "text", "text", XMLUtils.EMPTY_ATTRIBUTES);
        }
        super.characters(c, start, len);
    }
15394#public void endDocument() throws SAXException {
        if (this.hadNoRootElement) {
            super.endElement("", "text", "text");
        }
        super.endDocument();
    }
15395#public void recycle() {
        super.recycle();
        this.hasRootElement = false;
        this.hadNoRootElement = false;
    }
15396#public void setup(SourceResolver resolver,
                      Map objectModel,
                      String source,
                      Parameters parameters)
    throws ProcessingException, SAXException, IOException {
        this.objectModel = objectModel;
        this.request = ObjectModelHelper.getRequest( this.objectModel );

        String mountPoint = parameters.getParameter("mount", null);

        StringBuffer uribuf = new StringBuffer();
        boolean isSecure = this.request.isSecure();
        int port = this.request.getServerPort();

        if (isSecure) {
            uribuf.append("https://");
        } else {
            uribuf.append("http://");
        }
        uribuf.append(request.getServerName());

        if (isSecure) {
            if (port != 443) {
                uribuf.append(":").append(port);
            }
        } else {
            if (port != 80) {
                uribuf.append(":").append(port);
            }
        }
        if (mountPoint == null) {
            String requestedURI = this.request.getRequestURI();
            requestedURI = requestedURI.substring(0, requestedURI.lastIndexOf("/"));
            uribuf.append(requestedURI);
            uribuf.append("/");
        } else {
            uribuf.append(request.getContextPath());
            uribuf.append("/");
            uribuf.append(mountPoint);
        }
        this.baseURI = uribuf.toString();

        augmentedAttributes = new HashSet();
        myAugmentedAttributes(parameters);

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("List of attributes to augment: " + augmentedAttributes);
        }
    }
15397#public void startElement(String uri,
                             String name,
                             String qname,
                             Attributes attrs)
    throws SAXException {
        AttributesImpl newAttrs = null;

        for (int i = 0, size = attrs.getLength(); i < size; i++) {
            String attrName = attrs.getLocalName(i);
            if (augmentedAttributes.contains(attrName)) {
                String value = attrs.getValue(i);

                // Don't touch the attribute if it's an absolute URL
                if (value.startsWith("http:") || value.startsWith("https:")) {
                    continue;
                }

                if (newAttrs == null) {
                    newAttrs = new AttributesImpl(attrs);
                }

                String newValue = baseURI + value;
                newAttrs.setValue(i, newValue);
            }
        }

        if (newAttrs == null) {
            super.startElement(uri, name, qname, attrs);
        } else {
            super.startElement(uri, name, qname, newAttrs);
        }
    }
15398#/**
     * Recyclable
     */
    public void recycle() {
        this.objectModel = null;
        this.request = null;
        this.baseURI = null;
        super.recycle();
    }
15399#/**
     * Parses list of attributes names in form of <code>attr1 attr2 attr3</code>
     * and adds them to <code>augmentedAttributes</code>.
     * @param parameters
     */
    private void myAugmentedAttributes(Parameters parameters) {
        String augmentedAttributesStr = parameters.getParameter(AUGMENTED_ATTRIBUTES, "href");
        if (augmentedAttributesStr != null) {
            StringTokenizer t = new StringTokenizer(augmentedAttributesStr," \t\r\n\f,:");
            while ( t.hasMoreTokens()) {
                String attr = t.nextToken();
                attr = attr.trim();
                if ( attr.length() > 0){
                    augmentedAttributes.add(attr);
                }
            }
        }
    }
15400#public final void setup(SourceResolver resolver, Map objectModel, String src, Parameters params)
    throws ProcessingException, SAXException, IOException {
        this.request = ObjectModelHelper.getRequest(objectModel);
        this.skipCounter = 0;
    }
15401#/**
     * Disable caching
     */
    public java.io.Serializable getKey() {
        return null;
    }
15402#public final void startElement(String uri, String loc, String raw, Attributes a)
    throws SAXException {
        if (this.skipCounter > 0) {
            this.skipCounter++;
        } else {
            int roleIndex = a.getIndex(RoleFilterTransformer.URI, RoleFilterTransformer.RESTRICT);
            int viewIndex = a.getIndex(RoleFilterTransformer.URI, RoleFilterTransformer.VIEW);
            boolean propogate = true;
            boolean readOnly = false;

            if (roleIndex >= 0) {
                String roleRestriction = a.getValue(roleIndex);
                StringTokenizer roles = new StringTokenizer(roleRestriction, ",", false);
                propogate = false;

                while ((! propogate) && roles.hasMoreTokens()) {
                    if (request.isUserInRole(roles.nextToken())) {
                        propogate = true;
                    }
                }
            }

            if (propogate) {
                if (viewIndex >= 0) {
                    String viewRestriction = a.getValue(viewIndex);
                    StringTokenizer roles = new StringTokenizer(viewRestriction, ",", false);

                    while ((! readOnly) && roles.hasMoreTokens()) {
                        if (request.isUserInRole(roles.nextToken())) {
                            readOnly = true;
                        }
                    }
                }
                super.startElement(uri, loc, raw,
                        this.copyAttributes(a, roleIndex, viewIndex, readOnly));
            } else {
                this.skipCounter = 1;
            }
        }
    }
15403#public final void endElement(String uri, String loc, String raw)
    throws SAXException {
        if (skipCounter > 0) {
            skipCounter--; 
        } else {
            super.endElement(uri, loc, raw);
        }
    }
15404#private Attributes copyAttributes(final Attributes a, final int role,
                                      final int view, boolean readOnly) {
        if (role < 0 && view < 0) {
            return a;
        }

        AttributesImpl attr = new AttributesImpl();
        attr.setAttributes(a);
        if (role >= 0) {
            attr.removeAttribute(role);
        }

        if (view >= 0) {
            if (readOnly) {
                attr.setValue(view, "");
            } else {
                attr.removeAttribute(view);
            }
        }

        return attr;
    }
15405#public void recycle() {
        this.request = null;
        super.recycle();
    }
15406#public void startEntity(String name) throws SAXException {
        if (this.skipCounter == 0)  {
            super.startEntity(name);
        }
    }
15407#public void endEntity(String name) throws SAXException {
        if (this.skipCounter == 0)  {
            super.endEntity(name);
        }
    }
15408#public void comment(char[] ch, int start, int len) throws SAXException {
        if (this.skipCounter == 0)  {
            super.comment(ch, start, len);
        }
    }
15409#public void characters(char[] c, int start, int len) throws SAXException {
        if (this.skipCounter == 0)  {
            super.characters(c, start, len);
        }
    }
15410#public void startCDATA() throws SAXException {
        if (this.skipCounter == 0) {
            super.startCDATA();
        }
    }
15411#public void processingInstruction(String target, String data) throws SAXException {
        if (this.skipCounter == 0)  {
            super.processingInstruction(target, data);
        }
    }
15412#public SourceValidity getValidity() {
        return null;
    }
15413#public void endCDATA() throws SAXException {
        if (this.skipCounter == 0) {
            super.endCDATA();
        }
    }
15414#/**
     * Recyclable
     */
    public void recycle() {
        this.session = null;
        this.builder = null;
        this.buildDom = false;
        this.setup = false;
        super.recycle();
    }
15415#/* BEGIN SitemapComponent methods */

    public void setup(SourceResolver resolver, Map objectModel,
                      String source, Parameters parameters)
    throws ProcessingException, SAXException, IOException {
        getLogger().debug("WriteSessionTransformer: setup");
        Request request = ObjectModelHelper.getRequest(objectModel);
        session = request.getSession(false);
        if (session != null) {
            DOMName = parameters.getParameter(WriteDOMSessionTransformer.DOM_NAME, null);
            rootElement = parameters.getParameter(WriteDOMSessionTransformer.DOM_ROOT_ELEMENT, null);
            if (DOMName != null && rootElement != null) {
                // only now we know it is useful to store something in the session
                getLogger().debug("WriteSessionTransformer: " + WriteDOMSessionTransformer.DOM_NAME + "=" +
                                  DOMName + "; " + WriteDOMSessionTransformer.DOM_ROOT_ELEMENT + "=" +
                                  rootElement);
                setup = true;
                storedPrefixMap = new HashMap();
            } else {
                getLogger().error("WriteSessionTransformer: need " + WriteDOMSessionTransformer.DOM_NAME +
                                  " and " + WriteDOMSessionTransformer.DOM_ROOT_ELEMENT + " parameters");
            }
        } else {
            getLogger().error("WriteSessionTransformer: no session object");
        }
    }
15416#/* END SitemapComponent methods */

    /* BEGIN SAX ContentHandler handlers */

    public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
        super.startPrefixMapping(prefix, uri);
        if (buildDom) {
            builder.startPrefixMapping(prefix, uri);
        } else if (setup) {
            storePrefixMapping(prefix, uri);
        }
    }
15417#public void startElement(String uri, String name, String raw, Attributes attributes)
    throws SAXException {
        // only build the DOM tree if session is available
        if (setup && name.equalsIgnoreCase(rootElement)) {
            getLogger().debug("WriteSessionTransformer: start building DOM tree");
            buildDom = true;
            builder = new DOMBuilder();
            builder.startDocument();
            launchStoredMappings();
            builder.startElement(uri, name, raw, attributes);
        } else if (buildDom) {
            builder.startElement(uri, name, raw, attributes);
        }
        super.contentHandler.startElement(uri, name, raw, attributes);
    }
15418#public void endElement(String uri, String name, String raw)
            throws SAXException {
        if (setup && name.equalsIgnoreCase(rootElement)) {
            buildDom = false;
            builder.endElement(uri, name, raw);
            builder.endDocument();
            getLogger().debug("WriteSessionTransformer: putting DOM tree in session object");
            session.setAttribute(DOMName, builder.getDocument().getFirstChild());
            getLogger().debug("WriteSessionTransformer: DOM tree is in session object");
        } else if (buildDom) {
            builder.endElement(uri, name, raw);
        }
        super.contentHandler.endElement(uri, name, raw);
    }
15419#public void characters(char c[], int start, int len) throws SAXException {
        if (buildDom) {
            builder.characters(c, start, len);
        }
        super.contentHandler.characters(c, start, len);
    }
15420#public void startCDATA() throws SAXException {
        if (buildDom) {
            builder.startCDATA();
        }
        super.lexicalHandler.startCDATA();
    }
15421#public void endCDATA() throws SAXException {
        if (buildDom) {
            builder.endCDATA();
        }
        super.lexicalHandler.endCDATA();
    }
15422#/* END SAX ContentHandler handlers */

    protected void storePrefixMapping(String prefix, String uri) {
        storedPrefixMap.put(prefix, uri);
    }
15423#protected void launchStoredMappings() throws SAXException {
        Iterator it = storedPrefixMap.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            String pre = (String) entry.getKey();
            String uri = (String) entry.getValue();
            getLogger().debug("WriteSessionTransformer: launching prefix mapping[ pre: " + pre + " uri: " + uri + " ]");
            builder.startPrefixMapping(pre, uri);
        }
    }
15424#/*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.sitemap.SitemapModelComponent#setup(org.apache.cocoon.environment.SourceResolver,
     *      java.util.Map, java.lang.String,
     *      org.apache.avalon.framework.parameters.Parameters)
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters parameters)
        throws ProcessingException, SAXException, IOException {

        super.setup(resolver, objectModel, src, parameters);

        Source source = null;
        try {
            this.resolver = resolver;
            source = this.resolver.resolveURI(src);
            String systemId = source.getURI();
            if (!(source instanceof ModifiableSource)) {
                throw new ProcessingException("Source '" + systemId + "' is not writeable.");
            }
            if (this.osCommand != null) {
                // FileSource is the only option when using the system command feature
                fileName = ((FileSource)source).getFile().getAbsolutePath();
            }
            this.serializer = this.transformerFactory.newTransformerHandler();
            os = ((ModifiableSource) source).getOutputStream();

            this.serializer.setResult(new StreamResult(os));
        } catch (SourceException e) {
            throw SourceUtil.handle(e);
        } catch (TransformerConfigurationException e) {
            throw new ProcessingException(e);
        } catch (TransformerFactoryConfigurationError error) {
            throw new ProcessingException(error.getException());
        } finally {
            if (source != null) {
                this.resolver.release(source);
            }
        }
    }
15425#/*
     * (non-Javadoc)
     * 
     * @see org.apache.avalon.framework.configuration.Configurable#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration configuration) throws ConfigurationException {
        String tFactoryClass = configuration.getChild("transformer-factory").getValue(null);
        this.osCommand = configuration.getChild("command").getValue(null);
        if (tFactoryClass != null) {
            try {
                this.transformerFactory = (SAXTransformerFactory) ClassUtils
                    .newInstance(tFactoryClass);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Using transformer factory " + tFactoryClass);
                }
            } catch (Exception e) {
                throw new ConfigurationException(
                    "Cannot load transformer factory " + tFactoryClass, e);
            }
        } else {
            this.transformerFactory = (SAXTransformerFactory) TransformerFactory.newInstance();

        }
    }
15426#/**
     * Receive an object for locating the origin of SAX document events.
     */
    public void setDocumentLocator(Locator locator) {
        super.contentHandler.setDocumentLocator(locator);
        this.serializer.setDocumentLocator(locator);
    }
15427#/**
     * Receive notification of the beginning of a document.
     */
    public void startDocument() throws SAXException {
        super.contentHandler.startDocument();
        this.serializer.startDocument();
    }
15428#/**
     * Receive notification of the end of a document.
     * Optionally execute a command to view the output file
     */
    public void endDocument() throws SAXException {
        super.contentHandler.endDocument();
        this.serializer.endDocument();
        if (os != null) {
            try {
                os.close();

                if (this.osCommand != null) {
                    String command = this.osCommand.replaceAll("%s", this.fileName);
                    try {
                        (Runtime.getRuntime()).exec(command,null);
                    } catch(Exception e) {
                        throw new CascadingRuntimeException("Unable to lauch the specified program : "+command, e);
                    }
                }
            } catch (IOException e) {
                throw new CascadingRuntimeException("Error closing output stream.", e);
            }
        }
    }
15429#/**
     * Begin the scope of a prefix-URI Namespace mapping.
     */
    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        super.contentHandler.startPrefixMapping(prefix, uri);
        this.serializer.startPrefixMapping(prefix, uri);
    }
15430#/**
     * End the scope of a prefix-URI mapping.
     */
    public void endPrefixMapping(String prefix) throws SAXException {
        super.contentHandler.endPrefixMapping(prefix);
        this.serializer.endPrefixMapping(prefix);
    }
15431#/**
     * Receive notification of the beginning of an element.
     */
    public void startElement(String uri, String loc, String raw, Attributes a) throws SAXException {
        super.contentHandler.startElement(uri, loc, raw, a);
        this.serializer.startElement(uri, loc, raw, a);
    }
15432#/**
     * Receive notification of the end of an element.
     */
    public void endElement(String uri, String loc, String raw) throws SAXException {
        super.contentHandler.endElement(uri, loc, raw);
        this.serializer.endElement(uri, loc, raw);
    }
15433#/**
     * Receive notification of character data.
     */
    public void characters(char ch[], int start, int len) throws SAXException {
        super.contentHandler.characters(ch, start, len);
        this.serializer.characters(ch, start, len);
    }
15434#/**
     * Receive notification of ignorable whitespace in element content.
     */
    public void ignorableWhitespace(char ch[], int start, int len) throws SAXException {
        super.contentHandler.ignorableWhitespace(ch, start, len);
        this.serializer.ignorableWhitespace(ch, start, len);
    }
15435#/**
     * Receive notification of a processing instruction.
     */
    public void processingInstruction(String target, String data) throws SAXException {
        super.contentHandler.processingInstruction(target, data);
        this.serializer.processingInstruction(target, data);
    }
15436#/**
     * Receive notification of a skipped entity.
     */
    public void skippedEntity(String name) throws SAXException {
        super.contentHandler.skippedEntity(name);
        this.serializer.skippedEntity(name);
    }
15437#/**
     * Report the start of DTD declarations, if any.
     */
    public void startDTD(String name, String publicId, String systemId) throws SAXException {
        super.lexicalHandler.startDTD(name, publicId, systemId);
        this.serializer.startDTD(name, publicId, systemId);
    }
15438#/**
     * Report the end of DTD declarations.
     */
    public void endDTD() throws SAXException {
        super.lexicalHandler.endDTD();
        this.serializer.endDTD();
    }
15439#/**
     * Report the beginning of an entity.
     */
    public void startEntity(String name) throws SAXException {
        super.lexicalHandler.startEntity(name);
        this.serializer.startEntity(name);
    }
15440#/**
     * Report the end of an entity.
     */
    public void endEntity(String name) throws SAXException {
        super.lexicalHandler.endEntity(name);
        this.serializer.endEntity(name);
    }
15441#/**
     * Report the start of a CDATA section.
     */
    public void startCDATA() throws SAXException {
        super.lexicalHandler.startCDATA();
        this.serializer.startCDATA();
    }
15442#/**
     * Report the end of a CDATA section.
     */
    public void endCDATA() throws SAXException {
        super.lexicalHandler.endCDATA();
        this.serializer.endCDATA();
    }
15443#/**
     * Report an XML comment anywhere in the document.
     */
    public void comment(char ch[], int start, int len) throws SAXException {
        super.lexicalHandler.comment(ch, start, len);
        this.serializer.comment(ch, start, len);
    }
15444#/*
     * (non-Javadoc)
     * 
     * @see org.apache.avalon.excalibur.pool.Recyclable#recycle()
     */
    public void recycle() {
        super.recycle();
        this.serializer = null;
    }
15445#/**
     * Constructor. Set the namespace.
     */
    public SourceWritingTransformer() {
        super.defaultNamespaceURI = SWT_URI;
    }
15446#/**
     * Get the current <code>Configuration</code> instance used by this
     * <code>Configurable</code>.
     */
    public void configure(Configuration configuration)
    throws ConfigurationException {
        super.configure(configuration);
        this.configuredSerializerName = configuration.getChild(SERIALIZER_ATTRIBUTE).getValue(DEFAULT_SERIALIZER);
    }
15447#/**
     * Get the <code>Parameter</code> called "serializer" from the
     * <code>Transformer</code> invocation.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        super.setup(resolver, objectModel, src, par);

        this.configuredSerializerName = par.getParameter(SERIALIZER_ATTRIBUTE,
                                                         this.configuredSerializerName);
        this.state = STATE_OUTSIDE;
    }
15448#/**
     * Receive notification of the beginning of an element.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param name The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     * @param attr The attributes attached to the element. If there are no
     *            attributes, it shall be an empty Attributes object.
     */
    public void startTransformingElement(String uri, String name, String raw, Attributes attr)
    throws SAXException, IOException, ProcessingException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Start transforming element. uri=" + uri +
                              ", name=" + name + ", raw=" + raw + ", attr=" + attr);
        }

        // Element: insert
        if (this.state == STATE_OUTSIDE
            && (name.equals(INSERT_ELEMENT) || name.equals(WRITE_ELEMENT))) {

            this.state = (name.equals(INSERT_ELEMENT) ? STATE_INSERT : STATE_WRITE);
            this.parent_state = this.state;
            if (attr.getValue(CREATE_ATTRIBUTE) != null
                && attr.getValue(CREATE_ATTRIBUTE).equals("false")) {
                this.stack.push("false");
            } else {
                this.stack.push("true"); // default value
            }
            if (attr.getValue(OVERWRITE_ATTRIBUTE) != null
                && attr.getValue(OVERWRITE_ATTRIBUTE).equals("false")) {
                this.stack.push("false");
            } else {
                this.stack.push("true"); // default value
            }
            this.stack.push(attr.getValue(SERIALIZER_ATTRIBUTE));
            this.stack.push("END");

        // Element: delete
        } else if (this.state == STATE_OUTSIDE && name.equals(DELETE_ELEMENT)) {
            this.state = STATE_DELETE;
            this.parent_state = state;
            this.stack.push("END");
        // Element: file
        } else if (name.equals(SOURCE_ELEMENT)
                   && (this.state == STATE_INSERT || this.state == STATE_WRITE || this.state == STATE_DELETE)) {
            this.state = STATE_FILE;
            this.startTextRecording();

        // Element: path
        } else if (name.equals(PATH_ELEMENT)
                   && (this.state == STATE_INSERT || this.state == STATE_WRITE || this.state == STATE_DELETE)) {
            this.state = STATE_PATH;
            this.startTextRecording();

        // Element: replace
        } else if (name.equals(REPLACE_ELEMENT)
                   && this.state == STATE_INSERT) {
            this.state = STATE_REPLACE;
            this.startTextRecording();

        // Element: fragment
        } else if (name.equals(FRAGMENT_ELEMENT)
                   &&  (this.state == STATE_INSERT || this.state == STATE_WRITE || this.state == STATE_DELETE)) {
            this.state = STATE_FRAGMENT;
            this.startRecording();

        // Element: reinsert
        } else if (name.equals(REINSERT_ELEMENT)
                   && this.state == STATE_INSERT) {
            this.state = STATE_REINSERT;
            this.startTextRecording();

        } else {
            super.startTransformingElement(uri, name, raw, attr);
        }
    }
15449#/**
     * Receive notification of the end of an element.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param name The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     */
    public void endTransformingElement(String uri, String name, String raw)
    throws SAXException, IOException, ProcessingException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("End transforming element. uri=" + uri +
                              ", name=" + name + ", raw=" + raw);
        }

        if ((name.equals(INSERT_ELEMENT) && this.state == STATE_INSERT)
            || (name.equals(WRITE_ELEMENT) && this.state == STATE_WRITE)) {

            // get the information from the stack
            DocumentFragment fragment  = null;
            String tag;
            String sourceName    = null;
            String path        = (this.state == STATE_INSERT ? null : "/");
                                 // source:write's path can be empty
            String replacePath = null;
            String reinsert    = null;
            do {
                tag = (String)this.stack.pop();
                if (tag.equals("PATH")) {
                    path = (String)this.stack.pop();
                } else if (tag.equals("FILE")) {
                    sourceName = (String)this.stack.pop();
                } else if (tag.equals("FRAGMENT")) {
                    fragment = (DocumentFragment)this.stack.pop();
                } else if (tag.equals("REPLACE")) {
                    replacePath = (String)this.stack.pop();
                } else if (tag.equals("REINSERT")) {
                    reinsert = (String)this.stack.pop();
                }
            } while ( !tag.equals("END") );

            final String localSerializer = (String)this.stack.pop();
            final boolean overwrite = this.stack.pop().equals("true");
            final boolean create = this.stack.pop().equals("true");

            this.insertFragment(sourceName,
                                    path,
                                    fragment,
                                    replacePath,
                                    create,
                                    overwrite,
                                    reinsert,
                                    localSerializer,
                                    name);

            this.state = STATE_OUTSIDE;

        // Element: delete
        } else if (name.equals(DELETE_ELEMENT) && this.state == STATE_DELETE) {
            String sourceName = null;
            String tag;
            do {
                tag = (String)this.stack.pop();
                if (tag.equals("FILE")) {
                    sourceName = (String)this.stack.pop();
                } else if (tag.equals("FRAGMENT")) {
                    //Get rid of it
                    this.stack.pop();
                }
            } while ( !tag.equals("END"));

            this.deleteSource(sourceName);
            this.state = STATE_OUTSIDE;
        // Element: file
        } else if (name.equals(SOURCE_ELEMENT) && this.state == STATE_FILE) {
            this.state = this.parent_state;
            this.stack.push(this.endTextRecording());
            this.stack.push("FILE");

        // Element: path
        } else if (name.equals(PATH_ELEMENT) && this.state == STATE_PATH) {
            this.state = this.parent_state;
            this.stack.push(this.endTextRecording());
            this.stack.push("PATH");

        // Element: replace
        } else if (name.equals(REPLACE_ELEMENT) && this.state == STATE_REPLACE) {
            this.state = this.parent_state;
            this.stack.push(this.endTextRecording());
            this.stack.push("REPLACE");

        // Element: fragment
        } else if (name.equals(FRAGMENT_ELEMENT) && this.state == STATE_FRAGMENT) {
            this.state = this.parent_state;
            this.stack.push(this.endRecording());
            this.stack.push("FRAGMENT");

        // Element: reinsert
        } else if (name.equals(REINSERT_ELEMENT) && this.state == STATE_REINSERT) {
            this.state = this.parent_state;
            this.stack.push(this.endTextRecording());
            this.stack.push("REINSERT");

        // default
        } else {
            super.endTransformingElement(uri, name, raw);
        }
    }
15450#/**
     * Deletes a source
     * @param systemID
     */
    private void deleteSource(String systemID) throws ProcessingException, IOException, SAXException {
        Source source = null;
        try {
            source = resolver.resolveURI(systemID);
            if (!(source instanceof ModifiableSource)) {
                throw new ProcessingException("Source '" + systemID + "' is not writeable.");
            }

            ((ModifiableSource)source).delete();
            reportResult("none",
                         "delete",
                         "source deleted successfully",
                         systemID,
                         RESULT_SUCCESS,
                         ACTION_DELETE);
        } catch (SourceException se) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("FAIL exception: " + se, se);
            }
            reportResult("none",
                         "delete",
                         "unable to delete source: " + se.getMessage(),
                         systemID,
                         RESULT_FAILED,
                         ACTION_DELETE);
        } finally {
            resolver.release(source);
        }
    }
15451#/**
     * Insert a fragment into a file.
     * The file is loaded by the resource connector.
     *
     * @param systemID The name of the xml file.
     * @param path   The XPath specifying the node under which the data is inserted
     * @param fragment The data to be inserted.
     * @param replacePath Optional XPath relative to <CODE>path</CODE>. This path
     *                    can specify a node which will be removed if it exists.
     *                    So insertFragment can be used as a replace utility.
     * @param create      If the file does not exists and this is set to
     *                    <CODE>false</CODE> nothing is inserted. If it is set
     *                    to <CODE>true</CODE> the file is created and the data
     *                    is inserted.
     * @param overwrite   If this is set to <CODE>true</CODE> the data is only
     *                    inserted if the node specified by the <CODE>replacePath</CODE>
     *                    does not exists.
     * @param reinsertPath If specified and a node is replaced , all children of
     *                     this replaced node will be reinserted at the given path.
     * @param localSerializer  The serializer used to serialize the XML
     * @param tagname     The name of the tag that triggered me 'insert' or 'write'
     */
    protected void insertFragment(String systemID,
                                  String path,
                                  DocumentFragment fragment,
                                  String replacePath,
                                  boolean create,
                                  boolean overwrite,
                                  String  reinsertPath,
                                  String  localSerializer,
                                  String  tagname)
    throws SAXException, IOException, ProcessingException {
        // no sync req
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Insert fragment. systemID=" + systemID +
                              ", path=" + path +
                              ", replace=" + replacePath +
                              ", create=" + create +
                              ", overwrite=" + overwrite +
                              ", reinsert=" + reinsertPath +
                              ", fragment=" + (fragment == null ? "null" : XMLUtils.serializeNode(fragment)));
        }

        // test parameter
        if (systemID == null) {
            throw new ProcessingException("insertFragment: systemID is required.");
        }
        if (path == null) {
            throw new ProcessingException("insertFragment: path is required.");
        }
        if (path.startsWith("/")) {
            path = path.substring(1);
        }
        if (fragment == null) {
            throw new ProcessingException("insertFragment: fragment is required.");
        }

        // first: read the source as a DOM
        Source source = null;
        Document resource = null;
        boolean failed = true;
        boolean exists = false;
        String message = "";
        String target = systemID;
        try {
            source = this.resolver.resolveURI(systemID);
            if (! (source instanceof ModifiableSource)) {
                throw new ProcessingException("Source '" + systemID + "' is not writeable.");
            }
            ModifiableSource ws = (ModifiableSource) source;
            exists = ws.exists();
            target = source.getURI();

            // Insert?
            if (exists && this.state == STATE_INSERT) {
                message = "content inserted at: " + path;
                resource = SourceUtil.toDOM(this.manager, source);
                // import the fragment
                Node importNode = resource.importNode(fragment, true);
                // get the node
                Node parent = DOMUtil.selectSingleNode(resource, path, this.xpathProcessor);

                // replace?
                if (replacePath != null) {
                    try {
                        Node replaceNode = DOMUtil.getSingleNode(parent, replacePath, this.xpathProcessor);
                        // now get the parent of this node until it is the parent node for insertion
                        while (replaceNode != null && !replaceNode.getParentNode().equals(parent)) {
                           replaceNode = replaceNode.getParentNode();
                        }

                        if (replaceNode != null) {
                            if (overwrite) {
                                if (parent.getNodeType() == Node.DOCUMENT_NODE) {
                                    // replacing of the document element is not allowed
                                    resource = newDocument();
                                    resource.appendChild(resource.importNode(importNode, true));
                                    parent = resource;
                                    replaceNode = resource.importNode(replaceNode, true);
                                } else {
                                    parent.replaceChild(importNode, replaceNode);
                                }
                                message += ", replacing: " + replacePath;
                                if (reinsertPath != null) {
                                    Node insertAt = DOMUtil.getSingleNode(parent, reinsertPath, this.xpathProcessor);
                                    if (insertAt != null) {
                                        while (replaceNode.hasChildNodes()) {
                                            insertAt.appendChild(replaceNode.getFirstChild());
                                        }
                                    } else { // reinsert point null
                                        message = "replace failed, could not find your reinsert path: " + reinsertPath;
                                        resource = null;
                                    }
                                }
                            } else { // overwrite was false
                                message = "replace failed, no overwrite allowed.";
                                resource = null;
                            }
                        } else { // specified replaceNode was not found
                            parent.appendChild(importNode);
                        }
                    } catch (javax.xml.transform.TransformerException sax) {
                        throw new ProcessingException("TransformerException: " + sax, sax);
                    }
                } else { // no replace path, just do an insert at end
                    parent.appendChild(importNode);
                }

            // Create?
            } else if (create) {
                // Create new document
                resource = newDocument();

                // Import the fragment
                Node importNode = resource.importNode(fragment, true);

                if (path.equals("")) {
                    // Parent node is document itself
                    NodeList nodes = importNode.getChildNodes();
                    for (int i = 0; i < nodes.getLength();) {
                        Node node = nodes.item(i);
                        switch (node.getNodeType()) {
                            case Node.ELEMENT_NODE:
                                // May throw exception if fragment has more than one element
                                resource.appendChild(node);
                                break;

                            case Node.DOCUMENT_TYPE_NODE:
                            case Node.PROCESSING_INSTRUCTION_NODE:
                            case Node.COMMENT_NODE:
                                resource.appendChild(node);
                                break;

                            default:
                                // Ignore all other nodes
                                i++;
                                break;
                        }
                    }
                    message = "entire source overwritten";

                } else {
                    // Get the parent node
                    Node parent = DOMUtil.selectSingleNode(resource, path, this.xpathProcessor);
                    // Add a fragment
                    parent.appendChild(importNode);
                    message = "content appended to: " + path;
                }

            // Oops: Document does not exist and create is not allowed.
            } else {
                message = "create not allowed";
                resource = null;/**/
            }


            // Write source
            if (resource != null) {
                resource.normalize();
                // use serializer
                if (localSerializer == null) {
                    localSerializer = this.configuredSerializerName;
                }

                if (localSerializer != null) {
                    // Lookup the Serializer
                    ServiceSelector selector = null;
                    Serializer serializer = null;
                    OutputStream oStream = null;
                    try {
                        selector = (ServiceSelector)manager.lookup(Serializer.ROLE + "Selector");
                        serializer = (Serializer)selector.select(localSerializer);
                        oStream = ws.getOutputStream();
                        serializer.setOutputStream(oStream);
                        DOMStreamer streamer = new DOMStreamer(serializer);
                        streamer.stream(resource);
                    } finally {
                        if (oStream != null) {
                            oStream.flush();
                            try {
                                oStream.close();
                                failed = false;
                            } catch (Throwable t) {
                                if (getLogger().isDebugEnabled()) {
                                    getLogger().debug("FAIL (oStream.close) exception"+t, t);
                                }
                                throw new ProcessingException("Could not process your document.", t);
                            } finally {
                                if (selector != null) {
                                    selector.release(serializer);
                                    this.manager.release(selector);
                                }
                            }
                        }
                    }
                } else {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("ERROR: No serializer");
                    }
                    //throw new ProcessingException("No serializer specified for writing to source " + systemID);
                    message = "That source requires a serializer, please add the appropirate tag to your code.";
                }
            }
        } catch (DOMException de) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("FAIL exception: "+de, de);
            }
            message = "There was a problem manipulating your document: " + de;
        } catch (ServiceException ce) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("FAIL exception: "+ce, ce);
            }
            message = "There was a problem looking up a component: " + ce;
        } catch (SourceException se) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("FAIL exception: "+se, se);
            }
            message = "There was a problem resolving that source: [" + systemID + "] : " + se;
        } finally {
            this.resolver.release(source);
        }

        // Report result
        String result = (failed) ? RESULT_FAILED : RESULT_SUCCESS;
        String action = ACTION_NONE;
        if (!failed) {
            action = (exists) ? ACTION_OVER : ACTION_NEW;
        }

        reportResult(localSerializer, tagname, message, target, result, action);
    }
15452#private void reportResult(String localSerializer,
                                String tagname,
                                String message,
                                String target,
                                String result,
                                String action)
    throws SAXException {
        sendStartElementEvent(RESULT_ELEMENT);
            sendStartElementEvent(EXECUTION_ELEMENT);
                sendTextEvent(result);
            sendEndElementEvent(EXECUTION_ELEMENT);
            sendStartElementEvent(MESSAGE_ELEMENT);
                sendTextEvent(message);
            sendEndElementEvent(MESSAGE_ELEMENT);
            sendStartElementEvent(BEHAVIOUR_ELEMENT);
                sendTextEvent(tagname);
            sendEndElementEvent(BEHAVIOUR_ELEMENT);
            sendStartElementEvent(ACTION_ELEMENT);
                sendTextEvent(action);
            sendEndElementEvent(ACTION_ELEMENT);
            sendStartElementEvent(SOURCE_ELEMENT);
                sendTextEvent(target);
            sendEndElementEvent(SOURCE_ELEMENT);
            if (localSerializer != null) {
                sendStartElementEvent(SERIALIZER_ELEMENT);
                    sendTextEvent(localSerializer);
                sendEndElementEvent(SERIALIZER_ELEMENT);
            }
        sendEndElementEvent(RESULT_ELEMENT);
    }
15453#private Document newDocument() throws SAXException, ServiceException {
        DOMParser parser = (DOMParser) this.manager.lookup(DOMParser.ROLE);
        try {
            return parser.createDocument();
        } finally {
            this.manager.release(parser);
        }
    }
15454#/* (non-Javadoc)
     * @see org.apache.avalon.framework.service.Serviceable#service(ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        super.service(manager);
        this.xpathProcessor = (XPathProcessor) this.manager.lookup(XPathProcessor.ROLE);
    }
15455#/* (non-Javadoc)
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        if (this.manager != null) {
            this.manager.release(this.xpathProcessor);
            this.xpathProcessor = null;
        }
        super.dispose();
    }
15456#/** BEGIN SitemapComponent methods **/
    public void setup(SourceResolver resolver,
                      Map objectModel,
                      String source,
                      Parameters parameters)
            throws ProcessingException, SAXException, IOException {
        Request request = ObjectModelHelper.getRequest(objectModel);
        session = request.getSession(false);
        if (session != null) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Session is available. ID=" + session.getId());
            }
            this.attributeName = parameters.getParameter(ATTRIBUTE_NAME, null);
            if (this.attributeName == null) {
                // Try old syntax
                this.attributeName = parameters.getParameter("dom-name", null);
            }

            this.trigger = parameters.getParameter(TRIGGER_ELEMENT, null);
            this.position = parameters.getParameter(POSITION, "in");
            if (getLogger().isDebugEnabled()) {
                getLogger().debug(ATTRIBUTE_NAME + "=" + attributeName + ", "
                        + TRIGGER_ELEMENT + "=" + trigger + ", "
                        + POSITION + "=" + position);
            }
        } else {
            getLogger().warn("No session object: Nothing to do.");
        }
    }
15457#/** END SitemapComponent methods **/

    /** BEGIN SAX ContentHandler handlers **/
    public void startElement(String uri, String name, String raw, Attributes attributes)
            throws SAXException {
        // Start streaming after certain startelement is encountered
        if (name.equalsIgnoreCase(trigger)) {
            getLogger().debug("Trigger encountered");
            if ("before".equalsIgnoreCase(position))  {
                stream();
                super.contentHandler.startElement(uri,name,raw,attributes);
            } else if ("in".equalsIgnoreCase(position))  {
                super.contentHandler.startElement(uri,name,raw,attributes);
                stream();
            } else if ("after".equalsIgnoreCase(position))  {
                super.contentHandler.startElement(uri,name,raw,attributes);
            }
        } else {
            super.contentHandler.startElement(uri,name,raw,attributes);
        }
    }
15458#public void endElement(String uri,String name,String raw)
            throws SAXException  {
        super.contentHandler.endElement(uri,name,raw);
        if (name.equalsIgnoreCase(trigger)) {
            if ("after".equalsIgnoreCase(position))  {
                stream();
            }
        }
    }
15459#/** END SAX ContentHandler handlers **/

    /** own methods **/
    private void stream() throws SAXException  {
        if (attributeName != null)  {
            Object node = session.getAttribute(attributeName);
            if (node != null)  {
                getLogger().debug("Start streaming");
                XMLUtils.valueOf(new IncludeXMLConsumer(super.xmlConsumer), node);
            } else {
                getLogger().error("No attribute " + attributeName + " in session");
            }
        } else {
            getLogger().error("No "+ ATTRIBUTE_NAME + " parameter specified");
        }
    }
15460#public void setup(SourceResolver resolver, Map objectModel, String source, Parameters parameters)
    throws ProcessingException, SAXException, IOException {
        this.resolver = resolver;
        this.validity = new MultiSourceValidity(resolver, MultiSourceValidity.CHECK_ALWAYS); 
        this.xIncludePipe = new XIncludePipe(); 
        this.xIncludePipe.init(null, null);
        super.setContentHandler(xIncludePipe);
        super.setLexicalHandler(xIncludePipe);
    }
15461#public void setConsumer(XMLConsumer consumer) {
        xIncludePipe.setConsumer(consumer);
    }
15462#public void setContentHandler(ContentHandler handler) {
        xIncludePipe.setContentHandler(handler);
    }
15463#public void setLexicalHandler(LexicalHandler handler) {
        xIncludePipe.setLexicalHandler(handler);
    }
15464#public void service(ServiceManager manager) {
        this.manager = manager;
    }
15465#/** Key to be used for caching */ 
    public Serializable getKey() { 
        return XINCLUDE_CACHE_KEY; 
    }
15466#/** Get the validity for this transform */ 
    public SourceValidity getValidity() { 
        return this.validity; 
    }
15467#public void recycle()
    {
        // Reset all variables to initial state.
        this.resolver = null;
        this.validity = null; 
        this.xIncludePipe = null;
        super.recycle();
    }
15468#public void init(String uri, String xpointer) {
            this.href = uri;
            this.xpointer = xpointer;
            this.xmlBaseSupport = new XMLBaseSupport(resolver, getLogger());
        }
15469#public void setParent(XIncludePipe parent) {
            this.parent = parent;
        }
15470#public XIncludePipe getParent() {
            return parent;
        }
15471#public String getHref() {
            return href;
        }
15472#public String getXpointer() {
            return xpointer;
        }
15473#/**
         * Determine whether the pipe is currently in a state where contents
         * should be evaluated, i.e. xi:include elements should be resolved
         * and elements in other namespaces should be copied through. Will
         * return false for fallback contents within a successful xi:include,
         * and true for contents outside any xi:include or within an xi:fallback
         * for an unsuccessful xi:include.
         */
        private boolean isEvaluatingContent() {
            return xIncludeElementLevel == 0 || (fallbackElementLevel > 0 && fallbackElementLevel == useFallbackLevel);
        }
15474#public void endDocument() throws SAXException { 
            // We won't be getting any more sources so mark the MultiSourceValidity as finished. 
            validity.close(); 
            super.endDocument(); 
        }
15475#public void startElement(String uri, String name, String raw, Attributes attr) throws SAXException {
            // Track xml:base context:
            xmlBaseSupport.startElement(uri, name, raw, attr);
            // Handle elements in xinclude namespace:
            if (XINCLUDE_NAMESPACE_URI.equals(uri)) {
                // Handle xi:include:
                if (XINCLUDE_INCLUDE_ELEMENT.equals(name)) {
                    // Process the include, unless in an ignored fallback:
                    if (isEvaluatingContent()) {
                        String href = attr.getValue("", XINCLUDE_INCLUDE_ELEMENT_HREF_ATTRIBUTE);
                        String parse = attr.getValue("", XINCLUDE_INCLUDE_ELEMENT_PARSE_ATTRIBUTE);
                        String xpointer = attr.getValue("", XINCLUDE_INCLUDE_ELEMENT_XPOINTER_ATTRIBUTE);

                        try {
                            processXIncludeElement(href, parse, xpointer);
                        } catch (ProcessingException e) {
                            getLogger().debug("Rethrowing exception", e);
                            throw new SAXException(e);
                        } catch (IOException e) {
                            getLogger().debug("Rethrowing exception", e);
                            throw new SAXException(e);
                        }
                    }
                    xIncludeElementLevel++;
                } else if (XINCLUDE_FALLBACK_ELEMENT.equals(name)) {
                    // Handle xi:fallback
                    fallbackElementLevel++;
                } else {
                    // Unknown element:
                    throw new SAXException("Unknown XInclude element " + raw + " at " + getLocation());
                }
            } else if (isEvaluatingContent()) {
                // Copy other elements through when appropriate:
                super.startElement(uri, name, raw, attr);
            }
        }
15476#public void endElement(String uri, String name, String raw) throws SAXException {
            // Track xml:base context:
            xmlBaseSupport.endElement(uri, name, raw);

            // Handle elements in xinclude namespace:
            if (XINCLUDE_NAMESPACE_URI.equals(uri)) {
                // Handle xi:include:
                if (XINCLUDE_INCLUDE_ELEMENT.equals(name)) {
                    xIncludeElementLevel--;
                    if (useFallbackLevel > xIncludeElementLevel) {
                        useFallbackLevel = xIncludeElementLevel;
                    }
                } else if (XINCLUDE_FALLBACK_ELEMENT.equals(name)) {
                    // Handle xi:fallback:
                    fallbackElementLevel--;
                }
            } else if (isEvaluatingContent()) {
                // Copy other elements through when appropriate:
                super.endElement(uri, name, raw);
            }
        }
15477#public void startPrefixMapping(String prefix, String uri) throws SAXException {
            if (isEvaluatingContent()) {
                super.startPrefixMapping(prefix, uri);
                namespaces.put(prefix, uri);
            }
        }
15478#public void endPrefixMapping(String prefix) throws SAXException {
            if (isEvaluatingContent()) {
                super.endPrefixMapping(prefix);
                namespaces.remove(prefix);
            }
        }
15479#public void characters(char c[], int start, int len) throws SAXException {
            if (isEvaluatingContent()) {
                super.characters(c, start, len);
            }
        }
15480#public void ignorableWhitespace(char c[], int start, int len) throws SAXException {
            if (isEvaluatingContent()) {
                super.ignorableWhitespace(c, start, len);
            }
        }
15481#public void processingInstruction(String target, String data) throws SAXException {
            if (isEvaluatingContent()) {
                super.processingInstruction(target, data);
            }
        }
15482#public void skippedEntity(String name) throws SAXException {
            if (isEvaluatingContent()) {
                super.skippedEntity(name);
            }
        }
15483#public void startEntity(String name) throws SAXException {
            if (isEvaluatingContent()) {
                super.startEntity(name);
            }
        }
15484#public void endEntity(String name) throws SAXException {
            if (isEvaluatingContent()) {
                super.endEntity(name);
            }
        }
15485#public void startCDATA() throws SAXException {
            if (isEvaluatingContent()) {
                super.startCDATA();
            }
        }
15486#public void endCDATA() throws SAXException {
            if (isEvaluatingContent()) {
                super.endCDATA();
            }
        }
15487#public void comment(char ch[], int start, int len) throws SAXException {
            if (isEvaluatingContent()) {
                super.comment(ch, start, len);
            }
        }
15488#public void setDocumentLocator(Locator locator) {
            try {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("setDocumentLocator called " + locator.getSystemId());
                }

                // When using SAXON to serialize a DOM tree to SAX, a locator is passed with a "null" system id
                if (locator.getSystemId() != null) {
                    Source source = resolver.resolveURI(locator.getSystemId());
                    try {
                        xmlBaseSupport.setDocumentLocation(source.getURI());
                        // only for the "root" XIncludePipe, we'll have to set the href here, in the other cases
                        // the href is taken from the xi:include href attribute
                        if (href == null)
                            href = source.getURI();
                    } finally {
                        resolver.release(source);
                    }
                }
            } catch (Exception e) {
                throw new CascadingRuntimeException("Error in XIncludeTransformer while trying to resolve base URL for document", e);
            }
            this.locator = locator;
            super.setDocumentLocator(locator);
        }
15489#protected void processXIncludeElement(String href, String parse, String xpointer)
        throws SAXException,ProcessingException,IOException {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Processing XInclude element: href="+href+", parse="+parse+", xpointer="+xpointer);
            }

            // Default for @parse is "xml"
            if (parse == null) {
                parse = "xml";
            }
            Source url = null;

            try {
                int fragmentIdentifierPos = href.indexOf('#');
                if (fragmentIdentifierPos != -1) {
                    getLogger().warn("Fragment identifer found in 'href' attribute: " + href + 
                            "\nFragment identifiers are forbidden by the XInclude specification. " +
                            "They are still handled by XIncludeTransformer for backward " +
                            "compatibility, but their use is deprecated and will be prohibited " +
                            "in a future release.  Use the 'xpointer' attribute instead.");
                    if (xpointer == null) {
                        xpointer = href.substring(fragmentIdentifierPos + 1);
                    }
                    href = href.substring(0, fragmentIdentifierPos);
                }

                // An empty or absent href is a reference to the current document -- this can be different than the current base
                if (href == null || href.length() == 0) {
                    if (this.href == null) {
                        throw new SAXException("XIncludeTransformer: encountered empty href (= href pointing to the current document) but the location of the current document is unknown.");
                    }
                    // The following can be simplified once fragment identifiers are prohibited
                    int fragmentIdentifierPos2 = this.href.indexOf('#');
                    if (fragmentIdentifierPos2 != -1)
                        href = this.href.substring(0, fragmentIdentifierPos2);
                    else
                        href = this.href;
                }

                url = xmlBaseSupport.makeAbsolute(href);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("URL: " + url.getURI() + "\nXPointer: " + xpointer);
                }

                // add the source to the SourceValidity 
                validity.addSource(url); 

                if (parse.equals("text")) {
                    getLogger().debug("Parse type is text");
                    if (xpointer != null) {
                        throw new SAXException("xpointer attribute must not be present when parse='text': " + getLocation());
                    }
                    InputStream is = null;
                    InputStreamReader isr = null;
                    Reader reader = null;
                    try {
                        is = url.getInputStream();
                        isr = new InputStreamReader(is);
                        reader = new BufferedReader(isr);
                        int read;
                        char ary[] = new char[1024 * 4];
                        while ((read = reader.read(ary)) != -1) {
                            super.characters(ary,0,read);
                        }
                    } catch (SourceNotFoundException e) {
                        useFallbackLevel++;
                        fallBackException = new CascadingException("Resource not found: " + url.getURI());
                        getLogger().error("xIncluded resource not found: " + url.getURI(), e);
                    } finally {
                        if (reader != null) reader.close();
                        if (isr != null) isr.close();
                        if (is != null) is.close();
                    }
                } else if (parse.equals("xml")) {
                    getLogger().debug("Parse type is XML");

                    // Check loop inclusion
                    if (isLoopInclusion(url.getURI(), xpointer)) {
                        throw new ProcessingException("Detected loop inclusion of href=" + url.getURI() + ", xpointer=" + xpointer);
                    }

                    XIncludePipe subPipe = new XIncludePipe();
                    subPipe.init(url.getURI(), xpointer);
                    subPipe.setConsumer(xmlConsumer);
                    subPipe.setParent(this);

                    try {
                        if (xpointer != null && xpointer.length() > 0) {
                            XPointer xptr;
                            xptr = XPointerFrameworkParser.parse(NetUtils.decodePath(xpointer));
                            XPointerContext context = new XPointerContext(xpointer, url, subPipe, manager);
                            for (Iterator iter = namespaces.keySet().iterator(); iter.hasNext();) {
                                String prefix = (String) iter.next();
                                context.addPrefix(prefix, (String) namespaces.get(prefix));
                            }
                            xptr.process(context);
                        } else {
                            SourceUtil.toSAX(manager, url, new IncludeXMLConsumer(subPipe));
                        }
                        // restore locator on the consumer
                        if (locator != null)
                            xmlConsumer.setDocumentLocator(locator);
                    } catch (ResourceNotFoundException e) {
                        useFallbackLevel++;
                        fallBackException = new CascadingException("Resource not found: " + url.getURI());
                        getLogger().error("xIncluded resource not found: " + url.getURI(), e);
                    } catch (ParseException e) {
                        // this exception is thrown in case of an invalid xpointer expression
                        useFallbackLevel++;
                        fallBackException = new CascadingException("Error parsing xPointer expression", e);
                        fallBackException.fillInStackTrace();
                        getLogger().error("Error parsing XPointer expression, will try to use fallback.", e);
                    } catch(SAXException e) {
                        getLogger().error("Error in processXIncludeElement", e);
                        throw e;
                    } catch(ProcessingException e) {
                        getLogger().error("Error in processXIncludeElement", e);
                        throw e;
                    } catch(MalformedURLException e) {
                        useFallbackLevel++;
                        fallBackException = e;
                        getLogger().error("Error processing an xInclude, will try to use fallback.", e);
                    } catch(IOException e) {
                        useFallbackLevel++;
                        fallBackException = e;
                        getLogger().error("Error processing an xInclude, will try to use fallback.", e);
                    }
                } else {
                    throw new SAXException("Found 'parse' attribute with unknown value " + parse + " at " + getLocation());
                }
            } catch (SourceException se) {
                throw SourceUtil.handle(se);
            } finally {
                if (url != null) {
                    resolver.release(url);
                }
            }
        }
15490#public boolean isLoopInclusion(String uri, String xpointer) {
            if (xpointer == null) {
                xpointer = "";
            }

            if (uri.equals(this.href) && xpointer.equals(this.xpointer == null ? "" : this.xpointer)) {
                return true;
            }

            XIncludePipe parent = getParent();
            while (parent != null) {
                if (uri.equals(parent.getHref()) && xpointer.equals(parent.getXpointer() == null ? "" : parent.getXpointer())) {
                    return true;
                }
                parent = parent.getParent();
            }
            return false;
        }
15491#private String getLocation() {
            if (this.locator == null) {
                return "unknown location";
            } else {
                return this.locator.getSystemId() + ":" + this.locator.getColumnNumber() + ":" + this.locator.getLineNumber();
            }
        }
15492#/**
     * Setup
     */
    public void setup(SourceResolver resolver, Map objectModel,
                      String src, Parameters parameters)
    throws ProcessingException, SAXException, IOException {
        final boolean append = parameters.getParameterAsBoolean("append", false);
        final String  logfilename = parameters.getParameter("logfile", null);

        // Check for null, use System.out if logfile is not specified.
        this.logfile = null;
        if ( null != logfilename ) {
            Source source = null;
            try {
                source = resolver.resolveURI( logfilename );
                final String systemId = source.getURI();
                if ( systemId.startsWith("file:") ) {
                    this.logfile = new FileWriter(systemId.substring(5), append );
                } else {
                    throw new ProcessingException("The logfile parameter must point to a file: " + logfilename);
                }
            } catch (SourceException se) {
                throw SourceUtil.handle(se);
            } finally {
                resolver.release( source );
            }
        }

        Date date = new Date();
        StringBuffer logEntry = new StringBuffer();
        logEntry.append ( "---------------------------- [" );
        logEntry.append ( date.toString() );
        logEntry.append ( "] ----------------------------" );
        this.log("setup", logEntry.toString());
    }
15493#/**
     * Recycle
     */
    public void recycle() {
        super.recycle();
        try {
            if (this.logfile != null) logfile.close();
        } catch (Exception e) {
            this.getLogger().warn("LogTransformer.recycle()", e);
        }
        this.logfile = null;
    }
15494#/**
     * Receive an object for locating the origin of SAX document events.
     */
    public void setDocumentLocator(Locator locator) {
        this.log("setDocumentLocator", locator != null ? "systemid="+locator.getSystemId()+",publicid="+locator.getPublicId() : "(locator is null)");
        if (super.contentHandler!=null) {
            super.contentHandler.setDocumentLocator(locator);
        }
    }
15495#/**
     * Receive notification of the beginning of a document.
     */
    public void startDocument()
    throws SAXException {
        this.log("startDocument", "");
        if (super.contentHandler!=null) {
            super.contentHandler.startDocument();
        }
    }
15496#/**
     * Receive notification of the end of a document.
     */
    public void endDocument()
    throws SAXException {
        this.log ("endDocument", "");
        if (super.contentHandler!=null) {
            super.contentHandler.endDocument();
        }
    }
15497#/**
     * Begin the scope of a prefix-URI Namespace mapping.
     */
    public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
        this.log ("startPrefixMapping", "prefix="+prefix+",uri="+uri);
        if (super.contentHandler!=null) {
            super.contentHandler.startPrefixMapping(prefix,uri);
        }
    }
15498#/**
     * End the scope of a prefix-URI mapping.
     */
    public void endPrefixMapping(String prefix)
    throws SAXException {
        this.log ("endPrefixMapping", "prefix="+prefix);
        if (super.contentHandler!=null) {
            super.contentHandler.endPrefixMapping(prefix);
        }
    }
15499#/**
     * Receive notification of the beginning of an element.
     */
    public void startElement(String uri, String loc, String raw, Attributes a)
    throws SAXException {
        this.log ("startElement", "uri="+uri+",local="+loc+",raw="+raw);
        for (int i = 0; i < a.getLength(); i++) {
            this.log ("            ", new Integer(i+1).toString()
                 +". uri="+a.getURI(i)
                 +",local="+a.getLocalName(i)
                 +",qname="+a.getQName(i)
                 +",type="+a.getType(i)
                 +",value="+a.getValue(i));
        }
        if (super.contentHandler!=null) {
            super.contentHandler.startElement(uri,loc,raw,a);
        }
    }
15500#/**
     * Receive notification of the end of an element.
     */
    public void endElement(String uri, String loc, String raw)
    throws SAXException {
        this.log ("endElement", "uri="+uri+",local="+loc+",raw="+raw);
        if (super.contentHandler!=null) {
            super.contentHandler.endElement(uri,loc,raw);
        }
    }
15501#/**
     * Receive notification of character data.
     */
    public void characters(char ch[], int start, int len)
    throws SAXException {
        this.log ("characters", new String(ch,start,len));
        if (super.contentHandler!=null) {
            super.contentHandler.characters(ch,start,len);
        }
    }
15502#/**
     * Receive notification of ignorable whitespace in element content.
     */
    public void ignorableWhitespace(char ch[], int start, int len)
    throws SAXException {
        this.log ("ignorableWhitespace", new String(ch,start,len));
        if (super.contentHandler!=null) {
            super.contentHandler.ignorableWhitespace(ch,start,len);
        }
    }
15503#/**
     * Receive notification of a processing instruction.
     */
    public void processingInstruction(String target, String data)
    throws SAXException {
        log ("processingInstruction", "target="+target+",data="+data);
        if (super.contentHandler!=null) {
            super.contentHandler.processingInstruction(target,data);
        }
    }
15504#/**
     * Receive notification of a skipped entity.
     */
    public void skippedEntity(String name)
    throws SAXException {
        this.log ("skippedEntity", "name="+name);
        if (super.contentHandler!=null) {
            super.contentHandler.skippedEntity(name);
        }
    }
15505#/**
     * Report the start of DTD declarations, if any.
     */
    public void startDTD(String name, String publicId, String systemId)
    throws SAXException {
        this.log ("startDTD", "name="+name+",publicId="+publicId+",systemId="+systemId);
        if (super.lexicalHandler!=null) {
            super.lexicalHandler.startDTD(name,publicId,systemId);
        }
    }
15506#/**
     * Report the end of DTD declarations.
     */
    public void endDTD()
    throws SAXException {
        this.log ("endDTD", "");
        if (super.lexicalHandler!=null) {
            super.lexicalHandler.endDTD();
        }
    }
15507#/**
     * Report the beginning of an entity.
     */
    public void startEntity(String name)
    throws SAXException {
        this.log ("startEntity", "name="+name);
        if (super.lexicalHandler!=null) {
            super.lexicalHandler.startEntity(name);
        }
    }
15508#/**
     * Report the end of an entity.
     */
    public void endEntity(String name)
    throws SAXException {
        this.log ("endEntity", "name="+name);
        if (super.lexicalHandler!=null) {
            super.lexicalHandler.endEntity(name);
        }
    }
15509#/**
     * Report the start of a CDATA section.
     */
    public void startCDATA()
    throws SAXException {
        this.log ("startCDATA", "");
        if (super.lexicalHandler!=null) {
            super.lexicalHandler.startCDATA();
        }
    }
15510#/**
     * Report the end of a CDATA section.
     */
    public void endCDATA()
    throws SAXException {
        this.log ("endCDATA", "");
        if (super.lexicalHandler!=null) {
            super.lexicalHandler.endCDATA();
        }
    }
15511#/**
     * Report an XML comment anywhere in the document.
     */
    public void comment(char ch[], int start, int len)
    throws SAXException {
        this.log ("comment", new String(ch,start,len));
        if (super.lexicalHandler!=null) {
            super.lexicalHandler.comment(ch,start,len);
        }
    }
15512#/**
     * Report to logfile.
     */
    private void log (String location, String description) {
        final StringBuffer logEntry = new StringBuffer();
        logEntry.append ( "[" );
        logEntry.append ( location );
        logEntry.append ( "] " );
        logEntry.append ( description );
        logEntry.append ( lf );
        final String text = logEntry.toString();
        if ( this.getLogger().isInfoEnabled() ) {
            this.getLogger().info( text );
        }
        try {
            if ( null != this.logfile ) {
                this.logfile.write( text, 0, text.length());
                this.logfile.flush();
            } else {
                System.out.println( text );
            }
        }
        catch(IOException ioe) {
            this.getLogger().debug("LogTransformer.log", ioe);
        }
    }
15513#/**
     *  Attempt to close the log file when the class is GC'd
     */
    public void destroy() {
        try {
            if (this.logfile != null) logfile.close();
        } catch (Exception e) {getLogger().debug("LogTransformer.destroy()", e);}
    }
15514#/**
     * check if encoding of URLs is neccessary.
     *
     * This is true if session object exists, and session-id   
     * was provided from URL, or session is new.
     * The result is stored in some instance variables
     */
    protected void checkForEncoding(Request request) {
        this.session = request.getSession(false);
        this.isEncodeURLNeeded = false;

        if ( null != this.session ) {
            // do encoding if session id is from URL, or the session is new,
            // fixes BUG #13855, due to paint007@mc.duke.edu
            if ( request.isRequestedSessionIdFromURL() || this.session.isNew()) {
                this.isEncodeURLNeeded = true;
            }
        }
    }
15515#/**
     * Setup the transformer.
     * <p>
     *   Setup include, and exclude patterns from the parameters
     * </p>
     *
     * @param resolver source resolver
     * @param objectModel sitemap objects
     * @param parameters request parameters
     *
     */
    public void setup(SourceResolver resolver, Map objectModel, String source, Parameters parameters)
    throws ProcessingException, SAXException, IOException {

        this.checkForEncoding(ObjectModelHelper.getRequest(objectModel));

        if (this.isEncodeURLNeeded) {
            this.response = ObjectModelHelper.getResponse(objectModel);

            // don't check if URL encoding is needed now, as
            // a generator might create a new session
            final String includeName = parameters.getParameter(INCLUDE_NAME,
                                                               this.includeNameConfigure);
            final String excludeName = parameters.getParameter(EXCLUDE_NAME,
                                                               this.excludeNameConfigure);
            try {
                this.elementAttributeMatching = new ElementAttributeMatching(includeName, excludeName);
            } catch (PatternSyntaxException reex) {
                final String message = "Cannot parse include-name: " + includeName + " " +
                    "or exclude-name: " + excludeName + "!";
                throw new ProcessingException(message, reex);
            }
        }
    }
15516#/**
     * BEGIN SitemapComponent methods
     *
     * @param  configuration               Description of Parameter
     * @exception  ConfigurationException  Description of Exception
     */
    public void configure(Configuration configuration) throws ConfigurationException {
        Configuration child;

        child = configuration.getChild(INCLUDE_NAME);
        this.includeNameConfigure = child.getValue(INCLUDE_NAME_DEFAULT);

        child = configuration.getChild(EXCLUDE_NAME);
        this.excludeNameConfigure = child.getValue(EXCLUDE_NAME_DEFAULT);

        if (this.includeNameConfigure == null) {
            String message = "Configure " + INCLUDE_NAME + "!";
            throw new ConfigurationException(message);
        }
        if (this.excludeNameConfigure == null) {
            String message = "Configure " + EXCLUDE_NAME + "!";
            throw new ConfigurationException(message);
        }
    }
15517#/**
     * Recycle resources of this transformer
     */
    public void recycle() {
        super.recycle();
        this.response = null;
        this.session = null;
        this.elementAttributeMatching = null;
    }
15518#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     *
     * @return The generated key hashes the src
     */
    public java.io.Serializable getKey() {
        if (this.isEncodeURLNeeded) {
            return null;
        } else {
            return "1";
        }
    }
15519#/**
     * Generate the validity object.
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity() {
        if (this.isEncodeURLNeeded) {
            return null;
        } else {
            return NOPValidity.SHARED_INSTANCE;
        }
    }
15520#/**
     * Start parsing an element
     *
     * @param  uri               of the element
     * @param  name              of the element
     * @param  raw               name of the element
     * @param  attributes        list
     * @exception  SAXException  Description of Exception
     */
    public void startElement(String uri, String name, String raw, Attributes attributes)
    throws SAXException {
        if (this.isEncodeURLNeeded && this.elementAttributeMatching != null) {
            if (attributes != null && attributes.getLength() > 0) {
                AttributesImpl new_attributes = new AttributesImpl(attributes);
                for (int i = 0; i < new_attributes.getLength(); i++) {
                    String attr_lname = new_attributes.getLocalName(i);

                    String value = new_attributes.getValue(i);

                    if (elementAttributeMatching.matchesElementAttribute(name, attr_lname, value)) {
                        // don't use simply this.response.encodeURL(value)
                        // but be more smart about the url encoding
                        final String new_value = this.encodeURL(value);
                        if (getLogger().isDebugEnabled()) {
                            this.getLogger().debug("element/@attribute matches: " + name + "/@" + attr_lname);
                            this.getLogger().debug("encodeURL: " + value + " -> " + new_value);
                        }
                        new_attributes.setValue(i, new_value);
                    }
                }
                // parent handles element using encoded attribute values
                super.contentHandler.startElement(uri, name, raw, new_attributes);
                return;
            }
        }
        // no match, parent handles element as-is
        super.contentHandler.startElement(uri, name, raw, attributes);
    }
15521#/**
     * Do the URL rewriting.
     * <p>
     *   Check if <code>url</code> contains already the sessionid, some servlet-engines
     *   just appends the session-id without checking if the sessionid is already present.
     * </p>
     *
     * @param  url       the URL probably without sessionid.
     * @return           String the original url inclusive the sessionid
     */
    protected String encodeURL(String url) {
        String encoded_url;
        if (this.response != null) {
            // As some servlet-engine does not check if url has been already rewritten
            if (this.session != null && url.indexOf(this.session.getId()) > -1) {
                // url contains already the session id encoded
                encoded_url = url;
            } else {
                // do encode the session id
                encoded_url = this.response.encodeURL(url);
            }
        } else {
            encoded_url = url;
        }
        return encoded_url;
    }
15522#/**
         *Constructor for the ElementAttributeMatching object
         *
         * @param  includeName            Description of Parameter
         * @param  excludeName            Description of Parameter
         * @exception  PatternSyntaxException  Description of Exception
         */
        public ElementAttributeMatching(String includeName, String excludeName) throws PatternSyntaxException {
            includeNameRE = Pattern.compile(includeName, Pattern.CASE_INSENSITIVE);
            excludeNameRE = Pattern.compile(excludeName, Pattern.CASE_INSENSITIVE);
        }
15523#/**
         * Return true iff element_name attr_name pair is not matched by exclude-name,
         * but is matched by include-name
         * @param  element_name
         * @param  attr_name
         * @param value TODO
         *
         * @return               boolean true iff value of attribute_name should get rewritten, else
         *   false.
         */
        public boolean matchesElementAttribute(String element_name, String attr_name, String value) {
            String element_attr_name = canonicalizeElementAttribute(element_name, attr_name, value);

            if (excludeNameRE != null && includeNameRE != null) {
                return !matchesExcludesElementAttribute(element_attr_name) &&
                        matchesIncludesElementAttribute(element_attr_name);
            } else {
                return false;
            }
        }
15524#/**
         * Build from elementname, and attribute name a single string.
         * <p>
         *   String concatenated <code>element name + "/@" + attribute name</code>
         *   is matched against the include and excluding patterns.
         * </p>
         * @param  element_name  Description of Parameter
         * @param  attr_name     Description of Parameter
         * @param value The value
         *
         * @return               Description of the Returned Value
         */
        private String canonicalizeElementAttribute(String element_name, String attr_name, String value) {
            return element_name + "/@" + attr_name + "=" + value;
        }
15525#/**
         * Return true iff element_name attr_name pair is matched by exclude-name.
         *
         * @param  element_attr_name
         * @return                    boolean true iff exclude-name matches element_name, attr_name, else
         *   false.
         */
        private boolean matchesExcludesElementAttribute(String element_attr_name) {
            boolean match = excludeNameRE.matcher(element_attr_name).lookingAt();
            return match;
        }
15526#/**
         * Return true iff element_name attr_name pair is matched by include-name.
         *
         * @param  element_attr_name
         * @return                    boolean true iff include-name matches element_name, attr_name, else
         *   false.
         */
        private boolean matchesIncludesElementAttribute(String element_attr_name) {
            boolean match = includeNameRE.matcher(element_attr_name).lookingAt();
            return match;
        }
15527#/**
     * Configure this transformer.
     */
    public void configure(Configuration conf)
    throws ConfigurationException {
        Configuration child;

        child = conf.getChild("use-request-parameters");
        this.useParameters = child.getValueAsBoolean(false);
        this._useParameters = this.useParameters;

        child = conf.getChild("use-cookies");
        this.useCookies = child.getValueAsBoolean(false);
        this._useCookies = this.useCookies;

        child = conf.getChild("use-session-info");
        this.useSessionInfo = child.getValueAsBoolean(false);
        this._useSessionInfo = this.useSessionInfo;

        child = conf.getChild("xslt-processor-role");
        String xsltProcessorRole = child.getValue(XSLTProcessor.ROLE);
        if (!xsltProcessorRole.startsWith(XSLTProcessor.ROLE)) {
            xsltProcessorRole = XSLTProcessor.ROLE + '/' + xsltProcessorRole;
        }

        child = conf.getChild("check-includes");
        this.checkIncludes = child.getValueAsBoolean(this.checkIncludes);

        child = conf.getChild("default-src",false);
        if(child!=null) {
            this.defaultSrc = child.getValue();
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Use parameters is " + this.useParameters);
            getLogger().debug("Use cookies is " + this.useCookies);
            getLogger().debug("Use session info is " + this.useSessionInfo);
            getLogger().debug("Use TrAX Processor " + xsltProcessorRole);
            getLogger().debug("Check for included stylesheets is " + this.checkIncludes);
            getLogger().debug("Default source = " + this.defaultSrc);
        }

        try {
            this.xsltProcessor = (XSLTProcessor) this.manager.lookup(xsltProcessorRole);
        } catch (ServiceException e) {
            throw new ConfigurationException("Cannot load XSLT processor", e);
        }

        try {
            // see the recyle() method to see what we need this for
            Class dtmManagerClass = Class.forName("org.apache.xml.dtm.DTMManager");
            xalanDtmManagerGetIncrementalMethod = dtmManagerClass.getMethod("getIncremental", null);
        } catch (ClassNotFoundException e) {
            // do nothing -- user does not use xalan, so we don't need the dtm manager
        } catch (NoSuchMethodException e) {
            throw new ConfigurationException("Was not able to get getIncremental method from Xalan's DTMManager.", e);
        }
    }
15528#/**
     * Set the current <code>ServiceManager</code> instance used by this
     * <code>Serviceable</code>.
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
15529#/**
     * Set the <code>SourceResolver</code>, the <code>Map</code> with
     * the object model, the source and sitemap
     * <code>Parameters</code> used to process the request.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws SAXException, ProcessingException, IOException {

        if(src==null && defaultSrc!=null) {
            if(getLogger().isDebugEnabled()) {
                getLogger().debug("src is null, using default source " + defaultSrc);
            }
            src = defaultSrc;
        }

        if (src == null) {
            throw new ProcessingException("Stylesheet URI can't be null");
        }

        this.par = par;
        this.objectModel = objectModel;
        this.resolver = resolver;
        try {
            this.inputSource = resolver.resolveURI(src);
        } catch (SourceException se) {
            throw SourceUtil.handle("Unable to resolve " + src, se);
        }
        _useParameters = par.getParameterAsBoolean("use-request-parameters", this.useParameters);
        _useCookies = par.getParameterAsBoolean("use-cookies", this.useCookies);
        _useSessionInfo = par.getParameterAsBoolean("use-session-info", this.useSessionInfo);
        final boolean _checkIncludes = par.getParameterAsBoolean("check-includes", this.checkIncludes);

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Using stylesheet: '" + this.inputSource.getURI() + "' in " + this);
            getLogger().debug("Use parameters is " + this._useParameters);
            getLogger().debug("Use cookies is " + this._useCookies);
            getLogger().debug("Use session info is " + this._useSessionInfo);
            getLogger().debug("Check for included stylesheets is " + _checkIncludes);
        }

        // Get a Transformer Handler if we check for includes
        // If we don't check the handler is get during setConsumer()
        try {
            if ( _checkIncludes ) {
                XSLTProcessor.TransformerHandlerAndValidity handlerAndValidity =
                        this.xsltProcessor.getTransformerHandlerAndValidity(this.inputSource, null);
                this.transformerHandler = handlerAndValidity.getTransfomerHandler();
                this.transformerValidity = handlerAndValidity.getTransfomerValidity();
            } else {
                this.transformerValidity = this.inputSource.getValidity();
            }
        } catch (XSLTProcessorException se) {
            throw new ProcessingException("Unable to get transformer handler for " + this.inputSource.getURI(), se);
        }
    }
15530#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     *
     * @return The generated key hashes the src
     */
    public Serializable getKey() {
        Map map = getLogicSheetParameters();
        if (map == null) {
            return this.inputSource.getURI();
        }

        StringBuffer sb = new StringBuffer();
        sb.append(this.inputSource.getURI());
        Set entries = map.entrySet();
        for(Iterator i=entries.iterator(); i.hasNext();){
            sb.append(';');
            Map.Entry entry = (Map.Entry)i.next();
            sb.append(entry.getKey());
            sb.append('=');
            sb.append(entry.getValue());
        }
        return sb.toString();
    }
15531#/**
     * Generate the validity object.
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity() {
        //
        // VG: Key is generated using parameter/value pairs,
        // so this information does not need to be verified again
        // (if parameter added/removed or value changed, key should
        // change also), only stylesheet's validity is included.
        //
        return this.transformerValidity;
    }
15532#/**
     * Set the <code>XMLConsumer</code> that will receive XML data.
     */
    public void setConsumer(XMLConsumer consumer) {

        if ( this.transformerHandler == null ) {
            try {
                this.transformerHandler = this.xsltProcessor.getTransformerHandler(this.inputSource);
            } catch (XSLTProcessorException se) {
                // the exception will be thrown during startDocument()
                this.exceptionDuringSetConsumer =
                   new SAXException("Unable to get transformer handler for " + this.inputSource.getURI(), se);
                return;
            }
        }
        final Map map = getLogicSheetParameters();
        if (map != null) {
            final javax.xml.transform.Transformer transformer = this.transformerHandler.getTransformer();
            final Iterator iterator = map.entrySet().iterator();
            while (iterator.hasNext()) {
                final Map.Entry entry = (Entry) iterator.next();
                transformer.setParameter((String)entry.getKey(), entry.getValue());
            }
        }

        super.setContentHandler(this.transformerHandler);
        super.setLexicalHandler(this.transformerHandler);
        // Is there even single implementation of LogEnabled TransformerHandler?
        if (this.transformerHandler instanceof LogEnabled) {
        	((LogEnabled) this.transformerHandler).enableLogging(new CLLoggerWrapper(getLogger()));
        }
        // According to TrAX specs, all TransformerHandlers are LexicalHandlers
        final SAXResult result = new SAXResult(consumer);
        result.setLexicalHandler(consumer);
        this.transformerHandler.setResult(result);

        this.errorListener = new TraxErrorListener(this.inputSource.getURI());
        this.transformerHandler.getTransformer().setErrorListener(this.errorListener);
    }
15533#/**
     * Get the parameters for the logicsheet
     */
    protected Map getLogicSheetParameters() {
        if (this.logicSheetParameters != null) {
            return this.logicSheetParameters;
        }

        HashMap map = null;
        if (par != null) {
            String[] params = par.getNames();
            if (params != null) {
                for(int i = 0; i < params.length; i++) {
                    String name = params[i];
                    if (isValidXSLTParameterName(name)) {
                        String value = par.getParameter(name,null);
                        if (value != null) {
                            if (map == null) {
                                map = new HashMap(params.length);
                            }
                            map.put(name,value);
                        }
                    }
                }
            }
        }

        if (this._useParameters) {
            Request request = ObjectModelHelper.getRequest(objectModel);

            Enumeration parameters = request.getParameterNames();
            if (parameters != null) {
                while (parameters.hasMoreElements()) {
                    String name = (String) parameters.nextElement();
                    if (isValidXSLTParameterName(name)) {
                        String value = request.getParameter(name);
                        if (map == null) {
                            map = new HashMap();
                        }
                        map.put(name,value);
                    }
                }
            }
        }

        if (this._useSessionInfo) {
            final Request request = ObjectModelHelper.getRequest(objectModel);
            if (map == null) {
                map = new HashMap(6);
            }

            final HttpSession session = request.getSession(false);
            if (session != null) {
                map.put("session-available", "true");
                map.put("session-is-new", BooleanUtils.toStringTrueFalse(session.isNew()));
                map.put("session-id-from-cookie", BooleanUtils.toStringTrueFalse(request.isRequestedSessionIdFromCookie()));
                map.put("session-id-from-url", BooleanUtils.toStringTrueFalse(request.isRequestedSessionIdFromURL()));
                map.put("session-valid", BooleanUtils.toStringTrueFalse(request.isRequestedSessionIdValid()));
                map.put("session-id", session.getId());
            } else {
                map.put("session-available", "false");
            }
        }

        if (this._useCookies) {
            Request request = ObjectModelHelper.getRequest(objectModel);
            Cookie cookies[] = request.getCookies();
            if (cookies != null) {
                for (int i = 0; i < cookies.length; i++) {
                    String name = cookies[i].getName();
                    if (isValidXSLTParameterName(name)) {
                        String value = cookies[i].getValue();
                        if (map == null) {
                            map = new HashMap(cookies.length);
                        }
                        map.put(name,value);
                    }
                }
            }
        }
        this.logicSheetParameters = map;
        return this.logicSheetParameters;
    }
15534#/**
     * Test if the name is a valid parameter name for XSLT
     */
    static boolean isValidXSLTParameterName(String name) {
        if (name.length() == 0) {
            return false;
        }

        char c = name.charAt(0);
        if (!(Character.isLetter(c) || c == '_')) {
            return false;
        }

        for (int i = name.length()-1; i > 1; i--) {
            c = name.charAt(i);
            if (!(Character.isLetterOrDigit(c) ||
                    c == '-' ||
                    c == '_' ||
                    c == '.')) {
                return false;
            }
        }
        return true;
    }
15535#/**
     * Disposable
     */
    public void dispose() {
        if ( this.manager != null ) {
            this.manager.release(this.xsltProcessor);
            this.xsltProcessor = null;
            this.manager = null;
        }
    }
15536#/**
     * Recyclable
     */
    public void recycle() {
        this.objectModel = null;
        if (this.inputSource != null) {
            this.resolver.release(this.inputSource);
            this.inputSource = null;
        }
        this.resolver = null;
        this.par = null;
        if (!this.finishedDocument && transformerHandler != null) {
            // This situation will only occur if an exception occured during pipeline execution.
            // If Xalan is used in incremental mode, it is important that endDocument is called, otherwise
            // the thread on which it runs the transformation will keep waiting.
            // However, calling endDocument will cause the pipeline to continue executing, and thus the
            // serializer will write output to the outputstream after what's already there (the error page),
            // see also bug 13186.
            if (xalanDtmManagerGetIncrementalMethod != null
                && transformerHandler.getClass().getName().equals("org.apache.xalan.transformer.TransformerHandlerImpl")) {
                try {
                    final boolean incremental = ((Boolean)xalanDtmManagerGetIncrementalMethod.invoke(null, null)).booleanValue();
                    if (incremental) {
                        super.endDocument();
                    }
                } catch (Exception ignore) {}
            }
        }
        this.finishedDocument = true;
        this.logicSheetParameters = null;
        this.transformerHandler = null;
        this.transformerValidity = null;
        this.exceptionDuringSetConsumer = null;
        this.errorListener = null;
        super.recycle();
    }
15537#/**
     * Fix for stopping hanging threads of Xalan
     */
    public void endDocument()
    throws SAXException {
        try {
            super.endDocument();
        } catch(Exception e) {

            Throwable realEx = this.errorListener.getThrowable();
            if (realEx == null) realEx = e;

            if (realEx instanceof RuntimeException) {
                throw (RuntimeException)realEx;
            }

            if (realEx instanceof SAXException) {
                throw (SAXException)realEx;
            }

            if (realEx instanceof Error) {
                throw (Error)realEx;
            }

            throw new NestableRuntimeException(realEx);
        }
        this.finishedDocument = true;
    }
15538#/* (non-Javadoc)
     * @see org.xml.sax.ContentHandler#startDocument()
     */
    public void startDocument() throws SAXException {
        // did an exception occur during setConsumer?
        // if so, throw it here
        if ( this.exceptionDuringSetConsumer != null ) {
            throw this.exceptionDuringSetConsumer;
        }
        this.finishedDocument = false;
        super.startDocument();
    }
15539#/**
     * Configure this transformer.
     */
    public void configure(Configuration conf) throws ConfigurationException {
        this.extractURI = conf.getChild(EXTRACT_URI_NAME).getValue(EXTRACT_URI);
        this.extractElement = conf.getChild(EXTRACT_ELEMENT_NAME).getValue(EXTRACT_ELEMENT);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Extraction URI is " + this.extractURI);
            getLogger().debug("Extraction element is " + this.extractElement);
        }
    }
15540#/**
     * Set the current <code>ServiceManager</code> instance used by this
     * <code>Serviceable</code>.
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
15541#/**
     * Recycle this component
     */
    public void recycle() {
        this.serializer = null;
        super.recycle();        
    }
15542#/**
     * Release all resources.
     */
    public void dispose() {
        recycle();
        this.manager = null;
    }
15543#/**
     * Setup the transformer.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters parameters)
    throws ProcessingException, SAXException, IOException {
        extractLevel = 0;
        fragmentID = 0;
        prefixMap = new HashMap();

        this.requestURI = ObjectModelHelper.getRequest(objectModel).getSitemapURI();
    }
15544#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     *
     * @return "1"
     */
    public Serializable getKey() {
        return "1";
    }
15545#/**
     * Generate the validity object.
     *
     * @return NOPValidity object
     *         - if the input is valid the output is valid as well.
     */
    public SourceValidity getValidity() {
        return NOPValidity.SHARED_INSTANCE;
    }
15546#/**
     * Begin the scope of a prefix-URI Namespace mapping.
     *
     * @param prefix The Namespace prefix being declared.
     * @param uri The Namespace URI the prefix is mapped to.
     */
    public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
        if (extractLevel == 0) {
            super.startPrefixMapping(prefix, uri);
            prefixMap.put(prefix, uri);
        } else {
            this.serializer.startPrefixMapping(prefix, uri);
        }
    }
15547#/**
     * End the scope of a prefix-URI mapping.
     *
     * @param prefix The prefix that was being mapping.
     */
    public void endPrefixMapping(String prefix)
    throws SAXException {
        if (extractLevel == 0) {
            super.endPrefixMapping(prefix);
            prefixMap.remove(prefix);
        } else {
            this.serializer.endPrefixMapping(prefix);
        }
    }
15548#/**
     * Receive notification of the beginning of an element.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     * @param a The attributes attached to the element. If there are no
     *          attributes, it shall be an empty Attributes object.
     */
    public void startElement(String uri, String loc, String raw, Attributes a)
    throws SAXException {
        if (uri == null) uri = "";
        if (this.extractURI.equals(uri) && this.extractElement.equals(loc)) {
            extractLevel++;
            fragmentID++;
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("extractLevel now " + extractLevel + ".");
            }

            this.serializer = new XMLByteStreamCompiler();

            // Start the DOM document
            this.serializer.startDocument();

            Iterator itt = prefixMap.entrySet().iterator();
            while (itt.hasNext()) {
                Map.Entry entry = (Map.Entry)itt.next();
                this.serializer.startPrefixMapping(
                    (String)entry.getKey(),
                    (String)entry.getValue()
                );
            }
        }

        if (extractLevel == 0) {
            super.startElement(uri, loc, raw, a);
        } else {
            this.serializer.startElement(uri, loc, raw, a);
        }
    }
15549#/**
     * Receive notification of the end of an element.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     */
    public void endElement(String uri, String loc, String raw)
    throws SAXException {
        if (extractLevel == 0) {
            super.endElement(uri, loc, raw);
        } else {
            this.serializer.endElement(uri, loc, raw);
            if (uri == null) uri = "";
            if (this.extractURI.equals(uri) && this.extractElement.equals(loc)) {
                extractLevel--;
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("extractLevel now " + extractLevel + ".");
                }

                if (extractLevel == 0) {
                    // finish building the fragment. remove existing prefix mappings.
                    Iterator itt = prefixMap.entrySet().iterator();
                    while (itt.hasNext()) {
                        Map.Entry entry = (Map.Entry) itt.next();
                        this.serializer.endPrefixMapping(
                            (String)entry.getKey()
                        );
                    }
                    this.serializer.endDocument();

                    Store store = null;
                    String id = Long.toHexString((hashCode()^HashUtil.hash(requestURI)) + fragmentID);
                    try {
                        store = (Store) this.manager.lookup(Store.TRANSIENT_STORE);
                        store.store(id, this.serializer.getSAXFragment());
                    } catch (ServiceException se) {
                        throw new SAXException("Could not lookup for transient store.", se);
                    } catch (IOException ioe) {
                        throw new SAXException("Could not store fragment.", ioe);
                    } finally {
                        this.manager.release(store);
                        this.manager.release(this.serializer);
                        this.serializer = null;
                    }

                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("Stored document " + id + ".");
                    }

                    // Insert ref.
                    super.startPrefixMapping("fe", FE_URI);
                    AttributesImpl atts = new AttributesImpl();
                    atts.addAttribute("", "fragment-id", "fragment-id", "CDATA", id);
                    super.startElement(FE_URI, "fragment", "fe:fragment", atts);
                    super.endElement(FE_URI, "fragment", "fe:fragment");
                    super.endPrefixMapping("fe");
                }
            }
        }
    }
15550#/**
     * Receive notification of character data.
     *
     * @param c The characters from the XML document.
     * @param start The start position in the array.
     * @param len The number of characters to read from the array.
     */
    public void characters(char c[], int start, int len)
    throws SAXException {
        if (extractLevel == 0) {
            super.characters(c, start, len);
        } else {
            this.serializer.characters(c, start, len);
        }
    }
15551#/**
     * Receive notification of ignorable whitespace in element content.
     *
     * @param c The characters from the XML document.
     * @param start The start position in the array.
     * @param len The number of characters to read from the array.
     */
    public void ignorableWhitespace(char c[], int start, int len)
    throws SAXException {
        if (extractLevel == 0) {
            super.ignorableWhitespace(c, start, len);
        } else {
            this.serializer.ignorableWhitespace(c, start, len);
        }
    }
15552#/**
     * Receive notification of a processing instruction.
     *
     * @param target The processing instruction target.
     * @param data The processing instruction data, or null if none was
     *             supplied.
     */
    public void processingInstruction(String target, String data)
    throws SAXException {
        if (extractLevel == 0) {
            super.processingInstruction(target, data);
        } else {
            this.serializer.processingInstruction(target, data);
        }
    }
15553#/**
     * Receive notification of a skipped entity.
     *
     * @param name The name of the skipped entity.  If it is a  parameter
     *             entity, the name will begin with '%'.
     */
    public void skippedEntity(String name)
    throws SAXException {
        if (extractLevel == 0) {
            super.skippedEntity(name);
        } else {
            this.serializer.skippedEntity(name);
        }
    }
15554#/**
     * Report the start of DTD declarations, if any.
     *
     * @param name The document type name.
     * @param publicId The declared public identifier for the external DTD
     *                 subset, or null if none was declared.
     * @param systemId The declared system identifier for the external DTD
     *                 subset, or null if none was declared.
     */
    public void startDTD(String name, String publicId, String systemId)
    throws SAXException {
        if (extractLevel == 0) {
            super.startDTD(name, publicId, systemId);
        } else {
            throw new SAXException(
                "Recieved startDTD after beginning fragment extraction process."
            );
        }
    }
15555#/**
     * Report the end of DTD declarations.
     */
    public void endDTD()
    throws SAXException {
        if (extractLevel == 0) {
            super.endDTD();
        } else {
            throw new SAXException(
                "Recieved endDTD after beginning fragment extraction process."
            );
        }
    }
15556#/**
     * Report the beginning of an entity.
     *
     * @param name The name of the entity. If it is a parameter entity, the
     *             name will begin with '%'.
     */
    public void startEntity(String name)
    throws SAXException {
        if (extractLevel == 0) {
            super.startEntity(name);
        } else {
            this.serializer.startEntity(name);
        }
    }
15557#/**
     * Report the end of an entity.
     *
     * @param name The name of the entity that is ending.
     */
    public void endEntity(String name)
    throws SAXException {
        if (extractLevel == 0) {
            super.endEntity(name);
        } else {
            this.serializer.endEntity(name);
        }
    }
15558#/**
     * Report the start of a CDATA section.
     */
    public void startCDATA()
    throws SAXException {
        if (extractLevel == 0) {
            super.startCDATA();
        } else {
            this.serializer.startCDATA();
        }
    }
15559#/**
     * Report the end of a CDATA section.
     */
    public void endCDATA()
    throws SAXException {
        if (extractLevel == 0) {
            super.endCDATA();
        } else {
            this.serializer.endCDATA();
        }
    }
15560#/**
     * Report an XML comment anywhere in the document.
     *
     * @param ch An array holding the characters in the comment.
     * @param start The starting position in the array.
     * @param len The number of characters to use from the array.
     */
    public void comment(char ch[], int start, int len)
    throws SAXException {
        if (extractLevel == 0) {
            super.comment(ch, start, len);
        } else {
            this.serializer.comment(ch, start, len);
        }
    }
15561#/** BEGIN SitemapComponent methods **/
    public void setup(SourceResolver resolver,
                      Map objectModel,
                      String source,
                      Parameters parameters)
    throws ProcessingException, SAXException, IOException {
        this.counter=0;
        this.currentBlocknr=0;
        this.skip=false;
        this.foundIt=false;
        this.parentName=null;
        this.elementName = parameters.getParameter(ELEMENT, "");
        this.count = parameters.getParameterAsInteger(COUNT, DEFAULT_COUNT);
        this.blocknr = parameters.getParameterAsInteger(BLOCKNR, DEFAULT_BLOCK);
        if (this.elementName == null || this.elementName.equals("") || this.count == 0)  {
            throw new ProcessingException("FilterTransformer: both "+ ELEMENT + " and " +
            COUNT + " parameters need to be specified");
        }
    }
15562#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     * This method must be invoked before the generateValidity() method.
     *
     * @return The generated key or <code>0</code> if the component
     *              is currently not cacheable.
     */
    public java.io.Serializable getKey() {
        return this.elementName + '<' + this.count + '>' + this.blocknr;
    }
15563#/**
     * Generate the validity object.
     * Before this method can be invoked the generateKey() method
     * must be invoked.
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity() {
        return NOPValidity.SHARED_INSTANCE;
    }
15564#/** BEGIN SAX ContentHandler handlers **/
    public void startElement(String uri, String name, String raw, Attributes attributes)
    throws SAXException {
        if (name.equalsIgnoreCase(elementName)) {
            this.foundIt = true;
            this.counter++;
            if (this.counter <= (this.count*(this.blocknr)) && this.counter > (this.count*(this.blocknr-1))) {
                this.skip = false;
            } else  {
                this.skip = true;
            }
            if (this.currentBlocknr != (int)Math.ceil((float)this.counter/this.count)) {
                this.currentBlocknr = (int)Math.ceil((float)this.counter/this.count);
                AttributesImpl attr = new AttributesImpl();
                attr.addAttribute("", BLOCKID, BLOCKID, "CDATA", String.valueOf(this.currentBlocknr));
                if (this.counter < this.count)  {
                    super.contentHandler.startElement("", BLOCK, BLOCK, attr);
                } else  {
                    // fix Bugzilla Bug 13904, check if counter == 1
                    // in this case there is no startElement("", BLOCK, BLOCK)
                    // written, yet
                    if (this.counter > 1) {
                        super.contentHandler.endElement("", BLOCK, BLOCK);
                    }
                    super.contentHandler.startElement("", BLOCK, BLOCK, attr);
                }
            }
        } else if (!this.foundIt)  {
            this.parentName = name;
        }
        if (!this.skip)  {
            super.contentHandler.startElement(uri,name,raw,attributes);
        }
    }
15565#public void endElement(String uri,String name,String raw)
    throws SAXException  {
        if (this.foundIt && name.equals(this.parentName)) {
            // FIXME: VG: This will fail on XML like:
            // <parent>
            //   <element>
            //     <parent>
            super.contentHandler.endElement("", BLOCK, BLOCK);
            super.contentHandler.endElement(uri, name, raw);
            this.foundIt = false;
            this.skip = false;
        } else if (!this.skip)  {
            super.contentHandler.endElement(uri,name,raw);
        }
    }
15566#public void characters(char c[], int start, int len)
    throws SAXException {
        if (!this.skip)  {
            super.contentHandler.characters(c,start,len);
        }
    }
15567#public void processingInstruction(String target, String data)
    throws SAXException {
        if (!this.skip)  {
            super.contentHandler.processingInstruction(target, data);
        }
    }
15568#public void startEntity(String name)
    throws SAXException {
        if (!this.skip)  {
            super.lexicalHandler.startEntity(name);
        }
    }
15569#public void endEntity(String name)
    throws SAXException {
        if (!this.skip)  {
            super.lexicalHandler.endEntity( name);
        }
    }
15570#public void startCDATA()
    throws SAXException {
        if (!this.skip)  {
            super.lexicalHandler.startCDATA();
        }
    }
15571#public void endCDATA()
    throws SAXException {
        if (!this.skip)  {
            super.lexicalHandler.endCDATA();
        }
    }
15572#public void comment(char ch[], int start, int len)
    throws SAXException {
        if (!this.skip)  {
            super.lexicalHandler.comment(ch, start, len);
        }
    }
15573#public void setup(SourceResolver resolver, Map objectModel, String src,
                      Parameters params)
    throws ProcessingException, SAXException, IOException {
        // nothing needed
	}
15574#public Serializable getKey() {
        return "1";
    }
15575#public SourceValidity getValidity() {
        return NOPValidity.SHARED_INSTANCE;
    }
15576#public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
        // no prefix
    }
15577#public void endPrefixMapping(String prefix) throws SAXException {
        // no prefix
    }
15578#public void startElement(String uri, String localName, String qName, Attributes attr)
    throws SAXException {
        super.startElement(EMPTY_NS, localName, localName, attr);
    }
15579#public void endElement(String uri, String localName, String qName)
    throws SAXException {
        super.endElement(EMPTY_NS, localName, localName);
    }
15580#/**
     * Configure this transformer.
     */
    public void configure(Configuration conf)
    throws ConfigurationException {
        Configuration child;

        child = conf.getChild("use-request-parameters");
        this.useParameters = child.getValueAsBoolean(false);
        this._useParameters = this.useParameters;

        child = conf.getChild("use-cookies");
        this.useCookies = child.getValueAsBoolean(false);
        this._useCookies = this.useCookies;

        child = conf.getChild("use-session-info");
        this.useSessionInfo = child.getValueAsBoolean(false);
        this._useSessionInfo = this.useSessionInfo;

        child = conf.getChild("xslt-processor-role");
        String xsltProcessorRole = child.getValue(XSLTProcessor.class.getName());
        if (!xsltProcessorRole.startsWith(XSLTProcessor.class.getName())) {
            xsltProcessorRole = XSLTProcessor.class.getName() + '/' + xsltProcessorRole;
        }

        child = conf.getChild("check-includes");
        this.checkIncludes = child.getValueAsBoolean(this.checkIncludes);

        child = conf.getChild("default-src",false);
        if(child!=null) {
            this.defaultSrc = child.getValue();
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Use parameters is " + this.useParameters);
            getLogger().debug("Use cookies is " + this.useCookies);
            getLogger().debug("Use session info is " + this.useSessionInfo);
            getLogger().debug("Use TrAX Processor " + xsltProcessorRole);
            getLogger().debug("Check for included stylesheets is " + this.checkIncludes);
            getLogger().debug("Default source = " + this.defaultSrc);
        }

        try {
            this.xsltProcessor = (XSLTProcessor) this.manager.lookup(xsltProcessorRole);
        } catch (ServiceException e) {
            throw new ConfigurationException("Cannot load XSLT processor", e);
        }

        try {
            // see the recyle() method to see what we need this for
            Class dtmManagerClass = Class.forName("org.apache.xml.dtm.DTMManager");
            xalanDtmManagerGetIncrementalMethod = dtmManagerClass.getMethod("getIncremental", null);
        } catch (ClassNotFoundException e) {
            // do nothing -- user does not use xalan, so we don't need the dtm manager
        } catch (NoSuchMethodException e) {
            throw new ConfigurationException("Was not able to get getIncremental method from Xalan's DTMManager.", e);
        }
    }
15581#/**
     * Set the current <code>ServiceManager</code> instance used by this
     * <code>Serviceable</code>.
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
15582#/**
     * Set the <code>SourceResolver</code>, the <code>Map</code> with
     * the object model, the source and sitemap
     * <code>Parameters</code> used to process the request.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws SAXException, ProcessingException, IOException {

        if(src==null && defaultSrc!=null) {
            if(getLogger().isDebugEnabled()) {
                getLogger().debug("src is null, using default source " + defaultSrc);
            }
            src = defaultSrc;
        }

        if (src == null) {
            throw new ProcessingException("Stylesheet URI can't be null");
        }

        this.par = par;
        this.objectModel = objectModel;
        this.resolver = resolver;
        try {
            this.inputSource = resolver.resolveURI(src);
        } catch (SourceException se) {
            throw SourceUtil.handle("Unable to resolve " + src, se);
        }
        _useParameters = par.getParameterAsBoolean("use-request-parameters", this.useParameters);
        _useCookies = par.getParameterAsBoolean("use-cookies", this.useCookies);
        _useSessionInfo = par.getParameterAsBoolean("use-session-info", this.useSessionInfo);
        final boolean _checkIncludes = par.getParameterAsBoolean("check-includes", this.checkIncludes);

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Using stylesheet: '" + this.inputSource.getURI() + "' in " + this);
            getLogger().debug("Use parameters is " + this._useParameters);
            getLogger().debug("Use cookies is " + this._useCookies);
            getLogger().debug("Use session info is " + this._useSessionInfo);
            getLogger().debug("Check for included stylesheets is " + _checkIncludes);
        }

        // Get a Transformer Handler if we check for includes
        // If we don't check the handler is get during setConsumer()
        try {
            if ( _checkIncludes ) {
                XSLTProcessor.TransformerHandlerAndValidity handlerAndValidity =
                        this.xsltProcessor.getTransformerHandlerAndValidity(this.inputSource, null);
                this.transformerHandler = handlerAndValidity.getTransfomerHandler();
                this.transformerValidity = handlerAndValidity.getTransfomerValidity();
            } else {
                this.transformerValidity = this.inputSource.getValidity();
            }
        } catch (XSLTProcessorException se) {
            throw new ProcessingException("Unable to get transformer handler for " + this.inputSource.getURI(), se);
        }
    }
15583#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     *
     * @return The generated key hashes the src
     */
    public Serializable getKey() {
        Map map = getLogicSheetParameters();
        if (map == null) {
            return this.inputSource.getURI();
        }

        StringBuffer sb = new StringBuffer();
        sb.append(this.inputSource.getURI());
        Set entries = map.entrySet();
        for(Iterator i=entries.iterator(); i.hasNext();){
            sb.append(';');
            Map.Entry entry = (Map.Entry)i.next();
            sb.append(entry.getKey());
            sb.append('=');
            sb.append(entry.getValue());
        }
        return sb.toString();
    }
15584#/**
     * Generate the validity object.
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity() {
        //
        // VG: Key is generated using parameter/value pairs,
        // so this information does not need to be verified again
        // (if parameter added/removed or value changed, key should
        // change also), only stylesheet's validity is included.
        //
        return this.transformerValidity;
    }
15585#/**
     * Set the <code>XMLConsumer</code> that will receive XML data.
     */
    public void setConsumer(XMLConsumer consumer) {

        if ( this.transformerHandler == null ) {
            try {
                this.transformerHandler = this.xsltProcessor.getTransformerHandler(this.inputSource);
            } catch (XSLTProcessorException se) {
                // the exception will be thrown during startDocument()
                this.exceptionDuringSetConsumer =
                   new SAXException("Unable to get transformer handler for " + this.inputSource.getURI(), se);
                return;
            }
        }
        final Map map = getLogicSheetParameters();
        if (map != null) {
            final javax.xml.transform.Transformer transformer = this.transformerHandler.getTransformer();
            final Iterator iterator = map.entrySet().iterator();
            while (iterator.hasNext()) {
                final Map.Entry entry = (Entry) iterator.next();
                transformer.setParameter((String)entry.getKey(), entry.getValue());
            }
        }

        super.setContentHandler(this.transformerHandler);
        super.setLexicalHandler(this.transformerHandler);
        // Is there even single implementation of LogEnabled TransformerHandler?
        if (this.transformerHandler instanceof LogEnabled) {
            ((LogEnabled) this.transformerHandler).enableLogging(new CLLoggerWrapper(getLogger()));
        }
        // According to TrAX specs, all TransformerHandlers are LexicalHandlers
        final SAXResult result = new SAXResult(consumer);
        result.setLexicalHandler(consumer);
        this.transformerHandler.setResult(result);

        this.errorListener = new TraxErrorListener(this.inputSource.getURI());
        this.transformerHandler.getTransformer().setErrorListener(this.errorListener);
    }
15586#/**
     * Get the parameters for the logicsheet
     */
    protected Map getLogicSheetParameters() {
        if (this.logicSheetParameters != null) {
            return this.logicSheetParameters;
        }
        HashMap map = null;
        if (par != null) {
            String[] params = par.getNames();
            if (params != null) {
                for(int i = 0; i < params.length; i++) {
                    String name = params[i];
                    if (isValidXSLTParameterName(name)) {
                        String value = par.getParameter(name,null);
                        if (value != null) {
                            if (map == null) {
                                map = new HashMap(params.length);
                            }
                            map.put(name,value);
                        }
                    }
                }
            }
        }

        if (this._useParameters) {
            Request request = ObjectModelHelper.getRequest(objectModel);

            Enumeration parameters = request.getParameterNames();
            if (parameters != null) {
                while (parameters.hasMoreElements()) {
                    String name = (String) parameters.nextElement();
                    if (isValidXSLTParameterName(name)) {
                        String value = request.getParameter(name);
                        if (map == null) {
                            map = new HashMap();
                        }
                        map.put(name,value);
                    }
                }
            }
        }

        if (this._useSessionInfo) {
            final Request request = ObjectModelHelper.getRequest(objectModel);
            if (map == null) {
                map = new HashMap(6);
            }

            final HttpSession session = request.getSession(false);
            if (session != null) {
                map.put("session-available", "true");
                map.put("session-is-new", BooleanUtils.toStringTrueFalse(session.isNew()));
                map.put("session-id-from-cookie", BooleanUtils.toStringTrueFalse(request.isRequestedSessionIdFromCookie()));
                map.put("session-id-from-url", BooleanUtils.toStringTrueFalse(request.isRequestedSessionIdFromURL()));
                map.put("session-valid", BooleanUtils.toStringTrueFalse(request.isRequestedSessionIdValid()));
                map.put("session-id", session.getId());
            } else {
                map.put("session-available", "false");
            }
        }

        if (this._useCookies) {
            Request request = ObjectModelHelper.getRequest(objectModel);
            Cookie cookies[] = request.getCookies();
            if (cookies != null) {
                for (int i = 0; i < cookies.length; i++) {
                    String name = cookies[i].getName();
                    if (isValidXSLTParameterName(name)) {
                        String value = cookies[i].getValue();
                        if (map == null) {
                            map = new HashMap(cookies.length);
                        }
                        map.put(name,value);
                    }
                }
            }
        }
        this.logicSheetParameters = map;
        return this.logicSheetParameters;
    }
15587#/**
     * Test if the name is a valid parameter name for XSLT
     */
    static boolean isValidXSLTParameterName(String name) {
        if (name.length() == 0) {
            return false;
        }

        char c = name.charAt(0);
        if (!(Character.isLetter(c) || c == '_')) {
            return false;
        }

        for (int i = name.length()-1; i > 1; i--) {
            c = name.charAt(i);
            if (!(Character.isLetterOrDigit(c) ||
                    c == '-' ||
                    c == '_' ||
                    c == '.')) {
                return false;
            }
        }
        return true;
    }
15588#/**
     * Disposable
     */
    public void dispose() {
        if ( this.manager != null ) {
            this.manager.release(this.xsltProcessor);
            this.xsltProcessor = null;
            this.manager = null;
        }
    }
15589#/**
     * Recyclable
     */
    public void recycle() {
        this.objectModel = null;
        if (this.inputSource != null) {
            this.resolver.release(this.inputSource);
            this.inputSource = null;
        }
        this.resolver = null;
        this.par = null;
        if (!this.finishedDocument && transformerHandler != null) {
            // This situation will only occur if an exception occured during pipeline execution.
            // If Xalan is used in incremental mode, it is important that endDocument is called, otherwise
            // the thread on which it runs the transformation will keep waiting.
            // However, calling endDocument will cause the pipeline to continue executing, and thus the
            // serializer will write output to the outputstream after what's already there (the error page),
            // see also bug 13186.
            if (xalanDtmManagerGetIncrementalMethod != null
                && transformerHandler.getClass().getName().equals("org.apache.xalan.transformer.TransformerHandlerImpl")) {
                try {
                    final boolean incremental = ((Boolean)xalanDtmManagerGetIncrementalMethod.invoke(null, null)).booleanValue();
                    if (incremental) {
                        super.endDocument();
                    }
                } catch (Exception ignore) {}
            }
        }
        this.finishedDocument = true;
        this.logicSheetParameters = null;
        this.transformerHandler = null;
        this.transformerValidity = null;
        this.exceptionDuringSetConsumer = null;
        this.errorListener = null;
        super.recycle();
    }
15590#/**
     * Fix for stopping hanging threads of Xalan
     */
    public void endDocument()
    throws SAXException {
        try {
            super.endDocument();
        } catch(Exception e) {

            Throwable realEx = this.errorListener.getThrowable();
            if (realEx == null) realEx = e;

            if (realEx instanceof RuntimeException) {
                throw (RuntimeException)realEx;
            }

            if (realEx instanceof SAXException) {
                throw (SAXException)realEx;
            }

            if (realEx instanceof Error) {
                throw (Error)realEx;
            }

            throw new NestableRuntimeException(realEx);
        }
        this.finishedDocument = true;
    }
15591#/* (non-Javadoc)
     * @see org.xml.sax.ContentHandler#startDocument()
     */
    public void startDocument() throws SAXException {
        // did an exception occur during setConsumer?
        // if so, throw it here
        if ( this.exceptionDuringSetConsumer != null ) {
            throw this.exceptionDuringSetConsumer;
        }
        this.finishedDocument = false;
        super.startDocument();
    }
15592#/**
     * Set the current <code>ServiceManager</code> instance used by this
     * <code>Serviceable</code>.
     *
     * @param  manager  Description of the Parameter
     */
    public void service(ServiceManager manager) throws ServiceException {
        try {
            this.manager = manager;
            getLogger().debug("Looking up "+SAXParser.ROLE);
            this.parser = (SAXParser) manager.lookup(SAXParser.ROLE);

            getLogger().debug("Looking up " + Store.TRANSIENT_STORE);
            this.store = (Store) manager.lookup(Store.TRANSIENT_STORE);
        } catch (Exception e) {
            getLogger().error("Could not find component", e);
        }
    }
15593#/**
     * Dispose this component.
     */
    public void dispose() {
        if (this.parser!=null) {
            this.manager.release(this.parser);
        } else {
            this.parser = null;
        }
        if (this.store!=null) {
            this.manager.release(this.store);
        } else {
            this.store = null;
        }
    }
15594#/**
     * Setup the transformer.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src,
                      Parameters par)
                        throws ProcessingException, SAXException,
                               IOException {
      
      // FIXME: service is not called when in spring
      // making parser null. 
      if(null==this.parser){
        getLogger().debug("Looking up "+SAXParser.ROLE);
        try {
          this.parser = (SAXParser) manager.lookup(SAXParser.ROLE);
        } catch (ServiceException e) {
            throw new ProcessingException("Could not lookup '" +
                SAXParser.ROLE + "'");
        }
      }

        if (src == null) {
            throw new ProcessingException("I need the paginate instructions (pagesheet) to continue. Set the 'src' attribute.");
        }

        try {
            this.level = 0;
            this.prefixMapping = false;
            this.resolver = resolver;
            this.inputSource = resolver.resolveURI(src);
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Using pagesheet: '"+
                                  this.inputSource.getURI()+"' in "+this+
                                  ", last modified: "+
                                  this.inputSource.getLastModified());
            }
            this.page = par.getParameterAsInteger("page", 1);
            this.item = par.getParameterAsInteger("item", 0);
            this.itemGroup = par.getParameter("item-group", "");
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Paginating with [page = "+this.page+
                                  ", item = "+this.item+", item-group = "+
                                  this.itemGroup+"]");
            }

            this.request = ObjectModelHelper.getRequest(objectModel);
            this.requestURI = request.getRequestURI();

            // Get the pagesheet factory from the Store if available,
            // otherwise load it and put it into the store for further request
            if (store!=null) {
                pagesheet = (Pagesheet) store.get(src);
            }

            // If not in the store or if pagesheet has changed, loads and stores it
            if ((pagesheet==null) ||
                pagesheet.modifiedSince(inputSource.getLastModified())) {
                pagesheet = new Pagesheet();
                pagesheet.setLastModified(inputSource.getLastModified());
                parser.parse(new InputSource(inputSource.getInputStream()),
                             pagesheet);
                if (store!=null) {
                    store.store(src, pagesheet);
                }
            }

            // Clone it in order to avoid concurrency collisions since the
            // implementation is not reentrant.
            this.pagesheet = (Pagesheet) this.pagesheet.clone();
        } catch (SourceException se) {
            throw new ProcessingException("Could not retrieve source '" +
                                          src + "'", se);
        }
    }
15595#public void recycle() {
        if (null != this.inputSource) {
            this.resolver.release(this.inputSource);
            this.inputSource = null;
        }
        this.resolver = null;
        super.recycle();
    }
15596#/**
     * Generate the unique key. This key must be unique inside the space of
     * this component. This method must be invoked before the
     * generateValidity() method.
     *
     * @return The generated key or <code>null</code> if the component is
     *         currently not cacheable.
     */
    public Serializable getKey() {
        if (this.inputSource.getLastModified()!=0) {
            return this.inputSource.getURI()+page;
        } else {
            return null;
        }
    }
15597#/**
     * Generate the validity object. Before this method can be invoked the
     * generateKey() method must be invoked.
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity() {
        if (this.inputSource.getLastModified()!=0) {
            AggregatedValidity validity = new AggregatedValidity();

            validity.add(new TimeStampValidity(page));
            validity.add(this.inputSource.getValidity());
            return validity;
        } else {
            return null;
        }
    }
15598#/**
     * Receive notification of the beginning of an element.
     *
     * @param uri The Namespace URI, or the empty string if the
     *            element has no Namespace URI or if Namespace processing is not being
     *            performed.
     * @param loc The local name (without prefix), or the empty
     *            string if Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty
     *            string if raw names are not available.
     * @param a The attributes attached to the element. If there
     *          are no attributes, it shall be an empty Attributes object.
     */
    public void startElement(String uri, String loc, String raw,
                             Attributes a) throws SAXException {
        if ( !prefixMapping) {
            super.startPrefixMapping(PAGINATE_PREFIX, PAGINATE_URI);
            this.prefixMapping = true;
        }
        level++;
        pagesheet.processStartElement(uri, loc);
        if (pagesheet.isInPage(page, item, itemGroup)) {
            int itemCount = pagesheet.itemCount(uri, loc);

            if (itemCount>0) {
                String itemGroup = pagesheet.getItemGroupName(uri, loc);
                AttributesImpl atts = new AttributesImpl(a);

                atts.addAttribute(PAGINATE_URI, "item",
                                  PAGINATE_PREFIX_TOKEN+"item", "CDATA",
                                  String.valueOf(itemCount));
                atts.addAttribute(PAGINATE_URI, "item-group",
                                  PAGINATE_PREFIX_TOKEN+"item-group",
                                  "CDATA", itemGroup);
                super.startElement(uri, loc, raw, atts);
            } else {
                super.startElement(uri, loc, raw, a);
            }
        }
    }
15599#/**
     * Receive notification of the end of an element.
     *
     * @param uri The Namespace URI, or the empty string if the
     *            element has no Namespace URI or if Namespace processing is not being
     *            performed.
     * @param loc The local name (without prefix), or the empty
     *            string if Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty
     *            string if raw names are not available.
     */
    public void endElement(String uri, String loc,
                           String raw) throws SAXException {
        level--;

        // Prevent infinite recursive loop.
        if (PAGINATE_URI.equals(uri)) {
            super.endElement(uri, loc, raw);
            return;
        }

        if (pagesheet.isInPage(page, item, itemGroup)) {
            if (level==0) {
                if (item==0) {
                    int totalPages = pagesheet.getTotalPages();
                    PageRules rules = pagesheet.getPageRules(page);

                    Integer[] rangeLinks = rules.getRangeLinks();
                    int unitLinks = rules.unitLinks;
                    int currentPage = page;

                    // call add paginate
                    addPaginateTags(rangeLinks, unitLinks, currentPage,
                                    totalPages, requestURI, this);

                } else {
                    int totalItems = pagesheet.getTotalItems(itemGroup);
                    AttributesImpl atts = new AttributesImpl();

                    atts.addAttribute("", "current", "current", "CDATA",
                                      String.valueOf(item));
                    atts.addAttribute("", "total", "total", "CDATA",
                                      String.valueOf(totalItems));
                    atts.addAttribute("", "current-uri", "current-uri",
                                      "CDATA", requestURI);
                    atts.addAttribute("", "clean-uri", "clean-uri",
                                      "CDATA", cleanURI(requestURI, item));
                    atts.addAttribute("", "page", "page", "CDATA",
                                      String.valueOf(pagesheet.getPageForItem(item,
                                          itemGroup)));
                    super.startElement(PAGINATE_URI, "item",
                                       PAGINATE_PREFIX_TOKEN+"item", atts);
                    if (item>1) {
                        atts.clear();
                        atts.addAttribute("", "type", "type", "CDATA",
                                          "prev");
                        atts.addAttribute("", "uri", "uri", "CDATA",
                                          encodeURI(requestURI, item,
                                                    item-1));
                        super.startElement(PAGINATE_URI, "link",
                                           PAGINATE_PREFIX_TOKEN+"link",
                                           atts);
                        super.endElement(PAGINATE_URI, "link",
                                         PAGINATE_PREFIX_TOKEN+"link");
                    }
                    if (item<=totalItems) {
                        atts.clear();
                        atts.addAttribute("", "type", "type", "CDATA",
                                          "next");
                        atts.addAttribute("", "uri", "uri", "CDATA",
                                          encodeURI(requestURI, item,
                                                    item+1));
                        super.startElement(PAGINATE_URI, "link",
                                           PAGINATE_PREFIX_TOKEN+"link",
                                           atts);
                        super.endElement(PAGINATE_URI, "link",
                                         PAGINATE_PREFIX_TOKEN+"link");
                    }
                    super.endElement(PAGINATE_URI, "item",
                                     PAGINATE_PREFIX_TOKEN+"item");
                }

                super.endPrefixMapping(PAGINATE_PREFIX);
            }

            super.endElement(uri, loc, raw);
        }

        pagesheet.processEndElement(uri, loc);
    }
15600#public static void addPaginateTags(Integer[] rangeLinks, int unitLinks,
                                       int currentPage, int totalPages,
                                       String requestURI,
                                       AbstractTransformer saxTransformer)
                                         throws SAXException {
        AttributesImpl atts = new AttributesImpl();

        atts.addAttribute("", "current", "current", "CDATA",
                          String.valueOf(currentPage));
        atts.addAttribute("", "total", "total", "CDATA",
                          String.valueOf(totalPages));
        atts.addAttribute("", "current-uri", "current-uri", "CDATA",
                          requestURI);
        atts.addAttribute("", "clean-uri", "clean-uri", "CDATA",
                          Paginator.cleanURI(requestURI, currentPage));
        saxTransformer.startElement(Paginator.PAGINATE_URI, "page",
                                    Paginator.PAGINATE_PREFIX_TOKEN+"page",
                                    atts);

        for (int i = rangeLinks.length-1; i>-1; i--) {
            int rangeLink = rangeLinks[i].intValue();

            if ((rangeLink>0) && (currentPage-rangeLink>=1)) {
                atts.clear();
                atts.addAttribute("", "type", "type", "CDATA", "prev");
                atts.addAttribute("", "range", "range", "CDATA",
                                  rangeLinks[i].toString());
                atts.addAttribute("", "uri", "uri", "CDATA",
                                  Paginator.encodeURI(requestURI,
                                                      currentPage,
                                                      currentPage-rangeLink));
                atts.addAttribute("", "page", "page", "CDATA",
                                  String.valueOf(currentPage-rangeLink));
                saxTransformer.startElement(Paginator.PAGINATE_URI,
                                            "range-link",
                                            Paginator.PAGINATE_PREFIX_TOKEN+
                                            "range-link", atts);
                saxTransformer.endElement(Paginator.PAGINATE_URI,
                                          "range-link",
                                          Paginator.PAGINATE_PREFIX_TOKEN+
                                          "range-link");
            }
        }

        for (int i = currentPage-unitLinks; i<currentPage; i++) {
            if (i>0) {
                atts.clear();
                atts.addAttribute("", "type", "type", "CDATA", "prev");
                atts.addAttribute("", "uri", "uri", "CDATA",
                                  Paginator.encodeURI(requestURI,
                                                      currentPage, i));
                atts.addAttribute("", "page", "page", "CDATA",
                                  String.valueOf(i));
                saxTransformer.startElement(Paginator.PAGINATE_URI, "link",
                                            Paginator.PAGINATE_PREFIX_TOKEN+
                                            "link", atts);
                saxTransformer.endElement(Paginator.PAGINATE_URI, "link",
                                          Paginator.PAGINATE_PREFIX_TOKEN+
                                          "link");
            }
        }
        for (int i = currentPage+1; i<=currentPage+unitLinks; i++) {
            if (i<=totalPages) {
                atts.clear();
                atts.addAttribute("", "type", "type", "CDATA", "next");
                atts.addAttribute("", "uri", "uri", "CDATA",
                                  Paginator.encodeURI(requestURI,
                                                      currentPage, i));
                atts.addAttribute("", "page", "page", "CDATA",
                                  String.valueOf(i));
                saxTransformer.startElement(Paginator.PAGINATE_URI, "link",
                                            Paginator.PAGINATE_PREFIX_TOKEN+
                                            "link", atts);
                saxTransformer.endElement(Paginator.PAGINATE_URI, "link",
                                          Paginator.PAGINATE_PREFIX_TOKEN+
                                          "link");
            }
        }

        for (int i = 0; i<rangeLinks.length; i++) {
            int rangeLink = rangeLinks[i].intValue();

            if ((rangeLink>0) && (currentPage+rangeLink<=totalPages)) {
                atts.clear();
                atts.addAttribute("", "type", "type", "CDATA", "next");
                atts.addAttribute("", "range", "range", "CDATA",
                                  rangeLinks[i].toString());
                atts.addAttribute("", "uri", "uri", "CDATA",
                                  Paginator.encodeURI(requestURI,
                                                      currentPage,
                                                      currentPage+rangeLink));
                atts.addAttribute("", "page", "page", "CDATA",
                                  String.valueOf(currentPage+rangeLink));
                saxTransformer.startElement(Paginator.PAGINATE_URI,
                                            "range-link",
                                            Paginator.PAGINATE_PREFIX_TOKEN+
                                            "range-link", atts);
                saxTransformer.endElement(Paginator.PAGINATE_URI,
                                          "range-link",
                                          Paginator.PAGINATE_PREFIX_TOKEN+
                                          "range-link");
            }
        }

        saxTransformer.endElement(Paginator.PAGINATE_URI, "page",
                                  Paginator.PAGINATE_PREFIX_TOKEN+"page");
    }
15601#/**
     * Receive notification of character data.
     *
     * @param c The characters from the XML document.
     * @param start The start position in the array.
     * @param len The number of characters to read from the array.
     */
    public void characters(char c[], int start, int len) throws SAXException {
        pagesheet.processCharacters(c, start, len);
        if (pagesheet.isInPage(page, item, itemGroup)) {
            super.characters(c, start, len);
        }
    }
15602#/**
     * Receive notification of ignorable whitespace in element content.
     *
     * @param c The characters from the XML document.
     * @param start The start position in the array.
     * @param len The number of characters to read from the array.
     */
    public void ignorableWhitespace(char c[], int start,
                                    int len) throws SAXException {
        if (pagesheet.isInPage(page, item, itemGroup)) {
            super.ignorableWhitespace(c, start, len);
        }
    }
15603#/**
     * Receive notification of a processing instruction.
     *
     * @param target The processing instruction target.
     * @param data The processing instruction data, or null if none
     *             was supplied.
     */
    public void processingInstruction(String target,
                                      String data) throws SAXException {
        if (pagesheet.isInPage(page, item, itemGroup)) {
            super.processingInstruction(target, data);
        }
    }
15604#/**
     * Receive notification of a skipped entity.
     *
     * @param name The name of the skipped entity. If it is a
     *             parameter entity, the name will begin with '%'.
     */
    public void skippedEntity(String name) throws SAXException {
        if (pagesheet.isInPage(page, item, itemGroup)) {
            super.skippedEntity(name);
        }
    }
15605#/**
     * Report the start of DTD declarations, if any.
     *
     * @param name The document type name.
     * @param publicId The declared public identifier for the external
     *                 DTD subset, or null if none was declared.
     * @param systemId The declared system identifier for the external
     *                 DTD subset, or null if none was declared.
     */
    public void startDTD(String name, String publicId,
                         String systemId) throws SAXException {
        if (pagesheet.isInPage(page, item, itemGroup)) {
            super.startDTD(name, publicId, systemId);
        } else {
            throw new SAXException("Recieved startDTD not in page.");
        }
    }
15606#/**
     * Report the end of DTD declarations.
     */
    public void endDTD() throws SAXException {
        if (pagesheet.isInPage(page, item, itemGroup)) {
            super.endDTD();
        } else {
            throw new SAXException("Recieved endDTD not in page.");
        }
    }
15607#/**
     * Report the beginning of an entity.
     *
     *@param name The name of the entity. If it is a parameter
     *            entity, the name will begin with '%'.
     */
    public void startEntity(String name) throws SAXException {
        if (pagesheet.isInPage(page, item, itemGroup)) {
            super.startEntity(name);
        }
    }
15608#/**
     * Report the end of an entity.
     *
     * @param name The name of the entity that is ending.
     */
    public void endEntity(String name) throws SAXException {
        if (pagesheet.isInPage(page, item, itemGroup)) {
            super.endEntity(name);
        }
    }
15609#/**
     * Report the start of a CDATA section.
     */
    public void startCDATA() throws SAXException {
        if (pagesheet.isInPage(page, item, itemGroup)) {
            super.startCDATA();
        }
    }
15610#/**
     * Report the end of a CDATA section.
     */
    public void endCDATA() throws SAXException {
        if (pagesheet.isInPage(page, item, itemGroup)) {
            super.endCDATA();
        }
    }
15611#/**
     * Report an XML comment anywhere in the document.
     *
     * @param ch An array holding the characters in the comment.
     * @param start The starting position in the array.
     * @param len The number of characters to use from the array.
     */
    public void comment(char ch[], int start, int len) throws SAXException {
        if (pagesheet.isInPage(page, item, itemGroup)) {
            super.comment(ch, start, len);
        }
    }
15612#/**
     * Removes the pagination encoding from the URI by removing the page number
     * and the previous and next character.
     */
    public static String cleanURI(String uri, int current) {
        String currentS = String.valueOf(current);
        int index = uri.lastIndexOf(currentS);

        if (index==-1) {
            return uri;
        } else {
            return uri.substring(0, index-1)+
                   uri.substring(index+currentS.length()+1);
        }
    }
15613#/**
     * Encode the next page in the given URI. First tries to use the existing
     * encoding by replacing the current page number, but if the current
     * encoding is not found it appends "(xx)" to the filename (before the file
     * extention, if any) where "xx" is the next page value.
     */
    public static String encodeURI(String uri, int current, int next) {
        String currentS = String.valueOf(current);
        String nextS = String.valueOf(next);
        int index = uri.lastIndexOf(currentS);

        if (index==-1) {
            index = uri.lastIndexOf('.');
            if (index==-1) {
                return uri+"("+nextS+")";
            } else {
                return uri.substring(0, index)+"("+nextS+")."+
                       uri.substring(index+1);
            }
        } else {
            return uri.substring(0, index)+nextS+
                   uri.substring(index+currentS.length());
        }
    }
15614#public ServiceManager getManager() {
      return manager;
    }
15615#public void setManager(ServiceManager manager) {
      this.manager = manager;
    }
15616#public ItemGroup (String name, String elementURI, String elementName) {
        this.name = name;
        this.elementURI = elementURI;
        this.elementName = elementName;
    }
15617#public boolean match(String elementName, String elementURI) {
        return (this.elementName.equals(elementName) && this.elementURI.equals(elementURI));
    }
15618#public boolean match(String elementURI) {
        return this.elementURI.equals(elementURI);
    }
15619#public String getName() {
        return this.name;
    }
15620#public String getElementURI() {
        return this.elementURI;
    }
15621#public String getElementName() {
        return this.elementName;
    }
15622#public Pagesheet() {
        this.pages = new ResizableContainer(2);
    }
15623#private Pagesheet(ResizableContainer rules, Map itemGroupsPerName,
                      Map itemGroupsPerElement) {
        this.pageRules = rules;
        this.itemGroupsPerName = itemGroupsPerName;
        this.itemGroupsPerElement = itemGroupsPerElement;

        this.pages = new ResizableContainer(5);

        if ((this.itemGroupsPerName!=null) &&
            (this.itemGroupsPerElement!=null)) {
            this.itemListsPerName = new HashMap(itemGroupsPerName.size());
            this.itemListsPerElement = new HashMap(itemGroupsPerName.size());

            Iterator iter = itemGroupsPerName.values().iterator();

            for (; iter.hasNext(); ) {
                ItemGroup group = (ItemGroup) iter.next();
                ItemList list = new ItemList(10);

                this.itemListsPerName.put(group.getName(), list);
                this.itemListsPerElement.put(group.getElementURI()+
                                             group.getElementName(), list);
            }
        }
    }
15624#// --------------- interprets the pagesheet document ----------------

    public void startPrefixMapping(String prefix,
                                   String uri) throws SAXException {
        if ( !uri.equals(Paginator.PAGINATE_URI)) {
            throw new SAXException("The pagesheet's namespace is not supported.");
        }
    }
15625#public void startElement(String uri, String loc, String raw,
                             Attributes a) throws SAXException {
        level++;
        switch (level) {
            case 1 :
                if (loc.equals("pagesheet")) {
                    // This object represents pagesheet
                    return;
                }
                break;

            case 2 :
                if (loc.equals("rules")) {
                    if (this.pageRules == null) {
                        this.pageRules = new ResizableContainer(2);
                    }
                    String key = a.getValue("page");

                    if (key!=null) {
                        try {
                            pg = Integer.parseInt(key);
                        } catch (NumberFormatException e) {
                            throw new SAXException("Syntax error: the attribute 'rules/@page' must contain a number");
                        }
                    } else {
                        pg = 0;
                    }
                    rules = new PageRules();
                    return;
                } else if (loc.equals("items")) {
                    if (this.itemGroupsPerName==null) {
                        this.itemGroupsPerName = new HashMap(2);
                    }
                    if (this.itemGroupsPerElement==null) {
                        this.itemGroupsPerElement = new HashMap(2);
                    }
                    return;
                }
                break;

            case 3 :
                if (loc.equals("count")) {
                    rules.elementName = a.getValue("name");
                    rules.elementURI = a.getValue("namespace");

                    if (a.getValue("type").equals("element")) {
                        try {
                            rules.elementCount = Integer.parseInt(a.getValue("num"));
                        } catch (NumberFormatException e) {
                            throw new SAXException("Syntax error: the attribute 'count/@num' must contain a number");
                        }
                    } else if (a.getValue("type").equals("chars")) {
                        try {
                            rules.charCount = Integer.parseInt(a.getValue("num"));
                        } catch (NumberFormatException e) {
                            throw new SAXException("Syntax error: the attribute 'count/@num' must contain a number.");
                        }
                    } else {
                        throw new SAXException("Syntax error: count type not supported.");
                    }
                    return;
                } else if (loc.equals("link")) {
                    if (a.getValue("type").equals("unit")) {
                        try {
                            rules.unitLinks = Integer.parseInt(a.getValue("num"));
                        } catch (NumberFormatException e) {
                            throw new SAXException("Syntax error: the attribute 'link/@num' must contain a number.");
                        }
                    } else if (a.getValue("type").equals("range")) {
                        try {
                            rules.addRangeLink(a.getValue("value"));
                        } catch (NumberFormatException e) {
                            throw new SAXException("Syntax error: the attribute 'link/@value' must contain a number.");
                        }
                    } else {
                        throw new SAXException("Syntax error: link type not supported.");
                    }
                    return;
                } else if (loc.equals("group")) {
                    String name = a.getValue("name");

                    if (name==null) {
                        throw new SAXException("Syntax error: the attribute 'group/@name' must be present.");
                    }
                    String elementName = a.getValue("element");

                    if (elementName==null) {
                        throw new SAXException("Syntax error: the attribute 'group/@element' must be present.");
                    }
                    String elementURI = a.getValue("namespace");
                    ItemGroup group = new ItemGroup(name, elementURI,
                                                    elementName);

                    this.itemGroupsPerName.put(name, group);
                    this.itemGroupsPerElement.put(elementURI+elementName,
                                                  group);
                    return;
                }
        }
        throw new SAXException("Syntax error: element "+raw+
                               " is not recognized or is misplaced.");
    }
15626#public void endElement(String uri, String loc,
                           String raw) throws SAXException {
        level--;
        if (loc.equals("rules")) {
            pageRules.set(pg, rules);
        }
    }
15627#public void endDocument() throws SAXException {
        if (pageRules.size() == 0) {
            throw new SAXException("Pagesheet must contain at least a set of pagination rules.");
        }
        if (pageRules.get(0) == null) {
            throw new SAXException("Pagesheet must contain the global pagination rules.");
        }
    }
15628#// --------------- process the received element events ----------------

    public void processStartElement(String uri, String name) {
        PageRules rules = getPageRules(pageCounter);

        if (rules.match(name, uri)) {
            elementCounter++;
            descendant++;

            if (currentPage==null) {
                currentPage = new Page(rules, 1);
            }

            if (elementCounter>currentPage.elementEnd) {
                /*System.out.println(">>>> "+pageCounter+
                                   ": Starting new page!!! >>> "+
                                   elementCounter);*/
                pageCounter++;
                currentPage = new Page(rules, currentPage.elementEnd+1);
            }

            pages.set(pageCounter, currentPage);
        }

        if (itemGroupsPerElement!=null) {
            String qname = uri+name;
            ItemGroup group = (ItemGroup) this.itemGroupsPerElement.get(qname);

            if ((group!=null) && (group.match(uri))) {
                ItemList list = (ItemList) this.itemListsPerElement.get(qname);

                if (list!=null) {
                    list.addItem(pageCounter);
                }
            }
        }
    }
15629#public void processEndElement(String uri, String name) {
        PageRules rules = getPageRules(pageCounter);

        if (rules.match(name, uri)) {
            descendant--;

            if ((rules.charCount>0) &&
                (currentPage.characters>rules.charCount)) {
                // We are over character limit. Flip the page.
                // System.out.println(">>>> " + pageCounter + ": Flipping page!!!");
                currentPage.elementEnd = elementCounter;
            } else if (rules.elementCount==0) {
                // No limit on elements is specified, and limit on characters is not reached yet.
                currentPage.elementEnd++;
            }
        }
    }
15630#public void processCharacters(char[] ch, int index, int len) {
        if (descendant>0) {
            // Count amount of characters in the currect page.
            // System.out.println(">>>> " + pageCounter + ": " + new String(ch, index, len) + " (" + len + " bytes)");
            currentPage.characters += len;
        }
    }
15631#// --------------- return the pagination information ----------------

    public boolean isInPage(int page, int item, String itemGroup) {
        return ((descendant==0) || valid(page, item, itemGroup));
    }
15632#public int getTotalPages() {
        return pageCounter;
    }
15633#public int getTotalItems(String itemGroup) {
        if (this.itemListsPerName==null) {
            return 0;
        }
        ItemList list = (ItemList) this.itemListsPerName.get(itemGroup);

        return (list==null) ? 0 : list.size();
    }
15634#public int getPageForItem(int item, String itemGroup) {
        if (this.itemListsPerName==null) {
            return 0;
        }
        ItemList list = (ItemList) this.itemListsPerName.get(itemGroup);

        return (list==null) ? 0 : list.getPageForItem(item);
    }
15635#public int itemCount(String elementURI, String elementName) {
        if (this.itemListsPerElement==null) {
            return 0;
        }
        ItemList list = (ItemList) this.itemListsPerElement.get(elementURI+
                            elementName);

        return (list==null) ? 0 : list.size();
    }
15636#public String getItemGroupName(String elementURI, String elementName) {
        if (this.itemListsPerElement==null) {
            return null;
        }
        return ((ItemGroup) this.itemGroupsPerElement.get(elementURI+
            elementName)).getName();
    }
15637#// ---------------- miscellaneous methods ----------------------------

    private boolean valid(int page, int item, String itemGroup) {
        if (item==0) {
            Page p = (Page) pages.get(page);

            return (p!=null) && (p.validInPage(elementCounter));
        } else {
            if (this.itemListsPerElement==null) {
                return false;
            }
            ItemList list = (ItemList) this.itemListsPerName.get(itemGroup);

            return (list!=null) && (list.valid(item));
        }
    }
15638#public PageRules getPageRules(int page) {
        PageRules p = (PageRules) pageRules.get(page);

        return (p!=null) ? p : (PageRules) pageRules.get(0);
    }
15639#public void setLastModified(long lastModified) {
        this.lastModified = lastModified;
    }
15640#public boolean modifiedSince(long date) {
        return (this.lastModified == 0 || date!=this.lastModified);
    }
15641#public Object clone() {
        return new Pagesheet(pageRules, itemGroupsPerName,
                             itemGroupsPerElement);
    }
15642#public Page(PageRules rules, int elementStart) {
            this.elementStart = elementStart;

            if (rules.elementCount>0) {
                this.elementEnd = this.elementStart+rules.elementCount-1;
            } else {
                this.elementEnd = this.elementStart+1;
            }
        }
15643#public boolean validInPage(int elementCounter) {
            return (this.elementStart<=elementCounter) &&
                   (elementCounter<=this.elementEnd);
        }
15644#public ItemList(int capacity) {
            super(capacity);
        }
15645#public void addItem(int page) {
            this.add(new Integer(page));
        }
15646#public int getPageForItem(int item) {
            Integer i = (Integer) this.get(item-1);

            return (i==null) ? 0 : i.intValue();
        }
15647#public boolean valid(int item) {
            return (item==this.size());
        }
15648#public boolean match(String element, String namespace) {
        boolean elementMatches = ((this.elementName!=null) &&
                                  this.elementName.equals(element));

        if (this.elementURI==null) {
            return elementMatches;
        } else {
            return elementMatches && this.elementURI.equals(namespace);
        }
    }
15649#public boolean match(String namespace) {
        return ((this.elementURI!=null) &&
                (this.elementURI.equals(namespace)));
    }
15650#public Integer[] getRangeLinks() {
        return (Integer[]) this.rangeLinks.toArray(new Integer[this.rangeLinks.size()]);
    }
15651#public void addRangeLink(Integer rangeLink) {
        this.rangeLinks.add(rangeLink);
    }
15652#public void addRangeLink(int rangeLink) {
        this.addRangeLink(new Integer(rangeLink));
    }
15653#public void addRangeLink(String rangeLink) {
        this.addRangeLink(new Integer(rangeLink));
    }
15654#/**
     * Constructor
     */
    public PipelineCacheKey() {
        this.keys = new ArrayList(6);
    }
15655#/**
     * Constructor
     */
    public PipelineCacheKey(int size) {
        this.keys = new ArrayList(size);
    }
15656#/**
     * Add a key
     */
    public void addKey(ComponentCacheKey key) {
        this.keys.add(key);
        this.hashCode = 0;
        this.toString = null;
    }
15657#/**
     * Remove the last key
     */
    public void removeLastKey() {
        this.keys.remove(this.keys.size()-1);
        this.hashCode = 0;
        this.toString = null;
    }
15658#/**
     * Remove unitl cachepoint (including cachePoint) 
     */
    public void removeUntilCachePoint() {
        this.hashCode = 0;
        this.toString = null;
        int keyCount = this.keys.size();

        while (keyCount > 0) {
            if (((ComponentCacheKey)this.keys.get(keyCount-1)).isCachePoint()) {
                this.keys.remove(keyCount-1);
                return;
            }
            this.keys.remove(keyCount-1);
            keyCount--;
        }
    }
15659#/**
     * Return the number of keys
     */
    public int size() {
        return this.keys.size();
    }
15660#/**
     * Compare
     */
    public boolean equals(Object object) {
        if (object instanceof PipelineCacheKey) {
            PipelineCacheKey pck = (PipelineCacheKey)object;
            final int len = this.keys.size();
            if (pck.keys.size() == len) {
                boolean cont = true;
                int i = 0;
                while (i < len && cont) {
                    cont = this.keys.get(i).equals(pck.keys.get(i));
                    i++;
                }
                return cont;
            }
        }
        return false;
    }
15661#/**
     * Generate a hash code
     */
    public int hashCode() {
        if (this.hashCode == 0) {
            final int len = this.keys.size();
            for(int i=0; i < len; i++) {
                this.hashCode += this.keys.get(i).hashCode();
            }
            if (len % 2 == 0) this.hashCode++;
        }
        return this.hashCode;
    }
15662#/**
     * Clone the object (but not the component keys)
     */
    public PipelineCacheKey copy() {
        final int len = this.keys.size();
        PipelineCacheKey pck = new PipelineCacheKey(len);
        for(int i=0; i < len; i++) {
            pck.keys.add(this.keys.get(i));
        }
        return pck;
    }
15663#/**
     * toString
     * The FilesystemStore uses toString!
     */
    public String toString() {
        if (this.toString == null) {
            StringBuffer buffer = new StringBuffer();
            buffer.append("PK");
            final int len = this.keys.size();
            for(int i=0; i < len; i++) {
                buffer.append('_').append(this.keys.get(i).toString());
            }
            this.toString = buffer.toString();
        }
        return toString;
    }
15664#public CachingOutputStream(OutputStream os) {
        this.receiver = os;
        this.buf = new byte[1024];
        this.bufCount = 0;
    }
15665#public byte[] getContent() {
        byte newbuf[] = new byte[this.bufCount];
        System.arraycopy(this.buf, 0, newbuf, 0, this.bufCount);
        return newbuf;
    }
15666#public void write(int b) throws IOException {
        this.receiver.write(b);
        int newcount = this.bufCount + 1;
        if (newcount > this.buf.length) {
            byte newbuf[] = new byte[Math.max(this.buf.length << 1, newcount)];
            System.arraycopy(this.buf, 0, newbuf, 0, this.bufCount);
            this.buf = newbuf;
        }
        this.buf[this.bufCount] = (byte)b;
        this.bufCount = newcount;
    }
15667#public void write( byte b[] ) throws IOException {
        this.write(b, 0, b.length);
    }
15668#public void write(byte b[], int off, int len) throws IOException {
        this.receiver.write(b, off, len);
        if (len == 0) return;
        int newcount = this.bufCount + (len-off);
        if (newcount > this.buf.length) {
            byte newbuf[] = new byte[Math.max(this.buf.length << 1, newcount)];
            System.arraycopy(this.buf, 0, newbuf, 0, this.bufCount);
            this.buf = newbuf;
        }
        System.arraycopy(b, off, this.buf, this.bufCount, len);
        this.bufCount = newcount;
    }
15669#public void flush() throws IOException {
        this.receiver.flush();
    }
15670#public void close() throws IOException {
        this.receiver.close();
    }
15671#/**
     * Constructor
     */
    public ComponentCacheKey(int          componentType,
                             String       componentIdentifier,
                             Serializable cacheKey) {
        this(componentType, componentIdentifier, cacheKey, false);
    }
15672#/**
     * alternate cachepoint Constructor
     */
    public ComponentCacheKey(int          componentType,
                             String       componentIdentifier,
                             Serializable cacheKey,
			     boolean cachePoint) {
        this.type = componentType;
        this.identifier = componentIdentifier;
        this.key = cacheKey;
        /** cachePoint */
        this.cachePoint = cachePoint;
        this.hashCode = this.type +
                (this.identifier.length() << 3) +
                this.key.hashCode();
    }
15673#/**
     * Compare
     */
    public boolean equals(Object object) {
        if (object instanceof ComponentCacheKey) {
            ComponentCacheKey ccp = (ComponentCacheKey)object;
            if (this.type == ccp.type
                && this.identifier.equals(ccp.identifier)
                && this.key.equals(ccp.key)) {
                return true;
            }
        }
        return false;
    }
15674#/**
     * HashCode
     */
    public int hashCode() {
        return this.hashCode;
    }
15675#/**
     * toString
     * The FilesystemStore uses toString!
     */
    public String toString() {
        if (this.toString == null) {
            toString = COMPONENTS[this.type] + '-' + this.identifier + '-' + this.key.toString();
        }
        return toString;
    }
15676#/**
     * Check if we are a cachepoint 
     */
    public boolean isCachePoint() {
        return cachePoint;
    }
15677#/**
     * @param key Not null key value
     * @param external True if key represents external pipeline call
     */
    public IdentifierCacheKey(String key, boolean external) {
        this.key = key;
        this.external = external;
    }
15678#/**
     * The cache key
     */
    public String getKey() {
        return this.key;
    }
15679#/**
     * Compare
     */
    public boolean equals(Object object) {
        if (object instanceof IdentifierCacheKey) {
            IdentifierCacheKey pck = (IdentifierCacheKey) object;
            if (external != pck.external) {
                return false;
            }
            return this.key.equals(pck.key);
        }
        return false;
    }
15680#/**
     * Generate a hash code
     */
    public int hashCode() {
        return key.hashCode() + (external ? Boolean.TRUE : Boolean.FALSE).hashCode();
    }
15681#/**
     * toString
     * The FilesystemStore uses toString!
     */
    public String toString() {
        if (this.toString == null) {
            this.toString = "IK:" + external + ':' + key;
        }
        return toString;
    }
15682#/**
     * Store a cached response
     * @param key         the key used by the caching algorithm to identify the
     *                    request
     * @param response    the cached response
     */
    public void store(Serializable     key,
                      CachedResponse   response)
    throws ProcessingException {
        if (getLogger().isInfoEnabled()) {
            getLogger().info("Caching new response for " + key);
        }
        try {
            this.store.store(key, response);
        } catch (IOException e) {
            throw new ProcessingException("Unable to cache response.", e);
        }
    }
15683#/**
     * Get a cached response.
     * If it is not available <code>null</code> is returned.
     * @param key         the key used by the caching algorithm to identify the
     *                    request
     */
    public CachedResponse get(Serializable key) {
        final CachedResponse r = (CachedResponse) this.store.get(key);
        if (getLogger().isInfoEnabled()) {
            getLogger().info("Cache " + (r == null ? "MISS" : "HIT") + " for " + key);
        }
        return r;
    }
15684#/**
     * Remove a cached response.
     * If it is not available no operation is performed.
     * @param key         the key used by the caching algorithm to identify the
     *                    request
     */
    public void remove(Serializable key) {
        if (getLogger().isInfoEnabled()) {
            getLogger().info("Removing cached response for " + key);
        }
        this.store.remove(key);
    }
15685#/**
     * clear cache of all cached responses
     */
    public void clear() {
        if (getLogger().isInfoEnabled()) {
            getLogger().info("Clearing cache");
        }
        // FIXME this clears the whole store!
        this.store.clear();
    }
15686#/**
	 * See if a response is cached under this key
	 */
	public boolean containsKey(Serializable key) {
		return this.store.containsKey(key);
	}
15687#/**
     * Set the Store implementation
     */
    public void setStore(Store store) {
        this.store = store;
    }
15688#protected Log getLogger() {
        return this.logger;
    }
15689#/**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service (ServiceManager aManager)
    throws ServiceException {
        this.manager = aManager;
        this.newManager = aManager;
    }
15690#/**
     * Set the processor's service manager
     */
    public void setProcessorManager (ServiceManager manager) {
        this.newManager = manager;
    }
15691#/**
     * Parameterizable Interface - Configuration
     */
    public void parameterize(Parameters params)
    throws ParameterException {
        this.configuration = params;
        final String expiresValue = params.getParameter("expires", null);
        if (expiresValue != null) {
            this.configuredExpires = parseExpires(expiresValue);
        }
        this.configuredOutputBufferSize = params.getParameterAsInteger("outputBufferSize", -1);
    }
15692#/**
     * Setup this component
     */
    public void setup(Parameters params) {
        this.parameters = params;
        final String expiresValue = params.getParameter("expires", null);
        if (expiresValue != null) {
            this.expires = parseExpires(expiresValue);
        } else {
            this.expires = this.configuredExpires;
        }
        this.outputBufferSize = params.getParameterAsInteger("outputBufferSize",
                                                              this.configuredOutputBufferSize);
    }
15693#/**
     * Informs pipeline we have come across a branch point.
     * Default behaviour is do nothing.
     */
    public void informBranchPoint() {
        // this can be overwritten in subclasses
    }
15694#/**
     * Get the generator - used for content aggregation
     */
    public Generator getGenerator() {
        return this.generator;
    }
15695#/**
     * Set the generator that will be used as the initial step in the pipeline.
     * The generator role is given : the actual <code>Generator</code> is fetched
     * from the latest <code>ServiceManager</code>.
     *
     * @param role the generator role in the component manager.
     * @param source the source where to produce XML from, or <code>null</code> if no
     *        source is given.
     * @param param the parameters for the generator.
     * @throws ProcessingException if the generator couldn't be obtained.
     */
    public void setGenerator(String role, String source, Parameters param, Parameters hintParam)
    throws ProcessingException {
        if (this.generator != null) {
            throw new ProcessingException ("Generator already set. Cannot set generator '" + role + "'",
                    getLocation(param));
        }
        if (this.reader != null) {
            throw new ProcessingException ("Reader already set. Cannot set generator '" + role + "'",
                    getLocation(param));
        }
        try {
            this.generator = (Generator) this.newManager.lookup(Generator.ROLE + '/' + role);
        } catch (ServiceException ce) {
            throw ProcessingException.throwLocated("Lookup of generator '" + role + "' failed", ce, getLocation(param));
        }
        this.generatorSource = source;
        this.generatorParam = param;
    }
15696#/**
     * Add a transformer at the end of the pipeline.
     * The transformer role is given : the actual <code>Transformer</code> is fetched
     * from the latest <code>ServiceManager</code>.
     *
     * @param role the transformer role in the component manager.
     * @param source the source used to setup the transformer (e.g. XSL file), or
     *        <code>null</code> if no source is given.
     * @param param the parameters for the transfomer.
     * @throws ProcessingException if the generator couldn't be obtained.
     */
    public void addTransformer(String role, String source, Parameters param, Parameters hintParam)
    throws ProcessingException {
        if (this.reader != null) {
            // Should normally never happen as setting a reader starts pipeline processing
            throw new ProcessingException ("Reader already set. Cannot add transformer '" + role + "'",
                    getLocation(param));
        }
        if (this.generator == null) {
            throw new ProcessingException ("Must set a generator before adding transformer '" + role + "'",
                    getLocation(param));
        }
        try {
            this.transformers.add(this.newManager.lookup(Transformer.ROLE + '/' + role));
        } catch (ServiceException ce) {
            throw ProcessingException.throwLocated("Lookup of transformer '"+role+"' failed", ce, getLocation(param));
        }
        this.transformerSources.add(source);
        this.transformerParams.add(param);
    }
15697#/**
     * Set the serializer for this pipeline
     * @param mimeType Can be null
     */
    public void setSerializer(String role, String source, Parameters param, Parameters hintParam, String mimeType)
    throws ProcessingException {
        if (this.serializer != null) {
            // Should normally not happen as adding a serializer starts pipeline processing
            throw new ProcessingException ("Serializer already set. Cannot set serializer '" + role + "'",
                    getLocation(param));
        }
        if (this.reader != null) {
            // Should normally never happen as setting a reader starts pipeline processing
            throw new ProcessingException ("Reader already set. Cannot set serializer '" + role + "'",
                    getLocation(param));
        }
        if (this.generator == null) {
            throw new ProcessingException ("Must set a generator before setting serializer '" + role + "'",
                    getLocation(param));
        }

        try {
            this.serializer = (Serializer)this.newManager.lookup(Serializer.ROLE + '/' + role);
        } catch (ServiceException ce) {
            throw ProcessingException.throwLocated("Lookup of serializer '" + role + "' failed", ce, getLocation(param));
        }
        this.serializerSource = source;
        this.serializerParam = param;
        this.serializerMimeType = mimeType;
        this.lastConsumer = this.serializer;
    }
15698#/**
     * Set the reader for this pipeline
     * @param mimeType Can be null
     */
    public void setReader(String role, String source, Parameters param, String mimeType)
    throws ProcessingException {
        if (this.reader != null) {
            // Should normally never happen as setting a reader starts pipeline processing
            throw new ProcessingException ("Reader already set. Cannot set reader '" + role + "'",
                    getLocation(param));
        }
        if (this.generator != null) {
            // Should normally never happen as setting a reader starts pipeline processing
            throw new ProcessingException ("Generator already set. Cannot use reader '" + role + "'",
                    getLocation(param));
        }

        try {
            this.reader = (Reader)this.newManager.lookup(Reader.ROLE + '/' + role);
        } catch (ServiceException ce) {
            throw ProcessingException.throwLocated("Lookup of reader '"+role+"' failed", ce, getLocation(param));
        }
        this.readerSource = source;
        this.readerParam = param;
        this.readerMimeType = mimeType;
    }
15699#/**
     * Sets error handler for this pipeline.
     * Used for handling errors in the internal pipelines.
     * @param errorHandler error handler
     */
    public void setErrorHandler(SitemapErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
    }
15700#/**
     * Sanity check
     * @return true if the pipeline is 'sane', false otherwise.
     */
    protected boolean checkPipeline() {
        if (this.generator == null && this.reader == null) {
            return false;
        }

        if (this.generator != null && this.serializer == null) {
            return false;
        }

        return true;
    }
15701#/**
     * Setup pipeline components.
     */
    protected void setupPipeline(Environment environment)
    throws ProcessingException {
        try {
            // setup the generator
            this.generator.setup(
                this.sourceResolver,
                environment.getObjectModel(),
                generatorSource,
                generatorParam
            );

            Iterator transformerItt = this.transformers.iterator();
            Iterator transformerSourceItt = this.transformerSources.iterator();
            Iterator transformerParamItt = this.transformerParams.iterator();

            while (transformerItt.hasNext()) {
                Transformer trans = (Transformer)transformerItt.next();
                trans.setup(this.sourceResolver,
                            environment.getObjectModel(),
                            (String)transformerSourceItt.next(),
                            (Parameters)transformerParamItt.next()
                );
            }

            if (this.serializer instanceof SitemapModelComponent) {
                ((SitemapModelComponent)this.serializer).setup(
                    this.sourceResolver,
                    environment.getObjectModel(),
                    this.serializerSource,
                    this.serializerParam
                );
            }
        } catch (Exception e) {
            handleException(e);
        }
    }
15702#/**
     * Connect the next component
     */
    protected void connect(Environment environment,
                           XMLProducer producer,
                           XMLConsumer consumer)
    throws ProcessingException {
        // Connect next component.
        producer.setConsumer(consumer);
    }
15703#/**
     * Connect the XML pipeline.
     */
    protected void connectPipeline(Environment environment)
    throws ProcessingException {
        XMLProducer prev = this.generator;

        Iterator itt = this.transformers.iterator();
        while (itt.hasNext()) {
            Transformer next = (Transformer) itt.next();
            connect(environment, prev, next);
            prev = next;
        }

        // insert the serializer
        connect(environment, prev, this.lastConsumer);
    }
15704#/**
     * Process the given <code>Environment</code>, producing the output.
     */
    public boolean process(Environment environment)
    throws ProcessingException {
        if (!this.prepared) {
            preparePipeline(environment);
        }

        // See if we need to set an "Expires:" header
        if (this.expires != 0) {
            Response res = ObjectModelHelper.getResponse(environment.getObjectModel());
            res.setDateHeader("Expires", System.currentTimeMillis() + expires);
            res.setHeader("Cache-Control", "max-age=" + expires/1000 + ", public");
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Setting a new Expires object for this resource");
            }
            environment.getObjectModel().put(ObjectModelHelper.EXPIRES_OBJECT,
                                             new Long(expires + System.currentTimeMillis()));
        }

        if (this.reader != null) {
            if (checkIfModified(environment, this.reader.getLastModified())) {
                return true;
            }

            return processReader(environment);
        } else {
            // If this is an internal request, lastConsumer was reset!
            if (this.lastConsumer == null) {
                this.lastConsumer = this.serializer;
            }

            connectPipeline(environment);
            return processXMLPipeline(environment);
        }
    }
15705#/**
     * Prepare the pipeline
     */
    protected void preparePipeline(Environment environment)
    throws ProcessingException {
        // Look up the source resolver as late as possible as setProcessorManager might
        // have changed the service manager
        try {
            this.sourceResolver = (SourceResolver) this.newManager.lookup(SourceResolver.ROLE);
        } catch (ServiceException e) {
            throw new ProcessingException("Couldn't find a source resolver", e);
        }
        if (!checkPipeline()) {
            throw new ProcessingException("Attempted to process incomplete pipeline.");
        }

        if (this.prepared) {
            throw new ProcessingException("Duplicate preparePipeline call caught.");
        }

        if (this.reader != null) {
            setupReader(environment);
        } else {
            setupPipeline(environment);
        }
        this.prepared = true;
    }
15706#/**
     * Prepare an internal processing.
     * @param environment The current environment.
     * @throws ProcessingException
     */
    public void prepareInternal(Environment environment)
    throws ProcessingException {
        this.lastConsumer = null;
        try {
            preparePipeline(environment);
        } catch (ProcessingException e) {
            prepareInternalErrorHandler(environment, e);
        }
    }
15707#/**
     * If prepareInternal fails, prepare internal error handler.
     */
    protected void prepareInternalErrorHandler(Environment environment, ProcessingException ex)
    throws ProcessingException {
        if (this.errorHandler == null) {
            // propagate exception if we have no error handler
            throw ex;
        }

        try {
            this.errorPipeline = this.errorHandler.prepareErrorPipeline(ex);
            if (this.errorPipeline != null) {
                this.errorPipeline.prepareInternal(environment);
            }
        } catch (ProcessingException e) {
            // Log the original exception
            getLogger().error("Failed to process error handler for exception", ex);
            throw e;
        } catch (Exception e) {
            // Log the original exception
            getLogger().error("Failed to process error handler for exception", ex);
            throw new ProcessingException("Failed to handle exception <" + ex.getMessage() + ">", e);
        }
    }
15708#/**
     * @return true if error happened during internal pipeline prepare call.
     */
    protected boolean isInternalError() {
        return this.errorPipeline != null;
    }
15709#/**
     * Process the SAX event pipeline
     */
    protected boolean processXMLPipeline(Environment environment)
    throws ProcessingException {

        setMimeTypeForSerializer(environment);
        try {
            if (this.lastConsumer == null) {
                // internal processing
                this.generator.generate();
            } else {
                if (this.serializer.shouldSetContentLength()) {
                    // set the output stream
                    ByteArrayOutputStream os = new ByteArrayOutputStream();
                    this.serializer.setOutputStream(os);

                    // execute the pipeline:
                    this.generator.generate();
                    environment.setContentLength(os.size());
                    os.writeTo(environment.getOutputStream(0));
                } else {
                    // set the output stream
                    this.serializer.setOutputStream(environment.getOutputStream(this.outputBufferSize));
                    // execute the pipeline:
                    this.generator.generate();
                }
            }
        } catch (Exception e) {
            handleException(e);
        }

        return true;
    }
15710#/**
     * Setup the reader
     */
    protected void setupReader(Environment environment)
    throws ProcessingException {
        try {
            this.reader.setup(this.sourceResolver,environment.getObjectModel(),readerSource,readerParam);

            // set the expires parameter on the pipeline if the reader is configured with one
            if (readerParam.isParameter("expires")) {
	            // should this checking be done somewhere else??
	            this.expires = readerParam.getParameterAsLong("expires");
            }
        } catch (Exception e){
            handleException(e);
        }
    }
15711#/**
     * Set the mime-type for a reader
     * @param environment The current environment
     */
    protected void setMimeTypeForReader(Environment environment) {
        // Set the mime-type
        // the behaviour has changed from 2.1.x to 2.2 according to bug #10277:
        // MIME type declared in the sitemap (instance or declaration, in this order)
        // Ask the Reader for a MIME type:
        //     A *.doc reader could peek into the file
        //     and return either text/plain or application/vnd.msword or
        //     the reader can use MIME type declared in WEB-INF/web.xml or
        //     by the server.
        if ( this.readerMimeType != null ) {
            // there was a mime-type defined on map:read in the sitemap
            environment.setContentType(this.readerMimeType);
        } else {
            final String mimeType = this.reader.getMimeType();
            if (mimeType != null) {
                environment.setContentType(mimeType);
            }
            // If no mimeType available, leave to to upstream proxy
            // or browser to deduce content-type from URL extension.
        }
    }
15712#/**
     * Set the mime-type for a serializer
     * @param environment The current environment
     */
    protected void setMimeTypeForSerializer(Environment environment)
    throws ProcessingException {
        if (this.lastConsumer == null) {
            // internal processing: text/xml
            environment.setContentType("text/xml");
        } else {
            // Set the mime-type
            // the behaviour has changed from 2.1.x to 2.2 according to bug #10277
            if (serializerMimeType != null) {
                // there was a serializer defined in the sitemap
                environment.setContentType(serializerMimeType);
            } else {
                // ask to the component itself
                String mimeType = this.serializer.getMimeType();
                if (mimeType != null) {
                    environment.setContentType (mimeType);
                } else {
                    // No mimeType available
                    String message = "Unable to determine MIME type for " +
                        environment.getURIPrefix() + "/" + environment.getURI();
                    throw new ProcessingException(message);
                }
            }
        }
    }
15713#protected boolean checkIfModified(Environment environment,
                                      long lastModified)
    throws ProcessingException {
        // has the read resource been modified?
        if(!environment.isResponseModified(lastModified)) {
            // environment supports this, so we are finished
            environment.setResponseIsNotModified();
            return true;
        }
        return false;
    }
15714#/**
     * Process the pipeline using a reader.
     * @throws ProcessingException if
     */
    protected boolean processReader(Environment environment)
    throws ProcessingException {
        try {
            this.setMimeTypeForReader(environment);
            if (this.reader.shouldSetContentLength()) {
                ByteArrayOutputStream os = new ByteArrayOutputStream();
                this.reader.setOutputStream(os);
                this.reader.generate();
                environment.setContentLength(os.size());
                os.writeTo(environment.getOutputStream(0));
            } else {
                this.reader.setOutputStream(environment.getOutputStream(this.outputBufferSize));
                this.reader.generate();
            }
        } catch (Exception e) {
            handleException(e);
        }
        
        return true;
    }
15715#/**
     * @see org.apache.avalon.excalibur.pool.Recyclable#recycle()
     */
    public void recycle() {
        this.prepared = false;

        // Release reader.
        if (this.reader != null) {
            if ( this.reader instanceof DisposableSitemapComponent ) {
                ((DisposableSitemapComponent)this.reader).dispose();
            }
            this.newManager.release(this.reader);
            this.reader = null;
            this.readerParam = null;
        }

        // Release generator.
        if (this.generator != null) {
            if ( this.generator instanceof DisposableSitemapComponent ) {
                ((DisposableSitemapComponent)this.generator).dispose();
            }
            this.newManager.release(this.generator);
            this.generator = null;
            this.generatorParam = null;
        }

        // Release transformers
        int size = this.transformers.size();
        for (int i = 0; i < size; i++) {
            if ( this.transformers.get(i) instanceof DisposableSitemapComponent ) {
                ((DisposableSitemapComponent)this.transformers.get(i)).dispose();
            }
            this.newManager.release(this.transformers.get(i));
        }
        this.transformers.clear();
        this.transformerParams.clear();
        this.transformerSources.clear();

        // Release serializer
        if (this.serializer != null) {
            if ( this.serializer instanceof DisposableSitemapComponent ) {
                ((DisposableSitemapComponent)this.serializer).dispose();
            }
            this.newManager.release(this.serializer);
            this.serializerParam = null;
        }
        
        // Release source resolver
        if (this.sourceResolver != null) {
            this.newManager.release(this.sourceResolver);
        }
        this.serializer = null;
        this.parameters = null;
        this.sourceResolver = null;
        this.lastConsumer = null;

        // Release error handler
        this.errorHandler = null;

        // Release error pipeline
        // This is not done by using release in the creating container as release
        // is a noop for the Avalon life style in the Spring container 
        this.errorPipeline = null;
    }
15716#/**
     * Process the given <code>Environment</code>, but do not use the
     * serializer. Instead all SAX events are streamed to the XMLConsumer.
     */
    public boolean process(Environment environment, XMLConsumer consumer)
    throws ProcessingException {
        if (this.reader != null) {
            throw new ProcessingException("Streaming of an internal pipeline is not possible with a reader.");
        }

        // Exception happened during setup and was handled
        if (this.errorPipeline != null) {
            return this.errorPipeline.process(environment, consumer);
        }

        // Have to buffer events if error handler is specified.
        SaxBuffer buffer = null;
        this.lastConsumer = this.errorHandler == null? consumer: (buffer = new SaxBuffer());
        try {
            connectPipeline(environment);
            return processXMLPipeline(environment);
        } catch (ProcessingException e) {
            buffer = null;
            return processErrorHandler(environment, e, consumer);
        } finally {
            if (buffer != null) {
                try {
                    buffer.toSAX(consumer);
                } catch (SAXException e) {
                    throw new ProcessingException("Failed to execute pipeline.", e);
                }
            }
        }
    }
15717#protected boolean processErrorHandler(Environment environment, ProcessingException e, XMLConsumer consumer)
    throws ProcessingException {
        if (this.errorHandler != null) {
            try {
                this.errorPipeline = this.errorHandler.prepareErrorPipeline(e);
                if (this.errorPipeline != null) {
                    this.errorPipeline.prepareInternal(environment);
                    return this.errorPipeline.process(environment, consumer);
                }
            } catch (Exception ignored) {
                getLogger().debug("Exception in error handler", ignored);
            }
        }

        throw e;
    }
15718#/**
     * Return valid validity objects for the event pipeline
     * If the "event pipeline" (= the complete pipeline without the
     * serializer) is cacheable and valid, return all validity objects.
     * Otherwise return <code>null</code>
     */
    public SourceValidity getValidityForEventPipeline() {
        return null;
    }
15719#/**
     * Return the key for the event pipeline
     * If the "event pipeline" (= the complete pipeline without the
     * serializer) is cacheable and valid, return a key.
     * Otherwise return <code>null</code>
     */
    public String getKeyForEventPipeline() {
        return null;
    }
15720#/**
     * Parse the expires parameter
     */
    private long parseExpires(String expire) {
        StringTokenizer tokens = new StringTokenizer(expire);

        // get <base>
        String current = tokens.nextToken();
        if (current.equals("modification")) {
            getLogger().warn("the \"modification\" keyword is not yet" +
                             " implemented. Assuming \"now\" as the base attribute");
            current = "now";
        }

        if (!current.equals("now") && !current.equals("access")) {
            getLogger().error("bad <base> attribute, Expires header will not be set");
            return -1;
        }

        long number;
        long modifier;
        long expires = 0;

        while (tokens.hasMoreTokens()) {
            current = tokens.nextToken();

            // get rid of the optional <plus> keyword
            if (current.equals("plus")) {
                current = tokens.nextToken();
            }

            // We're expecting a sequence of <number> and <modification> here
            // get <number> first
            try {
                number = Long.parseLong(current);
            } catch (NumberFormatException nfe) {
                getLogger().error("state violation: a number was expected here");
                return -1;
            }

            // now get <modifier>
            try {
                current = tokens.nextToken();
            } catch (NoSuchElementException nsee) {
                getLogger().error("State violation: expecting a modifier" +
                                  " but no one found: Expires header will not be set");
            }
            if (current.equals("years")) {
                modifier = 365L * 24L * 60L * 60L * 1000L;
            } else if (current.equals("months")) {
                modifier = 30L * 24L * 60L * 60L * 1000L;
            } else if (current.equals("weeks")) {
                modifier = 7L * 24L * 60L * 60L * 1000L;
            } else if (current.equals("days")) {
                modifier = 24L * 60L * 60L * 1000L;
            } else if (current.equals("hours")) {
                modifier = 60L * 60L * 1000L;
            } else if (current.equals("minutes")) {
                modifier = 60L * 1000L;
            } else if (current.equals("seconds")) {
                modifier = 1000L;
            } else {
                getLogger().error("Bad modifier (" + current +
                                  "): ignoring expires configuration");
                return -1;
            }
            expires += number * modifier;
        }

        return expires;
    }
15721#protected Location getLocation(Parameters param) {
        Location location = null;
        if (param instanceof Locatable) {
            location = ((Locatable)param).getLocation();
        }
        if (location == null) {
            location = Location.UNKNOWN;
        }
        return location;
    }
15722#/**
     * Handles exception which can happen during pipeline processing.
     * If this not a connection reset, then all locations for pipeline components are
     * added to the exception.
     * 
     * @throws ConnectionResetException if connection reset detected
     * @throws ProcessingException in all other cases
     */
    protected void handleException(Exception e) throws ProcessingException {
        // Check if the client aborted the connection
        if (e instanceof SocketException) {
            if (e.getMessage().indexOf("reset") > -1
                    || e.getMessage().indexOf("aborted") > -1
                    || e.getMessage().indexOf("Broken pipe") > -1
                    || e.getMessage().indexOf("connection abort") > -1) {
                throw new ConnectionResetException("Connection reset by peer", e);
            }
        } else if (e instanceof IOException) {
            // Tomcat5 wraps SocketException into ClientAbortException which extends IOException.
            if (e.getClass().getName().endsWith("ClientAbortException")) {
                throw new ConnectionResetException("Connection reset by peer", e);
            }
        } else if (e instanceof ConnectionResetException) {
            // Exception comes up from a deeper pipeline
            throw (ConnectionResetException)e;
        }

        // Not a connection reset: add all location information        
        if (this.reader == null) {
            // Add all locations in reverse order
            ArrayList locations = new ArrayList(this.transformers.size() + 2);
            locations.add(getLocation(this.serializerParam));
            for (int i = this.transformerParams.size() - 1; i >= 0; i--) {
                locations.add(getLocation((Parameters)this.transformerParams.get(i)));
            }
            locations.add(getLocation(this.generatorParam));
            
            throw ProcessingException.throwLocated("Failed to process pipeline", e, locations);

        } else {
            // Add reader location
            throw ProcessingException.throwLocated("Failed to process reader", e, getLocation(this.readerParam));
        }
    }
15723#/**
     * Parameterizable Interface - Configuration
     */
    public void parameterize(Parameters params)
    throws ParameterException {
        super.parameterize(params);

        String cacheRole = params.getParameter("cache-role", Cache.ROLE);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Using cache " + cacheRole);
        }

        try {
            this.cache = (Cache) this.manager.lookup(cacheRole);
        } catch (ServiceException ce) {
            throw new ParameterException("Unable to lookup cache: " + cacheRole, ce);
        }
    }
15724#/**
     * Recyclable Interface
     */
    public void recycle() {
        this.xmlDeserializer = null;
        this.xmlSerializer = null;

        super.recycle();
    }
15725#/**
     * Disposable Interface
     */
    public void dispose() {
        if (null != this.manager) {
            this.manager.release(this.cache);
        }
        this.cache = null;
        this.manager = null;
    }
15726#public PipelineComponentInfo(PipelineComponentInfo parent) {
        this.parent = parent;
    }
15727#/**
     * Grabs on the fly the sitemap-related information on generators, transformers,
     * serializers and readers when they're declared in the <code>ServiceManager</code>.
     * <p>
     * This method is triggered when a component is added on a <code>CocoonServiceManager</code>.
     * 
     * @param role the component's role
     * @param clazz the component's class
     * @param config the component's configuration
     */
    public void componentAdded(String role, String clazz, Configuration config) {
        if (role.startsWith(GENERATOR_PREFIX)) {
            setupLabelAndPipelineHint(role, config);

        } else if (role.startsWith(TRANSFORMER_PREFIX)) {
            setupLabelAndPipelineHint(role, config);

        } else if (role.startsWith(SERIALIZER_PREFIX)) {
            setupLabelAndPipelineHint(role, config);
            setupMimeType(role, config);

        } else if (role.startsWith(READER_PREFIX)) {
            setupMimeType(role, config);
        }
    }
15728#protected void setupLabelAndPipelineHint(String role, Configuration config) {

        // Labels
        String label = config.getAttribute("label", null);
        if (label != null) {
            StringTokenizer st = new StringTokenizer(label, " ,", false);
            String[] labels = new String[st.countTokens()];
            for (int tokenIdx = 0; tokenIdx < labels.length; tokenIdx++) {
                labels[tokenIdx] = st.nextToken();
            }
            setLabels(role, labels);
        } else {
            // Set no labels, overriding those defined in the parent sitemap, if any
            setLabels(role, null);
        }

        // Pipeline hints
        String pipelineHint = config.getAttribute("hint", null);
        setPipelineHint(role, pipelineHint);
    }
15729#protected void setupMimeType(String role, Configuration config) {
        setMimeType(role, config.getAttribute("mime-type", null));
    }
15730#/** Store some data, creating the storage map if needed */
    private void setData(String key, Object value) {
        if (locked) throw new IllegalStateException("ProcessorComponentInfo is locked");
        if (this.data == null) this.data = new HashMap();
        this.data.put(key, value);
    }
15731#/** Get some data, asking the parent if needed */
    private Object getData(String key) {
        // Need to check containsKey as the default hint may be unspecified (i.e. no "default" attribute)
        if (this.data != null && this.data.containsKey(key)) {
            return this.data.get(key);
        } else if (this.parent != null) {
            // Ask parent
            return this.parent.getData(key);
        } else {
            return null;
        }
    }
15732#/**
     * Lock this component info object at the end of processor building to prevent
     * any further changes.
     */
    public void lock() {
        this.locked = true;
    }
15733#public void setDefaultType(String role, String hint) {
        setData("defaultType/" + role, hint);
    }
15734#public String getDefaultType(String role) {
        return (String)getData("defaultType/" + role);
    }
15735#public void setPipelineHint(String role, String hint) {
        setData("pipelineHint/" + role, hint);
    }
15736#public String getPipelineHint(String role, String type) {
        return (String)getData("pipelineHint/" + role + "/" + type);
    }
15737#public void setMimeType(String role, String mimeType) {
        setData("mimeType/" + role, mimeType);
    }
15738#public String getMimeType(String role, String type) {
        return (String)getData("mimeType/" + role + "/" + type);
    }
15739#public void setLabels(String role, String[] labels) {
        setData("labels/" + role, labels);
    }
15740#public String[] getLabels(String role, String type) {
        return (String[])getData("labels/" + role + "/" + type);
    }
15741#public boolean hasLabel(String role, String type, String label) {
        String[] labels = this.getLabels(role, type);
        if (labels != null) {
            for (int i = 0; i < labels.length; i++) {
                if (labels[i].equals(label))
                    return true;
            }
        }
        return false;
    }
15742#public Map getData() {
        return this.data;
    }
15743#public void setData(Map map) {
        this.data = map;
    }
15744#public void addData(Map map) {
        if (this.data == null)
            this.data = map;
        else
            this.data.putAll(map);
    }
15745#/** Abstract method defined in subclasses
     * @return <u>complete</u> cached response or <code>null</code><br>
     *         See issue COCOON-2009 for discussion*/
    protected abstract CachedResponse cacheResults(Environment environment,
                                                   OutputStream os)
        throws Exception;
15746#/** Abstract method defined in subclasses */
    protected abstract ComponentCacheKey newComponentCacheKey(int type,
                                                              String role,
                                                              Serializable key);
15747#/** Abstract method defined in subclasses */
    protected abstract void connectCachingPipeline(Environment environment)
        throws ProcessingException;
15748#/**
     * Parameterizable Interface - Configuration
     */
    public void parameterize(Parameters params) throws ParameterException {
        super.parameterize(params);

        String storeRole = params.getParameter("store-role", Store.TRANSIENT_STORE);
        try {
            transientStore = (Store) manager.lookup(storeRole);
        } catch (ServiceException e) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Could not look up transient store, synchronizing requests will not work!", e);
            }
        }
    }
15749#/**
     * Set the generator.
     */
    public void setGenerator(String role, String source, Parameters param,
                             Parameters hintParam) throws ProcessingException {
        super.setGenerator(role, source, param, hintParam);
        this.generatorRole = role;
    }
15750#/**
     * Add a transformer.
     */
    public void addTransformer(String role, String source, Parameters param,
                               Parameters hintParam) throws ProcessingException {
        super.addTransformer(role, source, param, hintParam);
        this.transformerRoles.add(role);
    }
15751#/**
     * Set the serializer.
     */
    public void setSerializer(String role, String source, Parameters param,
                              Parameters hintParam, String mimeType) throws ProcessingException {
        super.setSerializer(role, source, param, hintParam, mimeType);
        this.serializerRole = role;
    }
15752#/**
     * Set the Reader.
     */
    public void setReader(String role, String source, Parameters param,
                          String mimeType) throws ProcessingException {
        super.setReader(role, source, param, mimeType);
        this.readerRole = role;
    }
15753#/**
     * Look up the lock object by key, and if present, wait till notified.
     *
     * @return false if able to find a lock and was notified
     */
    protected boolean waitForLock(Object key) {
        if (transientStore != null) {
            final String lockKey = PIPELOCK_PREFIX + key;

            // Get a lock object from the store
            Object lock;
            synchronized (transientStore) {
                lock = transientStore.get(lockKey);
            }

            // Avoid deadlock with self (see JIRA COCOON-1985).
            Object current = RequestContextHolder.getRequestAttributes();
            if (lock != null && lock != current) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Waiting on Lock '" + lockKey + "'");
                }

                try {
                    synchronized (lock) {
                        lock.wait();
                    }

                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("Notified on Lock '" + lockKey + "'");
                    }
                } catch (InterruptedException e) {
                    /* ignored */
                }

                return false;
            }
        }

        return true;
    }
15754#/**
     * Makes the lock (instantiates a new object and puts it into the store)
     */
    protected void generateLock(Object key) {
        if (transientStore != null && key != null) {
            final String lockKey = PIPELOCK_PREFIX + key;
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Adding Lock '" + lockKey + "'");
            }

            synchronized (transientStore) {
                if (transientStore.containsKey(lockKey)) {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("Lock EXISTS: '" + lockKey + "'");
                    }
                } else {
                    Object lock = RequestContextHolder.getRequestAttributes();
                    try {
                        transientStore.store(lockKey, lock);
                    } catch (IOException e) {
                        /* should not happen */
                    }
                }
            }
        }
    }
15755#/**
     * Releases the lock (notifies it and removes it from the store)
     */
    protected void releaseLock(Object key) {
        if (transientStore != null && key != null) {
            final String lockKey = PIPELOCK_PREFIX + key;
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Releasing Lock '" + lockKey + "'");
            }

            Object lock = null;
            synchronized (transientStore) {
                if (!transientStore.containsKey(lockKey)) {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("Lock MISSING: '" + lockKey + "'");
                    }
                } else {
                    lock = transientStore.get(lockKey);
                    transientStore.remove(lockKey);
                }
            }

            if (lock != null) {
                // Notify everybody who's waiting
                synchronized (lock) {
                    lock.notifyAll();
                }
            }
        }
    }
15756#/**
     * Process the given <code>Environment</code>, producing the output.
     */
    protected boolean processXMLPipeline(Environment environment) throws ProcessingException {
        if (this.toCacheKey == null && this.cachedResponse == null) {
            return super.processXMLPipeline(environment);
        }

        if (this.cachedResponse != null && this.completeResponseIsCached) {

            // Allow for 304 (not modified) responses in dynamic content
            if (checkIfModified(environment, this.cachedResponse.getLastModified())) {
                return true;
            }

            // Set mime-type
            if (this.cachedResponse.getContentType() != null) {
                environment.setContentType(this.cachedResponse.getContentType());
            } else {
                setMimeTypeForSerializer(environment);
            }

            // Write response out
            try {
                final OutputStream outputStream = environment.getOutputStream(0);
                final byte[] content = this.cachedResponse.getResponse();
                if (content.length > 0) {
                    environment.setContentLength(content.length);
                    outputStream.write(content);
                }
            } catch (Exception e) {
                handleException(e);
            }
        } else {
            setMimeTypeForSerializer(environment);
            if (getLogger().isDebugEnabled() && this.toCacheKey != null) {
                getLogger().debug("processXMLPipeline: caching content for further" +
                                  " requests of '" + environment.getURI() +
                                  "' using key " + this.toCacheKey);
            }

            generateLock(this.toCacheKey);
            try {
                OutputStream os = null;

                if (this.cacheCompleteResponse && this.toCacheKey != null) {
                    os = new CachingOutputStream(environment.getOutputStream(this.outputBufferSize));
                }

                if (super.serializer != super.lastConsumer) {
                    if (os == null) {
                        os = environment.getOutputStream(this.outputBufferSize);
                    }

                    // internal processing
                    if (this.xmlDeserializer != null) {
                        this.xmlDeserializer.deserialize(this.cachedResponse.getResponse());
                    } else {
                        this.generator.generate();
                    }

                } else {
                    if (this.serializer.shouldSetContentLength()) {
                        if (os == null) {
                            os = environment.getOutputStream(0);
                        }

                        // Set the output stream
                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
                        this.serializer.setOutputStream(baos);

                        // Execute the pipeline
                        if (this.xmlDeserializer != null) {
                            this.xmlDeserializer.deserialize(this.cachedResponse.getResponse());
                        } else {
                            this.generator.generate();
                        }

                        environment.setContentLength(baos.size());
                        baos.writeTo(os);
                    } else {
                        if (os == null) {
                            os = environment.getOutputStream(this.outputBufferSize);
                        }

                        // Set the output stream
                        this.serializer.setOutputStream(os);

                        // Execute the pipeline
                        if (this.xmlDeserializer != null) {
                            this.xmlDeserializer.deserialize(this.cachedResponse.getResponse());
                        } else {
                            this.generator.generate();
                        }
                    }
                }

                //
                // Now that we have processed the pipeline,
                // we do the actual caching
                //
                CachedResponse completeCachedResponse = cacheResults(environment,os);

                if (completeCachedResponse != null) {
                	//Dirty work-around for setting Last-Modified header as there is no appoporiate method
                	//org.apache.cocoon.environment.http.HttpEnvironment.isResponseModified will set it and the result of
                	//the actual check is neither meaningful nor important here
                	environment.isResponseModified(completeCachedResponse.getLastModified());
                }

            } catch (Exception e) {
                handleException(e);
            } finally {
                releaseLock(this.toCacheKey);
            }

            //Request has been succesfully processed, set approporiate status code
            environment.setStatus(HttpServletResponse.SC_OK);
            return true;
        }

        return true;
    }
15757#/**
     * The components of the pipeline are checked if they are Cacheable.
     */
    protected void generateCachingKey(Environment environment) throws ProcessingException {

        this.toCacheKey = null;
        this.firstNotCacheableTransformerIndex = 0;
        this.cacheCompleteResponse = false;

        // first step is to generate the key:
        // All pipeline components starting with the generator
        // are tested if they are either a CacheableProcessingComponent
        // or Cacheable (deprecated). The returned keys are chained together
        // to build a unique key of the request

        // is the generator cacheable?
        Serializable key = null;
        if (super.generator instanceof CacheableProcessingComponent) {
            key = ((CacheableProcessingComponent) super.generator).getKey();
        }

        if (key != null) {
            this.toCacheKey = new PipelineCacheKey();
            this.toCacheKey.addKey(
                    newComponentCacheKey(
                            ComponentCacheKey.ComponentType_Generator,
                            this.generatorRole, key));

            // now testing transformers
            final int transformerSize = super.transformers.size();
            boolean continueTest = true;

            while (this.firstNotCacheableTransformerIndex < transformerSize && continueTest) {
                final Transformer trans =
                    (Transformer) super.transformers.get(this.firstNotCacheableTransformerIndex);
                key = null;
                if (trans instanceof CacheableProcessingComponent) {
                    key = ((CacheableProcessingComponent)trans).getKey();
                }
                if (key != null) {
                    this.toCacheKey.addKey(
                            newComponentCacheKey(
                                    ComponentCacheKey.ComponentType_Transformer,
                                    (String) this.transformerRoles.get(this.firstNotCacheableTransformerIndex),
                                    key));

                    this.firstNotCacheableTransformerIndex++;
                } else {
                    continueTest = false;
                }
            }
            // all transformers are cacheable => pipeline is cacheable
            // test serializer if this is not an internal request
            if (this.firstNotCacheableTransformerIndex == transformerSize
                && super.serializer == this.lastConsumer) {

                key = null;
                if (super.serializer instanceof CacheableProcessingComponent) {
                    key = ((CacheableProcessingComponent) this.serializer).getKey();
                }
                if (key != null) {
                    this.toCacheKey.addKey(
                            newComponentCacheKey(
                                    ComponentCacheKey.ComponentType_Serializer,
                                    this.serializerRole,
                                    key));
                    this.cacheCompleteResponse = true;
                }
            }
        }
    }
15758#/**
     * Generate validity objects for the new response
     */
    protected void setupValidities() throws ProcessingException {

        if (this.toCacheKey != null) {
            // only update validity objects if we cannot use
            // a cached response or when the cached response does
            // cache less than now is cacheable
            if (this.fromCacheKey == null
                    || this.fromCacheKey.size() < this.toCacheKey.size()) {

                this.toCacheSourceValidities =
                    new SourceValidity[this.toCacheKey.size()];

                int len = this.toCacheSourceValidities.length;
                int i = 0;
                while (i < len) {
                    final SourceValidity validity = getValidityForInternalPipeline(i);

                    if (validity == null) {
                        if (i > 0
                                && (this.fromCacheKey == null
                                    || i > this.fromCacheKey.size())) {
                            // shorten key
                            for (int m=i; m < this.toCacheSourceValidities.length; m++) {
                                this.toCacheKey.removeLastKey();
                                if (!this.cacheCompleteResponse) {
                                    this.firstNotCacheableTransformerIndex--;
                                }
                                this.cacheCompleteResponse = false;
                            }
                            SourceValidity[] copy = new SourceValidity[i];
                            System.arraycopy(this.toCacheSourceValidities, 0, copy, 0, copy.length);
                            this.toCacheSourceValidities = copy;
                            len = this.toCacheSourceValidities.length;
                        } else {
                            // caching is not possible!
                            this.toCacheKey = null;
                            this.toCacheSourceValidities = null;
                            this.cacheCompleteResponse = false;
                            len = 0;
                        }
                    } else {
                        this.toCacheSourceValidities[i] = validity;
                    }
                    i++;
                }
            } else {
                // we don't have to cache
                this.toCacheKey = null;
                this.cacheCompleteResponse = false;
            }
        }
    }
15759#/**
     * Calculate the key that can be used to get something from the cache, and
     * handle expires properly.
     */
    protected void validatePipeline(Environment environment) throws ProcessingException {

        this.completeResponseIsCached = this.cacheCompleteResponse;
        this.fromCacheKey = this.toCacheKey.copy();
        this.firstProcessedTransformerIndex = this.firstNotCacheableTransformerIndex;

        boolean finished = false;
        while (this.fromCacheKey != null && !finished) {
            finished = true;

            final CachedResponse response = this.cache.get(this.fromCacheKey);

            // now test validity
            if (response != null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Found cached response for '" + environment.getURI() +
                            "' using key: " + this.fromCacheKey);
                }

                boolean responseIsValid = true;
                boolean responseIsUsable = true;

                // See if we have an explicit "expires" setting. If so,
                // and if it's still fresh, we're done.
                Long responseExpires = response.getExpires();

                if (responseExpires != null) {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("Expires time found for " + environment.getURI());
                    }

                    if (responseExpires.longValue() > System.currentTimeMillis()) {
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("Expires time still fresh for " + environment.getURI() +
                                    ", ignoring all other cache settings. This entry expires on "+
                                    new Date(responseExpires.longValue()));
                        }
                        this.cachedResponse = response;
                        return;
                    } else {
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("Expires time has expired for " + environment.getURI() +
                                    ", regenerating content.");
                        }

                        // If an expires parameter was provided, use it. If this parameter is not available
                        // it means that the sitemap was modified, and the old expires value is not valid
                        // anymore.
                        if (expires != 0) {
                            if (this.getLogger().isDebugEnabled())
                                this.getLogger().debug("Refreshing expires informations");
                            response.setExpires(new Long(expires + System.currentTimeMillis()));
                        } else {
                            if (this.getLogger().isDebugEnabled())
                                this.getLogger().debug("No expires defined anymore for this object, setting it to no expires");
                            response.setExpires(null);
                        }
                    }
                } else {
                    // The response had no expires informations. See if it needs to be set (i.e. because the configuration has changed)
                    if (expires != 0) {
                        if (this.getLogger().isDebugEnabled())
                            this.getLogger().debug("Setting a new expires object for this resource");
                        response.setExpires(new Long(expires + System.currentTimeMillis()));
                    }
                }

                SourceValidity[] fromCacheValidityObjects = response.getValidityObjects();

                int i = 0;
                while (responseIsValid && i < fromCacheValidityObjects.length) {
                    // BH Check if validities[i] is null, may happen
                    //    if exception was thrown due to malformed content
                    SourceValidity validity = fromCacheValidityObjects[i];
                    int valid = validity == null ? SourceValidity.INVALID : validity.isValid();
                    if (valid == SourceValidity.UNKNOWN) {
                        // Don't know if valid, make second test
                        validity = getValidityForInternalPipeline(i);
                        if (validity != null) {
                            valid = fromCacheValidityObjects[i].isValid(validity);
                            if (valid == SourceValidity.UNKNOWN) {
                                validity = null;
                            }
                        }
                    }

                    if (valid != SourceValidity.VALID) {
                        responseIsValid = false;
                        // update validity
                        if (validity == null) {
                            responseIsUsable = false;
                            if (getLogger().isDebugEnabled()) {
                                getLogger().debug("validatePipeline: responseIsUsable is false, valid=" +
                                                  valid + " at index " + i);
                            }
                        } else {
                            if (getLogger().isDebugEnabled()) {
                                getLogger().debug("validatePipeline: responseIsValid is false due to " +
                                                  validity);
                            }
                        }
                    } else {
                        i++;
                    }
                }

                if (responseIsValid) {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("validatePipeline: using valid cached content for '" +
                                          environment.getURI() + "'.");
                    }

                    // we are valid, ok that's it
                    this.cachedResponse = response;
                    this.toCacheSourceValidities = fromCacheValidityObjects;
                } else {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("validatePipeline: cached content is invalid for '" +
                                          environment.getURI() + "'.");
                    }
                    // we are not valid!

                    if (!responseIsUsable) {
                        // we could not compare, because we got no
                        // validity object, so shorten pipeline key
                        if (i > 0) {
                            int deleteCount = fromCacheValidityObjects.length - i;
                            if (i > 0 && i <= firstNotCacheableTransformerIndex + 1) {
                                this.firstNotCacheableTransformerIndex = i-1;
                            }
                            for(int x=0; x < deleteCount; x++) {
                                this.toCacheKey.removeLastKey();
                            }
                        } else {
                            this.toCacheKey = null;
                        }
                        this.cacheCompleteResponse = false;
                    } else {
                        // the entry is invalid, remove it
                        this.cache.remove(this.fromCacheKey);
                    }

                    // try a shorter key
                    if (i > 0) {
                        this.fromCacheKey.removeLastKey();
                        if (!this.completeResponseIsCached) {
                            this.firstProcessedTransformerIndex--;
                        }
                    } else {
                        this.fromCacheKey = null;
                    }

                    finished = false;
                    this.completeResponseIsCached = false;
                }
            } else {
                // check if there might be one being generated
                if (!waitForLock(this.fromCacheKey)) {
                    finished = false;
                    continue;
                }

                // no cached response found
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Cached response not found for '" + environment.getURI() +
                                      "' using key: " +  this.fromCacheKey);
                }

                finished = setupFromCacheKey();
                this.completeResponseIsCached = false;
            }
        }
    }
15760#boolean setupFromCacheKey() {
        // stop on longest key for smart caching
        this.fromCacheKey = null;
        return true;
    }
15761#/**
     * Setup the evenet pipeline.
     * The components of the pipeline are checked if they are
     * Cacheable.
     */
    protected void setupPipeline(Environment environment) throws ProcessingException {
        super.setupPipeline(environment);

        // Generate the key to fill the cache
        generateCachingKey(environment);

        // Test the cache for a valid response
        if (this.toCacheKey != null) {
            validatePipeline(environment);
        }

        setupValidities();
    }
15762#/**
     * Connect the pipeline.
     */
    protected void connectPipeline(Environment   environment) throws ProcessingException {
        if (this.toCacheKey == null && this.cachedResponse == null) {
            super.connectPipeline(environment);
        } else if (this.completeResponseIsCached) {
            // do nothing
        } else {
            connectCachingPipeline(environment);
        }
    }
15763#/** Process the pipeline using a reader.
     * @throws ProcessingException if an error occurs
     */
    protected boolean processReader(Environment  environment) throws ProcessingException {
        try {
            boolean usedCache = false;
            OutputStream outputStream = null;
            SourceValidity readerValidity = null;
            PipelineCacheKey pcKey = null;

            // test if reader is cacheable
            Serializable readerKey = null;
            if (super.reader instanceof CacheableProcessingComponent) {
                readerKey = ((CacheableProcessingComponent)super.reader).getKey();
            }

            boolean finished = false;

            if (readerKey != null) {
                // response is cacheable, build the key
                pcKey = new PipelineCacheKey();
                pcKey.addKey(new ComponentCacheKey(ComponentCacheKey.ComponentType_Reader,
                                                   this.readerRole,
                                                   readerKey));

                while (!finished) {
                    finished = true;
                    // now we have the key to get the cached object
                    CachedResponse cachedObject = this.cache.get(pcKey);
                    if (cachedObject != null) {
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("Found cached response for '" +
                                              environment.getURI() + "' using key: " + pcKey);
                        }

                        SourceValidity[] validities = cachedObject.getValidityObjects();
                        if (validities == null || validities.length != 1) {
                            // to avoid getting here again and again, we delete it
                            this.cache.remove(pcKey);
                            if (getLogger().isDebugEnabled()) {
                                getLogger().debug("Cached response for '" + environment.getURI() +
                                                  "' using key: " + pcKey + " is invalid.");
                            }
                            this.cachedResponse = null;
                        } else {
                            SourceValidity cachedValidity = validities[0];
                            
                            int valid = cachedValidity.isValid();
                            if (valid == SourceValidity.UNKNOWN) {
                                // get reader validity and compare
                                readerValidity = ((CacheableProcessingComponent) super.reader).getValidity();
                                if (readerValidity != null) {
                                    valid = cachedValidity.isValid(readerValidity);
                                    if (valid == SourceValidity.UNKNOWN) {
                                        readerValidity = null;
                                    }
                                }
                            }

                            if (valid == SourceValidity.VALID) {
                                if (getLogger().isDebugEnabled()) {
                                    getLogger().debug("processReader: using valid cached content for '" +
                                            environment.getURI() + "'.");
                                }
                                byte[] response = cachedObject.getResponse();
                                if (response.length > 0) {
                                    usedCache = true;
                                    if (cachedObject.getContentType() != null) {
                                        environment.setContentType(cachedObject.getContentType());
                                    } else {
                                        setMimeTypeForReader(environment);
                                    }
                                    outputStream = environment.getOutputStream(0);
                                    environment.setContentLength(response.length);
                                    outputStream.write(response);
                                }
                            } else {
                                if (getLogger().isDebugEnabled()) {
                                    getLogger().debug("processReader: cached content is invalid for '" +
                                            environment.getURI() + "'.");
                                }
                                // remove invalid cached object
                                this.cache.remove(pcKey);
                            }
                        }
                    } else {
                        // check if something is being generated right now
                        if (!waitForLock(pcKey)) {
                            finished = false;
                            continue;
                        }
                    }
                }
            }

            if (!usedCache) {
                // make sure lock will be released
                try {
                    if (pcKey != null) {
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("processReader: caching content for further requests of '" +
                                    environment.getURI() + "'.");
                        }
                        generateLock(pcKey);

                        if (readerValidity == null) {
                            readerValidity = ((CacheableProcessingComponent)super.reader).getValidity();
                        }

                        if (readerValidity != null) {
                            outputStream = environment.getOutputStream(this.outputBufferSize);
                            outputStream = new CachingOutputStream(outputStream);
                        }
                    }

                    setMimeTypeForReader(environment);
                    if (this.reader.shouldSetContentLength()) {
                        ByteArrayOutputStream os = new ByteArrayOutputStream();
                        this.reader.setOutputStream(os);
                        this.reader.generate();
                        environment.setContentLength(os.size());
                        if (outputStream == null) {
                            outputStream = environment.getOutputStream(0);
                        }
                        os.writeTo(outputStream);
                    } else {
                        if (outputStream == null) {
                            outputStream = environment.getOutputStream(this.outputBufferSize);
                        }
                        this.reader.setOutputStream(outputStream);
                        this.reader.generate();
                    }

                    // store the response
                    if (pcKey != null && readerValidity != null) {
                        final CachedResponse res = new CachedResponse(new SourceValidity[] {readerValidity},
                                ((CachingOutputStream)outputStream).getContent());
                        res.setContentType(environment.getContentType());
                        this.cache.store(pcKey, res);
                    }

                } finally {
                    releaseLock(pcKey);
                }
            }
        } catch (Exception e) {
            handleException(e);
        }

        //Request has been succesfully processed, set approporiate status code
        environment.setStatus(HttpServletResponse.SC_OK);
        return true;
    }
15764#/**
     * Return valid validity objects for the event pipeline.
     *
     * If the event pipeline (the complete pipeline without the
     * serializer) is cacheable and valid, return all validity objects.
     *
     * Otherwise, return <code>null</code>.
     */
    public SourceValidity getValidityForEventPipeline() {
        if (isInternalError()) {
            return null;
        }

        if (this.cachedResponse != null) {
            if (!this.cacheCompleteResponse &&
                    this.firstNotCacheableTransformerIndex < super.transformers.size()) {
                // Cache contains only partial pipeline.
                return null;
                    }

            if (this.toCacheSourceValidities != null) {
                // This means that the pipeline is valid based on the validities
                // of the individual components
                final AggregatedValidity validity = new AggregatedValidity();
                for (int i=0; i < this.toCacheSourceValidities.length; i++) {
                    validity.add(this.toCacheSourceValidities[i]);
                }

                return validity;
            }

            // This means that the pipeline is valid because it has not yet expired
            return NOPValidity.SHARED_INSTANCE;
        } else {
            int vals = 0;

            if (null != this.toCacheKey
                    && !this.cacheCompleteResponse
                    && this.firstNotCacheableTransformerIndex == super.transformers.size()) {
                vals = this.toCacheKey.size();
            } else if (null != this.fromCacheKey
                    && !this.completeResponseIsCached
                    && this.firstProcessedTransformerIndex == super.transformers.size()) {
                vals = this.fromCacheKey.size();
                    }

            if (vals > 0) {
                final AggregatedValidity validity = new AggregatedValidity();
                for (int i = 0; i < vals; i++) {
                    validity.add(getValidityForInternalPipeline(i));
                }

                return validity;
            }

            return null;
        }
    }
15765#/* (non-Javadoc)
     * @see org.apache.cocoon.components.pipeline.ProcessingPipeline#getKeyForEventPipeline()
     */
    public String getKeyForEventPipeline() {
        if (isInternalError()) {
            return null;
        }

        if (null != this.toCacheKey
                && !this.cacheCompleteResponse
                && this.firstNotCacheableTransformerIndex == super.transformers.size()) {
            return String.valueOf(HashUtil.hash(this.toCacheKey.toString()));
                }
        if (null != this.fromCacheKey
                && !this.completeResponseIsCached
                && this.firstProcessedTransformerIndex == super.transformers.size()) {
            return String.valueOf(HashUtil.hash(this.fromCacheKey.toString()));
                }

        return null;
    }
15766#SourceValidity getValidityForInternalPipeline(int index) {
        final SourceValidity validity;

        // if debugging try to tell why something is not cacheable
        final boolean debug = this.getLogger().isDebugEnabled();
        String msg = null;
        if(debug) msg = "getValidityForInternalPipeline(" + index + "): ";

        if (index == 0) {
            // test generator
            validity = ((CacheableProcessingComponent)super.generator).getValidity();
            if(debug) msg += "generator: using getValidity";
        } else if (index <= firstNotCacheableTransformerIndex) {
            // test transformer
            final Transformer trans = (Transformer)super.transformers.get(index-1);
            validity = ((CacheableProcessingComponent)trans).getValidity();
            if(debug) msg += "transformer: using getValidity";
        } else {
            // test serializer
            validity = ((CacheableProcessingComponent)super.serializer).getValidity();
            if(debug) msg += "serializer: using getValidity";
        }

        if(debug) {
            msg += ", validity==" + validity;
            this.getLogger().debug(msg);
        }
        return validity;
    }
15767#/**
     * Recyclable Interface
     */
    public void recycle() {
        this.generatorRole = null;
        this.transformerRoles.clear();
        this.serializerRole = null;
        this.readerRole = null;

        this.fromCacheKey = null;
        this.cachedResponse = null;

        this.toCacheKey = null;
        this.toCacheSourceValidities = null;

        super.recycle();
    }
15768#public DeferredPipelineValidity(AbstractCachingProcessingPipeline pipeline, int index) {
        this.pipeline = pipeline;
        this.index = index;
    }
15769#/**
     * @see org.apache.excalibur.source.impl.validity.DeferredValidity#getValidity()
     */
    public SourceValidity getValidity() {
        return pipeline.getValidityForInternalPipeline(this.index);
    }
15770#/**
    * The <code>CachingPointProcessingPipeline</code> is configurable.
    * The autoCachingPoint algorithm can be switced on/off
    * in the sitemap.xmap
    */
    public void parameterize(Parameters config) throws ParameterException {
        super.parameterize(config);
        this.autoCachingPointSwitch = config.getParameter("autoCachingPoint", null);

        if (this.getLogger().isDebugEnabled()) {
            getLogger().debug("Auto caching-point is set to = '" + this.autoCachingPointSwitch + "'");
        }

        // Default is that auto caching-point is on
        if (this.autoCachingPointSwitch == null){
            this.autoCachingPoint=true;
            return;
        }

        if (this.autoCachingPointSwitch.toLowerCase().equals("on")) {
            this.autoCachingPoint=true;
        } else {
            this.autoCachingPoint=false;
        }
    }
15771#/**
     * Set the generator.
     */
    public void setGenerator (String role, String source, Parameters param, Parameters hintParam)
    throws ProcessingException {
        super.setGenerator(role, source, param, hintParam);

        // check the hint param for a "caching-point" hint
        String pipelinehint = null;
        try {
            pipelinehint = hintParam.getParameter("caching-point", null);

            if (this.getLogger().isDebugEnabled()) {
                getLogger().debug("generator caching-point pipeline-hint is set to: " + pipelinehint);
            }
        } catch (Exception ex) {
            if (this.getLogger().isWarnEnabled()) {
                getLogger().warn("caching-point hint Exception, pipeline-hint ignored: " + ex);
            }
        }

        // if this generator is manually set to "caching-point" (via pipeline-hint)
        // then ensure the next component is caching.
        if ( "true".equals(pipelinehint)) {
            this.nextIsCachePoint=true;
        }
    }
15772#/**
     * Add a transformer.
     */
    public void addTransformer (String role, String source, Parameters param,  Parameters hintParam)
    throws ProcessingException {
        super.addTransformer(role, source, param, hintParam);

        // check the hint param for a "caching-point" hint
        String pipelinehint = null;
        try {
            pipelinehint = hintParam.getParameter("caching-point", null);

            if (this.getLogger().isDebugEnabled()) {
                getLogger().debug("transformer caching-point pipeline-hint is set to: " + pipelinehint);
            }
        } catch (Exception ex) {
            if (this.getLogger().isWarnEnabled()) {
                getLogger().warn("caching-point hint Exception, pipeline-hint ignored: " + ex);
            }
        }

        // add caching point flag
        // default value is false
        this.isCachePoint.add(Boolean.valueOf(this.nextIsCachePoint));
        this.nextIsCachePoint = false;

        // if this transformer is manually set to "caching-point" (via pipeline-hint)
        // then ensure the next component is caching.
        if ( "true".equals(pipelinehint)) {
            this.nextIsCachePoint=true;
        }
    }
15773#/**
     * Determine if the given branch-point
     * is a caching-point
     *
     * Please Note: this method is used by auto caching-point
     * and is of no consequence when auto caching-point is switched off
     */
    public void informBranchPoint() {

        if (this.generator == null) {
            return;
        }
        if (!this.autoCachingPoint) {
            return;
        }

        this.nextIsCachePoint = true;
        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("Informed Pipeline of branch point");
        }
    }
15774#/**
     * Cache longest cacheable path plus cache points.
     */
    protected CachedResponse cacheResults(Environment environment, OutputStream os)  throws Exception {
    	CachedResponse completeCachedResponse = null;

        if (this.toCacheKey != null) {
            if ( this.cacheCompleteResponse ) {
                if (this.getLogger().isDebugEnabled()) {
                    this.getLogger().debug("Cached: caching complete response; pSisze"
                                           + this.toCacheKey.size() + " Key " + this.toCacheKey);
                }
                CachedResponse response = new CachedResponse(this.toCacheSourceValidities,
                                          ((CachingOutputStream)os).getContent());
                response.setContentType(environment.getContentType());
                this.cache.store(this.toCacheKey.copy(),
                                 response);
                completeCachedResponse = response;
                //
                // Scan back along the pipelineCacheKey for
                // for any cachepoint(s)
                //
                this.toCacheKey.removeUntilCachePoint();

                //
                // adjust the validities object
                // to reflect the new length of the pipeline cache key.
                //
                // REVISIT: Is it enough to simply reduce the length of the validities array?
                //
                if (this.toCacheKey.size()>0) {
                    SourceValidity[] copy = new SourceValidity[this.toCacheKey.size()];
                    System.arraycopy(this.toCacheSourceValidities, 0,
                                     copy, 0, copy.length);
                    this.toCacheSourceValidities = copy;
                }
            }

            if (this.toCacheKey.size()>0) {
                ListIterator itt = this.xmlSerializerArray.listIterator(this.xmlSerializerArray.size());
                while (itt.hasPrevious()) {
                    XMLByteStreamCompiler serializer = (XMLByteStreamCompiler) itt.previous();
                    CachedResponse response = new CachedResponse(this.toCacheSourceValidities,
                                              (byte[])serializer.getSAXFragment());
                    this.cache.store(this.toCacheKey.copy(),
                                     response);

                    if (this.getLogger().isDebugEnabled()) {
                        this.getLogger().debug("Caching results for the following key: "
                            + this.toCacheKey);
                    }

                    //
                    // Check for further cachepoints
                    //
                    toCacheKey.removeUntilCachePoint();
                    if (this.toCacheKey.size()==0)
                        // no cachePoint found in key
                        break;

                    //
                    // re-calculate validities array
                    //
                    SourceValidity[] copy = new SourceValidity[this.toCacheKey.size()];
                    System.arraycopy(this.toCacheSourceValidities, 0,
                                     copy, 0, copy.length);
                    this.toCacheSourceValidities = copy;
                } //end serializer loop

            }
        }
        return completeCachedResponse;
    }
15775#/**
     * Create a new ComponentCachekey
     * ComponentCacheKeys can be flagged as cachepoints
     */
    protected ComponentCacheKey newComponentCacheKey(int type, String role,Serializable key) {
        boolean cachePoint = false;

        if (type == ComponentCacheKey.ComponentType_Transformer) {
            cachePoint =
                ((Boolean)this.isCachePoint.get(this.firstNotCacheableTransformerIndex)).booleanValue();
        } else if (type == ComponentCacheKey.ComponentType_Serializer) {
            cachePoint = this.nextIsCachePoint;
        }

        return new ComponentCacheKey(type, role, key, cachePoint);
    }
15776#/**
     * Connect the caching point pipeline.
     */
    protected void connectCachingPipeline(Environment   environment)
    throws ProcessingException {
        XMLByteStreamCompiler localXMLSerializer = null;
        XMLByteStreamCompiler cachePointXMLSerializer = null;
        if (!this.cacheCompleteResponse) {
            this.xmlSerializer = new XMLByteStreamCompiler();
            localXMLSerializer = this.xmlSerializer;
        }

        if (this.cachedResponse == null) {
            XMLProducer prev = super.generator;
            XMLConsumer next;

            int cacheableTransformerCount = this.firstNotCacheableTransformerIndex;
            int currentTransformerIndex = 0; //start with the first transformer

            Iterator itt = this.transformers.iterator();
            while ( itt.hasNext() ) {
                next = (XMLConsumer) itt.next();

                // if we have cacheable transformers,
                // check the tranformers for cachepoints
                if (cacheableTransformerCount > 0) {
                    if ( (this.isCachePoint.get(currentTransformerIndex) != null)  &&
                            ((Boolean)this.isCachePoint.get(currentTransformerIndex)).booleanValue()) {

                        cachePointXMLSerializer = new XMLByteStreamCompiler();
                        next = new XMLTeePipe(next, cachePointXMLSerializer);
                        this.xmlSerializerArray.add(cachePointXMLSerializer);
                    }
                }


                // Serializer is not cacheable,
                // but we  have the longest cacheable key. Do default longest key caching
                if (localXMLSerializer != null) {
                    if (cacheableTransformerCount == 0) {
                        next = new XMLTeePipe(next, localXMLSerializer);
                        this.xmlSerializerArray.add(localXMLSerializer);
                        localXMLSerializer = null;
                    } else {
                        cacheableTransformerCount--;
                    }
                }
                this.connect(environment, prev, next);
                prev = (XMLProducer) next;

                currentTransformerIndex++;
            }
            next = super.lastConsumer;


            // if the serializer is not cacheable, but all the transformers are:
            // (this is default longest key caching)
            if (localXMLSerializer != null) {
                next = new XMLTeePipe(next, localXMLSerializer);
                this.xmlSerializerArray.add(localXMLSerializer);
                localXMLSerializer = null;
            }

            // else if the serializer is cacheable and has cocoon views
            else if ((currentTransformerIndex == this.firstNotCacheableTransformerIndex) &&
                    this.nextIsCachePoint) {
                cachePointXMLSerializer = new XMLByteStreamCompiler();
                next = new XMLTeePipe(next, cachePointXMLSerializer);
                this.xmlSerializerArray.add(cachePointXMLSerializer);
            }
            this.connect(environment, prev, next);

        } else {
            // Here the first part of the pipeline has been retrived from cache
            // we now check if any part of the rest of the pipeline can be cached
            this.xmlDeserializer = new XMLByteStreamInterpreter();
            // connect the pipeline:
            XMLProducer prev = xmlDeserializer;
            XMLConsumer next;
            int cacheableTransformerCount = 0;
            Iterator itt = this.transformers.iterator();
            while ( itt.hasNext() ) {
                next = (XMLConsumer) itt.next();

                if (cacheableTransformerCount >= this.firstProcessedTransformerIndex) {

                    // if we have cacheable transformers left,
                    // then check the tranformers for cachepoints
                    if (cacheableTransformerCount < this.firstNotCacheableTransformerIndex) {
                        if ( !(prev instanceof XMLByteStreamInterpreter) &&
                                (this.isCachePoint.get(cacheableTransformerCount) != null)  &&
                                ((Boolean)this.isCachePoint.get(cacheableTransformerCount)).booleanValue()) {
                            cachePointXMLSerializer = new XMLByteStreamCompiler();
                            next = new XMLTeePipe(next, cachePointXMLSerializer);
                            this.xmlSerializerArray.add(cachePointXMLSerializer);
                        }
                    }

                    // Serializer is not cacheable,
                    // but we  have the longest cacheable key. Do default longest key caching
                    if (localXMLSerializer != null && !(prev instanceof XMLByteStreamInterpreter)
                            && cacheableTransformerCount == this.firstNotCacheableTransformerIndex) {
                        next = new XMLTeePipe(next, localXMLSerializer);
                        this.xmlSerializerArray.add(localXMLSerializer);
                        localXMLSerializer = null;
                    }
                    this.connect(environment, prev, next);
                    prev = (XMLProducer)next;
                }
                cacheableTransformerCount++;
            }
            next = super.lastConsumer;

            //*all* the transformers are cacheable, but the serializer is not!! this is longest key
            if (localXMLSerializer != null && !(prev instanceof XMLByteStreamInterpreter)) {
                next = new XMLTeePipe(next, localXMLSerializer);
                this.xmlSerializerArray.add(localXMLSerializer);
                localXMLSerializer = null;
            } else if (this.nextIsCachePoint && !(prev instanceof XMLByteStreamInterpreter) &&
                    cacheableTransformerCount == this.firstNotCacheableTransformerIndex) {
                // else the serializer is cacheable but has views
                cachePointXMLSerializer = new XMLByteStreamCompiler();
                next = new XMLTeePipe(next,  cachePointXMLSerializer);
                this.xmlSerializerArray.add(cachePointXMLSerializer);
            }
            this.connect(environment, prev, next);
        }
    }
15777#/**
     * Recyclable Interface
     */
    public void recycle() {
        super.recycle();

        Iterator itt = this.xmlSerializerArray.iterator();
        while (itt.hasNext()) {
            this.manager.release(itt.next());
        }

        this.isCachePoint.clear();
        this.xmlSerializerArray.clear();
        this.nextIsCachePoint = false;
        this.autoCachingPointSwitch=null;
    }
15778#/**
    * Cache longest cacheable key
    */
    protected CachedResponse cacheResults(Environment environment, OutputStream os)  throws Exception {
        if (this.toCacheKey != null) {
            // See if there is an expires object for this resource.
            Long expiresObj = (Long) environment.getObjectModel().get(ObjectModelHelper.EXPIRES_OBJECT);

            CachedResponse response;
            if (this.cacheCompleteResponse) {
                response = new CachedResponse(this.toCacheSourceValidities,
                                              ((CachingOutputStream) os).getContent(),
                                              expiresObj);
                response.setContentType(environment.getContentType());
            } else {
                response = new CachedResponse(this.toCacheSourceValidities,
                                              (byte[]) this.xmlSerializer.getSAXFragment(),
                                              expiresObj);
            }

            this.cache.store(this.toCacheKey, response);
            return response;
        }
        return null;
    }
15779#/**
     * Create a new cache key
     */
    protected ComponentCacheKey newComponentCacheKey(int type, String role,Serializable key) {
        return new ComponentCacheKey(type, role, key);
    }
15780#/**
     * Connect the pipeline.
     */
    protected void connectCachingPipeline(Environment   environment)
    throws ProcessingException {
        XMLByteStreamCompiler localXMLSerializer = null;
        if (!this.cacheCompleteResponse) {
            this.xmlSerializer = new XMLByteStreamCompiler();
            localXMLSerializer = this.xmlSerializer;
        }

        if (this.cachedResponse == null) {
            XMLProducer prev = super.generator;
            XMLConsumer next;

            int cacheableTransformerCount = this.firstNotCacheableTransformerIndex;

            Iterator itt = this.transformers.iterator();
            while (itt.hasNext()) {
                next = (XMLConsumer) itt.next();
                if (localXMLSerializer != null) {
                    if (cacheableTransformerCount == 0) {
                        next = new XMLTeePipe(next, localXMLSerializer);
                        localXMLSerializer = null;
                    } else {
                        cacheableTransformerCount--;
                    }
                }
                connect(environment, prev, next);
                prev = (XMLProducer) next;
            }

            next = super.lastConsumer;
            if (localXMLSerializer != null) {
                next = new XMLTeePipe(next, localXMLSerializer);
                localXMLSerializer = null;
            }
            connect(environment, prev, next);
        } else {
            this.xmlDeserializer = new XMLByteStreamInterpreter();

            // connect the pipeline:
            XMLProducer prev = xmlDeserializer;
            XMLConsumer next;
            int cacheableTransformerCount = 0;
            Iterator itt = this.transformers.iterator();
            while (itt.hasNext()) {
                next = (XMLConsumer) itt.next();
                if (cacheableTransformerCount >= this.firstProcessedTransformerIndex) {
                    if (localXMLSerializer != null
                            && cacheableTransformerCount == this.firstNotCacheableTransformerIndex) {
                        next = new XMLTeePipe(next, localXMLSerializer);
                        localXMLSerializer = null;
                    }
                    connect(environment, prev, next);
                    prev = (XMLProducer) next;
                }
                cacheableTransformerCount++;
            }

            next = super.lastConsumer;
            if (localXMLSerializer != null) {
                next = new XMLTeePipe(next, localXMLSerializer);
                localXMLSerializer = null;
            }
            connect(environment, prev, next);
        }
    }
15781#public void parameterize(Parameters params)
    throws ParameterException {
        super.parameterize(params);

        this.defaultCacheExpires = params.getParameterAsLong("cache-expires", this.defaultCacheExpires);
    }
15782#/**
     * Process the given <code>Environment</code>, producing the output.
     */
    protected boolean processXMLPipeline(Environment environment)
    throws ProcessingException {
        try {
            if (this.cachedResponse != null) {
                byte[] content = cachedResponse.getResponse();

                if ( this.serializer == this.lastConsumer ) {
                    if ( cachedResponse.getContentType() != null ) {
                        environment.setContentType(cachedResponse.getContentType());
                    } else {
                        this.setMimeTypeForSerializer(environment);
                    }
                    final OutputStream outputStream = environment.getOutputStream(0);
                    if (content.length > 0) {
                        environment.setContentLength(content.length);
                        outputStream.write(content);
                    }
                } else {
                    this.setMimeTypeForSerializer(environment);
                    this.xmlDeserializer.setConsumer( this.lastConsumer );
                    this.xmlDeserializer.deserialize( content );
                }

            } else {

                // generate new response

                if ( this.cacheExpires == 0 ) {
                    return super.processXMLPipeline( environment );
                }

                this.setMimeTypeForSerializer(environment);
                byte[] cachedData;
                if ( this.serializer == this.lastConsumer ) {

                    if (this.serializer.shouldSetContentLength()) {
                        OutputStream os = environment.getOutputStream(this.outputBufferSize);

                        // set the output stream
                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
                        this.serializer.setOutputStream(baos);

                        this.generator.generate();

                        cachedData = baos.toByteArray();
                        environment.setContentLength(cachedData.length);
                        os.write(cachedData);
                    } else {
                        CachingOutputStream os = new CachingOutputStream( environment.getOutputStream(this.outputBufferSize) );
                        // set the output stream
                        this.serializer.setOutputStream( os );
                        this.generator.generate();

                        cachedData = os.getContent();
                    }

                } else {
                    this.generator.generate();
                    cachedData = (byte[])this.xmlSerializer.getSAXFragment();
                }

                //
                // Now that we have processed the pipeline,
                // we do the actual caching
                //
                if (this.cacheValidity != null) {
                    cachedResponse = new CachedResponse(this.cacheValidity,
                                                        cachedData);
                    cachedResponse.setContentType(environment.getContentType());
                    this.cache.store(this.cacheKey, cachedResponse);
                }
            }
        } catch (Exception e) {
            handleException(e);
        }

        //Request has been succesfully processed, set approporiate status code
        environment.setStatus(HttpServletResponse.SC_OK);
        return true;
    }
15783#/**
     * Connect the XML pipeline.
     */
    protected void connectPipeline(Environment environment)
    throws ProcessingException {
        if ( this.lastConsumer != this.serializer ) {
            // internal
            if ( this.cachedResponse == null) {
                // if we cache, we need an xml serializer
                if ( this.cacheExpires != 0) {
                    final XMLConsumer old = this.lastConsumer;
                    this.xmlSerializer = new XMLByteStreamCompiler();
                    this.lastConsumer = new XMLTeePipe(this.lastConsumer, this.xmlSerializer);

                    super.connectPipeline( environment );

                    this.lastConsumer = old;
                } else {
                    super.connectPipeline( environment );
                }
            } else {
                // we use the cache, so we need an xml deserializer
                this.xmlDeserializer = new XMLByteStreamInterpreter();
            }
        } else {
            // external: we only need to connect if we don't use a cached response
            if ( this.cachedResponse == null) {
                super.connectPipeline( environment );
            }
        }
    }
15784#/**
     * Prepare the pipeline
     */
    protected void preparePipeline(Environment environment)
    throws ProcessingException {
        // get the key and the expires info
        // we must do this before we call super.preparePipeline,
        // otherwise internal pipelines are instantiated and
        // get a copy of the object model with our info!
        final Map objectModel = environment.getObjectModel();
        String key = (String)objectModel.get(CACHE_KEY_KEY);
        if ( key == null ) {
            key = this.parameters.getParameter("cache-key", null);
            if ( key == null ) {
                key = environment.getURIPrefix()+environment.getURI();
            }
        } else {
            objectModel.remove(CACHE_KEY_KEY);
        }
        String expiresValue = (String)objectModel.get(CACHE_EXPIRES_KEY);
        if ( expiresValue == null ) {
            this.cacheExpires = this.parameters.getParameterAsLong("cache-expires", this.defaultCacheExpires);
        } else {
            this.cacheExpires = Long.valueOf(expiresValue).longValue();
            objectModel.remove(CACHE_EXPIRES_KEY);
        }

        // prepare the pipeline
        super.preparePipeline( environment );

        // and now prepare the caching information
        this.cacheKey = new IdentifierCacheKey(key,
                                           this.serializer == this.lastConsumer);
        if ( this.cacheExpires > 0) {
            this.cacheValidity = new ExpiresValidity(this.cacheExpires*1000);
        } else if ( this.cacheExpires < 0 ) {
            this.cacheValidity = NOPValidity.SHARED_INSTANCE;
        }
        final boolean purge = this.parameters.getParameterAsBoolean("purge-cache", false);

        this.cachedResponse = this.cache.get(this.cacheKey);
        if ( this.cachedResponse != null ) {
            final SourceValidity sv = cachedResponse.getValidityObjects()[0];
            if ( purge
                 || (this.cacheExpires != -1 && sv.isValid() != SourceValidity.VALID) ) {
                this.cache.remove( this.cacheKey );
                this.cachedResponse = null;
            }
        }
        if ( this.cacheExpires > 0
             && (this.reader != null || this.lastConsumer == this.serializer )) {
            Response res = ObjectModelHelper.getResponse(environment.getObjectModel());
            res.setDateHeader("Expires", System.currentTimeMillis() + (this.cacheExpires*1000));
            res.setHeader("Cache-Control", "max-age=" + this.cacheExpires + ", public");
        }
    }
15785#/**
     * Return valid validity objects for the event pipeline
     * If the "event pipeline" (= the complete pipeline without the
     * serializer) is cacheable and valid, return all validity objects.
     * Otherwise return <code>null</code>
     */
    public SourceValidity getValidityForEventPipeline() {
        return this.cacheValidity;
    }
15786#/* (non-Javadoc)
     * @see org.apache.cocoon.components.pipeline.ProcessingPipeline#getKeyForEventPipeline()
     */
    public String getKeyForEventPipeline() {
        if (this.cacheKey != null && this.cacheValidity != null) {
            return this.cacheKey.toString();
        }
        return null;
    }
15787#/**
     * Recyclable Interface
     */
    public void recycle() {
        this.cacheKey = null;
        this.cacheExpires = 0;
        this.cachedResponse = null;
        super.recycle();
    }
15788#/* (non-Javadoc)
     * @see org.apache.cocoon.components.pipeline.AbstractProcessingPipeline#processReader(org.apache.cocoon.environment.Environment)
     */
    protected boolean processReader(Environment environment)
    throws ProcessingException {
        try {
            if (this.cachedResponse != null) {
                if ( cachedResponse.getContentType() != null ) {
                    environment.setContentType(cachedResponse.getContentType());
                } else {
                    this.setMimeTypeForReader(environment);
                }

                final byte[] content = cachedResponse.getResponse();
                environment.setContentLength(content.length);

                final OutputStream os = environment.getOutputStream(0);
                os.write(content);

            } else {
                // generate new response

                if ( this.cacheExpires == 0 ) {
                    return super.processReader( environment );
                }

                byte[] cachedData;

                this.setMimeTypeForReader(environment);
                if (this.reader.shouldSetContentLength()) {
                    final OutputStream os = environment.getOutputStream(this.outputBufferSize);

                    // set the output stream
                    final ByteArrayOutputStream baos = new ByteArrayOutputStream();
                    this.reader.setOutputStream(baos);

                    this.reader.generate();

                    cachedData = baos.toByteArray();
                    environment.setContentLength(cachedData.length);
                    os.write(cachedData);
                } else {
                    final CachingOutputStream os = new CachingOutputStream( environment.getOutputStream(this.outputBufferSize) );
                    // set the output stream
                    this.reader.setOutputStream( os );
                    this.reader.generate();

                    cachedData = os.getContent();
                }

                //
                // Now that we have processed the pipeline,
                // we do the actual caching
                //
                if (this.cacheValidity != null) {
                    cachedResponse = new CachedResponse(this.cacheValidity,
                                                        cachedData);
                    cachedResponse.setContentType(environment.getContentType());
                    this.cache.store(this.cacheKey, cachedResponse);
                }
            }
        } catch (Exception e) {
            handleException(e);
        }

        //Request has been succesfully processed, set approporiate status code
        environment.setStatus(HttpServletResponse.SC_OK);
        return true;
    }
15789#public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if (bean instanceof Generator || bean instanceof Transformer || bean instanceof Serializer) {
            bean = Proxy.newProxyInstance(bean.getClass().getClassLoader(), getInterfaces(bean.getClass()), 
                                          new ScopeChangerProxy(bean, holder));
        }
        return bean;
    }
15790#public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
15791#public PipelineComponentScopeHolder getHolder() {
        return holder;
    }
15792#public void setHolder(PipelineComponentScopeHolder holder) {
        this.holder = holder;
    }
15793#//Copied from org.apache.cocoon.servletservice.DispatcherServlet
    
    private void getInterfaces(Set interfaces, Class clazz) {
        Class[] clazzInterfaces = clazz.getInterfaces();
        for (int i = 0; i < clazzInterfaces.length; i++) {
            //add all interfaces extended by this interface or directly
            //implemented by this class
            getInterfaces(interfaces, clazzInterfaces[i]);
        }

        //the superclazz is null if class is instanceof Object, is
        //an interface, a primitive type or void
        Class superclazz = clazz.getSuperclass();
        if (superclazz != null) {
            //add all interfaces of the superclass to the list
            getInterfaces(interfaces, superclazz);
        }

        interfaces.addAll(Arrays.asList(clazzInterfaces));
    }
15794#private Class[] getInterfaces(Class clazz) {
        Set interfaces = new LinkedHashSet();
        getInterfaces(interfaces, clazz);
        return (Class[]) interfaces.toArray(new Class[interfaces.size()]);
    }
15795#public ScopeChangerProxy(Object wrapped, PipelineComponentScopeHolder holder) {
            this.wrapped = wrapped;
            this.holder = holder;
            this.beans = new HashMap();
            this.destructionCallbacks = new HashMap();
        }
15796#public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            Object result;
            boolean modified = false;
            try {
                if (!holder.getInScope()) {
                    holder.setParentBeans(holder.getBeans());
                    holder.setParentDestructionCallbacks(holder.getDestructionCallbacks());
                    holder.setBeans(beans);
                    holder.setDestructionCallbacks(destructionCallbacks);
                    holder.setInScope(true);
                    modified = true;
                }
                result = method.invoke(wrapped, args);
            } finally {
                if (modified) {
                    holder.setBeans(holder.getParentBeans());
                    holder.setDestructionCallbacks(holder.getParentDestructionCallbacks());
                    holder.setParentBeans(null);
                    holder.setParentDestructionCallbacks(null);
                    holder.setInScope(false);
                }
            }
            return result;
        }
15797#//FIXME: This interface needs redesign

    public Map getBeans();
15798#public void setBeans(Map beans);
15799#public Map getParentBeans();
15800#public void setParentBeans(Map parentBeans);
15801#public Map getDestructionCallbacks();
15802#public void setDestructionCallbacks(Map destructionCallbacks);
15803#public Map getParentDestructionCallbacks();
15804#public void setParentDestructionCallbacks(Map destructionCallbacks);
15805#public void setInScope(boolean inScope);
15806#public boolean getInScope();
15807#public PipelineComponentScopeHolderImpl() {
        beans = new HashMap();
        destructionCallbacks = new HashMap();
        parentBeans = null;
        parentDestructionCallbacks = null;
        inScope = false;
    }
15808#/* (non-Javadoc)
     * @see org.apache.cocoon.components.pipeline.spring.PipelineComponentScopeHolder#getBeans()
     */
    public Map getBeans() {
        return beans;
    }
15809#/* (non-Javadoc)
     * @see org.apache.cocoon.components.pipeline.spring.PipelineComponentScopeHolder#setBeans(java.util.Map)
     */
    public void setBeans(Map beans) {
        this.beans = beans;
    }
15810#/* (non-Javadoc)
     * @see org.apache.cocoon.components.pipeline.spring.PipelineComponentScopeHolder#getDestructionCallbacks()
     */
    public Map getDestructionCallbacks() {
        return destructionCallbacks;
    }
15811#/* (non-Javadoc)
     * @see org.apache.cocoon.components.pipeline.spring.PipelineComponentScopeHolder#setDestructionCallbacks(java.util.Map)
     */
    public void setDestructionCallbacks(Map destructionCallbacks) {
        this.destructionCallbacks = destructionCallbacks;
    }
15812#/* (non-Javadoc)
     * @see org.apache.cocoon.components.pipeline.spring.PipelineComponentScopeHolder#getParentBeans()
     */
    public Map getParentBeans() {
        return parentBeans;
    }
15813#/* (non-Javadoc)
     * @see org.apache.cocoon.components.pipeline.spring.PipelineComponentScopeHolder#getParentDestructionCallbacks()
     */
    public Map getParentDestructionCallbacks() {
        return parentDestructionCallbacks;
    }
15814#/* (non-Javadoc)
     * @see org.apache.cocoon.components.pipeline.spring.PipelineComponentScopeHolder#setParentBeans()
     */
    public void setParentBeans(Map parentBeans) {
        this.parentBeans = parentBeans;
    }
15815#/* (non-Javadoc)
     * @see org.apache.cocoon.components.pipeline.spring.PipelineComponentScopeHolder#setParentDestructionCallbacks(java.util.Map)
     */
    public void setParentDestructionCallbacks(Map destructionCallbacks) {
        this.parentDestructionCallbacks = destructionCallbacks;
    }
15816#public boolean getInScope() {
        return inScope;
    }
15817#public void setInScope(boolean inScope) {
        this.inScope = inScope;
    }
15818#public PipelineComponentScopeHolder getHolder() {
        return holder;
    }
15819#public void setHolder(PipelineComponentScopeHolder holder) {
        this.holder = holder;
    }
15820#/* (non-Javadoc)
     * @see org.springframework.beans.factory.config.Scope#get(java.lang.String, org.springframework.beans.factory.ObjectFactory)
     */
    public Object get(String name, ObjectFactory objectFactory) {
        Object bean = holder.getBeans().get(name);
        if (bean == null) {
            bean = objectFactory.getObject();
            holder.getBeans().put(name, bean);
            if (bean instanceof ObjectModel && holder.getInScope()) {
                //FIXME: This should be moved to separate BeanPostProcessor
                ((ObjectModel)bean).setParent((ObjectModel)holder.getParentBeans().get(name));
            }
        }
        return bean;
    }
15821#/* (non-Javadoc)
     * @see org.springframework.beans.factory.config.Scope#getConversationId()
     */
    public String getConversationId() {
        // There is no conversation id concept for the pipeline component scope
        return null;
    }
15822#/* (non-Javadoc)
     * @see org.springframework.beans.factory.config.Scope#registerDestructionCallback(java.lang.String, java.lang.Runnable)
     */
    public void registerDestructionCallback(String name, Runnable callback) {
        holder.getDestructionCallbacks().put(name, callback);
    }
15823#/* (non-Javadoc)
     * @see org.springframework.beans.factory.config.Scope#remove(java.lang.String)
     */
    public Object remove(String name) {
        Object bean = holder.getBeans().get(name); 
        if (bean != null) {
            holder.getBeans().remove(name);
            holder.getDestructionCallbacks().remove(name);
        }
        return bean;
    }
15824#/**
     * Set the <code>XMLConsumer</code> that will receive XML data.
     * <br>
     * This method will simply call <code>setContentHandler(consumer)</code>
     * and <code>setLexicalHandler(consumer)</code>.
     */
    public void setConsumer(XMLConsumer consumer) {
        setContentHandler(consumer);
        setLexicalHandler(consumer);
    }
15825#/**
     * Set the <code>ContentHandler</code> that will receive XML data.
     * <br>
     * Subclasses may retrieve this <code>ContentHandler</code> instance
     * accessing the protected <code>super.contentHandler</code> field.
     */
    public void setContentHandler(ContentHandler handler) {
        this.contentHandler = handler;
    }
15826#/**
     * Set the <code>LexicalHandler</code> that will receive XML data.
     * <br>
     * Subclasses may retrieve this <code>LexicalHandler</code> instance
     * accessing the protected <code>super.lexicalHandler</code> field.
     */
    public void setLexicalHandler(LexicalHandler handler) {
        this.lexicalHandler = handler;
    }
15827#public void recycle() {
        this.contentHandler = EMPTY_CONTENT_HANDLER;
        this.lexicalHandler = DefaultLexicalHandler.NULL_HANDLER;
        this.list.clear();
    }
15828#/**
     * This method needs to be used by sub classes to start the parsing of the byte stream
     *
     * @throws SAXException
     */
    protected void parse() throws SAXException {
        this.list.clear();
        this.checkProlog();
        int event = -1;
        int lastEvent = -1;
        while ( ( event = readEvent() ) != -1 ) {
            lastEvent = event;
            switch (event) {
                case START_DOCUMENT:
                    contentHandler.startDocument();
                    break;
                case END_DOCUMENT:
                    contentHandler.endDocument();
                    break;
                case START_PREFIX_MAPPING:
                    contentHandler.startPrefixMapping(this.readString(), this.readString());
                    break;
                case END_PREFIX_MAPPING:
                    contentHandler.endPrefixMapping(this.readString());
                    break;
                case START_ELEMENT:
                    int attributes = this.readAttributes();
                    AttributesImpl atts = new AttributesImpl();
                    for (int i = 0; i < attributes; i++) {
                        atts.addAttribute(this.readString(), this.readString(), this.readString(), this.readString(), this.readString());
                    }
                    contentHandler.startElement(this.readString(), this.readString(), this.readString(), atts);
                    break;
                case END_ELEMENT:
                    contentHandler.endElement(this.readString(), this.readString(), this.readString());
                    break;
                case CHARACTERS:
                    char[] chars = this.readChars();
                    int len = chars.length;
                    while (len > 0 && chars[len-1]==0) len--;
                    if (len > 0) contentHandler.characters(chars, 0, len);
                    break;
                case IGNORABLE_WHITESPACE:
                    char[] spaces = this.readChars();
                    len = spaces.length;
                    while (len > 0 && spaces[len-1]==0) len--;
                    if (len > 0) contentHandler.characters(spaces, 0, len);
                    break;
                case PROCESSING_INSTRUCTION:
                    contentHandler.processingInstruction(this.readString(), this.readString());
                    break;
                case COMMENT:
                    chars = this.readChars();
                    len = chars.length;
                    while (len > 0 && chars[len-1]==0) len--;
                    if (len > 0) lexicalHandler.comment(chars, 0, len);
                    break;
                case LOCATOR:
                    {
                    String publicId = this.readString();
                    String systemId = this.readString();
                    int lineNumber = this.read();
                    int columnNumber = this.read();
                    org.xml.sax.helpers.LocatorImpl locator = new org.xml.sax.helpers.LocatorImpl();
                    locator.setPublicId(publicId);
                    locator.setSystemId(systemId);
                    locator.setLineNumber(lineNumber);
                    locator.setColumnNumber(columnNumber);
                    contentHandler.setDocumentLocator(locator);
                    }
                    break;
                case START_DTD:
                    lexicalHandler.startDTD(this.readString(),
                                            this.readString(),
                                            this.readString());
                    break;
                case END_DTD:
                    lexicalHandler.endDTD();
                    break;
                case START_CDATA:
                    lexicalHandler.startCDATA();
                    break;
                case END_CDATA:
                    lexicalHandler.endCDATA();
                    break;
                case SKIPPED_ENTITY:
                    contentHandler.skippedEntity( this.readString() );
                    break;
                case START_ENTITY:
                    lexicalHandler.startEntity( this.readString() );
                    break;
                case END_ENTITY:
                    lexicalHandler.endEntity( this.readString() );
                    break;
                default:
                    throw new SAXException ("parsing error: event not supported: " + event);
            }
        }
        if( lastEvent != END_DOCUMENT )
        {
            throw new SAXException ("parsing error: premature end of stream (lastEvent was " + lastEvent + ")." );
        }
    }
15829#protected int readEvent() throws SAXException {
        return this.read();
    }
15830#private int readAttributes() throws SAXException {
        int ch1 = this.read();
        int ch2 = this.read();
        return ((ch1 << 8) + (ch2 << 0));
    }
15831#private String readString() throws SAXException {
        int length = this.readWord();
        int index;
        if (length >= 0x00008000) {
            // index value in 16-bits format
            index = length & 0x00007FFF;
            return (String) list.get(index);
        } else {
            if (length == 0x00007FFF) {
                length = this.readLong();
                if (length >= 0x80000000) {
                    // index value in 32-bits format
                    index = length & 0x7fffffff;
                    return (String) list.get(index);
                }
            }
            char[] chars = this.readChars(length);
            int len = chars.length;
            if (len > 0) {
                while (chars[len-1]==0) len--;
            }
            String str;
            if (len == 0) {
                str = "";
            } else {
                str = new String(chars, 0, len);
            }
            list.add(str);
            return str;
        }
    }
15832#/**
     * The returned char array might contain any number of zero bytes
     * at the end
     */
    private char[] readChars() throws SAXException {
        int length = this.readWord();
        if (length == 0x00007FFF) {
            length = this.readLong();
        }
        return this.readChars(length);
    }
15833#protected abstract int read() throws SAXException;
15834#protected abstract int read(byte[] b) throws SAXException;
15835#/**
     * The returned char array might contain any number of zero bytes
     * at the end
     */
    private char[] readChars(int len) throws SAXException {
        char[] str = new char[len];
        byte[] bytearr = new byte[len];
        int c, char2, char3;
        int count = 0;
        int i = 0;

        this.readBytes(bytearr);

        while (count < len) {
            c = bytearr[count] & 0xff;
            switch (c >> 4) {
                case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
                    // 0xxxxxxx
                    count++;
                    str[i++] = (char) c;
                    break;
                case 12: case 13:
                    // 110x xxxx   10xx xxxx
                    count += 2;
                    char2 = bytearr[count-1];
                    str[i++] = (char) (((c & 0x1F) << 6) | (char2 & 0x3F));
                    break;
                case 14:
                    // 1110 xxxx  10xx xxxx  10xx xxxx
                    count += 3;
                    char2 = bytearr[count-2];
                    char3 = bytearr[count-1];
                    str[i++] = ((char)(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0)));
                    break;
                default:
                    // 10xx xxxx,  1111 xxxx
                    throw new SAXException("UTFDataFormatException");
            }
        }

        return str;
    }
15836#private void readBytes(byte[] b) throws SAXException {
        final int bytesRead = this.read( b );
        if (bytesRead < b.length ) {
            throw new SAXException("End of is reached.");
        }
    }
15837#private int readWord() throws SAXException {
        int ch1 = this.read();
        int ch2 = this.read();
        return ((ch1 << 8) + (ch2 << 0));
    }
15838#private int readLong() throws SAXException {
        int ch1 = this.read();
        int ch2 = this.read();
        int ch3 = this.read();
        int ch4 = this.read();
        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));
    }
15839#private void checkProlog() throws SAXException {
        int valid = 0;
        int ch = 0;
        if ((ch = this.read()) == 'C') valid++;
        else throw new SAXException("Unrecognized file format (." + valid + "," + ch + ")");
        if ((ch = this.read()) == 'X') valid++;
        else throw new SAXException("Unrecognized file format (." + valid + "," + ch + ")");
        if ((ch = this.read()) == 'M') valid++;
        else throw new SAXException("Unrecognized file format (." + valid + "," + ch + ")");
        if ((ch = this.read()) == 'L') valid++;
        else throw new SAXException("Unrecognized file format (." + valid + "," + ch + ")");
        if ((ch = this.read()) == 1) valid++;
        else throw new SAXException("Unrecognized file format (." + valid + "," + ch + ")");
        if ((ch = this.read()) == 0) valid++;
        else throw new SAXException("Unrecognized file format (." + valid + "," + ch + ")");
    }
15840#/**
     * Create a new XMLTeePipe with two consumers
     */
    public XMLTeePipe(XMLConsumer firstPipe,
                      XMLConsumer secondConsumer) {
        this.firstConsumer = firstPipe;
        this.secondConsumer = secondConsumer;
    }
15841#/**
     * Set the <code>XMLConsumer</code> that will receive XML data.
     */
    public void setConsumer(XMLConsumer consumer) {
        ((XMLProducer) this.firstConsumer).setConsumer(consumer);
    }
15842#/**
     * Reset consumers.
     */
    public void recycle() {
        this.firstConsumer = null;
        this.secondConsumer = null;
    }
15843#//
    // XMLPipe interface
    //

    public void startDocument() throws SAXException {
        this.firstConsumer.startDocument();
        this.secondConsumer.startDocument();
    }
15844#public void endDocument() throws SAXException {
        this.firstConsumer.endDocument();
        this.secondConsumer.endDocument();
    }
15845#public void startPrefixMapping(String prefix, String uri) throws SAXException {
        this.firstConsumer.startPrefixMapping(prefix, uri);
        this.secondConsumer.startPrefixMapping(prefix, uri);
    }
15846#public void endPrefixMapping(String prefix) throws SAXException {
        this.firstConsumer.endPrefixMapping(prefix);
        this.secondConsumer.endPrefixMapping(prefix);
    }
15847#public void startElement(String namespaceURI, String localName, String qName, Attributes atts)
    throws SAXException {
        this.firstConsumer.startElement(namespaceURI, localName, qName, atts);
        this.secondConsumer.startElement(namespaceURI, localName, qName, atts);
    }
15848#public void endElement(String namespaceURI, String localName, String qName)
    throws SAXException {
        this.firstConsumer.endElement(namespaceURI, localName, qName);
        this.secondConsumer.endElement(namespaceURI, localName, qName);
    }
15849#public void characters(char[] ch, int start, int length) throws SAXException {
        this.firstConsumer.characters(ch, start, length);
        this.secondConsumer.characters(ch, start, length);
    }
15850#public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        this.firstConsumer.ignorableWhitespace(ch, start, length);
        this.secondConsumer.ignorableWhitespace(ch, start, length);
    }
15851#public void processingInstruction(String target, String data) throws SAXException {
        this.firstConsumer.processingInstruction(target, data);
        this.secondConsumer.processingInstruction(target, data);
    }
15852#public void setDocumentLocator(Locator locator) {
        this.firstConsumer.setDocumentLocator(locator);
        this.secondConsumer.setDocumentLocator(locator);
    }
15853#public void skippedEntity(String name) throws SAXException {
        this.firstConsumer.skippedEntity(name);
        this.secondConsumer.skippedEntity(name);
    }
15854#public void startDTD(String name, String public_id, String system_id)
    throws SAXException {
        this.firstConsumer.startDTD(name, public_id, system_id);
        this.secondConsumer.startDTD(name, public_id, system_id);
    }
15855#public void endDTD() throws SAXException {
        this.firstConsumer.endDTD();
        this.secondConsumer.endDTD();
    }
15856#public void startEntity(String name) throws SAXException {
        this.firstConsumer.startEntity(name);
        this.secondConsumer.startEntity(name);
    }
15857#public void endEntity(String name) throws SAXException {
        this.firstConsumer.endEntity(name);
        this.secondConsumer.endEntity(name);
    }
15858#public void startCDATA() throws SAXException {
        this.firstConsumer.startCDATA();
        this.secondConsumer.startCDATA();
    }
15859#public void endCDATA() throws SAXException {
        this.firstConsumer.endCDATA();
        this.secondConsumer.endCDATA();
    }
15860#public void comment(char ary[], int start, int length)
    throws SAXException {
        this.firstConsumer.comment(ary, start, length);
        this.secondConsumer.comment(ary, start, length);
    }
15861#protected AbstractXMLByteStreamCompiler() {
        this.map = new HashMap();
        this.initOutput();
    }
15862#private void initOutput() {
        this.mapCount = 0;
        this.map.clear();
        this.hasProlog = false;
    }
15863#public void recycle() {
        this.initOutput();
    }
15864#public void startDocument() throws SAXException {
        if(!hasProlog)
            writeProlog();
        this.writeEvent(START_DOCUMENT);
    }
15865#public void endDocument() throws SAXException {
        this.writeEvent(END_DOCUMENT);
    }
15866#public void startPrefixMapping(java.lang.String prefix, java.lang.String uri) throws SAXException {
        if(!hasProlog)
            writeProlog();
        this.writeEvent(START_PREFIX_MAPPING);
        this.writeString(prefix);
        this.writeString(uri);
    }
15867#public void endPrefixMapping(String prefix) throws SAXException {
       this.writeEvent(END_PREFIX_MAPPING);
       this.writeString(prefix);
    }
15868#public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {
        int length = atts.getLength();
        this.writeEvent(START_ELEMENT);
        this.writeAttributes(length);
        for (int i = 0; i < length; i++) {
            this.writeString(atts.getURI(i));
            this.writeString(atts.getLocalName(i));
            this.writeString(atts.getQName(i));
            this.writeString(atts.getType(i));
            this.writeString(atts.getValue(i));
         }
         this.writeString((namespaceURI == null ? "" : namespaceURI));
         this.writeString(localName);
         this.writeString(qName);
     }
15869#public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
        this.writeEvent(END_ELEMENT);
        this.writeString((namespaceURI == null ? "" : namespaceURI));
        this.writeString(localName);
        this.writeString(qName);
    }
15870#public void characters(char[] ch, int start, int length) throws SAXException {
        this.writeEvent(CHARACTERS);
        this.writeChars(ch, start, length);
    }
15871#public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        if(!hasProlog)
            writeProlog();
        this.writeEvent(IGNORABLE_WHITESPACE);
        this.writeChars(ch, start, length);
    }
15872#public void processingInstruction(String target, String data) throws SAXException {
        this.writeEvent(PROCESSING_INSTRUCTION);
        this.writeString(target);
        this.writeString(data);
    }
15873#public void setDocumentLocator(Locator locator) {
        try {
            if(!hasProlog)
                writeProlog();
            this.writeEvent(LOCATOR);
            String publicId = locator.getPublicId();
            String systemId = locator.getSystemId();
            this.writeString(publicId!=null?publicId:"");
            this.writeString(systemId!=null?systemId:"");
            this.write(locator.getLineNumber());
            this.write(locator.getColumnNumber());
        } catch (Exception e) {
             throw new DocumentLocatorException("Error while handling locator", e);
        }
    }
15874#public void skippedEntity(java.lang.String name) throws SAXException {
        this.writeEvent(SKIPPED_ENTITY);
        this.writeString(name);
    }
15875#/**
     * SAX Event Handling: LexicalHandler
     */
    public void startDTD(String name, String publicId, String systemId) throws SAXException {
        this.writeEvent(START_DTD);
        this.writeString(name);
        this.writeString(publicId!=null?publicId:"");
        this.writeString(systemId!=null?systemId:"");
    }
15876#/**
     * SAX Event Handling: LexicalHandler
     */
    public void endDTD() throws SAXException {
        this.writeEvent(END_DTD);
    }
15877#/**
     * SAX Event Handling: LexicalHandler
     */
    public void startEntity(String name) throws SAXException {
        this.writeEvent(START_ENTITY);
        this.writeString(name);
    }
15878#/**
     * SAX Event Handling: LexicalHandler
     */
    public void endEntity(String name) throws SAXException {
        this.writeEvent(END_ENTITY);
        this.writeString(name);
    }
15879#/**
     * SAX Event Handling: LexicalHandler
     */
    public void startCDATA() throws SAXException {
        this.writeEvent(START_CDATA);
    }
15880#/**
     * SAX Event Handling: LexicalHandler
     */
    public void endCDATA() throws SAXException {
        this.writeEvent(END_CDATA);
    }
15881#/**
     * SAX Event Handling: LexicalHandler
     */
    public void comment(char ary[], int start, int length) throws SAXException {
        try {
            this.writeEvent(COMMENT);
            this.writeChars(ary, start, length);
        } catch (Exception e) {
            throw new SAXException(e);
        }
    }
15882#public final void writeEvent( final int event) throws SAXException {
        this.write(event);
    }
15883#public final void writeAttributes( final int attributes) throws SAXException {
        if (attributes > 0xFFFF) throw new SAXException("Too many attributes");
        this.write((attributes >>> 8) & 0xFF);
        this.write((attributes >>> 0) & 0xFF);
    }
15884#public final void writeString( final String str) throws SAXException {
        Integer index = (Integer) map.get(str);
        if (index == null) {
            map.put(str, new Integer(mapCount++));
            int length = str.length();
            this.writeChars(str.toCharArray(), 0, length);
        } else {
            int i = index.intValue();

            if (i <= 0x7FFF) {
                // write index value in 16-bits
                this.write(((i >>> 8) & 0xFF) | 0x80);
                this.write((i >>> 0) & 0xFF);
            } else {
                // write escape code (Short.MAX_VALUE) to write a full 32-bit value
                write((byte)0x7F);
                write((byte)0xFF);
                // write index value in 32-bit
                write((byte) ((i >>> 24) & 0xFF) | 0x80);
                write((byte) ((i >>> 16) & 0xFF));
                write((byte) ((i >>>  8) & 0xFF));
                write((byte) ((i >>>  0) & 0xFF));
            }
        }
    }
15885#public final void writeChars( final char[] ch, final int start, final int length) throws SAXException {
        int utflen = 0;
        int c;

        for (int i = 0; i < length; i++) {
            c = ch[i + start];
            if ((c >= 0x0001) && (c <= 0x007F)) {
                utflen++;
            }
            else if (c > 0x07FF) {
                utflen += 3;
            }
            else {
                utflen += 2;
            }
        }

        if (utflen >= 0x00007FFF) {
            write((byte)0x7F);
            write((byte)0xFF);
            write((byte) ((utflen >>> 24) & 0xFF));
            write((byte) ((utflen >>> 16) & 0xFF));
            write((byte) ((utflen >>>  8) & 0xFF));
            write((byte) ((utflen >>>  0) & 0xFF));
        }
        else {
            write((byte) ((utflen >>> 8) & 0xFF));
            write((byte) ((utflen >>> 0) & 0xFF));
        }

        for (int i = 0; i < length; i++) {
            c = ch[i + start];
            if ((c >= 0x0001) && (c <= 0x007F)) {
                write((byte) c);
            }
            else if (c > 0x07FF) {
                write((byte) (0xE0 | ((c >> 12) & 0x0F)));
                write((byte) (0x80 | ((c >>  6) & 0x3F)));
                write((byte) (0x80 | ((c >>  0) & 0x3F)));
            }
            else {
                write((byte) (0xC0 | ((c >>  6) & 0x1F)));
                write((byte) (0x80 | ((c >>  0) & 0x3F)));
            }
        }
    }
15886#abstract protected void write( final int b ) throws SAXException;
15887#private void writeProlog() throws SAXException {
        write((byte)'C');
        write((byte)'X');
        write((byte)'M');
        write((byte)'L');
        write((byte)1);
        write((byte)0);
        hasProlog = true;
    }
15888#public void recycle() {
        this.input = null;
        super.recycle();
    }
15889#public void deserialize(Object saxFragment) throws SAXException {
        if (!(saxFragment instanceof byte[])) {
            throw new SAXException("XMLDeserializer needs byte array for deserialization.");
        }
        this.input = (byte[])saxFragment;
        this.currentPos = 0;
        super.parse();
    }
15890#protected int read() throws SAXException {
        if (currentPos >= input.length)
            return -1;
        return input[currentPos++] & 0xff;
    }
15891#protected int read(byte[] b) throws SAXException {
        final int bytesRead = (this.currentPos + b.length > this.input.length ? this.input.length - this.currentPos : b.length);
        System.arraycopy(this.input, this.currentPos, b, 0, bytesRead);
        this.currentPos += bytesRead;
        return bytesRead;
    }
15892#/**
     * Creates a new <code>XMLByteStreamFragment</code> defined by the given
     * XML byte stream.
     *
     * @param bytes the XML byte stream representing the document fragment
     */
    public XMLByteStreamFragment(Object bytes) {
        this.xmlBytes = bytes;
    }
15893#/**
     * Output the fragment. If the fragment is a document, start/endDocument
     * events are discarded.
     */
    public void toSAX(ContentHandler ch) throws SAXException {
        // Stream bytes and discard start/endDocument
        XMLByteStreamInterpreter deserializer = new XMLByteStreamInterpreter();
        deserializer.setContentHandler(new EmbeddedXMLPipe(ch));
        deserializer.deserialize(this.xmlBytes);
    }
15894#public XMLOutputStreamCompiler(final OutputStream out)
        throws IOException {
        super();
        this.recycle(out);
    }
15895#public void recycle(final OutputStream out) {
        this.os = out;
        super.recycle();
    }
15896#public void recycle() {
        this.recycle(this.os);
    }
15897#protected void write(final int b)
        throws SAXException {
        try {
            this.os.write((byte)b);
        } catch(final IOException e) {
            throw new SAXException(e);
        }
    }
15898#public XMLByteStreamCompiler() {
        super();
        this.bufCountAverage = 2000;
        this.initOutput();
    }
15899#private void initOutput() {
        this.buf = new byte[bufCountAverage];
        this.bufCount = 0;
    }
15900#public void recycle() {
        bufCountAverage = (bufCountAverage + bufCount) / 2;
        initOutput();
        super.recycle();
    }
15901#public Object getSAXFragment() {
        if (this.bufCount == 0) { // no event arrived yet
            return null;
        }
        byte newbuf[] = new byte[this.bufCount];
        System.arraycopy(this.buf, 0, newbuf, 0, this.bufCount);
        return newbuf;
    }
15902#protected void write( final int b ) {
        int newcount = this.bufCount + 1;
        assure(newcount);
        this.buf[this.bufCount] = (byte)b;
        this.bufCount = newcount;
    }
15903#private void assure( final int size ) {
        if (size > this.buf.length) {
            byte newbuf[] = new byte[Math.max(this.buf.length << 1, size)];
            System.arraycopy(this.buf, 0, newbuf, 0, this.bufCount);
            this.buf = newbuf;
        }
    }
15904#public void deserialize(final InputStream inputStream)
        throws SAXException {
        this.is = inputStream;
        super.parse();
    }
15905#public void recycle() {
        this.is = null;
        super.recycle();
    }
15906#protected int read()
        throws SAXException {
        try {
            return is.read();
        } catch(final IOException e) {
            throw new SAXException(e);
        }
    }
15907#protected int read(final byte[] b)
        throws SAXException {
        try {
            return is.read(b);
        } catch(final IOException e) {
            throw new SAXException(e);
        }
    }
15908#public DocumentLocatorException(String message)
    {
        super(message, null);
    }
15909#public DocumentLocatorException(String message, Throwable cause)
    {
        super(message, cause);
    }
15910#/**
     * Create a new rewriter
     */
    public URLRewriter(Parameters configuration,
                       ContentHandler contentHandler,
                       LexicalHandler lexicalHandler)
    throws ProcessingException {
        try {
            this.contentHandler = contentHandler;
            this.lexicalHandler = lexicalHandler;
            this.mode = 0;
            if (configuration != null &&
                    MODE_COCOON.equalsIgnoreCase(configuration.getParameter(PARAMETER_MODE, null))) {
                this.mode = 1;
                this.baseUrl = configuration.getParameter(PARAMETER_URL);
                this.cocoonUrl = configuration.getParameter(PARAMETER_COCOON_URL) +
                        '?' + configuration.getParameter(PARAMETER_PARAMETER_NAME) + '=';
            }
        } catch (org.apache.avalon.framework.parameters.ParameterException local) {
            throw new ProcessingException("URLRewriter: configuration exception.", local);
        }
    }
15911#/**
     * Create a new rewriter
     */
    public URLRewriter(Parameters configuration,
                       ContentHandler contentHandler)
    throws ProcessingException {
        this(configuration, contentHandler,
             (contentHandler instanceof LexicalHandler ? (LexicalHandler)contentHandler : null));
    }
15912#/**
     * SAX Event Handling
     */
    public void setDocumentLocator(Locator locator) {
        contentHandler.setDocumentLocator(locator);
    }
15913#/**
     * SAX Event Handling
     */
    public void startDocument()
    throws SAXException {
        contentHandler.startDocument();
    }
15914#/**
     * SAX Event Handling
     */
    public void endDocument()
    throws SAXException {
        contentHandler.endDocument();
    }
15915#/**
     * SAX Event Handling
     */
    public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
        contentHandler.startPrefixMapping(prefix,uri);
    }
15916#/**
     * SAX Event Handling
     */
    public void endPrefixMapping(String prefix)
    throws SAXException {
        contentHandler.endPrefixMapping(prefix);
    }
15917#/**
     * SAX Event Handling
     */
    public void startElement(String namespace, String name, String raw,
                             Attributes attr)
    throws SAXException {
        if (this.mode == 1) {
            String attrname;
            AttributesImpl newattr = null;
            String value;

            for(int i = 0; i < attr.getLength(); i++) {
                attrname = attr.getLocalName(i);
                if (attrname.equals("href") == true ||
                        attrname.equals("action") == true) {
                    if (newattr == null) {
                        newattr = new AttributesImpl(attr);
                    }
                    value = attr.getValue(i);
                    if (value.indexOf(':') == -1) {
                        try {
                            URL baseURL = new URL(new URL(this.baseUrl), value);
                            value = baseURL.toExternalForm();
                        } catch (MalformedURLException local) {
                            value = attr.getValue(i);
                        }
                    }
                    newattr.setValue(i, this.cocoonUrl + value);
                } else if (attrname.equals("src") == true ||
                        attrname.equals("background") == true) {
                    if (newattr == null) {
                        newattr = new AttributesImpl(attr);
                    }
                    value = attr.getValue(i);
                    if (value.indexOf(':') == -1) {
                        try {
                            URL baseURL = new URL(new URL(this.baseUrl), value);
                            value = baseURL.toExternalForm();
                        } catch (MalformedURLException local) {
                            value = attr.getValue(i);
                        }
                    }
                    newattr.setValue(i, value);
                }
            }
            if (newattr != null) {
                contentHandler.startElement(namespace, name, raw, newattr);
                return;
            }
        }
        contentHandler.startElement(namespace, name, raw, attr);
    }
15918#/**
     * SAX Event Handling
     */
    public void endElement(String namespace, String name, String raw)
    throws SAXException {
        contentHandler.endElement(namespace, name, raw);
    }
15919#/**
     * SAX Event Handling
     */
    public void characters(char ary[], int start, int length)
    throws SAXException {
        contentHandler.characters(ary, start, length);
    }
15920#/**
     * SAX Event Handling
     */
    public void ignorableWhitespace(char ary[], int start, int length)
    throws SAXException {
        contentHandler.ignorableWhitespace(ary, start, length);
    }
15921#/**
     * SAX Event Handling
     */
    public void processingInstruction(String target, String data)
    throws SAXException {
        contentHandler.processingInstruction(target, data);
    }
15922#/**
     * SAX Event Handling
     */
    public void skippedEntity(String name)
    throws SAXException {
        contentHandler.skippedEntity(name);
    }
15923#/**
     * SAX Event Handling
     */
    public void startDTD(String name, String public_id, String system_id)
            throws SAXException {
        if (lexicalHandler != null) lexicalHandler.startDTD(name, public_id, system_id);
    }
15924#/**
     * SAX Event Handling
     */
    public void endDTD() throws SAXException {
        if (lexicalHandler != null) lexicalHandler.endDTD();
    }
15925#/**
     * SAX Event Handling
     */
    public void startEntity(String name) throws SAXException {
        if (lexicalHandler != null) lexicalHandler.startEntity(name);
    }
15926#/**
     * SAX Event Handling
     */
    public void endEntity(String name) throws SAXException {
        if (lexicalHandler != null) lexicalHandler.endEntity(name);
    }
15927#/**
     * SAX Event Handling
     */
    public void startCDATA() throws SAXException {
        if (lexicalHandler != null) lexicalHandler.startCDATA();
    }
15928#/**
     * SAX Event Handling
     */
    public void endCDATA() throws SAXException {
        if (lexicalHandler != null) lexicalHandler.endCDATA();
    }
15929#/**
     * SAX Event Handling
     */
    public void comment(char ary[], int start, int length)
    throws SAXException {
        if (this.lexicalHandler != null) {
            lexicalHandler.comment(ary, start, length);
        }
    }
15930#/**
     * <p>Create a new {@link MultiSourceValidity} instance.</p>
     *
     * <p>If the number of milliseconds is less than <b>zero</b>, or it's sum with
     * the number of <b>now</b> milliseconds is greater than the biggest long
     * representable, the expiration date will be set to {@link Long#MAX_VALUE}
     * milliseconds from the epoch.</p>
     *
     * @param resolver the {@link SourceResolver} used to access the sources.
     * @param delay the number of milliseconds from <b>now</b> defining for how long
     *              this instance will be valid.
     */
    public MultiSourceValidity(SourceResolver resolver, long delay) {
        /* Calculate the initial expiration time and calculate the delay */
        this.resolver = resolver;
        this.expiry = System.currentTimeMillis() + delay;
        this.delay = delay;
    }
15931#/**
     * <p>Add a {@link Source} to the list of {@link Source}s monitored by this
     * instance.</p>
     *
     * @param src a <b>non-null</b> {@link Source}.
     */
    public void addSource(Source src) {
        if (this.uris != null) {
            SourceValidity validity = src.getValidity();
            if (validity == null) {
                /* The source has no validity: this will be always be invalid. */
                this.uris = null;
            } else {
                /* Add the validity and URI to the list */
                super.add(validity);
                this.uris.add(src.getURI());
            }
        }
    }
15932#/**
     * <p>Close this instance, or in other words declare that no other sources will
     * be added to this {@link MultiSourceValidity} and that checkings can be now
     * performed.</p>
     */
    public void close() {
        this.isClosed = true;
        this.resolver = null;
    }
15933#/**
     * <p>Check the validity of this {@link SourceValidity} instance.</p>
     *
     * @see SourceValidity#isValid()
     */
    public int isValid() {
        if (System.currentTimeMillis() <= expiry) {
            /* Validity not expired, so, don't even check */
            return SourceValidity.VALID;
        }

        /* Re-calculate the expiry time based on the current time */
        expiry = System.currentTimeMillis() + delay;

        if (uris == null || !isClosed) {
            /* We have not been closed (yet) or we were forced to be invalid */
            return SourceValidity.INVALID;
        } else {
            /* Compute the status of all the sources listed in this instance */
            return computeStatus(null);
        }
    }
15934#/**
     * <p>Check the validity of this instance comparing it with a (recently acquired)
     * new {@link SourceValidity} object.</p>
     *
     * @see SourceValidity#isValid(SourceValidity)
     */
    public int isValid(SourceValidity newValidity) {
        if (uris == null || !isClosed) {
            /* We have not been closed (yet) or we were forced to be invalid */
            return SourceValidity.INVALID;
        }

        /* Perform a simple class check and compute the validity of the sources */
        if (newValidity instanceof MultiSourceValidity) {
            return computeStatus(((MultiSourceValidity)newValidity).resolver);
        } else {
            /* The supplied validity is not an instance of ourselves, forget it */
            return SourceValidity.INVALID;
        }
    }
15935#/**
     * <p>Compute the status of this instance by checking every source.</p>
     *
     * @param resolver The {@link SourceResolver} to use to access sources.
     * @return {@link SourceValidity.VALID}, {@link SourceValidity.INVALID} or
     *         {@link SourceValidity.UNKNOWN} depending on the status.
     */
    private int computeStatus(SourceResolver resolver) {
        /* Get the validities and analyse them one by one */
        List validities = super.getValidities();
        for (int i = 0; i < validities.size(); i++) {

            /* Check the validity status */
            SourceValidity validity = (SourceValidity) validities.get(i);
            switch (validity.isValid()) {

                /* The current source is valid: just continue to next source */
                case SourceValidity.VALID:
                    break;

                /* The current source is invalid: stop examining */
                case SourceValidity.INVALID:
                    return SourceValidity.INVALID;

                /* The source validity is not known: check with the new source */
                case SourceValidity.UNKNOWN:
                    /* We have no resolver: definitely don't know */
                    if (resolver == null) {
                        return SourceValidity.UNKNOWN;
                    }

                    /* Check the new source by asking to the resolver */
                    Source newSrc = null;
                    int newValidity = SourceValidity.INVALID;
                    try {
                        newSrc = resolver.resolveURI((String) this.uris.get(i));
                        newValidity = validity.isValid(newSrc.getValidity());
                    } catch(IOException ioe) {
                        /* Swallow the IOException, but set the new validity */
                        newValidity = SourceValidity.INVALID;
                    } finally {
                        /* Make sure that the source is released */
                        if (newSrc != null) {
                            resolver.release(newSrc);
                        }
                    }

                    /* If the source is still valid, go to the next one */
                    if (newValidity == SourceValidity.VALID) {
                        break;
                    }

                    /* The source is not valid (or unknown), we invalidate the lot */
                    return SourceValidity.INVALID;

                /* We got something _really_ odd out tof the validity, dunno. */
                default:
                    return SourceValidity.INVALID;
            }
        }

        /* All items checked successfully */
        return SourceValidity.VALID;
    }
15936#/**
     * Generates SAX events from the given source with possible URL rewriting.
     *
     * <p><b>NOTE</b>: If the implementation can produce lexical events,
     * care should be taken that <code>handler</code> can actually
     * directly implement the LexicalHandler interface!</p>
     *
     * @param  source    the data
     * @throws ProcessingException if no suitable converter is found
     */
    static public void toSAX(ServiceManager manager,
                             Source source,
                             ContentHandler handler,
                             Parameters typeParameters,
                             boolean filterDocumentEvent)
    throws SAXException, IOException, ProcessingException {
        // Test for url rewriting
        if (typeParameters != null
                && typeParameters.getParameter(URLRewriter.PARAMETER_MODE, null) != null) {
            handler = new URLRewriter(typeParameters, handler);
        }

        String mimeTypeHint = null;
        if (typeParameters != null) {
            mimeTypeHint = typeParameters.getParameter("mime-type", mimeTypeHint);
        }
        if (filterDocumentEvent) {
            IncludeXMLConsumer filter = new IncludeXMLConsumer(handler);
            toSAX(manager, source, mimeTypeHint, filter);
        } else {
            toSAX(manager, source, mimeTypeHint, handler);
        }
    }
15937#/**
	 * Generates SAX events from the XMLizable and handle SAXException.
	 *
	 * @param  source    the data
	 */
	public static void toSAX(XMLizable      source, ContentHandler handler) throws SAXException, IOException, ProcessingException {
	    try {
	        source.toSAX(handler);
	    } catch (SAXException e) {
	        // Unwrap ProcessingException, IOException, and extreme cases of SAXExceptions.
	        // Handle SourceException.
	        // See also handleSAXException
	        final Exception cause = e.getException();
	        if (cause != null) {
	            if (cause instanceof SourceException) {
	                throw handle((SourceException) cause);
	            }
	            if (cause instanceof ProcessingException) {
	                throw (ProcessingException) cause;
	            }
	            if (cause instanceof IOException) {
	                throw (IOException) cause;
	            }
	            if (cause instanceof SAXException) {
	                throw (SAXException) cause;
	            }
	        }
	
	        // Throw original SAX exception
	        throw e;
	    }
	}
15938#/**
     * Generates SAX events from the given source.
     *
     * <p><b>NOTE</b>: If the implementation can produce lexical events,
     * care should be taken that <code>handler</code> can actually
     * directly implement the LexicalHandler interface!</p>
     *
     * @param  source    the data
     * @throws ProcessingException if no suitable converter is found
     */
    static public void toSAX(ServiceManager manager,
    		                 Source         source,
                             ContentHandler handler)
    throws SAXException, IOException, ProcessingException {
        toSAX(manager, source, null, handler);
    }
15939#/**
     * Generates SAX events from the given source by using XMLizer.
     *
     * <p><b>NOTE</b>: If the implementation can produce lexical events,
     * care should be taken that <code>handler</code> can actually
     * directly implement the LexicalHandler interface!</p>
     *
     * @param  source    the data
     * @throws ProcessingException if no suitable converter is found
     */
    public static void toSAX(ServiceManager manager,
                             Source         source,
                             String         mimeTypeHint,
                             ContentHandler handler)
    throws SAXException, IOException, ProcessingException {
        if (source instanceof XMLizable) {
            toSAX((XMLizable) source, handler);
        } else {
            String mimeType = source.getMimeType();
            if (null == mimeType) {
                mimeType = mimeTypeHint;
            }
    
            XMLizer xmlizer = null;
            try {
                xmlizer = (XMLizer) manager.lookup(XMLizer.ROLE);
                xmlizer.toSAX(source.getInputStream(),
                              mimeType,
                              source.getURI(),
                              handler);
            } catch (SourceException e) {
                throw SourceUtil.handle(e);
            } catch (ServiceException e) {
                throw new ProcessingException("Exception during streaming source.", e);
            } finally {
                manager.release(xmlizer);
            }
        }
    }
15940#/**
     * Generates SAX events from the given source by using XMLizer.
     *
     * <p><b>NOTE</b>: If the implementation can produce lexical events,
     * care should be taken that <code>handler</code> can actually
     * directly implement the LexicalHandler interface!</p>
     *
     * @param  source    the data
     * @throws ProcessingException if no suitable converter is found
     */
    public static void toSAX(XMLizer        xmlizer,
                             Source         source,
                             String         mimeTypeHint,
                             ContentHandler handler)
    throws SAXException, IOException, ProcessingException {
        if (source instanceof XMLizable) {
            toSAX((XMLizable) source, handler);
        } else {
            String mimeType = source.getMimeType();
            if (null == mimeType) {
                mimeType = mimeTypeHint;
            }
            try {
                xmlizer.toSAX(source.getInputStream(),
                              mimeType,
                              source.getURI(),
                              handler);
            } catch (SourceException e) {
                throw SourceUtil.handle(e);
            }
        }
    }
15941#/**
	 * Generates character SAX events from the given source.
	 *
	 * @param source The data
	 * @param encoding The character encoding of the data
	 */
	public static void toCharacters(Source source, String encoding, ContentHandler handler) throws SAXException, IOException, ProcessingException {
	    try {
	        Reader r = encoding == null?
	                new InputStreamReader(source.getInputStream()):
	                new InputStreamReader(source.getInputStream(), encoding);
	
	        int len;
	        char[] chr = new char[4096];
	        try {
	            while ((len = r.read(chr)) > 0) {
	                handler.characters(chr, 0, len);
	            }
	        } finally {
	            r.close();
	        }
	    } catch (SAXException e) {
	        handleSAXException(source.getURI(), e);
	    }
	}
15942#/**
	 * Generates SAX events from the given source by parsing it.
	 *
	 * <p><b>NOTE</b>: If the implementation can produce lexical events,
	 * care should be taken that <code>handler</code> can actually
	 * directly implement the LexicalHandler interface!</p>
	 *
	 * @param  source    the data
	 * @throws ProcessingException if no suitable converter is found
	 * @deprecated use {@link #parse(SAXParser, Source, ContentHandler)} instead
	 */
	public static void parse(ServiceManager manager, Source source, ContentHandler handler) throws SAXException, IOException, ProcessingException {
	    if (source instanceof XMLizable) {
	        toSAX((XMLizable) source, handler);
	    } else {
	        org.apache.excalibur.xml.sax.SAXParser parser = null;
	        try {
	            parser = (org.apache.excalibur.xml.sax.SAXParser) manager.lookup(org.apache.excalibur.xml.sax.SAXParser.ROLE);
	            parser.parse(getInputSource(source), handler);
	        } catch (SourceException e) {
	        	throw SourceUtil.handle(e);
	        } catch (ServiceException e) {
	            throw new ProcessingException("Exception during parsing source.", e);
	        } finally {
	            manager.release(parser);
	        }
	    }
	}
15943#/**
	 * Generates SAX events from the given source by parsing it.
	 *
	 * <p><b>NOTE</b>: If the implementation can produce lexical events,
	 * care should be taken that <code>handler</code> can actually
	 * directly implement the LexicalHandler interface!</p>
	 *
	 * @param  source    the data
	 * @throws ProcessingException if error during processing source data occurs
	 */
	public static void parse(SAXParser parser, Source source, ContentHandler handler) throws SAXException, IOException, ProcessingException {
	    if (source instanceof XMLizable) {
	        toSAX((XMLizable) source, handler);
	    } else {
	        try {
	            parser.parse(getInputSource(source), handler);
	        } catch (SourceException e) {
	            throw SourceUtil.handle(e);
	        }
	    }
	}
15944#/**
	 * Generates a DOM from the given source
	 * @param source The data
	 *
	 * @return Created DOM document.
	 *
	 * @throws IOException If a io exception occurs.
	 * @throws ProcessingException if no suitable converter is found
	 * @throws SAXException If a SAX exception occurs.
	 */
	public static Document toDOM(ServiceManager manager, Source source) throws SAXException, IOException, ProcessingException {
	    DOMBuilder builder = new DOMBuilder();
	
	    toSAX(manager, source, null, builder);
	
	    Document document = builder.getDocument();
	    if (document == null) {
	        throw new ProcessingException("Could not build DOM for '" +
	                                      source.getURI() + "'");
	    }
	
	    return document;
	}
15945#/**
	 * Generates a DOM from the given source
	 * @param source The data
	 *
	 * @return Created DOM document.
	 *
	 * @throws IOException If a io exception occurs.
	 * @throws ProcessingException if no suitable converter is found
	 * @throws SAXException If a SAX exception occurs.
	 */
	public static Document toDOM(ServiceManager manager, String mimeTypeHint, Source source) throws SAXException, IOException, ProcessingException {
	    DOMBuilder builder = new DOMBuilder();
	
	    toSAX(manager, source, mimeTypeHint, builder);
	
	    Document document = builder.getDocument();
	    if (document == null) {
	        throw new ProcessingException("Could not build DOM for '" +
	                                      source.getURI() + "'");
	    }
	
	    return document;
	}
15946#/**
	 * Make a ProcessingException from a SourceException.
	 * If the exception is a SourceNotFoundException then a
	 * ResourceNotFoundException is thrown.
	 *
	 * @param se Source exception
	 * @return Created processing exception.
	 */
	public static ProcessingException handle(SourceException se) {
	    if (se instanceof SourceNotFoundException) {
	        return new ResourceNotFoundException("Resource not found.", se);
	    }
	    return new ProcessingException("Exception during source resolving.",
	                                   se);
	}
15947#/**
	 * Make a ProcessingException from a SourceException.
	 * If the exception is a SourceNotFoundException then a
	 * ResourceNotFoundException is thrown.
	 *
	 * @param message Additional exception message.
	 * @param se Source exception.
	 * @return Created processing exception.
	 */
	public static ProcessingException handle(String message, SourceException se) {
	    if (se instanceof SourceNotFoundException) {
	        return new ResourceNotFoundException(message, se);
	    }
	    return new ProcessingException(message, se);
	}
15948#/**
	 * Handle SAXException catched in Generator's generate method.
	 *
	 * @param source Generator's source
	 * @param e SAXException happened in the generator's generate method.
	 */
	public static void handleSAXException(String source, SAXException e) throws ProcessingException, IOException, SAXException {
	    final Exception cause = e.getException();
	    if (cause != null) {
	        // Unwrap ProcessingException, IOException, and extreme cases of SAXExceptions.
	        // Handle SourceException.
	        // See also toSax(XMLizable, ContentHandler)
	        if (cause instanceof SourceException) {
	            throw handle((SourceException) cause);
	        }
	        if (cause instanceof ProcessingException) {
	            throw (ProcessingException) cause;
	        }
	        if (cause instanceof IOException) {
	            throw (IOException) cause;
	        }
	        if (cause instanceof SAXException) {
	            throw (SAXException) cause;
	        }
	        throw new ProcessingException("Could not read resource " +
	                                      source, cause);
	    }
	    throw e;
	}
15949#/**
	 * Get an InputSource object
	 *
	 * @param source Source.
	 *
	 * @return Input stream of the source.
	 *
	 * @throws IOException If a io exception occurs.
	 * @throws ProcessingException If an exception occurs during
	 *                             processing.
	 */
	public static InputSource getInputSource(Source source) throws IOException, ProcessingException {
	    try {
	        final InputSource newObject = new InputSource(source.getInputStream());
	
	        newObject.setSystemId(source.getURI());
	        return newObject;
	    } catch (SourceException se) {
	        throw handle(se);
	    }
	}
15950#/**
	 * Get a <code>Source</code> object
	 *
	 * @param uri URI of the source.
	 * @param typeParameters Type of Source query.  Currently, only
	 * <code>method</code> parameter (value typically <code>GET</code> or
	 * <code>POST</code>) is recognized.  May be <code>null</code>.
	 * @param resourceParameters Parameters of the source.  May be <code>null</code>
	 * @param resolver Resolver for the source.
	 *
	 * @return The resolved source.
	 *
	 * @throws IOException If a io exception occurs.
	 * @throws SAXException If a SAX exception occurs.
	 * @throws SourceException If the source an exception throws.
	 */
	public static Source getSource(String uri, Parameters typeParameters, SourceParameters resourceParameters, SourceResolver resolver) throws IOException, SAXException, SourceException {
	
	    // first step: encode parameters which are already appended to the url
	    int queryPos = uri.indexOf('?');
	    if (queryPos != -1) {
	        String queryString = uri.substring(queryPos+1);
	        SourceParameters queries = new SourceParameters(queryString);
	
	        if (queries.hasParameters()) {
	            StringBuffer buffer = new StringBuffer(uri.substring(0, queryPos));
	            char separator = '?';
	
	            Iterator i = queries.getParameterNames();
	            while (i.hasNext()) {
	                String current = (String) i.next();
	                Iterator values = queries.getParameterValues(current);
	                while (values.hasNext()) {
	                    buffer.append(separator)
	                            .append(current)
	                            .append('=')
	                            .append(NetUtils.encode((String) values.next(), "utf-8"));
	                    separator = '&';
	                }
	            }
	            uri = buffer.toString();
	        }
	    }
	
	    String method = ((typeParameters!=null)
	                     ? typeParameters.getParameter("method", "GET")
	                     : "GET");
	    if (method.equalsIgnoreCase("POST") &&
	            (resourceParameters == null ||
	            !resourceParameters.hasParameters())) {
	        method = "GET";
	    }
	
	    if (uri.startsWith("cocoon:") && resourceParameters != null &&
	            resourceParameters.hasParameters()) {
	        int pos = uri.indexOf(";jsessionid=");
	
	        StringBuffer buf;
	        if (pos == -1) {
	            buf = new StringBuffer(uri);
	        } else {
	            buf = new StringBuffer(uri.substring(0, pos));
	        }
	        buf.append(((uri.indexOf('?') == -1) ? '?' : '&'));
	        buf.append(resourceParameters.getEncodedQueryString());
	        uri = buf.toString();
	    }
	
	    Map resolverParameters = new HashMap();
	    resolverParameters.put(SourceResolver.METHOD, method);
	    if (typeParameters != null) {
	        String encoding = typeParameters.getParameter("encoding",
	             System.getProperty("file.encoding", "ISO-8859-1"));
	        if (encoding != null && !"".equals(encoding)) {
	            resolverParameters.put(SourceResolver.URI_ENCODING, encoding);
	        }
	    }
	    resolverParameters.put(SourceResolver.URI_PARAMETERS,
	                           resourceParameters);
	
	    return resolver.resolveURI(uri, null, resolverParameters);
	}
15951#/**
	 * Return the scheme of a URI. Just as there are many different methods
	 * of access to resources, there are a variety of schemes for identifying
	 * such resources.
	 * (see <a href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>).
	 *
	 * @param uri Uniform resource identifier.
	 *
	 * @return Scheme of the URI.
	 */
	public static String getScheme(String uri) {
	    RE re = new RE(uripattern);
	    if (re.match(uri)) {
	        return re.getParen(2);
	    } else {
	        throw new IllegalArgumentException("'" + uri +
	                                           "' is not a correct URI");
	    }
	}
15952#/**
	 * Return the authority of a URI. This authority is
	 * typically defined by an Internet-based server or a scheme-specific
	 * registry of naming authorities
	 * (see <a href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>).
	 *
	 * @param uri Uniform resource identifier.
	 *
	 * @return Scheme of the URI.
	 */
	public static String getAuthority(String uri) {
	    RE re = new RE(uripattern);
	    if (re.match(uri)) {
	        return re.getParen(4);
	    } else {
	        throw new IllegalArgumentException("'" + uri +
	                                           "' is not a correct URI");
	    }
	}
15953#/**
	 * Return the path of a URI. The path contains data, specific to the
	 * authority (or the scheme if there is no authority component),
	 * identifying the resource within the scope of that scheme and authority
	 * (see <a href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>).
	 *
	 * @param uri Uniform resource identifier.
	 *
	 * @return Path of the URI.
	 */
	public static String getPath(String uri) {
	    RE re = new RE(uripattern);
	    if (re.match(uri)) {
	        return re.getParen(5);
	    } else {
	        throw new IllegalArgumentException("'" + uri +
	                                           "' is not a correct URI");
	    }
	}
15954#/**
	 * Return the path of a URI, if the URI can't contains a authority.
	 * This implementation differ to the RFC 2396.
	 *
	 * @param uri Uniform resource identifier.
	 *
	 * @return Path of the URI.
	 */
	public static String getPathWithoutAuthority(String uri) {
	    RE re = new RE(uripattern);
	    if (re.match(uri)) {
	        return re.getParen(4) + re.getParen(5);
	    } else {
	        throw new IllegalArgumentException("'" + uri +
	                                           "' is not a correct URI");
	    }
	}
15955#/**
	 * Return the query of a URI. The query is a string of information to
	 * be interpreted by the resource
	 * (see <a href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>).
	 *
	 * @param uri Uniform resource identifier.
	 *
	 * @return Query of the URI.
	 */
	public static String getQuery(String uri) {
	    RE re = new RE(uripattern);
	    if (re.match(uri)) {
	        return re.getParen(7);
	    } else {
	        throw new IllegalArgumentException("'" + uri +
	                                           "' is not a correct URI");
	    }
	}
15956#/**
	 * Return the fragment of a URI. When a URI reference is used to perform
	 * a retrieval action on the identified resource, the optional fragment
	 * identifier, consists of additional reference information to be
	 * interpreted by the user agent after the retrieval action has been
	 * successfully completed
	 * (see <a href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>).
	 *
	 * @param uri Uniform resource identifier.
	 *
	 * @return Fragment of the URI.
	 */
	public static String getFragment(String uri) {
	    RE re = new RE(uripattern);
	    if (re.match(uri)) {
	        return re.getParen(9);
	    } else {
	        throw new IllegalArgumentException("'" + uri +
	                                           "' is not a correct URI");
	    }
	}
15957#public void init() {
        if (this.mimeType != null)
            this.info.setMimeType(this.componentName, this.mimeType);
        if (this.label != null) {
            StringTokenizer st = new StringTokenizer(this.label, " ,", false);
            String[] labels = new String[st.countTokens()];
            for (int tokenIdx = 0; tokenIdx < labels.length; tokenIdx++) {
                labels[tokenIdx] = st.nextToken();
            }
            this.info.setLabels(this.componentName, labels);
        }
        if (this.hint != null)
            this.info.setPipelineHint(this.componentName, this.hint);
        if (this.data != null)
            this.info.addData(data);
    }
15958#/**
     * @param info
     */
    public void setInfo(PipelineComponentInfo info) {
        this.info = info;
    }
15959#/**
     * @param componentName
     */
    public void setComponentName(String componentName) {
        this.componentName = componentName;
    }
15960#/**
     * @param hint
     */
    public void setHint(String hint) {
        this.hint = hint;
    }
15961#/**
     * @param label
     */
    public void setLabel(String label) {
        this.label = label;
    }
15962#/**
     * @param mimeType
     */
    public void setMimeType(String mimeType) {
        this.mimeType = mimeType;
    }
15963#/**
     * @param data the data to set
     */
    public void setData(Map data) {
        this.data = data;
    }
15964#/**
     * @see org.springframework.beans.factory.xml.NamespaceHandler#init()
     */
    public void init() {
        registerBeanDefinitionDecorator("component", new PipelineComponentInfoInitializerDecorator());
    }
15965#/**
     * @see org.springframework.beans.factory.BeanFactoryAware#setBeanFactory(org.springframework.beans.factory.BeanFactory)
     */
    public void setBeanFactory(BeanFactory factory) throws BeansException {
        this.beanFactory = factory;
    }
15966#protected void init()
    throws Exception {
        PipelineComponentInfo parent = null;
        if ( this.beanFactory instanceof HierarchicalBeanFactory ) {
            BeanFactory parentFactory = ((HierarchicalBeanFactory)this.beanFactory).getParentBeanFactory();
            if ( parentFactory != null && parentFactory.containsBean(PipelineComponentInfo.ROLE) ) {
                parent = (PipelineComponentInfo)parentFactory.getBean(PipelineComponentInfo.ROLE);
            }
        }
        this.info = new PipelineComponentInfo(parent);
        if ( this.data != null ) {
            info.setData(data);
        }
    }
15967#/**
     * @see org.springframework.beans.factory.FactoryBean#getObject()
     */
    public Object getObject() throws Exception {
        return this.info;
    }
15968#/**
     * @see org.springframework.beans.factory.FactoryBean#getObjectType()
     */
    public Class getObjectType() {
        return PipelineComponentInfo.class;
    }
15969#/**
     * @see org.springframework.beans.factory.FactoryBean#isSingleton()
     */
    public boolean isSingleton() {
        return true;
    }
15970#public Map getData() {
        return data;
    }
15971#public void setData(Map data) {
        this.data = data;
    }
15972#/* (non-Javadoc)
     * @see org.springframework.beans.factory.xml.BeanDefinitionDecorator#decorate(org.w3c.dom.Node, org.springframework.beans.factory.config.BeanDefinitionHolder, org.springframework.beans.factory.xml.ParserContext)
     */
    public BeanDefinitionHolder decorate(Node source, BeanDefinitionHolder holder, ParserContext ctx) {
        registerPipelineComponentInfo(ctx);
        String initializerBeanName = registerPipelineComponentInfoInitializer(source, holder, ctx);
        createDependencyOnPipelineComponentInfoInitializer(holder, initializerBeanName);
        return holder;
    }
15973#private void registerPipelineComponentInfo(ParserContext ctx) {
        if (!ctx.getRegistry().containsBeanDefinition(PipelineComponentInfo.ROLE)) {
            BeanDefinitionBuilder defBuilder = BeanDefinitionBuilder.rootBeanDefinition(PipelineComponentInfoFactoryBean.class);
            defBuilder.setSingleton(true);
            defBuilder.setLazyInit(false);
            defBuilder.setInitMethodName("init");
            ctx.getRegistry().registerBeanDefinition(PipelineComponentInfo.ROLE, defBuilder.getBeanDefinition());
        }
    }
15974#private String registerPipelineComponentInfoInitializer(Node source, BeanDefinitionHolder holder, ParserContext ctx) {
        String componentName = holder.getBeanName();
        String mimeType = ((Element)source).hasAttribute("mime-type") ? ((Element)source).getAttribute("mime-type") : null;
        String label = ((Element)source).hasAttribute("label") ? ((Element)source).getAttribute("label") : null;
        String hint = ((Element)source).hasAttribute("hint") ? ((Element)source).getAttribute("hint") : null;

        BeanDefinitionBuilder initializer = BeanDefinitionBuilder.rootBeanDefinition(PipelineComponentInfoInitializer.class);
        initializer.addPropertyReference("info", PipelineComponentInfo.ROLE);
        initializer.addPropertyValue("componentName", componentName);
        if (mimeType != null)
            initializer.addPropertyValue("mimeType", mimeType);
        if (label != null)
            initializer.addPropertyValue("label", label);
        if (hint != null)
            initializer.addPropertyValue("hint", hint);
        initializer.setInitMethodName("init");

        String beanName = componentName + "/info";
        ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition());

        return beanName;
    }
15975#private void createDependencyOnPipelineComponentInfoInitializer(BeanDefinitionHolder holder, String initializerBeanName) {
        AbstractBeanDefinition definition = ((AbstractBeanDefinition) holder.getBeanDefinition());
        String[] dependsOn = definition.getDependsOn();
        if (dependsOn == null) {
           dependsOn = new String[]{initializerBeanName};
        } else {
           List dependencies = new ArrayList(Arrays.asList(dependsOn));
           dependencies.add(initializerBeanName);
           dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY);
        }
        definition.setDependsOn(dependsOn);
    }
15976#/**
     * Constructs the abstract environment
     */
    public AbstractEnvironment(String uri, String view) {
        this(uri, view, null);
    }
15977#/**
     * Constructs the abstract environment
     */
    public AbstractEnvironment(String uri, String view, String action) {
        this.uri = uri;
        this.view = view;
        this.action = action;
    }
15978#/**
     * Allow implementations to set view later than in super() constructor.
     * View can be set only once, and should be set in implementation's constructor.
     */
    protected void setView(String view) {
        if (this.view != null) {
            throw new IllegalStateException("View was already set on this environment");
        }
        this.view = view;
    }
15979#/**
     * Allow implementations to set action later than in super() constructor
     * Action can be set only once, and should be set in implementation's constructor.
     */
    protected void setAction(String action) {
        if (this.action != null) {
            throw new IllegalStateException("Action was already set on this environment");
        }
        this.action = action;
    }
15980#/**
     * Helper method to extract the view name from the request.
     */
    protected static String extractView(Request request) {
        return request.getParameter(Constants.VIEW_PARAM);
    }
15981#/**
     * Helper method to extract the action name from the request.
     */
    protected static String extractAction(Request req) {
        String action = req.getParameter(Constants.ACTION_PARAM);
        if (action != null) {
            /* TC: still support the deprecated syntax */
            return action;
        }
        for(Enumeration e = req.getParameterNames(); e.hasMoreElements(); ) {
            String name = (String)e.nextElement();
            if (name.startsWith(Constants.ACTION_PARAM_PREFIX)) {
                if (name.endsWith(".x") || name.endsWith(".y")) {
                    return name.substring(Constants.ACTION_PARAM_PREFIX.length(),name.length()-2);
                }
                 return name.substring(Constants.ACTION_PARAM_PREFIX.length());
            }
        }
        return null;
    }
15982#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getURI()
     */
    public String getURI() {
        return this.uri;
    }
15983#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getURIPrefix()
     */
    public String getURIPrefix() {
        return this.prefix;
    }
15984#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#setURI(java.lang.String)
     */
    public void setURI(String prefix, String value) {
        this.prefix = prefix;
        this.uri = value;
    }
15985#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getView()
     */
    public String getView() {
        return this.view;
    }
15986#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getAction()
     */
    public String getAction() {
        return this.action;
    }
15987#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#setStatus(int)
     */
    public void setStatus(int statusCode) {
        // for subclasses
    }
15988#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getObjectModel()
     */
    public Map getObjectModel() {
        return this.objectModel;
    }
15989#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#isResponseModified(long)
     */
    public boolean isResponseModified(long lastModified) {
        return true; // always modified
    }
15990#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#setResponseIsNotModified()
     */
    public void setResponseIsNotModified() {
        // does nothing
    }
15991#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getAttribute(java.lang.String)
     */
    public Object getAttribute(String name) {
        return this.attributes.get(name);
    }
15992#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#setAttribute(java.lang.String, java.lang.Object)
     */
    public void setAttribute(String name, Object value) {
        this.attributes.put(name, value);
    }
15993#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#removeAttribute(java.lang.String)
     */
    public void removeAttribute(String name) {
        this.attributes.remove(name);
    }
15994#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getAttributeNames()
     */
    public Enumeration getAttributeNames() {
        return new IteratorEnumeration(this.attributes.keySet().iterator());
    }
15995#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getOutputStream(int)
     */
    public OutputStream getOutputStream(int bufferSize)
    throws IOException {

        // This method could be called several times during request processing
        // with differing values of bufferSize and should handle this situation
        // correctly.

        if (bufferSize == -1) {
            if (this.secureOutputStream == null) {
                this.secureOutputStream = new BufferedOutputStream(this.outputStream);
            }
            return this.secureOutputStream;
        } else if (bufferSize == 0) {
            // Discard secure output stream if it was created before.
            if (this.secureOutputStream != null) {
                this.secureOutputStream = null;
            }
            return this.outputStream;
        } else {
            // FIXME Triple buffering, anyone?
            this.outputStream = new java.io.BufferedOutputStream(this.outputStream, bufferSize);
            return this.outputStream;
        }
    }
15996#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#tryResetResponse()
     */
    public boolean tryResetResponse()
    throws IOException {
        if (this.secureOutputStream != null) {
            this.secureOutputStream.clearBuffer();
            return true;
        }
        return false;
    }
15997#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#commitResponse()
     */
    public void commitResponse()
    throws IOException {
        if (this.secureOutputStream != null) {
            this.setContentLength(this.secureOutputStream.getCount());
            this.secureOutputStream.realFlush();
        } else if ( this.outputStream != null ){
            this.outputStream.flush();
        }
    }
15998#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#startingProcessing()
     */
    public void startingProcessing() {
        // do nothing here
    }
15999#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#finishingProcessing()
     */
    public void finishingProcessing() {
        // do nothing here
    }
16000#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#isInternRedirect()
     */
    public boolean isInternalRedirect() {
        return false;
    }
16001#/**
     * Constructor
     */
    public ForwardRedirector(Environment env) {
        this.env = env;
    }
16002#/**
     * Redirects to a given URL. If this URL starts with "cocoon:", then an internal
     * redirect is performed. Otherwise, an external redirect is send to the
     * environment.
     */
    public void redirect(boolean sessionMode, String url) throws IOException, ProcessingException {
        if (getLogger().isInfoEnabled()) {
            getLogger().info("Redirecting to '" + url + "'");
        }

        if (url.startsWith("cocoon:")) {
            cocoonRedirect(url);
        } else {
            this.doRedirect(sessionMode, url, false, false);
        }

        this.hasRedirected = true;
    }
16003#public void permanentRedirect(boolean sessionMode, String url) throws IOException, ProcessingException {
        if (getLogger().isInfoEnabled()) {
            getLogger().info("Redirecting to '" + url + "'");
        }

        if (url.startsWith("cocoon:")) {
            cocoonRedirect(url);
        } else {
            this.doRedirect(sessionMode, url, true, false);
        }

        this.hasRedirected = true;
    }
16004#/**
     * Unconditionally redirects to a given URL, even it this redirector is part of a
     * subpipeline.
     */
    public void globalRedirect(boolean sessionMode, String url) throws IOException, ProcessingException {
        if (getLogger().isInfoEnabled()) {
            getLogger().info("Redirecting to '" + url + "'");
        }

        // FIXME : how to handle global redirect to cocoon: ?
        if (url.startsWith("cocoon:")) {
            cocoonRedirect(url);
        } else {
            this.doRedirect(sessionMode, url, false, true);
        }
        this.hasRedirected = true;
    }
16005#protected abstract void cocoonRedirect(String uri) throws IOException, ProcessingException;
16006#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Redirector#hasRedirected()
     */
    public boolean hasRedirected() {
        return this.hasRedirected;
    }
16007#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Redirector#sendStatus(int)
     */
    public void sendStatus(int sc) {
        env.setStatus(sc);
        this.hasRedirected = true;
    }
16008#/**
     * Redirect the client to new URL with session mode
     */
    protected void doRedirect(boolean sessionmode, 
                              String newURL,
                              boolean permanent,
                              boolean global)
    throws IOException {
        final Request request = ObjectModelHelper.getRequest(this.env.getObjectModel());
        
        // check if session mode shall be activated
        if (sessionmode) {
            // The session
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("redirect: entering session mode");
            }
            String s = request.getRequestedSessionId();
            if (s != null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Old session ID found in request, id = " + s);
                    if (request.isRequestedSessionIdValid()) {
                        getLogger().debug("And this old session ID is valid");
                    }
                }
            }

            // get session from request, or create new session
            HttpSession session = request.getSession(true);
            if (session == null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("redirect session mode: unable to get session object!");
                }
            } else {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("redirect: session mode completed, id = " + session.getId());
                }
            }
        }

        // redirect
        this.env.redirect(newURL, global, permanent);
    }
16009#/**
     * Creates a HttpRequest based on a real HttpServletRequest object
     * @param req The HttpServletReqeust
     * @param env The HttpEnvironment
     */
    protected HttpRequest(HttpServletRequest req, HttpEnvironment env) {
        super();
        this.req = req;
        this.env = env;
    }
16010#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#get(java.lang.String)
     */
    public Object get(String name) {
        // if the request has been wrapped then access its method
        if (req instanceof ValueHolder) {
            return ((ValueHolder) req).get(name);
        }
        String[] values = req.getParameterValues(name);
        if (values == null) {
            return null;
        }
        if (values.length == 1) {
            return values[0];
        }
        if (values.length > 1) {
            Vector vect = new Vector(values.length);
            for (int i = 0; i < values.length; i++) {
                vect.add(values[i]);
            }
            return vect;
        }
        return null;
    }
16011#/* The HttpServletRequest interface methods */

    public String getAuthType() {
        return this.req.getAuthType();
    }
16012#public javax.servlet.http.Cookie[] getCookies() {
        return this.req.getCookies();
    }
16013#public Map getCookieMap() {
        if (this.cookieMap == null) {
            createCookieMap();
        }
        return this.cookieMap;
    }
16014#private synchronized void createCookieMap() {
        Map cookieMap = new HashMap();
        javax.servlet.http.Cookie[] cookies = this.req.getCookies();
        if (cookies != null) {
            for (int i=0; i < cookies.length; i++) {
                javax.servlet.http.Cookie cookie = cookies[i];
                cookieMap.put(cookie.getName(),cookie);
            }
        }
        this.cookieMap = Collections.unmodifiableMap(cookieMap);
    }
16015#public Cookie[] getCocoonCookies() {
        if (this.wrappedCookieMap == null) {
            wrapCookies();
        }
        return this.wrappedCookies;
    }
16016#public Map getCocoonCookieMap() {
        if (this.wrappedCookieMap == null) {
            wrapCookies();
        }
        return this.wrappedCookieMap;
    }
16017#private synchronized void wrapCookies() {
        this.wrappedCookieMap = new HashMap();
        javax.servlet.http.Cookie[] cookies = this.req.getCookies();
        if (cookies != null) {
            this.wrappedCookies = new Cookie[cookies.length];
            for(int i=0; i<cookies.length;i++) {
                HttpCookie cookie = new HttpCookie(cookies[i]);
                this.wrappedCookies[i] = cookie;
                this.wrappedCookieMap.put(cookie.getName(),cookie);
            }
        }
        this.wrappedCookieMap = Collections.unmodifiableMap(this.wrappedCookieMap);
    }
16018#public long getDateHeader(String name) {
        return this.req.getDateHeader(name);
    }
16019#public String getHeader(String name) {
        return this.req.getHeader(name);
    }
16020#public Enumeration getHeaders(String name) {
        return this.req.getHeaders(name);
    }
16021#public Enumeration getHeaderNames() {
        return this.req.getHeaderNames();
    }
16022#public int getIntHeader(String name) {
        return this.req.getIntHeader(name);
    }
16023#public String getMethod() {
        return this.req.getMethod();
    }
16024#public String getPathInfo() {
        return this.req.getPathInfo();
    }
16025#public String getPathTranslated() {
        return this.req.getPathTranslated();
    }
16026#public String getContextPath() {
        return this.req.getContextPath();
    }
16027#public String getQueryString() {
        return this.req.getQueryString();
    }
16028#public String getRemoteUser() {
        return this.req.getRemoteUser();
    }
16029#public boolean isUserInRole(String role) {
        return this.req.isUserInRole(role);
    }
16030#public java.security.Principal getUserPrincipal() {
        return this.req.getUserPrincipal();
    }
16031#public String getRequestedSessionId() {
        return this.req.getRequestedSessionId();
    }
16032#public String getRequestURI() {
        if (this.reqURI == null) {
            this.reqURI = this.req.getRequestURI();
            if ( this.reqURI.equals("/") ) {
                String s = this.req.getServletPath();
                final StringBuffer buffer = new StringBuffer();
                if ( null != s ) buffer.append(s);
                s = this.req.getPathInfo();
                if ( null != s ) buffer.append(s);
                this.reqURI = buffer.toString();
            }
        }
        return this.reqURI;
    }
16033#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getSitemapURI()
     */
    public String getSitemapURI() {
        return this.env.getURI();
    }
16034#public String getSitemapURIPrefix() {
        return this.env.getURIPrefix();
    }
16035#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getSitemapPath()
     */
    public String getSitemapPath() {
        return this.env.getURIPrefix();
    }
16036#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getServletPath()
     */
    public String getServletPath() {
        return this.req.getServletPath();
    }
16037#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getSession(boolean)
     */
    public javax.servlet.http.HttpSession getSession(boolean create) {
        javax.servlet.http.HttpSession serverSession = this.req.getSession(create);
        HttpSession session;
        if (serverSession != null)
        {
            synchronized (sessions)
            {
                // retrieve existing wrapper
                WeakReference ref = (WeakReference) sessions.get(serverSession);
                if (ref == null || (session = (HttpSession) ref.get()) == null)
                {
                    // create new wrapper
                    session = new HttpSession(serverSession);
                    sessions.put(serverSession, new WeakReference(session));
                }
            }
        }
        else
        {
            // invalidate
            session = null;
        }
        return session;
    }
16038#public javax.servlet.http.HttpSession getSession() {
        return this.getSession(true);
    }
16039#public Session getCocoonSession(boolean create) {
        return (Session) this.getSession(true);
    }
16040#public Session getCocoonSession() {
        return (Session) this.getSession(true);
    }
16041#public boolean isRequestedSessionIdValid() {
        return this.req.isRequestedSessionIdValid();
    }
16042#public boolean isRequestedSessionIdFromCookie()  {
        return this.req.isRequestedSessionIdFromCookie();
    }
16043#public boolean isRequestedSessionIdFromURL() {
        return this.req.isRequestedSessionIdFromURL();
    }
16044#/**
     * @deprecated As of Version 2.1 of the Java Servlet API, use
     *             {@link #isRequestedSessionIdFromURL()} instead.
     */
    public boolean isRequestedSessionIdFromUrl() {
        return this.req.isRequestedSessionIdFromURL();
    }
16045#/* The ServletRequest interface methods */

    /* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getAttribute(java.lang.String)
     */
    public Object getAttribute(String name) {
        return this.req.getAttribute(name);
    }
16046#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getAttributeNames()
     */
    public Enumeration getAttributeNames() {
        return this.req.getAttributeNames();
    }
16047#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#setAttribute(java.lang.String, java.lang.Object)
     */
    public void setAttribute(String name, Object value) {
        this.req.setAttribute(name, value);
    }
16048#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#removeAttribute(java.lang.String)
     */
    public void removeAttribute(String name) {
        this.req.removeAttribute(name);
    }
16049#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getLocalAttribute(java.lang.String)
     */
    public Object getLocalAttribute(String name) {
        return this.attributes.get(name);
    }
16050#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getLocalAttributeNames()
     */
    public Enumeration getLocalAttributeNames() {
        return IteratorUtils.asEnumeration(this.attributes.keySet().iterator());
    }
16051#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#setLocalAttribute(java.lang.String, java.lang.Object)
     */
    public void setLocalAttribute(String name, Object value) {
        this.attributes.put(name, value);
    }
16052#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#removeLocalAttribute(java.lang.String)
     */
    public void removeLocalAttribute(String name) {
        this.attributes.remove(name);
    }
16053#public String getCharacterEncoding() {
        if (this.form_encoding == null) {
            return this.req.getCharacterEncoding();
        }
        return this.form_encoding;
    }
16054#public void setCharacterEncoding(String form_encoding)
    throws java.io.UnsupportedEncodingException {
        this.form_encoding = form_encoding;
    }
16055#/**
     * Sets the default encoding of the servlet container.
     * @param container_encoding The default form encoding of the servlet container.
     */
    public void setContainerEncoding(String container_encoding) {
        this.container_encoding = container_encoding;
    }
16056#public int getContentLength() {
        return this.req.getContentLength();
    }
16057#public String getContentType() {
        return this.req.getContentType();
    }
16058#public ServletInputStream getInputStream() throws IOException {
        return this.req.getInputStream();
    }
16059#public String getParameter(String name) {
        String value = this.req.getParameter(name);
        if (this.form_encoding == null || this.container_encoding == null || value == null) {
            return value;
        }
        // Form and container encoding are equal, skip expensive value decoding
        if (this.container_encoding.equals(this.form_encoding)) {
            return value;
        }
        return decode(value);
    }
16060#private String decode(String str) {
        if (str == null) return null;
        try {
            if (this.container_encoding == null)
                this.container_encoding = "ISO-8859-1";
            byte[] bytes = str.getBytes(this.container_encoding);
            return new String(bytes, form_encoding);
        } catch (java.io.UnsupportedEncodingException uee) {
            throw new RequestEncodingException("Unsupported Encoding Exception", uee);
        }
    }
16061#public Enumeration getParameterNames() {
        return this.req.getParameterNames();
    }
16062#public String[] getParameterValues(String name) {
        String[] values = this.req.getParameterValues(name);
        if (values == null) return null;
        if (this.form_encoding == null) {
            return values;
        }
        String[] decoded_values = new String[values.length];
        for (int i = 0; i < values.length; ++i) {
            decoded_values[i] = decode(values[i]);
        }
        return decoded_values;
    }
16063#public String getProtocol() {
        return this.req.getProtocol();
    }
16064#public String getScheme() {
        return this.req.getScheme();
    }
16065#public String getServerName() {
        return this.req.getServerName();
    }
16066#public int getServerPort() {
        return this.req.getServerPort();
    }
16067#public BufferedReader getReader() throws IOException {
        return this.req.getReader();
    }
16068#public String getRemoteAddr() {
        return this.req.getRemoteAddr();
    }
16069#public String getRemoteHost() {
        return this.req.getRemoteHost();
    }
16070#public Locale getLocale() {
        return this.req.getLocale();
    }
16071#public Enumeration getLocales() {
        return this.req.getLocales();
    }
16072#public boolean isSecure() {
        return this.req.isSecure();
    }
16073#public RequestDispatcher getRequestDispatcher(String path) {
        return this.req.getRequestDispatcher(path);
    }
16074#/**
     * @deprecated As of Version 2.1 of the Java Servlet API, use
     * {@link javax.servlet.ServletContext#getRealPath(java.lang.String)}instead.
     */
    public String getRealPath(String path) {
        return this.req.getRealPath(path);
    }
16075#/**
     * @see org.apache.cocoon.environment.Request#searchAttribute(java.lang.String)
     */
    public Object searchAttribute(String name) {
        Object result = this.getLocalAttribute(name);
        if ( result == null ) {
            result = this.getAttribute(name);
        }
        return result;
    }
16076#/**
     * Constructs a HttpEnvironment object from a HttpServletRequest
     * and HttpServletResponse objects
     */
    public HttpEnvironment(String uri,
                           HttpServletRequest req,
                           HttpServletResponse res,
                           ServletContext servletContext,
                           Context context,
                           String containerEncoding,
                           String defaultFormEncoding)
    throws IOException {
        super(uri, null, null);

        this.request = new HttpRequest(req, this);
        this.request.setCharacterEncoding(defaultFormEncoding);
        this.request.setContainerEncoding(containerEncoding);
        this.response = new HttpResponse(res);

        setView(extractView(this.request));
        setAction(extractAction(this.request));

        this.objectModel.put(ObjectModelHelper.REQUEST_OBJECT, this.request);
        this.objectModel.put(ObjectModelHelper.RESPONSE_OBJECT, this.response);
        this.objectModel.put(ObjectModelHelper.CONTEXT_OBJECT, context);

        // This is a kind of a hack for the components that need
        // the real servlet objects to pass them along to other
        // libraries.
        this.objectModel.put(HTTP_REQUEST_OBJECT, req);
        this.objectModel.put(HTTP_RESPONSE_OBJECT, res);
        this.objectModel.put(HTTP_SERVLET_CONTEXT, servletContext);
    }
16077#/**
     *  Redirect the client to new URL
     */
    public void redirect(String newURL,
                         boolean global,
                         boolean permanent)
    throws IOException {
        // Redirect
        String redirect = this.response.encodeRedirectURL(newURL);

        // FIXME (VG): WebSphere 4.0/4.0.1 bug
        if (!newURL.startsWith("/") && newURL.indexOf(':') == -1 && redirect.indexOf(':') != -1) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Redirect: WebSphere Bug Detected!");
            }
            String base = NetUtils.getPath(request.getRequestURI());
            if (base.startsWith("/")) {
                base = base.substring(1);
            }
            redirect = response.encodeRedirectURL(base + '/' + newURL);
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Sending redirect to '" + redirect + "'");
        }

        if (permanent) {
            this.response.sendPermanentRedirect(redirect);
        } else {
            this.response.sendRedirect(redirect);
        }
    }
16078#/**
     * Set the StatusCode
     */
    public void setStatus(int statusCode) {
        this.response.setStatus(statusCode);
    }
16079#/**
     * Set the ContentType
     */
    public void setContentType(String contentType) {
        this.response.setContentType(contentType);
        this.contentType = contentType;
    }
16080#/**
     * Get the ContentType
     */
    public String getContentType() {
        return this.contentType;
    }
16081#/**
     * Set the length of the generated content
     */
    public void setContentLength(int length) {
        this.response.setContentLength(length);
    }
16082#/**
     * Check if the response has been modified since the same
     * "resource" was requested.
     * The caller has to test if it is really the same "resource"
     * which is requested.
     * @return true if the response is modified or if the
     *         environment is not able to test it
     */
    public boolean isResponseModified(long lastModified) {
        if (lastModified != 0) {
            long if_modified_since = this.request.getDateHeader("If-Modified-Since");
            this.response.setDateHeader("Last-Modified", lastModified);
            return (if_modified_since / 1000 < lastModified  / 1000);
        }
        return true;
    }
16083#/**
     * Mark the response as not modified.
     */
    public void setResponseIsNotModified() {
        this.response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
    }
16084#/**
     * Reset the response if possible. This allows error handlers to have
     * a higher chance to produce clean output if the pipeline that raised
     * the error has already output some data.
     *
     * @return true if the response was successfully reset
     */
    public boolean tryResetResponse()
    throws IOException {
        if (!super.tryResetResponse()) {
            try {
                if (!this.response.isCommitted()) {
                    this.response.reset();
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("Response successfully reset");
                    }
                    return true;
                }
            } catch (Exception e) {
                // Log the error, but don't transmit it
                getLogger().warn("Problem resetting response", e);
            }
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Response wasn't reset");
            }
            return false;
        }
        return true;
    }
16085#/**
     * Get the output stream where to write the generated resource.
     * The returned stream is buffered by the environment. If the
     * buffer size is -1 then the complete output is buffered.
     * If the buffer size is 0, no buffering takes place.
     */
    public OutputStream getOutputStream(final int bufferSize)
    throws IOException {
        if (this.outputStream == null) {
            this.outputStream = this.response.getOutputStream();
        }
        return super.getOutputStream(bufferSize);
    }
16086#/**
     * Always return <code>true</code>.
     */
    public boolean isExternal() {
        return true;
    }
16087#public HttpCookie(String name, String value) {
        this.cookie = new javax.servlet.http.Cookie(name, value);
    }
16088#public HttpCookie(javax.servlet.http.Cookie cookie) {
        this.cookie = cookie;
    }
16089#public javax.servlet.http.Cookie getServletCookie() {
        this.checkState();
        return this.cookie;
    }
16090#/**
     * Constructs a cookie with a specified name and value.
     *
     * <p>The name must conform to RFC 2109. That means it can contain
     * only ASCII alphanumeric characters and cannot contain commas,
     * semicolons, or white space or begin with a $ character. The cookie's
     * name cannot be changed after creation.
     *
     * <p>The value can be anything the server chooses to send. Its
     * value is probably of interest only to the server. The cookie's
     * value can be changed after creation with the
     * <code>setValue</code> method.
     *
     * <p>By default, cookies are created according to the Netscape
     * cookie specification. The version can be changed with the
     * <code>setVersion</code> method.
     *
     *
     * @param name                         a <code>String</code> specifying the name of the cookie
     *
     * @param value                        a <code>String</code> specifying the value of the cookie
     *
     * @throws IllegalArgumentException        if the cookie name contains illegal characters
     *                                        (for example, a comma, space, or semicolon)
     *                                        or it is one of the tokens reserved for use
     *                                        by the cookie protocol
     * @see #setValue(String)
     * @see #setVersion(int)
     *
     */

    public void init(String name, String value) {
        if (this.cookie == null) {
            this.cookie = new javax.servlet.http.Cookie(name, value);
        } else {
            throw new IllegalStateException("Cookie is already initialised");
        }
    }
16091#private void checkState() {
        if (this.cookie == null) {
            throw new IllegalStateException("Cookie is not initialised");
        }
    }
16092#/**
     *
     * Specifies a comment that describes a cookie's purpose.
     * The comment is useful if the browser presents the cookie
     * to the user. Comments
     * are not supported by Netscape Version 0 cookies.
     *
     * @param purpose                a <code>String</code> specifying the comment
     *                                to display to the user
     *
     * @see #getComment()
     *
     */

    public void setComment(String purpose) {
        this.checkState();
        this.cookie.setComment(purpose);
    }
16093#/**
     * Returns the comment describing the purpose of this cookie, or
     * <code>null</code> if the cookie has no comment.
     *
     * @return                        a <code>String</code> containing the comment,
     *                                or <code>null</code> if none
     *
     * @see #setComment(String)
     *
     */

    public String getComment() {
        this.checkState();
        return this.cookie.getComment();
    }
16094#/**
     *
     * Specifies the domain within which this cookie should be presented.
     *
     * <p>The form of the domain name is specified by RFC 2109. A domain
     * name begins with a dot (<code>.foo.com</code>) and means that
     * the cookie is visible to servers in a specified Domain Name System
     * (DNS) zone (for example, <code>www.foo.com</code>, but not
     * <code>a.b.foo.com</code>). By default, cookies are only returned
     * to the server that sent them.
     *
     *
     * @param pattern                a <code>String</code> containing the domain name
     *                                within which this cookie is visible;
     *                                form is according to RFC 2109
     *
     * @see #getDomain()
     *
     */

    public void setDomain(String pattern) {
        this.checkState();
        this.cookie.setDomain(pattern);
    }
16095#/**
     * Returns the domain name set for this cookie. The form of
     * the domain name is set by RFC 2109.
     *
     * @return                        a <code>String</code> containing the domain name
     *
     * @see #setDomain(String)
     *
     */

    public String getDomain() {
        this.checkState();
        return this.cookie.getDomain();
    }
16096#/**
     * Sets the maximum age of the cookie in seconds.
     *
     * <p>A positive value indicates that the cookie will expire
     * after that many seconds have passed. Note that the value is
     * the <i>maximum</i> age when the cookie will expire, not the cookie's
     * current age.
     *
     * <p>A negative value means
     * that the cookie is not stored persistently and will be deleted
     * when the Web browser exits. A zero value causes the cookie
     * to be deleted.
     *
     * @param expiry                an integer specifying the maximum age of the
     *                                 cookie in seconds; if negative, means
     *                                the cookie is not stored; if zero, deletes
     *                                the cookie
     *
     *
     * @see #getMaxAge()
     *
     */

    public void setMaxAge(int expiry) {
        this.checkState();
        this.cookie.setMaxAge(expiry);
    }
16097#/**
     * Returns the maximum age of the cookie, specified in seconds,
     * By default, <code>-1</code> indicating the cookie will persist
     * until browser shutdown.
     *
     *
     * @return                        an integer specifying the maximum age of the
     *                                cookie in seconds; if negative, means
     *                                the cookie persists until browser shutdown
     *
     *
     * @see #setMaxAge(int)
     *
     */

    public int getMaxAge() {
        this.checkState();
        return this.cookie.getMaxAge();
    }
16098#/**
     * Specifies a path for the cookie
     * to which the client should return the cookie.
     *
     * <p>The cookie is visible to all the pages in the directory
     * you specify, and all the pages in that directory's subdirectories.
     * A cookie's path must include the servlet that set the cookie,
     * for example, <i>/catalog</i>, which makes the cookie
     * visible to all directories on the server under <i>/catalog</i>.
     *
     * <p>Consult RFC 2109 (available on the Internet) for more
     * information on setting path names for cookies.
     *
     *
     * @param uri                a <code>String</code> specifying a path
     *
     *
     * @see #getPath()
     *
     */

    public void setPath(String uri) {
        this.checkState();
        this.cookie.setPath(uri);
    }
16099#/**
     * Returns the path on the server
     * to which the browser returns this cookie. The
     * cookie is visible to all subpaths on the server.
     *
     *
     * @return                a <code>String</code> specifying a path that contains
     *                        a servlet name, for example, <i>/catalog</i>
     *
     * @see #setPath(String)
     *
     */

    public String getPath() {
        this.checkState();
        return this.cookie.getPath();
    }
16100#/**
     * Indicates to the browser whether the cookie should only be sent
     * using a secure protocol, such as HTTPS or SSL.
     *
     * <p>The default value is <code>false</code>.
     *
     * @param flag        if <code>true</code>, sends the cookie from the browser
     *                        to the server using only when using a secure protocol;
     *                        if <code>false</code>, sent on any protocol
     *
     * @see #getSecure()
     *
     */

    public void setSecure(boolean flag) {
        this.checkState();
        this.cookie.setSecure(flag);
    }
16101#/**
     * Returns <code>true</code> if the browser is sending cookies
     * only over a secure protocol, or <code>false</code> if the
     * browser can send cookies using any protocol.
     *
     * @return                <code>true</code> if the browser can use
     *                        any standard protocol; otherwise, <code>false</code>
     *
     * @see #setSecure(boolean)
     *
     */

    public boolean getSecure() {
        this.checkState();
        return this.cookie.getSecure();
    }
16102#/**
     * Returns the name of the cookie. The name cannot be changed after
     * creation.
     *
     * @return                a <code>String</code> specifying the cookie's name
     *
     */

    public String getName() {
        this.checkState();
        return this.cookie.getName();
    }
16103#/**
     *
     * Assigns a new value to a cookie after the cookie is created.
     * If you use a binary value, you may want to use BASE64 encoding.
     *
     * <p>With Version 0 cookies, values should not contain white
     * space, brackets, parentheses, equals signs, commas,
     * double quotes, slashes, question marks, at signs, colons,
     * and semicolons. Empty values may not behave the same way
     * on all browsers.
     *
     * @param newValue                a <code>String</code> specifying the new value
     *
     *
     * @see #getValue()
     * @see Cookie
     *
     */

    public void setValue(String newValue) {
        this.checkState();
        this.cookie.setValue(newValue);
    }
16104#/**
     * Returns the value of the cookie.
     *
     * @return                        a <code>String</code> containing the cookie's
     *                                present value
     *
     * @see #setValue(String)
     * @see Cookie
     *
     */

    public String getValue() {
        this.checkState();
        return this.cookie.getValue();
    }
16105#/**
     * Returns the version of the protocol this cookie complies
     * with. Version 1 complies with RFC 2109,
     * and version 0 complies with the original
     * cookie specification drafted by Netscape. Cookies provided
     * by a browser use and identify the browser's cookie version.
     *
     *
     * @return                        0 if the cookie complies with the
     *                                original Netscape specification; 1
     *                                if the cookie complies with RFC 2109
     *
     * @see #setVersion(int)
     *
     */

    public int getVersion() {
        this.checkState();
        return this.cookie.getVersion();
    }
16106#/**
     * Sets the version of the cookie protocol this cookie complies
     * with. Version 0 complies with the original Netscape cookie
     * specification. Version 1 complies with RFC 2109.
     *
     * <p>Since RFC 2109 is still somewhat new, consider
     * version 1 as experimental; do not use it yet on production sites.
     *
     *
     * @param v                        0 if the cookie should comply with
     *                                the original Netscape specification;
     *                                1 if the cookie should comply with RFC 2109
     *
     * @see #getVersion()
     *
     */

    public void setVersion(int v) {
        this.checkState();
        this.cookie.setVersion(v);
    }
16107#public RequestEncodingException(String message)
    {
        super(message, null);
    }
16108#public RequestEncodingException(String message, Throwable cause)
    {
        super(message, cause);
    }
16109#/**
     * Construct a new session from an HttpSession
     */
    public HttpSession(javax.servlet.http.HttpSession session) {
        this.wrappedSession = session;
    }
16110#/**
     *
     * Returns the time when this session was created, measured
     * in milliseconds since midnight January 1, 1970 GMT.
     *
     * @return                                a <code>long</code> specifying
     *                                         when this session was created,
     *                                        expressed in
     *                                        milliseconds since 1/1/1970 GMT
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     *
     */
    public long getCreationTime() {
        return this.wrappedSession.getCreationTime();
    }
16111#/**
     *
     * Returns a string containing the unique identifier assigned
     * to this session. The identifier is assigned
     * by the context container and is implementation dependent.
     *
     * @return                                a string specifying the identifier
     *                                        assigned to this session
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     *
     */
    public String getId() {
        return this.wrappedSession.getId();
    }
16112#/**
     *
     * Returns the last time the client sent a request associated with
     * this session, as the number of milliseconds since midnight
     * January 1, 1970 GMT.
     *
     * <p>Actions that your application takes, such as getting or setting
     * a value associated with the session, do not affect the access
     * time.
     *
     * @return                                a <code>long</code>
     *                                        representing the last time
     *                                        the client sent a request associated
     *                                        with this session, expressed in
     *                                        milliseconds since 1/1/1970 GMT
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     *
     */

    public long getLastAccessedTime() {
        return this.wrappedSession.getLastAccessedTime();
    }
16113#/**
     *
     * Specifies the time, in seconds, between client requests before the
     * contextcontainer will invalidate this session.  A negative time
     * indicates the session should never timeout.
     *
     * @param interval                An integer specifying the number
     *                                 of seconds
     *
     */
    public void setMaxInactiveInterval(int interval) {
        this.wrappedSession.setMaxInactiveInterval(interval);
    }
16114#/**
    * Returns the maximum time interval, in seconds, that
    * the context container will keep this session open between
    * client accesses. After this interval, the context container
    * will invalidate the session.  The maximum time interval can be set
    * with the <code>setMaxInactiveInterval</code> method.
    * A negative time indicates the session should never timeout.
    *
    *
    * @return                an integer specifying the number of
    *                        seconds this session remains open
    *                        between client requests
    *
    * @see                #setMaxInactiveInterval(int)
    *
    *
    */
    public int getMaxInactiveInterval() {
        return this.wrappedSession.getMaxInactiveInterval();
    }
16115#/**
     *
     * Returns the object bound with the specified name in this session, or
     * <code>null</code> if no object is bound under the name.
     *
     * @param name                a string specifying the name of the object
     *
     * @return                        the object with the specified name
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     *
     */
    public Object getAttribute(String name) {
        return this.wrappedSession.getAttribute(name);
    }
16116#/**
     *
     * Returns an <code>Enumeration</code> of <code>String</code> objects
     * containing the names of all the objects bound to this session.
     *
     * @return                        an <code>Enumeration</code> of
     *                                <code>String</code> objects specifying the
     *                                names of all the objects bound to
     *                                this session
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     *
     */
    public Enumeration getAttributeNames() {
        return this.wrappedSession.getAttributeNames();
    }
16117#/**
     * Binds an object to this session, using the name specified.
     * If an object of the same name is already bound to the session,
     * the object is replaced.
     *
     *
     * @param name                        the name to which the object is bound;
     *                                        cannot be null
     *
     * @param value                        the object to be bound; cannot be null
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     *
     */
    public void setAttribute(String name, Object value) {
        this.wrappedSession.setAttribute(name, value);
    }
16118#/**
     *
     * Removes the object bound with the specified name from
     * this session. If the session does not have an object
     * bound with the specified name, this method does nothing.
     *
     *
     * @param name                                the name of the object to
     *                                                remove from this session
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        invalidated session
     */
    public void removeAttribute(String name) {
        this.wrappedSession.removeAttribute(name);
    }
16119#/**
     *
     * Invalidates this session
     * to it.
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        already invalidated session
     *
     */
    public void invalidate() {
        this.wrappedSession.invalidate();
    }
16120#/**
     *
     * Returns <code>true</code> if the client does not yet know about the
     * session or if the client chooses not to join the session.  For
     * example, if the server used only cookie-based sessions, and
     * the client had disabled the use of cookies, then a session would
     * be new on each request.
     *
     * @return                                 <code>true</code> if the
     *                                        server has created a session,
     *                                        but the client has not yet joined
     *
     * @exception IllegalStateException        if this method is called on an
     *                                        already invalidated session
     *
     */
    public boolean isNew() {
        return this.wrappedSession.isNew();
    }
16121#/**
     * Creates a HttpServletResponse based on a real HttpServletResponse object
     */
    protected HttpResponse (HttpServletResponse res) {
        this.res = res;
    }
16122#/**
     * Create a new cookie which is not added to the response
     */
    public javax.servlet.http.Cookie createCookie(String name, String value) {
        return new javax.servlet.http.Cookie(name, value);
    }
16123#public void addCookie(javax.servlet.http.Cookie cookie) {
        this.res.addCookie(cookie);
    }
16124#public Cookie createCocoonCookie(String name, String value) {
        return new HttpCookie(name, value);
    }
16125#public void addCookie(Cookie cookie) {
        if (cookie instanceof HttpCookie) {
            this.res.addCookie(((HttpCookie)cookie).getServletCookie());
        } else {
            javax.servlet.http.Cookie newCookie;
            newCookie = new javax.servlet.http.Cookie(cookie.getName(), cookie.getValue());
            newCookie.setComment(cookie.getComment());
            newCookie.setDomain(cookie.getDomain());
            newCookie.setMaxAge(cookie.getMaxAge());
            newCookie.setPath(cookie.getPath());
            newCookie.setSecure(cookie.getSecure());
            newCookie.setVersion(cookie.getVersion());
            this.res.addCookie(newCookie);
        }
    }
16126#public boolean containsHeader(String name) {
        return this.res.containsHeader(name);
    }
16127#public String encodeURL(String url) {
        if (url != null && url.indexOf(";jsessionid=") != -1)
            return url;
        return this.res.encodeURL(url);
    }
16128#public String encodeRedirectURL(String url) {
        if (url != null && url.indexOf(";jsessionid=") != -1) {
            return url;
        }

        return this.res.encodeRedirectURL(url);
    }
16129#public void sendError(int sc, String msg) throws IOException {
        this.res.sendError(sc, msg);
    }
16130#public void sendError(int sc) throws IOException {
        this.res.sendError(sc);
    }
16131#public void sendRedirect(String location) throws IOException {
        this.res.sendRedirect(location);
    }
16132#public void sendPermanentRedirect(String location) throws IOException {
        this.res.setHeader("location", location);
        this.res.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);
    }
16133#public void setDateHeader(String name, long date) {
        this.res.setDateHeader(name, date);
    }
16134#public void addDateHeader(String name, long date) {
        this.res.addDateHeader(name, date);
    }
16135#public void setHeader(String name, String value) {
        this.res.setHeader(name, value);
    }
16136#public void addHeader(String name, String value) {
        this.res.addHeader(name, value);
    }
16137#public void setIntHeader(String name, int value) {
        this.res.setIntHeader(name, value);
    }
16138#public void addIntHeader(String name, int value) {
        this.res.addIntHeader(name, value);
    }
16139#public void setStatus(int sc) {
        this.res.setStatus(sc);
    }
16140#/**
     * @deprecated        As of version 2.1, use encodeURL(String url) instead
     */
    public String encodeUrl(String url) {
        return this.res.encodeUrl(url);
    }
16141#/**
     * @deprecated        As of version 2.1, use
     *              encodeRedirectURL(String url) instead
     */
    public String encodeRedirectUrl(String url) {
        return this.res.encodeRedirectUrl(url);
    }
16142#/**
     * @deprecated As of version 2.1, due to ambiguous meaning of the
     * message parameter. To set a status code
     * use <code>setStatus(int)</code>, to send an error with a description
     * use <code>sendError(int, String)</code>.
     */
    public void setStatus(int sc, String sm) {
        this.res.setStatus(sc, sm);
    }
16143#/* The ServletResponse interface methods */

    public String getCharacterEncoding() {
        return this.res.getCharacterEncoding();
    }
16144#public ServletOutputStream getOutputStream() throws IOException {
        //throw new IllegalStateException ("you are not a serializer or reader");
        return this.res.getOutputStream();
    }
16145#public PrintWriter getWriter() throws IOException {
        //throw new IllegalStateException ("you are not a serializer or reader");
        return this.res.getWriter();
    }
16146#public void setContentLength(int len) {
        this.res.setContentLength(len);
    }
16147#public void setContentType(String type) {
        this.res.setContentType(type);
    }
16148#public void setBufferSize(int size) {
        this.res.setBufferSize(size);
    }
16149#public int getBufferSize() {
        return this.res.getBufferSize();
    }
16150#public void flushBuffer() throws IOException {
        this.res.flushBuffer();
    }
16151#public boolean isCommitted() {
        return this.res.isCommitted();
    }
16152#public void reset() {
        this.res.reset();
    }
16153#public void setLocale(Locale loc) {
        this.res.setLocale(loc);
    }
16154#public Locale getLocale() {
        return this.res.getLocale();
    }
16155#/**
     * Constructs a HttpContext object from a ServletContext object
     */
    public HttpContext (ServletContext servletContext) {
        this.servletContext = servletContext;
    }
16156#public Object getAttribute(String name) {
        return servletContext.getAttribute(name);
    }
16157#public void setAttribute(String name, Object value) {
        servletContext.setAttribute(name, value);
    }
16158#public void removeAttribute(String name) {
        servletContext.removeAttribute(name);
    }
16159#public Enumeration getAttributeNames() {
        return servletContext.getAttributeNames();
    }
16160#public URL getResource(String path)
       throws MalformedURLException {
       return servletContext.getResource(path);
    }
16161#public InputStream getResourceAsStream(String path) {
        return servletContext.getResourceAsStream(path);
    }
16162#public String getRealPath(String path) {
        if (path.equals("/")) {
            String value = servletContext.getRealPath(path);
            if (value == null) {
                // Try to figure out the path of the root from that of WEB-INF
                try {
                    URL webXml = this.servletContext.getResource("/WEB-INF/web.xml");
                    // In some contexts there might not be any web.xml, then we stop
                    // guessing an just return null, which follows the servlet specification
                    if (webXml == null)
                        return null;
                    value = webXml.toString();
                } catch (MalformedURLException mue) {
                    throw new ContextURLException("Cannot determine the base URL for " + path, mue);
                }
                value = value.substring(0,value.length()-"WEB-INF/web.xml".length());
            }
            return value;
        }
        return servletContext.getRealPath(path);
    }
16163#public String getMimeType(String file) {
      return servletContext.getMimeType(file);
    }
16164#public String getInitParameter(String name) {
        return servletContext.getInitParameter(name);
    }
16165#/*
     * These methods are not in Cocoon's Context interface, but in the
     * ServletContext. To use them you have to downcast Cocoon's Context
     * to this HttpContext until we decide to add them to the Context
     * interface too.
     *
     * The following methods are deprecated since Servlet API 2.0 or 2.1
     * and will not be implemented here:
     * - public Servlet getServlet(String name)
     * - public Enumeration getServletNames()
     * - public Enumeration getServlets()
     * - public void log(Exception exception, String msg)
     */

    public ServletContext getContext(String uripath) {
        return this.servletContext.getContext(uripath);
    }
16166#public Enumeration getInitParameterNames() {
        return this.servletContext.getInitParameterNames();
    }
16167#public int getMajorVersion() {
        return this.servletContext.getMajorVersion();
    }
16168#public int getMinorVersion() {
        return this.servletContext.getMinorVersion();
    }
16169#public RequestDispatcher getNamedDispatcher(String name) {
        return this.servletContext.getNamedDispatcher(name);
    }
16170#public RequestDispatcher getRequestDispatcher(String path) {
        return this.servletContext.getRequestDispatcher(path);
    }
16171#public String getServerInfo() {
        return this.servletContext.getServerInfo();
    }
16172#/**
     * @see org.apache.cocoon.environment.impl.AbstractContext#log(java.lang.String)
     */
    public void log(String msg) {
        this.servletContext.log(msg);
    }
16173#/**
     * @see org.apache.cocoon.environment.impl.AbstractContext#log(java.lang.String, java.lang.Throwable)
     */
    public void log(String msg, Throwable throwable) {
        this.servletContext.log(msg, throwable);
    }
16174#/**
     * @see org.apache.cocoon.environment.impl.AbstractContext#log(java.lang.Exception, java.lang.String)
     */
    public void log(Exception exception, String msg) {
        this.servletContext.log(msg, exception);
    }
16175#public ContextURLException(String message)
    {
        super(message, null);
    }
16176#public ContextURLException(String message, Throwable cause)
    {
        super(message, cause);
    }
16177#public RequestParameterMap(Request request) {
        this.request = request;
    }
16178#public Object get(Object key) {
        return request.getParameter(key.toString());
    }
16179#public Set entrySet() {
        Set entries = new HashSet();
        for (Enumeration e = request.getParameterNames(); e.hasMoreElements();) {
            String name = (String) e.nextElement();
            entries.add(new BaseMap.Entry(name, request.getParameter(name)));
        }

        return entries;
    }
16180#public boolean equals(Object obj) {
        if (obj == null || !(obj instanceof RequestParameterMap)) {
            return false;
        }

        return super.equals(obj);
    }
16181#public SessionMap(Session session) {
        this.session = session;
    }
16182#public Object get(Object key) {
        return session.getAttribute(key.toString());
    }
16183#public Object put(Object key, Object value) {
        String sKey = key.toString();
        Object old = session.getAttribute(sKey);
        session.setAttribute(sKey, value);
        return old;
    }
16184#public Object remove(Object key) {
        String sKey = key.toString();
        Object old = session.getAttribute(sKey);
        session.removeAttribute(sKey);
        return old;
    }
16185#public Set entrySet() {
        Set entries = new HashSet();
        for (Enumeration e = session.getAttributeNames(); e.hasMoreElements();) {
            String name = (String) e.nextElement();
            entries.add(new BaseMap.Entry(name, session.getAttribute(name)));
        }

        return entries;
    }
16186#public boolean equals(Object obj) {
        if (obj == null || !(obj instanceof SessionMap)) {
            return false;
        }

        return super.equals(obj);
    }
16187#public BaseMap() {
    }
16188#public void clear() {
        throw new UnsupportedOperationException();
    }
16189#public void putAll(Map t) {
        throw new UnsupportedOperationException();
    }
16190#public Object remove(Object key) {
        throw new UnsupportedOperationException();
    }
16191#public Set entrySet() {
        throw new UnsupportedOperationException();
    }
16192#public Entry(Object key, Object value) {
            this.key = key;
            this.value = value;
        }
16193#public Object getKey() {
            return key;
        }
16194#public Object getValue() {
            return value;
        }
16195#public Object setValue(Object value) {
            throw new UnsupportedOperationException();
        }
16196#public int hashCode() {
            return (key != null ? key.hashCode() : 0) ^ (value != null ? value.hashCode() : 0);
        }
16197#public boolean equals(Object obj) {
            if (obj == null || !(obj instanceof Map.Entry)) {
                return false;
            }

            Map.Entry other = (Map.Entry) obj;
            Object key = other.getKey();
            if (key == this.key || key != null && key.equals(this.key)) {
                Object value = other.getValue();
                return value == this.value || value != null && value.equals(this.value);
            }
            return false;
        }
16198#public Map getAttributes() {
	return new SessionMap(this);
    }
16199#public ServletContext getServletContext() {
        // TODO The method was added when Session was made extending HttpSession, implement the method
        throw new UnsupportedOperationException();
    }
16200#public HttpSessionContext getSessionContext() {
        // TODO Deprecated method that was added when Session was made extending HttpSession, should it be implemented?
        throw new UnsupportedOperationException();
    }
16201#public Object getValue(String name) {
        // TODO Deprecated method that was added when Session was made extending HttpSession, should it be implemented?
        throw new UnsupportedOperationException();
    }
16202#public String[] getValueNames() {
        // TODO Deprecated method that was added when Session was made extending HttpSession, should it be implemented?
        throw new UnsupportedOperationException();
    }
16203#public void putValue(String name, Object value) {
        // TODO Deprecated method that was added when Session was made extending HttpSession, should it be implemented?
        throw new UnsupportedOperationException();
    }
16204#public void removeValue(String name) {
        // TODO Deprecated method that was added when Session was made extending HttpSession, should it be implemented?
        throw new UnsupportedOperationException();
    }
16205#public RequestHeaderMap(Request request) {
        this.request = request;
    }
16206#public Object get(Object key) {
        return request.getHeader(key.toString());
    }
16207#public Set entrySet() {
        Set entries = new HashSet();
        for (Enumeration e = request.getHeaderNames(); e.hasMoreElements();) {
            String name = (String) e.nextElement();
            entries.add(new BaseMap.Entry(name, request.getHeader(name)));
        }

        return entries;
    }
16208#public boolean equals(Object obj) {
        if (obj == null || !(obj instanceof RequestHeaderMap)) {
            return false;
        }

        return super.equals(obj);
    }
16209#public String encodeRedirectURL(String url) {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16210#public String encodeRedirectUrl(String url) {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16211#public String encodeUrl(String url) {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16212#public void sendError(int sc) throws IOException {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16213#public void sendError(int sc, String msg) throws IOException {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16214#public void sendRedirect(String location) throws IOException {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16215#public void setStatus(int sc) {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16216#public void setStatus(int sc, String sm) {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16217#public void flushBuffer() throws IOException {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16218#public int getBufferSize() {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16219#public String getContentType() {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16220#public ServletOutputStream getOutputStream() throws IOException {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16221#public PrintWriter getWriter() throws IOException {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16222#public boolean isCommitted() {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16223#public void reset() {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16224#public void resetBuffer() {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16225#public void setBufferSize(int size) {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16226#public void setCharacterEncoding(String charset) {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16227#public void setContentLength(int len) {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16228#public void setContentType(String type) {
        // TODO The method was added when Response was made extending HttpServletResponse, implement the method
        throw new UnsupportedOperationException();
    }
16229#public RequestMap(Request request) {
        this.request = request;
    }
16230#public Object get(Object key) {
        return request.getAttribute(key.toString());
    }
16231#public Object put(Object key, Object value) {
        String sKey = key.toString();
        Object old = request.getAttribute(sKey);
        request.setAttribute(sKey, value);
        return old;
    }
16232#public Object remove(Object key) {
        String sKey = key.toString();
        Object old = request.getAttribute(sKey);
        request.removeAttribute(sKey);
        return old;
    }
16233#public Set entrySet() {
        Set entries = new HashSet();
        for (Enumeration e = request.getAttributeNames(); e.hasMoreElements();) {
            String name = (String) e.nextElement();
            entries.add(new BaseMap.Entry(name, request.getAttribute(name)));
        }

        return entries;
    }
16234#public boolean equals(Object obj) {
        if (obj == null || !(obj instanceof RequestMap)) {
            return false;
        }

        return super.equals(obj);
    }
16235#public ContextMap(Context context) {
        this.context = context;
    }
16236#public Object get(Object key) {
        return context.getAttribute(key.toString());
    }
16237#public Object put(Object key, Object value) {
        String sKey = key.toString();
        Object old = context.getAttribute(sKey);
        context.setAttribute(sKey, value);
        return old;
    }
16238#public Object remove(Object key) {
        String sKey = key.toString();
        Object old = context.getAttribute(sKey);
        context.removeAttribute(sKey);
        return old;
    }
16239#public Set entrySet() {
        Set entries = new HashSet();
        for (Enumeration e = context.getAttributeNames(); e.hasMoreElements();) {
            String name = (String) e.nextElement();
            entries.add(new BaseMap.Entry(name, context.getAttribute(name)));
        }

        return entries;
    }
16240#public boolean equals(Object obj) {
        if (obj == null || !(obj instanceof ContextMap)) {
            return false;
        }

        return super.equals(obj);
    }
16241#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getAttributes()
     */
    public Map getAttributes() {
        return new RequestMap(this);
    }
16242#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getParameters()
     */
    public Map getParameters() {
        return new RequestParameterMap(this);
    }
16243#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getHeaders()
     */
    public Map getHeaders() {
        return new RequestHeaderMap(this);
    }
16244#public int getIntHeader(String name) {
        // TODO The method was added when Request was made extending HttpServletRequest, implement the method
        throw new UnsupportedOperationException();
    }
16245#/* (non-Javadoc)
     * @see javax.servlet.http.HttpServletRequest#getRequestURL()
     */
    public StringBuffer getRequestURL() {
        // TODO The method was added when Request was made extending HttpServletRequest, implement the method
        throw new UnsupportedOperationException();
    }
16246#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getLocalAddr()
     */
    public String getLocalAddr() {
        // TODO The method was added when Request was made extending HttpServletRequest, implement the method
        throw new UnsupportedOperationException();
    }
16247#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getLocalName()
     */
    public String getLocalName() {
        // TODO The method was added when Request was made extending HttpServletRequest, implement the method
        throw new UnsupportedOperationException();
    }
16248#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getLocalPort()
     */
    public int getLocalPort() {
        // TODO The method was added when Request was made extending HttpServletRequest, implement the method
        throw new UnsupportedOperationException();
    }
16249#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getParameterMap()
     */
    public Map getParameterMap() {
        // TODO The method was added when Request was made extending HttpServletRequest, implement the method
        throw new UnsupportedOperationException();
    }
16250#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getRemotePort()
     */
    public int getRemotePort() {
        // TODO The method was added when Request was made extending HttpServletRequest, implement the method
        throw new UnsupportedOperationException();
    }
16251#/* (non-Javadoc)
     * @see javax.servlet.http.HttpServletRequest#isRequestedSessionIdFromUrl()
     */
    public boolean isRequestedSessionIdFromUrl() {
        // TODO The method was added when Request was made extending HttpServletRequest, implement the method
        throw new UnsupportedOperationException();
    }
16252#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getReader()
     */
    public BufferedReader getReader() throws IOException {
        // TODO The method was added when Request was made extending HttpServletRequest, implement the method
        throw new UnsupportedOperationException();
    }
16253#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getRealPath(java.lang.String)
     */
    public String getRealPath(String path) {
        // TODO The method was added when Request was made extending HttpServletRequest, implement the method
        throw new UnsupportedOperationException();
    }
16254#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getRequestDispatcher(java.lang.String)
     */
    public RequestDispatcher getRequestDispatcher(String path) {
        // TODO The method was added when Request was made extending HttpServletRequest, implement the method
        throw new UnsupportedOperationException();
    }
16255#/**
     * @see javax.servlet.ServletContext#getAttribute(java.lang.String)
     */
    public Object getAttribute(String key) {
        return this.attributes.get(key);
    }
16256#/**
     * @see javax.servlet.ServletContext#getAttributeNames()
     */
    public Enumeration getAttributeNames() {
        return Collections.enumeration(this.attributes.keySet());
    }
16257#/**
     * @see javax.servlet.ServletContext#getContext(java.lang.String)
     */
    public ServletContext getContext(String arg0) {
        return this;
    }
16258#/**
     * @see javax.servlet.ServletContext#getInitParameter(java.lang.String)
     */
    public String getInitParameter(String arg0) {
        return null;
    }
16259#/**
     * @see javax.servlet.ServletContext#getInitParameterNames()
     */
    public Enumeration getInitParameterNames() {
        return Collections.enumeration(Collections.EMPTY_LIST);
    }
16260#/**
     * @see javax.servlet.ServletContext#getMajorVersion()
     */
    public int getMajorVersion() {
        return 2;
    }
16261#/**
     * @see javax.servlet.ServletContext#getMimeType(java.lang.String)
     */
    public String getMimeType(String arg0) {
        return null;
    }
16262#/**
     * @see javax.servlet.ServletContext#getMinorVersion()
     */
    public int getMinorVersion() {
        return 3;
    }
16263#/**
     * @see javax.servlet.ServletContext#getNamedDispatcher(java.lang.String)
     */
    public RequestDispatcher getNamedDispatcher(String arg0) {
        return null;
    }
16264#/**
     * @see javax.servlet.ServletContext#getRealPath(java.lang.String)
     */
    public String getRealPath(String arg0) {
        return null;
    }
16265#/**
     * @see javax.servlet.ServletContext#getRequestDispatcher(java.lang.String)
     */
    public RequestDispatcher getRequestDispatcher(String arg0) {
        return null;
    }
16266#/**
     * @see javax.servlet.ServletContext#getResource(java.lang.String)
     */
    public URL getResource(String arg0) throws MalformedURLException {
        return null;
    }
16267#/**
     * Get access to the resource as @link {@link InputStream}. If there is any problem,
     * <code>null</code> is returned.
     * 
     * @see javax.servlet.ServletContext#getResourceAsStream(java.lang.String)
     */
    public InputStream getResourceAsStream(String path) {
    	URL resourceURL = null;
		try {
			resourceURL = this.getResource(path);
		} catch (MalformedURLException e) {
			return null;
		}
    	if(resourceURL != null) {
    		try {
				return resourceURL.openStream();
			} catch (IOException e) {
				return null;
			}
    	}
        return null;
    }
16268#/**
     * @see javax.servlet.ServletContext#getResourcePaths(java.lang.String)
     */
    public Set getResourcePaths(String arg0) {
        return null;
    }
16269#/**
     * @see javax.servlet.ServletContext#getServerInfo()
     */
    public String getServerInfo() {
        return null;
    }
16270#/**
     * @see javax.servlet.ServletContext#getServlet(java.lang.String)
     */
    public Servlet getServlet(String arg0) throws ServletException {
        return null;
    }
16271#/**
     * @see javax.servlet.ServletContext#getServletContextName()
     */
    public String getServletContextName() {
        return null;
    }
16272#/**
     * @see javax.servlet.ServletContext#getServletNames()
     */
    public Enumeration getServletNames() {
        return null;
    }
16273#/**
     * @see javax.servlet.ServletContext#getServlets()
     */
    public Enumeration getServlets() {
        return null;
    }
16274#/**
     * @see javax.servlet.ServletContext#removeAttribute(java.lang.String)
     */
    public void removeAttribute(String key) {
        this.attributes.remove(key);
    }
16275#/**
     * @see javax.servlet.ServletContext#setAttribute(java.lang.String, java.lang.Object)
     */
    public void setAttribute(String key, Object object) {
        this.attributes.put(key, object);
    }
16276#/**
     * @see org.apache.cocoon.environment.Context#getAttributes()
     */
    public Map getAttributes() {
	    return new ContextMap(this);
    }
16277#/**
     * Set the <code>SourceResolver</code>, object model <code>Map</code>,
     * the source and sitemap <code>Parameters</code> used to process the request.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        this.resolver = resolver;
        this.objectModel = objectModel;
        this.source = src;
        this.parameters = par;
    }
16278#/**
     * Recycle the generator by removing references
     */
    public void recycle() {
        super.recycle();
        this.resolver = null;
        this.objectModel = null;
        this.source = null;
        this.parameters = null;
    }
16279#/**
     * Set the current <code>ServiceManager</code> instance used by this
     * <code>Serviceable</code>.
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
16280#/**
     * Release all resources.
     */
    public void dispose() {
        this.manager = null;
    }
16281#/* (non-Javadoc)
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
16282#/* (non-Javadoc)
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        this.manager = null;
    }
16283#/* (non-Javadoc)
     * @see org.apache.cocoon.sitemap.SitemapModelComponent#setup(org.apache.cocoon.environment.SourceResolver, java.util.Map, java.lang.String, org.apache.avalon.framework.parameters.Parameters)
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {

        super.setup(resolver, objectModel, src, par);
        this.request = ObjectModelHelper.getRequest(objectModel);
        this.response = ObjectModelHelper.getResponse(objectModel);
        this.context = ObjectModelHelper.getContext(objectModel);
    }
16284#/* (non-Javadoc)
     * @see org.apache.avalon.excalibur.pool.Recyclable#recycle()
     */
    public void recycle() {
        super.recycle();
        this.request = null;
        this.response = null;
        this.context = null;
    }
16285#/**
	 * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
	 */
	public void service(ServiceManager manager) 
    throws ServiceException {
        this.manager = manager;
	}
16286#/**
     * Set the <code>SourceResolver</code> the object model <code>Map</code>,
     * the source and sitemap <code>Parameters</code> used to process the request.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        this.resolver = resolver;
        this.objectModel = objectModel;
        this.source = src;
        this.parameters = par;
    }
16287#/**
     * Set the <code>OutputStream</code>
     */
    public void setOutputStream(OutputStream out) {
        if (out instanceof BufferedOutputStream ||
            out instanceof org.apache.cocoon.util.BufferedOutputStream) {

            this.out = out;
        } else {
            this.out = new BufferedOutputStream(out, 1536);
        }
    }
16288#/**
     * Get the mime-type of the output of this <code>Reader</code>
     */
    public String getMimeType() {
        return null;
    }
16289#/**
     * @return the time the read source was last modified or 0 if it is not
     *         possible to detect
     */
    public long getLastModified() {
        return 0;
    }
16290#/**
     * Recycle the component
     */
    public void recycle() {
        this.out = null;
        this.resolver = null;
        this.source = null;
        this.parameters = null;
        this.objectModel = null;
    }
16291#/**
     * Test if the component wants to set the content length
     */
    public boolean shouldSetContentLength() {
        return false;
    }
16292#/**
     * Set the properties used for transformer handler used by the serializer
     * see {@link OutputKeys} for possible settings.
     * 
     * @param format
     */
    public void setFormat(Properties format) {
        this.format = format;
    }
16293#/**
     * Set the default encoding. This will be overided if the encoding is set
     * in the format properties. This is mainly useful together with Spring
     * bean inheritance.
     * 
     * @param defaultEncoding
     */
    public void setDefaultEncoding(String defaultEncoding) {
        this.defaultEncoding = defaultEncoding;
    }
16294#/**
     * Initialize logger, caching key, transformer handler and namespace pipe
     *
     * @throws Exception 
     */
    public void init() throws Exception {
        if (!this.format.containsKey(OutputKeys.ENCODING) && this.defaultEncoding != null) {
            this.format.put(OutputKeys.ENCODING, this.defaultEncoding);
        }
        this.cachingKey = createCachingKey(format);
        initTransformerFactory();
        initNamespacePipe();
    }
16295#/**
     * Optionally set the transformer factory used for creating the transformer
     * handler that is used for serialization. Otherwise the standard transformer
     * factory is used ({@link TransformerFactory}).
     * 
     * @param transformerFactoryClass the name of the class
     */
    public void setTransformerFactory(String transformerFactoryClass) {
        this.transformerFactoryClass = transformerFactoryClass;
    }
16296#/**
     * Interpose namespace pipe if needed.
     */
    public void setConsumer(XMLConsumer consumer) {
        if (this.namespacePipe == null) {
            super.setConsumer(consumer);
        } else {
            this.namespacePipe.setConsumer(consumer);
            super.setConsumer(this.namespacePipe);
        }
    }
16297#/**
     * Interpose namespace pipe if needed.
     */
    public void setContentHandler(ContentHandler handler) {
        if (this.namespacePipe == null) {
            super.setContentHandler(handler);
        } else {
            this.namespacePipe.setContentHandler(handler);
            super.setContentHandler(this.namespacePipe);
        }
    }
16298#/**
     * Interpose namespace pipe if needed.
     */
    public void setLexicalHandler(LexicalHandler handler) {
        if (this.namespacePipe == null) {
            super.setLexicalHandler(handler);
        } else {
            this.namespacePipe.setLexicalHandler(handler);
            super.setLexicalHandler(this.namespacePipe);
        }
    }
16299#/**
     * Helper for TransformerFactory.
     */
    protected SAXTransformerFactory getTransformerFactory() {
        return tfactory;
    }
16300#/**
     * Helper for TransformerHandler.
     */
    protected TransformerHandler getTransformerHandler() throws TransformerException {
        return this.getTransformerFactory().newTransformerHandler();
    }
16301#//    /**
//     * Set the {@link OutputStream} where the requested resource should
//     * be serialized.
//     */
//    public void setOutputStream(OutputStream out) throws IOException {
//        /*
//         * Add a level of buffering to the output stream. Xalan serializes
//         * every character individually. In conjunction with chunked
//         * transfer encoding this would otherwise lead to a whopping 6-fold
//         * increase of data on the wire.
//         */
//        //  if (outputBufferSize > 0) {
//        //      super.setOutputStream(
//        //        new BufferedOutputStream(out, outputBufferSize));
//        //  } else {
//        super.setOutputStream(out);
//        //  }
//    }

    /**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     * 
     * @deprecated use property injection instead
     */
    public void service(ServiceManager manager) throws ServiceException {
        final Settings settings = (Settings)manager.lookup(Settings.ROLE);
        String defaultEncoding  = settings.getFormEncoding();
        if (defaultEncoding != null) {
            this.format.setProperty(OutputKeys.ENCODING, defaultEncoding);
        }
        manager.release(settings);
    }
16302#/**
     * Set the configurations for this serializer.
     * 
     * @deprecated use property injection instead
     */
    public void configure(Configuration conf) throws ConfigurationException {
        // configure buffer size
        //   Configuration bsc = conf.getChild("buffer-size", false);
        //   if(null != bsc)
        //    outputBufferSize = bsc.getValueAsInteger(DEFAULT_BUFFER_SIZE);

        // configure xalan
        String cdataSectionElements = conf.getChild("cdata-section-elements").getValue(null);
        String dtPublic = conf.getChild("doctype-public").getValue(null);
        String dtSystem = conf.getChild("doctype-system").getValue(null);
        String encoding = conf.getChild("encoding").getValue(null);
        String indent = conf.getChild("indent").getValue(null);
        String mediaType = conf.getChild("media-type").getValue(null);
        String method = conf.getChild("method").getValue(null);
        String omitXMLDeclaration = conf.getChild("omit-xml-declaration").getValue(null);
        String standAlone = conf.getChild("standalone").getValue(null);
        String version = conf.getChild("version").getValue(null);

        if (cdataSectionElements != null) {
            format.put(OutputKeys.CDATA_SECTION_ELEMENTS, cdataSectionElements);
        }
        if (dtPublic != null) {
            format.put(OutputKeys.DOCTYPE_PUBLIC, dtPublic);
        }
        if (dtSystem != null) {
            format.put(OutputKeys.DOCTYPE_SYSTEM, dtSystem);
        }
        if (encoding != null) {
            format.put(OutputKeys.ENCODING, encoding);
        }
        if (indent != null) {
            format.put(OutputKeys.INDENT, indent);
        }
        if (mediaType != null) {
            format.put(OutputKeys.MEDIA_TYPE, mediaType);
        }
        if (method != null) {
            format.put(OutputKeys.METHOD, method);
        }
        if (omitXMLDeclaration != null) {
            format.put(OutputKeys.OMIT_XML_DECLARATION, omitXMLDeclaration);
        }
        if (standAlone != null) {
            format.put(OutputKeys.STANDALONE, standAlone);
        }
        if (version != null) {
            format.put(OutputKeys.VERSION, version);
        }

        this.cachingKey = createCachingKey(format);

        this.transformerFactoryClass = conf.getChild("transformer-factory").getValue(null);
        this.initTransformerFactory();

        this.initNamespacePipe();

    }
16303#/**
     * @see org.apache.avalon.excalibur.pool.Recyclable#recycle()
     */
    public void recycle() {
        super.recycle();
        if (this.namespacePipe != null) {
            this.namespacePipe.recycle();
        }
    }
16304#private void initTransformerFactory() throws ConfigurationException, TransformerFactoryConfigurationError {
        if (transformerFactoryClass != null) {
            try {
                this.tfactory = (SAXTransformerFactory) ClassUtils.newInstance(transformerFactoryClass);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Using transformer factory " + transformerFactoryClass);
                }
            } catch (Exception e) {
                throw new ConfigurationException("Cannot load transformer factory " + transformerFactoryClass, e);
            }
        } else {
            // Standard TrAX behaviour
            this.tfactory = (SAXTransformerFactory) TransformerFactory.newInstance();
        }
        tfactory.setErrorListener(new TraxErrorHandler(getLogger()));
    }
16305#private void initNamespacePipe() {
        // Check if we need namespace as attributes.
        try {
            if (needsNamespacesAsAttributes()) {
                // Setup a correction pipe
                this.namespacePipe = new NamespaceAsAttributes();
            }
        } catch (Exception e) {
            getLogger().warn("Cannot know if transformer needs namespaces attributes - assuming NO.", e);
        }
    }
16306#/**
     * Create the caching key from the formating properties used by the
     * transformer handler that is used for serialization.
     * @param format 
     *
     */
    protected static String createCachingKey(Properties format) {
        final StringBuffer buffer = new StringBuffer();
        String value = null;
        
        // Use lookup of the property values instead of just iterating through the
        // enumeration of them to give the caching key a  deterministic order of its parts

        if ((value = format.getProperty(OutputKeys.CDATA_SECTION_ELEMENTS)) != null) {
            buffer.append(";cdata-section-elements=").append(value);
        }
        if ((value = format.getProperty(OutputKeys.DOCTYPE_PUBLIC)) != null) {
            buffer.append(";doctype-public=").append(value);
        }
        if ((value = format.getProperty(OutputKeys.DOCTYPE_SYSTEM)) != null) {
            buffer.append(";doctype-system=").append(value);
        }
        if ((value = format.getProperty(OutputKeys.ENCODING)) != null) {
            buffer.append(";encoding=").append(value);
        }
        if ((value = format.getProperty(OutputKeys.INDENT)) != null) {
            buffer.append(";indent=").append(value);
        }
        if ((value = format.getProperty(OutputKeys.MEDIA_TYPE)) != null) {
            buffer.append(";media-type=").append(value);
        }
        if ((value = format.getProperty(OutputKeys.METHOD)) != null) {
            buffer.append(";method=").append(value);
        }
        if ((value = format.getProperty(OutputKeys.OMIT_XML_DECLARATION)) != null) {
            buffer.append(";omit-xml-declaration=").append(value);
        }
        if ((value = format.getProperty(OutputKeys.STANDALONE)) != null) {
            buffer.append(";standalone=").append(value);
        }
        if ((value = format.getProperty(OutputKeys.VERSION)) != null) {
            buffer.append(";version=").append(value);
        }

        if ( buffer.length() > 0 )
            return buffer.toString();
        else
            return "1";
    }
16307#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     * This method must be invoked before the generateValidity() method.
     *
     * @return The generated key or <code>0</code> if the component
     *              is currently not cacheable.
     */
    public java.io.Serializable getKey() {
        return this.cachingKey;
    }
16308#/**
     * Generate the validity object.
     * Before this method can be invoked the generateKey() method
     * must be invoked.
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity() {
        return NOPValidity.SHARED_INSTANCE;
    }
16309#/**
     * Checks if the used Trax implementation correctly handles namespaces set using
     * <code>startPrefixMapping()</code>, but wants them also as 'xmlns:' attributes.
     * <p>
     * The check consists in sending SAX events representing a minimal namespaced document
     * with namespaces defined only with calls to <code>startPrefixMapping</code> (no
     * xmlns:xxx attributes) and check if they are present in the resulting text.
     */
    protected boolean needsNamespacesAsAttributes() throws Exception {

        SAXTransformerFactory factory = getTransformerFactory();

        Boolean cacheValue = (Boolean) needsNamespaceCache.get(factory.getClass().getName());
        if (cacheValue != null) {
            return cacheValue.booleanValue();
        } else {
            // Serialize a minimal document to check how namespaces are handled.
            StringWriter writer = new StringWriter();

            String uri = "namespaceuri";
            String prefix = "nsp";
            String check = "xmlns:" + prefix + "='" + uri + "'";

            TransformerHandler handler = this.getTransformerHandler();

            handler.getTransformer().setOutputProperties(format);
            handler.setResult(new StreamResult(writer));

            // Output a single element
            handler.startDocument();
            handler.startPrefixMapping(prefix, uri);
            handler.startElement(uri, "element", "element", XMLUtils.EMPTY_ATTRIBUTES);
            handler.endElement(uri, "element", "element");
            handler.endPrefixMapping(prefix);
            handler.endDocument();

            String text = writer.toString();

            // Check if the namespace is there (replace " by ' to be sure of what we search in)
            boolean needsIt = (text.replace('"', '\'').indexOf(check) == -1);

            String msg = needsIt ? " needs namespace attributes (will be slower)." : " handles correctly namespaces.";

            getLogger().debug("Trax handler " + handler.getClass().getName() + msg);

            needsNamespaceCache.put(factory.getClass().getName(), BooleanUtils.toBooleanObject(needsIt));

            return needsIt;
        }
    }
16310#public void startDocument() throws SAXException {
            // Cleanup
            this.uriToPrefixMap.clear();
            this.prefixToUriMap.clear();
            clearMappings();
            super.startDocument();
        }
16311#/**
         * Track mappings to be able to add <code>xmlns:</code> attributes
         * in <code>startElement()</code>.
         */
        public void startPrefixMapping(String prefix, String uri) throws SAXException {
            // Store the mappings to reconstitute xmlns:attributes
            // except prefixes starting with "xml": these are reserved
            // VG: (uri != null) fixes NPE in startElement
            if (uri != null && !prefix.startsWith("xml")) {
                this.hasMappings = true;
                this.prefixList.add(prefix);
                this.uriList.add(uri);

                // append the prefix colon now, in order to save concatenations later, but
                // only for non-empty prefixes.
                if (prefix.length() > 0) {
                    this.uriToPrefixMap.put(uri, prefix + ":");
                } else {
                    this.uriToPrefixMap.put(uri, prefix);
                }

                this.prefixToUriMap.put(prefix, uri);
            }
            super.startPrefixMapping(prefix, uri);
        }
16312#/**
         * Ensure all namespace declarations are present as <code>xmlns:</code> attributes
         * and add those needed before calling superclass. This is a workaround for a Xalan bug
         * (at least in version 2.0.1) : <code>org.apache.xalan.serialize.SerializerToXML</code>
         * ignores <code>start/endPrefixMapping()</code>.
         */
        public void startElement(String eltUri, String eltLocalName, String eltQName, Attributes attrs)
                throws SAXException {

            // try to restore the qName. The map already contains the colon
            if (null != eltUri && eltUri.length() != 0 && this.uriToPrefixMap.containsKey(eltUri)) {
                eltQName = this.uriToPrefixMap.get(eltUri) + eltLocalName;
            }
            if (this.hasMappings) {
                // Add xmlns* attributes where needed

                // New Attributes if we have to add some.
                AttributesImpl newAttrs = null;

                int mappingCount = this.prefixList.size();
                int attrCount = attrs.getLength();

                for (int mapping = 0; mapping < mappingCount; mapping++) {

                    // Build infos for this namespace
                    String uri = (String) this.uriList.get(mapping);
                    String prefix = (String) this.prefixList.get(mapping);
                    String qName = prefix.equals("") ? "xmlns" : ("xmlns:" + prefix);

                    // Search for the corresponding xmlns* attribute
                    boolean found = false;
                    for (int attr = 0; attr < attrCount; attr++) {
                        if (qName.equals(attrs.getQName(attr))) {
                            // Check if mapping and attribute URI match
                            if (!uri.equals(attrs.getValue(attr))) {
                                getLogger().error("URI in prefix mapping and attribute do not match : '"
                                                  + uri + "' - '" + attrs.getURI(attr) + "'");
                                throw new SAXException("URI in prefix mapping and attribute do not match");
                            }
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        // Need to add this namespace
                        if (newAttrs == null) {
                            // Need to test if attrs is empty or we go into an infinite loop...
                            // Well know SAX bug which I spent 3 hours to remind of :-(
                            if (attrCount == 0) {
                                newAttrs = new AttributesImpl();
                            } else {
                                newAttrs = new AttributesImpl(attrs);
                            }
                        }

                        if (prefix.equals("")) {
                            newAttrs.addAttribute(Constants.XML_NAMESPACE_URI, "xmlns", "xmlns", "CDATA", uri);
                        } else {
                            newAttrs.addAttribute(Constants.XML_NAMESPACE_URI, prefix, qName, "CDATA", uri);
                        }
                    }
                } // end for mapping

                // Cleanup for the next element
                clearMappings();

                // Start element with new attributes, if any
                super.startElement(eltUri, eltLocalName, eltQName, newAttrs == null ? attrs : newAttrs);
            } else {
                // Normal job
                super.startElement(eltUri, eltLocalName, eltQName, attrs);
            }
        }
16313#/**
         * Receive notification of the end of an element.
         * Try to restore the element qName.
         */
        public void endElement(String eltUri, String eltLocalName, String eltQName) throws SAXException {
            // try to restore the qName. The map already contains the colon
            if (null != eltUri && eltUri.length() != 0 && this.uriToPrefixMap.containsKey(eltUri)) {
                eltQName = this.uriToPrefixMap.get(eltUri) + eltLocalName;
            }
            super.endElement(eltUri, eltLocalName, eltQName);
        }
16314#/**
         * End the scope of a prefix-URI mapping:
         * remove entry from mapping tables.
         */
        public void endPrefixMapping(String prefix) throws SAXException {
            // remove mappings for xalan-bug-workaround.
            // Unfortunately, we're not passed the uri, but the prefix here,
            // so we need to maintain maps in both directions.
            if (this.prefixToUriMap.containsKey(prefix)) {
                this.uriToPrefixMap.remove(this.prefixToUriMap.get(prefix));
                this.prefixToUriMap.remove(prefix);
            }

            if (hasMappings) {
                // most of the time, start/endPrefixMapping calls have an element event between them,
                // which will clear the hasMapping flag and so this code will only be executed in the
                // rather rare occasion when there are start/endPrefixMapping calls with no element
                // event in between. If we wouldn't remove the items from the prefixList and uriList here,
                // the namespace would be incorrectly declared on the next element following the
                // endPrefixMapping call.
                int pos = prefixList.lastIndexOf(prefix);
                if (pos != -1) {
                    prefixList.remove(pos);
                    uriList.remove(pos);
                }
            }

            super.endPrefixMapping(prefix);
        }
16315#/**
         *
         */
        public void endDocument() throws SAXException {
            // Cleanup
            this.uriToPrefixMap.clear();
            this.prefixToUriMap.clear();
            clearMappings();
            super.endDocument();
        }
16316#private void clearMappings() {
            this.hasMappings = false;
            this.prefixList.clear();
            this.uriList.clear();
        }
16317#/**
     * Set the {@link OutputStream} where the requested resource should
     * be serialized.
     */
    public void setOutputStream(OutputStream out)
    throws IOException {
        this.output = out;
    }
16318#/**
     * Get the mime-type of the output of this <code>Serializer</code>
     */
    public String getMimeType() {
        return null;
    }
16319#/**
     * Recycle serializer by removing references
     */
    public void recycle() {
        super.recycle();
        this.output = null;
    }
16320#/**
     * Test if the component wants to set the content length
     */
    public boolean shouldSetContentLength() {
        return false;
    }
16321#/** Setup the transformer. */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters parameters)
            throws ProcessingException, SAXException, IOException {
        extractLevel = 0;
        prefixMap = new HashMap();
    }
16322#public void recycle() {
        this.extractLevel = 0;
        this.currentBuilder = null;
        this.prefixMap = null;
        super.recycle();
    }
16323#/**
     * Begin the scope of a prefix-URI Namespace mapping.
     *
     * @param prefix The Namespace prefix being declared.
     * @param uri The Namespace URI the prefix is mapped to.
     */
    public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
        if (extractLevel == 0) {
            super.startPrefixMapping(prefix,uri);
            prefixMap.put(prefix,uri);
        } else {
            this.currentBuilder.startPrefixMapping(prefix,uri);
        }
    }
16324#/**
     * End the scope of a prefix-URI mapping.
     *
     * @param prefix The prefix that was being mapping.
     */
    public void endPrefixMapping(String prefix)
    throws SAXException {
        if (extractLevel == 0) {
            super.endPrefixMapping(prefix);
            prefixMap.remove(prefix);
        } else {
            this.currentBuilder.endPrefixMapping(prefix);
        }
    }
16325#/**
     * Receive notification of the beginning of an element. Uses
     * startExtraction to determine whether to start
     * extracting. Nested triggering tags result in only one document.
     * * startExtractedDocument with the first node of the extracted
     * Document.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     * @param a The attributes attached to the element. If there are no
     *          attributes, it shall be an empty Attributes object.
     */
    public void startElement(String uri, String loc, String raw, Attributes a) throws SAXException {
        if (!startExtracting(uri, loc, raw, a)) {

            if (extractLevel == 0) {
                super.startElement(uri,loc,raw,a);
            } else {
                this.currentBuilder.startElement(uri,loc,raw,a);
            }

        } else {

            extractLevel++;
            if (this.getLogger().isDebugEnabled()) {
                getLogger().debug("extractLevel now " + extractLevel + ".");
            }

            if (extractLevel != 1) {
                this.currentBuilder.startElement(uri,loc,raw,a);
            } else {

                // setup new document
                this.currentBuilder = new DOMBuilder();
                this.currentBuilder.startDocument();
                // setup namespaces
                Iterator itt = prefixMap.entrySet().iterator();
                while (itt.hasNext()) {
                    Map.Entry entry = (Map.Entry)itt.next();
                    this.currentBuilder.startPrefixMapping(
                        (String)entry.getKey(),
                        (String)entry.getValue()
                    );
                }
                // start root node
                startExtractingDocument(uri, loc, raw, a);

            }

        }
    }
16326#/**
     * Receive notification of the end of an element. Uses
     * endExtraction to determine whether to stop extracting or
     * not. Calls endExtractedDocument with the extracted document.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     */
    public void endElement(String uri, String loc, String raw)
    throws SAXException {
        if (extractLevel == 0) {
            super.endElement(uri,loc,raw);
        } else {
            if (endExtracting(uri, loc, raw)) {
                extractLevel--;
                if (this.getLogger().isDebugEnabled()) {
                    getLogger().debug("extractLevel now " + extractLevel + ".");
                }

                if (extractLevel != 0) {
                    this.currentBuilder.endElement(uri,loc,raw);
                } else {

                    // end root element
                    endExtractingDocument(uri, loc, raw);
                    // finish building the document. remove existing prefix mappings.
                    Iterator itt = prefixMap.entrySet().iterator();
                    while (itt.hasNext()) {
                        Map.Entry entry = (Map.Entry) itt.next();
                        this.currentBuilder.endPrefixMapping(
                            (String)entry.getKey()
                        );
                    }
                    this.currentBuilder.endDocument();

                    handleExtractedDocument(this.currentBuilder.getDocument());

                    if (this.getLogger().isDebugEnabled()) {
                        getLogger().debug("Stored document.");
                    }

                }
            } else {
                this.currentBuilder.endElement(uri, loc, raw);
            }
        }
    }
16327#/**
     * Receive notification of character data.
     *
     * @param c The characters from the XML document.
     * @param start The start position in the array.
     * @param len The number of characters to read from the array.
     */
    public void characters(char c[], int start, int len)
    throws SAXException {
        if (extractLevel == 0) {
            super.characters(c,start,len);
        } else {
            this.currentBuilder.characters(c,start,len);
        }
    }
16328#/**
     * Receive notification of ignorable whitespace in element content.
     *
     * @param c The characters from the XML document.
     * @param start The start position in the array.
     * @param len The number of characters to read from the array.
     */
    public void ignorableWhitespace(char c[], int start, int len)
    throws SAXException {
        if (extractLevel == 0) {
            super.ignorableWhitespace(c,start,len);
        } else {
            this.currentBuilder.ignorableWhitespace(c,start,len);
        }
    }
16329#/**
     * Receive notification of a processing instruction.
     *
     * @param target The processing instruction target.
     * @param data The processing instruction data, or null if none was
     *             supplied.
     */
    public void processingInstruction(String target, String data)
    throws SAXException {
        if (extractLevel == 0) {
            super.processingInstruction(target,data);
        } else {
            this.currentBuilder.processingInstruction(target,data);
        }
    }
16330#/**
     * Receive notification of a skipped entity.
     *
     * @param name The name of the skipped entity.  If it is a  parameter
     *             entity, the name will begin with '%'.
     */
    public void skippedEntity(String name)
    throws SAXException {
        if (extractLevel == 0) {
            super.skippedEntity(name);
        } else {
            this.currentBuilder.skippedEntity(name);
        }
    }
16331#/**
     * Report the start of DTD declarations, if any.
     *
     * @param name The document type name.
     * @param publicId The declared public identifier for the external DTD
     *                 subset, or null if none was declared.
     * @param systemId The declared system identifier for the external DTD
     *                 subset, or null if none was declared.
     */
    public void startDTD(String name, String publicId, String systemId)
    throws SAXException {
        if (extractLevel == 0) {
            super.startDTD(name,publicId,systemId);
        } else {
            throw new SAXException(
                "Recieved startDTD after beginning fragment extraction process."
            );
        }
    }
16332#/**
     * Report the end of DTD declarations.
     */
    public void endDTD()
    throws SAXException {
        if (extractLevel == 0) {
            super.endDTD();
        } else {
            throw new SAXException(
                "Recieved endDTD after beginning fragment extraction process."
            );
        }
    }
16333#/**
     * Report the beginning of an entity.
     *
     * @param name The name of the entity. If it is a parameter entity, the
     *             name will begin with '%'.
     */
    public void startEntity(String name)
    throws SAXException {
        if (extractLevel == 0) {
            super.startEntity(name);
        } else {
            this.currentBuilder.startEntity(name);
        }
    }
16334#/**
     * Report the end of an entity.
     *
     * @param name The name of the entity that is ending.
     */
    public void endEntity(String name)
    throws SAXException {
        if (extractLevel == 0) {
            super.endEntity(name);
        } else {
            this.currentBuilder.endEntity(name);
        }
    }
16335#/**
     * Report the start of a CDATA section.
     */
    public void startCDATA()
    throws SAXException {
        if (extractLevel == 0) {
            super.startCDATA();
        } else {
            this.currentBuilder.startCDATA();
        }
    }
16336#/**
     * Report the end of a CDATA section.
     */
    public void endCDATA()
    throws SAXException {
        if (extractLevel == 0) {
            super.endCDATA();
        } else {
            this.currentBuilder.endCDATA();
        }
    }
16337#/**
     * Report an XML comment anywhere in the document.
     *
     * @param ch An array holding the characters in the comment.
     * @param start The starting position in the array.
     * @param len The number of characters to use from the array.
     */
    public void comment(char ch[], int start, int len)
    throws SAXException {
        if (extractLevel == 0) {
            super.comment(ch,start,len);
        } else {
            this.currentBuilder.comment(ch,start,len);
        }
    }
16338#/**
     * Receive notification of the beginning of an element and signal extraction start.
     * 
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     * @param a The attributes attached to the element. If there are no
     *          attributes, it shall be an empty Attributes object.
     * @return a <code>boolean</code> value to signal to start extracting
     */
    abstract boolean startExtracting(String uri, String loc, String raw, Attributes a);
16339#/**
     * Receive notification of the beginning of the extracted Document. Per default send
     * startElement message to document builder. Override if necessary. Must override 
     * {@link #endExtractingDocument(String, String, String)} as well. 
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     * @param a The attributes attached to the element. If there are no
     *          attributes, it shall be an empty Attributes object.
     */
    public void startExtractingDocument(String uri, String loc, String raw, Attributes a) throws SAXException{
        this.currentBuilder.startElement(uri,loc,raw,a);
    }
16340#/**
     * Receive notification of the end of an element and signal extraction end.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     * @return a <code>boolean</code> value to signal to stop extracting
     */
    abstract boolean endExtracting(String uri, String loc, String raw);
16341#/**
     * Receive notification of the end of the extracted Document. Per default, 
     * send endElement message to document builder. Override if necessary.
     * Must override
     * {@link #startExtractingDocument(String, String, String, Attributes)}
     * as well.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     */
    public void endExtractingDocument(String uri, String loc, String raw) throws SAXException{
        this.currentBuilder.endElement(uri,loc,raw);
    }
16342#/**
     * Receive notification of the end of the extracted Document.
     *
     * @param doc a <code>Document</code> value
     */
    abstract void handleExtractedDocument(Document doc);
16343#/**
     * @see org.apache.avalon.framework.service.Serviceable#service(ServiceManager)
     */
    public void service(ServiceManager aManager) throws ServiceException {
        this.manager = aManager;
    }
16344#/**
     * @see Configurable#configure(Configuration)
     */
    public void configure(Configuration configuration) throws ConfigurationException {
        String tFactoryClass = configuration.getChild("transformer-factory").getValue(null);
        if (tFactoryClass != null) {
            try {
                this.tfactory = (SAXTransformerFactory) ClassUtils.newInstance(tFactoryClass);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Using transformer factory " + tFactoryClass);
                }
            } catch (Exception e) {
                throw new ConfigurationException("Cannot load transformer factory " + tFactoryClass, e);
            }
        } else {
            // Standard TrAX behaviour
            this.tfactory = (SAXTransformerFactory) TransformerFactory.newInstance();
        }
        tfactory.setErrorListener(new TraxErrorHandler(getLogger()));
    }
16345#/**
     * @see org.apache.cocoon.sitemap.SitemapModelComponent#setup(SourceResolver, Map, String, Parameters)
     */
    public void setup(SourceResolver resolver,
                      Map            objectModel,
                      String         src,
                      Parameters     params)
    throws ProcessingException, SAXException, IOException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Setup resolver=" + resolver +
                              ", objectModel=" + objectModel +
                              ", src=" + src +
                              ", parameters=" + params);
        }

        // defaultNamespaceURI should never be null
        if (this.defaultNamespaceURI == null) {
            this.defaultNamespaceURI = "";
        }
        this.objectModel = objectModel;

        this.request = ObjectModelHelper.getRequest(objectModel);
        this.response = ObjectModelHelper.getResponse(objectModel);
        this.context = ObjectModelHelper.getContext(objectModel);
        this.resolver = resolver;
        this.parameters = params;
        this.source = src;
        this.isInitialized = false;

        // get the current namespace
        this.namespaceURI = params.getParameter("namespaceURI",
                                                this.defaultNamespaceURI);

        this.ignoreHooksCount = 0;
        this.ignoreEventsCount = 0;
        this.ignoreWhitespaces = true;
        this.ignoreEmptyCharacters = false;
    }
16346#/**
     * @see org.apache.avalon.excalibur.pool.Recyclable#recycle()
     */
    public void recycle() {
        this.namespaceURI = null;
        this.objectModel = null;
        this.request = null;
        this.response = null;
        this.context = null;
        this.resolver = null;
        this.stack.clear();
        this.recorderStack.clear();
        this.parameters = null;
        this.source = null;
        this.namespaces.clear();
        this.ourPrefix = null;

        super.recycle();
    }
16347#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        this.manager = null;
    }
16348#//
    // SAX ContentHandler methods
    //

    /**
     * Process the SAX event.
     * @see ContentHandler#setDocumentLocator
     */
    public void setDocumentLocator(Locator locator) {
        if (this.ignoreEventsCount == 0) {
            super.setDocumentLocator(locator);
        }
    }
16349#/**
     * Process the SAX event. A new document is processed. The hook method
     * {@link #setupTransforming} is invoked.
     * @see ContentHandler#startDocument
     */
    public void startDocument()
    throws SAXException {
        if (!this.isInitialized) {
            try {
                setupTransforming();
            } catch (ProcessingException e) {
                throw new SAXException("ProcessingException: " + e, e);
            } catch (IOException e) {
                throw new SAXException("IOException: " + e, e);
            }
            this.isInitialized = true;
        }

        if (this.ignoreEventsCount == 0) {
            super.startDocument();
        }
    }
16350#/**
     * Process the SAX event. The processing of the document is finished.
     * @see org.xml.sax.ContentHandler#endDocument
     */
    public void endDocument()
    throws SAXException {
        if (this.ignoreEventsCount == 0) {
            super.endDocument();
        }
    }
16351#/**
     * Process the SAX event.
     * @see org.xml.sax.ContentHandler#startPrefixMapping
     */
    public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
        boolean isOurPrefix = false;
        if (prefix != null) {
            this.namespaces.add(new String[] {prefix, uri});
        }
        if (namespaceURI.equals(uri)) {
            this.ourPrefix = prefix;
            isOurPrefix = true;
        }
        if (this.ignoreEventsCount == 0) {
            if ( !removeOurNamespacePrefixes || !isOurPrefix) {
                super.startPrefixMapping(prefix, uri);
            }
        }
    }
16352#/**
     * Process the SAX event.
     * @see org.xml.sax.ContentHandler#endPrefixMapping
     */
    public void endPrefixMapping(String prefix)
    throws SAXException {
        boolean isOurPrefix = false;
        if (prefix != null) {
            // Find and remove the namespace prefix
            boolean found = false;
            for (int i = this.namespaces.size() - 1; i >= 0; i--) {
                final String[] prefixAndUri = (String[]) this.namespaces.get(i);
                if (prefixAndUri[0].equals(prefix)) {
                    this.namespaces.remove(i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                throw new SAXException("Namespace for prefix '" + prefix + "' not found.");
            }

            if (prefix.equals(this.ourPrefix)) {
                isOurPrefix = true;
                // Reset our current prefix
                this.ourPrefix = null;

                // Now search if we have a different prefix for our namespace
                for (int i = this.namespaces.size() - 1; i >= 0; i--) {
                    final String[] prefixAndUri = (String[]) this.namespaces.get(i);
                    if (namespaceURI.equals(prefixAndUri[1])) {
                        this.ourPrefix = prefixAndUri[0];
                        break;
                    }
                }
            }
        }

        if (this.ignoreEventsCount == 0) {
            if ( !removeOurNamespacePrefixes || !isOurPrefix) {
                super.endPrefixMapping(prefix);
            }
        }
    }
16353#/**
     * Process the SAX event. The namespace of the event is checked.
     * If it is the defined namespace for this transformer,
     * the {@link #startTransformingElement} hook is called.
     * @see org.xml.sax.ContentHandler#startElement
     */
    public void startElement(String uri,
                             String name,
                             String raw,
                             Attributes attr)
    throws SAXException {
        if (namespaceURI.equals(uri) && ignoreHooksCount == 0) {
            // this is our namespace:
            try {
                startTransformingElement(uri, name, raw, attr);
            } catch (ProcessingException e) {
                throw new SAXException("ProcessingException: " + e, e);
            } catch (IOException e) {
                throw new SAXException("IOException occured during processing: " + e, e);
            }
        } else {
            if (ignoreEventsCount == 0) {
                super.startElement(uri, name, raw, attr);
            }
        }
    }
16354#/**
     * Process the SAX event. The namespace of the event is checked.
     * If it is the defined namespace for this transformer,
     * the {@link #endTransformingElement} hook is called.
     * @see org.xml.sax.ContentHandler#endElement
     */
    public void endElement(String uri, String name, String raw)
    throws SAXException {
        if (namespaceURI.equals(uri) && this.ignoreHooksCount == 0) {
            // this is our namespace:
            try {
                endTransformingElement(uri, name, raw);
            } catch (ProcessingException e) {
                throw new SAXException("ProcessingException: " + e, e);
            } catch (IOException e) {
                throw new SAXException("IOException occured during processing: " + e, e);
            }
        } else {
            if (ignoreEventsCount == 0) {
                super.endElement(uri, name, raw);
            }
        }
    }
16355#/**
     * Process the SAX event.
     * @see org.xml.sax.ContentHandler#characters
     */
    public void characters(char[] p0, int p1, int p2)
    throws SAXException {
        if (this.ignoreEventsCount == 0) {
            if (this.ignoreEmptyCharacters) {
                String value = new String(p0, p1, p2);
                if (value.trim().length() > 0) {
                    super.characters(p0, p1, p2);
                }
            } else {
                super.characters(p0, p1, p2);
            }
        }
    }
16356#/**
     * Process the SAX event.
     * @see org.xml.sax.ContentHandler#ignorableWhitespace
     */
    public void ignorableWhitespace(char[] p0, int p1, int p2)
    throws SAXException {
        if (!ignoreWhitespaces && ignoreEventsCount == 0) {
            super.ignorableWhitespace(p0, p1, p2);
        }
    }
16357#/**
     * Process the SAX event.
     * @see ContentHandler#processingInstruction
     */
    public void processingInstruction(String target, String data)
    throws SAXException {
        if (this.ignoreEventsCount == 0) {
            super.processingInstruction(target, data);
        }
    }
16358#/**
     * Process the SAX event.
     * @see ContentHandler#skippedEntity
     */
    public void skippedEntity(String name)
    throws SAXException {
        if (this.ignoreEventsCount == 0) {
            super.skippedEntity(name);
        }
    }
16359#//
    // SAX LexicalHandler methods
    //

    /**
     * @see LexicalHandler#startDTD
     */
    public void startDTD(String name, String public_id, String system_id)
    throws SAXException {
        if (this.ignoreEventsCount == 0) {
            super.startDTD(name, public_id, system_id);
        }
    }
16360#/**
     * @see LexicalHandler#endDTD
     */
    public void endDTD() throws SAXException {
        if (this.ignoreEventsCount == 0) {
            super.endDTD();
        }
    }
16361#/**
     * @see LexicalHandler#startEntity
     */
    public void startEntity (String name)
    throws SAXException {
        if (this.ignoreEventsCount == 0) {
            super.startEntity(name);
        }
    }
16362#/**
     * @see LexicalHandler#endEntity
     */
    public void endEntity (String name)
    throws SAXException {
        if (this.ignoreEventsCount == 0) {
            super.endEntity(name);
        }
    }
16363#/**
     * @see LexicalHandler#startCDATA
     */
    public void startCDATA() throws SAXException {
        if (this.ignoreEventsCount == 0) {
            super.startCDATA();
        }
    }
16364#/**
     * @see LexicalHandler#endCDATA
     */
    public void endCDATA() throws SAXException {
        if (this.ignoreEventsCount == 0) {
            super.endCDATA();
        }
    }
16365#/**
     * @see LexicalHandler#comment
     */
    public void comment(char ary[], int start, int length)
    throws SAXException {
        if (this.ignoreEventsCount == 0) {
            super.comment(ary, start, length);
        }
    }
16366#/**
     * Add a new recorder to the recording chain.
     * Do not invoke this method directly.
     */
    protected void addRecorder(XMLConsumer recorder) {
        if (this.recorderStack.empty()) {
            // redirect if first (top) recorder
            this.originalLexicalHandler = this.lexicalHandler;
            this.originalContentHandler = this.contentHandler;
        }
        setContentHandler(recorder);
        setLexicalHandler(recorder);
        this.recorderStack.push(recorder);
    }
16367#/**
     * Remove a recorder from the recording chain.
     * Do not invoke this method directly.
     */
    protected Object removeRecorder() {
        Object recorder = this.recorderStack.pop();
        if (this.recorderStack.empty()) {
            // undo redirect if no recorder any more
            setContentHandler(originalContentHandler);
            setLexicalHandler(originalLexicalHandler);
            this.originalLexicalHandler = null;
            this.originalContentHandler = null;
        } else {
            XMLConsumer next = (XMLConsumer) recorderStack.peek();
            setContentHandler(next);
            setLexicalHandler(next);
        }

        return recorder;
    }
16368#/**
     * Start recording of SAX events.
     * All incoming events are recorded and not forwarded. The resulting
     * XMLizable can be obtained by the matching {@link #endSAXRecording} call.
     * @since 2.1.5
     */
    public void startSAXRecording()
    throws SAXException {
        addRecorder(new SaxBuffer());
        sendStartPrefixMapping();
    }
16369#/**
     * Stop recording of SAX events.
     * This method returns the resulting XMLizable.
     * @since 2.1.5
     */
    public XMLizable endSAXRecording()
    throws SAXException {
        sendEndPrefixMapping();
        return (XMLizable) removeRecorder();
    }
16370#/**
     * Start recording of a text.
     * No events forwarded, and all characters events
     * are collected into a string.
     */
    public void startTextRecording()
    throws SAXException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Start text recording");
        }
        addRecorder(new TextRecorder());
        sendStartPrefixMapping();
    }
16371#/**
     * Stop recording of text and return the recorded information.
     * @return The String, trimmed.
     */
    public String endTextRecording()
    throws SAXException {
        sendEndPrefixMapping();

        TextRecorder recorder = (TextRecorder) removeRecorder();
        String text = recorder.getText();
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("End text recording. Text=" + text);
        }
        return text;
    }
16372#/**
     * Start recording of serialized xml
     * All events are converted to an xml string which can be retrieved by
     * endSerializedXMLRecording.
     * @param format The format for the serialized output. If <CODE>null</CODE>
     *               is specified, the default format is used.
     */
    public void startSerializedXMLRecording(Properties format)
    throws SAXException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Start serialized XML recording. Format=" + format);
        }
        this.stack.push(format == null? XMLUtils.createPropertiesForXML(false): format);
        startSAXRecording();
    }
16373#/**
     * Return the serialized xml string.
     * @return A string containing the recorded xml information, formatted by
     * the properties passed to the corresponding startSerializedXMLRecording().
     */
    public String endSerializedXMLRecording()
    throws SAXException, ProcessingException {
        XMLizable xml = endSAXRecording();
        String text = XMLUtils.serialize(xml, (Properties) this.stack.pop());
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("End serialized XML recording. XML=" + text);
        }
        return text;
    }
16374#/**
     * Start recording of parameters.
     * All events are not forwarded and the incoming xml is converted to
     * parameters. Each toplevel node is a parameter and its text subnodes
     * form the value.
     * The Parameters can eiter be retrieved by endParametersRecording().
     */
    public void startParametersRecording()
    throws SAXException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Start parameters recording");
        }
        addRecorder(new ParametersRecorder());
        sendStartPrefixMapping();
    }
16375#/**
     * End recording of parameters
     * If source is null a new parameters object is created, otherwise
     * the parameters are added to this object.
     * @param additionalParameters An optional parameters object.
     * @return The object containing all parameters.
     */
    public SourceParameters endParametersRecording(Parameters additionalParameters)
    throws SAXException {
        sendEndPrefixMapping();

        final ParametersRecorder recorder = (ParametersRecorder) this.removeRecorder();
        final SourceParameters sourceParameters = recorder.getParameters(additionalParameters);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("End parameters recording. Parameters=" + sourceParameters);
        }
        return sourceParameters;
    }
16376#/**
     * End recording of parameters
     * If source is null a new parameters object is created, otherwise
     * the parameters are added to this object.
     * @param additionalParameters An optional parameters object.
     * @return The object containing all parameters.
     */
    public SourceParameters endParametersRecording(SourceParameters additionalParameters)
    throws SAXException {
        sendEndPrefixMapping();

        final ParametersRecorder recorder = (ParametersRecorder) removeRecorder();
        final SourceParameters sourceParameters = recorder.getParameters(additionalParameters);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("End parameters recording. Parameters=" + sourceParameters);
        }
        return sourceParameters;
    }
16377#/**
     * Start DOM DocumentFragment recording.
     * All incoming events are recorded and not forwarded. The resulting
     * DocumentFragment can be obtained by the matching {@link #endRecording} call.
     */
    public void startRecording()
    throws SAXException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Start recording");
        }
        DOMBuilder builder = new DOMBuilder(this.tfactory);
        addRecorder(builder);
        builder.startDocument();
        builder.startElement("", "cocoon", "cocoon", EMPTY_ATTRIBUTES);
        sendStartPrefixMapping();
    }
16378#/**
     * Stop DOM DocumentFragment recording.
     * This method returns the resulting DocumentFragment, normalized.
     */
    public DocumentFragment endRecording()
    throws SAXException {
        sendEndPrefixMapping();

        DOMBuilder builder = (DOMBuilder) removeRecorder();
        builder.endElement("", "cocoon", "cocoon");
        builder.endDocument();

        // Create Document Fragment
        final Document doc = builder.getDocument();
        final DocumentFragment fragment = doc.createDocumentFragment();
        final Node root = doc.getDocumentElement();

        // Remove empty text nodes and collapse neighbouring text nodes
        root.normalize();

        // Move all nodes into the fragment
        boolean space = true;
        while (root.hasChildNodes()) {
            Node child = root.getFirstChild();
            root.removeChild(child);

            // Leave out leading whitespace nodes
            // FIXME: Why leading spaces are trimmed at all? Why not trailing spaces?
            if (space && child.getNodeType() == Node.TEXT_NODE
                    && child.getNodeValue().trim().length() == 0) {
                continue;
            }
            space = false;

            fragment.appendChild(child);
        }

        if (getLogger().isDebugEnabled()) {
            Object serializedXML;
            try {
                serializedXML = fragment == null? "null": XMLUtils.serializeNode(fragment);
            } catch (ProcessingException ignore) {
                serializedXML = fragment;
            }
            getLogger().debug("End recording. Fragment=" + serializedXML);
        }

        return fragment;
    }
16379#//
    // Hooks
    //

    /**
     * Setup the transformation of an xml document.
     * This method is called just before the transformation (sending of sax events)
     * starts. It should be used to initialize setup parameter depending on the
     * object modell.
     */
    public void setupTransforming()
    throws IOException, ProcessingException, SAXException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("setupTransforming");
        }
        this.stack.clear();
        this.recorderStack.clear();
        this.ignoreWhitespaces = true;
        this.ignoreEmptyCharacters = false;
    }
16380#/**
     * Start processing elements of our namespace.
     * This hook is invoked for each sax event with our namespace.
     * @param uri The namespace of the element.
     * @param name The local name of the element.
     * @param raw The qualified name of the element.
     * @param attr The attributes of the element.
     */
    public void startTransformingElement(String uri,
                                         String name,
                                         String raw,
                                         Attributes attr)
    throws ProcessingException, IOException, SAXException {
        if (this.ignoreEventsCount == 0) {
            super.startElement(uri, name, raw, attr);
        }
    }
16381#/**
     * Start processing elements of our namespace.
     * This hook is invoked for each sax event with our namespace.
     * @param uri The namespace of the element.
     * @param name The local name of the element.
     * @param raw The qualified name of the element.
     */
    public void endTransformingElement(String uri,
                                       String name,
                                       String raw)
    throws ProcessingException, IOException, SAXException {
        if (this.ignoreEventsCount == 0) {
            super.endElement(uri, name, raw);
        }
    }
16382#/**
     * Send SAX events to the next pipeline component.
     * The characters event for the given text is send to the next
     * component in the current pipeline.
     * @param text The string containing the information.
     */
    public void sendTextEvent(String text)
    throws SAXException {
        characters(text.toCharArray(), 0, text.length());
    }
16383#/**
     * Send SAX events to the next pipeline component.
     * The startElement event for the given element is send
     * to the next component in the current pipeline.
     * The element has no namespace and no attributes
     * @param localname The name of the event.
     */
    public void sendStartElementEvent(String localname)
    throws SAXException {
        startElement("", localname, localname, EMPTY_ATTRIBUTES);
    }
16384#/**
     * Send SAX events to the next pipeline component.
     * The startElement event for the given element is send
     * to the next component in the current pipeline.
     * The element has the namespace of the transformer,
     * but not attributes
     * @param localname The name of the event.
     */
    public void sendStartElementEventNS(String localname)
    throws SAXException {
        startElement(this.namespaceURI,
                     localname, this.ourPrefix + ':' + localname, EMPTY_ATTRIBUTES);
    }
16385#/**
     * Send SAX events to the next pipeline component.
     * The startElement event for the given element is send
     * to the next component in the current pipeline.
     * The element has no namespace.
     * @param localname The name of the event.
     * @param attr The Attributes of the element
     */
    public void sendStartElementEvent(String localname, Attributes attr)
    throws SAXException {
        startElement("", localname, localname, attr);
    }
16386#/**
     * Send SAX events to the next pipeline component.
     * The startElement event for the given element is send
     * to the next component in the current pipeline.
     * The element has the namespace of the transformer.
     * @param localname The name of the event.
     * @param attr The Attributes of the element
     */
    public void sendStartElementEventNS(String localname, Attributes attr)
    throws SAXException {
        startElement(this.namespaceURI,
                     localname, this.ourPrefix + ':' + localname, attr);
    }
16387#/**
     * Send SAX events to the next pipeline component.
     * The endElement event for the given element is send
     * to the next component in the current pipeline.
     * The element has no namespace.
     * @param localname The name of the event.
     */
    public void sendEndElementEvent(String localname)
    throws SAXException {
        endElement("", localname, localname);
    }
16388#/**
     * Send SAX events to the next pipeline component.
     * The endElement event for the given element is send
     * to the next component in the current pipeline.
     * The element has the namespace of the transformer.
     * @param localname The name of the event.
     */
    public void sendEndElementEventNS(String localname)
    throws SAXException {
        endElement(this.namespaceURI,
                   localname, this.ourPrefix + ':' + localname);
    }
16389#/**
     * Send SAX events to the next pipeline component.
     * The node is parsed and the events are send to
     * the next component in the pipeline.
     * @param node The tree to be included.
     */
    public void sendEvents(Node node)
    throws SAXException {
        IncludeXMLConsumer.includeNode(node, this, this);
    }
16390#/**
     * Send SAX events for the <code>SourceParameters</code>.
     * For each parametername/value pair an element is
     * created with the name of the parameter and the content
     * of this element is the value.
     */
    public void sendParametersEvents(SourceParameters pars)
    throws SAXException {
        if (pars != null) {
            Iterator names = pars.getParameterNames();
            while (names.hasNext()) {
                final String currentName = (String)names.next();
                Iterator values = pars.getParameterValues(currentName);
                while (values.hasNext()) {
                    final String currentValue = (String)values.next();
                    sendStartElementEvent(currentName);
                    sendTextEvent(currentValue);
                    sendEndElementEvent(currentName);
                }
            }
        }
    }
16391#/**
     * Send all start prefix mapping events to the current content handler
     */
    protected void sendStartPrefixMapping()
    throws SAXException {
        final int l = this.namespaces.size();
        for (int i = 0; i < l; i++) {
            String[] prefixAndUri = (String[]) this.namespaces.get(i);
            super.contentHandler.startPrefixMapping(prefixAndUri[0], prefixAndUri[1]);
        }
    }
16392#/**
     * Send all end prefix mapping events to the current content handler
     */
    protected void sendEndPrefixMapping()
    throws SAXException {
        final int l = this.namespaces.size();
        for (int i = 0; i < l; i++) {
            String[] prefixAndUri = (String[]) this.namespaces.get(i);
            super.contentHandler.endPrefixMapping(prefixAndUri[0]);
        }
    }
16393#/**
     * Find prefix mapping for the given namespace URI.
     * @return Prefix mapping or null if no prefix defined
     */
    protected String findPrefixMapping(String uri) {
        final int l = this.namespaces.size();
        for (int i = 0; i < l; i++) {
            String[] prefixAndUri = (String[]) this.namespaces.get(i);
            if (prefixAndUri[1].equals(uri)) {
                return prefixAndUri[0];
            }
        }

        return null;
    }
16394#/**
     * Helper method to get a modifiable attribute set.
     */
    protected AttributesImpl getMutableAttributes(Attributes a) {
        if ( a instanceof AttributesImpl && !(a instanceof ImmutableAttributesImpl)) {
            return (AttributesImpl)a;
        }
        return new AttributesImpl(a);
    }
16395#public AbstractDOMTransformer() {
        this.builder = new DOMBuilder(this);
    }
16396#/**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager aManager) throws ServiceException {
        this.manager = aManager;
    }
16397#/**
     * Set the <code>SourceResolver</code>, objectModel <code>Map</code>,
     * the source and sitemap <code>Parameters</code> used to process the request.
     *
     * If you wish to process the parameters, override this method, call
     * <code>super()</code> and then add your code.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
            throws ProcessingException, SAXException, IOException {

        this.resolver = resolver;
        this.objectModel = objectModel;
        this.source = src;
        this.parameters = par;
    }
16398#/**
     * Recycle the component.
     */
    public void recycle() {
        this.resolver = null;
        this.source = null;
        this.objectModel = null;
        this.parameters = null;
        this.builder.recycle();
        super.recycle();
    }
16399#/* (non-Javadoc)
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        this.builder = null;
        this.manager = null;
    }
16400#/**
     * This method is called when the Document is finished.
     * @param doc The DOM Document object representing this SAX stream
     * @see org.apache.cocoon.xml.dom.DOMBuilder.Listener
     */
    public void notify(Document doc) throws SAXException {
        // Call the user's transform method
        Document newdoc = transform(doc);

        // Now we stream the resulting DOM tree down the pipe
        DOMStreamer s = new DOMStreamer(contentHandler, lexicalHandler);
        s.stream(newdoc);
    }
16401#/**
     * Transform the specified DOM, returning a new DOM to stream down the pipeline.
     * @param doc The DOM Document representing the SAX stream
     * @return A DOM Document to stream down the pipeline
     */
    protected abstract Document transform(Document doc);
16402#//
    // SAX Methods. Send incoming SAX events to the DOMBuilder.
    //

    public void setDocumentLocator(Locator locator) {
        builder.setDocumentLocator(locator);
    }
16403#public void startDocument() throws SAXException {
        builder.startDocument();
    }
16404#public void endDocument() throws SAXException {
        builder.endDocument();
    }
16405#public void startPrefixMapping(String prefix, String uri) throws SAXException {
        builder.startPrefixMapping(prefix, uri);
    }
16406#public void endPrefixMapping(String prefix) throws SAXException {
        builder.endPrefixMapping(prefix);
    }
16407#public void startElement(String uri, String loc, String raw, Attributes a)
            throws SAXException {
        builder.startElement(uri, loc, raw, a);
    }
16408#public void endElement(String uri, String loc, String raw)
            throws SAXException {
        builder.endElement(uri, loc, raw);
    }
16409#public void characters(char c[], int start, int len)
            throws SAXException {
        builder.characters(c, start, len);
    }
16410#public void ignorableWhitespace(char c[], int start, int len)
            throws SAXException {
        builder.ignorableWhitespace(c, start, len);
    }
16411#public void processingInstruction(String target, String data)
            throws SAXException {
        builder.processingInstruction(target, data);
    }
16412#public void skippedEntity(String name)
            throws SAXException {
        builder.skippedEntity(name);
    }
16413#public void startDTD(String name, String publicId, String systemId)
            throws SAXException {
        builder.startDTD(name, publicId, systemId);
    }
16414#public void endDTD()
            throws SAXException {
        builder.endDTD();
    }
16415#public void startEntity(String name)
            throws SAXException {
        builder.startEntity(name);
    }
16416#public void endEntity(String name)
            throws SAXException {
        builder.endEntity(name);
    }
16417#public void startCDATA()
            throws SAXException {
        builder.startCDATA();
    }
16418#public void endCDATA()
            throws SAXException {
        builder.endCDATA();
    }
16419#public void comment(char ch[], int start, int len)
            throws SAXException {
        builder.comment(ch, start, len);
    }
16420#/**
     * Set the <code>SourceResolver</code>, object model <code>Map</code>,
     * the source and sitemap <code>Parameters</code> used to process the request.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        this.resolver = resolver;
        this.objectModel = objectModel;
        this.source = src;
        this.parameters = par;
    }
16421#/**
     * Recycle the generator by removing references
     */
    public void recycle() {
        super.recycle();
        this.resolver = null;
        this.objectModel = null;
        this.source = null;
        this.parameters = null;
    }
16422#/* (non-Javadoc)
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager aManager) throws ServiceException {
        this.manager = aManager;
    }
16423#/* (non-Javadoc)
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        this.manager = null;
    }
16424#public NOPRecorder() {
    }
16425#public void setDocumentLocator(Locator locator) {
    }
16426#public void startDocument()
    throws SAXException {
    }
16427#public void endDocument()
    throws SAXException {
    }
16428#public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
    }
16429#public void endPrefixMapping(String prefix)
    throws SAXException {
    }
16430#public void startElement(String namespace, String name, String raw,
                         Attributes attr)
    throws SAXException {
    }
16431#public void endElement(String namespace, String name, String raw)
    throws SAXException {
    }
16432#public void characters(char ary[], int start, int length)
    throws SAXException {
    }
16433#public void ignorableWhitespace(char ary[], int start, int length)
    throws SAXException {
    }
16434#public void processingInstruction(String target, String data)
    throws SAXException {
    }
16435#public void skippedEntity(String name)
    throws SAXException {
    }
16436#public void startDTD(String name, String public_id, String system_id)
    throws SAXException {
    }
16437#public void endDTD() throws SAXException {
    }
16438#public void startEntity(String name) throws SAXException {
    }
16439#public void endEntity(String name) throws SAXException {
    }
16440#public void startCDATA() throws SAXException {
    }
16441#public void endCDATA() throws SAXException {
    }
16442#public void comment(char ary[], int start, int length)
    throws SAXException {
    }
16443#public TextRecorder() {
        super();
        this.buffer = new StringBuffer();
    }
16444#public void characters(char ary[], int start, int length) {
        this.buffer.append(ary, start, length);
    }
16445#/**
     * @return Recorded text so far, trimmed.
     */
    public String getText() {
        return this.buffer.toString().trim();
    }
16446#/**
     * If source is null a new Parameters object is created
     * Otherwise they are joined.
     */
    public ParametersRecorder() {
        super();
        this.parameters = new SourceParameters();
    }
16447#public SourceParameters getParameters(Parameters source) {
        if (source != null) {
            String[] names = source.getNames();
            for(int i=0; i<names.length; i++) {
                final String currentParameterName = names[i];
                this.parameters.setParameter(currentParameterName, source.getParameter(currentParameterName, ""));
            }
        }
        return parameters;
    }
16448#public SourceParameters getParameters(SourceParameters source) {
        if (source != null) {
            Iterator iter = source.getParameterNames();
            Iterator valuesIter;
            String value, parName;
            while (iter.hasNext() == true) {
                parName = (String)iter.next();
                valuesIter = source.getParameterValues(parName);
                while (valuesIter.hasNext() == true) {
                    value = (String)valuesIter.next();
                    this.parameters.setParameter(parName, value);
                }
            }
        }
        return parameters;
    }
16449#public void startElement(String namespace, String name, String raw,
                         Attributes attr)
    throws SAXException {
        if (this.key == null) {
            this.key = name;
            this.buffer = new StringBuffer();
        }
    }
16450#public void endElement(String namespace, String name, String raw)
    throws SAXException {
        if (this.key != null && this.key.equals(name) == true) {
            String value = this.buffer.toString().trim();
            if (value.length() > 0) {
                this.parameters.setParameter(this.key, value);
            }
            this.buffer = null;
            this.key = null;
        }
    }
16451#public void characters(char ary[], int start, int length)
    throws SAXException {
        if (this.key != null && this.buffer != null) {
            String value = new String(ary, start, length).trim();
            if (value.length() > 0) {
                buffer.append(value);
            } else {
                buffer.append(' ');
            }
        }
    }
16452#/**
     * Set the <code>XMLConsumer</code> that will receive XML data.
     *
     * <p>This method will call <code>setContentHandler(consumer)</code>
     * and <code>setLexicalHandler(consumer)</code> since {@link XMLConsumer}
     * interface implements both {@link ContentHandler} and {@link LexicalHandler}.
     *
     * @param consumer xml consumer, should never be null.
     */
    public void setConsumer(XMLConsumer consumer) {
        this.xmlConsumer = consumer;
        setContentHandler(consumer);
        setLexicalHandler(consumer);
    }
16453#/**
     * Set the <code>ContentHandler</code> that will receive XML data.
     *
     * <p>Subclasses may retrieve this <code>ContentHandler</code> instance
     * accessing the protected <code>super.contentHandler</code> field.
     *
     * @param handler content handler, should never be null.
     */
    public void setContentHandler(ContentHandler handler) {
        this.contentHandler = handler;
    }
16454#/**
     * Set the <code>LexicalHandler</code> that will receive XML data.
     *
     * <p>Subclasses may retrieve this <code>LexicalHandler</code> instance
     * accessing the protected <code>super.lexicalHandler</code> field.
     *
     * @param handler lexical handler, should never be null.
     */
    public void setLexicalHandler(LexicalHandler handler) {
        this.lexicalHandler = handler;
    }
16455#/**
     * Recycle the producer by removing references, and resetting handlers to
     * null (empty) implementations.
     */
    public void recycle() {
        this.xmlConsumer = null;
        this.contentHandler = EMPTY_CONTENT_HANDLER;
        this.lexicalHandler = DefaultLexicalHandler.NULL_HANDLER;
    }
16456#public XMLBaseSupport(SourceResolver resolver, Log logger) {
        this.resolver = resolver;
        this.logger = logger;
    }
16457#public void setDocumentLocation(String loc) throws SAXException {
        // -2 is used as level to avoid this BaseInfo to be ever popped of the stack
        bases.push(new BaseInfo(loc, -2));
    }
16458#public void startElement(String namespaceURI, String localName, String qName, Attributes attrs) throws SAXException {
        level++;
        String base = attrs.getValue(XMLBASE_NAMESPACE_URI, XMLBASE_ATTRIBUTE);
        if (base != null) {
            Source baseSource = null;
            String baseUrl;
            try {
                baseSource = resolve(getCurrentBase(), base);
                baseUrl = baseSource.getURI();
            } finally {
                if (baseSource != null) {
                    resolver.release(baseSource);
                }
            }
            bases.push(new BaseInfo(baseUrl, level));
        }
    }
16459#public void endElement(String namespaceURI, String localName, String qName) {
        if (getCurrentBaseLevel() == level)
            bases.pop();
        level--;
    }
16460#/**
     * Warning: do not forget to release the source returned by this method.
     */
    private Source resolve(String baseURI, String location) throws SAXException {
        try {
            Source source;
            if (baseURI != null) {
                source = resolver.resolveURI(location, baseURI, Collections.EMPTY_MAP);
            } else {
                source = resolver.resolveURI(location);
            }
            if (logger.isDebugEnabled()) {
                logger.debug("XMLBaseSupport: resolved location " + location +
                             " against base URI " + baseURI + " to " + source.getURI());
            }
            return source;
        } catch (IOException e) {
            throw new SAXException("XMLBaseSupport: problem resolving uri.", e);
        }
    }
16461#/**
     * Makes the given path absolute based on the current base URL. Do not forget to release
     * the returned source object!
     * @param spec any URL (relative or absolute, containing a scheme or not)
     */
    public Source makeAbsolute(String spec) throws SAXException {
        return resolve(getCurrentBase(), spec);
    }
16462#private String getCurrentBase() {
        if (bases.size() > 0) {
            BaseInfo baseInfo = (BaseInfo)bases.peek();
            return baseInfo.getUrl();
        }
        return null;
    }
16463#private int getCurrentBaseLevel() {
        if (bases.size() > 0) {
            BaseInfo baseInfo = (BaseInfo)bases.peek();
            return baseInfo.getLevel();
        }
        return -1;
    }
16464#public BaseInfo(String url, int level) {
            this.url = url;
            this.level = level;
        }
16465#public String getUrl() {
            return url;
        }
16466#public int getLevel() {
            return level;
        }
16467#// FIXME: parent parameter not used anymore
    // Using parent because some dom implementations like jtidy are bugged,
    // cannot get parent or delete child
    public static void stripDuplicateAttributes(Node node, Node parent) {

        // The output depends on the type of the node
        switch(node.getNodeType()) {
        case Node.DOCUMENT_NODE: {
            Document doc = (Document)node;
            Node child = doc.getFirstChild();
            while(child != null) {
                stripDuplicateAttributes(child, node);
                child = child.getNextSibling();
            }
            break;
        }

        case Node.ELEMENT_NODE: {
            Element elt = (Element) node;
            NamedNodeMap attrs = elt.getAttributes();

            ArrayList nodesToRemove = new ArrayList();
            int nodesToRemoveNum = 0;

            for (int i = 0; i < attrs.getLength(); i++) {
                final Node a = attrs.item(i);

                for (int j = 0; j < attrs.getLength(); j++) {
                    final Node b = attrs.item(j);

                    //if there are two attributes with same name
                    if (i != j && (a.getNodeName().equals(b.getNodeName()))) {
                        nodesToRemove.add(b);
                        nodesToRemoveNum++;
                    }
                }
            }

            for (int i = 0; i < nodesToRemoveNum; i++) {
                Attr nodeToDelete = (Attr) nodesToRemove.get(i);
                Element nodeToDeleteParent = (Element) node; // nodeToDelete.getParentNode();
                nodeToDeleteParent.removeAttributeNode(nodeToDelete);
            }

            nodesToRemove.clear();

            Node child = elt.getFirstChild();
            while (child != null) {
                stripDuplicateAttributes(child, node);
                child = child.getNextSibling();
            }

            break;
        }

        default:
            //do nothing
            break;
        }
    }
16468#/**
     * Get an <code>XMLConsumer</code> from a <code>ContentHandler</code> and
     * a <code>LexicalHandler</code>. If the content handler is already an
     * <code>XMLConsumer</code>, it is returned as is, otherwise it is wrapped
     * in an <code>XMLConsumer</code> with the lexical handler.
     *
     * @param ch the content handler, which should not be <code>null</code>
     * @param lh the lexical handler, which can be <code>null</code>
     * @return an <code>XMLConsumer</code> for <code>ch</code> an <code>lh</code>
     */
    public static XMLConsumer getConsumer(ContentHandler ch, LexicalHandler lh) {
        if (ch instanceof XMLConsumer) {
            return (XMLConsumer)ch;
        } else {
            if (lh == null && ch instanceof LexicalHandler) {
                lh = (LexicalHandler)ch;
            }
            return new ContentHandlerWrapper(ch, lh);
        }
    }
16469#/**
     * Get an <code>XMLConsumer</code> from <code>ContentHandler</code>. If the
     * content handler is already an <code>XMLConsumer</code>, it is returned as
     * is, otherwise it is wrapped in an <code>XMLConsumer</code>.
     *
     * @param ch the content handler, which should not be <code>null</code>
     * @return an <code>XMLConsumer</code> for <code>ch</code>
     */
    public static XMLConsumer getConsumer(ContentHandler ch) {
        return getConsumer(ch, null);
    }
16470#/**
     * Method for static initializer
     */
    private static Properties createDefaultPropertiesForXML(boolean omitXMLDeclaration) {
        final Properties format = new Properties();
        format.put(OutputKeys.METHOD, "xml");
        format.put(OutputKeys.OMIT_XML_DECLARATION, (omitXMLDeclaration ? "yes" : "no"));
        format.put(OutputKeys.INDENT, "yes");
        return format;
    }
16471#/**
     * Create a new properties set for serializing xml.
     * The omit xml declaration property can be controlled by the flag.
     *
     * <ul>
     * <li>Method: xml
     * <li>Omit xml declaration: according to the flag
     * <li>Indent: yes
     * </ul>
     */
    public static Properties createPropertiesForXML(boolean omitXMLDeclaration) {
        /* Properties passed as parameters to the Properties constructor become "default properties".
            But Xalan does not use the default properties, so they are lost.
            Therefore, we must promote them to "set properties".
         */
         Properties propertiesForXML = new Properties(omitXMLDeclaration? XML_FORMAT_NODECL: XML_FORMAT);
         for (Enumeration e = propertiesForXML.propertyNames(); e.hasMoreElements(); ) {
             String propertyName = (String)e.nextElement();
             propertiesForXML.setProperty(propertyName, propertiesForXML.getProperty(propertyName, ""));
         }
         return propertiesForXML;
    }
16472#/**
     * Serialize a DOM node into a string using format created by
     * <code>createPropertiesForXML(false)</code>.
     *
     * @see #createPropertiesForXML
     */
    public static String serializeNode(Node node)
    throws ProcessingException {
        // Don't create new properties as we do not intend to modify defaults.
        return serializeNode(node, XML_FORMAT);
    }
16473#/**
     * Serialize a DOM node into a string.
     * If the node is null the empty string is returned.
     *
     * @param format The format of the output to be used by SAX transformer.
     * @see OutputKeys
     */
    public static String serializeNode(Node node, Properties format)
    throws ProcessingException {

        try {
            if (node == null) {
                return "";
            }

            StringWriter writer = new StringWriter();
            TransformerHandler transformerHandler;
            transformerHandler = FACTORY.newTransformerHandler();
            transformerHandler.getTransformer().setOutputProperties(format);
            transformerHandler.setResult(new StreamResult(writer));
            if (node.getNodeType() != Node.DOCUMENT_NODE) {
                transformerHandler.startDocument();
            }
            DOMStreamer domStreamer = new DOMStreamer(transformerHandler, transformerHandler);
            domStreamer.stream(node);
            if (node.getNodeType() != Node.DOCUMENT_NODE) {
                transformerHandler.endDocument();
            }

            return writer.toString();
        } catch (TransformerException e) {
            throw new ProcessingException("TransformerException: " + e, e);
        } catch (SAXException e) {
            throw new ProcessingException("SAXException while streaming DOM node to SAX: " + e, e);
        }
    }
16474#/**
     * Serialize a XMLizable into a string.
     * If the object is null the empty string is returned.
     *
     * @param format The format of the output to be used by SAX transformer.
     * @see OutputKeys
     */
    public static String serialize(org.apache.excalibur.xml.sax.XMLizable xml, Properties format)
    throws ProcessingException {
        
        try {
            if (xml == null) {
                return "";
            }

            StringWriter writer = new StringWriter();
            TransformerHandler transformerHandler;
            transformerHandler = FACTORY.newTransformerHandler();
            transformerHandler.getTransformer().setOutputProperties(format);
            transformerHandler.setResult(new StreamResult(writer));
            transformerHandler.startDocument();
            xml.toSAX(new EmbeddedXMLPipe(transformerHandler));
            transformerHandler.endDocument();

            return writer.toString();
        } catch (TransformerException e) {
            throw new ProcessingException("TransformerException: " + e, e);
        } catch (SAXException e) {
            throw new ProcessingException("SAXException while streaming DOM node to SAX: " + e, e);
        }
    }
16475#/**
     * Add string data
     *
     * @param contentHandler The SAX content handler
     * @param data The string data
     */
    public static void data(ContentHandler contentHandler,
                            String data)
    throws SAXException {

        contentHandler.characters(data.toCharArray(), 0, data.length());
    }
16476#/**
     * Implementation of &lt;xsp:expr&gt; for <code>String</code> :
     * outputs characters representing the value.
     *
     * @param contentHandler the SAX content handler
     * @param text the value
     */
    public static void valueOf(ContentHandler contentHandler, String text)
    throws SAXException {

        if (text != null) {
            data(contentHandler, text);
        }
    }
16477#/**
     * Implementation of &lt;xsp:expr&gt; for <code>XMLizable</code> :
     * outputs the value by calling <code>v.toSax(contentHandler)</code>.
     *
     * @param contentHandler the SAX content handler
     * @param v the XML fragment
     */
    public static void valueOf(ContentHandler contentHandler,
                               org.apache.excalibur.xml.sax.XMLizable v)
    throws SAXException {

        if (v != null) {
            v.toSAX(contentHandler);
        }
    }
16478#/**
     * Implementation of &lt;xsp:expr&gt; for <code>org.w3c.dom.Node</code> :
     * converts the Node to a SAX event stream.
     *
     * @param contentHandler the SAX content handler
     * @param v the value
     */
    public static void valueOf(ContentHandler contentHandler, Node v)
    throws SAXException {

        if (v != null) {
            DOMStreamer streamer = new DOMStreamer(contentHandler);
            if (contentHandler instanceof LexicalHandler) {
                streamer.setLexicalHandler((LexicalHandler)contentHandler);
            }
            streamer.stream(v);
        }
    }
16479#/**
     * Implementation of &lt;xsp:expr&gt; for <code>java.util.Collection</code> :
     * outputs the value by calling <code>xspExpr()</code> on each element of the
     * collection.
     *
     * @param contentHandler the SAX content handler
     * @param v the XML fragment
     */
    public static void valueOf(ContentHandler contentHandler,
                               Collection v)
    throws SAXException {

        if (v != null) {
            Iterator iterator = v.iterator();
            while (iterator.hasNext()) {
                valueOf(contentHandler, iterator.next());
            }
        }
     }
16480#/**
     * Implementation of &lt;xsp:expr&gt; for <code>Object</code> depending on its class :
     * <ul>
     * <li>if it's an array, call <code>xspExpr()</code> on all its elements,</li>
     * <li>if it's class has a specific <code>xspExpr()</code>implementation, use it,</li>
     * <li>else, output it's string representation.</li>
     * </ul>
     *
     * @param contentHandler the SAX content handler
     * @param v the value
     */
    public static void valueOf(ContentHandler contentHandler, Object v)
    throws SAXException {

        if (v == null) {
            return;
        }

        // Array: recurse over each element
        if (v.getClass().isArray()) {
            Object[] elements = (Object[]) v;

            for (int i = 0; i < elements.length; i++) {
                valueOf(contentHandler, elements[i]);
            }
            return;
         }

         // Check handled object types in case they were not typed in the XSP

         // XMLizable
         if (v instanceof org.apache.excalibur.xml.sax.XMLizable) {
             valueOf(contentHandler, (org.apache.excalibur.xml.sax.XMLizable)v);
             return;
         }

         // Node
         if (v instanceof Node) {
             valueOf(contentHandler, (Node)v);
             return;
         }

         // Collection
         if (v instanceof Collection) {
             valueOf(contentHandler, (Collection)v);
             return;
         }

         // Give up: hope it's a string or has a meaningful string representation
         data(contentHandler, String.valueOf(v));
    }
16481#/**
     * Create a start and endElement with a empty Namespace and without Attributes
     *
     * @param localName The local name (without prefix)
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement(ContentHandler, String)
     */
    public static void createElement(ContentHandler contentHandler,
                                     String localName)
    throws SAXException {

        startElement(contentHandler, localName);
        endElement(contentHandler, localName);
    }
16482#/**
     * Create a start and endElement with a empty Namespace and without Attributes
     * The content of the Element is set to the stringValue parameter
     *
     * @param localName The local name (without prefix)
     * @param stringValue The content of the Element
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement(ContentHandler, String)
     */
    public static void createElement(ContentHandler contentHandler,
                                     String localName,
                                     String stringValue)
    throws SAXException {

        startElement(contentHandler, localName);
        data(contentHandler, stringValue);
        endElement(contentHandler, localName);
    }
16483#/**
     * Create a start and endElement with a empty Namespace
     *
     * @param localName The local name (without prefix)
     * @param atts The attributes attached to the element.  If
     *        there are no attributes, it shall be an empty
     *        Attributes object.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement(ContentHandler, String)
     * @see org.xml.sax.Attributes
     */
    public static void createElement(ContentHandler contentHandler,
                                     String localName,
                                     Attributes atts)
    throws SAXException {

        startElement(contentHandler, localName, atts);
        endElement(contentHandler, localName);
    }
16484#/**
     * Create a start and endElement with a empty Namespace
     * The content of the Element is set to the stringValue parameter
     *
     * @param localName The local name (without prefix)
     * @param atts The attributes attached to the element.  If
     *        there are no attributes, it shall be an empty
     *        Attributes object.
     * @param stringValue The content of the Element
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement(ContentHandler, String)
     * @see org.xml.sax.Attributes
     */
    public static void createElement(ContentHandler contentHandler,
                                     String localName,
                                     Attributes atts,
                                     String stringValue)
    throws SAXException {

        startElement(contentHandler, localName, atts);
        data(contentHandler, stringValue);
        endElement(contentHandler, localName);
    }
16485#/**
     * Create a start and endElement without Attributes
     *
     * @param localName The local name (without prefix)
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement(ContentHandler, String)
     */
    public static void createElementNS(ContentHandler contentHandler,
                                       String namespaceURI,
                                       String localName)
    throws SAXException {

        startElement(contentHandler, namespaceURI, localName);
        endElement(contentHandler, namespaceURI, localName);
    }
16486#/**
     * Create a start and endElement without Attributes
     * The content of the Element is set to the stringValue parameter
     *
     * @param localName The local name (without prefix)
     * @param stringValue The content of the Element
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement(ContentHandler, String)
     */
    public static void createElementNS(ContentHandler contentHandler,
                                       String namespaceURI,
                                       String localName,
                                       String stringValue)
    throws SAXException {

        startElement(contentHandler, namespaceURI, localName);
        data(contentHandler, stringValue);
        endElement(contentHandler, namespaceURI, localName);
    }
16487#/**
     * Create a start and endElement
     *
     * @param localName The local name (without prefix)
     * @param atts The attributes attached to the element.  If
     *        there are no attributes, it shall be an empty
     *        Attributes object.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement(ContentHandler, String)
     * @see org.xml.sax.Attributes
     */
    public static void createElementNS(ContentHandler contentHandler,
                                       String namespaceURI,
                                       String localName,
                                       Attributes atts)
    throws SAXException {

        startElement(contentHandler, namespaceURI, localName, atts);
        endElement(contentHandler, namespaceURI, localName);
    }
16488#/**
     * Create a start and endElement with a empty Namespace
     * The content of the Element is set to the stringValue parameter
     *
     * @param localName The local name (without prefix)
     * @param atts The attributes attached to the element.  If
     *        there are no attributes, it shall be an empty
     *        Attributes object.
     * @param stringValue The content of the Element
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement(ContentHandler, String)
     * @see org.xml.sax.Attributes
     */
    public static void createElementNS(ContentHandler contentHandler,
                                       String namespaceURI,
                                       String localName,
                                       Attributes atts,
                                       String stringValue)
    throws SAXException {

        startElement(contentHandler, namespaceURI, localName, atts);
        data(contentHandler, stringValue);
        endElement(contentHandler, namespaceURI, localName);
    }
16489#/**
     * Create endElement with empty Namespace
     *
     * <p>For information on the names, see startElement.</p>
     *
     * @param localName The local name (without prefix)
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     */
    public static void endElement(ContentHandler contentHandler,
                                  String localName)
    throws SAXException {

        contentHandler.endElement("", localName, localName);
    }
16490#/**
     * Create endElement
     * Prefix must be mapped to empty String
     *
     * <p>For information on the names, see startElement.</p>
     *
     * @param localName The local name (without prefix)
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     */
    public static void endElement(ContentHandler contentHandler,
                                  String namespaceURI,
                                  String localName)
    throws SAXException {

        contentHandler.endElement(namespaceURI, localName, localName);
    }
16491#/**
     * Create a startElement with a empty Namespace and without Attributes
     *
     * @param localName The local name (without prefix)
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement(ContentHandler, String)
     */
    public static void startElement(ContentHandler contentHandler,
                                    String localName)
    throws SAXException {

        contentHandler.startElement("", localName, localName, EMPTY_ATTRIBUTES);
    }
16492#/**
     * Create a startElement without Attributes
     * Prefix must be mapped to empty String
     *
     * @param namespaceURI The Namespace URI
     * @param localName The local name (without prefix)
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement(ContentHandler, String)
     */
    public static void startElement(ContentHandler contentHandler,
                                    String namespaceURI,
                                    String localName)
    throws SAXException {

        contentHandler.startElement(namespaceURI, localName, localName, EMPTY_ATTRIBUTES);
    }
16493#/**
     * Create a startElement with a empty Namespace
     *
     * @param localName The local name (without prefix)
     * @param atts The attributes attached to the element.  If
     *        there are no attributes, it shall be an empty
     *        Attributes object.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement(ContentHandler, String)
     * @see org.xml.sax.Attributes
     */
    public static void startElement(ContentHandler contentHandler,
                                    String localName,
                                    Attributes atts)
    throws SAXException {

        contentHandler.startElement("", localName, localName, atts);
    }
16494#/**
     * Create a startElement with a empty Namespace
     * Prefix must be mapped to empty String
     *
     * @param namespaceURI The Namespace URI
     * @param localName The local name (without prefix)
     * @param atts The attributes attached to the element.  If
     *        there are no attributes, it shall be an empty
     *        Attributes object.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @see #endElement(ContentHandler, String)
     * @see org.xml.sax.Attributes
     */
    public static void startElement(ContentHandler contentHandler,
                                    String namespaceURI,
                                    String localName,
                                    Attributes atts)
    throws SAXException {

        contentHandler.startElement(namespaceURI, localName, localName, atts);
    }
16495#/**
     * Receive an object for locating the origin of SAX document events.
     *
     * @param locator An object that can return the location of any SAX
     *                document event.
     */
    public void setDocumentLocator(Locator locator) {
        contentHandler.setDocumentLocator(locator);
    }
16496#/**
     * Receive notification of the beginning of a document.
     */
    public void startDocument()
    throws SAXException {
        contentHandler.startDocument();
    }
16497#/**
     * Receive notification of the end of a document.
     */
    public void endDocument()
    throws SAXException {
        contentHandler.endDocument();
    }
16498#/**
     * Begin the scope of a prefix-URI Namespace mapping.
     *
     * @param prefix The Namespace prefix being declared.
     * @param uri The Namespace URI the prefix is mapped to.
     */
    public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
        contentHandler.startPrefixMapping(prefix, uri);
    }
16499#/**
     * End the scope of a prefix-URI mapping.
     *
     * @param prefix The prefix that was being mapping.
     */
    public void endPrefixMapping(String prefix)
    throws SAXException {
        contentHandler.endPrefixMapping(prefix);
    }
16500#/**
     * Receive notification of the beginning of an element.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     * @param a The attributes attached to the element. If there are no
     *          attributes, it shall be an empty Attributes object.
     */
    public void startElement(String uri, String loc, String raw, Attributes a)
    throws SAXException {
        contentHandler.startElement(uri, loc, raw, a);
    }
16501#/**
     * Receive notification of the end of an element.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     */
    public void endElement(String uri, String loc, String raw)
    throws SAXException {
        contentHandler.endElement(uri, loc, raw);
    }
16502#/**
     * Receive notification of character data.
     *
     * @param c The characters from the XML document.
     * @param start The start position in the array.
     * @param len The number of characters to read from the array.
     */
    public void characters(char c[], int start, int len)
    throws SAXException {
        contentHandler.characters(c, start, len);
    }
16503#/**
     * Receive notification of ignorable whitespace in element content.
     *
     * @param c The characters from the XML document.
     * @param start The start position in the array.
     * @param len The number of characters to read from the array.
     */
    public void ignorableWhitespace(char c[], int start, int len)
    throws SAXException {
        contentHandler.ignorableWhitespace(c, start, len);
    }
16504#/**
     * Receive notification of a processing instruction.
     *
     * @param target The processing instruction target.
     * @param data The processing instruction data, or null if none was
     *             supplied.
     */
    public void processingInstruction(String target, String data)
    throws SAXException {
        contentHandler.processingInstruction(target, data);
    }
16505#/**
     * Receive notification of a skipped entity.
     *
     * @param name The name of the skipped entity.  If it is a  parameter
     *             entity, the name will begin with '%'.
     */
    public void skippedEntity(String name)
    throws SAXException {
        contentHandler.skippedEntity(name);
    }
16506#/**
     * Report the start of DTD declarations, if any.
     *
     * @param name The document type name.
     * @param publicId The declared public identifier for the external DTD
     *                 subset, or null if none was declared.
     * @param systemId The declared system identifier for the external DTD
     *                 subset, or null if none was declared.
     */
    public void startDTD(String name, String publicId, String systemId)
    throws SAXException {
        lexicalHandler.startDTD(name, publicId, systemId);
    }
16507#/**
     * Report the end of DTD declarations.
     */
    public void endDTD()
    throws SAXException {
        lexicalHandler.endDTD();
    }
16508#/**
     * Report the beginning of an entity.
     *
     * @param name The name of the entity. If it is a parameter entity, the
     *             name will begin with '%'.
     */
    public void startEntity(String name)
    throws SAXException {
        lexicalHandler.startEntity(name);
    }
16509#/**
     * Report the end of an entity.
     *
     * @param name The name of the entity that is ending.
     */
    public void endEntity(String name)
    throws SAXException {
        lexicalHandler.endEntity(name);
    }
16510#/**
     * Report the start of a CDATA section.
     */
    public void startCDATA()
    throws SAXException {
        lexicalHandler.startCDATA();
    }
16511#/**
     * Report the end of a CDATA section.
     */
    public void endCDATA()
    throws SAXException {
        lexicalHandler.endCDATA();
    }
16512#/**
     * Report an XML comment anywhere in the document.
     *
     * @param ch An array holding the characters in the comment.
     * @param start The starting position in the array.
     * @param len The number of characters to use from the array.
     */
    public void comment(char ch[], int start, int len)
    throws SAXException {
        lexicalHandler.comment(ch, start, len);
    }
16513#/**
     * Appends children representing the object's state to the given node
     * by using the results of <code>toSAX()</code>.
     */
    public void toDOM(Node node) throws Exception {
        toSAX(new DOMBuilder(node));
    }
16514#/**
     * Create a new <code>ContentHandlerWrapper</code> instance.
     */
    public ContentHandlerWrapper() {
        super();
     }
16515#/**
     * Create a new <code>ContentHandlerWrapper</code> instance.
     */
    public ContentHandlerWrapper(ContentHandler contentHandler) {
        this();
        this.setContentHandler(contentHandler);
    }
16516#/**
     * Create a new <code>ContentHandlerWrapper</code> instance.
     */
    public ContentHandlerWrapper(ContentHandler contentHandler,
                                 LexicalHandler lexicalHandler) {
        this();
        this.setContentHandler(contentHandler);
        this.setLexicalHandler(lexicalHandler);
    }
16517#/**
     * Set the <code>ContentHandler</code> that will receive XML data.
     *
     * @exception IllegalStateException If the <code>ContentHandler</code>
     *                                  was already set.
     */
    public void setContentHandler(ContentHandler contentHandler)
    throws IllegalStateException {
        if (this.contentHandler!=null) throw new IllegalStateException();
        this.contentHandler=contentHandler;
    }
16518#/**
     * Set the <code>LexicalHandler</code> that will receive XML data.
     *
     * @exception IllegalStateException If the <code>LexicalHandler</code>
     *                                  was already set.
     */
    public void setLexicalHandler(LexicalHandler lexicalHandler)
    throws IllegalStateException {
        if (this.lexicalHandler!=null) throw new IllegalStateException();
        this.lexicalHandler=lexicalHandler;
    }
16519#public void recycle () {
        this.contentHandler = null;
        this.lexicalHandler = null;
    }
16520#/**
     * Receive an object for locating the origin of SAX document events.
     */
    public void setDocumentLocator (Locator locator) {
        if (this.contentHandler==null) return;
        else this.contentHandler.setDocumentLocator(locator);
    }
16521#/**
     * Receive notification of the beginning of a document.
     */
    public void startDocument ()
    throws SAXException {
        if (this.contentHandler==null)
            throw new SAXException("ContentHandler not set");
        this.contentHandler.startDocument();
    }
16522#/**
     * Receive notification of the end of a document.
     */
    public void endDocument ()
    throws SAXException {
        this.contentHandler.endDocument();
    }
16523#/**
     * Begin the scope of a prefix-URI Namespace mapping.
     */
    public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
        if (this.contentHandler==null)
            throw new SAXException("ContentHandler not set");
        this.contentHandler.startPrefixMapping(prefix, uri);
    }
16524#/**
     * End the scope of a prefix-URI mapping.
     */
    public void endPrefixMapping(String prefix)
    throws SAXException {
        this.contentHandler.endPrefixMapping(prefix);
    }
16525#/**
     * Receive notification of the beginning of an element.
     */
    public void startElement(String uri, String loc, String raw, Attributes a)
    throws SAXException {
        this.contentHandler.startElement(uri, loc, raw, a);
    }
16526#/**
     * Receive notification of the end of an element.
     */
    public void endElement(String uri, String loc, String raw)
    throws SAXException {
        this.contentHandler.endElement(uri, loc, raw);
    }
16527#/**
     * Receive notification of character data.
     */
    public void characters(char ch[], int start, int len)
    throws SAXException {
        this.contentHandler.characters(ch,start,len);
    }
16528#/**
     * Receive notification of ignorable whitespace in element content.
     */
    public void ignorableWhitespace(char ch[], int start, int len)
    throws SAXException {
        this.contentHandler.ignorableWhitespace(ch,start,len);
    }
16529#/**
     * Receive notification of a processing instruction.
     */
    public void processingInstruction(String target, String data)
    throws SAXException {
        this.contentHandler.processingInstruction(target,data);
    }
16530#/**
     * Receive notification of a skipped entity.
     *
     * @param name The name of the skipped entity.  If it is a  parameter
     *             entity, the name will begin with '%'.
     */
    public void skippedEntity(String name)
    throws SAXException {
        this.contentHandler.skippedEntity(name);
    }
16531#/**
     * Report the start of DTD declarations, if any.
     *
     * @param name The document type name.
     * @param publicId The declared public identifier for the external DTD
     *                 subset, or null if none was declared.
     * @param systemId The declared system identifier for the external DTD
     *                 subset, or null if none was declared.
     */
    public void startDTD(String name, String publicId, String systemId)
    throws SAXException {
        if (this.lexicalHandler != null)
            this.lexicalHandler.startDTD(name, publicId, systemId);
    }
16532#/**
     * Report the end of DTD declarations.
     */
    public void endDTD()
    throws SAXException {
        if (this.lexicalHandler != null)
            this.lexicalHandler.endDTD();
    }
16533#/**
     * Report the beginning of an entity.
     *
     * @param name The name of the entity. If it is a parameter entity, the
     *             name will begin with '%'.
     */
    public void startEntity(String name)
    throws SAXException {
        if (this.lexicalHandler != null)
            this.lexicalHandler.startEntity(name);
    }
16534#/**
     * Report the end of an entity.
     *
     * @param name The name of the entity that is ending.
     */
    public void endEntity(String name)
    throws SAXException {
        if (this.lexicalHandler != null)
            this.lexicalHandler.endEntity(name);
    }
16535#/**
     * Report the start of a CDATA section.
     */
    public void startCDATA()
    throws SAXException {
        if (this.lexicalHandler != null)
            this.lexicalHandler.startCDATA();
    }
16536#/**
     * Report the end of a CDATA section.
     */
    public void endCDATA()
    throws SAXException {
        if (this.lexicalHandler != null)
            this.lexicalHandler.endCDATA();
    }
16537#/**
     * Report an XML comment anywhere in the document.
     *
     * @param ch An array holding the characters in the comment.
     * @param start The starting position in the array.
     * @param len The number of characters to use from the array.
     */
    public void comment(char ch[], int start, int len)
    throws SAXException {
        if (this.lexicalHandler != null)
            this.lexicalHandler.comment(ch, start, len);
    }
16538#/**
     * Creates an EmbeddedXMLPipe that writes into the given XMLConsumer.
     */
    public EmbeddedXMLPipe(XMLConsumer consumer) {
        setConsumer(consumer);
    }
16539#/**
     * Creates an EmbeddedXMLPipe that writes into the given ContentHandler.
     */
    public EmbeddedXMLPipe(ContentHandler handler) {
        setContentHandler(handler);
        if (handler instanceof LexicalHandler) {
            setLexicalHandler((LexicalHandler) handler);
        }
    }
16540#/**
     * Creates an EmbeddedXMLPipe that writes into the given ContentHandler.
     */
    public EmbeddedXMLPipe(ContentHandler contentHandler, LexicalHandler lexicalHandler) {
        setContentHandler(contentHandler);
        setLexicalHandler(lexicalHandler);
    }
16541#/**
     * Ignore the <code>startDocument</code> event: this method does nothing.
     *
     * @exception SAXException if an error occurs
     */
    public void startDocument() throws SAXException {
    }
16542#/**
     * Ignore the <code>endDocument</code> event: this method does nothing.
     *
     * @exception SAXException if an error occurs
     */
    public void endDocument() throws SAXException {
    }
16543#/**
     * Ignore the <code>startDTD</code> event: this method does nothing.
     *
     * @exception SAXException if an error occurs
     */
    public void startDTD(String name, String publicId, String systemId)
    throws SAXException {
        // Ignored
        this.inDTD = true;
    }
16544#/**
     * Ignore the <code>endDTD</code> event: this method does nothing.
     *
     * @exception SAXException if an error occurs
     */
    public void endDTD() throws SAXException {
        // Ignored
        this.inDTD = false;
    }
16545#/**
     * Ignore all <code>comment</code> events if between
     * startDTD/endDTD events.
     *
     * @exception SAXException if an error occurs
     */
    public void comment(char ch[], int start, int len)
    throws SAXException {
        if (!inDTD) {
            super.comment(ch, start, len);
        }
    }
16546#/**
     * Receive an object for locating the origin of SAX document events.
     *
     * @param locator An object that can return the location of any SAX
     *                document event.
     */
    public void setDocumentLocator(Locator locator) {
    }
16547#/**
     * Receive notification of the beginning of a document.
     */
    public void startDocument()
    throws SAXException {
    }
16548#/**
     * Receive notification of the end of a document.
     */
    public void endDocument()
    throws SAXException {
    }
16549#/**
     * Begin the scope of a prefix-URI Namespace mapping.
     *
     * @param prefix The Namespace prefix being declared.
     * @param uri The Namespace URI the prefix is mapped to.
     */
    public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
    }
16550#/**
     * End the scope of a prefix-URI mapping.
     *
     * @param prefix The prefix that was being mapping.
     */
    public void endPrefixMapping(String prefix)
    throws SAXException {
    }
16551#/**
     * Receive notification of the beginning of an element.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     * @param a The attributes attached to the element. If there are no
     *          attributes, it shall be an empty Attributes object.
     */
    public void startElement(String uri, String loc, String raw, Attributes a)
    throws SAXException {
    }
16552#/**
     * Receive notification of the end of an element.
     *
     * @param uri The Namespace URI, or the empty string if the element has no
     *            Namespace URI or if Namespace
     *            processing is not being performed.
     * @param loc The local name (without prefix), or the empty string if
     *            Namespace processing is not being performed.
     * @param raw The raw XML 1.0 name (with prefix), or the empty string if
     *            raw names are not available.
     */
    public void endElement(String uri, String loc, String raw)
    throws SAXException {
    }
16553#/**
     * Receive notification of character data.
     *
     * @param ch The characters from the XML document.
     * @param start The start position in the array.
     * @param len The number of characters to read from the array.
     */
    public void characters(char ch[], int start, int len)
    throws SAXException {
    }
16554#/**
     * Receive notification of ignorable whitespace in element content.
     *
     * @param ch The characters from the XML document.
     * @param start The start position in the array.
     * @param len The number of characters to read from the array.
     */
    public void ignorableWhitespace(char ch[], int start, int len)
    throws SAXException {
    }
16555#/**
     * Receive notification of a processing instruction.
     *
     * @param target The processing instruction target.
     * @param data The processing instruction data, or null if none was
     *             supplied.
     */
    public void processingInstruction(String target, String data)
    throws SAXException {
    }
16556#/**
     * Receive notification of a skipped entity.
     *
     * @param name The name of the skipped entity.  If it is a  parameter
     *             entity, the name will begin with '%'.
     */
    public void skippedEntity(String name)
    throws SAXException {
    }
16557#/**
     * Report the start of DTD declarations, if any.
     *
     * @param name The document type name.
     * @param publicId The declared public identifier for the external DTD
     *                 subset, or null if none was declared.
     * @param systemId The declared system identifier for the external DTD
     *                 subset, or null if none was declared.
     */
    public void startDTD(String name, String publicId, String systemId)
    throws SAXException {
    }
16558#/**
     * Report the end of DTD declarations.
     */
    public void endDTD()
    throws SAXException {
    }
16559#/**
     * Report the beginning of an entity.
     *
     * @param name The name of the entity. If it is a parameter entity, the
     *             name will begin with '%'.
     */
    public void startEntity(String name)
    throws SAXException {
    }
16560#/**
     * Report the end of an entity.
     *
     * @param name The name of the entity that is ending.
     */
    public void endEntity(String name)
    throws SAXException {
    }
16561#/**
     * Report the start of a CDATA section.
     */
    public void startCDATA()
    throws SAXException {
    }
16562#/**
     * Report the end of a CDATA section.
     */
    public void endCDATA()
    throws SAXException {
    }
16563#/**
     * Report an XML comment anywhere in the document.
     *
     * @param ch An array holding the characters in the comment.
     * @param start The starting position in the array.
     * @param len The number of characters to use from the array.
     */
    public void comment(char ch[], int start, int len)
    throws SAXException {
    }
16564#/**
     * Creates empty SaxBuffer
     */
    public SaxBuffer() {
        this.saxbits = new ArrayList();
    }
16565#/**
     * Creates SaxBuffer based on the provided bits list.
     */
    public SaxBuffer(List bits) {
        this.saxbits = bits;
    }
16566#/**
     * Creates copy of another SaxBuffer
     */
    public SaxBuffer(SaxBuffer saxBuffer) {
        this.saxbits = new ArrayList(saxBuffer.saxbits);
    }
16567#//
    // ContentHandler Interface
    //

    public void skippedEntity(String name) throws SAXException {
        saxbits.add(new SkippedEntity(name));
    }
16568#public void setDocumentLocator(Locator locator) {
        // Don't record this event
    }
16569#public void ignorableWhitespace(char ch[], int start, int length) throws SAXException {
        saxbits.add(new IgnorableWhitespace(ch, start, length));
    }
16570#public void processingInstruction(String target, String data) throws SAXException {
        saxbits.add(new PI(target, data));
    }
16571#public void startDocument() throws SAXException {
        saxbits.add(StartDocument.SINGLETON);
    }
16572#public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {
        saxbits.add(new StartElement(namespaceURI, localName, qName, atts));
    }
16573#public void endPrefixMapping(String prefix) throws SAXException {
        saxbits.add(new EndPrefixMapping(prefix));
    }
16574#public void characters(char ch[], int start, int length) throws SAXException {
        saxbits.add(new Characters(ch, start, length));
    }
16575#public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
        saxbits.add(new EndElement(namespaceURI, localName, qName));
    }
16576#public void endDocument() throws SAXException {
        saxbits.add(EndDocument.SINGLETON);
    }
16577#public void startPrefixMapping(String prefix, String uri) throws SAXException {
        saxbits.add(new StartPrefixMapping(prefix, uri));
    }
16578#//
    // LexicalHandler Interface
    //

    public void endCDATA() throws SAXException {
        saxbits.add(EndCDATA.SINGLETON);
    }
16579#public void comment(char ch[], int start, int length) throws SAXException {
        saxbits.add(new Comment(ch, start, length));
    }
16580#public void startEntity(String name) throws SAXException {
        saxbits.add(new StartEntity(name));
    }
16581#public void endDTD() throws SAXException {
        saxbits.add(EndDTD.SINGLETON);
    }
16582#public void startDTD(String name, String publicId, String systemId) throws SAXException {
        saxbits.add(new StartDTD(name, publicId, systemId));
    }
16583#public void startCDATA() throws SAXException {
        saxbits.add(StartCDATA.SINGLETON);
    }
16584#public void endEntity(String name) throws SAXException {
        saxbits.add(new EndEntity(name));
    }
16585#//
    // Public Methods
    //

    /**
     * Add a bit containing XMLizable object
     */
    public void xmlizable(XMLizable xml) {
        saxbits.add(new XMLizableBit(xml));
    }
16586#/**
     * @return true if buffer is empty
     */
    public boolean isEmpty() {
        return saxbits.isEmpty();
    }
16587#/**
     * @return unmodifiable list of SAX bits
     */
    public List getBits() {
        return Collections.unmodifiableList(saxbits);
    }
16588#/**
     * Stream this buffer into the provided content handler.
     * If contentHandler object implements LexicalHandler, it will get lexical
     * events as well.
     */
    public void toSAX(ContentHandler contentHandler) throws SAXException {
        for (Iterator i = saxbits.iterator(); i.hasNext();) {
            SaxBit saxbit = (SaxBit)i.next();
            saxbit.send(contentHandler);
        }
    }
16589#/**
     * @return String value of the buffer
     */
    public String toString() {
        // NOTE: This method is used in i18n XML bundle implementation
        final StringBuffer value = new StringBuffer();
        for (Iterator i = saxbits.iterator(); i.hasNext();) {
            final SaxBit saxbit = (SaxBit) i.next();
            if (saxbit instanceof Characters) {
                ((Characters) saxbit).toString(value);
            }
        }

        return value.toString();
    }
16590#/**
     * Clear this buffer
     */
    public void recycle() {
        saxbits.clear();
    }
16591#/**
     * Dump buffer contents into the provided writer.
     */
    public void dump(Writer writer) throws IOException {
        Iterator i = saxbits.iterator();
        while (i.hasNext()) {
            final SaxBit saxbit = (SaxBit) i.next();
            saxbit.dump(writer);
        }
        writer.flush();
    }
16592#//
    // Implementation Methods
    //

    /**
     * Adds a SaxBit to the bits list
     */
    protected final void addBit(SaxBit bit) {
        saxbits.add(bit);
    }
16593#/**
     * Iterates through the bits list
     */
    protected final Iterator bits() {
        return saxbits.iterator();
    }
16594#public void send(ContentHandler contentHandler) throws SAXException;
16595#public void dump(Writer writer) throws IOException;
16596#public void send(ContentHandler contentHandler) throws SAXException {
            contentHandler.startDocument();
        }
16597#public void dump(Writer writer) throws IOException {
            writer.write("[StartDocument]\n");
        }
16598#public void send(ContentHandler contentHandler) throws SAXException {
            contentHandler.endDocument();
        }
16599#public void dump(Writer writer) throws IOException {
            writer.write("[EndDocument]\n");
        }
16600#public PI(String target, String data) {
            this.target = target;
            this.data = data;
        }
16601#public void send(ContentHandler contentHandler) throws SAXException {
            contentHandler.processingInstruction(target, data);
        }
16602#public void dump(Writer writer) throws IOException {
            writer.write("[ProcessingInstruction] target=" + target + ",data=" + data + "\n");
        }
16603#public StartDTD(String name, String publicId, String systemId) {
            this.name = name;
            this.publicId = publicId;
            this.systemId = systemId;
        }
16604#public void send(ContentHandler contentHandler) throws SAXException {
            if (contentHandler instanceof LexicalHandler)
                ((LexicalHandler)contentHandler).startDTD(name, publicId, systemId);
        }
16605#public void dump(Writer writer) throws IOException {
            writer.write("[StartDTD] name=" + name + ",publicId=" + publicId + ",systemId=" + systemId + "\n");
        }
16606#public void send(ContentHandler contentHandler) throws SAXException {
            if (contentHandler instanceof LexicalHandler)
                ((LexicalHandler)contentHandler).endDTD();
        }
16607#public void dump(Writer writer) throws IOException {
            writer.write("[EndDTD]\n");
        }
16608#public StartEntity(String name) {
            this.name = name;
        }
16609#public void send(ContentHandler contentHandler) throws SAXException {
            if (contentHandler instanceof LexicalHandler)
                ((LexicalHandler)contentHandler).startEntity(name);
        }
16610#public void dump(Writer writer) throws IOException {
            writer.write("[StartEntity] name=" + name + "\n");
        }
16611#public EndEntity(String name) {
            this.name = name;
        }
16612#public void send(ContentHandler contentHandler) throws SAXException {
            if (contentHandler instanceof LexicalHandler)
                ((LexicalHandler)contentHandler).endEntity(name);
        }
16613#public void dump(Writer writer) throws IOException {
            writer.write("[EndEntity] name=" + name + "\n");
        }
16614#public SkippedEntity(String name) {
            this.name = name;
        }
16615#public void send(ContentHandler contentHandler) throws SAXException {
            contentHandler.skippedEntity(name);
        }
16616#public void dump(Writer writer) throws IOException {
            writer.write("[SkippedEntity] name=" + name + "\n");
        }
16617#public StartPrefixMapping(String prefix, String uri) {
            this.prefix = prefix;
            this.uri = uri;
        }
16618#public void send(ContentHandler contentHandler) throws SAXException {
            contentHandler.startPrefixMapping(prefix, uri);
        }
16619#public void dump(Writer writer) throws IOException {
            writer.write("[StartPrefixMapping] prefix=" + prefix + ",uri=" + uri + "\n");
        }
16620#public EndPrefixMapping(String prefix) {
            this.prefix = prefix;
        }
16621#public void send(ContentHandler contentHandler) throws SAXException {
            contentHandler.endPrefixMapping(prefix);
        }
16622#public void dump(Writer writer) throws IOException {
            writer.write("[EndPrefixMapping] prefix=" + prefix + "\n");
        }
16623#public StartElement(String namespaceURI, String localName, String qName, Attributes attrs) {
            this.namespaceURI = namespaceURI;
            this.localName = localName;
            this.qName = qName;
            this.attrs = new org.xml.sax.helpers.AttributesImpl(attrs);
        }
16624#public void send(ContentHandler contentHandler) throws SAXException {
            contentHandler.startElement(namespaceURI, localName, qName, attrs);
        }
16625#public void dump(Writer writer) throws IOException {
            writer.write("[StartElement] namespaceURI=" + namespaceURI + ",localName=" + localName + ",qName=" + qName + "\n");
            for (int i = 0; i < attrs.getLength(); i++) {
                writer.write("      [Attribute] namespaceURI=" + attrs.getURI(i) + ",localName=" + attrs.getLocalName(i) + ",qName=" + attrs.getQName(i) + ",type=" + attrs.getType(i) + ",value=" + attrs.getValue(i) + "\n");
            }
        }
16626#public EndElement(String namespaceURI, String localName, String qName) {
            this.namespaceURI = namespaceURI;
            this.localName = localName;
            this.qName = qName;
        }
16627#public void send(ContentHandler contentHandler) throws SAXException {
            contentHandler.endElement(namespaceURI, localName, qName);
        }
16628#public void dump(Writer writer) throws IOException {
            writer.write("[EndElement] namespaceURI=" + namespaceURI + ",localName=" + localName + ",qName=" + qName + "\n");
        }
16629#public Characters(char[] ch, int start, int length) {
            // make a copy so that we don't hold references to a potentially large array we don't control
            this.ch = new char[length];
            System.arraycopy(ch, start, this.ch, 0, length);
        }
16630#public void send(ContentHandler contentHandler) throws SAXException {
            contentHandler.characters(ch, 0, ch.length);
        }
16631#public void toString(StringBuffer value) {
            value.append(ch);
        }
16632#public void dump(Writer writer) throws IOException {
            writer.write("[Characters] ch=" + new String(ch) + "\n");
        }
16633#public Comment(char[] ch, int start, int length) {
            // make a copy so that we don't hold references to a potentially large array we don't control
            this.ch = new char[length];
            System.arraycopy(ch, start, this.ch, 0, length);
        }
16634#public void send(ContentHandler contentHandler) throws SAXException {
            if (contentHandler instanceof LexicalHandler)
                ((LexicalHandler)contentHandler).comment(ch, 0, ch.length);
        }
16635#public void dump(Writer writer) throws IOException {
            writer.write("[Comment] ch=" + new String(ch) + "\n");
        }
16636#public void send(ContentHandler contentHandler) throws SAXException {
            if (contentHandler instanceof LexicalHandler)
                ((LexicalHandler)contentHandler).startCDATA();
        }
16637#public void dump(Writer writer) throws IOException {
            writer.write("[StartCDATA]\n");
        }
16638#public void send(ContentHandler contentHandler) throws SAXException {
            if (contentHandler instanceof LexicalHandler)
                ((LexicalHandler)contentHandler).endCDATA();
        }
16639#public void dump(Writer writer) throws IOException {
            writer.write("[EndCDATA]\n");
        }
16640#public IgnorableWhitespace(char[] ch, int start, int length) {
            // make a copy so that we don't hold references to a potentially large array we don't control
            this.ch = new char[length];
            System.arraycopy(ch, start, this.ch, 0, length);
        }
16641#public void send(ContentHandler contentHandler) throws SAXException {
            contentHandler.ignorableWhitespace(ch, 0, ch.length);
        }
16642#public void dump(Writer writer) throws IOException {
            writer.write("[IgnorableWhitespace] ch=" + new String(ch) + "\n");
        }
16643#public XMLizableBit(XMLizable xml) {
            this.xml = xml;
        }
16644#public void send(ContentHandler contentHandler) throws SAXException {
            this.xml.toSAX(new EmbeddedXMLPipe(contentHandler));
        }
16645#public void dump(Writer writer) throws IOException {
            if (xml instanceof SaxBuffer) {
                writer.write("[XMLizable] Begin nested SaxBuffer\n");
                ((SaxBuffer)xml).dump(writer);
                writer.write("[XMLizable] End nested SaxBuffer\n");
            } else {
                writer.write("[XMLizable] xml=" + xml + "\n");
            }
        }
16646#public ImmutableAttributesImpl() {
        super();
    }
16647#public ImmutableAttributesImpl(Attributes attrs) {
        super(attrs);
    }
16648#public void clear() {
        throw new UnsupportedOperationException("immutable attributes");
    }
16649#public void removeAttribute(int index) {
        throw new UnsupportedOperationException("immutable attributes");
    }
16650#public void setLocalName(int index, String localName) {
        throw new UnsupportedOperationException("immutable attributes");
    }
16651#public void setQName(int index, String qName) {
        throw new UnsupportedOperationException("immutable attributes");
    }
16652#public void setType(int index, String type) {
        throw new UnsupportedOperationException("immutable attributes");
    }
16653#public void setURI(int index, String uri) {
        throw new UnsupportedOperationException("immutable attributes");
    }
16654#public void setValue(int index, String value) {
        throw new UnsupportedOperationException("immutable attributes");
    }
16655#public void setAttributes(Attributes atts) {
        throw new UnsupportedOperationException("immutable attributes");
    }
16656#public void setAttribute(int index, String uri, String localName, String qName, String type, String value) {
        throw new UnsupportedOperationException("immutable attributes");
    }
16657#public void addAttribute(String uri, String localName, String qName, String type, String value) {
        throw new UnsupportedOperationException("immutable attributes");
    }
16658#public void startDTD(String name, String publicId, String systemId) throws SAXException {
        // nothing
    }
16659#public void endDTD() throws SAXException {
        // nothing
    }
16660#public void startEntity(String name) throws SAXException {
        // nothing
    }
16661#public void endEntity(String name) throws SAXException {
        // nothing
    }
16662#public void startCDATA() throws SAXException {
        // nothing
    }
16663#public void endCDATA() throws SAXException {
        // nothing
    }
16664#public void comment(char[] ch, int start, int length) throws SAXException {
        // nothing
    }
16665#/**
     * Constructor
     */
    public IncludeXMLConsumer (XMLConsumer consumer) {
        this(consumer, consumer);
    }
16666#/**
     * Constructor
     */
    public IncludeXMLConsumer (ContentHandler contentHandler) {
        this(contentHandler, contentHandler instanceof LexicalHandler ? (LexicalHandler)contentHandler : null);
    }
16667#/**
     * Constructor
     */
    public IncludeXMLConsumer (ContentHandler contentHandler, LexicalHandler lexicalHandler) {
        this.contentHandler = contentHandler;
        this.lexicalHandler = lexicalHandler;
    }
16668#/**
     * Utility method to stream a DOM node into the provided content handler,
     * lexical handler.
     *
     * @param node The DOM Node to be included
     * @param contentHandler The SAX ContentHandler receiving the information
     * @param lexicalHandler The SAX LexicalHandler receiving the information (optional)
     */
    public static void includeNode(Node           node,
                                   ContentHandler contentHandler,
                                   LexicalHandler lexicalHandler)
    throws SAXException {
        if (node != null) {
            if (node.getNodeType() == Node.TEXT_NODE){
                String value = node.getNodeValue();
                contentHandler.characters(value.toCharArray(), 0, value.length());
            } else {
                try {
                    IncludeXMLConsumer filter = new IncludeXMLConsumer(contentHandler, lexicalHandler);
                    Transformer transformer = FACTORY.newTransformer();
                    DOMSource source = new DOMSource(node);
                    SAXResult result = new SAXResult(filter);
                    result.setLexicalHandler(filter);
                    transformer.transform(source, result);
                } catch (TransformerConfigurationException e) {
                    throw new SAXException("TransformerConfigurationException", e);
                } catch (TransformerException e) {
                    throw new SAXException("TransformerException", e);
                }
            }
        }
    }
16669#/**
     * Control SAX event handling.
     * If set to <code>true</code> all empty characters events are ignored.
     * The default is <code>false</code>.
     */
    public void setIgnoreEmptyCharacters(boolean value) {
        this.ignoreEmptyCharacters = value;
    }
16670#/**
     * Control SAX event handling.
     * If set to <code>true</code> the root element is ignored.
     * The default is <code>false</code>.
     */
    public void setIgnoreRootElement(boolean value) {
        this.ignoreRootElement = value;
        this.ignoreRootElementCount = 0;
    }
16671#//
    // ContentHandler interface
    //

    public void setDocumentLocator(Locator loc) {
        this.contentHandler.setDocumentLocator(loc);
    }
16672#public void startDocument() throws SAXException {
        // Ignored
    }
16673#public void endDocument() throws SAXException {
        // Ignored
    }
16674#public void startPrefixMapping(String prefix, String uri) throws SAXException {
        this.contentHandler.startPrefixMapping(prefix, uri);
    }
16675#public void endPrefixMapping(String prefix) throws SAXException {
        this.contentHandler.endPrefixMapping(prefix);
    }
16676#public void startElement(String uri, String local, String qName, Attributes attr) throws SAXException {
        if (this.ignoreRootElement == false ||
            this.ignoreRootElementCount > 0) {
            this.contentHandler.startElement(uri,local,qName,attr);
        }
        this.ignoreRootElementCount++;
    }
16677#public void endElement(String uri, String local, String qName) throws SAXException {
        this.ignoreRootElementCount--;
        if (!this.ignoreRootElement  || this.ignoreRootElementCount > 0) {
            this.contentHandler.endElement(uri, local, qName);
        }
    }
16678#public void characters(char[] ch, int start, int end) throws SAXException {
        if (this.ignoreEmptyCharacters) {
            String text = new String(ch, start, end).trim();
            if (text.length() > 0) {
                this.contentHandler.characters(text.toCharArray(), 0, text.length());
            }
        } else {
            this.contentHandler.characters(ch, start, end);
        }
    }
16679#public void ignorableWhitespace(char[] ch, int start, int end) throws SAXException {
        if (!this.ignoreEmptyCharacters) {
            this.contentHandler.ignorableWhitespace(ch, start, end);
        }
    }
16680#public void processingInstruction(String name, String value) throws SAXException {
        this.contentHandler.processingInstruction(name, value);
    }
16681#public void skippedEntity(String ent) throws SAXException {
        this.contentHandler.skippedEntity(ent);
    }
16682#//
    // LexicalHandler interface
    //

    public void startDTD(String name, String public_id, String system_id)
    throws SAXException {
        // Ignored
        this.inDTD = true;
    }
16683#public void endDTD() throws SAXException {
        // Ignored
        this.inDTD = false;
    }
16684#public void startEntity(String name) throws SAXException {
        if (lexicalHandler != null) {
            lexicalHandler.startEntity(name);
        }
    }
16685#public void endEntity(String name) throws SAXException {
        if (lexicalHandler != null) {
            lexicalHandler.endEntity(name);
        }
    }
16686#public void startCDATA() throws SAXException {
        if (lexicalHandler != null) {
            lexicalHandler.startCDATA();
        }
    }
16687#public void endCDATA() throws SAXException {
        if (lexicalHandler != null) {
            lexicalHandler.endCDATA();
        }
    }
16688#public void comment(char ary[], int start, int length) throws SAXException {
        if (!inDTD && lexicalHandler != null) {
            lexicalHandler.comment(ary,start,length);
        }
    }
16689#/**
     * Constructor
     */
    public AttributesImpl() {
        super();
    }
16690#/**
     *  Constructor
     */
    public AttributesImpl(Attributes attr) {
        super(attr);
    }
16691#/**
	 * Add an attribute of type CDATA with empty Namespace to the end of the list.
	 *
	 * <p>For the sake of speed, this method does no checking
	 * to see if the attribute is already in the list: that is
	 * the responsibility of the application.</p>
	 *
	 * @param localName The local name.
	 * @param value The attribute value.
	 */
	public void addCDATAAttribute(String localName, String value) {
		addAttribute("", localName, localName, AttributeTypes.CDATA, value);
	}
16692#/**
     * Add an attribute of type CDATA with the namespace to the end of the list.
     *
     * <p>For the sake of speed, this method does no checking
     * to see if the attribute is already in the list: that is
     * the responsibility of the application.</p>
     *
     * @param namespace The namespace.
     * @param localName The local name.
     * @param value The attribute value.
     */
    public void addCDATAAttribute(String namespace, String localName, String value) {
        addAttribute(namespace, localName, localName, AttributeTypes.CDATA, value);
    }
16693#/**
	 * Add an attribute of type CDATA to the end of the list.
	 *
	 * <p>For the sake of speed, this method does no checking
	 * to see if the attribute is already in the list: that is
	 * the responsibility of the application.</p>
	 *
	 * @param uri The Namespace URI, or the empty string if
	 *        none is available or Namespace processing is not
	 *        being performed.
	 * @param localName The local name, or the empty string if
	 *        Namespace processing is not being performed.
	 * @param qName The qualified (prefixed) name, or the empty string
	 *        if qualified names are not available.
	 * @param value The attribute value.
	 */
	public void addCDATAAttribute(String uri,
                            		String localName,
                            		String qName,
                            		String value) {
		addAttribute(uri, localName, qName, AttributeTypes.CDATA, value);
	}
16694#/**
     * Remove an attribute
     */
    public void removeAttribute(String localName) {
        final int index = this.getIndex(localName);
        if ( index != -1 ) {
            this.removeAttribute(index);
        }
    }
16695#/**
     * Remove an attribute
     */
    public void removeAttribute(String uri, String localName) {
        final int index = this.getIndex(uri, localName);
        if ( index != -1 ) {
            this.removeAttribute(index);
        }
    }
16696#/** Creates a new instance of DocmentWrapper */
    public DocumentWrapper(Document doc) {
        this.document = doc;
    }
16697#/**
     * Generates SAX events representing the object's state.<br/>
     * <b>NOTE</b> : if the implementation can produce lexical events,
     * care should be taken that <code>handler</code> can actually be
     * a {@link org.apache.cocoon.xml.XMLConsumer} that accepts such
     * events.
     */
    public void toSAX(org.xml.sax.ContentHandler handler) throws SAXException {

        DOMStreamer ds = new DOMStreamer(handler);
        ds.stream(this.document.getDocumentElement());
    }
16698#public String toString() {
        try {
            return XMLUtils.serializeNode(this.document);
        } catch (ProcessingException e) {
        }
        return "";
    }
16699#/** Adds the node <code>newChild</code> to the end of the list of children
     * of this node. If the <code>newChild</code> is already in the tree, it
     * is first removed.
     * @param newChild The node to add.If it is a
     *   <code>DocumentFragment</code> object, the entire contents of the
     *   document fragment are moved into the child list of this node
     * @return The node added.
     * @exception DOMException
     *   HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not
     *   allow children of the type of the <code>newChild</code> node, or if
     *   the node to append is one of this node's ancestors or this node
     *   itself.
     *   <br>WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created
     *   from a different document than the one that created this node.
     *   <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or
     *   if the previous parent of the node being inserted is readonly.
     *
     */
    public Node appendChild(Node newChild) throws DOMException {
        return this.document.appendChild(newChild);
    }
16700#/** Returns a duplicate of this node, i.e., serves as a generic copy
     * constructor for nodes. The duplicate node has no parent; (
     * <code>parentNode</code> is <code>null</code>.).
     * <br>Cloning an <code>Element</code> copies all attributes and their
     * values, including those generated by the XML processor to represent
     * defaulted attributes, but this method does not copy any text it
     * contains unless it is a deep clone, since the text is contained in a
     * child <code>Text</code> node. Cloning an <code>Attribute</code>
     * directly, as opposed to be cloned as part of an <code>Element</code>
     * cloning operation, returns a specified attribute (
     * <code>specified</code> is <code>true</code>). Cloning any other type
     * of node simply returns a copy of this node.
     * <br>Note that cloning an immutable subtree results in a mutable copy,
     * but the children of an <code>EntityReference</code> clone are readonly
     * . In addition, clones of unspecified <code>Attr</code> nodes are
     * specified. And, cloning <code>Document</code>,
     * <code>DocumentType</code>, <code>Entity</code>, and
     * <code>Notation</code> nodes is implementation dependent.
     * @param deep If <code>true</code>, recursively clone the subtree under
     *   the specified node; if <code>false</code>, clone only the node
     *   itself (and its attributes, if it is an <code>Element</code>).
     * @return The duplicate node.
     *
     */
    public Node cloneNode(boolean deep) {
        return this.document.cloneNode(deep);
    }
16701#/** Creates an <code>Attr</code> of the given name. Note that the
     * <code>Attr</code> instance can then be set on an <code>Element</code>
     * using the <code>setAttributeNode</code> method.
     * <br>To create an attribute with a qualified name and namespace URI, use
     * the <code>createAttributeNS</code> method.
     * @param name The name of the attribute.
     * @return A new <code>Attr</code> object with the <code>nodeName</code>
     *   attribute set to <code>name</code>, and <code>localName</code>,
     *   <code>prefix</code>, and <code>namespaceURI</code> set to
     *   <code>null</code>. The value of the attribute is the empty string.
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified name contains an
     *   illegal character.
     *
     */
    public Attr createAttribute(String name) throws DOMException {
        return this.document.createAttribute(name);
    }
16702#/** Creates an attribute of the given qualified name and namespace URI.
     * @param namespaceURI The namespace URI of the attribute to create.
     * @param qualifiedName The qualified name of the attribute to
     *   instantiate.
     * @return A new <code>Attr</code> object with the following attributes:
     * <table border='1'>
     * <tr>
     * <th>
     *   Attribute</th>
     * <th>Value</th>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.nodeName</code></td>
     * <td valign='top' rowspan='1' colspan='1'>qualifiedName</td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'>
     *   <code>Node.namespaceURI</code></td>
     * <td valign='top' rowspan='1' colspan='1'><code>namespaceURI</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'>
     *   <code>Node.prefix</code></td>
     * <td valign='top' rowspan='1' colspan='1'>prefix, extracted from
     *   <code>qualifiedName</code>, or <code>null</code> if there is no
     *   prefix</td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.localName</code></td>
     * <td valign='top' rowspan='1' colspan='1'>local name, extracted from
     *   <code>qualifiedName</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Attr.name</code></td>
     * <td valign='top' rowspan='1' colspan='1'>
     *   <code>qualifiedName</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.nodeValue</code></td>
     * <td valign='top' rowspan='1' colspan='1'>the empty
     *   string</td>
     * </tr>
     * </table>
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified qualified name
     *   contains an illegal character, per the XML 1.0 specification .
     *   <br>NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is
     *   malformed per the Namespaces in XML specification, if the
     *   <code>qualifiedName</code> has a prefix and the
     *   <code>namespaceURI</code> is <code>null</code>, if the
     *   <code>qualifiedName</code> has a prefix that is "xml" and the
     *   <code>namespaceURI</code> is different from "
     *   http://www.w3.org/XML/1998/namespace", or if the
     *   <code>qualifiedName</code>, or its prefix, is "xmlns" and the
     *   <code>namespaceURI</code> is different from "
     *   http://www.w3.org/2000/xmlns/".
     *   <br>NOT_SUPPORTED_ERR: Always thrown if the current document does not
     *   support the <code>"XML"</code> feature, since namespaces were
     *   defined by XML.
     * @since DOM Level 2
     *
     */
    public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {
        return this.document.createAttributeNS(namespaceURI, qualifiedName);
    }
16703#/** Creates a <code>CDATASection</code> node whose value is the specified
     * string.
     * @param data The data for the <code>CDATASection</code> contents.
     * @return The new <code>CDATASection</code> object.
     * @exception DOMException
     *   NOT_SUPPORTED_ERR: Raised if this document is an HTML document.
     *
     */
    public CDATASection createCDATASection(String data) throws DOMException {
        return this.document.createCDATASection(data);
    }
16704#/** Creates a <code>Comment</code> node given the specified string.
     * @param data The data for the node.
     * @return The new <code>Comment</code> object.
     *
     */
    public Comment createComment(String data) {
        return this.document.createComment(data);
    }
16705#/** Creates an empty <code>DocumentFragment</code> object.
     * @return A new <code>DocumentFragment</code>.
     *
     */
    public DocumentFragment createDocumentFragment() {
        return this.document.createDocumentFragment();
    }
16706#/** Creates an element of the type specified. Note that the instance
     * returned implements the <code>Element</code> interface, so attributes
     * can be specified directly on the returned object.
     * <br>In addition, if there are known attributes with default values,
     * <code>Attr</code> nodes representing them are automatically created
     * and attached to the element.
     * <br>To create an element with a qualified name and namespace URI, use
     * the <code>createElementNS</code> method.
     * @param tagName The name of the element type to instantiate. For XML,
     *   this is case-sensitive. For HTML, the <code>tagName</code>
     *   parameter may be provided in any case, but it must be mapped to the
     *   canonical uppercase form by the DOM implementation.
     * @return A new <code>Element</code> object with the
     *   <code>nodeName</code> attribute set to <code>tagName</code>, and
     *   <code>localName</code>, <code>prefix</code>, and
     *   <code>namespaceURI</code> set to <code>null</code>.
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified name contains an
     *   illegal character.
     *
     */
    public Element createElement(String tagName) throws DOMException {
        return this.document.createElement(tagName);
    }
16707#/** Creates an element of the given qualified name and namespace URI.
     * @param namespaceURI The namespace URI of the element to create.
     * @param qualifiedName The qualified name of the element type to
     *   instantiate.
     * @return A new <code>Element</code> object with the following
     *   attributes:
     * <table border='1'>
     * <tr>
     * <th>Attribute</th>
     * <th>Value</th>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.nodeName</code></td>
     * <td valign='top' rowspan='1' colspan='1'>
     *   <code>qualifiedName</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.namespaceURI</code></td>
     * <td valign='top' rowspan='1' colspan='1'>
     *   <code>namespaceURI</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.prefix</code></td>
     * <td valign='top' rowspan='1' colspan='1'>prefix, extracted
     *   from <code>qualifiedName</code>, or <code>null</code> if there is
     *   no prefix</td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Node.localName</code></td>
     * <td valign='top' rowspan='1' colspan='1'>local name, extracted from
     *   <code>qualifiedName</code></td>
     * </tr>
     * <tr>
     * <td valign='top' rowspan='1' colspan='1'><code>Element.tagName</code></td>
     * <td valign='top' rowspan='1' colspan='1'>
     *   <code>qualifiedName</code></td>
     * </tr>
     * </table>
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified qualified name
     *   contains an illegal character, per the XML 1.0 specification .
     *   <br>NAMESPACE_ERR: Raised if the <code>qualifiedName</code> is
     *   malformed per the Namespaces in XML specification, if the
     *   <code>qualifiedName</code> has a prefix and the
     *   <code>namespaceURI</code> is <code>null</code>, or if the
     *   <code>qualifiedName</code> has a prefix that is "xml" and the
     *   <code>namespaceURI</code> is different from "
     *   http://www.w3.org/XML/1998/namespace" .
     *   <br>NOT_SUPPORTED_ERR: Always thrown if the current document does not
     *   support the <code>"XML"</code> feature, since namespaces were
     *   defined by XML.
     * @since DOM Level 2
     *
     */
    public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {
        return this.document.createElementNS(namespaceURI, qualifiedName);
    }
16708#/** Creates an <code>EntityReference</code> object. In addition, if the
     * referenced entity is known, the child list of the
     * <code>EntityReference</code> node is made the same as that of the
     * corresponding <code>Entity</code> node.If any descendant of the
     * <code>Entity</code> node has an unbound namespace prefix, the
     * corresponding descendant of the created <code>EntityReference</code>
     * node is also unbound; (its <code>namespaceURI</code> is
     * <code>null</code>). The DOM Level 2 does not support any mechanism to
     * resolve namespace prefixes.
     * @param name The name of the entity to reference.
     * @return The new <code>EntityReference</code> object.
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified name contains an
     *   illegal character.
     *   <br>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.
     *
     */
    public EntityReference createEntityReference(String name) throws DOMException {
        return this.document.createEntityReference(name);
    }
16709#/** Creates a <code>ProcessingInstruction</code> node given the specified
     * name and data strings.
     * @param target The target part of the processing instruction.
     * @param data The data for the node.
     * @return The new <code>ProcessingInstruction</code> object.
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified target contains an
     *   illegal character.
     *   <br>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.
     *
     */
    public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {
        return this.document.createProcessingInstruction(target, data);
    }
16710#/** Creates a <code>Text</code> node given the specified string.
     * @param data The data for the node.
     * @return The new <code>Text</code> object.
     *
     */
    public Text createTextNode(String data) {
        return this.document.createTextNode(data);
    }
16711#/** A <code>NamedNodeMap</code> containing the attributes of this node (if
     * it is an <code>Element</code>) or <code>null</code> otherwise.
     *
     */
    public NamedNodeMap getAttributes() {
        return this.document.getAttributes();
    }
16712#/** A <code>NodeList</code> that contains all children of this node. If
     * there are no children, this is a <code>NodeList</code> containing no
     * nodes.
     *
     */
    public NodeList getChildNodes() {
        return this.document.getChildNodes();
    }
16713#/** The Document Type Declaration (see <code>DocumentType</code>)
     * associated with this document. For HTML documents as well as XML
     * documents without a document type declaration this returns
     * <code>null</code>. The DOM Level 2 does not support editing the
     * Document Type Declaration. <code>docType</code> cannot be altered in
     * any way, including through the use of methods inherited from the
     * <code>Node</code> interface, such as <code>insertNode</code> or
     * <code>removeNode</code>.
     *
     */
    public DocumentType getDoctype() {
        return this.document.getDoctype();
    }
16714#/** This is a convenience attribute that allows direct access to the child
     * node that is the root element of the document. For HTML documents,
     * this is the element with the tagName "HTML".
     *
     */
    public Element getDocumentElement() {
        return this.document.getDocumentElement();
    }
16715#/** Returns the <code>Element</code> whose <code>ID</code> is given by
     * <code>elementId</code>. If no such element exists, returns
     * <code>null</code>. Behavior is not defined if more than one element
     * has this <code>ID</code>. The DOM implementation must have
     * information that says which attributes are of type ID. Attributes
     * with the name "ID" are not of type ID unless so defined.
     * Implementations that do not know whether attributes are of type ID or
     * not are expected to return <code>null</code>.
     * @param elementId The unique <code>id</code> value for an element.
     * @return The matching element.
     * @since DOM Level 2
     *
     */
    public Element getElementById(String elementId) {
        return this.document.getElementById(elementId);
    }
16716#/** Returns a <code>NodeList</code> of all the <code>Elements</code> with a
     * given tag name in the order in which they are encountered in a
     * preorder traversal of the <code>Document</code> tree.
     * @param tagname The name of the tag to match on. The special value "*"
     *   matches all tags.
     * @return A new <code>NodeList</code> object containing all the matched
     *   <code>Elements</code>.
     *
     */
    public NodeList getElementsByTagName(String tagname) {
        return this.document.getElementsByTagName(tagname);
    }
16717#/** Returns a <code>NodeList</code> of all the <code>Elements</code> with a
     * given local name and namespace URI in the order in which they are
     * encountered in a preorder traversal of the <code>Document</code> tree.
     * @param namespaceURI The namespace URI of the elements to match on. The
     *   special value "*" matches all namespaces.
     * @param localName The local name of the elements to match on. The
     *   special value "*" matches all local names.
     * @return A new <code>NodeList</code> object containing all the matched
     *   <code>Elements</code>.
     * @since DOM Level 2
     *
     */
    public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {
        return this.document.getElementsByTagNameNS(namespaceURI, localName);
    }
16718#/** The first child of this node. If there is no such node, this returns
     * <code>null</code>.
     *
     */
    public Node getFirstChild() {
        return this.document.getFirstChild();
    }
16719#/** The <code>DOMImplementation</code> object that handles this document. A
     * DOM application may use objects from multiple implementations.
     *
     */
    public DOMImplementation getImplementation() {
        return this.document.getImplementation();
    }
16720#/** The last child of this node. If there is no such node, this returns
     * <code>null</code>.
     *
     */
    public Node getLastChild() {
        return this.document.getLastChild();
    }
16721#/** Returns the local part of the qualified name of this node.
     * <br>For nodes of any type other than <code>ELEMENT_NODE</code> and
     * <code>ATTRIBUTE_NODE</code> and nodes created with a DOM Level 1
     * method, such as <code>createElement</code> from the
     * <code>Document</code> interface, this is always <code>null</code>.
     * @since DOM Level 2
     *
     */
    public String getLocalName() {
        return this.document.getLocalName();
    }
16722#/** The namespace URI of this node, or <code>null</code> if it is
     * unspecified.
     * <br>This is not a computed value that is the result of a namespace
     * lookup based on an examination of the namespace declarations in
     * scope. It is merely the namespace URI given at creation time.
     * <br>For nodes of any type other than <code>ELEMENT_NODE</code> and
     * <code>ATTRIBUTE_NODE</code> and nodes created with a DOM Level 1
     * method, such as <code>createElement</code> from the
     * <code>Document</code> interface, this is always <code>null</code>.Per
     * the Namespaces in XML Specification  an attribute does not inherit
     * its namespace from the element it is attached to. If an attribute is
     * not explicitly given a namespace, it simply has no namespace.
     * @since DOM Level 2
     *
     */
    public String getNamespaceURI() {
        return this.document.getNamespaceURI();
    }
16723#/** The node immediately following this node. If there is no such node,
     * this returns <code>null</code>.
     *
     */
    public Node getNextSibling() {
        return this.document.getNextSibling();
    }
16724#/** The name of this node, depending on its type; see the table above.
     *
     */
    public String getNodeName() {
        return this.document.getNodeName();
    }
16725#/** A code representing the type of the underlying object, as defined above.
     *
     */
    public short getNodeType() {
        return this.document.getNodeType();
    }
16726#/** The value of this node, depending on its type; see the table above.
     * When it is defined to be <code>null</code>, setting it has no effect.
     * @exception DOMException
     *   NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
     *   DOMSTRING_SIZE_ERR: Raised when it would return more characters than
     *   fit in a <code>DOMString</code> variable on the implementation
     *   platform.
     *
     */
    public String getNodeValue() throws DOMException {
        return this.document.getNodeValue();
    }
16727#/** The <code>Document</code> object associated with this node. This is
     * also the <code>Document</code> object used to create new nodes. When
     * this node is a <code>Document</code> or a <code>DocumentType</code>
     * which is not used with any <code>Document</code> yet, this is
     * <code>null</code>.
     * @since DOM Level 2
     *
     */
    public Document getOwnerDocument() {
        return this.document.getOwnerDocument();
    }
16728#/** The parent of this node. All nodes, except <code>Attr</code>,
     * <code>Document</code>, <code>DocumentFragment</code>,
     * <code>Entity</code>, and <code>Notation</code> may have a parent.
     * However, if a node has just been created and not yet added to the
     * tree, or if it has been removed from the tree, this is
     * <code>null</code>.
     *
     */
    public Node getParentNode() {
        return this.document.getParentNode();
    }
16729#/** The namespace prefix of this node, or <code>null</code> if it is
     * unspecified.
     * <br>Note that setting this attribute, when permitted, changes the
     * <code>nodeName</code> attribute, which holds the qualified name, as
     * well as the <code>tagName</code> and <code>name</code> attributes of
     * the <code>Element</code> and <code>Attr</code> interfaces, when
     * applicable.
     * <br>Note also that changing the prefix of an attribute that is known to
     * have a default value, does not make a new attribute with the default
     * value and the original prefix appear, since the
     * <code>namespaceURI</code> and <code>localName</code> do not change.
     * <br>For nodes of any type other than <code>ELEMENT_NODE</code> and
     * <code>ATTRIBUTE_NODE</code> and nodes created with a DOM Level 1
     * method, such as <code>createElement</code> from the
     * <code>Document</code> interface, this is always <code>null</code>.
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified prefix contains an
     *   illegal character, per the XML 1.0 specification .
     *   <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     *   <br>NAMESPACE_ERR: Raised if the specified <code>prefix</code> is
     *   malformed per the Namespaces in XML specification, if the
     *   <code>namespaceURI</code> of this node is <code>null</code>, if the
     *   specified prefix is "xml" and the <code>namespaceURI</code> of this
     *   node is different from "http://www.w3.org/XML/1998/namespace", if
     *   this node is an attribute and the specified prefix is "xmlns" and
     *   the <code>namespaceURI</code> of this node is different from "
     *   http://www.w3.org/2000/xmlns/", or if this node is an attribute and
     *   the <code>qualifiedName</code> of this node is "xmlns" .
     * @since DOM Level 2
     *
     */
    public String getPrefix() {
        return this.document.getPrefix();
    }
16730#/** The node immediately preceding this node. If there is no such node,
     * this returns <code>null</code>.
     *
     */
    public Node getPreviousSibling() {
        return this.document.getPreviousSibling();
    }
16731#/** Returns whether this node (if it is an element) has any attributes.
     * @return <code>true</code> if this node has any attributes,
     *   <code>false</code> otherwise.
     * @since DOM Level 2
     *
     */
    public boolean hasAttributes() {
        return this.document.hasAttributes();
    }
16732#/** Returns whether this node has any children.
     * @return <code>true</code> if this node has any children,
     *   <code>false</code> otherwise.
     *
     */
    public boolean hasChildNodes() {
        return this.document.hasChildNodes();
    }
16733#/** Imports a node from another document to this document. The returned
     * node has no parent; (<code>parentNode</code> is <code>null</code>).
     * The source node is not altered or removed from the original document;
     * this method creates a new copy of the source node.
     * <br>For all nodes, importing a node creates a node object owned by the
     * importing document, with attribute values identical to the source
     * node's <code>nodeName</code> and <code>nodeType</code>, plus the
     * attributes related to namespaces (<code>prefix</code>,
     * <code>localName</code>, and <code>namespaceURI</code>). As in the
     * <code>cloneNode</code> operation on a <code>Node</code>, the source
     * node is not altered.
     * <br>Additional information is copied as appropriate to the
     * <code>nodeType</code>, attempting to mirror the behavior expected if
     * a fragment of XML or HTML source was copied from one document to
     * another, recognizing that the two documents may have different DTDs
     * in the XML case. The following list describes the specifics for each
     * type of node.
     * <dl>
     * <dt>ATTRIBUTE_NODE</dt>
     * <dd>The <code>ownerElement</code> attribute
     * is set to <code>null</code> and the <code>specified</code> flag is
     * set to <code>true</code> on the generated <code>Attr</code>. The
     * descendants of the source <code>Attr</code> are recursively imported
     * and the resulting nodes reassembled to form the corresponding subtree.
     * Note that the <code>deep</code> parameter has no effect on
     * <code>Attr</code> nodes; they always carry their children with them
     * when imported.</dd>
     * <dt>DOCUMENT_FRAGMENT_NODE</dt>
     * <dd>If the <code>deep</code> option
     * was set to <code>true</code>, the descendants of the source element
     * are recursively imported and the resulting nodes reassembled to form
     * the corresponding subtree. Otherwise, this simply generates an empty
     * <code>DocumentFragment</code>.</dd>
     * <dt>DOCUMENT_NODE</dt>
     * <dd><code>Document</code>
     * nodes cannot be imported.</dd>
     * <dt>DOCUMENT_TYPE_NODE</dt>
     * <dd><code>DocumentType</code>
     * nodes cannot be imported.</dd>
     * <dt>ELEMENT_NODE</dt>
     * <dd>Specified attribute nodes of the
     * source element are imported, and the generated <code>Attr</code>
     * nodes are attached to the generated <code>Element</code>. Default
     * attributes are not copied, though if the document being imported into
     * defines default attributes for this element name, those are assigned.
     * If the <code>importNode</code> <code>deep</code> parameter was set to
     * <code>true</code>, the descendants of the source element are
     * recursively imported and the resulting nodes reassembled to form the
     * corresponding subtree.</dd>
     * <dt>ENTITY_NODE</dt>
     * <dd><code>Entity</code> nodes can be
     * imported, however in the current release of the DOM the
     * <code>DocumentType</code> is readonly. Ability to add these imported
     * nodes to a <code>DocumentType</code> will be considered for addition
     * to a future release of the DOM.On import, the <code>publicId</code>,
     * <code>systemId</code>, and <code>notationName</code> attributes are
     * copied. If a <code>deep</code> import is requested, the descendants
     * of the the source <code>Entity</code> are recursively imported and
     * the resulting nodes reassembled to form the corresponding subtree.</dd>
     * <dt>
     * ENTITY_REFERENCE_NODE</dt>
     * <dd>Only the <code>EntityReference</code> itself is
     * copied, even if a <code>deep</code> import is requested, since the
     * source and destination documents might have defined the entity
     * differently. If the document being imported into provides a
     * definition for this entity name, its value is assigned.</dd>
     * <dt>NOTATION_NODE</dt>
     * <dd>
     * <code>Notation</code> nodes can be imported, however in the current
     * release of the DOM the <code>DocumentType</code> is readonly. Ability
     * to add these imported nodes to a <code>DocumentType</code> will be
     * considered for addition to a future release of the DOM.On import, the
     * <code>publicId</code> and <code>systemId</code> attributes are copied.
     * Note that the <code>deep</code> parameter has no effect on
     * <code>Notation</code> nodes since they never have any children.</dd>
     * <dt>
     * PROCESSING_INSTRUCTION_NODE</dt>
     * <dd>The imported node copies its
     * <code>target</code> and <code>data</code> values from those of the
     * source node.</dd>
     * <dt>TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE</dt>
     * <dd>These three
     * types of nodes inheriting from <code>CharacterData</code> copy their
     * <code>data</code> and <code>length</code> attributes from those of
     * the source node.</dd>
     * </dl>
     * @param importedNode The node to import.
     * @param deep If <code>true</code>, recursively import the subtree under
     *   the specified node; if <code>false</code>, import only the node
     *   itself, as explained above. This has no effect on <code>Attr</code>
     *   , <code>EntityReference</code>, and <code>Notation</code> nodes.
     * @return The imported node that belongs to this <code>Document</code>.
     * @exception DOMException
     *   NOT_SUPPORTED_ERR: Raised if the type of node being imported is not
     *   supported.
     * @since DOM Level 2
     *
     */
    public Node importNode(Node importedNode, boolean deep) throws DOMException {
        return this.document.importNode(importedNode, deep);
    }
16734#/** Inserts the node <code>newChild</code> before the existing child node
     * <code>refChild</code>. If <code>refChild</code> is <code>null</code>,
     * insert <code>newChild</code> at the end of the list of children.
     * <br>If <code>newChild</code> is a <code>DocumentFragment</code> object,
     * all of its children are inserted, in the same order, before
     * <code>refChild</code>. If the <code>newChild</code> is already in the
     * tree, it is first removed.
     * @param newChild The node to insert.
     * @param refChild The reference node, i.e., the node before which the
     *   new node must be inserted.
     * @return The node being inserted.
     * @exception DOMException
     *   HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not
     *   allow children of the type of the <code>newChild</code> node, or if
     *   the node to insert is one of this node's ancestors or this node
     *   itself.
     *   <br>WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created
     *   from a different document than the one that created this node.
     *   <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or
     *   if the parent of the node being inserted is readonly.
     *   <br>NOT_FOUND_ERR: Raised if <code>refChild</code> is not a child of
     *   this node.
     *
     */
    public Node insertBefore(Node newChild, Node refChild) throws DOMException {
        return this.document.insertBefore(newChild, refChild);
    }
16735#/** Tests whether the DOM implementation implements a specific feature and
     * that feature is supported by this node.
     * @param feature The name of the feature to test. This is the same name
     *   which can be passed to the method <code>hasFeature</code> on
     *   <code>DOMImplementation</code>.
     * @param version This is the version number of the feature to test. In
     *   Level 2, version 1, this is the string "2.0". If the version is not
     *   specified, supporting any version of the feature will cause the
     *   method to return <code>true</code>.
     * @return Returns <code>true</code> if the specified feature is
     *   supported on this node, <code>false</code> otherwise.
     * @since DOM Level 2
     *
     */
    public boolean isSupported(String feature, String version) {
        return this.document.isSupported(feature, version);
    }
16736#/** Puts all <code>Text</code> nodes in the full depth of the sub-tree
     * underneath this <code>Node</code>, including attribute nodes, into a
     * "normal" form where only structure (e.g., elements, comments,
     * processing instructions, CDATA sections, and entity references)
     * separates <code>Text</code> nodes, i.e., there are neither adjacent
     * <code>Text</code> nodes nor empty <code>Text</code> nodes. This can
     * be used to ensure that the DOM view of a document is the same as if
     * it were saved and re-loaded, and is useful when operations (such as
     * XPointer  lookups) that depend on a particular document tree
     * structure are to be used.In cases where the document contains
     * <code>CDATASections</code>, the normalize operation alone may not be
     * sufficient, since XPointers do not differentiate between
     * <code>Text</code> nodes and <code>CDATASection</code> nodes.
     * @since DOM Level 2
     *
     */
    public void normalize() {
        this.document.normalize();
    }
16737#/** Removes the child node indicated by <code>oldChild</code> from the list
     * of children, and returns it.
     * @param oldChild The node being removed.
     * @return The node removed.
     * @exception DOMException
     *   NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     *   <br>NOT_FOUND_ERR: Raised if <code>oldChild</code> is not a child of
     *   this node.
     *
     */
    public Node removeChild(Node oldChild) throws DOMException {
        return this.document.removeChild(oldChild);
    }
16738#/** Replaces the child node <code>oldChild</code> with <code>newChild</code>
     *  in the list of children, and returns the <code>oldChild</code> node.
     * <br>If <code>newChild</code> is a <code>DocumentFragment</code> object,
     * <code>oldChild</code> is replaced by all of the
     * <code>DocumentFragment</code> children, which are inserted in the
     * same order. If the <code>newChild</code> is already in the tree, it
     * is first removed.
     * @param newChild The new node to put in the child list.
     * @param oldChild The node being replaced in the list.
     * @return The node replaced.
     * @exception DOMException
     *   HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not
     *   allow children of the type of the <code>newChild</code> node, or if
     *   the node to put in is one of this node's ancestors or this node
     *   itself.
     *   <br>WRONG_DOCUMENT_ERR: Raised if <code>newChild</code> was created
     *   from a different document than the one that created this node.
     *   <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the parent of
     *   the new node is readonly.
     *   <br>NOT_FOUND_ERR: Raised if <code>oldChild</code> is not a child of
     *   this node.
     *
     */
    public Node replaceChild(Node newChild, Node oldChild) throws DOMException {
        return this.document.replaceChild(newChild, oldChild);
    }
16739#/** The value of this node, depending on its type; see the table above.
     * When it is defined to be <code>null</code>, setting it has no effect.
     * @exception DOMException
     *   NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.
     *   DOMSTRING_SIZE_ERR: Raised when it would return more characters than
     *   fit in a <code>DOMString</code> variable on the implementation
     *   platform.
     *
     */
    public void setNodeValue(String nodeValue) throws DOMException {
        this.document.setNodeValue(nodeValue);
    }
16740#/** The namespace prefix of this node, or <code>null</code> if it is
     * unspecified.
     * <br>Note that setting this attribute, when permitted, changes the
     * <code>nodeName</code> attribute, which holds the qualified name, as
     * well as the <code>tagName</code> and <code>name</code> attributes of
     * the <code>Element</code> and <code>Attr</code> interfaces, when
     * applicable.
     * <br>Note also that changing the prefix of an attribute that is known to
     * have a default value, does not make a new attribute with the default
     * value and the original prefix appear, since the
     * <code>namespaceURI</code> and <code>localName</code> do not change.
     * <br>For nodes of any type other than <code>ELEMENT_NODE</code> and
     * <code>ATTRIBUTE_NODE</code> and nodes created with a DOM Level 1
     * method, such as <code>createElement</code> from the
     * <code>Document</code> interface, this is always <code>null</code>.
     * @exception DOMException
     *   INVALID_CHARACTER_ERR: Raised if the specified prefix contains an
     *   illegal character, per the XML 1.0 specification .
     *   <br>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.
     *   <br>NAMESPACE_ERR: Raised if the specified <code>prefix</code> is
     *   malformed per the Namespaces in XML specification, if the
     *   <code>namespaceURI</code> of this node is <code>null</code>, if the
     *   specified prefix is "xml" and the <code>namespaceURI</code> of this
     *   node is different from "http://www.w3.org/XML/1998/namespace", if
     *   this node is an attribute and the specified prefix is "xmlns" and
     *   the <code>namespaceURI</code> of this node is different from "
     *   http://www.w3.org/2000/xmlns/", or if this node is an attribute and
     *   the <code>qualifiedName</code> of this node is "xmlns" .
     * @since DOM Level 2
     *
     */
    public void setPrefix(String prefix) throws DOMException {
        this.document.setPrefix(prefix);
    }
16741#/**
     * @since DOM Level 3
     */
    public Node renameNode(Node node, String namespaceURI, String qualifiedName) throws DOMException {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16742#/**
     * @since DOM Level 3
     */
    public void normalizeDocument() {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16743#/**
     * @since DOM Level 3
     */
    public DOMConfiguration getDomConfig() {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16744#/**
     * @since DOM Level 3
     */
    public Node adoptNode(Node source) {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16745#/**
     * @since DOM Level 3
     */
    public void setDocumentURI(String uri) {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16746#/**
     * @since DOM Level 3
     */
    public String getDocumentURI() {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16747#/**
     * @since DOM Level 3
     */
    public void setStrictErrorChecking(boolean value) {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16748#/**
     * @since DOM Level 3
     */
    public boolean getStrictErrorChecking() {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16749#/**
     * @since DOM Level 3
     */
    public void setXmlVersion(String version) {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16750#/**
     * @since DOM Level 3
     */
    public String getXmlVersion() {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16751#/**
     * @since DOM Level 3
     */
    public void setXmlStandalone(boolean value) {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16752#/**
     * @since DOM Level 3
     */
    public boolean getXmlStandalone() {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16753#/**
     * @since DOM Level 3
     */
    public void setXmlEncoding(String version) {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16754#/**
     * @since DOM Level 3
     */
    public String getXmlEncoding() {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16755#/**
     * @since DOM Level 3
     */
    public String getInputEncoding() {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16756#/**
     * @since DOM Level 3
     */
    public Object getUserData(String key) {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16757#/**
     * @since DOM Level 3
     */
    public Object setUserData(String key, Object value, UserDataHandler handler) {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16758#/**
     * @since DOM Level 3
     */
    public Object getFeature(String feature, String version) { 
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16759#/**
     * @since DOM Level 3
     */
    public short compareDocumentPosition(Node other) throws DOMException {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16760#/**
     * @since DOM Level 3
     */
    public String getBaseURI() {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16761#/**
     * @since DOM Level 3
     */
    public String getTextContent() throws DOMException {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16762#/**
     * @since DOM Level 3
     */
    public boolean isDefaultNamespace(String namespaceURI) {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16763#/**
     * @since DOM Level 3
     */
    public boolean isEqualNode(Node arg) {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16764#/**
     * @since DOM Level 3
     */
    public boolean isSameNode(Node other) {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16765#/**
     * @since DOM Level 3
     */
    public String lookupNamespaceURI(String prefix) {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16766#/**
     * @since DOM Level 3
     */
    public String lookupPrefix(String namespaceURI) {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16767#/**
     * @since DOM Level 3
     */
    public void setTextContent(String textContent) throws DOMException {
        throw new UnsupportedOperationException(DOMLEVEL3_ERR_MSG);
    }
16768#/**
     * Get the owner of the DOM document belonging to the node. This works even
     * if the node is the document itself.
     * 
     * @param node
     *            The node.
     * @return The corresponding document.
     */
    public static Document getOwnerDocument(Node node) {
        if (node.getNodeType() == Node.DOCUMENT_NODE) {
            return (Document) node;
        } else {
            return node.getOwnerDocument();
        }
    }
16769#/**
     * Get the value of the node specified by the XPath. This works similar to
     * &lt;xsl:value-of&gt;. If the node does not exist <CODE>null</CODE> is
     * returned.
     * 
     * @param root
     *            The node to start the search.
     * @param path
     *            XPath search expression.
     * @return The value of the node or <CODE>null</CODE>
     */
    public static String getValueOfNode(XPathProcessor processor, Node root, String path) throws ProcessingException {
        if (path == null) {
            throw new ProcessingException(XPATH_IS_REQUIRED);
        }
        if (root != null) {
            path = StringUtils.strip(path, "/");
            Node node = XPathUtil.searchSingleNode(processor, root, path);
            if (node != null) {
                return getValueOfNode(node);
            }
        }
        return null;
    }
16770#/**
     * Get the value of the node specified by the XPath. This works similar to
     * &lt;xsl:value-of&gt;. If the node is not found the <CODE>defaultValue</CODE>
     * is returned.
     * 
     * @param root
     *            The node to start the search.
     * @param path
     *            XPath search expression.
     * @param defaultValue
     *            The default value if the node does not exist.
     * @return The value of the node or <CODE>defaultValue</CODE>
     */
    public static String getValueOfNode(XPathProcessor processor, Node root, String path, String defaultValue)
            throws ProcessingException {
        String value = getValueOfNode(processor, root, path);
        if (value == null)
            value = defaultValue;

        return value;
    }
16771#/**
     * Get the boolean value of the node specified by the XPath. This works
     * similar to &lt;xsl:value-of&gt;. If the node exists and has a value this
     * value is converted to a boolean, e.g. "true" or "false" as value will
     * result into the corresponding boolean values.
     * 
     * @param root
     *            The node to start the search.
     * @param path
     *            XPath search expression.
     * @return The boolean value of the node.
     * @throws ProcessingException
     *             If the node is not found.
     */
    public static boolean getValueOfNodeAsBoolean(XPathProcessor processor, Node root, String path)
            throws ProcessingException {
        String value = getValueOfNode(processor, root, path);
        if (value == null) {
            throw new ProcessingException("No such node: " + path);
        }
        return Boolean.valueOf(value).booleanValue();
    }
16772#/**
     * Get the boolean value of the node specified by the XPath. This works
     * similar to &lt;xsl:value-of&gt;. If the node exists and has a value this
     * value is converted to a boolean, e.g. "true" or "false" as value will
     * result into the corresponding boolean values. If the node does not exist,
     * the <CODE>defaultValue</CODE> is returned.
     * 
     * @param root
     *            The node to start the search.
     * @param path
     *            XPath search expression.
     * @param defaultValue
     *            Default boolean value.
     * @return The value of the node or <CODE>defaultValue</CODE>
     */
    public static boolean getValueOfNodeAsBoolean(XPathProcessor processor, Node root, String path, boolean defaultValue)
            throws ProcessingException {
        String value = getValueOfNode(processor, root, path);
        if (value != null) {
            return BooleanUtils.toBoolean(value);
        }
        return defaultValue;
    }
16773#/**
     * Get the value of the DOM node. The value of a node is the content of the
     * first text node. If the node has no text nodes, <code>null</code> is
     * returned.
     */
    public static String getValueOfNode(Node node) {
        if (node != null) {
            if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
                return node.getNodeValue();
            } else {
                node.normalize();
                NodeList childs = node.getChildNodes();
                int i = 0;
                int length = childs.getLength();
                while (i < length) {
                    if (childs.item(i).getNodeType() == Node.TEXT_NODE) {
                        return childs.item(i).getNodeValue().trim();
                    } else {
                        i++;
                    }
                }
            }
        }
        return null;
    }
16774#/**
     * Get the value of the node. The value of the node is the content of the
     * first text node. If the node has no text nodes the <CODE>defaultValue</CODE>
     * is returned.
     */
    public static String getValueOfNode(Node node, String defaultValue) {
        return StringUtils.defaultString(getValueOfNode(node), defaultValue);
    }
16775#/**
     * Set the value of the DOM node. All current children of the node are
     * removed and a new text node with the value is appended.
     */
    public static void setValueOfNode(Node node, String value) {
        if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
            node.setNodeValue(value);
        } else {
            while (node.hasChildNodes()) {
                node.removeChild(node.getFirstChild());
            }
            node.appendChild(node.getOwnerDocument().createTextNode(value));
        }
    }
16776#/**
     * Get a document fragment from a <code>Reader</code>. The reader must
     * provide valid XML, but it is allowed that the XML has more than one root
     * node. This xml is parsed by the specified parser instance and a DOM
     * DocumentFragment is created.
     */
    public static DocumentFragment getDocumentFragment(SAXParser parser, Reader stream) throws ProcessingException {
        DocumentFragment frag = null;

        Writer writer;
        Reader reader;
        boolean removeRoot = true;

        try {
            // create a writer,
            // write the root element, then the input from the
            // reader
            writer = new StringWriter();

            writer.write(XML_ROOT_DEFINITION);
            char[] cbuf = new char[16384];
            int len;
            do {
                len = stream.read(cbuf, 0, 16384);
                if (len != -1) {
                    writer.write(cbuf, 0, len);
                }
            } while (len != -1);
            writer.write("</root>");

            // now test if xml input start with <?xml
            String xml = writer.toString();
            String searchString = XML_ROOT_DEFINITION + "<?xml ";
            if (xml.startsWith(searchString)) {
                // now remove the surrounding root element
                xml = xml.substring(XML_ROOT_DEFINITION.length(), xml.length() - 7);
                removeRoot = false;
            }

            reader = new StringReader(xml);

            InputSource input = new InputSource(reader);

            DOMBuilder builder = new DOMBuilder();
            builder.startDocument();
            builder.startElement("", "root", "root", XMLUtils.EMPTY_ATTRIBUTES);

            IncludeXMLConsumer filter = new IncludeXMLConsumer(builder, builder);
            parser.parse(input, filter);

            builder.endElement("", "root", "root");
            builder.endDocument();

            // Create Document Fragment, remove <root>
            final Document doc = builder.getDocument();
            frag = doc.createDocumentFragment();
            final Node root = doc.getDocumentElement().getFirstChild();
            root.normalize();
            if (removeRoot == false) {
                root.getParentNode().removeChild(root);
                frag.appendChild(root);
            } else {
                Node child;
                while (root.hasChildNodes()) {
                    child = root.getFirstChild();
                    root.removeChild(child);
                    frag.appendChild(child);
                }
            }
        } catch (SAXException sax) {
            throw new ProcessingException("SAXException: " + sax, sax);
        } catch (IOException ioe) {
            throw new ProcessingException("IOException: " + ioe, ioe);
        }
        return frag;
    }
16777#/**
     * Create a parameter object from xml. The xml is flat and consists of
     * elements which all have exactly one text node: <parone>value_one<parone>
     * <partwo>value_two<partwo> A parameter can occur more than once with
     * different values. If <CODE>source</CODE> is not specified a new
     * parameter object is created otherwise the parameters are added to source.
     */
    public static SourceParameters createParameters(Node fragment, SourceParameters source) {
        SourceParameters par = (source == null ? new SourceParameters() : source);
        if (fragment != null) {
            NodeList childs = fragment.getChildNodes();
            if (childs != null) {
                Node current;
                for (int i = 0; i < childs.getLength(); i++) {
                    current = childs.item(i);

                    // only element nodes
                    if (current.getNodeType() == Node.ELEMENT_NODE) {
                        current.normalize();
                        NodeList valueChilds = current.getChildNodes();
                        String key;
                        StringBuffer valueBuffer;
                        String value;

                        key = current.getNodeName();
                        valueBuffer = new StringBuffer();
                        for (int m = 0; m < valueChilds.getLength(); m++) {
                            current = valueChilds.item(m); // attention: current is reused here!
                            if (current.getNodeType() == Node.TEXT_NODE) { // only text nodes
                                if (valueBuffer.length() > 0)
                                    valueBuffer.append(' ');
                                valueBuffer.append(current.getNodeValue());
                            }
                        }
                        value = valueBuffer.toString().trim();
                        if (key != null && value.length() > 0) {
                            par.setParameter(key, value);
                        }
                    }
                }
            }
        }
        return par;
    }
16778#/**
     * Create a string from a DOM document fragment. Only the top level text
     * nodes are chained together to build the text.
     */
    public static String createText(DocumentFragment fragment) {
        StringBuffer value = new StringBuffer();
        if (fragment != null) {
            NodeList childs = fragment.getChildNodes();
            if (childs != null) {
                Node current;

                for (int i = 0; i < childs.getLength(); i++) {
                    current = childs.item(i);

                    // only text nodes
                    if (current.getNodeType() == Node.TEXT_NODE) {
                        if (value.length() > 0)
                            value.append(' ');
                        value.append(current.getNodeValue());
                    }
                }
            }
        }
        return value.toString().trim();
    }
16779#/**
     * Compare all attributes of two elements. This method returns true only if
     * both nodes have the same number of attributes and the same attributes
     * with equal values. Namespace definition nodes are ignored
     */
    public static boolean compareAttributes(Element first, Element second) {
        NamedNodeMap attr1 = first.getAttributes();
        NamedNodeMap attr2 = second.getAttributes();
        String value;

        if (attr1 == null && attr2 == null)
            return true;
        int attr1Len = (attr1 == null ? 0 : attr1.getLength());
        int attr2Len = (attr2 == null ? 0 : attr2.getLength());
        if (attr1Len > 0) {
            int l = attr1.getLength();
            for (int i = 0; i < l; i++) {
                if (attr1.item(i).getNodeName().startsWith("xmlns:"))
                    attr1Len--;
            }
        }
        if (attr2Len > 0) {
            int l = attr2.getLength();
            for (int i = 0; i < l; i++) {
                if (attr2.item(i).getNodeName().startsWith("xmlns:"))
                    attr2Len--;
            }
        }
        if (attr1Len != attr2Len)
            return false;
        int i, l;
        int m, l2;
        i = 0;
        l = attr1.getLength();
        l2 = attr2.getLength();
        boolean ok = true;
        // each attribute of first must be in second with the same value
        while (i < l && ok) {
            value = attr1.item(i).getNodeName();
            if (value.startsWith("xmlns:") == false) {
                ok = false;
                m = 0;
                while (m < l2 && ok == false) {
                    if (attr2.item(m).getNodeName().equals(value)) {
                        // same name, same value?
                        ok = attr1.item(i).getNodeValue().equals(attr2.item(m).getNodeValue());
                    }
                    m++;
                }
            }

            i++;
        }
        return ok;
    }
16780#/**
     * Implementation for <code>String</code> : outputs characters
     * representing the value.
     * 
     * @param parent
     *            The node getting the value
     * @param text
     *            the value
     */
    public static void valueOf(Node parent, String text) throws ProcessingException {
        if (text != null) {
            parent.appendChild(parent.getOwnerDocument().createTextNode(text));
        }
    }
16781#/**
     * Implementation for <code>XMLizable</code> : outputs the value by
     * calling <code>v.toSax(contentHandler)</code>.
     * 
     * @param parent
     *            The node getting the value
     * @param v
     *            the XML fragment
     */
    public static void valueOf(Node parent, XMLizable v) throws ProcessingException {
        if (v != null) {
            DOMBuilder builder = new DOMBuilder(parent);
            try {
                v.toSAX(builder);
            } catch (SAXException e) {
                throw new ProcessingException(e);
            }
        }
    }
16782#/**
     * Implementation for <code>org.w3c.dom.Node</code> : converts the Node to
     * a SAX event stream.
     * 
     * @param parent
     *            The node getting the value
     * @param v
     *            the value
     */
    public static void valueOf(Node parent, Node v) throws ProcessingException {
        if (v != null) {
            parent.appendChild(parent.getOwnerDocument().importNode(v, true));
        }
    }
16783#/**
     * Implementation for <code>java.util.Collection</code> : outputs the
     * value by calling {@link #valueOf(Node, Object)} on each element of the
     * collection.
     * 
     * @param parent
     *            The node getting the value
     * @param v
     *            the XML fragment
     */
    public static void valueOf(Node parent, Collection v) throws ProcessingException {
        if (v != null) {
            Iterator iterator = v.iterator();
            while (iterator.hasNext()) {
                valueOf(parent, iterator.next());
            }
        }
    }
16784#/**
     * Implementation for <code>java.util.Map</code> : For each entry an
     * element is created with the childs key and value Outputs the value and
     * the key by calling {@link #valueOf(Node, Object)} on each value and key
     * of the Map.
     * 
     * @param parent
     *            The node getting the value
     * @param v
     *            the Map
     */
    public static void valueOf(Node parent, Map v) throws ProcessingException {
        if (v != null) {
            Node mapNode = parent.getOwnerDocument().createElementNS(null, "java.util.map");
            parent.appendChild(mapNode);
            for (Iterator iter = v.entrySet().iterator(); iter.hasNext();) {
                final Map.Entry me = (Map.Entry) iter.next();

                Node entryNode = mapNode.getOwnerDocument().createElementNS(null, "entry");
                mapNode.appendChild(entryNode);

                Node keyNode = entryNode.getOwnerDocument().createElementNS(null, "key");
                entryNode.appendChild(keyNode);
                valueOf(keyNode, me.getKey());

                Node valueNode = entryNode.getOwnerDocument().createElementNS(null, "value");
                entryNode.appendChild(valueNode);
                valueOf(valueNode, me.getValue());
            }
        }
    }
16785#/**
     * Implementation for <code>Object</code> depending on its class :
     * <ul>
     * <li>if it's an array, call {@link #valueOf(Node, Object)} on all its
     * elements,</li>
     * <li>if it's class has a specific {@link #valueOf(Node, Object)}
     * implementation, use it,</li>
     * <li>else, output it's string representation.</li>
     * </ul>
     * 
     * @param parent
     *            The node getting the value
     * @param v
     *            the value
     */
    public static void valueOf(Node parent, Object v) throws ProcessingException {
        if (v == null) {
            return;
        }

        // Array: recurse over each element
        if (v.getClass().isArray()) {
            Object[] elements = (Object[]) v;

            for (int i = 0; i < elements.length; i++) {
                valueOf(parent, elements[i]);
            }
            return;
        }

        // Check handled object types in case they were not typed in the XSP

        // XMLizable
        if (v instanceof XMLizable) {
            valueOf(parent, (XMLizable) v);
            return;
        }

        // Node
        if (v instanceof Node) {
            valueOf(parent, (Node) v);
            return;
        }

        // Collection
        if (v instanceof Collection) {
            valueOf(parent, (Collection) v);
            return;
        }

        // Map
        if (v instanceof Map) {
            valueOf(parent, (Map) v);
            return;
        }

        // Give up: hope it's a string or has a meaningful string representation
        valueOf(parent, String.valueOf(v));
    }
16786#/**
     * Use an XPath string to select a single node. XPath namespace prefixes are
     * resolved from the context node, which may not be what you want (see the
     * next method).
     * 
     * @param contextNode
     *            The node to start searching from.
     * @param str
     *            A valid XPath string.
     * @param processor
     *            The XPath processor to use
     * @return The first node found that matches the XPath, or null.
     * 
     * @throws TransformerException
     */
    public static Node getSingleNode(Node contextNode, String str, XPathProcessor processor)
            throws TransformerException {
        String[] pathComponents = buildPathArray(str);
        if (pathComponents == null) {
            return processor.selectSingleNode(contextNode, str);
        } else {
            return getFirstNodeFromPath(contextNode, pathComponents, false);
        }
    }
16787#/**
     * Return the <CODE>Node</CODE> from the DOM Node <CODE>rootNode</CODE>
     * using the XPath expression <CODE>path</CODE>. If the node does not
     * exist, it is created and then returned. This is a very simple method for
     * creating new nodes. If the XPath contains selectors ([,,,]) or "*" it is
     * of course not possible to create the new node. So if you use such XPaths
     * the node must exist beforehand. An simple exception is if the expression
     * contains attribute test to values (e.g. [@id = 'du' and
     * 
     * @number = 'you'], the attributes with the given values are added. The
     *         attributes must be separated with 'and'. Another problem are
     *         namespaces: XPath requires sometimes selectors for namespaces,
     *         e.g. : /*[namespace-uri()="uri" and local-name()="name"] Creating
     *         such a node with a namespace is not possible right now as we use
     *         a very simple XPath parser which is not able to parse all kinds
     *         of selectors correctly.
     * 
     * @param rootNode
     *            The node to start the search.
     * @param path
     *            XPath expression for searching the node.
     * @param processor
     *            The XPath processor to use
     * @return The node specified by the path.
     * @throws ProcessingException
     *             If no path is specified or the XPath engine fails.
     */
    public static Node selectSingleNode(Node rootNode, String path, XPathProcessor processor)
            throws ProcessingException {
        // Now we have to parse the string
        // First test: path? rootNode?
        if (path == null) {
            throw new ProcessingException(XPATH_IS_REQUIRED);
        }
        if (rootNode == null)
            return rootNode;

        if (path.length() == 0 || path.equals("/"))
            return rootNode;

        // now the first "quick" test is if the node exists using the
        // full XPathAPI
        try {
            Node testNode = getSingleNode(rootNode, path, processor);
            if (testNode != null)
                return testNode;
        } catch (TransformerException local) {
            throw new ProcessingException("Transforming exception during selectSingleNode with path: '" + path
                    + "'. Exception: " + local, local);
        }

        // remove leading "/" oon both ends
        path = StringUtils.strip(path, "/");

        // now step through the nodes!
        Node parent = rootNode;
        int pos;
        int posSelector;
        do {
            pos = path.indexOf("/"); // get next separator
            posSelector = path.indexOf("[");
            if (posSelector != -1 && posSelector < pos) {
                posSelector = path.indexOf("]");
                pos = path.indexOf("/", posSelector);
            }

            String nodeName;
            boolean isAttribute = false;
            if (pos != -1) { // found separator
                nodeName = path.substring(0, pos); // string until "/"
                path = path.substring(pos + 1); // rest of string after "/"
            } else {
                nodeName = path;
            }

            // test for attribute spec
            if (nodeName.startsWith("@")) {
                isAttribute = true;
            }

            Node singleNode;
            try {
                singleNode = getSingleNode(parent, nodeName, processor);
            } catch (TransformerException localException) {
                throw new ProcessingException("XPathUtil.selectSingleNode: " + localException.getMessage(),
                        localException);
            }

            // create node if necessary
            if (singleNode == null) {
                Node newNode;
                // delete XPath selectors
                int posSelect = nodeName.indexOf("[");
                String XPathExp = null;
                if (posSelect != -1) {
                    XPathExp = nodeName.substring(posSelect + 1, nodeName.length() - 1);
                    nodeName = nodeName.substring(0, posSelect);
                }
                if (isAttribute) {
                    try {
                        newNode = getOwnerDocument(rootNode).createAttributeNS(null, nodeName.substring(1));
                        ((Element) parent).setAttributeNodeNS((org.w3c.dom.Attr) newNode);
                        parent = newNode;
                    } catch (DOMException local) {
                        throw new ProcessingException("Unable to create new DOM node: '" + nodeName + "'.", local);
                    }
                } else {
                    try {
                        newNode = getOwnerDocument(rootNode).createElementNS(null, nodeName);
                    } catch (DOMException local) {
                        throw new ProcessingException("Unable to create new DOM node: '" + nodeName + "'.", local);
                    }
                    if (XPathExp != null) {
                        java.util.List attrValuePairs = new java.util.ArrayList(4);
                        boolean noError = true;

                        String attr;
                        String value;
                        // scan for attributes
                        StringTokenizer tokenizer = new StringTokenizer(XPathExp, "= ");
                        while (tokenizer.hasMoreTokens()) {
                            attr = tokenizer.nextToken();
                            if (attr.startsWith("@")) {
                                if (tokenizer.hasMoreTokens()) {
                                    value = tokenizer.nextToken();
                                    if (value.startsWith("'") && value.endsWith("'"))
                                        value = value.substring(1, value.length() - 1);
                                    if (value.startsWith("\"") && value.endsWith("\""))
                                        value = value.substring(1, value.length() - 1);
                                    attrValuePairs.add(attr.substring(1));
                                    attrValuePairs.add(value);
                                } else {
                                    noError = false;
                                }
                            } else if (attr.trim().equals("and") == false) {
                                noError = false;
                            }
                        }
                        if (noError) {
                            for (int l = 0; l < attrValuePairs.size(); l = l + 2) {
                                ((Element) newNode).setAttributeNS(null, (String) attrValuePairs.get(l),
                                        (String) attrValuePairs.get(l + 1));
                            }
                        }
                    }
                    parent.appendChild(newNode);
                    parent = newNode;
                }
            } else {
                parent = singleNode;
            }
        }
        while (pos != -1);
        return parent;
    }
16788#/**
     * Get the value of the node specified by the XPath. This works similar to
     * &lt;xsl:value-of&gt;. If the node does not exist <CODE>null</CODE> is
     * returned.
     * 
     * @param root
     *            The node to start the search.
     * @param path
     *            XPath search expression.
     * @param processor
     *            The XPath processor to use
     * @return The value of the node or <CODE>null</CODE>
     */
    public static String getValueOf(Node root, String path, XPathProcessor processor) throws ProcessingException {
        if (path == null) {
            throw new ProcessingException(XPATH_IS_REQUIRED);
        }
        if (root == null)
            return null;
        path = StringUtils.strip(path, "/");

        try {
            Node node = getSingleNode(root, path, processor);
            if (node != null) {
                return getValueOfNode(node);
            }
        } catch (TransformerException localException) {
            throw new ProcessingException("XPathUtil.selectSingleNode: " + localException.getMessage(), localException);
        }
        return null;
    }
16789#/**
     * Get the value of the node specified by the XPath.
     * This works similar to xsl:value-of. If the node is not found
     * the <CODE>defaultValue</CODE> is returned.
     * 
     * @param root
     *            The node to start the search.
     * @param path
     *            XPath search expression.
     * @param defaultValue
     *            The default value if the node does not exist.
     * @param processor
     *            The XPath Processor
     * @return The value of the node or <CODE>defaultValue</CODE>
     */
    public static String getValueOf(Node root, String path, String defaultValue, XPathProcessor processor)
            throws ProcessingException {
        String value = getValueOf(root, path, processor);
        if (value == null) {
            value = defaultValue;
        }
        return value;
    }
16790#/**
     * Get the boolean value of the node specified by the XPath.
     * This works similar to xsl:value-of. If the node exists and has a value
     * this value is converted to a boolean, e.g. "true" or "false" as value
     * will result into the corresponding boolean values.
     * 
     * @param root
     *            The node to start the search.
     * @param path
     *            XPath search expression.
     * @param processor
     *            The XPath Processor
     * @return The boolean value of the node.
     * @throws ProcessingException
     *             If the node is not found.
     */
    public static boolean getValueAsBooleanOf(Node root, String path, XPathProcessor processor)
            throws ProcessingException {
        String value = getValueOf(root, path, processor);
        if (value == null) {
            throw new ProcessingException("No such node: " + path);
        }
        return Boolean.valueOf(value).booleanValue();
    }
16791#/**
     * Get the boolean value of the node specified by the XPath.
     * This works similar to xsl:value-of. If the node exists and has a value
     * this value is converted to a boolean, e.g. "true" or "false" as value
     * will result into the corresponding boolean values.
     * If the node does not exist, the <CODE>defaultValue</CODE> is returned.
     * 
     * @param root
     *            The node to start the search.
     * @param path
     *            XPath search expression.
     * @param defaultValue
     *            Default boolean value.
     * @param processor
     *            The XPath Processor
     * @return The value of the node or <CODE>defaultValue</CODE>
     */
    public static boolean getValueAsBooleanOf(Node root, String path, boolean defaultValue, XPathProcessor processor)
            throws ProcessingException {
        String value = getValueOf(root, path, processor);
        if (value != null) {
            return Boolean.valueOf(value).booleanValue();
        }
        return defaultValue;
    }
16792#/**
     * Create a new empty DOM document.
     */
    public static Document createDocument() throws ProcessingException {
        try {
            DocumentBuilderFactory documentFactory = DocumentBuilderFactory.newInstance();
            documentFactory.setNamespaceAware(true);
            documentFactory.setValidating(false);
            DocumentBuilder docBuilder = documentFactory.newDocumentBuilder();
            return docBuilder.newDocument();
        } catch (ParserConfigurationException pce) {
            throw new ProcessingException("Creating document failed.", pce);
        }
    }
16793#/**
     *  Use an XPath string to select a nodelist.
     *  XPath namespace prefixes are resolved from the contextNode.
     * 
     * @param contextNode
     *            The node to start searching from.
     * @param str
     *            A valid XPath string.
     * @param processor
     *            The XPath Processor
     * @return A NodeIterator, should never be null.
     * 
     * @throws TransformerException
     */
    public static NodeList selectNodeList(Node contextNode, String str, XPathProcessor processor)
            throws TransformerException {
        String[] pathComponents = buildPathArray(str);
        if (pathComponents != null) {
            return getNodeListFromPath(contextNode, pathComponents);
        }
        return processor.selectNodeList(contextNode, str);
    }
16794#/**
     * Build the input for the get...FromPath methods. If the XPath expression
     * cannot be handled by the methods, <code>null</code> is returned.
     */
    public static String[] buildPathArray(String xpath) {
        String[] result = null;
        if (xpath != null && xpath.charAt(0) != '/') {
            // test
            int components = 1;
            int i, l;
            l = xpath.length();
            boolean found = false;
            i = 0;
            while (i < l && found == false) {
                switch (xpath.charAt(i)) {
                case '[':
                    found = true;
                    break;
                case '(':
                    found = true;
                    break;
                case '*':
                    found = true;
                    break;
                case '@':
                    found = true;
                    break;
                case ':':
                    found = true;
                    break;
                case '/':
                    components++;
                default:
                    i++;
                }
            }
            if (found == false) {
                result = new String[components];
                if (components == 1) {
                    result[components - 1] = xpath;
                } else {
                    i = 0;
                    int start = 0;
                    components = 0;
                    while (i < l) {
                        if (xpath.charAt(i) == '/') {
                            result[components] = xpath.substring(start, i);
                            start = i + 1;
                            components++;
                        }
                        i++;
                    }
                    result[components] = xpath.substring(start);
                }
            }
        }
        return result;
    }
16795#/**
     * Use a path to select the first occurence of a node. The namespace of a
     * node is ignored!
     * 
     * @param contextNode
     *            The node starting the search.
     * @param path
     *            The path to search the node. The contextNode is searched for a
     *            child named path[0], this node is searched for a child named
     *            path[1]...
     * @param create
     *            If a child with the corresponding name is not found and create
     *            is set, this node will be created.
     */
    public static Node getFirstNodeFromPath(Node contextNode, final String[] path, final boolean create) {
        if (contextNode == null || path == null || path.length == 0)
            return contextNode;
        // first test if the node exists
        Node item = getFirstNodeFromPath(contextNode, path, 0);
        if (item == null && create) {
            int i = 0;
            NodeList childs;
            boolean found;
            int m, l;
            while (contextNode != null && i < path.length) {
                childs = contextNode.getChildNodes();
                found = false;
                if (childs != null) {
                    m = 0;
                    l = childs.getLength();
                    while (found == false && m < l) {
                        item = childs.item(m);
                        if (item.getNodeType() == Node.ELEMENT_NODE && item.getLocalName().equals(path[i])) {
                            found = true;
                            contextNode = item;
                        }
                        m++;
                    }
                }
                if (found == false) {
                    Element e = contextNode.getOwnerDocument().createElementNS(null, path[i]);
                    contextNode.appendChild(e);
                    contextNode = e;
                }
                i++;
            }
            item = contextNode;
        }
        return item;
    }
16796#/**
     * Private helper method for getFirstNodeFromPath()
     */
    private static Node getFirstNodeFromPath(final Node contextNode, final String[] path, final int startIndex) {
        int i = 0;
        NodeList childs;
        boolean found;
        int l;
        Node item = null;

        childs = contextNode.getChildNodes();
        found = false;
        if (childs != null) {
            i = 0;
            l = childs.getLength();
            while (found == false && i < l) {
                item = childs.item(i);
                if (item.getNodeType() == Node.ELEMENT_NODE
                        && path[startIndex].equals(item.getLocalName() != null ? item.getLocalName() : item
                                .getNodeName())) {
                    if (startIndex == path.length - 1) {
                        found = true;
                    } else {
                        item = getFirstNodeFromPath(item, path, startIndex + 1);
                        if (item != null)
                            found = true;
                    }
                }
                if (found == false) {
                    i++;
                }
            }
            if (found == false) {
                item = null;
            }
        }
        return item;
    }
16797#/**
     * Use a path to select all occurences of a node. The namespace of a node is
     * ignored!
     * 
     * @param contextNode
     *            The node starting the search.
     * @param path
     *            The path to search the node. The contextNode is searched for a
     *            child named path[0], this node is searched for a child named
     *            path[1]...
     */
    public static NodeList getNodeListFromPath(Node contextNode, String[] path) {
        if (contextNode == null)
            return new NodeListImpl();
        if (path == null || path.length == 0) {
            return new NodeListImpl(new Node[] { contextNode });
        }
        NodeListImpl result = new NodeListImpl();
        try {
            getNodesFromPath(result, contextNode, path, 0);
        } catch (NullPointerException npe) {
            // this NPE is thrown because the parser is not configured
            // to use DOM Level 2
            throw new NullPointerException("XMLUtil.getNodeListFromPath() did catch a NullPointerException."
                    + "This might be due to a missconfigured XML parser which does not use DOM Level 2."
                    + "Make sure that you use the XML parser shipped with Cocoon.");
        }
        return result;
    }
16798#/**
     * Helper method for getNodeListFromPath()
     */
    private static void getNodesFromPath(final NodeListImpl result, final Node contextNode, final String[] path,
            final int startIndex) {
        final NodeList childs = contextNode.getChildNodes();
        int m, l;
        Node item;
        if (startIndex == (path.length - 1)) {
            if (childs != null) {
                m = 0;
                l = childs.getLength();
                while (m < l) {
                    item = childs.item(m);
                    if (item.getNodeType() == Node.ELEMENT_NODE) {
                        // Work around: org.apache.xerces.dom.ElementImpl
                        // doesn't handle getLocalName() correct
                        if (path[startIndex].equals(item.getLocalName() != null ? item.getLocalName() : item
                                .getNodeName())) {
                            result.addNode(item);
                        }
                    }
                    m++;
                }
            }
        } else {
            if (childs != null) {
                m = 0;
                l = childs.getLength();
                while (m < l) {
                    item = childs.item(m);
                    if (item.getNodeType() == Node.ELEMENT_NODE) {
                        // Work around: org.apache.xerces.dom.ElementImpl
                        // doesn't handle getLocalName() correct
                        if (path[startIndex].equals(item.getLocalName() != null ? item.getLocalName() : item
                                .getNodeName())) {
                            getNodesFromPath(result, item, path, startIndex + 1);
                        }
                    }
                    m++;
                }
            }
        }
    }
16799#/**
     * Creates a W3C Document that remembers the location of each element in
     * the source file. The location of element nodes can then be retrieved
     * using the {@link #getLocation(Element)} method.
     *
     * @param inputSource the inputSource to read the document from
     */
    public static Document parse(InputSource inputSource)
    throws SAXException, SAXNotSupportedException, IOException {
        try {
            final XMLReader parser = saxFactory.newSAXParser().getXMLReader();
            final DOMBuilder builder = new DOMBuilder();
            
            // Enhance the sax stream with location information
            final ContentHandler locationHandler = new LocationAttributes.Pipe(builder);
            parser.setContentHandler(locationHandler);
    
            parser.parse(inputSource);
            
            return builder.getDocument();
        } catch (ParserConfigurationException pce) {
            throw new SAXException(pce);
        }
    }
16800#public static Location getLocationObject(Element element) {
        return LocationAttributes.getLocation(element);
    }
16801#/**
     * Retrieves the location of an element node in the source file from which
     * the Document was created. This will only work for Document's created
     * with the method {@link #parse(InputSource, ServiceManager)} of this class.
     */
    public static String getLocation(Element element) {
        return LocationAttributes.getLocationString(element);
    }
16802#public static String getSystemIdLocation(Element element) {
        return LocationAttributes.getURI(element);
    }
16803#public static int getLineLocation(Element element) {
        return LocationAttributes.getLine(element);
    }
16804#public static int getColumnLocation(Element element) {
        return LocationAttributes.getColumn(element);
    }
16805#/**
     * Returns all Element children of an Element that belong to the given
     * namespace.
     */
    public static Element[] getChildElements(Element element, String namespace) {
        ArrayList elements = new ArrayList();
        NodeList nodeList = element.getChildNodes();
        for (int i = 0; i < nodeList.getLength(); i++) {
            Node node = nodeList.item(i);
            if (node instanceof Element
                    && namespace.equals(node.getNamespaceURI()))
                elements.add(node);
        }
        return (Element[])elements.toArray(new Element[elements.size()]);
    }
16806#/**
     * Returns all Element children of an Element that belong to the given
     * namespace and have the given local name.
     */
    public static Element[] getChildElements(Element element,
            String namespace, String localName) {
        ArrayList elements = new ArrayList();
        NodeList nodeList = element.getChildNodes();
        for (int i = 0; i < nodeList.getLength(); i++) {
            Node node = nodeList.item(i);
            if (node instanceof Element
                    && namespace.equals(node.getNamespaceURI()) 
                    && localName.equals(node.getLocalName())) {
                elements.add(node);
            }
        }
        return (Element[])elements.toArray(new Element[elements.size()]);
    }
16807#/**
     * Returns the first child element with the given namespace and localName,
     * or null if there is no such element.
     */
    public static Element getChildElement(Element element, String namespace, 
            String localName) {
        Element node = null;
        try {
            node = getChildElement(element, namespace, localName, false);
        } catch (Exception e) {
            node = null;
        }
        return node;
    }
16808#/**
     * Returns the first child element with the given namespace and localName,
     * or null if there is no such element and required flag is unset or
     * throws an Exception if the "required" flag is set.
     */
    public static Element getChildElement(Element element, String namespace, 
            String localName, boolean required) throws Exception {
        NodeList nodeList = element.getChildNodes();
        for (int i = 0; i < nodeList.getLength(); i++) {
            Node node = nodeList.item(i);
            if (node instanceof Element
                    && namespace.equals(node.getNamespaceURI()) 
                    && localName.equals(node.getLocalName())) {
                return (Element)node;
            }
        }
        if (required) {
            throw new Exception("Missing element \"" + localName +
                    "\" as child of element \"" + element.getTagName() + 
                    "\" at " + DomHelper.getLocation(element));
        } else {
            return null;
        }
    }
16809#/**
     * Returns the value of an element's attribute, but throws an exception
     * if the element has no such attribute.
     */
    public static String getAttribute(Element element, String attributeName)
            throws Exception {
        String attrValue = element.getAttribute(attributeName);
        if (attrValue.length() == 0) {
            throw new Exception("Missing attribute \"" + attributeName + 
                    "\" on element \"" + element.getTagName() + 
                    "\" at " + getLocation(element));
        }
        return attrValue;
    }
16810#/**
     * Returns the value of an element's attribute, or a default value if the 
     * element has no such attribute.
     */
    public static String getAttribute(Element element, String attributeName, 
            String defaultValue) {
        String attrValue = element.getAttribute(attributeName);
        if (attrValue.length() == 0) {
            return defaultValue;
        }
        return attrValue;
    }
16811#public static int getAttributeAsInteger(Element element, 
            String attributeName) throws Exception {
        String attrValue = getAttribute(element, attributeName);
        try {
            return Integer.parseInt(attrValue);
        } catch (NumberFormatException e) {
            throw new Exception("Cannot parse the value \"" + attrValue + 
                    "\" as an integer in the attribute \"" + attributeName + 
                    "\" on the element \"" + element.getTagName() + 
                    "\" at " + getLocation(element));
        }
    }
16812#public static int getAttributeAsInteger(Element element, 
            String attributeName, int defaultValue) throws Exception {
        String attrValue = element.getAttribute(attributeName);
        if (attrValue.length() == 0) {
            return defaultValue;
        } else {
            try {
                return Integer.parseInt(attrValue);
            } catch (NumberFormatException e) {
                throw new Exception("Cannot parse the value \"" + attrValue + 
                        "\" as an integer in the attribute \"" + 
                        attributeName + "\" on the element \"" +
                        element.getTagName() + "\" at " +
                        getLocation(element));
            }
        }
    }
16813#public static boolean getAttributeAsBoolean(Element element, 
                String attributeName, boolean defaultValue) {
        String attrValue = element.getAttribute(attributeName);
        Boolean result;
        try {
            result = BooleanUtils.toBooleanObject(attrValue, "true", "false", null);
        } catch (IllegalArgumentException iae) {
            result = null;
        }
        if (result != null) {
            return result.booleanValue();
        }
        try {
            result = BooleanUtils.toBooleanObject(attrValue, "yes", "no", null);
        } catch (IllegalArgumentException iae) {
            result = null;
        }
        if (result != null) {
            return result.booleanValue();
        }
        return defaultValue;    
    }
16814#public static String getElementText(Element element) {
        StringBuffer value = new StringBuffer();
        NodeList nodeList = element.getChildNodes();
        for (int i = 0; i < nodeList.getLength(); i++) {
            Node node = nodeList.item(i);
            if (node instanceof Text || node instanceof CDATASection) {
                value.append(node.getNodeValue());
            }
        }
        return value.toString();
    }
16815#/**
     * Returns the content of the given Element as an object implementing the
     * XMLizable interface. Practically speaking, the implementation uses the
     * {@link SaxBuffer} class. The XMLizable object will be a standalone blurb
     * of SAX events, not producing start/endDocument calls and containing all
     * necessary namespace declarations.
     */
    public static XMLizable compileElementContent(Element element) {
        // Remove location information
        LocationAttributes.remove(element, true);

        SaxBuffer saxBuffer = new SaxBuffer();
        DOMStreamer domStreamer = new DOMStreamer();
        domStreamer.setContentHandler(saxBuffer);

        NodeList childNodes = element.getChildNodes();
        for (int i = 0; i < childNodes.getLength(); i++) {
            try {
                domStreamer.stream(childNodes.item(i));
            } catch (SAXException e) {
                // It's unlikely that an exception will occur here,
                // so use a runtime exception
                throw new RuntimeException(
                        "Error in DomHelper.compileElementContent: " + 
                        e.toString());
            }
        }
        return saxBuffer;
    }
16816#public static Map getLocalNSDeclarations(Element elm) {
        return addLocalNSDeclarations(elm, null);
    }
16817#private static Map addLocalNSDeclarations(Element elm, Map nsDeclarations) {
        NamedNodeMap atts = elm.getAttributes();
        int attsSize = atts.getLength();

        for (int i = 0; i < attsSize; i++)
        {
            Attr attr = (Attr)atts.item(i);
            if (XMLNS_URI.equals(attr.getNamespaceURI()))
            {
                String nsUri = attr.getValue();
                String pfx = attr.getLocalName();
                if (nsDeclarations == null)
                    nsDeclarations = new HashMap();
                nsDeclarations.put(nsUri, pfx);
            }
        }        
        return nsDeclarations;    }
16818#public static Map getInheritedNSDeclarations(Element elm) {
        List ancestorsAndSelf = new LinkedList();
        Element current = elm;
        while (current != null) {
            ancestorsAndSelf.add(current);
            Node parent = current.getParentNode();
            if (parent.getNodeType() == Node.ELEMENT_NODE)
                current = (Element)parent;
            else 
                current = null;
        }
        
        Map nsDeclarations = null;
        ListIterator iter = ancestorsAndSelf.listIterator(ancestorsAndSelf.size());
        while (iter.hasPrevious()) {
            Element element = (Element) iter.previous();
            nsDeclarations = addLocalNSDeclarations(element, nsDeclarations);
        }
        
        return nsDeclarations;
    }
16819#/**
     * Construct a new instance of this DOMBuilder.
     */
    public DOMBuilder() {
        this((Listener) null, (Node) null);
    }
16820#/**
     * Construct a new instance of this DOMBuilder.
     */
    public DOMBuilder(SAXTransformerFactory factory) {
        this(factory, null, null);
    }
16821#/**
     * Construct a new instance of this DOMBuilder.
     */
    public DOMBuilder(Listener listener) {
        this(listener, null);
    }
16822#/**
     * Constructs a new instance that appends nodes to the given parent node.
     * <br/>
     * <strong>Note:</strong> You cannot use a <code>Listener<code> when appending to a
     * <code>Node</code>, because the notification occurs at <code>endDocument()</code>
     * which does not happen here.
     */
    public DOMBuilder(Node parentNode) {
        this(null, parentNode);
    }
16823#/**
     * Construct a new instance of this DOMBuilder.
     */
    public DOMBuilder(Listener listener, Node parentNode) {
        this((SAXTransformerFactory) null, listener, parentNode);
    }
16824#/**
     * Construct a new instance of this DOMBuilder.
     */
    public DOMBuilder(SAXTransformerFactory factory, Listener listener, Node parentNode) {
        super();
        this.factory = factory == null? FACTORY: factory;
        this.listener = listener;
        this.parentNode = parentNode;
        setup();
    }
16825#/**
     * Setup this instance transformer and result objects.
     */
    private void setup() {
        try {
            TransformerHandler handler = this.factory.newTransformerHandler();
            setContentHandler(handler);
            setLexicalHandler(handler);
            if (this.parentNode != null) {
                this.result = new DOMResult(this.parentNode);
            } else {
                this.result = new DOMResult();
            }
            handler.setResult(this.result);
        } catch (javax.xml.transform.TransformerException local) {
            throw new CascadingRuntimeException("Fatal-Error: Unable to get transformer handler", local);
        }
    }
16826#/**
     * Recycle this builder, prepare for re-use.
     */
    public void recycle() {
        super.recycle();
        setup();
    }
16827#/**
     * Return the newly built Document.
     */
    public Document getDocument() {
        if (this.result == null || this.result.getNode() == null) {
            return null;
        } else if (this.result.getNode().getNodeType() == Node.DOCUMENT_NODE) {
            return (Document) this.result.getNode();
        } else {
            return this.result.getNode().getOwnerDocument();
        }
    }
16828#/**
     * Receive notification of the end of a document.
     *
     * @exception SAXException If this method was not called appropriately.
     */
    public void endDocument() throws SAXException {
        super.endDocument();
        // Notify the listener
        notifyListener();
    }
16829#/**
     * Receive notification of a successfully completed DOM tree generation.
     */
    protected void notifyListener() throws SAXException {
        if (this.listener != null) {
            this.listener.notify(getDocument());
        }
    }
16830#/**
         * Receive notification of a successfully completed DOM tree generation.
         */
        void notify(Document doc) throws SAXException;
16831#/**
     * Create a new <code>DOMStreamer</code> instance.
     */
    public DOMStreamer() {
        super();
    }
16832#/**
     * Create a new <code>DOMStreamer</code> instance.
     */
    public DOMStreamer(ContentHandler content, LexicalHandler lexical) {
        this();
        setContentHandler(content);
        setLexicalHandler(lexical);
    }
16833#/**
     * Create a new <code>DOMStreamer</code> instance.
     */
    public DOMStreamer(XMLConsumer consumer) {
        this(consumer, consumer);
    }
16834#/**
     * Create a new <code>DOMStreamer</code> instance.
     */
    public DOMStreamer(ContentHandler content) {
        this(content, content instanceof LexicalHandler ? (LexicalHandler) content : null);
    }
16835#/**
     * Set the <code>XMLConsumer</code> that will receive XML data.
     */
    public void setConsumer(XMLConsumer consumer) {
        setContentHandler(consumer);
        setLexicalHandler(consumer);
    }
16836#/**
     * Set the <code>ContentHandler</code> that will receive XML data.
     */
    public void setContentHandler(ContentHandler handler) {
        defaultDOMStreamer.setContentHandler(handler);
        namespaceNormalizingDOMStreamer.setContentHandler(handler);
    }
16837#/**
     * Set the <code>LexicalHandler</code> that will receive XML data.
     */
    public void setLexicalHandler(LexicalHandler handler) {
        defaultDOMStreamer.setLexicalHandler(handler);
        namespaceNormalizingDOMStreamer.setLexicalHandler(handler);
    }
16838#/**
     * Start the production of SAX events.
     */
    public void stream(Node node) throws SAXException {
        if (normalizeNamespaces) {
            namespaceNormalizingDOMStreamer.stream(node);
        } else {
            defaultDOMStreamer.stream(node);
        }
    }
16839#public boolean isNormalizeNamespaces() {
        return normalizeNamespaces;
    }
16840#public void setNormalizeNamespaces(boolean normalizeNamespaces) {
        this.normalizeNamespaces = normalizeNamespaces;
    }
16841#public void recycle() {
        defaultDOMStreamer.recycle();
        namespaceNormalizingDOMStreamer.recycle();
        normalizeNamespaces = DEFAULT_NORMALIZE_NAMESPACES;
    }
16842#public void recycle() {
            super.recycle();
            currentElementInfo = null;
            newPrefixCounter = 0;
        }
16843#/**
         * Start the production of SAX events.
         *
         * <p>Perform a pre-order traversal non-recursive style.
         *
         * <p>Note that TreeWalker assumes that the subtree is intended to represent
         * a complete (though not necessarily well-formed) document and, during a
         * traversal, startDocument and endDocument will always be issued to the
         * SAX listener.
         *
         * @param pos Node in the tree where to start traversal
         */
        protected void stream(Node pos) throws SAXException {

            // Start document only if we're streaming a document
            boolean isDoc = (pos.getNodeType() == Node.DOCUMENT_NODE);
            if (isDoc) {
              contentHandler.startDocument();
            }

            Node top = pos;
            while (null != pos) {
                startNode(pos);

                Node nextNode = pos.getFirstChild();
                while (null == nextNode) {
                    endNode(pos);

                    if (top.equals(pos)) {
                        break;
                    }

                    nextNode = pos.getNextSibling();
                    if (null == nextNode) {
                        pos = pos.getParentNode();

                        if ((null == pos) || (top.equals(pos))) {
                            if (null != pos) {
                                endNode(pos);
                            }
                            nextNode = null;

                            break;
                        }
                    }
                }

                pos = nextNode;
            }

            if (isDoc) {
            	contentHandler.endDocument();
            }
        }
16844#private final void dispatchChars(Node node) throws SAXException {
            final String data = ((Text) node).getData();
            if ( data != null ) {
                contentHandler.characters(data.toCharArray(), 0, data.length());
            }
        }
16845#/**
         * Start processing given node
         *
         * @param node Node to process
         */
        protected void startNode(Node node) throws SAXException {

            switch (node.getNodeType()) {
                case Node.COMMENT_NODE:
                    {
                        if (lexicalHandler != null) {
                            final String data = ((Comment) node).getData();
                            if ( data != null ) {
                                lexicalHandler.comment(data.toCharArray(), 0, data.length());
                            }
                        }
                    }
                    break;
                case Node.DOCUMENT_FRAGMENT_NODE:
                    // ??;
                case Node.DOCUMENT_NODE:
                    break;
                case Node.ELEMENT_NODE:
                    NamedNodeMap atts = node.getAttributes();
                    int nAttrs = atts.getLength();

                    // create a list of localy declared namespace prefixes
                    currentElementInfo = new NamespaceNormalizingDOMStreamer.ElementInfo(currentElementInfo);
                    for (int i = 0; i < nAttrs; i++) {
                        Node attr = atts.item(i);
                        String attrName = attr.getNodeName();

                        if (attrName.equals("xmlns") || attrName.startsWith("xmlns:")) {
                            int index;
                            String prefix = (index = attrName.indexOf(":")) < 0
                                    ? "" : attrName.substring(index + 1);

                            currentElementInfo.put(prefix, attr.getNodeValue());
                        }
                    }

                    String namespaceURI = node.getNamespaceURI();
                    String prefix = node.getPrefix();
                    String localName = node.getLocalName();

                    if (localName == null) {
                        // this is an element created with createElement instead of createElementNS
                        String[] prefixAndLocalName = getPrefixAndLocalName(node.getNodeName());
                        prefix = prefixAndLocalName[0];
                        localName = prefixAndLocalName[1];
                        // note: if prefix is null, there can still be a default namespace...
                        namespaceURI = getNamespaceForPrefix(prefix, (Element)node);
                    }

                    if (namespaceURI != null) {
                        // no prefix means: make this the default namespace
                        if (prefix == null) {
                            prefix = "";
                        }
                        // check that is declared
                        String uri = currentElementInfo.findNamespaceURI(prefix);
                        if (StringUtils.equals(uri, namespaceURI)) {
                            // System.out.println("namespace is declared");
                            // prefix is declared correctly, do nothing
                            //} else if (uri != null) {
                            // System.out.println("prefix is declared with other namespace, overwriting it");
                            // prefix exists but is bound to another namespace, overwrite it
                            // currentElementInfo.put(prefix, namespaceURI);
                        } else {
                            // System.out.println("prefix is not yet declared, declaring it now");
                            currentElementInfo.put(prefix, namespaceURI);
                        }
                    } else {
                        // element has no namespace
                        // check if there is a default namespace, if so undeclare it
                        String uri = currentElementInfo.findNamespaceURI("");
                        if (StringUtils.isNotEmpty(uri)) {
                            // System.out.println("undeclaring default namespace");
                            currentElementInfo.put("", "");
                        }
                    }

                    // SAX uses empty string to denote no namespace, while DOM uses null.
                    if (namespaceURI == null)
                        namespaceURI = "";

                    String qName;
                    if (StringUtils.isNotEmpty(prefix)) {
                        qName = prefix + ":" + localName;
                    } else {
                        qName = localName;
                    }

                    // make the attributes
                    AttributesImpl newAttrs = new AttributesImpl();
                    for (int i = 0; i < nAttrs; i++) {
                        Node attr = atts.item(i);
                        String attrName = attr.getNodeName();
                        String assignedAttrPrefix = null;

                        // only do non-namespace attributes
                        if (!(attrName.equals("xmlns") || attrName.startsWith("xmlns:"))) {
                            String attrPrefix;
                            String attrLocalName;
                            String attrNsURI;

                            if (attr.getLocalName() == null) {
                                // this is an attribute created with setAttribute instead of setAttributeNS
                                String[] prefixAndLocalName = getPrefixAndLocalName(attrName);
                                attrPrefix = prefixAndLocalName[0];
                                // the statement below causes the attribute to keep its prefix even if it is not
                                // bound to a namespace (to support pre-namespace XML).
                                assignedAttrPrefix = attrPrefix;
                                attrLocalName = prefixAndLocalName[1];
                                // note: if prefix is null, the attribute has no namespace (namespace defaulting
                                // does not apply to attributes)
                                if (attrPrefix != null)
                                    attrNsURI = getNamespaceForPrefix(attrPrefix, (Element)node);
                                else
                                    attrNsURI = null;
                            } else {
                                attrLocalName = attr.getLocalName();
                                attrPrefix = attr.getPrefix();
                                attrNsURI = attr.getNamespaceURI();
                            }

                            if (attrNsURI != null) {
                                String declaredUri = currentElementInfo.findNamespaceURI(attrPrefix);
                                // if the prefix is null, or the prefix has not been declared, or conflicts with an in-scope binding
                                if (declaredUri == null || !declaredUri.equals(attrNsURI)) {
                                    String availablePrefix = currentElementInfo.findPrefix(attrNsURI);
                                    if (availablePrefix != null && !availablePrefix.equals(""))
                                        assignedAttrPrefix = availablePrefix;
                                    else {
                                        if (attrPrefix != null && declaredUri == null) {
                                            // prefix is not null and is not yet declared: declare it
                                            assignedAttrPrefix = attrPrefix;
                                            currentElementInfo.put(assignedAttrPrefix, attrNsURI);
                                        } else {
                                            // attribute has no prefix (which is not allowed for namespaced attributes) or
                                            // the prefix is already bound to something else: generate a new prefix
                                            newPrefixCounter++;
                                            assignedAttrPrefix = "NS" + newPrefixCounter;
                                            currentElementInfo.put(assignedAttrPrefix, attrNsURI);
                                        }
                                    }
                                } else {
                                    assignedAttrPrefix = attrPrefix;
                                }
                            }

                            String assignedAttrNsURI = attrNsURI != null ? attrNsURI : "";
                            String attrQName;
                            if (assignedAttrPrefix != null) {
                                attrQName = assignedAttrPrefix + ":" + attrLocalName;
                            } else {
                                attrQName = attrLocalName;
                            }
                            newAttrs.addAttribute(assignedAttrNsURI, attrLocalName, attrQName, "CDATA", attr.getNodeValue());
                        }
                    }

                    // add local namespace declaration and fire startPrefixMapping events
                    if (currentElementInfo.namespaceDeclarations != null && currentElementInfo.namespaceDeclarations.size() > 0) {
                        Iterator localNsDeclIt = currentElementInfo.namespaceDeclarations.entrySet().iterator();
                        while (localNsDeclIt.hasNext()) {
                            Map.Entry entry = (Map.Entry) localNsDeclIt.next();
                            String pr = (String) entry.getKey();
                            String ns = (String) entry.getValue();
                            // the following lines enable the creation of explicit xmlns attributes
                            //String pr1 = pr.equals("") ? "xmlns" : pr;
                            //String qn = pr.equals("") ? "xmlns" : "xmlns:" + pr;
                            //newAttrs.addAttribute("", pr1, qn, "CDATA", ns);
                            // System.out.println("starting prefix mapping  for prefix " + pr + " for " + ns);
                            contentHandler.startPrefixMapping(pr, ns);
                        }
                    }

                    contentHandler.startElement(namespaceURI, localName, qName, newAttrs);

                    currentElementInfo.localName = localName;
                    currentElementInfo.namespaceURI = namespaceURI;
                    currentElementInfo.qName = qName;
                    break;
                case Node.PROCESSING_INSTRUCTION_NODE:
                    {
                        ProcessingInstruction pi = (ProcessingInstruction) node;
                        contentHandler.processingInstruction(pi.getNodeName(), pi.getData());
                    }
                    break;
                case Node.CDATA_SECTION_NODE:
                    {
                        if (lexicalHandler != null)
                            lexicalHandler.startCDATA();

                        dispatchChars(node);

                        if (lexicalHandler != null)
                            lexicalHandler.endCDATA();
                    }
                    break;
                case Node.TEXT_NODE:
                    {
                        dispatchChars(node);
                    }
                    break;
                case Node.ENTITY_REFERENCE_NODE:
                    {
                        EntityReference eref = (EntityReference) node;

                        if (lexicalHandler != null) {
                            lexicalHandler.startEntity(eref.getNodeName());
                        } else {
                            // warning("Can not output entity to a pure SAX ContentHandler");
                        }
                    }
                    break;
                default :
            }
        }
16846#/**
         * Searches the namespace for a given namespace prefix starting from a
         * given Element.
         *
         * <p>Note that this resolves the prefix in the orginal DOM-tree, not in
         * the {@link ElementInfo} objects. This is used to resolve prefixes
         * of elements or attributes created with createElement or setAttribute
         * instead of createElementNS or setAttributeNS.
         *
         * <p>The code in this method is largely based on
         * org.apache.xml.utils.DOMHelper.getNamespaceForPrefix() (from Xalan).
         *
         * @param prefix the prefix to look for, can be empty or null to find the
         * default namespace
         *
         * @return the namespace, or null if not found.
         */
        public String getNamespaceForPrefix(String prefix, Element namespaceContext) {
            int type;
            Node parent = namespaceContext;
            String namespace = null;

            if (prefix == null)
                prefix = "";

            if (prefix.equals("xml")) {
                namespace = "http://www.w3.org/XML/1998/namespace";
            } else if(prefix.equals("xmlns")) {
                namespace = "http://www.w3.org/2000/xmlns/";
            } else {
                // Attribute name for this prefix's declaration
                String declname = (prefix.length() == 0) ? "xmlns" : "xmlns:" + prefix;

                // Scan until we run out of Elements or have resolved the namespace
                while ((null != parent)
                   && (((type = parent.getNodeType()) == Node.ELEMENT_NODE)
                       || (type == Node.ENTITY_REFERENCE_NODE))) {
                    if (type == Node.ELEMENT_NODE) {
                        Attr attr=((Element)parent).getAttributeNode(declname);
                        if (attr != null) {
                            namespace = attr.getNodeValue();
                            break;
                        }
                    }
                    parent = parent.getParentNode();
                }
            }
            return namespace;
        }
16847#/**
         * Splits a nodeName into a prefix and a localName
         *
         * @return an array containing two elements, the first one is the prefix (can be null), the
         * second one is the localName
         */
        private String[] getPrefixAndLocalName(String nodeName) {
            String prefix, localName;
            int colonPos = nodeName.indexOf(":");
            if (colonPos != -1) {
                prefix = nodeName.substring(0, colonPos);
                localName = nodeName.substring(colonPos + 1, nodeName.length());
            } else {
                prefix = null;
                localName = nodeName;
            }
            return new String[] {prefix, localName};
        }
16848#/**
         * End processing of given node
         *
         * @param node Node we just finished processing
         */
        protected void endNode(Node node) throws org.xml.sax.SAXException {

            switch (node.getNodeType()) {
                case Node.ELEMENT_NODE:
                    contentHandler.endElement(currentElementInfo.namespaceURI,
                            currentElementInfo.localName, currentElementInfo.qName);

                    // generate endPrefixMapping events if needed
                    if (currentElementInfo.namespaceDeclarations != null && currentElementInfo.namespaceDeclarations.size() > 0) {
                        Iterator namespaceIt = currentElementInfo.namespaceDeclarations.entrySet().iterator();
                        while (namespaceIt.hasNext()) {
                            Map.Entry entry = (Map.Entry) namespaceIt.next();
                            contentHandler.endPrefixMapping((String) entry.getKey());
                            //System.out.println("ending prefix mapping " + (String) entry.getKey());
                        }
                    }
                    currentElementInfo = currentElementInfo.parent;
                    break;
                case Node.DOCUMENT_NODE:
                case Node.CDATA_SECTION_NODE:
                    break;
                case Node.ENTITY_REFERENCE_NODE:
                    {
                        EntityReference eref = (EntityReference) node;

                        if (lexicalHandler != null) {
                            lexicalHandler.endEntity(eref.getNodeName());
                        }
                    }
                    break;
                default :
            }
        }
16849#/**
         * Start the production of SAX events.
         */
        public void stream(Node node)
        throws SAXException {
            if (this.transformer == null) {
                try {
                    this.transformer = FACTORY.newTransformer();
                } catch (TransformerConfigurationException e) {
                    throw new SAXException(e);
                }
            }
            DOMSource source = new DOMSource(node);

            ContentHandler handler;
            if (node.getNodeType() == Node.DOCUMENT_NODE) {
                // Pass all SAX events
                handler = contentHandler;
            } else {
                // Strip start/endDocument
                handler = new EmbeddedXMLPipe(contentHandler);
            }

            SAXResult result = new SAXResult(handler);
            result.setLexicalHandler(lexicalHandler);

            try {
                transformer.transform(source, result);
            } catch (TransformerException e) {
                throw new SAXException(e);
            }
        }
16850#public ElementInfo(ElementInfo parent) {
                this.parent = parent;
            }
16851#/**
             * Declare a new namespace prefix on this element, possibly overriding
             * an existing one.
             */
            public void put(String prefix, String namespaceURI) {
                if (namespaceDeclarations == null)
                    namespaceDeclarations = new HashMap();
                namespaceDeclarations.put(prefix, namespaceURI);
            }
16852#/**
             * Finds a prefix declared on this element.
             */
            public String getPrefix(String namespaceURI) {
                if (namespaceDeclarations == null || namespaceDeclarations.size() == 0)
                    return null;
                // note: there could be more than one prefix for the same namespaceURI, but
                // we return the first found one.
                Iterator it = namespaceDeclarations.entrySet().iterator();
                while (it.hasNext()) {
                    Map.Entry entry = (Map.Entry) it.next();
                    if (entry.getValue().equals(namespaceURI))
                        return (String) entry.getKey();
                }
                return null;
            }
16853#/**
             * Finds a namespace URI declared on this element.
             */
            public String getNamespaceURI(String prefix) {
                if (namespaceDeclarations == null || namespaceDeclarations.size() == 0)
                    return null;

                return (String) namespaceDeclarations.get(prefix);
            }
16854#/**
             * Finds a prefix declaration on this element or containing elements.
             */
            public String findPrefix(String namespaceURI) {
                if (namespaceDeclarations != null && namespaceDeclarations.size() != 0) {
                    String prefix = getPrefix(namespaceURI);
                    if (prefix != null) {
                        return prefix;
                    }
                }
                if (parent != null) {
                    return parent.findPrefix(namespaceURI);
                }
                return null;
            }
16855#/**
             * Finds a namespace declaration on this element or containing elements.
             */
            public String findNamespaceURI(String prefix) {
                if (namespaceDeclarations != null && namespaceDeclarations.size() != 0) {
                    String uri = (String) namespaceDeclarations.get(prefix);
                    if (uri != null) {
                        return uri;
                    }
                }
                if (parent != null) {
                    return parent.findNamespaceURI(prefix);
                }
                return null;
            }
16856#public void startElement( String uri, String name, String raw, Attributes attr ) throws SAXException
    {
        String type = attr.getValue( XLINK_NAMESPACE_URI, XLINK_TYPE );
        if ( type != null )
        {
            if ( type.equals( XLINK_TYPE_SIMPLE ) )
            {
                if ( this.extendedLinkElementName != null )
                {
                    throw new SAXException( "An XLink simple link cannot be included into an 'extended' element" );
                }
                else if ( this.linkLocatorElementName != null )
                {
                    throw new SAXException( "An XLink simple link cannot be included into a 'locator' element" );
                }
                else if ( this.linkArcElementName != null )
                {
                    throw new SAXException( "An XLink simple link cannot be included into an 'arc' element" );
                }
                String href = attr.getValue( XLINK_NAMESPACE_URI, XLINK_HREF );
                String role = attr.getValue( XLINK_NAMESPACE_URI, XLINK_ROLE );
                String arcrole = attr.getValue( XLINK_NAMESPACE_URI, XLINK_ARCROLE );
                String title = attr.getValue( XLINK_NAMESPACE_URI, XLINK_TITLE );
                String show = attr.getValue( XLINK_NAMESPACE_URI, XLINK_SHOW );
                String actuate = attr.getValue( XLINK_NAMESPACE_URI, XLINK_ACTUATE );
                simpleLink( href, role, arcrole, title, show, actuate, uri, name, raw, attr );
            }
            else if ( type.equals( XLINK_TYPE_EXTENDED ) )
            {
                if ( this.extendedLinkElementName != null )
                {
                    throw new SAXException( "An XLink extended link cannot include another 'extended' element" );
                }
                else if ( this.linkLocatorElementName != null )
                {
                    throw new SAXException( "An XLink extended link cannot be included into a 'locator' element" );
                }
                else if ( this.linkArcElementName != null )
                {
                    throw new SAXException( "An XLink extended link cannot be included into an 'arc' element" );
                }
                String role = attr.getValue( XLINK_NAMESPACE_URI, XLINK_ROLE );
                String title = attr.getValue( XLINK_NAMESPACE_URI, XLINK_TITLE );
                this.extendedLinkElementName = name;
                this.extendedLinkElementURI = uri;
                startExtendedLink( role, title, uri, name, raw, attr );
            }
            else if ( type.equals( XLINK_TYPE_LOCATOR ) )
            {
                if ( this.extendedLinkElementName == null )
                {
                    throw new SAXException( "An XLink locator must be included into an 'extended' element" );
                }
                else if ( this.linkLocatorElementName != null )
                {
                    throw new SAXException( "An XLink locator  cannot be included into another 'locator' element" );
                }
                else if ( this.linkArcElementName != null )
                {
                    throw new SAXException( "An XLink locator cannot be included into an 'arc' element" );
                }
                String href = attr.getValue( XLINK_NAMESPACE_URI, XLINK_HREF );
                String role = attr.getValue( XLINK_NAMESPACE_URI, XLINK_ROLE );
                String title = attr.getValue( XLINK_NAMESPACE_URI, XLINK_TITLE );
                String label = attr.getValue( XLINK_NAMESPACE_URI, XLINK_LABEL );
                this.linkLocatorElementName = name;
                this.linkLocatorElementURI = uri;
                startLocator( href, role, title, label, uri, name, raw, attr );
            }
            else if ( type.equals( XLINK_TYPE_ARC ) )
            {
                if ( this.extendedLinkElementName == null )
                {
                    throw new SAXException( "An XLink arc must be included into an 'extended' element" );
                }
                else if ( this.linkLocatorElementName != null )
                {
                    throw new SAXException( "An XLink arc cannot be included into a 'locator' element" );
                }
                else if ( this.linkArcElementName != null )
                {
                    throw new SAXException( "An XLink arc cannot be included into another 'arc' element" );
                }
                String arcrole = attr.getValue( XLINK_NAMESPACE_URI, XLINK_ARCROLE );
                String title = attr.getValue( XLINK_NAMESPACE_URI, XLINK_TITLE );
                String show = attr.getValue( XLINK_NAMESPACE_URI, XLINK_SHOW );
                String actuate = attr.getValue( XLINK_NAMESPACE_URI, XLINK_ACTUATE );
                String from = attr.getValue( XLINK_NAMESPACE_URI, XLINK_FROM );
                String to = attr.getValue( XLINK_NAMESPACE_URI, XLINK_TO );
                this.linkArcElementName = name;
                this.linkArcElementURI = uri;
                startArc( arcrole, title, show, actuate, from, to, uri, name, raw, attr );
            }
            else if ( type.equals( XLINK_TYPE_RESOURCE ) )
            {
                if ( this.extendedLinkElementName == null )
                {
                    throw new SAXException( "An XLink resource must be included into an 'extended' element" );
                }
                String role = attr.getValue( XLINK_NAMESPACE_URI, XLINK_ROLE );
                String title = attr.getValue( XLINK_NAMESPACE_URI, XLINK_TITLE );
                String label = attr.getValue( XLINK_NAMESPACE_URI, XLINK_LABEL );
                linkResource( role, title, label, uri, name, raw, attr );
            }
            else if ( type.equals( XLINK_TYPE_TITLE ) )
            {
                if ( ( this.extendedLinkElementName == null )
                        && ( this.linkLocatorElementName == null )
                        && ( this.linkArcElementName == null ) )
                {
                    throw new SAXException( "An XLink title must be included into an 'extended', 'locator' or 'arc' element" );
                }
                linkTitle( uri, name, raw, attr );
            }
            else
            {
                super.startElement( uri, name, raw, attr );
            }
        }
        else
        {
            super.startElement( uri, name, raw, attr );
        }
    }
16857#public void endElement( String uri, String name, String raw ) throws SAXException
    {
        if ( ( name.equals( this.extendedLinkElementName ) ) && ( uri.equals( this.extendedLinkElementURI ) ) )
        {
            this.extendedLinkElementName = null;
            this.extendedLinkElementURI = null;
            this.endExtendedLink( uri, name, raw );
        }
        else if ( ( name.equals( this.linkLocatorElementName ) ) && ( uri.equals( this.linkLocatorElementURI ) ) )
        {
            this.linkLocatorElementName = null;
            this.linkLocatorElementURI = null;
            this.endLocator( uri, name, raw );
        }
        else if ( ( name.equals( this.linkArcElementName ) ) && ( uri.equals( this.linkArcElementURI ) ) )
        {
            this.linkArcElementName = null;
            this.linkArcElementURI = null;
            this.endArc( uri, name, raw );
        }
        else
        {
            super.endElement( uri, name, raw );
        }
    }
16858#// Default XLinkHandler implementation (defaults to copy over)

    public void simpleLink( String href, String role, String arcrole, String title, String show, String actuate, String uri, String name, String raw, Attributes attr ) throws SAXException
    {
        AttributesImpl newattr = new AttributesImpl( attr );
        int hrefIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_HREF );
        int roleIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_ROLE );
        int arcroleIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_ARCROLE );
        int titleIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_TITLE );
        int showIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_SHOW );
        int actuateIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_ACTUATE );
        if ( hrefIndex > -1 )
            newattr.setValue( hrefIndex, href );
        if ( roleIndex > -1 )
            newattr.setValue( roleIndex, role );
        if ( arcroleIndex > -1 )
            newattr.setValue( arcroleIndex, arcrole );
        if ( titleIndex > -1 )
            newattr.setValue( titleIndex, title );
        if ( showIndex > -1 )
            newattr.setValue( showIndex, show );
        if ( actuateIndex > -1 )
            newattr.setValue( actuateIndex, actuate );
        super.startElement( uri, name, raw, newattr );
    }
16859#public void startExtendedLink( String role, String title, String uri, String name, String raw, Attributes attr ) throws SAXException
    {
        AttributesImpl newattr = new AttributesImpl( attr );
        int roleIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_ROLE );
        int titleIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_TITLE );
        if ( roleIndex > -1 )
            newattr.setValue( roleIndex, role );
        if ( titleIndex > -1 )
            newattr.setValue( titleIndex, title );
        super.startElement( uri, name, raw, newattr );
    }
16860#public void startLocator( String href, String role, String title, String label, String uri, String name, String raw, Attributes attr ) throws SAXException
    {
        AttributesImpl newattr = new AttributesImpl( attr );
        int hrefIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_HREF );
        int roleIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_ROLE );
        int titleIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_TITLE );
        int labelIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_LABEL );
        if ( hrefIndex > -1 )
            newattr.setValue( hrefIndex, href );
        if ( roleIndex > -1 )
            newattr.setValue( roleIndex, role );
        if ( titleIndex > -1 )
            newattr.setValue( titleIndex, title );
        if ( labelIndex > -1 )
            newattr.setValue( labelIndex, label );
        super.startElement( uri, name, raw, newattr );
    }
16861#public void startArc( String arcrole, String title, String show, String actuate, String from, String to, String uri, String name, String raw, Attributes attr ) throws SAXException
    {
        AttributesImpl newattr = new AttributesImpl( attr );
        int arcroleIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_ARCROLE );
        int titleIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_TITLE );
        int showIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_SHOW );
        int actuateIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_ACTUATE );
        int fromIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_FROM );
        int toIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_TO );
        if ( arcroleIndex > -1 )
            newattr.setValue( arcroleIndex, arcrole );
        if ( titleIndex > -1 )
            newattr.setValue( titleIndex, title );
        if ( showIndex > -1 )
            newattr.setValue( showIndex, show );
        if ( actuateIndex > -1 )
            newattr.setValue( actuateIndex, actuate );
        if ( fromIndex > -1 )
            newattr.setValue( actuateIndex, from );
        if ( toIndex > -1 )
            newattr.setValue( actuateIndex, to );
        super.startElement( uri, name, raw, newattr );
    }
16862#public void linkResource( String role, String title, String label, String uri, String name, String raw, Attributes attr ) throws SAXException
    {
        AttributesImpl newattr = new AttributesImpl( attr );
        int roleIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_ROLE );
        int titleIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_TITLE );
        int labelIndex = attr.getIndex( XLINK_NAMESPACE_URI, XLINK_LABEL );
        if ( roleIndex > -1 )
            newattr.setValue( roleIndex, role );
        if ( titleIndex > -1 )
            newattr.setValue( titleIndex, title );
        if ( labelIndex > -1 )
            newattr.setValue( labelIndex, label );
        super.startElement( uri, name, raw, newattr );
    }
16863#public void linkTitle( String uri, String name, String raw, Attributes attr ) throws SAXException
    {
        super.startElement( uri, name, raw, attr );
    }
16864#public void endExtendedLink( String uri, String name, String raw ) throws SAXException
    {
        super.endElement( uri, name, raw );
    }
16865#public void endLocator( String uri, String name, String raw ) throws SAXException
    {
        super.endElement( uri, name, raw );
    }
16866#public void endArc( String uri, String name, String raw ) throws SAXException
    {
        super.endElement( uri, name, raw );
    }
16867#protected static Set arrayToSet(Object[] array) {
        final Set set = new HashSet(array.length);

        for (int i = 0; i < array.length; i++)
            set.add(array[i]);
        return set;
    }
16868#public void startElement(
        String uri,
        final String name,
        final String raw,
        final Attributes attr)
        throws SAXException {
        final Set attrList = (Set) MAP.get((uri == null) ? "" : uri);

        if (attrList != null) {
            for (int i = attrIndex + 1; i < attr.getLength(); i++)
                if (attr.getURI(i).equals("")
                    && attrList.contains(attr.getLocalName(i))) {

                    final String att = attr.getValue(i);

                    if (att != null) {
                        final String str =
                            ": URI="
                                + uri
                                + " NAME="
                                + name
                                + " RAW="
                                + raw
                                + " ATT="
                                + attr.getLocalName(i)
                                + " NS="
                                + uri
                                + " VALUE="
                                + att;

                        if (getLogger().isDebugEnabled())
                           getLogger().debug("Transforming to XLink" + str);
                           
                        attrIndex = i;
                        
                        simpleLink(
                            att,
                            null,
                            null,
                            null,
                            null,
                            null,
                            uri,
                            name,
                            raw,
                            attr);
                        
                        return;
                    }
                }
            attrIndex = -1;
        }

        super.startElement(uri, name, raw, attr);
    }
16869#public void simpleLink(
        final String href,
        final String role,
        final String arcrole,
        final String title,
        final String show,
        final String actuate,
        final String uri,
        final String name,
        final String raw,
        final Attributes attr)
        throws SAXException {
        if (attrIndex != -1) {
            final AttributesImpl newattr = new AttributesImpl(attr);
            newattr.setValue(attrIndex, href);
            startElement(uri, name, raw, newattr);
        } else {
            super.simpleLink(
                href,
                role,
                arcrole,
                title,
                show,
                actuate,
                uri,
                name,
                raw,
                attr);
        }
    }
16870#/**
     * Process the given <code>Environment</code> producing the output.
     * @return If the processing is successfull <code>true</code> is returned.
     *         If no match is found in the sitemap <code>false</code>
     *         is returned.
     * @throws ResourceNotFoundException If a sitemap component tries
     *                                   to access a resource which can not
     *                                   be found, e.g. the generator
     *         ConnectionResetException  If the connection was reset
     */
    boolean process(Environment environment)
    throws Exception;
16871#/**
     * Process the given <code>Environment</code> to assemble
     * a <code>ProcessingPipeline</code>.
     * Don't forget to release the pipeline using
     * {@link InternalPipelineDescription#release()}.
     * @since 2.2
     */
    InternalPipelineDescription buildPipeline(Environment environment)
    throws Exception;
16872#/**
     * Get the root processor parent of this processor.
     * @since 2.1.1
     */
    Processor getRootProcessor();
16873#/**
     * Get the source resolver for this processor
     * @since 2.2
     */
    SourceResolver getSourceResolver();
16874#/**
     * Get the context URI for this processor
     * @since 2.2
     */
    String getContext();
16875#/**
     * Sets an attribute
     * @since 2.2
     */
    void setAttribute(String name, Object value);
16876#/**
     * Gets an attribute
     * @since 2.2
     */
    Object getAttribute(String name);
16877#/**
     * Remove an attribute.
     * @since 2.2
     */
    Object removeAttribute(String name);
16878#/**
     * Get the parent processor (if any).
     * @return The parent processor or null.
     * @since 2.2
     */
    Processor getParent();
16879#public InternalPipelineDescription(Processor processor,
                                           ServiceManager manager,
                                           ProcessingPipeline pipeline) {
            this.processor = processor;
            this.pipelineManager = manager;
            this.processingPipeline = pipeline;
        }
16880#public void release() {
            if (this.pipelineManager != null) {
                this.pipelineManager.release(this.processingPipeline);
            }
            this.processingPipeline = null;
            this.pipelineManager = null;
            this.processor = null;
        }
16881#/**
     * Controls the processing against some values of the
     * <code>Dictionary</code> objectModel and returns a
     * <code>Map</code> object with values used in subsequent
     * sitemap substitution patterns.
     *
     * NOTE: This interface is designed so that implentations can be <code>ThreadSafe<code>.
     * When an action is ThreadSafe, only one instance serves all requests : this
     * reduces memory usage and avoids pooling.
     *
     * @param resolver    The <code>SourceResolver</code> in charge
     * @param objectModel The <code>Map</code> with object of the
     *                    calling environment which can be used
     *                    to select values this controller may need
     *                    (ie Request, Response).
     * @param source      A source <code>String</code> to the Action
     * @param parameters  The <code>Parameters</code> for this invocation
     * @return Map        The returned <code>Map</code> object with
     *                    sitemap substitution values which can be used
     *                    in subsequent elements attributes like src=
     *                    using a xpath like expression: src="mydir/{myval}/foo"
     *                    If the return value is null the processing inside
     *                    the <map:act> element of the sitemap will
     *                    be skipped.
     * @exception Exception Indicates something is totally wrong
     */
    Map act(Redirector redirector, SourceResolver resolver, Map objectModel, String source, Parameters parameters)
            throws Exception;
16882#ClassLoader createClassLoader(ClassLoader              parent,
                                  ClassLoaderConfiguration config,
                                  ServletContext           servletContext)
    throws Exception;
16883#public void addInclude(String include) {
        this.includes.add(include);
    }
16884#public void addExclude(String include) {
        this.excludes.add(include);
    }
16885#public void addClassDirectory(String include) {
        this.classDirectories.add(include);
    }
16886#public void addLibDirectory(String include) {
        this.libDirectories.add(include);
    }
16887#public List getClassDirectories() {
        return classDirectories;
    }
16888#public List getLibDirectories() {
        return libDirectories;
    }
16889#public List getExcludes() {
        return excludes;
    }
16890#public List getIncludes() {
        return includes;
    }
16891#public void setExcludes(final List excludePatterns);
16892#public void setIncludes(final List includePatterns);
16893#/**
     * Disposes the passed continuation object.
     * <p>
     * This method is called from the ContinuationsManager in the event of
     * the invalidation of a continuation upon the {@link ContinuationsDisposer}
     * object passed during the creation of the WebContinuation.
     * 
     * @param webContinuation the {@link WebContinuation} value representing the  
     * continuation object. 
     */
    public void disposeContinuation(WebContinuation webContinuation);
16894#/**
     * Create a <code>WebContinuation</code> object. Saves the object in
     * the hash table of continuations maintained by
     * <code>manager</code> (this is done as a side effect of obtaining
     * and identifier from it).
     *
     * @param continuation an <code>Object</code> value
     * @param parentContinuation a <code>WebContinuation</code> value
     * @param timeToLive time this continuation should live
     * @param disposer a <code>ContinuationsDisposer</code> to call when this
     * continuation gets invalidated.
     */
    WebContinuation(String id,
                    Object continuation,
                    WebContinuation parentContinuation,
                    int timeToLive,
                    String interpreterId,
                    ContinuationsDisposer disposer) {
        this.id = id;
        this.continuation = continuation;
        this.parentContinuation = parentContinuation;
        this.updateLastAccessTime();
        this.timeToLive = timeToLive;
        this.interpreterId = interpreterId;
        this.disposer = disposer;

        if (parentContinuation != null) {
            this.parentContinuation.children.add(this);
        }
    }
16895#public final Log getLogger() {
        return this.logger;
    }
16896#public void setLogger(Log logger) {
        this.logger = logger;
    }
16897#/**
     * Get an attribute of this continuation
     * 
     * @param name the attribute name.
     */
    public Object getAttribute(String name) {
        if (this.attributes == null) {
            return null;
        }
        
        return this.attributes.get(name);
    }
16898#/**
     * Set an attribute of this continuation
     * 
     * @param name the attribute name
     * @param value its value
     */
    public void setAttribute(String name, Object value) {
        if (this.attributes == null) {
            this.attributes = Collections.synchronizedMap(new HashMap());
        }
        
        this.attributes.put(name, value);
    }
16899#/**
     * Remove an attribute of this continuation
     * 
     * @param name the attribute name
     */
    public void removeAttribute(String name) {
        if (this.attributes == null)
            return;
        
        this.attributes.remove(name);
    }
16900#/**
     * Enumerate the attributes of this continuation.
     * 
     * @return an enumeration of strings
     */
    public Enumeration getAttributeNames() {
        if (this.attributes == null)
            return new IteratorEnumeration();
        
        ArrayList keys = new ArrayList(this.attributes.keySet());
        return new IteratorEnumeration(keys.iterator());
    }
16901#/**
     * Return the continuation object.
     *
     * @return an <code>Object</code> value
     */
    public Object getContinuation() {
        updateLastAccessTime();
        return continuation;
    }
16902#/**
     * Return the ancestor continuation situated <code>level</code>s
     * above the current continuation. The current instance is
     * considered to be at level 0. The parent continuation of the
     * receiving instance at level 1, its parent is at level 2 relative
     * to the receiving instance. If <code>level</code> is bigger than
     * the depth of the tree, the root of the tree is returned.
     *
     * @param level an <code>int</code> value
     * @return a <code>WebContinuation</code> value
     */
    public WebContinuation getContinuation(int level) {
        if (level <= 0) {
            updateLastAccessTime();
            return this;
        } else if (parentContinuation == null) {
            return this;
        } else {
            return parentContinuation.getContinuation(level - 1);
        }
    }
16903#/**
     * Return the parent <code>WebContinuation</code>. Equivalent with
     * <code>getContinuation(1)</code>.
     *
     * @return a <code>WebContinuation</code> value
     */
    public WebContinuation getParentContinuation() {
        return parentContinuation;
    }
16904#/**
     * Return the children <code>WebContinuation</code> which were
     * created as a result of resuming the processing from the current
     * <code>continuation</code>.
     *
     * @return a <code>List</code> value
     */
    public List getChildren() {
        return children;
    }
16905#/**
     * Returns the string identifier of this
     * <code>WebContinuation</code>.
     *
     * @return a <code>String</code> value
     */
    public String getId() {
        return id;
    }
16906#/**
     * Returns the string identifier of the interpreter to which
     * this <code>WebContinuation</code> is bound.
     *
     * @return a <code>String</code> value
     */
    public String getInterpreterId() {
        return interpreterId;
    }
16907#/**
     * Returns the last time this
     * <code>WebContinuation</code> was accessed.
     *
     * @return a <code>long</code> value
     */
    public long getLastAccessTime() {
        return lastAccessTime;
    }
16908#/**
     * Returns the the timetolive for this
     * <code>WebContinuation</code>.
     *
     * @return a <code>long</code> value
     */
    public long getTimeToLive() {
        return this.timeToLive;
    }
16909#/**
     * Sets the user object associated with this instance.
     *
     * @param obj an <code>Object</code> value
     */
    public void setUserObject(Object obj) {
        this.userObject = obj;
    }
16910#/**
     * Obtains the user object associated with this instance.
     *
     * @return an <code>Object</code> value
     */
    public Object getUserObject() {
        return userObject;
    }
16911#/**
     * Obtains the <code>ContinuationsDisposer</code> to call when this continuation
     * is invalidated.
     *
     * @return a <code>ContinuationsDisposer</code> instance or null if there are
     * no specific clean-up actions required.
     */
    ContinuationsDisposer getDisposer() {
        return this.disposer;
    }
16912#/**
     * Returns the hash code of the associated identifier.
     *
     * @return an <code>int</code> value
     */
    public int hashCode() {
        return id.hashCode();
    }
16913#/**
     * True if the identifiers are the same, false otherwise.
     *
     * @param another an <code>Object</code> value
     * @return a <code>boolean</code> value
     */
    public boolean equals(Object another) {
        if (another instanceof WebContinuation) {
            return id.equals(((WebContinuation) another).id);
        }
        return false;
    }
16914#/**
     * Compares the expiration time of this instance with that of the
     * WebContinuation passed as argument.
     *
     * <p><b>Note:</b> this class has a natural ordering that is
     * inconsistent with <code>equals</code>.</p>.
     *
     * @param other an <code>Object</code> value, which should be a
     * <code>WebContinuation</code> instance
     * @return an <code>int</code> value
     */
    public int compareTo(Object other) {
        WebContinuation wk = (WebContinuation) other;
        return (int) ((lastAccessTime + timeToLive)
                - (wk.lastAccessTime + wk.timeToLive));
    }
16915#/**
     * Debugging method.
     *
     * <p>Assumes the receiving instance as the root of a tree and
     * displays the tree of continuations.
     */
    public void display() {
        getLogger().debug("\nWK: Tree" + display(0));
    }
16916#/**
     * Debugging method.
     *
     * <p>Displays the receiving instance as if it is at the
     * <code>indent</code> depth in the tree of continuations. Each
     * level is indented 2 spaces.
     *
     * @param depth an <code>int</code> value
     */
    protected String display(int depth) {
        StringBuffer tree = new StringBuffer("\n");
        for (int i = 0; i < depth; i++) {
            tree.append("  ");
        }

        tree.append("WK: WebContinuation ")
                .append(id)
                .append(" ExpireTime [");

        if ((lastAccessTime + timeToLive) < System.currentTimeMillis()) {
            tree.append("Expired");
        } else {
            tree.append(lastAccessTime + timeToLive);
        }

        tree.append("]");

        // REVISIT: is this needed for some reason?
        // System.out.print(spaces); System.out.println("WebContinuation " + id);

        int size = children.size();
        depth++;

        for (int i = 0; i < size; i++) {
            tree.append(((WebContinuation) children.get(i)).display(depth));
        }

        return tree.toString();
    }
16917#/**
     * Update the continuation in the
     */
    protected void updateLastAccessTime() {
        lastAccessTime = System.currentTimeMillis();
    }
16918#/**
     * Determines whether this continuation has expired
     *
     * @return a <code>boolean</code> value
     */
    public boolean hasExpired() {
        long currentTime = System.currentTimeMillis();
        long expireTime = this.getLastAccessTime() + this.timeToLive;

        return (currentTime > expireTime);
    }
16919#/**
     * Dispose this continuation. Should be called on invalidation.
     */
    public void dispose() {
        // Call possible implementation-specific clean-up on this continuation.
        if (this.disposer != null) {
            this.disposer.disposeContinuation(this);
        }
        // Remove continuation object - will also serve as "disposed" flag
        this.continuation = null;
    }
16920#/**
     * Return true if this continuation was disposed of
     */
    public boolean disposed() {
        return this.continuation == null;
    }
16921#public boolean interpreterMatches( String interpreterId ) {
        return StringUtils.equals(this.interpreterId, interpreterId);
    }
16922#public void detachFromParent() {
        if (getParentContinuation() != null) {
            getParentContinuation().getChildren().remove(this);
        }
    }
16923#/**
	 * @return the unique ID for this interpreter.
	 */
	String getInterpreterID();
16924#/**
     * Set the unique ID for this interpreter.
     */
    void setInterpreterID(String interpreterID);
16925#/**
     * This method is called from the sitemap, using the syntax
     *
     * <pre>
     *   &lt;map:call function="..."/&gt;
     * </pre>
     *
     * The method will execute the named function, which must be defined
     * in the given language. There is no assumption made on how various
     * arguments are passed to the function.
     *
     * <p>The <code>params</code> argument is a <code>List</code> object
     * that contains <code>Interpreter.Argument</code> instances,
     * representing the parameters to be passed to the called
     * function. An <code>Argument</code> instance is a key-value pair,
     * where the key is the name of the parameter, and the value is its
     * desired value. Most languages will ignore the name value and
     * simply pass to the function, in a positional order, the values of
     * the argument. Some languages however can pass the arguments in a
     * different order than the original prototype of the function. For
     * these languages the ability to associate the actual argument with
     * a formal parameter using its name is essential.
     *
     * <p>A particular language implementation may decide to put the
     * environment, request, response etc. objects in the dynamic scope
     * available to the function at the time of the call. Other
     * implementations may decide to pass these as arguments to the
     * called function.
     *
     * <p>The current implementation assumes the sitemap implementation
     * is TreeProcessor.
     *
     * @param funName a <code>String</code> value, the name of the
     * function to call
     * @param params a <code>List</code> object whose components are
     * CallFunctionNode.Argument instances. The interpretation of the
     * parameters is left to the actual implementation of the
     * interpreter.
     * @param redirector a <code>Redirector</code> used to call views
     */
    void callFunction(String funName, List params, Redirector redirector)
    throws Exception;
16926#/**
     * Forward the request to a Cocoon pipeline.
     *
     * @param uri a <code>String</code>, the URI of the forwarded request
     * @param bizData an <code>Object</code>, the business data object
     * to be made available to the forwarded pipeline
     * @param continuation a <code>WebContinuation</code>, the
     * continuation to be called to resume the processing
     * @param redirector a <code>Redirector</code> used to call views
     * @exception Exception if an error occurs
     */
    void forwardTo(String uri, Object bizData, WebContinuation continuation,
                   Redirector redirector)
    throws Exception;
16927#/**
     * Continues a previously started processing. The continuation
     * object where the processing should start from is indicated by the
     * <code>continuationId</code> string.
     *
     * @param continuationId a <code>String</code> value
     *
     * @param params a <code>List</code> value, containing the
     * parameters to be passed when invoking the continuation. As
     * opposed to the parameters passed by <code>callFunction</code>,
     * these parameters will only become available in the language's
     * environment, if at all.
     *
     * @param redirector a <code>Redirector</code> used to call views
     * @exception Exception if an error occurs
     */
    void handleContinuation(String continuationId, List params,
                            Redirector redirector)
    throws Exception;
16928#/**
     * Registers a source file with the interpreter. Using this method
     * an implementation keeps track of all the script files which are
     * compiled. This allows them to reload the script files which get
     * modified on the file system.
     *
     */
    void register(String source);
16929#/**
     * Return the default extension of script files associated with this
     * interpreter.
     * The extension is used by the sitemap to automount all scripts
     * from the "flow" directory. If this method returns null, no
     * scripts are mounted automatically.
     * @return The script extension, like ".js", or null.
     */
    String getScriptExtension();
16930#public Argument(String name, String value) {
            this.name = name;
            this.value = value;
        }
16931#public String toString() {
            return name + ": " + value;
        }
16932#/**
     * Create a <code>WebContinuation</code> object given a native
     * continuation object and its parent. If the parent continuation is
     * null, the <code>WebContinuation</code> returned becomes the root
     * of a tree in the forrest.
     *
     * @param kont an <code>Object</code> value
     * @param parentKont a <code>WebContinuation</code> value
     * @param timeToLive an <code>int</code> value indicating how long
     * in seconds this continuation will live in the server if not
     * accessed
     * @param interpreterId id of interpreter invoking continuation creation
     * @param disposer a <code>ContinuationsDisposer</code> instance to called when 
     * the continuation gets cleaned up.
     * @return a <code>WebContinuation</code> value
     * @see WebContinuation
     */
    public WebContinuation createWebContinuation(Object kont,
                                                 WebContinuation parentKont,
                                                 int timeToLive,
                                                 String interpreterId,
                                                 ContinuationsDisposer disposer);
16933#/**
     * Invalidates a <code>WebContinuation</code>. This effectively
     * means that the continuation object associated with it will no
     * longer be accessible from Web pages. Invalidating a
     * <code>WebContinuation</code> invalidates all the
     * <code>WebContinuation</code>s which are children of it.
     *
     * @param k a <code>WebContinuation</code> value
     */
    public void invalidateWebContinuation(WebContinuation k);
16934#/**
     * Given a <code>WebContinuation</code> id, retrieve the associated
     * <code>WebContinuation</code> object.
     * @param id a <code>String</code> value
     * @param interpreterId Id of an interpreter that queries for 
     * the continuation
     *
     * @return a <code>WebContinuation</code> object, null if no such
     * <code>WebContinuation</code> could be found. Also null if 
     * <code>WebContinuation</code> was found but interpreter id does 
     * not match the one that the continuation was initialy created for.
     */
    public WebContinuation lookupWebContinuation(String id, String interpreterId);
16935#/**
     * Prints debug information about all web continuations into the log file.
     * @see WebContinuation#display()
     */
    public void displayAllContinuations();
16936#/**
     * Get a list of all continuations as <code>WebContinuationDataBean</code> objects. 
     */
    public List getWebContinuationsDataBeanList();
16937#/**
     * Standard access to an attribute's value. If more than one value
     * exists, the first is returned. If the value does not exist,
     * null is returned. To get all values, use
     * {@link #getAttributeValues(String, Configuration, Map)} or
     * {@link #getAttributeNames(Configuration, Map)} and
     * {@link #getAttribute(String, Configuration, Map)} to get them one by one.
     * @param name a String that specifies what the caller thinks
     * would identify an attribute. This is mainly a fallback if no
     * modeConf is present.
     * @param modeConf column's mode configuration from resource
     * description. This argument is optional.
     * @param objectModel
     */
    Object getAttribute( String name, Configuration modeConf, Map objectModel ) throws ConfigurationException;
16938#/**
     * Returns an Iterator of String objects containing the names
     * of the attributes available. If no attributes are available,
     * the method returns an empty Iterator.
     * @param modeConf column's mode configuration from resource
     * description. This argument is optional.
     * @param objectModel
     */
    Iterator getAttributeNames( Configuration modeConf, Map objectModel ) throws ConfigurationException;
16939#/**
     * Returns an array of String objects containing all of the values
     * the given attribute has, or null if the attribute does not
     * exist. As an alternative,
     * {@link #getAttributeNames(Configuration, Map)} together with
     * {@link #getAttribute(String, Configuration, Map)} can be used to get the
     * values one by one.
     * @param name a String that specifies what the caller thinks
     * would identify an attributes. This is mainly a fallback
     * if no modeConf is present.
     * @param modeConf column's mode configuration from resource
     * description. This argument is optional.
     * @param objectModel
     */
    Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel ) throws ConfigurationException;
16940#/**
     * communicate an attribute value to further processing logic. OutputModules
     * work in implicit transaction mode, thus setting an attribute starts an
     * transaction and sttributes are only visible after the transaction is
     * successfully completed with a call to commit
     * @param modeConf column's mode configuration from resource
     * description. This argument is optional.
     * @param objectModel The objectModel
     * @param name The attribute's label, consisting of "table.column"
     * or "table.column[index]" in case of multiple attributes of the
     * same spec.
     * @param value The attriute's value.
     * */
    void setAttribute( Configuration modeConf, Map objectModel, String name, Object value );
16941#/**
     * If a database transaction needs to rollback, this is called to
     * inform the further processing logic about this fact. All
     * already set attribute values are invalidated. <em>This is difficult
     * because only the request object can be used to synchronize this
     * and build some kind of transaction object. Beaware that sending
     * your data straight to some beans or other entities could result
     * in data corruption!</em>
     * */
    void rollback( Configuration modeConf, Map objectModel, Exception e );
16942#/**
     * Signal that the database transaction completed
     * successfully. See notes on {@link #rollback(Configuration, Map, Exception)}.
     * */
    void commit( Configuration modeConf, Map objectModel );
16943#/** Builds a Notifying object (SimpleNotifyingObject in this case)
   *  that tries to explain what the Object o can reveal.
   * @param sender who sent this Object.
   * @param o the object to use when building the SimpleNotifyingObject
   * @return the  Notifying Object that was build
   * @see org.apache.cocoon.components.notification.Notifying
   */
  Notifying build(Object sender, Object o);
16944#/** Builds a Notifying object (SimpleNotifyingObject in this case)
   *  that explains a notification.
   * @param sender who sent this Object.
   * @param o the object to use when building the SimpleNotifyingObject
   * @param type see the Notifying apidocs
   * @param title see the Notifying apidocs
   * @param source see the Notifying apidocs
   * @param message see the Notifying apidocs
   * @param description see the Notifying apidocs
   * @param extra see the Notifying apidocs
   * @return the  Notifying Object that was build
   * @see org.apache.cocoon.components.notification.Notifying
   */
  Notifying build(Object sender, Object o, String type, String title,
          String source, String message, String description, Map extra);
16945#/**
     * Gets the Type of the Notifying object
     */
    String getType();
16946#/**
     * Gets the Title of the Notifying object
     */
    String getTitle();
16947#/**
     * Gets the Source of the Notifying object
     */
    String getSource();
16948#/**
     * Gets the Sender of the Notifying object
     */
    String getSender();
16949#/**
     * Gets the Message of the Notifying object
     */
    String getMessage();
16950#/**
     * Gets the Description of the Notifying object
     */
    String getDescription();
16951#/**
     * Gets the ExtraDescriptions of the Notifying object
     */
    Map getExtraDescriptions();
16952#/**
     * Prepares a pattern in a form that allows faster match. For example, a regular
     * expression matcher can precompile the expression and return the corresponding
     * object. This method is called once for each pattern used with a particular matcher
     * class. The returned value is then passed back as the <code>preparedPattern</code>
     * parameter of {@link #preparedMatch(Object, Map, Parameters)}.
     *
     * @param pattern The pattern to prepare. Depending on the implementation the pattern
     *                can contain wildcards or regular expressions.
     * @return an optimized representation of the pattern.
     * @throws PatternException if the pattern couldn't be prepared.
     */
    Object preparePattern(String pattern) throws PatternException;
16953#/**
     * Matches the prepared pattern against some values in the object model (most often the
     * <code>Request</code>) and returns a <code>Map</code> object with replacements
     * for wildcards contained in the pattern.
     *
     * @param preparedPattern The preparedPattern to match against, as returned by {@link #preparePattern(String)}.
     * @param objectModel     The <code>Map</code> with objects of the calling environment
     *                        which can be used to select values this matchers matches against.
     * @return                a <code>Map</code> object with replacements for wildcards/regular-expressions
     *                        contained in the pattern. If the return value is null there was no match.
     */
    Map preparedMatch(Object preparedPattern, Map objectModel, Parameters parameters) throws PatternException;
16954#/**
     * Matches the pattern against some <code>Request</code> values
     * and returns a <code>Map</code> object with replacements
     * for wildcards contained in the pattern.
     * @param pattern     The pattern to match against. Depending on the
     *                    implementation the pattern can contain wildcards
     *                    or regular expressions.
     * @param objectModel The <code>Map</code> with object of the
     *                    calling environment which can be used
     *                    to select values this matchers matches against.
     * @return Map        The returned <code>Map</code> object with
     *                    replacements for wildcards/regular-expressions
     *                    contained in the pattern.
     *                    If the return value is null there was no match.
     */
    Map match (String pattern, Map objectModel, Parameters parameters) throws PatternException;
16955#HttpServletRequest getRequest();
16956#HttpServletResponse getResponse();
16957#ServletContext getServletContext();
16958#Map getObjectModel();
16959#/**
     * Selectors test pattern against some objects in a <code>Map</code>
     * model and signals success with the returned boolean value
     * @param expression  The expression to test.
     * @param objectModel The <code>Map</code> containing object of the
     *                    calling environment which may be used
     *                    to select values to test the expression.
     * @param parameters  The sitemap parameters, as specified by &lt;parameter/&gt; tags.
     * @return boolean    Signals successfull test.
     */
    boolean select (String expression, Map objectModel, Parameters parameters);
16960#/**
     * Method to create a selector context.
     *
     * @param objectModel The <code>Map</code> containing object of the
     *                    calling environment which may be used
     *                    to select values to test the expression.
     * @param parameters  The sitemap parameters, as specified by
     *                    &lt;parameter/&gt; tags.
     * @return            Selector context
     */
    Object getSelectorContext(Map objectModel, Parameters parameters);
16961#/**
     * Switch Selectors test patterns against a context object
     * and signal success with the returned boolean value
     * @param expression  The expression to test.
     * @param selectorContext The context this test should be performed in.
     * @return            true if the test was successful.
     */
    boolean select(String expression, Object selectorContext);
16962#/**
     * @param source The current processor (sitemap)
     * @param env    The environment describing the current request
     */
    public SitemapEvent(Processor source, Environment env) {
        super(source);
        this.environment = env;
    }
16963#public Processor getSourceProcessor() {
        return (Processor)this.getSource();
    }
16964#public Environment getEnvironment() {
        return this.environment;
    }
16965#public EnterSitemapEvent(Processor source, Environment env) {
        super(source, env);
    }
16966#void leftSitemap(LeaveSitemapEvent event);
16967#/**
     * Set the root element. Please make sure that the parameters are not null!
     */
    public void setRootElement(String element, String namespace, String prefix);
16968#/**
     * Add a part. Please make sure that the parameters are not null!
     */
    public void addPart(String uri,
                        String element,
                        String namespace,
                        String stripRootElement,
                        String prefix);
16969#/**
     * Invoke an action and return the result.
     */
    Map invokeAction(ExecutionContext context,
                     Map              objectModel, 
                     Action           action, 
                     Redirector       redirector, 
                     SourceResolver   resolver, 
                     String           source, 
                     Parameters       parameters )
    throws Exception;
16970#/**
     * Invoke a match and return the result
     */
    Map invokeMatcher(ExecutionContext context,
                      Map              objectModel,
                      Matcher          matcher,
                      String           pattern,
                      Parameters       parameters )
    throws PatternException;
16971#/**
     * Invoke a match and return the result
     */
    Map invokePreparableMatcher(ExecutionContext context,
                      Map               objectModel,
                      PreparableMatcher matcher,
                      String            pattern,
                      Object            preparedPattern,
                      Parameters        parameters )
    throws PatternException;
16972#/**
     * Invoke a selector
     * @param context
     * @param objectModel
     * @param selector
     * @param expression
     * @param parameters
     * @return True if the selector did match.
     */
    boolean invokeSelector(ExecutionContext context,
            Map               objectModel,
            Selector selector, 
            String expression, 
            Parameters parameters);
16973#/**
     * Invoke a switch selector
     * @param context
     * @param objectModel
     * @param selector
     * @param expression
     * @param parameters
     * @param selectorContext The context object for the switch selector
     * @return True if the selector did match.
     */
    boolean invokeSwitchSelector(ExecutionContext context,
                                 Map             objectModel,
                                 SwitchSelector  selector, 
                                 String expression, 
                                 Parameters parameters,
                                 Object selectorContext);
16974#/**
     * Push map of information on the context stack.
     * @param context The execution context
     * @param objectModel The object model
     * @param key A key that can be used to identify this map (can be null)
     * @param variables The variables as key/value pairs
     * @return The variables that are used in the sitemap. The executor can
     *         modify the set of available variables by returning a different
     *         map.
     */
    Map pushVariables(ExecutionContext context, 
                      Map              objectModel,
                      String           key, 
                      Map              variables);
16975#/**
     * Pop a map of information from the context stack.
     * @param context     The execution context
     * @param objectModel The object model
     */
    void popVariables(ExecutionContext context,
                      Map              objectModel);
16976#/**
     * Enter a new sitemap
     * @param context     The execution context
     * @param objectModel The object model
     * @param source The uri of the sitemap
     */
    void enterSitemap(ExecutionContext context, 
                      Map              objectModel,
                      String           source);
16977#/**
     * Leaves a sitemap.
     */
    void leaveSitemap(ExecutionContext context,
                      Map              objectModel);
16978#/**
     * Add a generator
     * @param context
     * @param objectModel
     * @param desc The descrption of the component
     * @return The desc of the component to use
     */
    PipelineComponentDescription addGenerator(ExecutionContext context, 
                                              Map              objectModel,
                                              PipelineComponentDescription desc);
16979#/**
     * Add a transformer
     * @param context
     * @param objectModel
     * @param desc The descrption of the component
     * @return The desc of the component to use
     */
    PipelineComponentDescription addTransformer(ExecutionContext context, 
                                                Map              objectModel,
                                                PipelineComponentDescription desc);
16980#/**
     * Add a serializer
     * @param context
     * @param objectModel
     * @param desc The descrption of the component
     * @return The desc of the component to use
     */
    PipelineComponentDescription addSerializer(ExecutionContext context, 
                                               Map              objectModel,
                                               PipelineComponentDescription desc);
16981#/**
     * Add a reader
     * @param context
     * @param objectModel
     * @param desc The descrption of the component
     * @return The desc of the component to use
     */
    PipelineComponentDescription addReader(ExecutionContext context, 
                                           Map              objectModel,
                                           PipelineComponentDescription desc);
16982#/**
     * This informs the executor about a new pipeline section.
     * @param context
     * @param objectModel
     * @param desc
     * @return A (new) description for the pipeline component to use.
     */
    PipelineComponentDescription enteringPipeline(ExecutionContext context,
                                                  Map              objectModel,
                                                  PipelineComponentDescription desc);
16983#/**
     * Informs about a redirect.
     * @return The uri to redirect to.
     */
    String redirectTo(ExecutionContext context,
                      Map              objectModel,
                      String           uri,
                      boolean          createSession,
                      boolean          global,
                      boolean          permanent);
16984#/**
     * Return the location of the statement in the sitemap.
     */
    Location getLocation();
16985#/**
     * Return the component type
     */
    String getType();
16986#void enteredSitemap(EnterSitemapEvent event);
16987#public LeaveSitemapEvent(Processor source, Environment env) {
        super(source, env);
    }
16988#/**
     * Construct a new <code>PatternException</code> instance.
     */
    public PatternException(String message) {
        super(message, null);
    }
16989#/**
     * Creates a new <code>PatternException</code> instance.
     *
     * @param ex an <code>Exception</code> value
     */
    public PatternException(Exception ex) {
        super(ex.getMessage(), ex);
    }
16990#/**
     * Construct a new <code>PatternException</code> that references
     * a parent Exception.
     */
    public PatternException(String message, Throwable t) {
        super(message, t);
    }
16991#public Map act(Redirector redirector,
                    SourceResolver resolver,
                    Map objectModel,
                    String src,
                    Parameters par
    ) throws Exception {
        final String cacheRole = par.getParameter("cache-role", Cache.ROLE);
        Cache cache = null;

        try {
            cache = (Cache)this.manager.lookup(cacheRole);
            cache.clear();
            return EMPTY_MAP;
        } catch (Exception ex) {
	        if (this.getLogger().isDebugEnabled()) {
                getLogger().debug("Exception while trying to clear Cache with role " + cacheRole, ex);
            }
            return null;
        } finally {
            this.manager.release( cache );
        }
    }
16992#/* (non-Javadoc)
     * @see org.apache.cocoon.acting.Action#act(org.apache.cocoon.environment.Redirector, org.apache.cocoon.environment.SourceResolver, java.util.Map, java.lang.String, org.apache.avalon.framework.parameters.Parameters)
     */
    public Map act(Redirector redirector, SourceResolver resolver,
                   Map objectModel, String source, Parameters parameters)
        throws Exception {

        HashMap map = null;
        Configuration conf = null;
        String module = parameters.getParameter("module", (String) this.settings.get("module"));
        String attrib =
            parameters.getParameter("attribute", (String) this.settings.get("attribute"));
        boolean single =
            parameters.getParameterAsBoolean(
                "single-value",
                ((Boolean) this.settings.get("single-value")).booleanValue());

        if (module != null && attrib != null) {
            InputModuleHelper mhelper = new InputModuleHelper();
            mhelper.setup(manager);
            Object[] result = null;
            if (!single) {
                result = mhelper.getAttributeValues(objectModel, conf, module, attrib, null);
            } else {
                Object tmp = mhelper.getAttribute(objectModel, conf, module, attrib, null);
                if (tmp != null){
                    result = new Object[1];
                    result[0] = tmp;
                }
            }
            mhelper.releaseAll();

            if (result != null && result.length != 0) {
                map = new HashMap();
                for (int i = 0; i < result.length; i++) {
                    map.put(Integer.toString(i), result[i]);
                }
            }
        } else {
            if (getLogger().isErrorEnabled()) {
                getLogger().error(
                    "Parameter is missing: module=" + module + " attribute=" + attrib);
            }
        }
        return map;
    }
16993#/* (non-Javadoc)
     * @see org.apache.avalon.framework.configuration.Configurable#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration conf) throws ConfigurationException {
        super.configure(conf);
        String tmp = (String) this.settings.get("single-value", "false");
        this.settings.put("single-value", BooleanUtils.toBooleanObject(tmp));
    }
16994#/* (non-Javadoc)
     * @see org.apache.cocoon.acting.AbstractValidatorAction#createMapOfParameters(java.util.Map, java.util.Collection)
     */
    protected HashMap createMapOfParameters(Map objectModel, Collection set) {
        String name;
        HashMap params = new HashMap(set.size());
        // put required params into hash
        HttpSession session = ObjectModelHelper.getRequest(objectModel).getSession();
        for (Iterator i = set.iterator(); i.hasNext();) {
            name = ((Configuration) i.next()).getAttribute("name", "").trim();
            Object value = session.getAttribute(name);
            params.put(name, value);
        }
        return params;
    }
16995#/* (non-Javadoc)
     * @see org.apache.cocoon.acting.AbstractValidatorAction#setResult(java.util.Map, java.util.Map, java.util.Map, boolean)
     */
    protected Map setResult(Map objectModel, Map actionMap, Map resultMap, boolean allOK) {
        if (allOK){
            HttpSession session = ObjectModelHelper.getRequest(objectModel).getSession();
            for (Iterator i = actionMap.keySet().iterator(); i.hasNext(); ){
                String name = (String) i.next();
                session.setAttribute(name, actionMap.get(name));
            }
        }
        return super.setResult(objectModel, actionMap, resultMap, allOK);
    }
16996#/* (non-Javadoc)
     * @see org.apache.cocoon.acting.AbstractValidatorAction#isStringEncoded()
     */
    boolean isStringEncoded() {
        return false;
    }
16997#public void configure(Configuration conf) throws ConfigurationException {
        super.configure(conf);
        this.defaults = super.settings.keySet().toArray();
    }
16998#public Map act(Redirector redirector, SourceResolver resolver,
                   Map objectModel, String source, Parameters parameters)
    throws Exception {
        final Map results = new HashMap();

        final Response response = ObjectModelHelper.getResponse(objectModel);

        // Process local configuration parameters
        final String[] names = parameters.getNames();
        for (int i = 0; i < names.length; i++) {
            response.setHeader(names[i],parameters.getParameter(names[i]));
            results.put(names[i], parameters.getParameter(names[i]));
        }

        // Process global defaults, that are not overridden
        for (int i = 0; i < defaults.length; i++) {
            if (!results.containsKey(this.defaults[i])) {
                response.setHeader((String) this.defaults[i], (String) this.settings.get(defaults[i]));
                results.put(this.defaults[i], this.settings.get(defaults[i]));
            }
        }

        return Collections.unmodifiableMap(results);
    }
16999#/**
     * Reads parameter values from request parameters for all parameters
     * that are contained in the active constraint list. If a parameter
     * has multiple values, all are stored in the resulting map.
     * 
     * @param objectModel the object model
     * @param set a collection of parameter names
     * @return HashMap of required parameters 
     */
    protected HashMap createMapOfParameters(Map objectModel, Collection set) {
        String name;
        HashMap params = new HashMap(set.size());
        // put required params into hash
        Request request = ObjectModelHelper.getRequest(objectModel);
        for (Iterator i = set.iterator(); i.hasNext();) {
            name = ((Configuration) i.next()).getAttribute("name", "").trim();
            Object[] values = request.getParameterValues(name);
            if (values != null) {
                switch (values.length) {
                    case 0 :
                        params.put(name, null);
                        break;
                    case 1 :
                        params.put(name, values[0]);
                        break;
                    default :
                        params.put(name, values);
                }
            } else {
                params.put(name, values);
            }
        }
        return params;
    }
17000#/* (non-Javadoc)
     * @see org.apache.cocoon.acting.AbstractValidatorAction#isStringEncoded()
     */
    boolean isStringEncoded() {
        return true;
    }
17001#/**
     * @see Parameterizable#parameterize(org.apache.avalon.framework.parameters.Parameters)
     * @throws ParameterException
     */
    public void parameterize(Parameters params) 
    throws ParameterException {
        String modeDef = params.getParameter("mode", null);
        if ( modeDef != null ) {
            if ( MODEDEF_OBJECT_MODEL.equals(modeDef) ) {
                this.mode = MODE_OBJECT_MODEL;
            } else if ( MODEDEF_REQUEST_ATTR.equals(modeDef) ) {
                this.mode = MODE_REQUEST_ATTR;
            } else if ( MODEDEF_SESSION_ATTR.equals(modeDef) ) {
                this.mode = MODE_SESSION_ATTR;
            } else {
                throw new ParameterException("Unknown mode: " + this.mode);
            }
        }
    }
17002#/**
     * @see org.apache.cocoon.acting.Action#act(org.apache.cocoon.environment.Redirector, org.apache.cocoon.environment.SourceResolver, java.util.Map, java.lang.String, org.apache.avalon.framework.parameters.Parameters)
     */
    public Map act(Redirector redirector,
                   SourceResolver resolver,
                   Map objectModel,
                   String source,
                   Parameters parameters)
    throws Exception {
        final String[] names = parameters.getNames();
        for(int i = 0; i < names.length; i++) {
            final String name = names[i];
            if ( this.mode == MODE_OBJECT_MODEL ) {
                objectModel.put(name, parameters.getParameter(name));                
            } else if ( this.mode == MODE_REQUEST_ATTR ) {
                ObjectModelHelper.getRequest(objectModel).setAttribute(name, parameters.getParameter(name));                
            } else if ( this.mode == MODE_SESSION_ATTR ) {
                ObjectModelHelper.getRequest(objectModel).getSession().setAttribute(name, parameters.getParameter(name));                
            }
        }
        return EMPTY_MAP;
    }
17003#public void configure(Configuration configuration)
    throws ConfigurationException {
        super.configure(configuration);

        // RFC-822 Date with a GMT based time zone
        this.formatter = FastDateFormat.getInstance("EEE, dd MMM yyyy kk:mm:ss zzz", DateUtils.UTC_TIME_ZONE);
        this.days = configuration.getChild("days").getValueAsInteger(0);
        this.hours = configuration.getChild("hours").getValueAsInteger(0);
        this.minutes = configuration.getChild("minutes").getValueAsInteger(0);
        this.seconds = configuration.getChild("seconds").getValueAsInteger(0);
    }
17004#public Map act(Redirector redirector, SourceResolver resolver,
                   Map objectModel, String source, Parameters parameters)
    throws Exception {
        Response response = ObjectModelHelper.getResponse(objectModel);
        Calendar calendar = Calendar.getInstance(DateUtils.UTC_TIME_ZONE);
        Map values = new HashMap(3);

        /* Get the current time and output as the last modified header */
        String value = this.formatter.format(calendar);
        long maxage = calendar.getTime().getTime();
        response.setHeader("Last-Modified", value);
        values.put("last-modified",  value);

        /* Advance the time as much as required */
        calendar.add(Calendar.DATE, this.days);
        calendar.add(Calendar.HOUR, this.hours);
        calendar.add(Calendar.MINUTE, this.minutes);
        calendar.add(Calendar.SECOND, this.seconds);

        /* Recalculate time and age to see what changed */
        maxage = calendar.getTime().getTime() - maxage;

        /* If we got more than one second everything is quite normal */
        if (maxage > 1000) {
            value = this.formatter.format(calendar);
            response.setHeader("Expires", value);
            values.put("expires", value);

            value = "max-age=" + Long.toString(maxage / 1000l);
            response.setHeader("Cache-Control", value);
            values.put("cache-control", value);

        /* If we got less than one second (even negatives) no cache */
        } else {
            /* We still hold the old value from Last-Modified here */
            response.setHeader("Expires", value);
            values.put("expires", value);

            response.setHeader("Cache-Control", "no-cache");
            values.put("cache-control", "no-cache");
        }

        /* Return the headers */
        return(Collections.unmodifiableMap(values));
    }
17005#public void configure(Configuration conf) throws ConfigurationException {
        super.configure(conf);
        Configuration[] dflts = conf.getChildren();
        if (dflts != null) {
            this.defaults = new ArrayList(dflts.length);
            for (int i = 0; i < dflts.length; i++) {
                this.defaults.add(
                    new Entry(
                        dflts[i].getName(),
                        dflts[i].getValue()));
            }
        } else {
            this.defaults = new ArrayList(0);
        }
    }
17006#/**
     * Main invocation routine.
     */
    public Map act (Redirector redirector, SourceResolver resolver, Map objectModel, String src,
                    Parameters parameters) throws Exception {
        Request req = ObjectModelHelper.getRequest(objectModel);
        HashMap actionMap = new HashMap ();

        /* check session validity */
        HttpSession session = req.getSession (false);
        if (session == null) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("No session object");
            }
            return null;
        }

        try {
            String[] names = parameters.getNames();

            // parameters
            for (int i = 0; i < names.length; i++) {
                String sessionParamName = names[i];
                String value = parameters.getParameter(sessionParamName);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Propagating value "
                                      + value
                                      + " to session attribute "
                                      + sessionParamName);
                }
                session.setAttribute(sessionParamName, value);
                actionMap.put(sessionParamName, value);
            }

            // defaults, that are not overridden
            for (int i = 0; i < defaults.size(); i++) {
                final Entry entry = (Entry)defaults.get(i);
                if (!actionMap.containsKey(entry.key)) {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("Propagating value "
                                          + entry.value
                                          + " to session attribute "
                                          + entry.key);
                    }  
                    session.setAttribute(entry.key, entry.value);
                    actionMap.put(entry.key, entry.value);
                }
            }
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("All params propagated " + "to session");
            }
            return Collections.unmodifiableMap(actionMap);
        } catch (Exception e) {
            getLogger().warn("exception: ", e);
        }
        return null;
    }
17007#public Entry(String key, String value) {
            this.key = key;
            this.value = value;
        }
17008#/**
     * A simple Action that logs a given message for a given log level.
     */
    public Map act(Redirector redirector, SourceResolver resolver, Map objectModel, String src, Parameters par)
            throws Exception {

        final String logLevel = (par.getParameter(PARAM_LEVEL) != null ? (String) par.getParameter(PARAM_LEVEL)
                : LEVEL_DEFAULT);
        final String logMsg = (par.getParameter(PARAM_MSG) != null ? (String) par.getParameter(PARAM_MSG) : MSG_DEFAULT);

        if (par.getParameterAsBoolean(PARAM_CONSOLE, CONSOLE_DEFAULT)) {
            System.out.println(logMsg);
        }

        if (logLevel.equalsIgnoreCase("info")) {
            if (log.isInfoEnabled()) {
                log.info(logMsg);
            }
        } else {
            if (logLevel.equalsIgnoreCase("warn")) {
                if (log.isWarnEnabled()) {
                    log.warn(logMsg);
                }
            } else {
                if (logLevel.equalsIgnoreCase("error")) {
                    if (log.isErrorEnabled()) {
                        log.error(logMsg);
                    }
                } else {
                    if (logLevel.equalsIgnoreCase("fatal")) {
                        if (log.isFatalEnabled()) {
                            log.fatal(logMsg);
                        }
                    } else {
                        if (log.isDebugEnabled()) {
                            log.debug(logMsg);
                        }
                    }
                }
            }
        }

        return null;
    }
17009#public Map act(Redirector redirector, SourceResolver resolver, Map objectModel,
                   String source, Parameters param) throws Exception {

        Request request = ObjectModelHelper.getRequest(objectModel);

        Map map = new HashMap();

        map.put(MAP_URI, request.getRequestURI());

        String query = request.getQueryString();
        if (query != null && query.length() > 0) {
            map.put(MAP_QUERY, "?" + query);
        } else {
            map.put(MAP_QUERY, "");
        }

        map.put(MAP_CONTEXTPATH, request.getContextPath());

        if ("true".equalsIgnoreCase(param.getParameter(PARAM_PARAMETERS, null))) {
            Enumeration e = request.getParameterNames();
            while (e.hasMoreElements()) {
                String name = (String)e.nextElement();
                String value = request.getParameter(name);

                if (value != null && !map.containsKey(name)) {
                    map.put(name, value);
                }
            }

            String[] paramNames = param.getNames();
            for (int i = 0; i < paramNames.length; i++) {
                if (paramNames[i].startsWith(PARAM_DEFAULT_PREFIX)
                        && (request.getParameter(paramNames[i].substring(PARAM_DEFAULT_PREFIX.length())) == null)) {
                    map.put(paramNames[i].substring(PARAM_DEFAULT_PREFIX.length()),
                            param.getParameter(paramNames[i]));
                }
            }
        }
        return (map);
    }
17010#public void parameterize(Parameters parameters)
    throws ParameterException {
        // super.parameterize(parameters);

        global_form_encoding = parameters.getParameter("form-encoding", null);
    }
17011#/**
     * Set character encoding of current request.
     */
    public Map act (Redirector redirector, SourceResolver resolver, Map objectModel, String src, Parameters par) throws Exception {
        Request request = ObjectModelHelper.getRequest(objectModel);
        if (request != null) {
            String form_encoding = par.getParameter("form-encoding", global_form_encoding);
            if (form_encoding != null) {
                request.setCharacterEncoding(form_encoding);
            }
        }

        return null;
    }
17012#/**
     * A simple Action that logs if the <code>Session</code> object
     * has been created
     */
    public Map act (Redirector redirector, SourceResolver resolver, Map objectModel, String src, Parameters par) throws Exception {
        Request request = ObjectModelHelper.getRequest(objectModel);
        if (request != null) {
            HttpSession session = request.getSession (false);

            if (session != null) {
                if (session.isNew()) {
                    getLogger().debug("Session is new");
                } else {
                    getLogger().debug("Session is old");
                }
            } else {
                getLogger().debug("A session object was not created");
            }
        }

        return null;
    }
17013#public Map act(Redirector redirector, SourceResolver resolver, Map objectModel, String src, Parameters parameters) throws Exception {
        String resourceURI = parameters.getParameter("url", src);
        Source source = null;
        try {
            source = resolver.resolveURI(resourceURI);
            if (source.exists()) {
                return EMPTY_MAP;
            }
        } catch (SourceNotFoundException e) {
            // Do not log
        } catch (Exception e) {
            getLogger().warn("Exception resolving resource " + resourceURI, e);
        } finally {
            if (source != null) {
                resolver.release(source);
            }
        }
        return null;
    }
17014#/**
     * Main invocation routine.
     */
    public Map act (Redirector redirector, SourceResolver resolver, Map objectModel, String src,
            Parameters parameters) throws Exception {
        Request req = ObjectModelHelper.getRequest(objectModel);

        /* check session validity */
        HttpSession session = req.getSession (false);
        if (session != null) {
            session.invalidate ();
            if (this.getLogger().isDebugEnabled()) {
                getLogger ().debug ("SESSIONINVALIDATOR: session invalidated");
            }
        } else {
            if (this.getLogger().isDebugEnabled()) {
                getLogger ().debug ("SESSIONINVALIDATOR: no session object");
            }
        }

        return EMPTY_MAP; // cut down on object creation
    }
17015#/* (non-Javadoc)
     * @see org.apache.avalon.framework.configuration.Configurable#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration config) throws ConfigurationException {
        this.outputConf = config.getChild(CONFIG_OUTPUT_MODULE);
        this.outputName = this.outputConf.getAttribute("name", OUTPUT_HINT);
        this.storeEmpty =
            config.getChild(CONFIG_STORE_EMPTY).getValueAsBoolean(this.storeEmpty);

        Configuration[] dflts = config.getChild("defaults").getChildren("default");
        if (dflts != null) {
            this.defaults = new ArrayList(dflts.length);
            for (int i = 0; i < dflts.length; i++) {
                this.defaults.add(
                        new Entry(dflts[i].getAttribute("name"),
                                  dflts[i].getAttribute("value")));
            }
        } else {
            this.defaults = new ArrayList(0);
        }
    }
17016#/* (non-Javadoc)
     * @see org.apache.cocoon.acting.Action#act(Redirector, SourceResolver, Map, String, Parameters)
     */
    public Map act(Redirector redirector,
                   SourceResolver resolver,
                   Map objectModel,
                   String source,
                   Parameters parameters)
    throws Exception {
        // Read action parameters
        String outputName = parameters.getParameter(ACTION_PREFIX + CONFIG_OUTPUT_MODULE,
                                                    null);
        boolean storeEmpty = parameters.getParameterAsBoolean(ACTION_PREFIX + CONFIG_STORE_EMPTY,
                                                              this.storeEmpty);
        parameters.removeParameter(ACTION_PREFIX + CONFIG_OUTPUT_MODULE);
        parameters.removeParameter(ACTION_PREFIX + CONFIG_STORE_EMPTY);

        Configuration outputConf = null;
        if (outputName == null) {
            outputName = this.outputName;
            outputConf = this.outputConf;
        }

        // Action results map
        final Map results = new HashMap();

        OutputModule output = null;
        ServiceSelector selector = null;
        try {
            selector = (ServiceSelector) this.manager.lookup(OutputModule.ROLE + "Selector");
            if (outputName != null
                && selector != null
                && selector.isSelectable(outputName)) {

                output = (OutputModule) selector.select(outputName);

                String[] names = parameters.getNames();
                for (int i = 0; i < names.length; i++) {
                    String name = names[i];
                    String value = parameters.getParameter(name);
                    if (storeEmpty || (value != null && !value.equals(""))) {
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("Propagating <" + name + "> value <" + value + ">");
                        }
                        output.setAttribute(outputConf,
                                            objectModel,
                                            name,
                                            value);
                        results.put(name, value);
                    }
                }

                // Defaults, that are not overridden
                for (Iterator i = defaults.iterator(); i.hasNext();) {
                    Entry entry = (Entry) i.next();
                    if (!results.containsKey(entry.key)) {
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("Propagating default <" + entry.key + "> value <" + entry.value + ">");
                        }
                        output.setAttribute(outputConf,
                                            objectModel,
                                            entry.key,
                                            entry.value);
                        results.put(entry.key, entry.value);
                    }
                }

                output.commit(outputConf, objectModel);
            }
        } catch (Exception e) {
            if (output != null) {
                output.rollback(outputConf, objectModel, e);
            }
            throw e;
        } finally {
            if (selector != null) {
                if (output != null) {
                    selector.release(output);
                }
                this.manager.release(selector);
            }
        }

        return Collections.unmodifiableMap(results);
    }
17017#public Entry(String key, String value) {
            this.key = key;
            this.value = value;
        }
17018#/**
     * Main invocation routine.
     */
    public Map act (Redirector redirector, SourceResolver resolver, Map objectModel, String src,
            Parameters parameters) throws Exception {
        Request req = ObjectModelHelper.getRequest(objectModel);

        /* check session validity */
        HttpSession session = req.getSession (false);
        if (session == null) {
            if (this.getLogger().isDebugEnabled()) {
                getLogger().debug("No session object");
            }
            return null;
        }
        if (!req.isRequestedSessionIdValid()) {
            if (this.getLogger().isDebugEnabled()) {
                getLogger().debug("Requested session id is invalid");
            }
            return null;
        }

        return EMPTY_MAP;
    }
17019#public Map act(Redirector redirector,
                    SourceResolver resolver,
                    Map objectModel,
                    String src,
                    Parameters par
    ) throws Exception {
        if ( this.manager.hasService( Store.PERSISTENT_STORE) ) {
            final Store store_persistent = (Store)this.manager.lookup(Store.ROLE);

            try {
                store_persistent.clear();
                return EMPTY_MAP;
            } catch (Exception ex) {
                getLogger().debug("Exception while trying to Clearing the Store", ex);
                return null;
            } finally {
                this.manager.release( store_persistent );
            }
        } else {
            getLogger().info("Unable to clear persistent store as no persistent store is configured.");
            return null;
        }
    }
17020#/**
     * Configures the Action.
     */
    public void configure(Configuration conf) throws ConfigurationException {
        super.configure(conf);

        if (settings.containsKey("state-key-prefix")) {
            statekey = (String) settings.get("state-key-prefix");
        }
        if (settings.containsKey("new-state")) {
            newstate = (String) settings.get("new-state");
        }
        if (settings.containsKey("sub-levels")) {
            sublevels = Integer.parseInt((String) settings.get("sub-levels"));
        }
        if (settings.containsKey("state-level")) {
            mylevel = Integer.parseInt((String) settings.get("state-level"));
        }
    }
17021#public Map act(Redirector redirector,
                   SourceResolver resolver,
                   Map objectModel,
                   String src,
                   Parameters par) throws Exception {

        Request request = ObjectModelHelper.getRequest(objectModel);

        // read local settings
        String newstate = par.getParameter("new-state", this.newstate);
        String statekey = par.getParameter("state-key", this.statekey);
        int sublevels = par.getParameterAsInteger("sublevels", this.sublevels);
        int mylevel = par.getParameterAsInteger("state-level", this.mylevel);

        if (newstate == null) {
            if (this.getLogger().isDebugEnabled()) {
                getLogger().error("new-state is null");
            }
            return null;
        }

        if (request != null) {
            HttpSession session = request.getSession(false);

            if (session != null && request.isRequestedSessionIdValid()) {
                String oldstate = null;
                if (sublevels == 0) {
                    oldstate = (String) session.getAttribute(statekey);
                    session.setAttribute(statekey, newstate);
                    if (this.getLogger().isDebugEnabled()) {
                         getLogger().debug(statekey + "=" + newstate);
                    }

                } else { // sublevels != 0
                    oldstate = (String)session.getAttribute(statekey + mylevel);
                    for (int i = mylevel + 1; i <= sublevels; i++) {
                        session.removeAttribute(statekey + i);
                        if (this.getLogger().isDebugEnabled()) {
                            getLogger().debug("Remove " + statekey + i);
                        }
                    }
                    session.setAttribute(statekey + mylevel, newstate);
                    if (this.getLogger().isDebugEnabled()) {
                        getLogger().debug(statekey + mylevel + "=" + newstate);
                    }
                }
                if (this.getLogger().isDebugEnabled()) {
                    getLogger().debug("Transition " + oldstate + " -> " + newstate);
                }

                HashMap map = new HashMap(1);
                map.put("newstate", newstate);
                return map;
            } else {
                getLogger().warn(
                    "A session object was not present or no longer valid");
                return null;
            }
        } else {
            getLogger().warn("No request object");
            return null;
        }
    }
17022#public Map act( Redirector redirector,
            SourceResolver resolver,
            Map objectModel,
            String source,
            Parameters parameters
            )
    throws Exception {
        Request request = ObjectModelHelper.getRequest(objectModel);
        HashMap results = new HashMap();
        HashMap items = new HashMap();
        int wildcards = 0;

        // check default parameters for existence
        if (this.getLogger().isDebugEnabled()) {
            getLogger().debug("checking default parameters");
        }
        Iterator reqParams = settings.values().iterator();
        while (reqParams.hasNext()) {
            String paramName = (String) reqParams.next();
            StringParts sp = splitParameter(paramName);
            if (sp != null) {
                // wildcard: special care required (deferred until later)
                items.put(new Integer(wildcards++), sp);
                if (this.getLogger().isDebugEnabled()) {
                    getLogger().debug("(default) deferring " + paramName);
                }
            } else {
                String paramValue = request.getParameter(paramName);
                if (paramValue == null) {
                    return null;
                }
                results.put(paramName, paramValue);
            }
        }

        // check parameters for existence
        if (this.getLogger().isDebugEnabled()) {
            getLogger().debug("checking sitemap parameters");
        }
        String params = parameters.getParameter("parameters", null);
        if (params != null) {
            StringTokenizer st = new StringTokenizer(params);
            while (st.hasMoreTokens()) {
                String paramName = st.nextToken();
                StringParts sp = splitParameter(paramName);
                if (sp != null) {
                    // wildcard: special care required (deferred until later)
                    items.put(new Integer(wildcards++), sp);
                    if (this.getLogger().isDebugEnabled()) {
                        getLogger().debug("deferring " + paramName);
                    }
                } else {

                    String paramValue = request.getParameter(paramName);
                    if (paramValue == null) {
                        return null;
                    }
                    results.put(paramName, paramValue);
                }
            }
        }

        if (wildcards != 0) {
            // special care for parameters with wildcard
            //
            if (this.getLogger().isDebugEnabled()) {
                getLogger().debug("deferred checking for parameters: " + wildcards);
            }

            // first one
            //
            if (this.getLogger().isDebugEnabled()) {
                getLogger().debug(" checking first");
            }
            HashMap values = new HashMap();
            StringParts sp1 = (StringParts) items.get(new Integer(0));
            if (this.getLogger().isDebugEnabled()) {
                getLogger().debug(
                    "  Parameter is [" + sp1.prefix + " * " + sp1.pstfix + "] ");
            }
            Enumeration requestParams = request.getParameterNames();
            Boolean dummy = Boolean.TRUE;
            while (requestParams.hasMoreElements()) {
                String paramName = (String) requestParams.nextElement();
                String match = getMatch(paramName, sp1);
                if (match != null) {
                    if (this.getLogger().isDebugEnabled()) {
                        getLogger().debug(
                            "  value is >"
                            + match
                            + "< "
                            + sp1.prefix.length()
                            + " "
                            + paramName.length()
                            + " "
                            + sp1.pstfix.length());
                    }
                    values.put(match, dummy);
                    sp1.count++;
                    if (this.getLogger().isDebugEnabled()) {
                        getLogger().debug(
                            "   Parameter "
                            + sp1.prefix
                            + "*"
                            + sp1.pstfix
                            + " matches "
                            + paramName
                            + " ("
                            + sp1.count
                            + " so far)");
                    }
                    String paramValue = request.getParameter(paramName);
                    if (paramValue == null) {
                        return null;
                    }
                    results.put(paramName, paramValue);
                }
            }

            if (sp1.count == 0) {
                if (this.getLogger().isDebugEnabled()) {
                    getLogger().debug(
                       "   Parameter "
                        + sp1.prefix
                        + "*"
                        + sp1.pstfix
                        + " matches "
                        + sp1.count);
                }
                return null;
            }

            // all other ones
            //
            if (this.getLogger().isDebugEnabled()) {
                getLogger().debug(" checking others");
            }
            requestParams = request.getParameterNames();
            while (requestParams.hasMoreElements()) {
                String paramName = (String) requestParams.nextElement();
                if (this.getLogger().isDebugEnabled()) {
                    getLogger().debug("  checking request parameter " + paramName);
                }
                for (int i = wildcards - 1; i > 0; i--) {
                    if (this.getLogger().isDebugEnabled()) {
                        getLogger().debug("   checking against " + i);
                    }
                    StringParts sp = (StringParts) items.get(new Integer(i));
                    String match = getMatch(paramName, sp);
                    if (this.getLogger().isDebugEnabled()) {
                        getLogger().debug(
                            "   Parameter is ["
                            + sp.prefix
                            + " * "
                            + sp.pstfix
                            + "] ");
                    }
                    if (match != null) {
                        if (this.getLogger().isDebugEnabled()) {
                            getLogger().debug(
                                "   Parameter "
                                    + sp.prefix
                                    + "*"
                                    + sp.pstfix
                                    + " matches "
                                    + paramName
                                    + " ("
                                    + sp.count
                                    + " so far)");
                        }
                        if (values.containsKey(match)) {
                            sp.count++;
                            if (this.getLogger().isDebugEnabled()) {
                                getLogger().debug(
                                "   " + paramName + " (verified)");
                            }
                            String paramValue = request.getParameter(paramName);
                            if (paramValue == null) {
                                return null;
                            }
                            results.put(paramName, paramValue);

                        } else {
                            if (this.getLogger().isDebugEnabled()) {
                                getLogger().debug(
                                    "Match "
                                    + match
                                    + "not found for "
                                    + sp1.prefix
                                    + "*"
                                    + sp1.pstfix
                                    + " but for "
                                    + sp.prefix
                                    + "*"
                                    + sp.pstfix);
                            }
                            return null;
                        }
                    }
                }
            }

            // since we enforce that only matches are counted, that exist for
            // the first parameter as well, check if every parameter has an
            // equal number of matches.
            //
            if (this.getLogger().isDebugEnabled()) {
                getLogger().debug("checking number of matches");
            }
            for (int i = wildcards - 1; i > 0; i--) {
                StringParts sp = (StringParts) items.get(new Integer(i));
                if (sp.count != sp1.count) {
                    if (this.getLogger().isDebugEnabled()) {
                        getLogger().debug(
                            "Found "
                            + sp.count
                            + " matches for "
                            + sp.prefix
                            + "*"
                            + sp.pstfix
                            + " but expected "
                            + sp1.count);
                    }
                    return null;
                } else {
                    if (this.getLogger().isDebugEnabled()) {
                        getLogger().debug(
                            "Found "
                            + sp.count
                            + " matches for "
                            + sp.prefix
                            + "*"
                            + sp.pstfix
                            + " as expected");
                    }
                }
            }

        }

        return Collections.unmodifiableMap(results);
    }
17023#/**
     * Find first "*" in a String and split it into the substring
     * before and after the "*". Returns null if no "*" is present.
     */
    protected StringParts splitParameter( String paramName )
    {
    int idx = paramName.indexOf("*");
    if ( idx != -1 ) {
        return new StringParts(paramName.substring(0,idx), paramName.substring(idx+1));
    } else {
        return null;
    }
    }
17024#/**
     * If a String matches a StringPart spec, return the substring
     * between the specified prefix and postfix. Returns null if it
     * doesn't match.
     */
    protected String getMatch( String paramName,
                   StringParts sp
                   )
    {
    if ( paramName.startsWith( sp.prefix ) && paramName.endsWith( sp.pstfix ) ) {
        return paramName.substring( sp.prefix.length(), ( paramName.length() - sp.pstfix.length() ) );
    } else {
        return null;
    }
    }
17025#public StringParts ( String pre, String post ) {
            prefix = pre;
            pstfix = post;
        }
17026#protected Object getContextObject(Configuration modeConf,
                                      Map objectModel) {

        return ObjectModelHelper.getRequest(objectModel);
    }
17027#/* (non-Javadoc)
    * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
    */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
        this.resolver = (SourceResolver) manager.lookup(SourceResolver.ROLE);
    }
17028#/**
     * Static (cocoon.xconf) configuration.
     * Configuration is expected to be of the form:
     * &lt;...&gt;
     * &lt;reloadable&gt;<b>true</b>|false&lt;/reloadable&gt;
     * &lt;cacheable&gt;<b>true</b>|false&lt;/cacheable&gt;
     * &lt;cache-role&gt;org.apache.excalibur.store.Store/TransientStore&lt;/cache-role&gt;
     * &lt;file src="<i>src</i>"/&gt;
     * ...
     * &lt;/...&gt;
     * <p/>
     * The &lt;file/&gt; element specifies a file pattern. Only one
     * &lt;file&gt; can be specified, however it can contain references to input modules which will be resolved
     * each time the module is used. The configured <i>src</i> is used if not
     * overridden via a file parameter in the sitemap.
     *
     * @param config a <code>Configuration</code> value, as described above.
     * @throws org.apache.avalon.framework.configuration.ConfigurationException
     *          if an error occurs
     */
    public void configure(Configuration config) throws ConfigurationException {
        this.configuration = JXPathHelper.setup(config);
        this.staticConfLocation = config.getLocation();
        Configuration roleConfig = config.getChild("cache-role", true);
        boolean cacheAll = config.getChild("cacheable").getValueAsBoolean(true);
        this.reloadAll = config.getChild("reloadable").getValueAsBoolean(true);
        String cacheRole = roleConfig.getValue(ROLE);

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Using cache " + cacheRole);
        }

        try {
            this.cache = (Store) this.manager.lookup(cacheRole);
        } catch (ServiceException ce) {
            throw new ConfigurationException("Unable to lookup cache: " + cacheRole, ce);
        }

        Configuration fileConfig = config.getChild("file");

        this.src = fileConfig.getAttribute("src");
        this.cacheParm = fileConfig.getAttribute("cacheable", null);
        this.reloadParm = fileConfig.getAttribute("reloadable", null);
        if (this.cacheParm == null) {
            this.cacheSource = Boolean.valueOf(cacheAll);
        } else if (VariableResolverFactory.needsResolve(this.cacheParm)) {
            this.cacheSource = null;
        } else {
            this.cacheSource = Boolean.valueOf(this.cacheParm);
        }
        if (this.reloadParm == null) {
            this.reloadSource = Boolean.valueOf(this.reloadAll);
        } else if (VariableResolverFactory.needsResolve(this.reloadParm)) {
            this.reloadSource = null;
        } else {
            this.reloadSource = Boolean.valueOf(this.reloadParm);
        }

        // init caches
        this.cacheExpressions = config.getChild("cache-expressions").getValueAsBoolean(true);
        this.needsResolve = VariableResolverFactory.needsResolve(this.src);
    }
17029#/**
     * Dispose this component
     */
    public void dispose() {
        super.dispose();
        if (this.manager != null) {
            this.manager.release(this.resolver);
            this.manager.release(this.cache);
            this.resolver = null;
            this.cache = null;
            this.manager = null;
        }
    }
17030#public Object getAttribute(String name, Configuration modeConf, Map objectModel)
        throws ConfigurationException {
        return getAttribute(name, modeConf, objectModel, false);
    }
17031#public Object[] getAttributeValues(String name, Configuration modeConf, Map objectModel)
        throws ConfigurationException {
        Object result = getAttribute(name, modeConf, objectModel, true);
        return (result != null ? (Object[]) result : null);
    }
17032#/**
     * Get the DocumentInfo for the DOM object that JXPath will operate on when evaluating
     * attributes.  This DOM is loaded from a Source, specified in the
     * modeConf, or (if modeConf is null) from the
     * {@link #configure(org.apache.avalon.framework.configuration.Configuration)}.
     *
     * @param name The JXPath to retrieve
     * @param modeConf    The dynamic configuration for the current operation. May
     *                    be <code>null</code>, in which case static (cocoon.xconf) configuration
     *                    is used.  Configuration is expected to have a &lt;file> child node, and
     *                    be of the form:
     *                    &lt;...&gt;
     *                    &lt;file src="..." reloadable="true|false"/&gt;
     *                    &lt;/...&gt;
     * @param objectModel Object Model for the current module operation.
     * @param getValues true if multiple values should be retrieve, false otherwise
     * @return the result of the XPath query into the XML document
     * @throws ConfigurationException if an error occurs.
     */
    private Object getAttribute(String name, Configuration modeConf, Map objectModel, boolean getValues)
        throws ConfigurationException {

        if (modeConf != null) {
            name = modeConf.getChild("parameter").getValue(this.parameter != null ? this.parameter : name);
        }

        boolean hasDynamicConf = false; // whether we have a <file src="..."> dynamic configuration
        Configuration fileConf = null;  // the nested <file>, if any

        if (modeConf != null && modeConf.getChildren().length > 0) {
            fileConf = modeConf.getChild("file", false);
            if (fileConf == null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Missing 'file' child element at " + modeConf.getLocation());
                }
            } else {
                hasDynamicConf = true;
            }
        }

        String src = this.src;
        Boolean cacheSource = this.cacheSource;
        Boolean reloadSource = this.cacheSource;
        boolean needsResolve = this.needsResolve;
        String cacheParm = this.cacheParm;
        String reloadParm = this.reloadParm;

        if (hasDynamicConf) {
            src = fileConf.getAttribute("src");
            cacheParm = fileConf.getAttribute("cacheable", this.cacheParm);
            reloadParm = fileConf.getAttribute("reloadable", this.reloadParm);
            if (cacheParm == null) {
                cacheSource = this.cacheSource;
            } else if (VariableResolverFactory.needsResolve(cacheParm)) {
                cacheSource = null;
                if (cacheSource == null) {
                    try {
                        VariableResolver varResolver = VariableResolverFactory.getResolver(cacheParm, this.manager);
                        cacheSource = Boolean.valueOf(varResolver.resolve(objectModel));
                    } catch (PatternException pe) {
                        throw new ConfigurationException("Unable to resolve " + cacheParm, pe);
                    }
                }
            } else {
                cacheSource = Boolean.valueOf(cacheParm);
            }
            if (reloadParm == null) {
                reloadSource = this.reloadSource;
            } else if (VariableResolverFactory.needsResolve(reloadParm)) {
                reloadSource = null;
            } else {
                reloadSource = Boolean.valueOf(reloadParm);
            }
            needsResolve = true;
        }
        if (cacheSource == null) {
            try {
                VariableResolver varResolver = VariableResolverFactory.getResolver(cacheParm, this.manager);
                cacheSource = Boolean.valueOf(varResolver.resolve(objectModel));
            } catch (PatternException pe) {
                throw new ConfigurationException("Unable to resolve " + cacheParm, pe);
            }
        }
        if (reloadSource == null) {
            try {
                VariableResolver varResolver =
                    VariableResolverFactory.getResolver(reloadParm, this.manager);
                reloadSource = Boolean.valueOf(varResolver.resolve(objectModel));
            } catch (PatternException pe) {
                throw new ConfigurationException("Unable to resolve " + reloadParm, pe);
            }
        }

        if (src == null) {
            throw new ConfigurationException(
                "No source specified"
                    + (modeConf != null ? ", either dynamically in " + modeConf.getLocation() + ", or " : "")
                    + " statically in "
                    + staticConfLocation);
        }

        if (needsResolve) {
            try {
                VariableResolver varResolver = VariableResolverFactory.getResolver(src, this.manager);
                src = varResolver.resolve(objectModel);
            } catch (PatternException pe) {
                throw new ConfigurationException("Error resolving variables for " + src, pe);
            }
        }

        Object result;

        if (cacheSource.booleanValue()) {
            DocumentInfo info = (DocumentInfo) this.cache.get(src);
            if (info == null || (reloadSource.booleanValue() && !info.isValid())) {
                Source docSource = null;
                try {
                    docSource = resolver.resolveURI(src);
                    DocumentInfo newInfo =  new DocumentInfo(src, SourceUtil.toDOM(this.manager, docSource),
                        docSource.getValidity(), this.cacheExpressions, this.resolver);
                    synchronized(this.cache) {
                        DocumentInfo cachedInfo = (DocumentInfo)this.cache.get(src);
                        if (cachedInfo == null || cachedInfo == info) {
                            this.cache.store(src, newInfo);
                            info = newInfo;
                        } else {
                            info = cachedInfo;
                        }
                    }
                } catch (MalformedURLException mue) {
                    throw new ConfigurationException("Unable to resolve " + src, mue);
                } catch (IOException ioe) {
                    throw new ConfigurationException("Unable to access" + src, ioe);
                } catch (ProcessingException pe) {
                    throw new ConfigurationException("Unable to process " + src, pe);
                } catch (SAXException se) {
                    throw new ConfigurationException("Error processing XML document " + src, se);
                } finally {
                    if (docSource != null) {
                        resolver.release(docSource);
                    }
                }
            }
            if (info.cacheExpressions) {
                Map cache = getValues ? info.expressionValuesCache : info.expressionCache;
                synchronized (cache) {
                    if (cache.containsKey(name)) {
                        result = cache.get(name);
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("for " + name + " using cached result " + result);
                        }
                    } else {
                        result = getResult(name, info.document, modeConf, getValues);
                        if (result != null) {
                            cache.put(name, result);
                            if (getLogger().isDebugEnabled()) {
                                getLogger().debug("for " + name + " newly caching result " + result);
                            }
                        } else {
                            if (getLogger().isDebugEnabled()) {
                                getLogger().debug("for " + name + " result is null");
                            }
                        }
                    }
                }
            } else {
                result = getResult(name, info.document, modeConf, getValues);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("for " + name + " result is " + result);
                }
            }
        } else {
            Source docSource = null;
            try {
                docSource = resolver.resolveURI(src);
                result = getResult(name, SourceUtil.toDOM(this.manager, docSource), modeConf, getValues);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("for " + name + " result is " + result);
                }
            } catch (MalformedURLException mue) {
                throw new ConfigurationException("Unable to resolve " + src, mue);
            } catch (IOException ioe) {
                throw new ConfigurationException("Unable to access" + src, ioe);
            } catch (ProcessingException pe) {
                throw new ConfigurationException("Unable to process " + src, pe);
            } catch (SAXException se) {
                throw new ConfigurationException("Error processing XML document " + src, se);
            } finally {
                if (docSource != null) {
                    resolver.release(docSource);
                }
            }
        }

        return result;
    }
17033#private Object getResult(String name, Document document, Configuration modeConf, boolean getValues)
        throws ConfigurationException {
        Object result;

        if (getValues) {
            result = JXPathHelper.getAttributeValues(name, modeConf, this.configuration, document);
        } else {
            result = JXPathHelper.getAttributeValue(name, modeConf, this.configuration, document);
        }
        return result;
    }
17034#public DocumentInfo(String uri, Document doc, SourceValidity validity, boolean cacheExpressions,
                            SourceResolver resolver) {
            this.cacheExpressions = cacheExpressions;
            if (cacheExpressions) {
                expressionCache = new ReferenceMap(AbstractReferenceMap.SOFT, AbstractReferenceMap.SOFT);
                expressionValuesCache = new ReferenceMap(AbstractReferenceMap.SOFT, AbstractReferenceMap.SOFT);
            }
            this.resolver = resolver;
            this.uri = uri;
            this.document = doc;
            this.validity = validity;
        }
17035#/**
         * Returns true if the document is valid, false otherwise.
         * <p/>
         *
         * @return returns true if the document is valid, false otherwise.
         */
        private boolean isValid() {
            Source src = null;
            boolean result = true;

            try {
                int valid = validity == null ? SourceValidity.INVALID : validity.isValid();
                if (valid == SourceValidity.UNKNOWN) {
                    // Get new source and validity
                    src = resolver.resolveURI(this.uri);
                    SourceValidity newValidity = src.getValidity();
                    valid = validity.isValid(newValidity);
                }
                if (valid != SourceValidity.VALID) {
                    result = false;
                }
            }
            catch (Exception ex) {
                result = false;
            }
            finally {
                if (src != null) {
                    resolver.release(src);
                }
            }
            return result;
        }
17036#public Object getAttribute(String name,
                               Configuration modeConf,
                               Map objectModel) throws ConfigurationException {
        if (name == null) {
            return null;
        }

        String encoding = (String) this.settings.get("encoding", "utf-8");
        try {
            return NetUtils.decode(name, encoding);
        } catch (UnsupportedEncodingException e) {
            throw new ConfigurationException("URLDecodeModule, invalid encoding: " + encoding);
        }
    }
17037#public JXPathMetaModule() {
        // this value has a default in the super class
        super.defaultInput = "request-attr";
    }
17038#/**
     * Configure component. Preprocess list of packages and functions
     * to add to JXPath context later.
     *
     * @param config a <code>Configuration</code> value
     * @exception ConfigurationException if an error occurs
     */
    /**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration config) throws ConfigurationException {
        this.inputConf = config.getChild("input-module");
        this.defaultInput = this.inputConf.getAttribute("name",this.defaultInput);
        this.parameter = config.getChild("parameter").getValue(this.parameter);

        this.configuration = JXPathHelper.setup(config);
    }
17039#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttribute(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object getAttribute(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        Object contextObj = getContextObject(modeConf, objectModel);
        if (modeConf != null) {
            name = modeConf.getChild("parameter").getValue(!this.parameter.equals("") ? this.parameter : name);
        }
        return JXPathHelper.getAttributeValue(name, modeConf, this.configuration, contextObj);
    }
17040#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Iterator getAttributeNames(Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        Object contextObj = getContextObject(modeConf, objectModel);
        return JXPathHelper.getAttributeNames(this.configuration, contextObj);
    }
17041#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        Object contextObj = getContextObject(modeConf, objectModel);
        if (modeConf != null) {
            name = modeConf.getChild("parameter").getValue(!this.parameter.equals("") ? this.parameter : name);
        }
        return JXPathHelper.getAttributeValues(name, modeConf, this.configuration, contextObj);
    }
17042#/**
     * Looks up object from configured InputModule.
     *
     * @param modeConf a <code>Configuration</code> value
     * @param objectModel a <code>Map</code> value
     * @return an <code>Object</code> value
     * @throws ConfigurationException from called components.
     */
    protected  Object getContextObject(Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        if (!this.initialized) {
            lazy_initialize();
        }

        Configuration mConf = null;
        String inputName = null;
        String parameter = this.parameter;
        if (modeConf != null) {
            mConf = modeConf.getChild("input-module");
            inputName = mConf.getAttribute("name", null);
            parameter = modeConf.getChild("from-parameter").getValue(parameter);
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("modeConf is " + modeConf + " this.inputConf is " + this.inputConf
                              + " mConf is " + mConf + " this.input is " + this.input
                              + " this.defaultInput is " + this.defaultInput
                              + " inputName is " + inputName + " parameter is " + parameter);
        }

        Object obj = getValue(parameter, objectModel,
                              this.input, this.defaultInput, this.inputConf,
                              null, inputName, mConf);

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("returning an " + (obj == null ? "null" : obj.getClass().getName()) +
                              " as " + obj);
        }

        return obj;
    }
17043#public Object getAttribute( String name, Configuration modeConf, Map objectModel )
        throws ConfigurationException {

        String pname = (String) this.settings.get("parameter",name);
        if ( modeConf != null ) {
            pname = modeConf.getAttribute( "parameter", pname );
            // preferred
            pname = modeConf.getChild("parameter").getValue(pname);
        }
        return ObjectModelHelper.getRequest(objectModel).getHeader( pname );
    }
17044#public Iterator getAttributeNames( Configuration modeConf, Map objectModel )
        throws ConfigurationException {

        return new IteratorHelper(ObjectModelHelper.getRequest(objectModel).getHeaderNames());
    }
17045#public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
        throws ConfigurationException {

        Request request = ObjectModelHelper.getRequest(objectModel);
        String wildcard = (String) this.settings.get("parameter", name);
        if ( modeConf != null ) {
            wildcard = modeConf.getAttribute( "parameter", wildcard );
            // preferred
            wildcard = modeConf.getChild("parameter").getValue(wildcard);
        }
        int wildcardIndex = wildcard.indexOf( "*" );
        if ( wildcardIndex != -1 ) {
            // "*" contained in attribute name => combine all
            // attributes' values that match prefix, suffix
            
            // split the attribute's name so that the "*" could be
            // determined by looking at the attributes' names that
            // start with the prefix and end with the suffix
            //
            String prefix = wildcard.substring( 0, wildcardIndex );
            String suffix;
            if ( wildcard.length() >= wildcardIndex + 1 ) {
                suffix = wildcard.substring( wildcardIndex + 1 );
            } else {
                suffix = "";
            }
            SortedSet names = new TreeSet();
            Enumeration allNames = request.getHeaderNames();

            while (allNames.hasMoreElements()) {
                String pname = (String) allNames.nextElement();
                if ( pname.startsWith( prefix ) && pname.endsWith( suffix ) ) {
                    names.add(pname);
                }
            }

            List values = new LinkedList();
            Iterator j = names.iterator();
            while (j.hasNext()){
                String pname = (String) j.next();
                values.add( request.getHeader( pname ) );
            }
            
            return values.toArray();

        } else {
            // no "*" in attribute name => just return all values of
            // this one attribute. Make sure, it's an array.
            
            Object value = request.getHeader( wildcard );
            if ( value != null && !value.getClass().isArray() ) {
                Object[] values = new Object[1];
                values[0] = value;
                return values;
            } else {
                return (Object[]) value;
            }
            
        }
    
    }
17046#/**
     * @see org.apache.avalon.framework.configuration.Configurable#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration conf) throws ConfigurationException {
        this.projectBase = conf.getChild(PROJECT_PARAM_NAME).getValue();
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Configuration supplied: " + this.projectBase);
        }
        if (this.projectBase == null) {
       	    this.projectBase = PROJECT_PARAM_DEFAULT;
            if (getLogger().isWarnEnabled()) {
                getLogger().warn("No configuration supplied, using default: " + PROJECT_PARAM_DEFAULT);
            }
        }
        if (this.projectBase.equals("")) {
            this.projectBase = PROJECT_PARAM_DEFAULT;
            if (getLogger().isWarnEnabled()) {
                getLogger().warn("Empty configuration supplied, using default: " + PROJECT_PARAM_DEFAULT);
            }
        }
    }
17047#/**
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttribute(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object getAttribute(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        String uri = ObjectModelHelper.getRequest(objectModel).getServletPath();
        StringBuffer result = new StringBuffer(uri.length());
        int baseIndex = uri.indexOf(this.projectBase);
        if (baseIndex != -1) {
            uri = uri.substring(baseIndex + this.projectBase.length());
        } else {
            throw new ConfigurationException( "No project-base path found in URI");
        }
        try {
            // provide a relative path back to the project
            if (name.startsWith("relative")) {
                int nextIndex = 0;
                while ((nextIndex = uri.indexOf('/', nextIndex) + 1) > 0) {
                    result.append("../");
                }
            } else if (name.startsWith("path")) {
                // provide the full path from the project
                result.append("/");
                result.append(uri);
            } else if (name.startsWith("folder")) {
                // provide the folder path from the project
                result.append("/");
                result.append(uri.substring(0,uri.lastIndexOf("/") + 1));
            } else {
                if (getLogger().isWarnEnabled()) {
                    getLogger().warn("Invalid verb: " + name);
                }
            }
            return result;
        } catch( final Exception mue ) {
            throw new ConfigurationException( "Problems resolving project path.", mue);
        }
    }
17048#/**
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Iterator getAttributeNames( Configuration modeConf, Map objectModel )
    throws ConfigurationException {
        return ProjectPathModule.returnNames.iterator();
    }
17049#/**
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
    throws ConfigurationException {
        List values = new LinkedList();
        values.add( this.getAttribute(name, modeConf, objectModel) );

        return values.toArray();
    }
17050#/**
     * @throws SecurityException if access is denied
     */
    protected Object getContextObject(Configuration modeConf,
                                      Map objectModel) {
        return System.getProperties();
    }
17051#public Object getAttribute(String name,
                               Configuration modeConf,
                               Map objectModel) throws ConfigurationException {
        if (name == null) {
            return null;
        }

        String encoding = (String) this.settings.get("encoding", "utf-8");
        try {
            return NetUtils.encode(name, encoding);
        } catch (UnsupportedEncodingException e) {
            throw new ConfigurationException("URLEncodeModule, invalid encoding: " + encoding);
        }
    }
17052#public Object getAttribute(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        String uri = ObjectModelHelper.getContext(objectModel).getRealPath(name);
        if (uri == null) {
            return null;
        }

        int lastCharPos = uri.length() - 1;
        if (uri.charAt(lastCharPos) == '\\') {
            uri = uri.substring(0, lastCharPos);
        }
        return uri;
    }
17053#public Iterator getAttributeNames(Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        return RealPathModule.returnNames.iterator();
    }
17054#public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
    throws ConfigurationException {
        return new Object[] { getAttribute(name, modeConf, objectModel) };
    }
17055#/**
     * Fill in InitialContext properties from passed configuration.
     */
    public void configure(Configuration conf) throws ConfigurationException {
        Configuration[] parameters = conf.getChildren();
        this.properties = new Properties();
        for (int i = 0; i < parameters.length; i++) {
            String key = parameters[i].getName();
            String val = parameters[i].getValue("");
            this.properties.put(key, val);
        }
    }
17056#/**
     * Creates InitialContext with configured properties.
     */
    public void initialize() throws Exception {
        this.context = new InitialContext(this.properties);
    }
17057#/**
     * Close InitialContext.
     */
    public void dispose() {
        super.dispose();
        if (this.context != null) {
            try {
                this.context.close();
            } catch (NamingException ignored) {
            }
        }
    }
17058#/**
     * Look up <code>name</code> from the InitialContext.
     */
    public Object getAttribute(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {

        // Why properties can override passed name parameter? See RequestParameterModule
        String pname = (String) this.properties.get("path");
        if (pname == null) {
            pname = name;
        }

        if (modeConf != null) {
            pname = modeConf.getAttribute("path", pname);
            // preferred
            pname = modeConf.getChild("path").getValue(pname);
        }

        try {
            return this.context.lookup(pname);
        } catch (NamingException e) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Can't get parameter " + pname, e);
            }
            return null;
        }
    }
17059#/**
     * Returns empty iterator
     */
    public Iterator getAttributeNames(Configuration modeConf, Map objectModel)
    throws ConfigurationException {

        return Collections.EMPTY_LIST.iterator();
    }
17060#public Object getAttribute( String name, Configuration modeConf, Map objectModel )
        throws ConfigurationException {

        String pname = (String) this.settings.get("parameter", name);
        if ( modeConf != null ) {
            pname = modeConf.getAttribute( "parameter", pname );
            // preferred
            pname = modeConf.getChild("parameter").getValue(pname);
        }
        return ObjectModelHelper.getRequest(objectModel).getSession().getAttribute( pname );
    }
17061#public Iterator getAttributeNames( Configuration modeConf, Map objectModel )
        throws ConfigurationException {

        return new IteratorHelper(ObjectModelHelper.getRequest(objectModel).getSession().getAttributeNames());
    }
17062#public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
        throws ConfigurationException {

        Request request = ObjectModelHelper.getRequest(objectModel);
        String wildcard = (String) this.settings.get("parameter", name);
        if ( modeConf != null ) {
            wildcard = modeConf.getAttribute( "parameter", wildcard );
            // preferred
            wildcard = modeConf.getChild("parameter").getValue(wildcard);
        }
        int wildcardIndex = wildcard.indexOf( "*" );
        if ( wildcardIndex != -1 ) {
            // "*" contained in attribute name => combine all
            // attributes' values that match prefix, suffix

            // split the attribute's name so that the "*" could be
            // determined by looking at the attributes' names that
            // start with the prefix and end with the suffix
            //
            String prefix = wildcard.substring( 0, wildcardIndex );
            String suffix;
            if ( wildcard.length() >= wildcardIndex + 1 ) {
                suffix = wildcard.substring( wildcardIndex + 1 );
            } else {
                suffix = "";
            }
            SortedSet names = new TreeSet();
            HttpSession session = request.getSession();
            Enumeration allNames = session.getAttributeNames();

            while (allNames.hasMoreElements()) {
                String pname = (String) allNames.nextElement();
                if ( pname.startsWith( prefix ) && pname.endsWith( suffix ) ) {
                    names.add(pname);
                }
            }

            List values = new LinkedList();
            Iterator j = names.iterator();
            while (j.hasNext()){
                String pname = (String) j.next();
                values.add( session.getAttribute(pname) );
            }

            return values.toArray();

        } else {
            // no "*" in attribute name => just return all values of
            // this one attribute. Make sure, it's an array.

            Object value = request.getSession().getAttribute( wildcard );
            if ( value != null && !value.getClass().isArray() ) {
                Object[] values = new Object[1];
                values[0] = value;
                return values;
            } else {
                return (Object[]) value;
            }

        }

    }
17063#/* (non-Javadoc)
     * @see Serviceable#service(ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        m_manager = manager;
        m_resolver = (SourceResolver) m_manager.lookup(SourceResolver.ROLE);
    }
17064#/* (non-Javadoc)
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        super.dispose();
        if (this.m_manager != null) {
            this.m_manager.release(this.m_resolver);
            this.m_manager = null;
            this.m_resolver = null;
        }
    }
17065#/**
     * Configure the location of the properties file:
     * <p>
     *  <code>&lt;file src="resource://my.properties" /&gt;</code>
     * </p>
     */
    public void configure(Configuration configuration) throws ConfigurationException {
        super.configure(configuration);
        String file = configuration.getChild("file").getAttribute("src");
        load(file);
    }
17066#private void load(String file) throws ConfigurationException {
        Source source = null;
        InputStream stream = null;
        try {
            source = m_resolver.resolveURI(file);
            stream = source.getInputStream();
            m_properties = new Properties();
            m_properties.load(stream);
        } catch (IOException e) {
            throw new ConfigurationException("Cannot load properties file " + file);
        } finally {
            if (source != null) {
                m_resolver.release(source);
            }
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException ignored) {
                }
            }
        }
    }
17067#protected Object getContextObject(Configuration modeConf, Map objectModel)
    throws ConfigurationException {

        return m_properties;
    }
17068#protected Object getContextObject(Configuration modeConf,
                                      Map objectModel) {

        return ObjectModelHelper.getRequest(objectModel).getSession(false);
    }
17069#public Object getAttribute( String name, Configuration modeConf, Map objectModel ) throws ConfigurationException {

        String pname = (String) this.settings.get("parameter",name);
        if ( modeConf != null ) {
            pname = modeConf.getAttribute( "parameter", pname );
            // preferred
            pname = modeConf.getChild("parameter").getValue(pname);
        }
        Object obj = ObjectModelHelper.getRequest(objectModel).get( pname );
        if (obj instanceof Vector) {
            return ((Vector) obj).firstElement();
        } else {
            return obj;
        }

    }
17070#public Iterator getAttributeNames( Configuration modeConf, Map objectModel ) throws ConfigurationException {

        return new IteratorHelper(ObjectModelHelper.getRequest(objectModel).getParameterNames());
    }
17071#public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
        throws ConfigurationException {

        Object obj = getAttribute(name, modeConf, objectModel);
        if (obj instanceof Vector) {
           return ((Vector)obj).toArray();
        } else if (obj.getClass().isArray()) {
            return (Object[]) obj;
        } else {
            Object[] tmp = new Object[1];
            tmp[0] = obj;
            return tmp;
        }
    }
17072#/** (non-Javadoc)
	 *      * @see Serviceable#service(ServiceManager)
	 *           */
    public void service(ServiceManager manager) throws ServiceException {
        m_manager = manager;
        m_resolver = (SourceResolver) m_manager.lookup(SourceResolver.ROLE);
    }
17073#/** (non-Javadoc)
     *
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     *
     */
    public void dispose() {
        super.dispose();
        if ( this.m_manager != null ) {
            this.m_manager.release( this.m_resolver );
            this.m_manager = null;
            this.m_resolver = null;
        }
    }
17074#public Object getAttribute( String name, Configuration modeConf, Map objectModel ) throws ConfigurationException {
        try {
            if(name.startsWith("/")) {
                return m_resolver.resolveURI("context:/"+name).getURI().substring("file:".length());
            }
            return m_resolver.resolveURI(name).getURI().substring("file:".length());
        } catch( final IOException mue ) {
            throw new ConfigurationException( "Cannot resolve realpath", mue);
        }
    }
17075#public Iterator getAttributeNames( Configuration modeConf, Map objectModel ) throws ConfigurationException {

        return ContextPathModule.returnNames.iterator();
    }
17076#public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
        throws ConfigurationException {

            List values = new LinkedList();
            values.add( this.getAttribute(name, modeConf, objectModel) );

            return values.toArray();
    }
17077#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration config) throws ConfigurationException {
        this.inputConf = config.getChild("input-module");
        this.defaultInput = this.inputConf.getAttribute("name", this.defaultInput);
        this.objectName = this.inputConf.getAttribute("object",this.objectName);
        this.parameter = this.inputConf.getAttribute("parameter",this.parameter);

        // preferred
        this.objectName = config.getChild("object").getValue(this.objectName);
        this.parameter = config.getChild("parameter").getValue(this.parameter);
    }
17078#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttribute(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object getAttribute( String name, Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        if (!this.initialized) {
            this.lazy_initialize();
        }
        if (this.defaultInput == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }

        // obtain correct configuration objects
        // default vs dynamic
        String inputName=null;
        String objectName = this.objectName;
        String parameter = this.parameter;
        if (modeConf != null) {
            inputName  = modeConf.getChild("input-module").getAttribute("name",null);
            objectName = modeConf.getAttribute("object",objectName);
            parameter  = modeConf.getAttribute("parameter",parameter);

            // preferred
            objectName = modeConf.getChild("object").getValue(objectName);
            parameter  = modeConf.getChild("parameter").getValue(parameter);
        }
        parameter = (parameter != null? parameter : name);

        Object value = getValue(objectName, objectModel, 
                                this.input, this.defaultInput, this.inputConf, 
                                null, inputName, modeConf);

        value = (value!=null? ((Map) value).get(parameter) : null);

        return value;        
    }
17079#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Iterator getAttributeNames( Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        if (!this.initialized) {
             this.lazy_initialize();
        }
        if (this.defaultInput == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }

        // obtain correct configuration objects
        // default vs dynamic
        Configuration inputConfig = null;
        String inputName=null;
        String objectName = this.objectName;
        if (modeConf!=null) {
            inputName   = modeConf.getChild("input-module").getAttribute("name",null);
            objectName = modeConf.getAttribute("object",this.objectName);

            // preferred
            objectName = modeConf.getChild("object").getValue(objectName);
            if (inputName != null) {
                inputConfig = modeConf.getChild("input-module");
            }
        }

        Iterator keys = ((Map) getValue(objectName, objectModel, 
                                        this.input, this.defaultInput, this.inputConf,
                                        null, inputName, inputConfig)).keySet().iterator();

        return keys;        
    }
17080#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        Object[] values = new Object[1];
        values[0] = this.getAttribute(name, modeConf, objectModel);
        return (values[0]!=null?values:null);
    }
17081#public Object getAttribute( String name, Configuration modeConf, Map objectModel ) throws ConfigurationException {
        
        return null;
    }
17082#public Iterator getAttributeNames( Configuration modeConf, Map objectModel ) throws ConfigurationException {

        return null;
    }
17083#public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
        throws ConfigurationException {

        return null;
            
    }
17084#public Object getAttribute( String name, Configuration modeConf, Map objectModel )
    throws ConfigurationException {
        return EnvironmentHelper.getCurrentEnvironment().getAttribute(name);
    }
17085#public Object[] getAttributeValues(String name, Configuration modeConf, Map objectModel)
        throws ConfigurationException {
        throw new UnsupportedOperationException();
    }
17086#public Iterator getAttributeNames(Configuration modeConf, Map objectModel)
        throws ConfigurationException {
        throw new UnsupportedOperationException();
    }
17087#public void configure(Configuration config) throws ConfigurationException {
        
        this.constants = new HashMap();
        Configuration[] consts = config.getChild("values").getChildren();
        for (int i = 0; i < consts.length; i++) {
            this.constants.put(consts[i].getName(), consts[i].getValue(""));
        }
    }
17088#public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
    throws ConfigurationException {

        String parameter = name;
        Configuration mConf = null;
        if (modeConf != null) {
            mConf = modeConf.getChild("values");
        }

        Object[] values = new Object[1];
        values[0] = mConf != null ? mConf.getChild(parameter).getValue((String) this.constants.get(parameter))
                : this.constants.get(parameter);
        return values;
    }
17089#public Iterator getAttributeNames( Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {

        SortedSet matchset = new TreeSet(this.constants.keySet());
        if (modeConf != null) {
            Configuration[] consts = modeConf.getChild("values").getChildren();
            for (int i = 0; i < consts.length; i++)
                matchset.add(consts[i].getName());
        }

        return matchset.iterator();
    }
17090#public Object getAttribute(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {

        Object[] values = this.getAttributeValues(name, modeConf, objectModel);
        return values[0];
    }
17091#/**
     * @return the value of the cookie whose name matches the one requested,
     * or <code>null</code> if there is no match.
     */
    public Object getAttribute(String name, Configuration modeConf,
            Map objectModel) throws ConfigurationException {
        
        Cookie cookie = (Cookie) getCookieMap(objectModel).get(name);
        String value = (cookie == null ? null : cookie.getValue());
        
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Cookie[" + name + "]=" + value);
        }
        return value;
    }
17092#/*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration,
     *      java.util.Map)
     */
    public Iterator getAttributeNames(Configuration modeConf, Map objectModel)
            throws ConfigurationException {
        
        return getCookieMap(objectModel).keySet().iterator();
    }
17093#/*
     * (non-Javadoc)
     * 
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttributeValues(java.lang.String,
     *      org.apache.avalon.framework.configuration.Configuration,
     *      java.util.Map)
     */
    public Object[] getAttributeValues(String name, Configuration modeConf,
            Map objectModel) throws ConfigurationException {
        
        Map allCookies = getCookieMap(objectModel);
        
        Iterator it = allCookies.values().iterator();
        List matched = new LinkedList();
        while (it.hasNext()) {
            Cookie cookie = (Cookie) it.next();
            if (cookie.getName().matches(name)) {
                matched.add(cookie.getValue());
            }
        }
        return matched.toArray();
    }
17094#/**
     * @param objectModel
     *            Object Model for the current request
     * @return a Map of {see: HttpCookie}s for the current request, keyed on
     *         cookie name.
     */
    protected Map getCookieMap(Map objectModel) {
        return ObjectModelHelper.getRequest(objectModel).getCookieMap();
    }
17095#public Object getAttribute( String name, Configuration modeConf, Map objectModel ) throws ConfigurationException {
        
        if (modeConf == null) {
            return null;
        } else {
            return modeConf.getValue();
        }
    }
17096#public Iterator getAttributeNames( Configuration modeConf, Map objectModel ) throws ConfigurationException {

        return StringConstantModule.returnNames.iterator();
    }
17097#public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
        throws ConfigurationException {

            List values = new LinkedList();
            values.add( this.getAttribute(name, modeConf, objectModel) );

            return values.toArray();
            
    }
17098#protected Object getContextObject(Configuration modeConf,
                                      Map objectModel) {

        return FlowHelper.getWebContinuation(objectModel);
    }
17099#public ChainMetaModule() {
        this.defaultInput = null;
    }
17100#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration config) throws ConfigurationException {
        Configuration[] confs = config.getChildren("input-module");
        if (confs.length > 0) {
            this.inputs = new ModuleHolder[confs.length];
            int j = 0;
            for (int i=0; i<confs.length; i++) {
                ModuleHolder module = new ModuleHolder();
                module.name = confs[i].getAttribute("name",null);
                if (module.name == null) {
                    if (getLogger().isErrorEnabled())
                        getLogger().error("No name attribute for module configuration. Skipping.");
                    continue;
                }
                module.config = confs[i];
                this.inputs[j]=module;
                j++;
            }
        }
        this.emptyAsNull = config.getChild("empty-as-null").getValueAsBoolean(this.emptyAsNull);
        this.allNames = config.getChild("all-names").getValueAsBoolean(this.allNames);
        this.allValues = config.getChild("all-values").getValueAsBoolean(this.allValues);
    }
17101#/**
     * @see org.apache.cocoon.components.modules.input.AbstractMetaModule#lazy_initialize()
     */
    public synchronized void lazy_initialize() {
        if ( !this.initialized ) {
            super.lazy_initialize();
            // obtain input modules
            for (int i=0; i<this.inputs.length; i++) {
                if (this.inputs[i].name != null) 
                    this.inputs[i].input = obtainModule(this.inputs[i].name);
            }
        }
    }
17102#/**
     * @see org.apache.cocoon.components.modules.input.AbstractMetaModule#dispose()
     */
    public void dispose() {
        if (this.inputSelector != null) {
            for (int i=0; i<this.inputs.length; i++) {
                this.inputSelector.release(this.inputs[i].input);
            }
            this.inputs = null;
        }
        super.dispose();
    }
17103#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues( String attr, Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        if (!this.initialized) {
            this.lazy_initialize();
        }

        // obtain correct configuration objects
        // default vs dynamic
        Configuration[] inputConfigs = null;
        boolean allValues = this.allValues;
        boolean emptyAsNull = this.emptyAsNull;
        if (modeConf!=null && modeConf.getChildren().length > 0) {
            inputConfigs = modeConf.getChildren("input-module");
            emptyAsNull = modeConf.getChild("empty-as-null").getValueAsBoolean(emptyAsNull);
            allValues = modeConf.getChild("all-values").getValueAsBoolean(allValues);
            if (inputConfigs.length == 0) inputConfigs = null;
        }

        Object[] value = null;
        boolean debug = getLogger().isDebugEnabled();
        List values = null;
        if (allValues) values = new ArrayList();

        if (inputConfigs == null) {
            // static configuration branch
            int i = 0;
            while (i < this.inputs.length && (value == null || allValues)) {
                if (this.inputs[i].name != null) {
                    value = getValues(attr, objectModel, this.inputs[i].input, this.inputs[i].name, this.inputs[i].config);
                    if (emptyAsNull && value != null && value.length == 0) value = null;
                    if (emptyAsNull && value != null && value.length == 1 && 
                        value[0] instanceof String && value[0].equals("")) value = null;
                    if (debug) getLogger().debug("read from "+this.inputs[i].name+" attribute "+attr+" as "+value);
                    if (allValues && value != null) values.addAll(Arrays.asList(value));
                }
                i++;
            }
        } else {
            // run-time configuration branch
            int i = 0;
            while (i < inputConfigs.length && (value == null || allValues)) {
                String name = inputConfigs[i].getAttribute("name",null);
                if (name != null) {
                    value = getValues(attr, objectModel, null, name, inputConfigs[i]);
                    if (emptyAsNull && value != null && value.length == 0) value = null;
                    if (emptyAsNull && value != null && value.length == 1 && 
                        value[0] instanceof String && value[0].equals("")) value = null;
                    if (debug) getLogger().debug("read from "+name+" attribute "+attr+" as "+value);
                    if (allValues && value != null) values.addAll(Arrays.asList(value));
                }
                i++;
            }
        }
        if (debug) getLogger().debug("result chaining for "+attr+" is "+(allValues? values.toArray() : value));
        return (allValues? values.toArray() : value);
    }
17104#private void addIterator(Collection col, Iterator iter) {
        while (iter != null && iter.hasNext())
            col.add(iter.next());
    }
17105#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Iterator getAttributeNames( Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        if (!this.initialized) {
            this.lazy_initialize();
        }

        // obtain correct configuration objects
        // default vs dynamic
        Configuration[] inputConfigs = null;
        boolean emptyAsNull = this.emptyAsNull;
        boolean allNames = this.allNames;
        if (modeConf!=null && modeConf.getChildren().length > 0) {
            inputConfigs = modeConf.getChildren("input-module");
            emptyAsNull = modeConf.getChild("empty-as-null").getValueAsBoolean(emptyAsNull);
            allNames = modeConf.getChild("all-names").getValueAsBoolean(allNames);
            if (inputConfigs.length == 0) inputConfigs = null;
        }

        Iterator value = null;
        Collection values = null;
        if (allNames) values = new ArrayList();
        boolean debug = getLogger().isDebugEnabled();

        if (inputConfigs == null) {
            // static configuration branch
            int i = 0;
            while (i < this.inputs.length && (value == null || allNames)) {
                if (this.inputs[i].name != null) {
                    value = getNames(objectModel, this.inputs[i].input, this.inputs[i].name, this.inputs[i].config);
                    if (debug) getLogger().debug("read from "+this.inputs[i].name+" AttributeNames as "+value);
                    if (allNames && value != null) addIterator(values, value);
                }
                i++;
            }
        } else {
            // run-time configuration branch
            int i = 0;
            while (i < inputConfigs.length && value == null) {
                String name = inputConfigs[i].getAttribute("name",null);
                if (name != null) {
                    value = getNames(objectModel, null, name, inputConfigs[i]);
                    if (debug) getLogger().debug("read from "+name+" AttributeNames as "+value);
                    if (allNames && value != null) addIterator(values, value);
                }
                i++;
            }
        }
        if (debug) getLogger().debug("result chaining names is "+(allNames? values.iterator() : value));
        return (allNames? values.iterator() : value);
     }
17106#public Object getAttribute( String attr, Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        Object[] values = this.getAttributeValues(attr,modeConf,objectModel);
        if (getLogger().isDebugEnabled()) getLogger().debug("result chaining single for "+attr+" is "+(values != null? values[0] : "null"));
        return (values != null? values[0] : null);
    }
17107#public Object getAttribute(final String name,
                               final Configuration modeConf,
                               final Map objectModel)
    throws ConfigurationException {

        String uri;
        if (name.equals("SitemapBaseLink"))
            uri = ObjectModelHelper.getRequest(objectModel).getSitemapURI();
        else if (name.equals("RequestBaseLink"))
            uri = ObjectModelHelper.getRequest(objectModel).getRequestURI();
        else
            uri = "";

        if (uri.startsWith("/")) {
            uri = uri.substring(1);
        }

        StringBuffer result = new StringBuffer(uri.length());

        int nextIndex = 0;
        while ((nextIndex = uri.indexOf('/', nextIndex) + 1) > 0) {
            result.append("../");
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Returns " + result + " for uri " + uri + " and attribute " + name);
        }

        return result.toString();
    }
17108#public Iterator getAttributeNames(final Configuration modeConf, final Map objectModel)
    throws ConfigurationException {

        return NAMES.iterator();
    }
17109#public Object[] getAttributeValues(final String name,
                                       final Configuration modeConf,
                                       final Map objectModel)
    throws ConfigurationException {

        Object result = getAttribute(name, modeConf, objectModel);
        return result == null ? null : new Object[]{result};
    }
17110#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration config) throws ConfigurationException {
        this.inputConf = config.getChild("input-module");
        this.defaultInput = this.inputConf.getAttribute("name", this.defaultInput);
        this.rootName = this.inputConf.getAttribute("root",this.rootName);
        this.ignore = this.inputConf.getAttribute("ignore",this.ignore);
        this.use = this.inputConf.getAttribute("use",this.use);
        this.strip = this.inputConf.getAttribute("strip",this.strip);
        this.config = config;

        // preferred
        this.rootName = config.getChild("root").getValue(this.rootName);
        this.ignore = config.getChild("ignore").getValue(this.ignore);
        this.use = config.getChild("use").getValue(this.use);
        this.strip = config.getChild("strip").getValue(this.strip);
    }
17111#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttribute(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object getAttribute( String name, Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        if (!this.initialized) {
            this.lazy_initialize();
        }
        if (this.defaultInput == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }

        // obtain correct configuration objects
        // default vs dynamic
        Configuration inputConfig = null;
        String inputName=null;
        String rootName = this.rootName;
        String ignore  = this.ignore;
        String use  = this.use;
        String strip  = this.strip;
        if (modeConf!=null) {
            inputName   = modeConf.getChild("input-module").getAttribute("name",null);
            rootName = modeConf.getAttribute("root",this.rootName);
            ignore  = modeConf.getAttribute("ignore" ,this.ignore );
            use  = modeConf.getAttribute("use" ,this.use );
            strip  = modeConf.getAttribute("strip" ,this.strip );

            // preferred
            rootName = modeConf.getChild("root").getValue(rootName);
            ignore  = modeConf.getChild("ignore").getValue(ignore );
            use  = modeConf.getChild("use").getValue(use );
            strip  = modeConf.getChild("strip").getValue(strip );
            if (inputName != null) {
                inputConfig = modeConf.getChild("input-module");
            }
        }

        // see whether the Document is already stored as request
        // attribute and return that
        Request request = ObjectModelHelper.getRequest(objectModel);
        Map cache = (Map) request.getAttribute(CACHE_OBJECT_NAME);
        Object key = (modeConf != null ? modeConf : this.config);
        Document doc = null;

        if (cache != null && cache.containsKey(key)) {
            doc = (Document) cache.get(key);
            if (getLogger().isDebugEnabled())
                getLogger().debug("using cached copy "+doc);
            return doc;
        }
        if (getLogger().isDebugEnabled())
            getLogger().debug("no cached copy "+cache+" / "+key);


        // get InputModule and all attribute names
        InputModule input = null;
        if (inputName != null) input = obtainModule(inputName);

        Iterator names = getNames(objectModel, 
                                  this.input, this.defaultInput, this.inputConf,
                                  input, inputName, inputConfig);

        // first, sort all attribute names that the DOM can be created in one go
        // while doing so, remove unwanted attributes
        SortedSet set = new TreeSet();
        String aName = null;
        while (names.hasNext()){
            aName = (String) names.next();
            if ((use == null || aName.startsWith(use)) &&
                (ignore == null || !aName.startsWith(ignore))) {
                set.add(aName);
            }
        }

        try {
            names = set.iterator();
            
            // create new document and append root node
            doc = DOMUtil.createDocument();
            Element elem = doc.createElement(rootName);
            doc.appendChild(elem);

            while (names.hasNext()){
                aName = (String) names.next();
                // obtain values from input module
                Object[] value = getValues(aName, objectModel,
                                           this.input, this.defaultInput, this.inputConf,
                                           input, inputName, inputConfig);

                // strip unwanted prefix from attribute name if present
                if (strip != null && aName.startsWith(strip)) 
                    aName = aName.substring(strip.length());

                if (value.length > 0) {
                    // add new node from xpath 
                    // (since the names are in a set, the node cannot exist already)
                    Node node = DOMUtil.selectSingleNode(doc.getDocumentElement(), aName, this.xpathProcessor);
                    node.appendChild( node.getOwnerDocument().createTextNode(value[0].toString()));

                    if (value.length > 1) {
                        // if more than one value was obtained, append
                        // further nodes (same name)

                        // isolate node name, selection expressions
                        // "[...]" may not be part of it
                        int endPos = aName.length() - (aName.endsWith("/") ? 1 : 0);
                        int startPos = aName.lastIndexOf("/", endPos) +1;
                        String nodeName = aName.substring(startPos, endPos);
                        if (nodeName.indexOf("[") != -1) {
                            endPos = nodeName.lastIndexOf("]");
                            startPos = nodeName.indexOf("[") +1;
                            nodeName = nodeName.substring(startPos, endPos);
                        }

                        // append more nodes
                        Node parent = node.getParentNode();
                        for (int i = 1; i < value.length; i++) {
                            Node newNode = parent.getOwnerDocument().createElementNS(null, nodeName);
                            parent.appendChild( newNode );
                            newNode.appendChild( newNode.getOwnerDocument().createTextNode(value[i].toString()));
                        }
                    }
                }
            }
        } catch (Exception e) {
            throw new ConfigurationException(e.getMessage());
        }

        if (input != null) releaseModule(input);

        // create a wrapped instance that is XMLizable
        doc = new DocumentWrapper(doc);

        // store Document as request attribute
        if (cache == null)
            cache = new HashMap();
        if (getLogger().isDebugEnabled())
            getLogger().debug("no cached copy "+cache+" / "+key);
        cache.put(key, doc);
        request.setAttribute(CACHE_OBJECT_NAME,cache);
        
        
        if (getLogger().isDebugEnabled())
            getLogger().debug("returning "+doc.toString());
        return doc;
    }
17112#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Iterator getAttributeNames( Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        if (!this.initialized) {
             this.lazy_initialize();
        }
        if (this.defaultInput == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }

        return XMLMetaModule.returnNames.iterator();
    }
17113#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        if (!this.initialized) {
            this.lazy_initialize();
        }
        if (this.defaultInput == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }
        
        Object[] values = new Object[1];
        values[0] = this.getAttribute(name, modeConf, objectModel);
        return values;
    }
17114#/**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        super.service(manager);
        this.xpathProcessor = (XPathProcessor)this.manager.lookup(XPathProcessor.ROLE);
    }
17115#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        if ( this.manager != null ) {
            this.manager.release(this.xpathProcessor);
            this.xpathProcessor = null;
        }
        super.dispose();
    }
17116#/* (non-Javadoc)
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
        this.resolver = (SourceResolver) manager.lookup(SourceResolver.ROLE);
    }
17117#/**
     * Static (cocoon.xconf) configuration.
     * Configuration is expected to be of the form:
     * &lt;...&gt;
     *   &lt;reloadable&gt;true|<b>false</b>&lt;/reloadable&gt;
     *   &lt;cacheable&gt;<b>true</b>|false&lt;/cacheable&gt;
     *   &lt;file src="<i>src1</i>" reloadable="true|<b>false</b>" cacheable="<b>true</b>|false"/&gt;
     *   &lt;file src="<i>src2</i>" reloadable="true|<b>false</b>" cacheable="<b>true</b>|false"/&gt;
     *   ...
     * &lt;/...&gt;
     *
     * Each &lt;file/&gt; element pre-loads an XML DOM for querying. Typically only one
     * &lt;file&gt; is specified, and its <i>src</i> is used as a default if not
     * overridden in the {@link #getContextObject(Configuration, Map)}
     *
     * @param config a <code>Configuration</code> value, as described above.
     * @exception ConfigurationException if an error occurs
     */
    public void configure(Configuration config)
    throws ConfigurationException {
        super.configure(config);
        this.staticConfLocation = config.getLocation();
        this.reloadAll = config.getChild("reloadable").getValueAsBoolean(false);

        if (config.getChild("cachable", false) != null) {
            throw new ConfigurationException("Bzzt! Wrong spelling at " +
                                             config.getChild("cachable").getLocation() +
                                             ": please use 'cacheable', not 'cachable'");
        }
        this.cacheAll = config.getChild("cacheable").getValueAsBoolean(true);

        this.documents = Collections.synchronizedMap(new HashMap());
        Configuration[] files = config.getChildren("file");
        for (int i = 0; i < files.length; i++) {
            boolean reload = files[i].getAttributeAsBoolean("reloadable", this.reloadAll);
            boolean cache = files[i].getAttributeAsBoolean("cacheable", this.cacheAll);
            this.src = files[i].getAttribute("src");
            // by assigning the source uri to this.src the last one will be the default
            // OTOH caching / reload parameters can be specified in one central place
            // if multiple file tags are used.
            this.documents.put(this.src, new DocumentHelper(reload, cache, this.src, this));
        }

        // init caches
        this.cacheExpressions = config.getChild("cache-expressions").getValueAsBoolean(true);
        if (this.cacheExpressions) {
            this.expressionCache = new ReferenceMap(AbstractReferenceMap.SOFT, AbstractReferenceMap.SOFT);
            this.expressionValuesCache = new ReferenceMap(AbstractReferenceMap.SOFT, AbstractReferenceMap.SOFT);
        }
    }
17118#/**
     * Dispose this component
     */
    public void dispose() {
        super.dispose();
        if (this.manager != null) {
            this.manager.release(this.resolver);
            this.resolver = null;
            this.manager = null;
        }

        this.documents = null;
        this.expressionCache = null;
        this.expressionValuesCache = null;
    }
17119#/**
     * Retrieve document helper
     */
    private DocumentHelper getDocumentHelper(Configuration modeConf)
    throws ConfigurationException {
        boolean hasDynamicConf = false; // whether we have a <file src="..."> dynamic configuration
        Configuration fileConf = null;  // the nested <file>, if any

        if (modeConf != null && modeConf.getChildren().length > 0) {
            fileConf = modeConf.getChild("file", false);
            if (fileConf == null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Missing 'file' child element at " + modeConf.getLocation());
                }
            } else {
                hasDynamicConf = true;
            }
        }

        String src = this.src;
        if (hasDynamicConf) {
            src = fileConf.getAttribute("src");
        }

        if (src == null) {
            throw new ConfigurationException(
                "No source specified"
                    + (modeConf != null ? ", either dynamically in " + modeConf.getLocation() + ", or " : "")
                    + " statically in "
                    + staticConfLocation);
        }

        if (!this.documents.containsKey(src)) {
            boolean reload = this.reloadAll;
            boolean cache = this.cacheAll;
            if (hasDynamicConf) {
                reload = fileConf.getAttributeAsBoolean("reloadable", reload);
                cache = fileConf.getAttributeAsBoolean("cacheable", cache);
                if (fileConf.getAttribute("cachable", null) != null) {
                    throw new ConfigurationException(
                        "Bzzt! Wrong spelling at "
                            + fileConf.getLocation()
                            + ": please use 'cacheable', not 'cachable'");
                }
            }

            this.documents.put(src, new DocumentHelper(reload, cache, src, this));
        }

        return (DocumentHelper) this.documents.get(src);
    }
17120#/**
     * Get the DOM object that JXPath will operate on when evaluating
     * attributes.  This DOM is loaded from a Source, specified in the
     * modeConf, or (if modeConf is null) from the
     * {@link #configure(Configuration)}.
     * @param modeConf The dynamic configuration for the current operation. May
     * be <code>null</code>, in which case static (cocoon.xconf) configuration
     * is used.  Configuration is expected to have a &lt;file> child node, and
     * be of the form:
     * &lt;...&gt;
     *   &lt;file src="..." reloadable="true|false"/&gt;
     * &lt;/...&gt;
     * @param objectModel Object Model for the current module operation.
     */
    protected Object getContextObject(Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        DocumentHelper helper = getDocumentHelper(modeConf);

        try {
            return helper.getDocument(this.manager, this.resolver, getLogger());
        } catch (Exception e) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Error using source " + src + "\n" + e.getMessage(), e);
            }
            throw new ConfigurationException("Error using source " + src, e);
        }
    }
17121#public Object getAttribute(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        return getAttribute(name, modeConf, objectModel, false);
    }
17122#public Object[] getAttributeValues(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        Object result = getAttribute(name, modeConf, objectModel, true);
        return (result != null ? (Object[]) result : null);
    }
17123#private Object getAttribute(String name, Configuration modeConf, Map objectModel, boolean getValues)
    throws ConfigurationException {
        Object contextObj = getContextObject(modeConf, objectModel);
        if (modeConf != null) {
            name = modeConf.getChild("parameter").getValue(this.parameter != null ? this.parameter : name);
        }

        Object result = null;
        Map cache = null;
        boolean hasBeenCached = false;
        if (this.cacheExpressions) {
            cache = getExpressionCache(getValues? this.expressionValuesCache: this.expressionCache, contextObj);
            hasBeenCached = cache.containsKey(name);
            if (hasBeenCached) {
                result = cache.get(name);
            }
        }

        if (!hasBeenCached) {
            if (getValues){
                result = JXPathHelper.getAttributeValues(name, modeConf, this.configuration, contextObj);
            } else {
                result = JXPathHelper.getAttributeValue(name, modeConf, this.configuration, contextObj);
            }
            if (this.cacheExpressions) {
                cache.put(name, result);
                if (this.getLogger().isDebugEnabled()) {
                    this.getLogger().debug("for " + name + " newly caching result " + result);
                }
            } else {
                if (this.getLogger().isDebugEnabled()) {
                    this.getLogger().debug("for " + name + " result is " + result);
                }
            }
        } else {
            if (this.getLogger().isDebugEnabled()) {
                this.getLogger().debug("for " + name + " using cached result " + result);
            }
        }

        return result;
    }
17124#protected void flushCache() {
        if (this.cacheExpressions) {
            synchronized(this.expressionCache) {
                this.expressionCache.clear();
            }
            synchronized(this.expressionValuesCache) {
                this.expressionValuesCache.clear();
            }
        }
    }
17125#private Map getExpressionCache(Map cache, Object key) {
        synchronized (cache) {
            Map map = (Map) cache.get(key);
            if (map == null) {
                map = Collections.synchronizedMap(new HashMap());
                cache.put(key, map);
            }
            return map;
        }
    }
17126#/**
         * Creates a new <code>DocumentHelper</code> instance.
         *
         * @param reload a <code>boolean</code> value, whether this source should be reloaded if changed.
         * @param cache a <code>boolean</code> value, whether this source should be kept in memory.
         * @param src a <code>String</code> value containing the URI
         */
        public DocumentHelper(boolean reload, boolean cache, String src, XMLFileModule instance) {
            this.reloadable = reload;
            this.cacheable = cache;
            this.uri = src;
            this.instance = instance;
            // defer loading of the document
        }
17127#/**
         * Returns the Document belonging to the configured
         * source. Transparently handles reloading and caching.
         *
         * @param manager a <code>ServiceManager</code> value
         * @param resolver a <code>SourceResolver</code> value
         * @return a <code>Document</code> value
         * @exception Exception if an error occurs
         */
        public synchronized Document getDocument(ServiceManager manager, SourceResolver resolver, Log logger)
        throws Exception {
            Source src = null;
            Document dom = null;
            try {
                if (this.document == null) {
                    if (logger.isDebugEnabled()) {
                        logger.debug("Document not cached... Loading uri " + this.uri);
                    }
                    src = resolver.resolveURI(this.uri);
                    this.validity = src.getValidity();
                    this.document = SourceUtil.toDOM(manager, src);
                } else if (this.reloadable) {
                    if (logger.isDebugEnabled()) {
                        logger.debug("Document cached... checking validity of uri " + this.uri);
                    }

                    int valid = this.validity == null? SourceValidity.INVALID: this.validity.isValid();
                    if (valid != SourceValidity.VALID) {
                        // Get new source and validity
                        src = resolver.resolveURI(this.uri);
                        SourceValidity newValidity = src.getValidity();
                        // If already invalid, or invalid after validities comparison, reload
                        if (valid == SourceValidity.INVALID || this.validity.isValid(newValidity) != SourceValidity.VALID) {
                            if (logger.isDebugEnabled()) {
                                logger.debug("Reloading document... uri " + this.uri);
                            }
                            this.validity = newValidity;
                            this.document = SourceUtil.toDOM(manager, src);

                            /*
                             * Clear the cache, otherwise reloads won't do much.
                             *
                             * FIXME (pf): caches should be held in the DocumentHelper
                             *             instance itself, clearing global cache will
                             *             clear everything for each configured document.
                             *             (this is a quick fix, no time to do the whole)
                             */
                            this.instance.flushCache();
                        }
                    }
                }

                dom = this.document;
            } finally {
                if (src != null) {
                    resolver.release(src);
                }

                if (!this.cacheable) {
                    if (logger.isDebugEnabled()) {
                        logger.debug("Not caching document cached... uri " + this.uri);
                    }
                    this.validity = null;
                    this.document = null;
                }
            }

            if (logger.isDebugEnabled()) {
                logger.debug("Done with document... uri " + this.uri);
            }
            return dom;
        }
17128#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration config) throws ConfigurationException {
        this.inputConf = config.getChild("input-module");
        this.defaultInput = this.inputConf.getAttribute("name",this.defaultInput);
        this.defaultFormat = this.inputConf.getAttribute("format",this.defaultFormat);
        if (this.defaultFormat != null) {
            this.defaultFormatter = new SimpleDateFormat(this.defaultFormat);
        }
    }
17129#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        if (!this.initialized) {
            this.lazy_initialize();
        }
        if (this.defaultInput == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given");
        }

        // obtain correct configuration objects
        // default vs dynamic
        Configuration mConf = null;
        String inputName=null;
        String parameter=name;
        String format=this.defaultFormat;
        DateFormat formatter=null;
        if (modeConf!=null) {
            mConf       = modeConf.getChild("input-module");
            inputName   = modeConf.getChild("input-module").getAttribute("name",null);
            parameter   = modeConf.getAttribute("parameter",parameter);
            format      = modeConf.getAttribute("format",format);
            // preferred:
            parameter   = modeConf.getChild("parameter").getValue(parameter);
            format      = modeConf.getChild("format").getValue(format);
        }
        if (this.defaultFormat.equals(format)) {
            formatter = this.defaultFormatter;
        } else {
            formatter = new SimpleDateFormat(format);
        }
        
        Object[] values = getValues(parameter, objectModel, 
                                    this.input, this.defaultInput, this.inputConf,
                                    null, inputName, mConf);
        
        Object[] dates = null;
        if (values != null) {
            dates = new Object[values.length];
            for (int i=0; i<values.length; i++) 
                try {
                    dates[i] = formatter.parse(String.valueOf(values[i]));
                } catch (Exception e) {
                    if(getLogger().isWarnEnabled()) 
                        getLogger().warn("Problem: Aquired '"+values[i]+"' from '" + inputName + "' for '"
                                         +name+"' using format '"+format+"' : "+e.getMessage());
                }
        }
        return dates;
    }
17130#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Iterator getAttributeNames( Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        if (!this.initialized) {
            this.lazy_initialize();
        }
        if (this.defaultInput == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given");
        }

        // obtain correct configuration objects
        // default vs dynamic
        Configuration inputConfig = this.inputConf;
        Configuration mConf = null;
        String inputName=null;
        if (modeConf!=null) {
            mConf       = modeConf.getChild("input-module");
            inputName   = modeConf.getChild("input-module").getAttribute("name",null);
            if (inputName != null) {
                inputConfig = modeConf.getChild("input-module");
            }
        }

        // done reading configuration
        // setup modules and read values
        Iterator enumeration = getNames(objectModel,
                                    this.input, this.defaultInput, inputConfig,
                                    null, inputName, mConf);
        return enumeration;
    }
17131#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttribute(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object getAttribute( String name, Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        Object[] values = this.getAttributeValues(name,modeConf,objectModel);
        return (values != null ? values[0] : null);
    }
17132#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration config) throws ConfigurationException {
        // It seems that even if there is no config, we'll get an empty
        // input-module element here, so it will never be null (JT)
        this.inputConf = config.getChild("input-module");
        this.defaultInput = this.inputConf.getAttribute("name", this.defaultInput);
        this.prefix = config.getChild("prefix").getValue(null);
        this.suffix = config.getChild("suffix").getValue(null);
        this.rmPrefix = config.getChild("rm-prefix").getValue(null);
        this.rmSuffix = config.getChild("rm-suffix").getValue(null);
        this.mapping = new Mapping(config);
    }
17133#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttribute(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object getAttribute( String name, Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        if (!this.initialized) {
            this.lazy_initialize();
        }
        if (this.defaultInput == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }

        Configuration inputConfig = null;
        String inputName=null;
        Mapping mapping = this.mapping;
        String prefix = this.prefix;
        String suffix = this.suffix;
        String rmPrefix = this.rmPrefix;
        String rmSuffix = this.rmSuffix;

        if (modeConf!=null && modeConf.getChildren().length > 0) {
            inputName   = modeConf.getChild("input-module").getAttribute("name",null);
            if (inputName != null) {
                inputConfig = modeConf.getChild("input-module");
            }
            mapping = new Mapping(modeConf);
            prefix = modeConf.getChild("prefix").getValue(null);
            suffix = modeConf.getChild("suffix").getValue(null);
            rmPrefix = modeConf.getChild("rm-prefix").getValue(null);
            rmSuffix = modeConf.getChild("rm-suffix").getValue(null);
        }
        
        // remove rm-prefix and rm-suffix
        if (rmPrefix != null && name.startsWith(rmPrefix)) {
            name = name.substring(rmPrefix.length());
        }
        if (rmSuffix != null && name.endsWith(rmSuffix)) {
            name = name.substring(0,name.length() - rmSuffix.length());
        }
        // map
        String param = mapping.mapTo(name);
        // add prefix and suffix
        if (prefix != null) param = prefix + param;
        if (suffix != null) param = param + suffix;
        if (getLogger().isDebugEnabled())
            getLogger().debug("mapping ['"+name+"'] to ['"+param+"']");

        Object res = getValue(param, objectModel,
                              this.input, this.defaultInput, this.inputConf,
                              null, inputName, inputConfig);
        
        if (getLogger().isDebugEnabled())
            getLogger().debug("getting for real attribute ['"+param+"'] value: "+res);

        return res;
    }
17134#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        if (!this.initialized) {
            this.lazy_initialize();
        }
        if (this.defaultInput == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }

        Configuration inputConfig = null;
        String inputName=null;
        Mapping mapping = this.mapping;
        String prefix = this.prefix;
        String suffix = this.suffix;
        String rmPrefix = this.rmPrefix;
        String rmSuffix = this.rmSuffix;

        if (modeConf!=null && modeConf.getChildren().length > 0) {
            inputName   = modeConf.getChild("input-module").getAttribute("name",null);
            if (inputName != null) {
                inputConfig = modeConf.getChild("input-module");
            }
            mapping = new Mapping(modeConf);
            prefix = modeConf.getChild("prefix").getValue(null);
            suffix = modeConf.getChild("suffix").getValue(null);
            rmPrefix = modeConf.getChild("rm-prefix").getValue(null);
            rmSuffix = modeConf.getChild("rm-suffix").getValue(null);
        }
        
        // remove rm-prefix and rm-suffix
        if (rmPrefix != null && name.startsWith(rmPrefix)) {
            name = name.substring(rmPrefix.length());
        }
        if (rmSuffix != null && name.endsWith(rmSuffix)) {
            name = name.substring(0,name.length() - rmSuffix.length());
        }
        // map
        String param = mapping.mapTo(name);
        // add prefix and suffix
        if (prefix != null) param = prefix + param;
        if (suffix != null) param = param + suffix;
        if (getLogger().isDebugEnabled())
            getLogger().debug("mapping ['"+name+"'] to ['"+param+"']");

        Object[] res = getValues(param, objectModel,
                                 this.input, this.defaultInput, this.inputConf,
                                 null, inputName, inputConfig);
        if (getLogger().isDebugEnabled())
            getLogger().debug("getting for real attribute ['"+param+"'] value: "+res);

        return res;
    }
17135#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Iterator getAttributeNames( Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        if (!this.initialized) {
            this.lazy_initialize();
        }
        if (this.defaultInput == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }

        Configuration inputConfig = null;
        String inputName=null;
        Mapping mapping = this.mapping;
        String prefix = this.prefix;
        String suffix = this.suffix;
        String rmPrefix = this.rmPrefix;
        String rmSuffix = this.rmSuffix;
        if (modeConf!=null && modeConf.getChildren().length > 0) {
            inputName   = modeConf.getChild("input-module").getAttribute("name",null);
            if (inputName != null) {
                inputConfig = modeConf.getChild("input-module");
            }
            mapping = new Mapping(modeConf);
            prefix = modeConf.getChild("prefix").getValue(null);
            suffix = modeConf.getChild("suffix").getValue(null);
            rmPrefix = modeConf.getChild("rm-prefix").getValue(null);
            rmSuffix = modeConf.getChild("rm-suffix").getValue(null);
        }
        
        Iterator names = getNames(objectModel, 
                                  this.input, this.defaultInput, this.inputConf, 
                                  null, inputName, inputConfig);

        Set set = new HashSet();
        while (names.hasNext()) {
            String param = (String) names.next();
            if (getLogger().isDebugEnabled())
                getLogger().debug("reverse mapping starts with ['"+param+"']");
            if (prefix != null) 
                if (param.startsWith(prefix))
                    param = param.substring(prefix.length());
                else 
                    continue; // prefix is set but parameter does not start with it.
            
            //if (getLogger().isDebugEnabled())
            //    getLogger().debug("reverse mapping after remove prefix ['"+param+"']");

            if (suffix != null)
                if (param.endsWith(suffix))
                    param = param.substring(0,param.length() - suffix.length());
                else 
                    continue; // suffix is set but parameter does not end with it.

            //if (getLogger().isDebugEnabled())
            //    getLogger().debug("reverse mapping after remove suffix ['"+param+"']");

            if (param.length() < 1)
                continue; // nothing left

            String newName = mapping.mapFrom(param);

            if (rmPrefix != null) newName = rmPrefix + newName;
            if (rmSuffix != null) newName = newName + rmSuffix;

            if (getLogger().isDebugEnabled())
                getLogger().debug("reverse mapping results in ['"+newName+"']");

            set.add(newName);
        }

        return set.iterator();

    }
17136#public Mapping() {
        }
17137#public Mapping(Map to, Map from) {
            this.toMap = to;
            this.fromMap = from;
        }
17138#public Mapping(Configuration config) throws ConfigurationException {
            Configuration[] mappings = config.getChildren("mapping");
            if (mappings!=null) {
                if (this.toMap == null) this.toMap = new HashMap();
                if (this.fromMap == null) this.fromMap = new HashMap();
                for (int i=0; i < mappings.length; i++){
                    String in = mappings[i].getAttribute("in",null);
                    String out = mappings[i].getAttribute("out",null);
                    if (in != null && out != null) {
                        this.toMap.put(in,out);
                        this.fromMap.put(out,in);
                    }
                }
            }
        }
17139#private String mapIt(Map map, String param) {
            Object newParam = param;
            if (map != null) {
                newParam = map.get(param);
                if (!map.containsKey(param) || newParam == null)
                    newParam = param;
            }
            return (String) newParam;
        }
17140#public String mapFrom(String param) {
            return this.mapIt(this.fromMap, param);
        }
17141#public String mapTo(String param) {
            return this.mapIt(this.toMap, param);
        }
17142#/**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager aManager) throws ServiceException {
        this.manager = aManager;
        this.infoProvider = (ProcessInfoProvider)this.manager.lookup(ProcessInfoProvider.ROLE);
    }
17143#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        if (this.manager != null) {
            this.manager.release(this.infoProvider);
            this.infoProvider = null;
            this.manager = null;
        }
    }
17144#/**
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttribute(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object getAttribute(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        final Settings settings = (Settings)WebAppContextUtils.getCurrentWebApplicationContext().getBean(Settings.ROLE);
        return settings.getProperty(name);
    }
17145#/**
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Iterator getAttributeNames(Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        final Settings settings = (Settings)WebAppContextUtils.getCurrentWebApplicationContext().getBean(Settings.ROLE);
        return settings.getPropertyNames().iterator();
    }
17146#/**
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        Object o = getAttribute(name, modeConf, objectModel);
        if (o != null) {
            return new Object[]{o};
        }
        
        return null;
    }
17147#/* (non-Javadoc)
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttribute(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object getAttribute( String name, Configuration modeConf, Map objectModel )
    throws ConfigurationException {
        final KeyInfo info = new KeyInfo(name);
        return this.getAttribute(info.key, modeConf, objectModel, info.scope);
    }
17148#/* (non-Javadoc)
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
    throws ConfigurationException {
        final KeyInfo info = new KeyInfo(name);
        return this.getAttributeValues(info.key, modeConf, objectModel, info.scope );
    }
17149#public KeyInfo(String name) throws ConfigurationException {
            final int pos = name.indexOf(':');
            if ( pos == -1 ) {
                throw new ConfigurationException("Scope is missing in '" + name + '.');
            }
            final String scopeValue = name.substring(0, pos);
            this.key = name.substring(pos + 1);
            if ( "global".equalsIgnoreCase(scopeValue) ) {
                this.scope = Request.GLOBAL_SCOPE;
            } else if ("request".equalsIgnoreCase(scopeValue)) {
                this.scope = Request.REQUEST_SCOPE;
            } else {
                throw new ConfigurationException("Unknown value for scope: " + scopeValue);
            }
        }
17150#public SelectMetaInputModule() {
        this.defaultInput = null; // not needed
    }
17151#/**
     * @see org.apache.avalon.framework.configuration.Configurable#configure(Configuration)
     */
    public void configure(Configuration config) throws ConfigurationException {
        Configuration[] expr = config.getChildren("input-module");
        if (expr == null || expr.length != 1) {
            throw new ConfigurationException("Need to have exactly one input-module element.");
        }
        this.parameter = config.getChild("parameter").getValue();
        Configuration[] whens = config.getChildren("when");
        Configuration[] others = config.getChildren("otherwise");
        if ((whens == null && others == null)
            || ((whens == null || whens.length == 0) && (others == null || others.length == 0))) {
            throw new ConfigurationException("Need to have at least one when or otherwise element.");
        }
        if (others != null && others.length > 1) {
            throw new ConfigurationException("Need to have at most one otherwise element.");
        }
        this.whenTest = new TreeMap();
        for (int i = 0; i < expr.length; i++) {
            String name = expr[i].getAttribute("name");
            this.expression = new ModuleHolder(name, expr[i], null);
        }

        if (others != null) {
            for (int i = 0; i < others.length; i++) {
                String name = others[i].getAttribute("name");
                this.otherwise = new ModuleHolder(name, others[i], null);
            }
        }

        if (whens != null) {
            for (int i = 0; i < whens.length; i++) {
                String name = whens[i].getAttribute("name");
                this.whenTest.put(
                    whens[i].getAttribute("test"),
                    new ModuleHolder(name, whens[i], null));
            }
        }
    }
17152#/**
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttribute(String, Configuration, Map)
     */
    public Object getAttribute(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        Object result = this.getAttribute(name, modeConf, objectModel, false);
        return result;
    }
17153#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        Object result = this.getAttribute(name, modeConf, objectModel, true);
        return (result != null ? (Object[]) result : null );
    }
17154#private Object getAttribute(String name, Configuration modeConf, Map objectModel, boolean getValues)
    throws ConfigurationException {
        if (!this.initialized) {
            this.lazy_initialize();
        }
        ModuleHolder expression = this.expression;
        ModuleHolder otherwise = this.otherwise;
        ModuleHolder module = null;
        String parameter = this.parameter;
        boolean needRelease = false;
        boolean dynamicConfig = (modeConf != null && modeConf.getChildren().length > 0);

        if (dynamicConfig) {
            // clear all configured values so that they
            // don't get mixed up
            expression = null;
            otherwise = null;
            needRelease = true;

            Configuration[] expr = modeConf.getChildren("input-module");
            Configuration[] other = modeConf.getChildren("otherwise");
            if (expr != null && expr.length == 1) {
                expression = new ModuleHolder(expr[0].getAttribute("name"), expr[0]);
            }
            if (other != null && other.length == 1) {
                otherwise = new ModuleHolder(other[0].getAttribute("name"), other[0]);
            }
            parameter = modeConf.getChild("parameter").getValue();
        }

        String value =
            (String) this.getValue(parameter, objectModel, expression.input, expression.name, expression.config);
        if (needRelease) {
            this.releaseModule(expression.input);
        }
        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug(
                (dynamicConfig ? "(dyn)" : "(static)")
                    + " select ("
                    + value
                    + ") from "
                    + expression.name
                    + ":"
                    + parameter);
        }

        if (dynamicConfig && value != null) {
            Configuration[] whens = modeConf.getChildren("when");
            if (whens != null && whens.length > 0) {
                int i = 0;
                boolean found = false;
                while (!found && i < whens.length) {
                    if (whens[i].getAttribute("test").equals(value)) {
                        found = true;
                        break;
                    }
                    i++;
                }
                if (found) {
                    module = new ModuleHolder(whens[i].getAttribute("name"), whens[i]);
                }
            }
        } else if (value != null) {
            module = (ModuleHolder) this.whenTest.get(value);
        }
        if (module != null) {
            if (this.getLogger().isDebugEnabled()) {
                this.getLogger().debug("found matching when : "+module.name);
            }
        } else {
            module = otherwise;
            if (this.getLogger().isDebugEnabled()) {
                this.getLogger().debug("using otherwise : "+module.name);
            }
        }

        Object result;
        if (getValues){
            result = (module == null ? null : this.getValues(name, objectModel, module));
        } else {
            result = (module == null ? null : this.getValue(name, objectModel, module));
        }

        if (needRelease && module != null) {
            this.releaseModule(module.input);
        }
        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("Obtained value : "+result);
        }
        return result;
    }
17155#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        this.releaseModule(this.expression.input);
        this.expression = null;

        if (this.otherwise != null) {
            this.releaseModule(this.otherwise.input);
            this.otherwise = null;
        }

        for (Iterator i = this.whenTest.values().iterator(); i.hasNext();) {
            ModuleHolder holder = (ModuleHolder) i.next();
            this.releaseModule(holder.input);
        }
        this.whenTest = null;

        super.dispose();
    }
17156#/**
     * @see org.apache.cocoon.components.modules.input.AbstractMetaModule#lazy_initialize()
     */
    public synchronized void lazy_initialize() {
        if (this.initialized) {
            return;
        }

        super.lazy_initialize();

        if (this.expression != null) {
            this.expression.input = this.obtainModule(this.expression.name);
        }
        if (this.otherwise != null){
            this.otherwise.input = this.obtainModule(this.otherwise.name);
        }
        if (this.whenTest != null){
            for (Iterator i = this.whenTest.values().iterator(); i.hasNext(); ){
                ModuleHolder moduleHolder = (ModuleHolder) i.next();
                moduleHolder.input = this.obtainModule(moduleHolder.name);
            }
        }
    }
17157#public Object getAttribute( String name, Configuration modeConf, Map objectModel ) throws ConfigurationException {

        String uri = ObjectModelHelper.getRequest(objectModel).getSitemapURI();

        if (uri.startsWith("/")) {
            uri = uri.substring(1);
        }

        return uri;
    }
17158#public Iterator getAttributeNames( Configuration modeConf, Map objectModel ) throws ConfigurationException {

        return RequestURIModule.returnNames.iterator();
    }
17159#public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
        throws ConfigurationException {

            Object values = new Object[1];
            values = this.getAttribute(name, modeConf, objectModel);

            return (values == null? null : new Object[]{values});            
    }
17160#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration config) throws ConfigurationException {
        this.inputConf = config.getChild("input-module");
        this.defaultInput = this.inputConf.getAttribute("name", this.defaultInput);

        this.defaultAlgorithm = this.inputConf.getAttribute("algorithm",this.defaultAlgorithm);
        this.defaultProvider = this.inputConf.getAttribute("provider",this.defaultProvider);
        this.defaultSalt = this.inputConf.getAttribute("salt",this.defaultSalt);
        this.defaultEncode = this.inputConf.getAttribute("encode","false");

        // preferred
        this.defaultAlgorithm = config.getChild("algorithm").getValue(this.defaultAlgorithm);
        this.defaultProvider = config.getChild("provider").getValue(this.defaultProvider);
        this.defaultSalt = config.getChild("salt").getValue(this.defaultSalt);
        this.defaultEncode = config.getChild("encode").getValue(this.defaultEncode);

        if (encodingNames.get(this.defaultEncode) == null) {
            if (getLogger().isErrorEnabled())
                getLogger().error("Requested encoding is unknown: "+this.defaultEncode);
            this.defaultEncode="false";
        }
    }
17161#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttribute(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object getAttribute( String name, Configuration modeConf, Map objectModel ) 
    throws ConfigurationException {
        if (!this.initialized) {
            this.lazy_initialize();
        }
        if (this.defaultInput == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }

        // obtain correct configuration objects
        // default vs dynamic
        Configuration inputConfig = null;
        String inputName=null;
        String algorithm = this.defaultAlgorithm;
        String provider  = this.defaultProvider;
        String salt  = this.defaultSalt;
        int encode = ((Integer) encodingNames.get(this.defaultEncode)).intValue();
        if (modeConf!=null) {
            inputName   = modeConf.getChild("input-module").getAttribute("name",null);
            if (inputName != null) {
                inputConfig = modeConf.getChild("input-module");
            }
            // read necessary parameters
            algorithm = modeConf.getAttribute("algorithm", algorithm);
            provider  = modeConf.getAttribute("provider", provider);
            salt  = modeConf.getAttribute("salt", salt);
            encode = ((Integer) encodingNames.get(modeConf.getAttribute("encode", this.defaultEncode))).intValue();

            // preferred
            algorithm = modeConf.getChild("algorithm").getValue(algorithm);
            provider  = modeConf.getChild("provider").getValue(provider);
            salt  = modeConf.getChild("salt").getValue(salt);
            encode = ((Integer) encodingNames.get(modeConf.getChild("encode").getValue(this.defaultEncode))).intValue();
        }


        Object value = getValue(name, objectModel,
                                this.input, this.defaultInput, this.inputConf,
                                null, inputName, inputConfig);
        
        if (value != null)
            try {
                MessageDigest md = (provider==null ? MessageDigest.getInstance(algorithm) : 
                                    MessageDigest.getInstance(algorithm,provider));
                
                md.update((salt+(value instanceof String? (String)value : value.toString())).getBytes());
                return encodeByteArray(md.digest(),encode);

            } catch (NoSuchAlgorithmException nsae) {
                if (getLogger().isWarnEnabled()) 
                    getLogger().warn("A problem occurred acquiring digest algorithm '" + algorithm 
                                     + (provider==null?"":"' from '"+provider) +"': " + nsae.getMessage());
            } catch (NoSuchProviderException nspe) {
                if (getLogger().isWarnEnabled()) 
                    getLogger().warn("A problem occurred acquiring digest algorithm '" + algorithm 
                                     + (provider==null?"":"' from '"+provider) +"': " + nspe.getMessage());
            }

        return null;        
    }
17162#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Iterator getAttributeNames( Configuration modeConf, Map objectModel )
    throws ConfigurationException {
        if (!this.initialized) {
             this.lazy_initialize();
        }
        if (this.defaultInput == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }

        // obtain correct configuration objects
        // default vs dynamic
        Configuration inputConfig = null;
        String inputName=null;
        if (modeConf!=null) {
            inputName   = modeConf.getChild("input-module").getAttribute("name",null);
            if (inputName != null) {
                inputConfig = modeConf.getChild("input-module");
            }
        }

        Iterator names = getNames(objectModel, 
                                  this.input, this.defaultInput, this.inputConf, 
                                  null, inputName, inputConfig);
        
        return names;
    }
17163#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
    throws ConfigurationException {
        if (!this.initialized) {
            this.lazy_initialize();
        }
        if (this.defaultInput == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }

        // obtain correct configuration objects
        // default vs dynamic
        Configuration inputConfig = null;
        String inputName=null;
        String algorithm = this.defaultAlgorithm;
        String provider  = this.defaultProvider;
        String salt  = this.defaultSalt;
        int encode = ((Integer) encodingNames.get(this.defaultEncode)).intValue();
        if (modeConf!=null) {
            inputName   = modeConf.getChild("input-module").getAttribute("name",null);
            if (inputName != null) {
                inputConfig = modeConf.getChild("input-module");
            }
            // read necessary parameters
            algorithm = modeConf.getAttribute("algorithm", algorithm);
            provider  = modeConf.getAttribute("provider" , provider );
            salt  = modeConf.getAttribute("salt" , salt );
            encode = ((Integer) encodingNames.get(modeConf.getAttribute("encode" , this.defaultEncode))).intValue();

            // preferred
            algorithm = modeConf.getChild("algorithm").getValue(algorithm);
            provider  = modeConf.getChild("provider").getValue(provider);
            salt  = modeConf.getChild("salt").getValue(salt);
            encode = ((Integer) encodingNames.get(modeConf.getChild("encode").getValue(this.defaultEncode))).intValue();
        }

        Object[] values = getValues(name, objectModel, 
                                    this.input, this.defaultInput, this.inputConf, 
                                    null, inputName, inputConfig);
        Object[] result = null;

        if (values != null) {
            try {
                MessageDigest md = (provider==null ? MessageDigest.getInstance(algorithm) : 
                                    MessageDigest.getInstance(algorithm,provider));
                
                result = new Object[values.length];
                for (int i=0; i<values.length; i++) {
                    md.update((salt + (values[i] instanceof String? (String)values[i] : 
                                       values[i].toString())).getBytes());
                    result[i] = encodeByteArray(md.digest(), encode);
                }
                return result;
            } catch (NoSuchAlgorithmException nsae) {
                if (getLogger().isWarnEnabled()) 
                    getLogger().warn("A problem occurred acquiring digest algorithm '" + algorithm 
                                     + (provider==null?"":"' from '"+provider) +"': " + nsae.getMessage());
            } catch (NoSuchProviderException nspe) {
                if (getLogger().isWarnEnabled()) 
                    getLogger().warn("A problem occurred acquiring digest algorithm '" + algorithm 
                                     + (provider==null?"":"' from '"+provider) +"': " + nspe.getMessage());
            }
        }
        return result;
    }
17164#/**
     * Create the output representation.
     * @param b a <code>byte[]</code>
     * @param encode an <code>int</code>, one of {@link #ENCODING_NONE},{@link #ENCODING_URL},{@link #ENCODING_HEX}
     * @return an <code>Object</code>
     */
    Object encodeByteArray(byte[] b, int encode) {
        Object result = null;
        switch(encode) {
        case ENCODING_HEX:
            result = byte2Hex(b);
            break;
        case ENCODING_STR:
            try {
                result = new String(b, "UTF-8");
            } catch (UnsupportedEncodingException uee) {
                if (getLogger().isErrorEnabled())
                    getLogger().error("UTF-8 not supported -- cannot convert message digest to String.");
            }
            break;
        case ENCODING_URL:
            try {
                String str = new String(b, "UTF-8");
                result = URLEncoder.encode(str, "utf-8");
            } catch (UnsupportedEncodingException uee) {
                if (getLogger().isErrorEnabled())
                    getLogger().error("UTF-8 not supported -- cannot convert message digest to String.");
            }
            break;
        case ENCODING_NONE:
            // nothing to do
            break;
        default:
            // should not happen
        }
        return result;
    }
17165#/**
     * Create a hex representation of a byte array.
     *
     * @param b a <code>byte[]</code> value
     * @return a <code>String</code> value
     */
    static String byte2Hex ( byte[] b ) {
        StringBuffer sb = new StringBuffer( b.length * 2 );
        for ( int i=0 ; i < b.length ; i++ ) {
            sb.append( hexChar [ ( b[i] & 0xf0 ) >>> 4 ] ) ;
            sb.append( hexChar [ ( b[i] & 0x0f )       ] ) ;
        }
        return sb.toString() ;
    }
17166#public Object getAttribute(String name, Configuration modeConf, Map objectModel) throws ConfigurationException {
        long min = Long.parseLong((String)this.settings.get("min", "0"));
        long max = Long.parseLong((String)this.settings.get("max", String.valueOf(Long.MAX_VALUE)));
        if (modeConf != null) {
            min = modeConf.getAttributeAsLong("max", min);
            max = modeConf.getAttributeAsLong("max", max);

            //preferred
            min = modeConf.getChild("min").getValueAsLong(min);
            max = modeConf.getChild("max").getValueAsLong(max);
        }
        return Long.toString(min + Math.round(Math.random()*(max-min)));
    }
17167#public Iterator getAttributeNames(Configuration modeConf, Map objectModel) throws ConfigurationException {
        return RandomNumberModule.returnNames.iterator();
    }
17168#public Object[] getAttributeValues(String name, Configuration modeConf, Map objectModel)
        throws ConfigurationException {
            List values = new LinkedList();
            values.add(this.getAttribute(name, modeConf, objectModel));
            return values.toArray();
    }
17169#protected Object getAttribute( String name, Configuration modeConf, Map objectModel, int scope)
    throws ConfigurationException {
        String pname = (String) this.settings.get("parameter", name);
        if ( modeConf != null ) {
            pname = modeConf.getAttribute( "parameter", pname );
            // preferred
            pname = modeConf.getChild("parameter").getValue(pname);
        }
        Request req = ObjectModelHelper.getRequest(objectModel);
        return (scope == Request.GLOBAL_SCOPE) ? req.getAttribute(pname) : req.getLocalAttribute(pname);       
    }
17170#/* (non-Javadoc)
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttribute(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object getAttribute( String name, Configuration modeConf, Map objectModel )
    throws ConfigurationException {
        return ObjectModelHelper.getRequest(objectModel).getAttribute(name);
    }
17171#/* (non-Javadoc)
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Iterator getAttributeNames( Configuration modeConf, Map objectModel )
    throws ConfigurationException {
        return new IteratorHelper(ObjectModelHelper.getRequest(objectModel).getAttributeNames());
    }
17172#protected Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel, int scope )
    throws ConfigurationException {
        final Request request = ObjectModelHelper.getRequest(objectModel);
        
        String wildcard = (String) this.settings.get("parameter",name);
        if ( modeConf != null ) {
            wildcard = modeConf.getAttribute( "parameter", wildcard );
            // preferred
            wildcard = modeConf.getChild("parameter").getValue(wildcard);
        }
        int wildcardIndex = wildcard.indexOf( "*" );
        if ( wildcardIndex != -1 ) {
            // "*" contained in attribute name => combine all
            // attributes' values that match prefix, suffix

            // split the attribute's name so that the "*" could be
            // determined by looking at the attributes' names that
            // start with the prefix and end with the suffix
            //
            String prefix = wildcard.substring( 0, wildcardIndex );
            String suffix;
            if ( wildcard.length() >= wildcardIndex + 1 ) {
                suffix = wildcard.substring( wildcardIndex + 1 );
            } else {
                suffix = "";
            }
            SortedSet names = new TreeSet();
            Enumeration allNames = (scope == Request.GLOBAL_SCOPE) ?
                    request.getAttributeNames() : request.getLocalAttributeNames();

            while (allNames.hasMoreElements()) {
                String pname = (String) allNames.nextElement();
                if ( pname.startsWith( prefix ) && pname.endsWith( suffix ) ) {
                    names.add(pname);
                }
            }

            List values = new LinkedList();
            Iterator j = names.iterator();
            while (j.hasNext()){
                String pname = (String) j.next();
                values.add( request.getAttribute( pname ) );
            }

            return values.toArray();

        } else {
            // no "*" in attribute name => just return all values of
            // this one attribute. Make sure, it's an array.

            Object value = (scope == Request.GLOBAL_SCOPE) ? request.getAttribute( wildcard) :
                    request.getLocalAttribute( wildcard);
            if ( value != null && !value.getClass().isArray() ) {
                Object[] values = new Object[1];
                values[0] = value;
                return values;
            } else {
                return (Object[]) value;
            }

        }

    }
17173#/* (non-Javadoc)
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
    throws ConfigurationException {
        return this.getAttributeValues(name, modeConf, objectModel, Request.GLOBAL_SCOPE );
    }
17174#public StringConcatMetaModule() {
        this.defaultInput = null;
    }
17175#/**
     * @param configurations
     *            List of configuration objects for input modules
     * @return List of {@link ModuleHolder} objects obtained from
     *         configurations. If configuration does not have {@code name}
     *         attribute it will be skipped and error logged.
     * @throws ConfigurationException
     */
    protected ModuleHolder[] getFilteredInputModules(Configuration[] configurations) throws ConfigurationException {
        ModuleHolder[] moduleList = new ModuleHolder[configurations.length];
        int j = 0;
        for (int i = 0; i < configurations.length; i++) {
            if (configurations[i].getAttribute("name", null) == null) {
                if (getLogger().isErrorEnabled())
                    getLogger().error("No name attribute for module configuration. Skipping.");
                continue;
            }
            moduleList[j] = new ModuleHolder(configurations[i].getAttribute("name"), configurations[i]);
            j++;
        }
        return moduleList;
    }
17176#/**
     * @param dynamicConfigurations
     * @return It returns list of modules. If {@code dynamicConfigurations} does
     *         not contain valid list of configuration (e.g. is null) then
     *         static list is returned. In other case list is obtained from
     *         dynamicConfigurations.
     * @throws ConfigurationException
     */
    protected ModuleHolder[] getInputModules(Configuration[] dynamicConfigurations) throws ConfigurationException {
        return (dynamicConfigurations != null && dynamicConfigurations.length != 0) ? getFilteredInputModules(dynamicConfigurations) : inputs;
    }
17177#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration config) throws ConfigurationException {
        this.inputs = getFilteredInputModules(config.getChildren("input-module"));
    }
17178#public Object getAttribute(String name, Configuration modeConf, Map objectModel) throws ConfigurationException {
        ModuleHolder[] inputModules = getInputModules(modeConf != null ? modeConf.getChildren("input-module") : null);
        Object rawValue;
        String value = "";

        for (int i = 0; i < inputModules.length; i++) {
            rawValue = getValue(name, objectModel, inputModules[i]);
            if (rawValue == null)
                throw new RuntimeException("Module " + inputModules[i].name + "returned null as attribute " + name);
            value = value + rawValue;
        }

        return value;
    }
17179#/**
     * Calculate the minimal length of the URL, that is the position
     * of the first ":" if a protocol is provided or otherwise 0.
     * @param name
     * @return minimal length
     */
    protected int calculateMinLen(String name) {

        int minLen = name.indexOf(':');
        minLen = (minLen == -1 ? 0 : minLen);

        return minLen;
    }
17180#/**
     * Remove one path element from the URL unless minimum length has
     * been reached.
     * 
     * @param urlstring
     * @param minLen
     * @return shortened URI
     */
    protected String shortenURI(String urlstring, int minLen) {

        int idx = urlstring.lastIndexOf('/');
        idx = (idx <= minLen + 1) ? minLen : idx;
        urlstring = urlstring.substring(0, idx);

        return urlstring;
    }
17181#/** 
     * if the url does not end with a "/", keep the last part in
     * order to add it later again after traversing up
     */
    protected String extractFilename(String urlstring) {

        String filename = "";
        if (!urlstring.endsWith("/")) {
            int idx = urlstring.lastIndexOf('/');
            filename = urlstring.substring(idx);
        }

        return filename;
    }
17182#/**
     * Locate a resource with the given URL consisting of urlstring + filename.
     * The filename is appended each time the path is shortened. Returns the first
     * existing occurance.
     * 
     * @param urlstring
     * @param filename
     * @param minLen
     * @return urlstring if resource was found, <code>null</code> otherwise
     */
    protected String locateResource(String urlstring, String filename, int minLen) {
        String sourcename = null;
        Source src = null;
        SourceResolver resolver = null;
        boolean found = false;
        try {
            resolver =
                (SourceResolver) this.manager.lookup(
                    org.apache.excalibur.source.SourceResolver.ROLE);
            while (!found && urlstring.length() > minLen) {
                sourcename = urlstring + filename;
                try {
                    src = resolver.resolveURI(sourcename);
                    if (src.exists())
                        found = true;
                } catch (Exception e) {
                    if (this.getLogger().isWarnEnabled())
                        this.getLogger().warn("Exception resolving URL " + sourcename, e);
                } finally {
                    resolver.release(src);
                }
                if (!found) {
                    urlstring = shortenURI(urlstring, minLen);
                }
            }
        } catch (ServiceException e1) {
            if (this.getLogger().isErrorEnabled())
                this.getLogger().error("Exception obtaining source resolver ", e1);
        } finally {
            if (resolver != null) {
                this.manager.release(resolver);
            }
        }
        return (found ? urlstring : null);
    }
17183#/* (non-Javadoc)
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
17184#/* (non-Javadoc)
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttribute(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object getAttribute(String name, Configuration modeConf, Map objectModel)
        throws ConfigurationException {

        String urlstring = name;
        String filename = extractFilename(urlstring);
        int minLen = calculateMinLen(name);
        if (filename.length() > 0) {
            urlstring = shortenURI(urlstring, minLen);
        }

        String result = locateResource(urlstring, filename, minLen);
        if (result != null) {
            result += filename;
        }
        if (this.getLogger().isDebugEnabled())
            this.getLogger().debug(
                "located " + name + " @ " + result);
        return result;
    }
17185#/* (non-Javadoc)
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Iterator getAttributeNames(Configuration modeConf, Map objectModel)
        throws ConfigurationException {
        // return an iterator to an empty collection
        return LocateResource.col.iterator();
    }
17186#/* (non-Javadoc)
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues(String name, Configuration modeConf, Map objectModel)
        throws ConfigurationException {

        Vector uris = null;
        String urlstring = name;
        String filename = extractFilename(urlstring);
        int minLen = calculateMinLen(name);
        if (filename.length() > 0) {
            urlstring = shortenURI(urlstring, minLen);
        }

        while (urlstring != null && urlstring.length() > minLen) {
            urlstring = this.locateResource(urlstring, filename, minLen);
            if (urlstring != null) {
                if (uris == null)
                    uris = new Vector();
                if (this.getLogger().isDebugEnabled())
                    this.getLogger().debug("-> located " + name + " @ " + urlstring + filename);
                uris.add(urlstring + filename);
                urlstring = shortenURI(urlstring, minLen);
            }
        }
        return (uris == null ? null : uris.toArray());
    }
17187#public Object getAttribute( String name, Configuration modeConf, Map objectModel ) throws ConfigurationException {

        String pname = (String) this.settings.get("parameter", name);
        if ( modeConf != null ) {
            pname = modeConf.getAttribute( "parameter", pname );
            // preferred
            pname = modeConf.getChild("parameter").getValue(pname);
        }
        return ObjectModelHelper.getRequest(objectModel).getParameter( pname );
    }
17188#public Iterator getAttributeNames( Configuration modeConf, Map objectModel ) throws ConfigurationException {

        return new IteratorHelper(ObjectModelHelper.getRequest(objectModel).getParameterNames());
    }
17189#public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
        throws ConfigurationException {

        Request request = ObjectModelHelper.getRequest(objectModel);
        String wildcard = (String) this.settings.get("parameter", name);
        if ( modeConf != null ) {
            wildcard = modeConf.getAttribute( "parameter", wildcard );
            // preferred
            wildcard = modeConf.getChild("parameter").getValue(wildcard);
        }
        int wildcardIndex = wildcard.indexOf( "*" );
        if ( wildcardIndex != -1 ) {
            // "*" contained in parameter name => combine all
            // parameters' values that match prefix, suffix

            // split the parameter's name so that the "*" could be
            // determined by looking at the parameters' names that
            // start with the prefix and end with the suffix
            //
            String prefix = wildcard.substring( 0, wildcardIndex );
            String suffix;
            if ( wildcard.length() >= wildcardIndex + 1 ) {
                suffix = wildcard.substring( wildcardIndex + 1 );
            } else {
                suffix = "";
            }
            SortedSet names = new TreeSet();
            Enumeration allNames = request.getParameterNames();

            while (allNames.hasMoreElements()) {
                String pname = (String) allNames.nextElement();
                if ( pname.startsWith( prefix ) && pname.endsWith( suffix ) ) {
                    names.add(pname);
                }
            }

            List values = new LinkedList();
            Iterator j = names.iterator();
            while (j.hasNext()){
                String pname = (String) j.next();
                values.add( request.getParameter( pname ) );
            }

            return values.toArray();

        } else {
            // no "*" in parameter name => just return all values of
            // this one parameter.

            return request.getParameterValues( wildcard );

        }

    }
17190#public Object getAttribute( String name, Configuration modeConf, Map objectModel ) throws ConfigurationException {
        
        String format = (String) this.settings.get("format",name);
        if (modeConf != null) {
            format = modeConf.getAttribute("format", format);
            // this is preferred:
            format = modeConf.getChild("format").getValue(format);
        }

        if (format==null) {
            return new Date();
        } else {
            try {
                return new SimpleDateFormat(format).format(new Date());
            } catch (Exception e) {
                return new Date();
            }           
        }
    }
17191#public Iterator getAttributeNames( Configuration modeConf, Map objectModel ) throws ConfigurationException {

        return DateInputModule.returnNames.iterator();
    }
17192#public Object[] getAttributeValues( String name, Configuration modeConf, Map objectModel )
        throws ConfigurationException {

            List values = new LinkedList();
            values.add( this.getAttribute(name, modeConf, objectModel) );

            return values.toArray();
            
    }
17193#protected Object getContextObject(Configuration modeConf,
                                      Map objectModel) {

        return FlowHelper.getContextObject(objectModel);
    }
17194#/**
     * communicate an attribute value to further processing logic.
     * @param modeConf column's mode configuration from resource
     * description. This argument is optional.
     * @param objectModel The objectModel
     * @param name The attribute's label, consisting of "table.column"
     * or "table.column[index]" in case of multiple attributes of the
     * same spec.
     * @param value The attriute's value.
     * */
    public void setAttribute( Configuration modeConf, Map objectModel, String name, Object value ) {
        if (this.settings.get("isolation-level","0").equals("1")) {
            if (getLogger().isDebugEnabled())
                getLogger().debug("setting transient ['"+name+"'] to ['"+value+"']");
            this.transientSetAttribute(objectModel, TRANS_PREFIX, name, value);
        } else {
            // use read uncommitted isolation level

            HttpSession session = ObjectModelHelper.getRequest(objectModel).getSession();

            name = getName(name);

            if (!this.attributeExists(objectModel, ROLLBACK_LIST, name)) {
                Object tmp = session.getAttribute(name);
                this.transientSetAttribute(objectModel, ROLLBACK_LIST, name, tmp);
            }

            if (getLogger().isDebugEnabled())
                getLogger().debug("setting ['"+name+"'] to ['"+value+"']");
            session.setAttribute(name, value);
        }

    }
17195#/**
     * If a database transaction needs to rollback, this is called to
     * inform the further processing logic about this fact. All
     * already set attribute values are invalidated. <em>This is difficult
     * because only the request object can be used to synchronize this
     * and build some kind of transaction object. Beaware that sending
     * your data straight to some beans or other entities could result
     * in data corruption!</em>
     * */
    public void rollback( Configuration modeConf, Map objectModel, Exception e ) {
        if (this.settings.get("isolation-level","0").equals("1")) {
            if (getLogger().isDebugEnabled())
                getLogger().debug("rolling back");
            this.rollback(objectModel, TRANS_PREFIX);
        } else {

            if (getLogger().isDebugEnabled())
                getLogger().debug("start rolling back");
            
            HttpSession session = ObjectModelHelper.getRequest(objectModel).getSession();
            Object tmp = this.prepareCommit(objectModel,ROLLBACK_LIST);
            if (tmp != null) {
                Map rollbackList = (Map) tmp;
                Iterator iter = rollbackList.keySet().iterator();
                while(iter.hasNext()) {
                    String key = (String) iter.next();
                    Object val = rollbackList.get(key);
                    if (val != null) {
                        if (getLogger().isDebugEnabled())
                            getLogger().debug("rolling back ['"+key+"'] to ['"+val+"']");
                        session.setAttribute(key, val);
                    } else {
                        if (getLogger().isDebugEnabled())
                            getLogger().debug("rolling back ['"+key+"']");
                        session.removeAttribute(key);
                    }
                }
            }
        }

        if (getLogger().isDebugEnabled())
            getLogger().debug("done rolling back");

        String prefix = (String) this.settings.get("key-prefix", PREFIX );
        if (!(prefix.equals(""))) {
            ObjectModelHelper.getRequest(objectModel).getSession().setAttribute(prefix+":",e.getMessage());
        } else {
            ObjectModelHelper.getRequest(objectModel).getSession().setAttribute("errorMessage",e.getMessage());
        }
    }
17196#/**
     * Signal that the database transaction completed
     * successfully. See notes on @link{rollback}.
     * */
    public void commit( Configuration modeConf, Map objectModel ) {
        if (this.settings.get("isolation-level","0").equals("1")) {

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("prepare commit");
            }

            Map aMap = this.prepareCommit(objectModel, TRANS_PREFIX);
            if (aMap == null) {
                return;
            }
            
            Iterator iter = aMap.keySet().iterator();
            if (!iter.hasNext()){
                return;
            }
            
            String prefix = (String) this.settings.get("key-prefix", PREFIX );
            if (prefix.length() > 0) {
                prefix = prefix + ":";
            } else {
                prefix = null;
            }
            HttpSession session = ObjectModelHelper.getRequest(objectModel).getSession();
            while (iter.hasNext()) {
                String key = (String) iter.next();
                Object value = aMap.get(key);
                if (prefix != null) { key = prefix + key; }
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("committing ['"+key+"'] to ['"+value+"']");
                }
                session.setAttribute(key, value);
            }

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("done commit");
            }

        } else {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("commit");
            }

            prepareCommit(objectModel, ROLLBACK_LIST);
        }
    }
17197#protected String getName( String name ) {
        String prefix = (String) this.settings.get("key-prefix", PREFIX);
        return prefix.length() == 0 ? name : prefix + ":" + name;
    }
17198#/**
     * communicate an attribute value to further processing logic.
     * @param modeConf column's mode configuration from resource
     * description. This argument is optional.
     * @param objectModel The objectModel
     * @param name The attribute's label, consisting of "table.column"
     * or "table.column[index]" in case of multiple attributes of the
     * same spec.
     * @param value The attriute's value.
     * */
    public void setAttribute( Configuration modeConf, Map objectModel, String name, Object value ) {
        if (getLogger().isDebugEnabled())
            getLogger().debug("setting transient ['"+name+"'] to ['"+value+"']");
        super.transientSetAttribute(objectModel, TRANS_PREFIX, name, value );
    }
17199#/**
     * If a database transaction needs to rollback, this is called to
     * inform the further processing logic about this fact. All
     * already set attribute values are invalidated. <em>This is difficult
     * because only the request object can be used to synchronize this
     * and build some kind of transaction object. Beaware that sending
     * your data straight to some beans or other entities could result
     * in data corruption!</em>
     * */
    public void rollback( Configuration modeConf, Map objectModel, Exception e ) {
        if (getLogger().isDebugEnabled())
            getLogger().debug("rolling back");
        super.rollback(objectModel, TRANS_PREFIX);
    }
17200#/**
     * Signal that the database transaction completed
     * successfully. See notes on @link{rollback}.
     * */
    public void commit( Configuration modeConf, Map objectModel ) {
        if (getLogger().isDebugEnabled())
            getLogger().debug("prepare commit");
        Map aMap = super.prepareCommit(objectModel,TRANS_PREFIX);
        if (aMap == null) {
            // nothing to do
            return;
        }
        
        String prefix = (String) this.settings.get("key-prefix", PREFIX);
        Request request = ObjectModelHelper.getRequest(objectModel);
        Object temp = request.getAttribute(prefix);
        Map old = null;
        if (temp == null) {
            old = aMap;
        } else {
            old = (Map) temp;
            old.putAll(aMap);
        }
        request.setAttribute(prefix, old);
        if (getLogger().isDebugEnabled())
            getLogger().debug("done commit to ['"+prefix+"']");
    }
17201#/**
     * communicate an attribute value to further processing logic.
     * @param modeConf column's mode configuration from resource
     *                 description. This argument is optional.
     * @param objectModel The objectModel
     * @param name The attribute's label, consisting of "table.column"
     *             or "table.column[index]" in case of multiple attributes
     *             of the same spec.
     * @param value The attriute's value.
     */
    public void setAttribute(Configuration modeConf, Map objectModel, String name, Object value) {
        if (this.settings.get("isolation-level", "0").equals("1")) {
            // Read committed isolation level
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Setting transient ['" + name + "'] to ['" + value + "']");
            }
            transientSetAttribute(objectModel, TRANS_PREFIX, name, value);
        } else {
            // Read uncommitted isolation level
            final Request request = ObjectModelHelper.getRequest(objectModel);

            name = getName(name);

            if (!attributeExists(objectModel, ROLLBACK_LIST, name)) {
                Object tmp = request.getAttribute(name);
                transientSetAttribute(objectModel, ROLLBACK_LIST, name, tmp);
            }

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Setting ['" + name + "'] to ['" + value + "']");
            }
            request.setAttribute(name, value);
        }
    }
17202#/**
     * If a database transaction needs to rollback, this is called to
     * inform the further processing logic about this fact. All
     * already set attribute values are invalidated.
     *
     * <em>This is difficult
     * because only the request object can be used to synchronize this
     * and build some kind of transaction object. Beware that sending
     * your data straight to some beans or other entities could result
     * in data corruption!</em>
     */
    public void rollback(Configuration modeConf, Map objectModel, Exception e) {
        getLogger().debug("Rollback");
        final Request request = ObjectModelHelper.getRequest(objectModel);

        if (this.settings.get("isolation-level", "0").equals("1")) {
            rollback(objectModel, TRANS_PREFIX);
        } else {
            Map rollbackList = prepareCommit(objectModel, ROLLBACK_LIST);
            if (rollbackList != null) {
                for (Iterator i = rollbackList.entrySet().iterator(); i.hasNext();) {
                    final Map.Entry me = (Map.Entry) i.next();
                    String key = (String) me.getKey();
                    Object val = me.getValue();
                    if (val != null) {
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("Rolling back ['" + key + "'] to ['" + val + "']");
                        }
                        request.setAttribute(key, val);
                    } else {
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("Rolling back ['" + key + "']");
                        }
                        request.removeAttribute(key);
                    }
                }
            }
        }

        String prefix = (String) this.settings.get("key-prefix", PREFIX);
        if (prefix.equals("")) {
            request.setAttribute("errorMessage", e.getMessage());
        } else {
            request.setAttribute(prefix + ':' + "errorMessage", e.getMessage());
        }
    }
17203#/**
     * Signal that the database transaction completed
     * successfully. See notes on @link{rollback}.
     */
    public void commit(Configuration modeConf, Map objectModel) {
        getLogger().debug("Commit");
        if (this.settings.get("isolation-level", "0").equals("1")) {
            Map data = prepareCommit(objectModel, TRANS_PREFIX);
            if (data == null || data.isEmpty()) {
                return;
            }

            String prefix = (String) this.settings.get("key-prefix", PREFIX);
            if (prefix.length() == 0) {
                prefix = null;
            }

            Request request = ObjectModelHelper.getRequest(objectModel);
            for (Iterator i = data.entrySet().iterator(); i.hasNext();) {
                final Map.Entry me = (Map.Entry) i.next();
                String key = (String) me.getKey();
                Object value = me.getValue();
                if (prefix != null) {
                    key = prefix + ':' + key;
                }
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Committing ['" + key + "'] to ['" + value + "']");
                }
                request.setAttribute(key, value);
            }
        } else {
            prepareCommit(objectModel, ROLLBACK_LIST);
        }
        
        
    }
17204#protected String getName(String name) {
        String prefix = (String) this.settings.get("key-prefix", PREFIX);
        return prefix.equals("") ? name : prefix + ':' + name;
    }
17205#/**
     * Servicable Interface
     */
    public void service( ServiceManager manager ) throws ServiceException {
        this.manager = manager;
    }
17206#/**
     * Contextualizable, get the object model
     */
    public void contextualize( Context context ) throws ContextException {
        this.context = context;
    }
17207#/**
     * Get a {@link XModuleSource} object.
     * 
     * @param location   The URI to resolve - this URI includes the scheme.
     * @param parameters this is optional and not used here
     */
    public Source getSource(String location, Map parameters) throws IOException {

        Map objectModel = ContextHelper.getObjectModel(this.context);
        return new XModuleSource(objectModel, location, this.manager);
    }
17208#/**
     * Release a {@link Source} object.
     */
    public void release(Source source) {
        // Do nothing here
    }
17209#/**
     * Construct a new object
     */
    public SitemapSource(ServiceManager manager,
                         String         uri,
                         Map            parameters)
    throws MalformedURLException {

        Environment env = EnvironmentHelper.getCurrentEnvironment();
        if ( env == null ) {
            throw new MalformedURLException("The cocoon protocol can not be used outside an environment.");
        }
        this.manager = manager;

        SitemapSourceInfo info = SitemapSourceInfo.parseURI(env, uri);
        this.protocol = info.protocol;

        // does the uri point to this sitemap or to the root sitemap?
        if (info.processFromRoot) {
            this.processor = EnvironmentHelper.getCurrentProcessor().getRootProcessor();
        } else {
            this.processor = EnvironmentHelper.getCurrentProcessor();
        }

        // create environment...
        final EnvironmentWrapper wrapper = new EnvironmentWrapper(env, info);

        // The environment is a facade whose delegate can be changed in case of internal redirects
        this.environment = new MutableEnvironmentFacade(wrapper);

        // ...and put information passed from the parent request to the internal request
        if ( null != parameters ) {
            this.environment.getObjectModel().put(ObjectModelHelper.PARENT_CONTEXT, parameters);
        } else {
            this.environment.getObjectModel().remove(ObjectModelHelper.PARENT_CONTEXT);
        }

        this.systemId = info.systemId;

        // create a new validity holder
        this.validity = new SitemapSourceValidity();

        // initialize
        this.init();
    }
17210#/**
     * Return the protocol identifier.
     */
    public String getScheme() {
        return this.protocol;
    }
17211#/**
     * Get the content length of the source or -1 if it
     * is not possible to determine the length.
     */
    public long getContentLength() {
        return -1;
    }
17212#/**
     * Get the last modification date.
     * @return The last modification in milliseconds since January 1, 1970 GMT
     *         or 0 if it is unknown
     */
    public long getLastModified() {
        return 0;
    }
17213#/**
     * Return an <code>InputStream</code> object to read from the source.
     */
    public InputStream getInputStream() throws IOException {

        if (this.needsRefresh) {
            this.refresh();
        }
        // VG: Why exception is not thrown in constructor?
        if (this.exception != null) {
            throw new SourceException("Cannot get input stream for " + getURI(), this.exception);
        }

        if (this.redirectSource != null) {
            return this.redirectSource.getInputStream();
        }

        try {
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            this.environment.setOutputStream(os);
            EnvironmentHelper.enterProcessor(this.pipelineDescription.processor,
                                             this.environment);
            try {

                this.pipelineDescription.processingPipeline.process(this.environment);
            } finally {
                EnvironmentHelper.leaveProcessor();
            }

            return new ByteArrayInputStream(os.toByteArray());

        } catch (ResourceNotFoundException e) {
            throw new SourceNotFoundException("Exception during processing of " + this.systemId, e);
        } catch (Exception e) {
            throw new SourceException("Exception during processing of " + this.systemId, e);
        } finally {
            if (touchedOM) {
                //Because of complicated flow of this source it must maintain the cleaness of OM on its own
                ObjectModel newObjectModel;
                try {
                    newObjectModel = (ObjectModel)manager.lookup(ObjectModel.ROLE);
                } catch (ServiceException e) {
                    throw new RuntimeException("Couldn't look up Object Model", e);
                }
                newObjectModel.cleanupLocalContext();
                touchedOM = false;
            }
            // Unhide wrapped environment output stream
            this.environment.setOutputStream(null);
            this.needsRefresh = true;
        }
    }
17214#/**
     * Returns the unique identifer for this source
     */
    public String getURI() {
        return this.systemIdForCaching;
    }
17215#/**
     * Returns true always.
     * @see org.apache.excalibur.source.Source#exists()
     */
    public boolean exists() {
        return true;
    }
17216#/**
     * Get the validity object. This wraps validity of the enclosed event
     * pipeline. If pipeline is not cacheable, <code>null</code> is returned.
     */
    public SourceValidity getValidity() {
        return this.validity.getNestedValidity() == null? null: this.validity;
    }
17217#/**
     * The mime-type of the content described by this object.
     * If the source is not able to determine the mime-type by itself
     * this can be null.
     */
     public String getMimeType() {
         return this.mimeType;
     }
17218#/**
     * Refresh this object and update the last modified date
     * and content length.
     */
    public void refresh() {
        this.reset();
        this.init();
    }
17219#/**
     * Initialize
     */
    protected void init() {
        this.systemIdForCaching = this.systemId;
        try {
            this.environment.startingProcessing();
            this.processed = true;
            this.pipelineDescription = this.processor.buildPipeline(this.environment);
            this.environment.setURI(this.pipelineDescription.prefix, this.pipelineDescription.uri);
            
            //Because of complicated flow of this source it must maintain the cleaness of OM on its own
            ObjectModel newObjectModel = (ObjectModel)manager.lookup(ObjectModel.ROLE);
            newObjectModel.markLocalContext();
            touchedOM = true;
            manager.release(newObjectModel);

            String redirectURL = this.environment.getRedirectURL();
            if (redirectURL == null) {

                EnvironmentHelper.enterProcessor(this.pipelineDescription.processor,
                                                 this.environment);
                try {
                    this.pipelineDescription.processingPipeline.prepareInternal(this.environment);
                    this.validity.set(this.pipelineDescription.processingPipeline.getValidityForEventPipeline());
                    final String eventPipelineKey = this.pipelineDescription.processingPipeline.getKeyForEventPipeline();
                    this.mimeType = this.environment.getContentType();

                    if (eventPipelineKey != null) {
                        StringBuffer buffer = new StringBuffer(this.systemId);
                        if (this.systemId.indexOf('?') == -1) {
                            buffer.append('?');
                        } else {
                            buffer.append('&');
                        }
                        buffer.append("pipelinehash=");
                        buffer.append(eventPipelineKey);
                        this.systemIdForCaching = buffer.toString();
                    } else {
                        this.systemIdForCaching = this.systemId;
                    }
                } finally {
                    EnvironmentHelper.leaveProcessor();
                }
            } else {
                if (redirectURL.indexOf(":") == -1) {
                    redirectURL = this.protocol + ":/" + redirectURL;
                }
                if (this.sourceResolver == null) {
                    this.sourceResolver = (SourceResolver) this.manager.lookup(SourceResolver.ROLE);
                }
                this.redirectSource = this.sourceResolver.resolveURI(redirectURL);
                this.validity.set(this.redirectSource.getValidity());
                this.mimeType = this.redirectSource.getMimeType();
            }
        } catch (SAXException e) {
            reset();
            this.exception = e;
        } catch (Exception e) {
            reset();
            this.exception = new SAXException("Could not get sitemap source " + this.systemId, e);
        }
        this.needsRefresh = false;
    }
17220#/**
     * Stream content to the content handler
     */
    public void toSAX(ContentHandler contentHandler)
    throws SAXException {
        if (this.needsRefresh) {
            this.refresh();
        }
        if (this.exception != null) {
            throw this.exception;
        }
        try {
            if (this.redirectSource != null) {
                SourceUtil.parse(this.manager, this.redirectSource, contentHandler);
            } else {
                XMLConsumer consumer;
                if (contentHandler instanceof XMLConsumer) {
                    consumer = (XMLConsumer)contentHandler;
                } else if (contentHandler instanceof LexicalHandler) {
                    consumer = new ContentHandlerWrapper(contentHandler, (LexicalHandler)contentHandler);
                } else {
                    consumer = new ContentHandlerWrapper(contentHandler);
                }
                // We have to add an environment changer
                // for clean environment stack handling.
                EnvironmentHelper.enterProcessor(this.pipelineDescription.processor,
                                                 this.environment);
                try {
                    this.pipelineDescription.processingPipeline.process(this.environment,
                                                                        EnvironmentHelper.createEnvironmentAwareConsumer(consumer));
                } finally {
                    EnvironmentHelper.leaveProcessor();
                }
            }
        } catch (SAXException e) {
            // Preserve original exception
            throw e;
        } catch (Exception e) {
            throw new SAXException("Exception during processing of " + this.systemId, e);
        } finally {
            if (touchedOM) {
                //Because of complicated flow of this source it must maintain the cleaness of OM on its own
                ObjectModel newObjectModel;
                try {
                    newObjectModel = (ObjectModel)manager.lookup(ObjectModel.ROLE);
                } catch (ServiceException e) {
                    throw new SAXException("Couldn't look up Object Model", e);
                }
                newObjectModel.cleanupLocalContext();
                touchedOM = false;
            }
            this.needsRefresh = true;
        }
    }
17221#/**
     * Reset everything
     */
    private void reset() {
        if (this.pipelineDescription != null) {
            this.pipelineDescription.release();
            this.pipelineDescription = null;
        }

        if (this.processed) {
            this.processed = false;
            this.environment.finishingProcessing();
        }

        if (this.redirectSource != null) {
            this.sourceResolver.release(this.redirectSource);
            this.redirectSource = null;
        }

        this.validity.set(null);

        this.environment.reset();
        this.exception = null;
        this.needsRefresh = true;
    }
17222#/**
     * Recyclable
     */
    public void recycle() {
        this.validity = new SitemapSourceValidity();
        this.reset();
        if ( this.sourceResolver != null ) {
            this.manager.release( this.sourceResolver );
            this.sourceResolver = null;
        }
    }
17223#protected SitemapSourceValidity() {
            super();
        }
17224#protected void set(SourceValidity validity) {
            this.validity = validity;
        }
17225#public int isValid() {
            return (this.validity != null ?
                    this.validity.isValid() :
                    SourceValidity.INVALID);
        }
17226#public int isValid(SourceValidity validity) {
            if (validity instanceof SitemapSourceValidity) {
                return (this.validity != null ?
                        this.validity.isValid(((SitemapSourceValidity) validity).getNestedValidity()) :
                        SourceValidity.INVALID);
            }
            return SourceValidity.INVALID;
        }
17227#public SourceValidity getNestedValidity() {
            return this.validity;
        }
17228#/**
     * Servicable Interface
     */
    public void service( ServiceManager manager ) throws ServiceException {
        this.manager = manager;
    }
17229#/**
     * Contextualizable, get the object model
     */
    public void contextualize( Context context ) throws ContextException {
        this.context = context;
    }
17230#/**
     * Get a {@link ModuleSource} object.
     * 
     * @param location   The URI to resolve - this URI includes the scheme.
     * @param parameters this is optional and not used here
     */
    public Source getSource(String location, Map parameters) throws IOException {

        Map objectModel = ContextHelper.getObjectModel(this.context);
        return new ModuleSource(objectModel, location, this.manager);
    }
17231#/**
     * Release a {@link Source} object.
     */
    public void release( Source source ) {
        // Do nothing here
    }
17232#/**
     * @see Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
17233#/**
     * @see SourceFactory#getSource(java.lang.String, java.util.Map)
     */
    public Source getSource(String location, Map parameters) throws IOException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Creating source object for " + location);
        }

        return new SitemapSource(this.manager, location, parameters);
    }
17234#/**
     * @see SourceFactory#release(org.apache.excalibur.source.Source)
     */
    public void release(Source source) {
        if (source != null) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Releasing source " + source.getURI());
            }
            ((SitemapSource) source).recycle();
        }
    }
17235#/**
     * @see URIAbsolutizer#absolutize(java.lang.String, java.lang.String)
     */
    public String absolutize(String baseURI, String location) {
        return SourceUtil.absolutize(baseURI, location, true);
    }
17236#/**
     * Create a module source from a 'module:' uri and a the object model.
     * <p>The uri is of the form "module:attribute-type:attribute-name#xpath</p>
     */
    public ModuleSource(Map objectModel, String uri, ServiceManager manager)
    throws MalformedURLException {

        this.objectModel = objectModel;
        this.manager = manager;

        setSystemId( uri );

        // Scheme
        int start = 0;
        int end = uri.indexOf( ':' );
        if ( end == -1 )
            throw new MalformedURLException("Malformed uri for module source (cannot find scheme) : " + uri);

        String scheme = uri.substring( start, end );
        if ( !SCHEME.equals( scheme ) )
            throw new MalformedURLException("Malformed uri for a module source : " + uri);

        setScheme( scheme );

        // Attribute type
        start = end + 1;
        end = uri.indexOf( ':', start );
        if ( end == -1 ) {
            throw new MalformedURLException("Malformed uri for module source (cannot find attribute type) : " + uri);
        }
        this.attributeType = uri.substring( start, end );

        // Attribute name
        start = end + 1;
        end = uri.indexOf( '#', start );

        if ( end == -1 )
            end = uri.length();

        if ( end == start )
            throw new MalformedURLException("Malformed uri for module source (cannot find attribute name) : " + uri);

        this.attributeName = uri.substring( start, end );

        // xpath
        start = end + 1;
        this.xPath = start < uri.length() ? uri.substring( start ) : "";
    }
17237#/**
     * Return an <code>InputStream</code> object to read from the source.
     *
     * @throws IOException if I/O error occured.
     */
    public InputStream getInputStream() throws IOException {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug("Getting InputStream for " + getURI());
        }

        Object obj = getInputAttribute( this.attributeType, this.attributeName );
        if ( obj == null )
            throw new SourceException( " The attribute: " + this.attributeName +
                                       " is empty" );

        if ( !(this.xPath.length() == 0 || this.xPath.equals( "/" )) ) {
            JXPathContext context = JXPathContext.newContext( obj );
            obj = context.getValue( this.xPath );

            if ( obj == null )
                throw new SourceException( "the xpath: " + this.xPath +
                                           " applied on the attribute: " +
                                           this.attributeName +
                                           " returns null");
        }

        if ( obj instanceof InputStream ) {
            return (InputStream)obj;
        } else if ( obj instanceof Source ) {
            return ((Source)obj).getInputStream();
        } else if ( obj instanceof String ) {
            return new ByteArrayInputStream( ((String)obj).getBytes() );
        } else if (obj instanceof byte[]) {
            return new ByteArrayInputStream((byte[]) obj);
        } else {
            throw new SourceException( "The object type: " + obj.getClass() +
                                       " could not be serialized as a InputStream " + obj );
        }
    }
17238#/**
     * Does this source actually exist ?
     *
     * @return true if the resource exists.
     *
     */
    public boolean exists() {
        boolean exists;
        try {
            exists = getInputAttribute(this.attributeType, this.attributeName) != null;
        } catch (SourceException e) {
            exists = false;
        }
        return exists;
    }
17239#private Object getInputAttribute( String inputModuleName, String attributeName )
    throws  SourceException {
        Object obj;

        ServiceSelector selector = null;
        InputModule inputModule = null;
        try {
            selector = (ServiceSelector) this.manager.lookup( InputModule.ROLE + "Selector" );
            inputModule = (InputModule) selector.select( inputModuleName );
            obj = inputModule.getAttribute( attributeName, null, this.objectModel );

        } catch (ServiceException e) {
            throw new SourceException("Could not find an InputModule of the type " +
                                      inputModuleName, e);
        } catch (ConfigurationException e) {
            throw new SourceException("Could not find an attribute: " + attributeName +
                                      " from the InputModule " + inputModuleName, e);
        } finally {
            if (inputModule != null) {
                selector.release(inputModule);
            }
            this.manager.release(selector);
        }

        return obj;
    }
17240#/**
     * Create a xmodule source from a 'xmodule:' uri and a the object model.
     * <p>The uri is of the form "xmodule:/attribute-type/attribute-name/xpath</p>
     */
    public XModuleSource(Map objectModel, String uri, ServiceManager manager)
    throws MalformedURLException {

        this.objectModel = objectModel;
        this.manager = manager;

        setSystemId( uri );

        // Scheme
        int start = 0;
        int end = uri.indexOf( ':' );
        if ( end == -1 )
            throw new MalformedURLException("Malformed uri for xmodule source (cannot find scheme) : " + uri);

        String scheme = uri.substring( start, end );
        if ( !SCHEME.equals( scheme ) )
            throw new MalformedURLException("Malformed uri for a xmodule source : " + uri);

        setScheme( scheme );

        // Attribute type
        start = end + 1;
        end = uri.indexOf( ':', start );
        if ( end == -1 ) {
            throw new MalformedURLException("Malformed uri for xmodule source (cannot find attribute type) : " + uri);
        }
        this.attributeType = uri.substring( start, end );

        // Attribute name
        start = end + 1;
        end = uri.indexOf( '#', start );

        if ( end == -1 )
            end = uri.length();

        if ( end == start )
            throw new MalformedURLException("Malformed uri for xmodule source (cannot find attribute name) : " + uri);

        this.attributeName = uri.substring( start, end );

        // xpath
        start = end + 1;
        this.xPath = start < uri.length() ? uri.substring( start ) : "";
    }
17241#/**
     * Implement this method to obtain SAX events.
     *
     */

    public void toSAX(ContentHandler handler)
        throws SAXException {

        Object obj = getInputAttribute( this.attributeType, this.attributeName );
        if ( obj == null )
            throw new SAXException( " The attribute: " + this.attributeName +
                                    " is empty" );

        if ( !(this.xPath.length() == 0 || this.xPath.equals( "/" )) ) {
            JXPathContext context = JXPathContext.newContext( obj );

            obj = context.getPointer( this.xPath ).getNode();

            if ( obj == null )
                throw new SAXException( "the xpath: " + this.xPath +
                                        " applied on the attribute: " +
                                        this.attributeName +
                                        " returns null");
        }

        if ( obj instanceof Document ) {
            DOMStreamer domStreamer = new DOMStreamer( handler );
            domStreamer.stream( (Document)obj );
        } else if ( obj instanceof Node ) {
            DOMStreamer domStreamer = new DOMStreamer( handler );
            handler.startDocument();
            domStreamer.stream( (Node)obj );
            handler.endDocument();
        } else if ( obj instanceof XMLizable ) {
            ((XMLizable)obj).toSAX( handler );
        } else {
            throw new SAXException( "The object type: " + obj.getClass() +
                                    " could not be serialized to XML: " + obj );
        }
    }
17242#/**
     * Return an <code>InputStream</code> object to read from the source.
     *
     * @throws IOException if I/O error occured.
     */
    public InputStream getInputStream() throws IOException {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug("Getting InputStream for " + getURI());
        }

        // Serialize the SAX events to the XMLSerializer
        ByteArrayInputStream inputStream = null;

        ServiceSelector selector = null;
        Serializer serializer = null;
        try {
            selector = (ServiceSelector)this.manager.lookup(Serializer.ROLE + "Selector");
            serializer = (Serializer)selector.select(this.configuredSerializerName);

            ByteArrayOutputStream outputStream = new ByteArrayOutputStream(2048);
            serializer.setOutputStream(outputStream);
            toSAX(serializer);
            inputStream = new ByteArrayInputStream(outputStream.toByteArray());
        } catch (SAXException e) {
            throw new SourceException("Serializing SAX to a ByteArray failed!", e);
        } catch (ServiceException e) {
            throw new SourceException("Retrieving serializer failed.", e);
        } finally {
            if (selector != null) {
                selector.release(serializer);
                this.manager.release(selector);
            }
        }
        return inputStream;
    }
17243#/**
     * Does this source actually exist ?
     *
     * @return true if the resource exists.
     *
     */
    public boolean exists() {
        boolean exists;
        try {
            exists = getInputAttribute(this.attributeType, this.attributeName) != null;
        } catch (SAXException e) {
            exists = false;
        }
        return exists;
    }
17244#/**
     * Get an <code>InputStream</code> where raw bytes can be written to.
     * The signification of these bytes is implementation-dependent and
     * is not restricted to a serialized XML document.
     *
     * @return a stream to write to
     */ 
    public OutputStream getOutputStream() throws IOException {
        return new DOMOutputStream();
    }
17245#/**
     * Delete the source 
     */
    public void delete() throws SourceException {
        if (!(this.xPath.length() == 0 || this.xPath.equals("/"))) {
            Object value;
            try {
                value = getInputAttribute(this.attributeType, this.attributeName);
            } catch (SAXException e) {
                throw new SourceException("delete: ", e);
            }
            if (value == null)
                throw new SourceException(" The attribute: " + this.attributeName +
                                          " is empty");

            JXPathContext context = JXPathContext.newContext(value);
            context.removeAll(this.xPath);
        } else {
            try {
                setOutputAttribute(this.attributeType, this.attributeName, null);
            } catch (SAXException e) {
                throw new SourceException("delete: ", e);
            }
        }
    }
17246#/**
     * FIXME
     * delete is an operator in java script, this method is for
     * testing puposes in java script only
     */
    public void deleteTest() throws SourceException {
        delete();
    }
17247#/**
     * Can the data sent to an <code>OutputStream</code> returned by
     * {@link #getOutputStream()} be cancelled ?
     *
     * @return true if the stream can be cancelled
     */
    public boolean canCancel( OutputStream stream ) { return false; }
17248#/**
     * Cancel the data sent to an <code>OutputStream</code> returned by
     * {@link #getOutputStream()}.
     * <p>
     * After cancel, the stream should no more be used.
     */
    public void cancel(OutputStream stream) throws IOException {}
17249#/**
     * Get a <code>ContentHandler</code> where an XML document can
     * be written using SAX events.
     * <p>
     * Care should be taken that the returned handler can actually
     * be a {@link org.apache.cocoon.xml.XMLConsumer} supporting also
     * lexical events such as comments.
     *
     * @return a handler for SAX events
     */
    public ContentHandler getContentHandler() {
        return new DOMBuilder( this );
    }
17250#public void notify( Document insertDoc ) throws SAXException {

        // handle xpaths, we are only handling inserts, i.e. if there is no
        // attribute of the given name and type the operation will fail
        if ( !(this.xPath.length() == 0 || this.xPath.equals( "/" )) ) {

            Object value = getInputAttribute( this.attributeType, this.attributeName );
            if ( value == null )
                throw new SAXException( " The attribute: " + this.attributeName +
                                        " is empty" );

            JXPathContext context = JXPathContext.newContext( value );

            if ( value instanceof Document ) {
                // If the attribute contains a dom document we
                // create the elements in the given xpath if
                // necesary, import the input document and put it
                // in the place described by the xpath.
                Document doc = (Document)value;
                
                Node importedNode =
                    doc.importNode( insertDoc.getDocumentElement(), true );
                
                context.setLenient( true );
                context.setFactory( new DOMFactory() );
                context.createPathAndSetValue( this.xPath, importedNode );
            } else {
                // Otherwise just try to put a the input document in
                // the place pointed to by the xpath
                context.setValue( this.xPath, insertDoc );
            }
                    
        } else {
            setOutputAttribute( this.attributeType, this.attributeName, insertDoc );
        }
    }
17251#private Object getInputAttribute( String inputModuleName, String attributeName )
        throws SAXException {
        Object obj;
        ServiceSelector selector = null;
        InputModule inputModule = null;
        try {
            selector = (ServiceSelector) this.manager.lookup( InputModule.ROLE + "Selector" );
            inputModule = (InputModule) selector.select( inputModuleName );
            obj = inputModule.getAttribute( attributeName, null, this.objectModel );

        } catch ( ServiceException e ) {
            throw new SAXException( "Could not find an InputModule of the type " + 
                                    inputModuleName , e );
        } catch ( ConfigurationException e ) {
            throw new SAXException( "Could not find an attribute: " + attributeName +
                                    " from the InputModule " + inputModuleName, e );
        } finally {
            if ( selector != null ) {
                selector.release( inputModule );
                this.manager.release( selector );
            }
        }

        return obj;
    }
17252#private void setOutputAttribute( String outputModuleName,
                                     String attributeName, Object value )
        throws SAXException{
        ServiceSelector selector = null;
        OutputModule outputModule = null;
        try {
            selector = (ServiceSelector) this.manager.lookup( OutputModule.ROLE + "Selector" );
            outputModule = (OutputModule) selector.select( outputModuleName );
            outputModule.setAttribute( null, this.objectModel, attributeName, value );
            outputModule.commit( null, this.objectModel );

        } catch ( ServiceException e ) {
            throw new SAXException( "Could not find an OutputModule of the type " + 
                                    outputModuleName , e );
        } finally {
            if ( selector != null ) {
                selector.release( outputModule );
                this.manager.release( selector );
            }
        }
    }
17253#public void close() throws IOException {
            SAXParser parser = null;
            try {
                parser = (SAXParser)XModuleSource.this.manager.lookup( SAXParser.ROLE );

                parser.parse( new InputSource( new ByteArrayInputStream( super.toByteArray() ) ),
                              XModuleSource.this.getContentHandler());
            } catch (Exception e){
                throw new IOException("Exception during processing of " +
                                       XModuleSource.this.getURI() +
                                       e.getMessage());
            } finally {
                if (parser != null) XModuleSource.this.manager.release( parser );
            }
            super.close();
        }
17254#/**
     * @see org.apache.avalon.framework.context.Contextualizable#contextualize(org.apache.avalon.framework.context.Context)
     */
    public void contextualize(Context avalonContext) throws ContextException {
        this.context = avalonContext;
    }
17255#/**
     * @see org.apache.avalon.framework.configuration.Configurable#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration configuration) throws ConfigurationException {
        this.showContinuations = configuration.getChild("show-continuations").getValueAsBoolean(true);
        this.showLibrary = configuration.getChild("show-libraries").getValueAsBoolean(true);
    }
17256#/**
     * Set the current <code>ServiceManager</code> instance used by this
     * <code>Serviceable</code>.
     * Need to get statistics about cache hits
     */
    public void service(ServiceManager serviceManager) throws ServiceException {
        super.service(serviceManager);
        this.settings = (Settings) this.manager.lookup(Settings.ROLE);

        if (this.manager.hasService(StoreJanitor.ROLE)) {
            this.storeJanitor = (StoreJanitor) manager.lookup(StoreJanitor.ROLE);
        } else {
            getLogger().info("StoreJanitor is not available. Sorry, no cache statistics");
        }

        if (this.manager.hasService(Store.ROLE)) {
            this.store = (Store) this.manager.lookup(Store.ROLE);
        } else {
            getLogger().info("Store is not available. Sorry no cache statistics about it.");
        }
        
        if (this.manager.hasService(Store.PERSISTENT_STORE)) {
            this.storePersistent = (Store) this.manager.lookup(Store.PERSISTENT_STORE);
        } else {
            getLogger().info("Persistent Store is not available. Sorry no cache statistics about it.");
        }

        if(this.manager.hasService(ContinuationsManager.ROLE)) {
            continuationsManager = (ContinuationsManager) this.manager.lookup(ContinuationsManager.ROLE);
        } else {
            getLogger().info("ContinuationsManager is not available. Sorry no overview of created continuations");
        }
    }
17257#public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        super.setup(resolver, objectModel, src, par);

        if (this.showLibrary) {
            try {
                this.libDirectory = super.resolver.resolveURI("context://WEB-INF/lib");
            } catch (SourceException e) {
                throw SourceUtil.handle(e);
            }
        }
    }
17258#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        if (this.manager != null) {
            this.manager.release(this.settings);
            this.manager.release(this.storePersistent);
            this.manager.release(this.storeJanitor);
            this.manager.release(this.continuationsManager);
            this.settings = null;
            this.storePersistent = null;
            this.store = null;
            this.storeJanitor = null;
            this.continuationsManager = null;
        }

        if (this.libDirectory != null) {
            super.resolver.release(this.libDirectory);
            this.libDirectory = null;
        }

        super.dispose();
    }
17259#/**
     * Generate the status information in XML format.
     * @throws SAXException
     *         when there is a problem creating the output SAX events.
     */
    public void generate() throws SAXException, ProcessingException {

        // Start the document and set the namespace.
        super.contentHandler.startDocument();
        super.contentHandler.startPrefixMapping("", NAMESPACE);
        super.contentHandler.startPrefixMapping(XLINK_PREFIX, XLINK_NS);

        genStatus();

        // End the document.
        super.contentHandler.endPrefixMapping(XLINK_PREFIX);
        super.contentHandler.endPrefixMapping("");
        super.contentHandler.endDocument();
    }
17260#/**
     * Generate the main status document.
     */
    private void genStatus() throws SAXException, ProcessingException {
        // Root element.

        // The current date and time.
        String dateTime = DateFormat.getDateTimeInstance().format(new Date());
        String localHost;

        // The local host.
        try {
            localHost = InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException e) {
            getLogger().debug("StatusGenerator:UnknownHost", e);
            localHost = "";
        } catch (SecurityException e) {
            getLogger().debug("StatusGenerator:Security", e);
            localHost = "";
        }

        AttributesImpl atts = new AttributesImpl();
        atts.addCDATAAttribute(NAMESPACE, "date", dateTime);
        atts.addCDATAAttribute(NAMESPACE, "host", localHost);
        atts.addCDATAAttribute(NAMESPACE, "cocoon-version", Constants.VERSION);
        dateTime = DateFormat.getDateTimeInstance().format(new Date(this.settings.getCreationTime()));
        atts.addCDATAAttribute(NAMESPACE, "creation-time", dateTime);
        super.contentHandler.startElement(NAMESPACE, "statusinfo", "statusinfo", atts);

        if (this.showContinuations) {
            genContinuationsTree();
        }
        genSettings();
        genVMStatus();
        genBeans();
        genProperties();
        if (this.showLibrary) {
            genLibrarylist();
        }

        // End root element.
        super.contentHandler.endElement(NAMESPACE, "statusinfo", "statusinfo");
    }
17261#private void genBeans() throws SAXException {
        startGroup("Spring Beans");
        
        Stack acStack = new Stack();

        // get the hierarchy of Spring ApplicationContexts (BeanFactories)
        {
            ApplicationContext appContext =
                WebAppContextUtils.getCurrentWebApplicationContext();
            
            acStack.push(appContext);
            
            while (appContext.getParent() != null) {
                appContext = appContext.getParent();
                acStack.push(appContext);
            }
        }
        
        int index = 0;
        final int total = acStack.size();
        
        while (acStack.size() > 0) {
            ApplicationContext ac = (ApplicationContext) acStack.pop();
            
            String acName;
            if (index == (total-2)) {
                acName = "Global ApplicationContext (" + ac.getDisplayName() + ")";
            } else if (index == (total-1)) {
                acName = "Sitemap ApplicationContext (" + ac.getDisplayName() + ")";                
            } else {
                acName = ac.getDisplayName();
            }

            List values = new ArrayList();
            String[] names = ac.getBeanDefinitionNames();
            for (int i=0,iEnd=names.length; i < iEnd; i++) {
                String name = names[i];
                Class type = ac.getType(name);
                if (type == null) {
                    values.add(name + " => ???");
                } else {
                    values.add(name + " => " + ac.getType(name).getName());
                }
            }
            addMultilineValue(acName, values);
            
            index++;
        }
        
        endGroup();
    }
17262#private void genContinuationsTree() throws SAXException {
        startGroup("Continuations");
        List continuationsAsDataBeansList = this.continuationsManager.getWebContinuationsDataBeanList();
        for (Iterator i = continuationsAsDataBeansList.iterator(); i.hasNext();) {
            displayContinuation((WebContinuationDataBean) i.next());
        }
        endGroup();
    }
17263#private void displayContinuation(WebContinuationDataBean wc) throws SAXException {
        AttributesImpl ai = new AttributesImpl();
        ai.addAttribute(NAMESPACE, "id", "id", "CDATA", wc.getId());
        ai.addAttribute(NAMESPACE, "interpreter", "interpreter", "CDATA", wc.getInterpreterId());
        ai.addAttribute(NAMESPACE, "expire-time", "expire-time", "CDATA", wc.getExpireTime());
        ai.addAttribute(NAMESPACE, "time-to-live", "time-to-live", "CDATA", wc.getTimeToLive());
        ai.addAttribute(NAMESPACE, "last-access-time", "last-access-time", "CDATA", wc.getLastAccessTime());

        super.contentHandler.startElement(NAMESPACE, "cont", "cont", ai);
        List children = wc.get_children();
        for (int i = 0; i < children.size(); i++) {
            displayContinuation((WebContinuationDataBean) children.get(i));
        }
        super.contentHandler.endElement(NAMESPACE, "cont", "cont");
    }
17264#private void genVMStatus() throws SAXException {
        AttributesImpl atts = new AttributesImpl();
        startGroup("VM");

        // BEGIN ClassPath
        String classpath = SystemUtils.JAVA_CLASS_PATH;
        if (classpath != null) {
            List paths = new ArrayList();
            StringTokenizer tokenizer = new StringTokenizer(classpath, SystemUtils.PATH_SEPARATOR);
            while (tokenizer.hasMoreTokens()) {
                paths.add(tokenizer.nextToken());
            }
            addMultilineValue("classpath", paths);
        }
        // END ClassPath

        // BEGIN Memory status
        startGroup("Memory");
        final long totalMemory = Runtime.getRuntime().totalMemory();
        final long freeMemory = Runtime.getRuntime().freeMemory();
        addValue("total", String.valueOf(totalMemory));
        addValue("used", String.valueOf(totalMemory - freeMemory));
        addValue("free", String.valueOf(freeMemory));
        endGroup();
        // END Memory status

        // BEGIN JRE
        startGroup("JRE");
        addValue("version", SystemUtils.JAVA_VERSION);
        atts.clear();
        // qName = prefix + ':' + localName
        atts.addAttribute(XLINK_NS, "type", XLINK_PREFIX + ":type", "CDATA", "simple");
        atts.addAttribute(XLINK_NS, "href", XLINK_PREFIX + ":href", "CDATA", SystemUtils.JAVA_VENDOR_URL);
        addValue("java-vendor", SystemUtils.JAVA_VENDOR, atts);
        endGroup();
        // END JRE

        // BEGIN Operating system
        startGroup("Operating System");
        addValue("name", SystemUtils.OS_NAME);
        addValue("architecture", SystemUtils.OS_ARCH);
        addValue("version", SystemUtils.OS_VERSION);
        endGroup();
        // END operating system

        // BEGIN Cache
        if (this.storeJanitor != null) {
            startGroup("Store Janitor");

            // For each element in StoreJanitor
            Iterator i = this.storeJanitor.iterator();
            while (i.hasNext()) {
                Store store = (Store) i.next();
                startGroup(store.getClass().getName() + " (hash = 0x" + Integer.toHexString(store.hashCode()) + ")" );
                int size = 0;
                int empty = 0;
                atts.clear();
                atts.addAttribute(NAMESPACE, "name", "name", "CDATA", "cached");
                super.contentHandler.startElement(NAMESPACE, "value", "value", atts);

                atts.clear();
                Enumeration e = store.keys();
                while (e.hasMoreElements()) {
                    size++;
                    Object key = e.nextElement();
                    Object val = store.get(key);
                    String line;
                    if (val == null) {
                        empty++;
                    } else {
                        line = key + " (class: " + val.getClass().getName() + ")";
                        super.contentHandler.startElement(NAMESPACE, "line", "line", atts);
                        super.contentHandler.characters(line.toCharArray(), 0, line.length());
                        super.contentHandler.endElement(NAMESPACE, "line", "line");
                    }
                }
                if (size == 0) {
                    super.contentHandler.startElement(NAMESPACE, "line", "line", atts);
                    String value = "[empty]";
                    super.contentHandler.characters(value.toCharArray(), 0, value.length());
                    super.contentHandler.endElement(NAMESPACE, "line", "line");
                }
                super.contentHandler.endElement(NAMESPACE, "value", "value");

                addValue("size", String.valueOf(size) + " items in cache (" + empty + " are empty)");
                endGroup();
            }
            endGroup();
        }
        
        if (this.store != null) {
            genStore(this.store);
        }

        if (this.storePersistent != null) {
            genStore(this.storePersistent);
        }
        // END Cache

        endGroup();
    }
17265#private void genStore(Store store) throws SAXException {
        AttributesImpl atts = new AttributesImpl();
        startGroup(store.getClass().getName() + " (hash = 0x" + Integer.toHexString(store.hashCode()) + ")");
        int size = 0;
        int empty = 0;
        atts.clear();
        atts.addAttribute(NAMESPACE, "name", "name", "CDATA", "cached");
        super.contentHandler.startElement(NAMESPACE, "value", "value", atts);

        atts.clear();
        Enumeration e = store.keys();
        while (e.hasMoreElements()) {
            size++;
            Object key = e.nextElement();
            Object val = store.get(key);
            String line;
            if (val == null) {
                empty++;
            } else {
                line = key + " (class: " + val.getClass().getName() + ")";
                super.contentHandler.startElement(NAMESPACE, "line", "line", atts);
                super.contentHandler.characters(line.toCharArray(), 0, line.length());
                super.contentHandler.endElement(NAMESPACE, "line", "line");
            }
        }
        if (size == 0) {
            super.contentHandler.startElement(NAMESPACE, "line", "line", atts);
            String value = "[empty]";
            super.contentHandler.characters(value.toCharArray(), 0, value.length());
            super.contentHandler.endElement(NAMESPACE, "line", "line");
        }
        super.contentHandler.endElement(NAMESPACE, "value", "value");

        addValue("size", size + " items in cache (" + empty + " are empty)");
        endGroup();
    }
17266#private void genSettings() throws SAXException {
        final Settings s = this.settings;
        this.startGroup("Base Settings");

        this.addValue("Running mode", s.getRunningMode());
        this.addMultilineValue(Settings.KEY_LOAD_CLASSES, s.getLoadClasses());
        this.addValue(Settings.KEY_CACHE_DIRECTORY, s.getCacheDirectory());
        this.addValue(Settings.KEY_WORK_DIRECTORY, s.getWorkDirectory());
        this.addValue(Settings.KEY_FORM_ENCODING, s.getFormEncoding());
        this.addValue(Settings.KEY_CONTAINER_ENCODING, s.getContainerEncoding());

        this.endGroup();

        this.startGroup("Dynamic Settings");

        this.addValue(Settings.KEY_RELOADING, s.isReloadingEnabled(null));
        this.addValue(Settings.KEY_RELOAD_DELAY, s.getReloadDelay(null));
        Iterator i = s.getPropertyNames("org.apache.cocoon." + Settings.KEY_RELOADING + '.').iterator();
        while ( i.hasNext() ) {
            final String key = (String)i.next();
            final String value = s.getProperty(key);
            this.addValue(key.substring(18), value);
        }
        i = s.getPropertyNames("org.apache.cocoon." + Settings.KEY_RELOAD_DELAY + '.').iterator();
        while ( i.hasNext() ) {
            final String key = (String)i.next();
            final String value = s.getProperty(key);
            this.addValue(key.substring(18), value);
        }

        this.endGroup();
    }
17267#private void genProperties() throws SAXException {
        this.startGroup("System-Properties");
        final Properties p = System.getProperties();
        final Enumeration e = p.keys();
        while ( e.hasMoreElements() ) {
            final String key = (String)e.nextElement();
            final String value = p.getProperty(key);
            this.addValue(key, value);
        }
        this.endGroup();
    }
17268#private void genLibrarylist() throws SAXException,ProcessingException {
        try {
            if (this.libDirectory instanceof TraversableSource) {
                startGroup("WEB-INF/lib");

                Set files = new TreeSet();
                Collection kids = ((TraversableSource) this.libDirectory).getChildren();
                try {
                    for (Iterator i = kids.iterator(); i.hasNext(); ) {
                        final Source lib = (Source) i.next();
                        final String name = lib.getURI().substring(lib.getURI().lastIndexOf('/') + 1);
                        files.add(name);
                    }
                } finally {
                    for (Iterator i = kids.iterator(); i.hasNext(); ) {
                        final Source lib = (Source) i.next();
                        super.resolver.release(lib);
                    }
                }

                for (Iterator i = files.iterator(); i.hasNext(); ) {
                    addValue("file", (String) i.next());
                }

                endGroup();
            }
        } catch (SourceException e) {
            throw new ResourceNotFoundException("Could not read directory", e);
        }
    }
17269#/** Utility function to begin a <code>group</code> tag pair. */
    private void startGroup(String name) throws SAXException {
        startGroup(name, null);
    }
17270#/** Utility function to begin a <code>group</code> tag pair with added attributes. */
    private void startGroup(String name, Attributes atts)
    throws SAXException {
        AttributesImpl ai = (atts == null) ? new AttributesImpl() : new AttributesImpl(atts);
        ai.addAttribute(NAMESPACE, "name", "name", "CDATA", name);
        super.contentHandler.startElement(NAMESPACE, "group", "group", ai);
    }
17271#/** Utility function to end a <code>group</code> tag pair. */
    private void endGroup() throws SAXException {
        super.contentHandler.endElement(NAMESPACE, "group", "group");
    }
17272#/** Utility function to begin and end a <code>value</code> tag pair. */
    private void addValue(String name, String value)
    throws SAXException {
        addValue(name, value, null);
    }
17273#/** Utility function to begin and end a <code>value</code> tag pair. */
    private void addValue(String name, boolean value) throws SAXException {
        addValue(name, String.valueOf(value), null);
    }
17274#/** Utility function to begin and end a <code>value</code> tag pair. */
    private void addValue(String name, long value) throws SAXException {
        addValue(name, String.valueOf(value), null);
    }
17275#/** Utility function to begin and end a <code>value</code> tag pair with added attributes. */
    private void addValue(String name, String value, Attributes atts)
    throws SAXException {
        AttributesImpl ai = (atts == null) ? new AttributesImpl() : new AttributesImpl(atts);
        ai.addAttribute(NAMESPACE, "name", "name", "CDATA", name);
        super.contentHandler.startElement(NAMESPACE, "value", "value", ai);
        super.contentHandler.startElement(NAMESPACE, "line", "line", XMLUtils.EMPTY_ATTRIBUTES);

        if (value != null) {
            super.contentHandler.characters(value.toCharArray(), 0, value.length());
        }

        super.contentHandler.endElement(NAMESPACE, "line", "line");
        super.contentHandler.endElement(NAMESPACE, "value", "value");
    }
17276#/** Utility function to begin and end a <code>value</code> tag pair. */
    private void addMultilineValue(String name, List values)
    throws SAXException {
        addMultilineValue(name, values, null);
    }
17277#/** Utility function to begin and end a <code>value</code> tag pair with added attributes. */
    private void addMultilineValue(String name, List values, Attributes atts)
    throws SAXException {
        AttributesImpl ai = (atts == null) ? new AttributesImpl() : new AttributesImpl(atts);
        ai.addAttribute(NAMESPACE, "name", "name", "CDATA", name);
        super.contentHandler.startElement(NAMESPACE, "value", "value", ai);

        for (int i = 0; i < values.size(); i++) {
            String value = (String) values.get(i);
            if (value != null) {
                super.contentHandler.startElement(NAMESPACE, "line", "line", XMLUtils.EMPTY_ATTRIBUTES);
                super.contentHandler.characters(value.toCharArray(), 0, value.length());
                super.contentHandler.endElement(NAMESPACE, "line", "line");
            }
        }
        super.contentHandler.endElement(NAMESPACE, "value", "value");
    }
17278#protected String getMatchString(Map objectModel, Parameters parameters) {
        return ObjectModelHelper.getRequest(objectModel).getHeader("Host");
    }
17279#public void configure(Configuration config) throws ConfigurationException {
        this.defaultParam = config.getChild("attribute-name").getValue(null);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Default attribute-name is = '" + this.defaultParam + "'");
        }
    }
17280#protected String getMatchString(Map objectModel, Parameters parameters) {

        String paramName = parameters.getParameter("attribute-name", this.defaultParam);
        if (paramName == null) {
            getLogger().warn("No attribute name given. FAILING");
            return null;
        }

        Object result = ObjectModelHelper.getRequest(objectModel).getAttribute(paramName);
        if (result == null) {
            getLogger().debug("Request attribute '" + paramName + "' not set.");
            return null;
        }

        return result.toString();
    }
17281#public void configure(Configuration config) throws ConfigurationException {
        this.defaultParam = config.getChild("parameter-name").getValue(null);
    }
17282#protected String getMatchString(Map objectModel, Parameters parameters) {

        String paramName = parameters.getParameter("parameter-name", this.defaultParam);
        if (paramName == null) {
            getLogger().warn("No parameter name given. FAILING");
            return null;
        }

        String result = parameters.getParameter(paramName, null);
        if (result == null) {
            getLogger().debug("Parameter '" + paramName + "' not set.");
        }

        return result;
    }
17283#public void configure(Configuration config) throws ConfigurationException {
        this.defaultParam = config.getChild("parameter-name").getValue(null);
    }
17284#protected String getMatchString(Map objectModel, Parameters parameters) {

        String paramName = parameters.getParameter("parameter-name", this.defaultParam);
        if (paramName == null) {
            getLogger().warn("No parameter name given. FAILING");
            return null;
        }

        String result = ObjectModelHelper.getRequest(objectModel).getParameter(paramName);
        if (result == null) {
            getLogger().debug("Parameter '" + paramName + "' not set.");
        }

        return result;
    }
17285#/**
     * Match method to see if the request attribute exists. If it does
     * have a value the string represenation of attribute is added to
     * the array list for later sitemap substitution.
     *
     * @param pattern name of request attribute to find
     * @param objectModel environment passed through via cocoon
     * @return null or map containing value of request attribute 'pattern'
     */
    public Map match(String pattern, Map objectModel, Parameters parameters) {

        Object attribute = ObjectModelHelper.getRequest(objectModel).getAttribute(pattern);

        if (attribute == null) {
            return null;
        } else {
            Map map = new HashMap();
            map.put("1", attribute.toString());
            return map;
        }
    }
17286#public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
        this.resolver = (SourceResolver) this.manager.lookup(SourceResolver.ROLE);
    }
17287#public void parameterize(Parameters params) throws ParameterException {
        this.ignoreMissingTables = params.getParameterAsBoolean("ignore-missing-tables", false);
    }
17288#private Map getMountTable(String src) throws Exception {
        Source source = null;
        try {
            source = this.resolver.resolveURI(src);
            final String uri = source.getURI();

            // Check if source exists
            // FIXME: source.exists() returns true in the case of an OSGI bundle uri,
            // For example if uri=bundle://11/../mount-table.xml, exists() returns true
            // but the Source is unusable
            if (!source.exists()) {
                if (this.ignoreMissingTables) {
                    return Collections.EMPTY_MAP;
                } else {
                    throw new PatternException("Mount table does not exist: '" + uri + "'");
                }
            }

            // Source exists
            Object[] values = (Object[]) this.mountTables.get(uri);
            if (values != null) {
                // Check validity
                SourceValidity oldValidity = (SourceValidity) values[1];

                int valid = oldValidity != null ? oldValidity.isValid() : SourceValidity.INVALID;
                if (valid == SourceValidity.VALID) {
                    // Valid without needing the new validity
                    return (Map) values[0];
                }

                if (valid == SourceValidity.UNKNOWN &&
                        oldValidity.isValid(source.getValidity()) == SourceValidity.VALID) {
                    // Valid after comparing with the new validity
                    return (Map) values[0];
                }

                // Invalid: fallback below to read the mount table
            } else {
                values = new Object[2];
            }

            // Read the mount table
            Map mounts = new HashMap();
            DefaultConfigurationBuilder builder = new DefaultConfigurationBuilder();
            Configuration config = builder.build(SourceUtil.getInputSource(source));

            Configuration[] children = config.getChildren();
            for (int i = 0; i < children.length; i++) {
                Configuration child = children[i];
                if ("mount".equals(child.getName())) {
                    String prefix = children[i].getAttribute("uri-prefix");
                    // Append a '/' at the end of a not-empty prefix
                    // this avoids flat uri matching which would cause
                    // exceptions in the sub sitemap!
                    if (!prefix.endsWith("/") && prefix.length() != 0) {
                        prefix = prefix + '/';
                    }
                    mounts.put(prefix, children[i].getAttribute("src"));
                } else {
                    throw new PatternException(
                        "Unexpected element '" + child.getName() + "' (awaiting 'mount'), at " + child.getLocation());
                }
            }
            values[0] = mounts;
            values[1] = source.getValidity();

            // Cache it with the source validity
            this.mountTables.put(uri, values);

            return mounts;

        } catch (SecurityException e) {
            if (this.ignoreMissingTables) {
                return Collections.EMPTY_MAP;
            } else {
                throw new PatternException("Mount table is not accessible: '" + src + "' (" + e + ")");
            }

        } finally {
            if (source != null) {
                this.resolver.release(source);
            }
        }
    }
17289#public Map match(String pattern, Map objectModel, Parameters parameters) throws PatternException {
        Map mounts;
        try {
            mounts = getMountTable(pattern);
        } catch (PatternException pe) {
            throw pe;
        } catch (Exception e) {
            throw new PatternException(e);
        }

        // Get the request URI
        Request request = ObjectModelHelper.getRequest(objectModel);
        String uri = request.getSitemapURI();

        // and search for a matching prefix
        Iterator iter = mounts.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry entry = (Map.Entry) iter.next();
            String prefix = (String) entry.getKey();
            if (uri.startsWith(prefix)) {
                // Found it
                Map result = new HashMap(2);
                result.put("uri-prefix", prefix);
                result.put("src", entry.getValue());

                // Return immediately
                return result;
            }
        }

        // Not found
        return null;
    }
17290#public void configure(Configuration config) throws ConfigurationException {
        this.defaultParam = config.getChild("parameter-name").getValue(null);
    }
17291#protected String getMatchString(Map objectModel, Parameters parameters) {

        String paramName = parameters.getParameter("parameter-name", this.defaultParam);
        if (paramName == null) {
            getLogger().warn("No parameter name given. FAILING");
            return null;
        }

        String result = ObjectModelHelper.getRequest(objectModel).getParameter(paramName);
        if (result == null) {
            getLogger().debug("Parameter '" + paramName + "' not set.");
        }

        return result;
    }
17292#public void configure(Configuration config) throws ConfigurationException {

        this.defaultParam = config.getChild("header-name").getValue(null);
    }
17293#protected String getMatchString(Map objectModel, Parameters parameters) {

        String paramName = parameters.getParameter("header-name", this.defaultParam);
        if (paramName == null) {
            getLogger().warn("No header name given. FAILING");
            return null;
        }

        String result = ObjectModelHelper.getRequest(objectModel).getHeader(paramName);
        if (result == null) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Header '" + paramName + "' not set.");
            }
        }

        return result;
    }
17294#public void configure(Configuration config) throws ConfigurationException {
        this.defaultParam = config.getChild("parameter-name").getValue(null);
    }
17295#protected String getMatchString(Map objectModel, Parameters parameters) {

        String paramName = parameters.getParameter("parameter-name", this.defaultParam);
        if (paramName == null) {
            getLogger().warn("No parameter name given. FAILING");
            return null;
        }

        String value = parameters.getParameter(paramName, null);
        if (value == null) {
            getLogger().debug("Parameter '" + paramName + "' not set.");
        }

        return value;
    }
17296#/**
     * Return the request URI.
     */
    protected String getMatchString(Map objectModel, Parameters parameters) {
        String uri = ObjectModelHelper.getRequest(objectModel).getSitemapURI();

        if (uri.startsWith("/")) {
            uri = uri.substring(1);
        }

        return uri;
    }
17297#public void configure(Configuration config) throws ConfigurationException {
        this.defaultParam = config.getChild("attribute-name").getValue(null);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Default attribute-name is = '" + this.defaultParam + "'");
        }
    }
17298#protected String getMatchString(Map objectModel, Parameters parameters) {

        String paramName = parameters.getParameter("attribute-name", this.defaultParam);
        if (paramName == null) {
            getLogger().warn("No attribute name given. FAILING");
            return null;
        }

        Object result = ObjectModelHelper.getRequest(objectModel).getSession().getAttribute(paramName);
        if (result == null) {
            getLogger().debug("Session attribute '" + paramName + "' not set.");
            return null;
        }

        return result.toString();
    }
17299#public void configure(Configuration config) throws ConfigurationException {
        this.defaultParam = config.getChild("attribute-name").getValue(null);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Default attribute-name is = '" + this.defaultParam + "'");
        }
    }
17300#protected String getMatchString(Map objectModel, Parameters parameters) {

        String paramName = parameters.getParameter("attribute-name", this.defaultParam);
        if (paramName == null) {
            getLogger().warn("No attribute name given. FAILING");
            return null;
        }

        Object result = ObjectModelHelper.getRequest(objectModel).getAttribute(paramName);
        if (result == null) {
            getLogger().debug("Request attribute '" + paramName + "' not set.");
            return null;
        }

        return result.toString();
    }
17301#protected String getMatchString(Map objectModel, Parameters parameters) {
        return ObjectModelHelper.getRequest(objectModel).getHeader("Host");
    }
17302#/**
     * Match method to see if the request attribute exists. If it does
     * have a value the string represenation of attribute is added to
     * the array list for later sitemap substitution.
     *
     * @param pattern name of session attribute to find
     * @param objectModel environment passed through via cocoon
     * @return null or map containing value of session attribute 'pattern'
     */
    public Map match(String pattern, Map objectModel, Parameters parameters) {

        Object attribute = ObjectModelHelper.getRequest(objectModel).getSession().getAttribute(pattern);
        if (attribute == null) {
            return null;
        } else {
            Map map = new HashMap();
            map.put("1", attribute.toString());
            return map;
        }
    }
17303#/**
     * Match method to see if the request parameter exists. If it does
     * have a value the parameter is added to the array list for later
     * sitemap substitution.
     *
     * @param pattern name of request parameter to find
     * @param objectModel environment passed through via cocoon
     * @return null or map containing value of request parameter 'pattern'
     */
    public Map match(String pattern, Map objectModel, Parameters parameters) {
        Request request = ObjectModelHelper.getRequest(objectModel);

        String parameter = request.getParameter(pattern);
        if (parameter == null) {
            return null; // no parameter defined
        } else {
            Map map = new HashMap();
            map.put("1", parameter);
            return map; // parameter defined, return map
        }
    }
17304#/**
     * Match method to see if the request header exists. If it does
     * have a value the header added to the array list for later
     * sitemap substitution.
     *
     * @param pattern name of request header to find
     * @param objectModel environment passed through via cocoon
     * @return null or map containing value of request header 'pattern'
     */
    public Map match(String pattern, Map objectModel, Parameters parameters) {
        Request request = ObjectModelHelper.getRequest(objectModel);

        String value = request.getHeader(pattern);
        if (value == null) {
            return null; // no request header defined
        } else {
            Map map = new HashMap();
            map.put("1", value);
            return map; // request header defined, return map
        }
    }
17305#public void configure(Configuration config) throws ConfigurationException {
        this.defaultParam = config.getChild("attribute-name").getValue(null);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Default attribute-name is = '" + this.defaultParam + "'");
        }
    }
17306#protected String getMatchString(Map objectModel, Parameters parameters) {

        String paramName = parameters.getParameter("attribute-name", this.defaultParam);
        if (paramName == null) {
            getLogger().warn("No attribute name given. FAILING");
            return null;
        }

        Object result = ObjectModelHelper.getRequest(objectModel).getSession().getAttribute(paramName);
        if (result == null) {
            getLogger().debug("Session attribute '" + paramName + "' not set.");
            return null;
        }

        return result.toString();
    }
17307#/**
     * Return the request URI.
     */
    protected String getMatchString(Map objectModel, Parameters parameters) {
        String uri = ObjectModelHelper.getRequest(objectModel).getSitemapURI();

        if (uri.startsWith("/")) {
            uri = uri.substring(1);
        }

        return uri;
    }
17308#/**
     * Match method to see if the sitemap parameter exists. If it does
     * have a value the parameter added to the array list for later
     * sitemap substitution.
     *
     * @param pattern name of sitemap parameter to find
     * @param objectModel environment passed through via cocoon
     * @return null or map containing value of sitemap parameter 'pattern'
     */
    public Map match(String pattern, Map objectModel, Parameters parameters) {

        String parameter = parameters.getParameter(pattern, null);
        if (parameter == null) {
            return null; // no parameter defined
        } else {
            Map map = new HashMap();
            map.put("1", parameter);
            return map; // parameter defined, return map
        }
    }
17309#public Map match(String pattern, Map objectModel, Parameters parameters)
    throws PatternException {

        if (pattern == null) {
            throw new PatternException("No cookie name given.");
        }

        Request request = ObjectModelHelper.getRequest(objectModel);
        Cookie[] cookies = request.getCookies();
        HashMap result = null;

        if (cookies != null) {
            for (int i = 0; i < cookies.length; i++) {
                Cookie cookie = cookies[i];
                if (cookie.getName().equals(pattern)) {
                    result = new HashMap();
                    result.put("1", cookie.getValue());
                    break;
                }
            }
        }

        return result;
    }
17310#public void configure(Configuration config) throws ConfigurationException {
        // Check old name
        this.defaultParam = config.getChild("parameter-name").getValue(null);
        if (defaultParam != null) {
            getLogger().warn("'parameter-name' is deprecated. Please use 'header-name'");
        }
        // Load with new one
        this.defaultParam = config.getChild("header-name").getValue(this.defaultParam);
    }
17311#protected String getMatchString(Map objectModel, Parameters parameters) {

        // Check old name
        String paramName = parameters.getParameter("parameter-name", null);
        if (paramName != null) {
            getLogger().warn("'parameter-name' is deprecated. Please use 'header-name'");
        } else {
            paramName = this.defaultParam;
        }

        // Load with new one.
        paramName = parameters.getParameter("header-name", paramName);

        if (paramName == null) {
            getLogger().warn("No header name given. FAILING");
            return null;
        }

        String result = ObjectModelHelper.getRequest(objectModel).getHeader(paramName);
        if (result == null) {
            getLogger().debug("Header '" + paramName + "' not set.");
        }

        return result;
    }
17312#/* (non-Javadoc)
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager=manager;
    }
17313#public void configure(Configuration config) throws ConfigurationException {
        this.defaultParam = config.getChild("parameter-name").getValue(null);
        this.inputConf = config.getChild("input-module");
        this.defaultInput = this.inputConf.getAttribute("name",this.defaultInput);
    }
17314#protected String getMatchString(Map objectModel, Parameters parameters) {

        String paramName = parameters.getParameter("parameter-name", this.defaultParam);
        String inputName = parameters.getParameter("input-module", this.defaultInput);

        if (paramName == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No parameter name given. Trying to continue");
        }
        if (inputName == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }

        InputModule input = null;
        ServiceSelector inputSelector = null;
        Object result = null;

        // one could test whether the input module is ThreadSafe and
        // keep a reference for that instance. Then one would need
        // to implement Disposable in order to release it at EOL
        // That would probably speed up things a lot. Especially, since
        // matchers are invoked very often.
        // Perhaps a CachingWildcardMatcher ?

        try {
            // obtain input module
            inputSelector=(ServiceSelector) this.manager.lookup(INPUT_MODULE_SELECTOR); 
            if (inputSelector != null && inputSelector.isSelectable(inputName)) {
                input = (InputModule) inputSelector.select(inputName);
            }
            if (input != null) {
                result = input.getAttribute(paramName, this.inputConf, objectModel);
            }
        } catch (Exception e) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("A problem occurred acquiring Parameter '" + paramName 
                                 + "' from '" + inputName + "': " + e.getMessage());
        } finally {
            // release components
            if (inputSelector != null) {
                if (input != null)
                    inputSelector.release(input);
                this.manager.release(inputSelector);
            }
        }

        if (getLogger().isDebugEnabled())
            getLogger().debug(" using "+inputName+" obtained value "+result);

        if (result instanceof String) {
            return (String) result;
        } else {
            return result.toString();
        }
    }
17315#public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
17316#/* (non-Javadoc)
     * @see org.apache.avalon.framework.configuration.Configurable#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration config) throws ConfigurationException {
        this.defaultParam = config.getChild("parameter-name").getValue(null);
        this.inputConf = config.getChild("input-module");
        this.defaultInput = this.inputConf.getAttribute("name",this.defaultInput);
    }
17317#/* (non-Javadoc)
     * @see org.apache.avalon.framework.activity.Initializable#initialize()
     */
    public void initialize() {
        try {
            // obtain input module
            this.inputSelector=(ServiceSelector) this.manager.lookup(INPUT_MODULE_SELECTOR); 
            if (this.defaultInput != null && 
                this.inputSelector != null && 
                this.inputSelector.isSelectable(this.defaultInput)
                ){
                this.input = (InputModule) this.inputSelector.select(this.defaultInput);
                if (!(this.input instanceof ThreadSafe && this.inputSelector instanceof ThreadSafe) ) {
                    this.inputSelector.release(this.input);
                    this.manager.release(this.inputSelector);
                    this.input = null;
                    this.inputSelector = null;
                }
                this.initialized = true;
            } else {
                if (getLogger().isErrorEnabled())
                    getLogger().error("A problem occurred setting up '" + this.defaultInput 
                                      + "': Selector is "+(this.inputSelector!=null?"not ":"")
                                      +"null, Component is "
                                      +(this.inputSelector!=null&&this.inputSelector.isSelectable(this.defaultInput)?"known":"unknown"));
            }
        } catch (Exception e) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("A problem occurred setting up '" + this.defaultInput + "': " + e.getMessage());
        }
    }
17318#/* (non-Javadoc)
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        if (!this.initialized) 
            if (getLogger().isErrorEnabled()) 
                getLogger().error("Uninitialized Component! FAILING");
        else 
            if (this.inputSelector != null) {
                if (this.input != null)
                    this.inputSelector.release(this.input);
                this.manager.release(this.inputSelector);
            }
    }
17319#protected String getMatchString(Map objectModel, Parameters parameters) {

        String paramName = parameters.getParameter("parameter-name", this.defaultParam);
        String inputName = parameters.getParameter("input-module", this.defaultInput);

        if (!this.initialized) {
            if (getLogger().isErrorEnabled()) 
                getLogger().error("Uninitialized Component! FAILING");
            return null;
        }
        if (paramName == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No parameter name given. Trying to Continue");
        }
        if (inputName == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }

        Object result = null;

        if (this.input != null && inputName.equals(this.defaultInput)) {
            // input module is thread safe
            // thus we still have a reference to it
            try {
                if (this.input != null) {
                    result = this.input.getAttribute(paramName, this.inputConf, objectModel);
                }
            } catch (Exception e) {
                if (getLogger().isWarnEnabled()) 
                    getLogger().warn("A problem occurred acquiring Parameter '" + paramName 
                                      + "' from '" + inputName + "': " + e.getMessage());
            }
        } else {
            // input was not thread safe
            // so acquire it again
            ServiceSelector iputSelector = null;
            InputModule iput = null;
            try {
                // obtain input module
                iputSelector=(ServiceSelector) this.manager.lookup(INPUT_MODULE_SELECTOR); 
                if (iputSelector != null && iputSelector.isSelectable(inputName)) {
                    iput = (InputModule) iputSelector.select(inputName);
                }
                if (iput != null) {
                    result = iput.getAttribute(paramName, this.inputConf, objectModel);
                }
            } catch (Exception e) {
                if (getLogger().isWarnEnabled()) 
                    getLogger().warn("A problem occurred acquiring Parameter '" + paramName 
                                     + "' from '" + inputName + "': " + e.getMessage());
            } finally {
                // release components
                if (iputSelector != null) {
                    if (iput != null)
                        iputSelector.release(iput);
                    this.manager.release(iputSelector);
                }
            }
        }

        if (result instanceof String) {
            return (String) result;
        } else {
            return result.toString();
        }
    }
17320#/* (non-Javadoc)
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager=manager;
    }
17321#/* (non-Javadoc)
     * @see org.apache.avalon.framework.configuration.Configurable#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration config) throws ConfigurationException {

        this.defaultParam = config.getChild("parameter-name").getValue(null);
        this.inputConf = config.getChild("input-module");
        this.defaultInput = this.inputConf.getAttribute("name",this.defaultInput);
    }
17322#/* (non-Javadoc)
     * @see org.apache.avalon.framework.activity.Initializable#initialize()
     */
    public void initialize() {
        try {
            // obtain input module
            this.inputSelector=(ServiceSelector) this.manager.lookup(INPUT_MODULE_SELECTOR); 
            if (this.defaultInput != null && 
                this.inputSelector != null && 
                this.inputSelector.isSelectable(this.defaultInput)
                ){
                this.input = (InputModule) this.inputSelector.select(this.defaultInput);
                if (!(this.input instanceof ThreadSafe && this.inputSelector instanceof ThreadSafe) ) {
                    this.inputSelector.release(this.input);
                    this.manager.release(this.inputSelector);
                    this.input = null;
                    this.inputSelector = null;
                }
                this.initialized = true;
            } else {
                if (getLogger().isErrorEnabled())
                    getLogger().error("A problem occurred setting up '" + this.defaultInput 
                                      + "': Selector is "+(this.inputSelector!=null?"not ":"")
                                      +"null, Component is "
                                      +(this.inputSelector!=null&&this.inputSelector.isSelectable(this.defaultInput)?"known":"unknown"));
            }
        } catch (Exception e) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("A problem occurred setting up '" + this.defaultInput + "': " + e.getMessage());
        }
    }
17323#public void dispose() {

        if (!this.initialized) 
            if (getLogger().isErrorEnabled()) 
                getLogger().error("Uninitialized Component! FAILING");
        else 
            if (this.inputSelector != null) {
                if (this.input != null)
                    this.inputSelector.release(this.input);
                this.manager.release(this.inputSelector);
            }
    }
17324#protected String getMatchString(Map objectModel, Parameters parameters) {

        String paramName = parameters.getParameter("parameter-name", this.defaultParam);
        String inputName = parameters.getParameter("input-module", this.defaultInput);

        if (!this.initialized) {
            if (getLogger().isErrorEnabled()) 
                getLogger().error("Uninitialized Component! FAILING");
            return null;
        }
        if (paramName == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No parameter name given. Trying to Continue");
        }
        if (inputName == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("No input module given. FAILING");
            return null;
        }

        Object result = null;

        if (this.input != null && inputName.equals(this.defaultInput)) {
            // input module is thread safe
            // thus we still have a reference to it
            try {
                if (this.input != null) {
                    result = this.input.getAttribute(paramName, this.inputConf, objectModel);
                }
            } catch (Exception e) {
                if (getLogger().isWarnEnabled()) 
                    getLogger().warn("A problem occurred acquiring Parameter '" + paramName 
                                      + "' from '" + inputName + "': " + e.getMessage());
            }
        } else {
            // input was not thread safe
            // so acquire it again
            ServiceSelector iputSelector = null;
            InputModule iput = null;
            try {
                // obtain input module
                iputSelector=(ServiceSelector) this.manager.lookup(INPUT_MODULE_SELECTOR); 
                if (iputSelector != null && iputSelector.isSelectable(inputName)) {
                    iput = (InputModule) iputSelector.select(inputName);
                }
                if (iput != null) {
                    result = iput.getAttribute(paramName, this.inputConf, objectModel);
                }
            } catch (Exception e) {
                if (getLogger().isWarnEnabled()) 
                    getLogger().warn("A problem occurred acquiring Parameter '" + paramName 
                                     + "' from '" + inputName + "': " + e.getMessage());
            } finally {
                // release components
                if (iputSelector != null) {
                    if (iput != null)
                        iputSelector.release(iput);
                    this.manager.release(iputSelector);
                }
            }
        }

        if (result instanceof String) {
            return (String) result;
        } else {
            return result.toString();
        }
    }
17325#public boolean select(String expression, Map objectModel, Parameters parameters) {
        String method = ObjectModelHelper.getRequest(objectModel).getMethod();
        return method.equals(expression);
    }
17326#public void configure(Configuration config) throws ConfigurationException {
        this.defaultName = config.getChild("cookie-name").getValue(null);
    }
17327#public boolean select(String expression, Map objectModel, Parameters parameters) {

        String name = parameters.getParameter("cookie-name", this.defaultName);
        if (name == null) {
            getLogger().warn("No cookie name given -- failing.");
            return false;
        }

        Cookie[] cookies = ObjectModelHelper.getRequest(objectModel).getCookies();
        if (cookies == null) {
            getLogger().debug("Cookie '" + name + "' not set -- failing");
            return false;
        }

        // TODO: this is not optimized
        String value = null;
        for (int i = 0; i < cookies.length; i++) {
            if (cookies[i].getName().equals(name)) {
                value = cookies[i].getValue();
                break;
            }
        }

        if (value == null) {
            getLogger().debug("Cookie '" + name + "' not set -- failing");
            return false;
        }

        return value.equals(expression);
    }
17328#/**
     * <p>Create a new {@link RegexpHeaderSelector} instance.</p>
     */
    public RegexpHeaderSelector() {
        super();
    }
17329#/**
     * <p>Configure this instance parsing all regular expression patterns and
     * storing the header name upon which selection occurs.</p>
     * 
     * @param configuration the {@link Configuration} instance where configured
     *                      patterns are defined.
     * @throws ConfigurationException if one of the regular-expression to configure
     *                                could not be compiled.
     */
    public void configure(Configuration configuration)
    throws ConfigurationException {
        super.configure(configuration);
        this.headerName = configuration.getChild("header-name").getValue(null);
    }
17330#/**
     * <p>Return the value of the header identified by the configured header
     * name, if any.</p>
     * 
     * @param objectModel the Cocoon object model.
     * @param parameters the {@link Parameters} associated with the pipeline.
     * @return the value of the configured request parameter or <b>null</b>.
     */
    public Object getSelectorContext(Map objectModel, Parameters parameters) {
        String name = parameters.getParameter("header-name", this.headerName);
        if (name == null) {
            this.getLogger().warn("No header name given -- failing.");
            return null;
        }
        return ObjectModelHelper.getRequest(objectModel).getHeader(name);
    }
17331#/**
     * Selectors test pattern against some objects in a <code>Map</code>
     * model and signals success with the returned boolean value
     * @param expr        The expression to test.
     * @return Signals successful test.
     */
    public boolean select(String expr, Map objectModel, Parameters params) {
	// Inform proxies that response varies with the selector header
	String name = params.getParameter("header-name", this.headerName);
	if (name != null)
	    ObjectModelHelper.getResponse(objectModel).addHeader("Vary", name);
        return select(expr, getSelectorContext(objectModel, params));
    }
17332#public boolean select(String expression, Map objectModel, Parameters parameters) {
        String compareToString = parameters.getParameter("parameter-selector-test", null);
        return compareToString != null && compareToString.equals(expression);
    }
17333#public Object getSelectorContext(Map objectModel, Parameters parameters) {
        return parameters.getParameter("value", "");
    }
17334#public boolean select(String expression, Object selectorContext) {
        if (selectorContext == null) {
            if (getLogger().isWarnEnabled()) 
                getLogger().warn("Value not set -- failing.");
            return false;
        }

        return selectorContext.equals(expression);
    }
17335#public void configure(Configuration conf) throws ConfigurationException {
        configure(conf, "browser", "name", "useragent");
    }
17336#public boolean select(String expression, Map objectModel, Parameters parameters) {
        // Inform proxies that response varies with the user-agent header
        ObjectModelHelper.getResponse(objectModel).addHeader("Vary", "User-Agent");

        // Get the user-agent request header
        String userAgent = ObjectModelHelper.getRequest(objectModel).getHeader("User-Agent");
        if (userAgent == null) {
            getLogger().debug("No User-Agent header -- failing.");
            return false;
        }

        return checkPatterns(expression, userAgent);
    }
17337#/**
     * <p>Create a new {@link RegexpRequestParameterSelector} instance.</p>
     */
    public RegexpRequestParameterSelector() {
        super();
    }
17338#/**
     * <p>Configure this instance parsing all regular expression patterns and
     * storing the parameter name upon which selection occurs.</p>
     * 
     * @param configuration the {@link Configuration} instance where configured
     *                      patterns are defined.
     * @throws ConfigurationException if one of the regular-expression to configure
     *                                could not be compiled.
     */
    public void configure(Configuration configuration)
    throws ConfigurationException {
        super.configure(configuration);
        this.parameterName = configuration.getChild("parameter-name").getValue(null);
    }
17339#/**
     * <p>Return the value of the parameter identified by the configured parameter
     * name, if any.</p>
     * 
     * @param objectModel the Cocoon object model.
     * @param parameters the {@link Parameters} associated with the pipeline.
     * @return the value of the configured request parameter or <b>null</b>.
     */
    public Object getSelectorContext(Map objectModel, Parameters parameters) {
        String name = parameters.getParameter("parameter-name", this.parameterName);
        if (name == null) {
            this.getLogger().warn("No parameter name given -- failing.");
            return null;
        }
        return ObjectModelHelper.getRequest(objectModel).getParameter(name);
    }
17340#public void configure(Configuration conf) throws ConfigurationException {

        Configuration[] children = conf.getChildren("exception");

        this.clazz = new Class[children.length];
        this.name = new String[children.length];
        this.unroll = new boolean[children.length];

        for (int i = 0; i < children.length; i++) {
            Configuration child = children[i];

            String childClassName = child.getAttribute("class");
            Class childClass = null;
            try {
                childClass = ClassUtils.loadClass(childClassName);
            }
            catch (Exception e) {
                throw new ConfigurationException("Cannot load class '" + childClassName + "' at " + child.getLocation());
            }
            
            // Check that this class is not hidden by a more general class already declared
            for (int j = 0; j < i; j++) {
                if (this.clazz[j].isAssignableFrom(childClass)) {
                    throw new ConfigurationException("Class '" + this.clazz[j].getName() + "' hides its subclass '" +
                    	childClassName + "' at " + child.getLocation());
                }
            }

			this.clazz[i] = childClass;
            this.name[i] = child.getAttribute("name", null);
            this.unroll[i] = child.getAttributeAsBoolean("unroll", false);

            if (this.name[i] == null && !this.unroll[i]) {
                throw new ConfigurationException("Must specify one of 'name' or 'unroll' at " + child.getLocation());
            }
        }
    }
17341#/**
     * Compute the exception type, given the configuration and the exception stored in the object model.
     * 
     * @see ObjectModelHelper#getThrowable(java.util.Map)
     */
    public Object getSelectorContext(Map objectModel, Parameters parameters) {
        // Get the name of the exception
        Throwable thr = ObjectModelHelper.getThrowable(objectModel);
        if (thr == null) {
            throw new IllegalStateException("No exception in object model. ExceptionSelector can only be used in <map:handle-errors>");
        }

        return find(thr);
    }
17342#private FindResult find(Throwable thr) {
        // Now find the proper name
        for (int i = 0; i < this.clazz.length; i++) {
            if (this.clazz[i].isInstance(thr)) {

                // If exception needs to be unrolled, and it has a cause,
                // return the cause name, if not null (recursively)
                if (this.unroll[i]) {
                    Throwable cause = ExceptionUtils.getCause(thr);
                    if (cause != null) {
                        FindResult result = find(cause);
                        if (result != null) {
                            return result;
                        }
                    }
                }

                // Not unrolled
                return new FindResult(this.name[i], thr);
            }
        }

        // Not found
        return null;
    }
17343#public boolean select(String expression, Object selectorContext) {
        if ( selectorContext == null ) {
            return false;
        }
        // Just compare the expression with the previously found name
		boolean result = expression.equals(((FindResult)selectorContext).getName());
		
		if (result) {
			if (getLogger().isDebugEnabled())
				getLogger().debug("select succesfull for condition " + selectorContext.toString());						
		}
        
		return result; 
    }
17344#public FindResult(String name, Throwable throwable) {
    		this.name = name;
    		this.throwable = throwable;
    	}
17345#public String getName() {
			return this.name;
		}
17346#public void setName(String name) {
			this.name = name;
		}
17347#public Throwable getThrowable() {
			return this.throwable;
		}
17348#public void setThrowable(Throwable throwable) {
			this.throwable = throwable;
		}
17349#public String toString() {
			return this.name;
		}
17350#public void configure(Configuration config) throws ConfigurationException {
        this.defaultName = config.getChild("parameter-name").getValue(null);
    }
17351#public Object getSelectorContext(Map objectModel, Parameters parameters) {
        
        String name = parameters.getParameter("parameter-name", this.defaultName);

        if (name == null) {
            getLogger().warn("No parameter name given -- failing.");
            return null;
        }

        return ObjectModelHelper.getRequest(objectModel).getParameter(name);
    }
17352#public boolean select(String expression, Object selectorContext) {
        if (selectorContext == null) {
            getLogger().debug("Request parameter '" + selectorContext + "' not set -- failing.");
            return false;
        }

        return selectorContext.equals(expression);
    }
17353#public void configure(Configuration config) throws ConfigurationException {
        this.defaultName = config.getChild("attribute-name").getValue(null);
    }
17354#public boolean select(String expression, Map objectModel, Parameters parameters) {
        String name = parameters.getParameter("attribute-name", this.defaultName);

        if (name == null) {
            getLogger().warn("No attribute name given -- failing.");
            return false;
        }

        Object value = ObjectModelHelper.getRequest(objectModel).getSession().getAttribute(name);
        if (value == null) {
            getLogger().debug("Session attribute '" + name + "' not set -- failing.");
            return false;
        }

        return value.toString().equals(expression);
    }
17355#public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
        this.resolver = (SourceResolver)manager.lookup(SourceResolver.ROLE);
    }
17356#public void dispose() {
        this.manager.release(this.resolver);
        this.resolver = null;
        this.manager = null;
    }
17357#public boolean select(String expression, Map objectModel, Parameters parameters) {
        String resourceURI = parameters.getParameter("prefix", "") + expression;
        Source source = null;
        try {
            source = resolver.resolveURI(resourceURI);
            return source.exists();
        } catch (SourceNotFoundException e) {
            return false;
        } catch (Exception e) {
            getLogger().warn("Exception resolving resource " + resourceURI, e);
            return false;
        } finally {
            if (source != null) {
                resolver.release(source);
            }
        }
    }
17358#public void configure(Configuration config) throws ConfigurationException {
        // Check old name
        this.defaultName = config.getChild("parameter-name").getValue(null);
        if (defaultName != null) {
            getLogger().warn("'parameter-name' is deprecated. Please use 'header-name'");
        }
        // Load with new one
        this.defaultName = config.getChild("header-name").getValue(this.defaultName);
    }
17359#public boolean select(String expression, Map objectModel, Parameters parameters) {
        // Check old name
        String name = parameters.getParameter("parameter-name", null);
        if (name != null) {
            getLogger().warn("'parameter-name' is deprecated. Please use 'header-name'");
        } else {
            name = this.defaultName;
        }

        // Load with new one.
        name = parameters.getParameter("header-name", name);

        if (name == null) {
            getLogger().warn("No header name given -- failing.");
            return false;
        }

        String value = ObjectModelHelper.getRequest(objectModel).getHeader(name);
        if (value == null) {
            getLogger().debug("Header '" + name + "' not set -- failing.");
            return false;
        }

        return value.equals(expression);
    }
17360#public void configure(Configuration config) throws ConfigurationException {
        this.defaultName = config.getChild("attribute-name").getValue(null);
    }
17361#public boolean select(String expression, Map objectModel, Parameters parameters) {
        String name = parameters.getParameter("attribute-name", this.defaultName);

        if (name == null) {
            getLogger().warn("No attribute name given -- failing.");
            return false;
        }

        Object value = ObjectModelHelper.getRequest(objectModel).getAttribute(name);
        if (value == null) {
            getLogger().debug("Request attribute '" + name + "' not set -- failing.");
            return false;
        }

        return value.toString().equals(expression);
    }
17362#public void configure(Configuration conf) throws ConfigurationException {
        configure(conf, "host", "name", "value");
    }
17363#public boolean select(String expression, Map objectModel, Parameters parameters) {
        // Inform proxies that response varies with the Host header
        ObjectModelHelper.getResponse(objectModel).addHeader("Vary", "Host");

        // Get the host request header
        String host = ObjectModelHelper.getRequest(objectModel).getHeader("Host");
        if (host == null) {
            getLogger().debug("No Host header -- failing.");
            return false;
        }

        return checkPatterns(expression, host);
    }
17364#public void configure(Configuration conf) throws ConfigurationException {

        super.configure(conf);

        Configuration[] children = conf.getChildren("exception");
        Configuration[] xPathChildren;

        for (int i = 0; i < children.length; i++) {
            // Check if there are XPath-Expressions configured
            xPathChildren = children[i].getChildren("xpath");
            Map xPathMap = new LinkedMap(11);

            for (int j = 0; j < xPathChildren.length; j++) {
                Configuration xPathChild = xPathChildren[j];

                String xPathName = xPathChild.getAttribute("name");
                CompiledExpression xPath = JXPathContext.compile(xPathChild.getAttribute("test"));

                xPathMap.put(xPathName, xPath);
            }
            if (xPathMap.size() > 0) {
                // store xpath - config if there is some
                exception2XPath.put(children[i].getAttribute("name", null),
                                    xPathMap);
            }
        }
    }
17365#/**
     * Compute the exception type, given the configuration and the exception stored in the object model.
     */
    public Object getSelectorContext(Map objectModel, Parameters parameters) {

        // get exception from super class
        FindResult selectorContext = (FindResult) super.getSelectorContext(objectModel,
                                         parameters);

        if (selectorContext != null) {
            String exceptionName = selectorContext.getName();
            Throwable t = selectorContext.getThrowable();

            Map xPathMap = (Map) exception2XPath.get(exceptionName);

            if (xPathMap != null) {
                // create a context for the thrown exception
                JXPathContext context = JXPathContext.newContext(t);

                for (Iterator iterator = xPathMap.entrySet().iterator(); iterator.hasNext(); ) {
                    Map.Entry entry = (Map.Entry) iterator.next();

                    if (((CompiledExpression) entry.getValue()).getValue(context).equals(Boolean.TRUE)) {
                        // set the configured name if the expression is succesfull
                        selectorContext.setName((String) entry.getKey());
                        return selectorContext;
                    }
                }
            }
        }

        return selectorContext;
    }
17366#/**
     * Configures the Action.
     *
     * Takes the children from the <code>Configuration</code> and stores them
     * them as key (configuration name) and value (configuration value)
     * in <code>settings</code>.
     * <br/>
     * This automates parsing of flat string-only configurations.
     * For nested configurations, override this function in your action.
     */
    public void configure(Configuration conf) throws ConfigurationException {
        Configuration[] parameters = conf.getChildren();
        this.settings = new HashMap(parameters.length);
        for (int i = 0; i < parameters.length; i++) {
            String key = parameters[i].getName();
            String val = parameters[i].getValue(null);
            this.settings.put(key, val);
        }
    }
17367#private static final String removePrefix( String name ) {
        int prefixLen = ACTION_METHOD_PREFIX.length();
        return name.substring(prefixLen, prefixLen + 1).toLowerCase() + name.substring(prefixLen + 1);
    }
17368#public void configure(Configuration conf) throws ConfigurationException {
        super.configure(conf);

        try {
            Method[] methods = this.getClass().getMethods();
            methodIndex = new HashMap();

            for (int i = 0; i < methods.length; i++) {
                String methodName = methods[i].getName();
                if (methodName.startsWith(ACTION_METHOD_PREFIX)) {
                    String actionName = removePrefix(methodName);
                    methodIndex.put(actionName, methods[i]);
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("registered method \"" + methodName + "\" as action \"" + actionName + "\"");
                    }
                }
            }
        } catch (Exception e) {
            throw new ConfigurationException("cannot get methods by reflection", e);
        }
    }
17369#public Map act(Redirector redirector, SourceResolver resolver, Map objectModel, String source, Parameters parameters) throws Exception {
        String actionMethod = parameters.getParameter(ACTION_METHOD_PARAMETER, null);

        if (actionMethod == null) {
            Request req = ObjectModelHelper.getRequest(objectModel);
            if (req != null) {
                // checking request for action method parameters
                String name;
                for (Enumeration e = req.getParameterNames(); e.hasMoreElements();) {
                    name = (String) e.nextElement();
                    if (name.startsWith(ACTION_METHOD_PREFIX)) {
                        if (name.endsWith(".x") || name.endsWith(".y")) {
                            name = name.substring(ACTION_METHOD_PREFIX.length(), name.length() - 2);
                        }
                        actionMethod = removePrefix(name);
                        break;
                    }
                }
            }
        }

        if((actionMethod != null) && (actionMethod.length() > 0)) {
            Method method = (Method) methodIndex.get(actionMethod);
            if (method != null) {
                try {
                    return ((Map) method.invoke(this, new Object[]{redirector, resolver, objectModel, source, parameters}));
                } catch (InvocationTargetException ite) {
                    if ((ite.getTargetException() != null) && (ite.getTargetException() instanceof Exception)) {
                        throw (Exception)ite.getTargetException();
                    } else {
                        throw ite;
                    }
                }
            } else {
                throw new Exception("action has no method \"" + actionMethod + "\"");
            }
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("you need to specify the method with parameter \"" + ACTION_METHOD_PARAMETER + "\" or have a request parameter starting with \"" + ACTION_METHOD_PREFIX + "\"");
        }
        return null;
    }
17370#/**
     * Set the current <code>ServiceManager</code> instance used by this
     * <code>Serviceable</code>.
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
17371#/* (non-Javadoc)
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
17372#/**
     * Make constructor private to inhibit creation outside.
     */
    private ValidatorActionResult (String image) {
        super (image);
    }
17373#/**
     * Create a ValidatorActionHelper object that contains just the
     * object. Defaults to <code>OK</code> as validation result.
     *
     * @param validatedObject object that has been validated
     */
    public ValidatorActionHelper ( Object validatedObject ) {
        this.object = validatedObject;
        this.result = ValidatorActionResult.OK;
    }
17374#/**
     * Create a ValidatorActionHelper object that contains just the
     * object. Defaults to <code>OK</code> as validation result.
     *
     * @param validatedObject object that has been validated
     * @param validationResult result of the validation
     */
    public ValidatorActionHelper ( Object validatedObject, ValidatorActionResult validationResult ) {
        this.object = validatedObject;
        this.result = validationResult;
    }
17375#/**
     * Tests if the validation result is <code>OK</code>
     *
     */
    public boolean isOK() {
        return (result.equals(ValidatorActionResult.OK));
    }
17376#/**
     * Tests if the validation result is <code>NOTPRESENT</code>,
     * e.g. when the value is null and is allowed to be null.
     *
     */
    public boolean isNotPresent() {
        return (result.equals(ValidatorActionResult.NOTPRESENT));
    }
17377#/**
     * Tests if the validation result is <code>ISNULL</code>,
     * e.g. when the value is null but is not supposed to be null.
     *
     */
    public boolean isNull() {
        return (result.equals(ValidatorActionResult.ISNULL));
    }
17378#/**
     * Tests if the validation result is <code>TOOLARGE</code>,
     * e.g. in case of a double or long the value is too large or in
     * case of a string it is too long.
     *
     */
    public boolean isTooLarge() {
        return (result.equals(ValidatorActionResult.TOOLARGE));
    }
17379#/**
     * Tests if the validation result is <code>TOOSMALL</code>,
     * e.g. in case of a double or long the value is too small or in
     * case of a string it is too short.
     *
     */
    public boolean isTooSmall() {
        return (result.equals(ValidatorActionResult.TOOSMALL));
    }
17380#/**
     * Tests if the validation result is <code>NOMATCH</code>, can
     * only occur when
     *
     */
    public boolean doesNotMatch() {
        return (result.equals(ValidatorActionResult.NOMATCH));
    }
17381#/**
     * Returns the tested object.
     *
     */
    public Object getObject() {
        return object;
    }
17382#/**
     * Returns the result.
     *
     */
    public ValidatorActionResult getResult() {
        return result;
    }
17383#/**
     * Reads parameter values for all parameters that are contained in the active
     * constraint list. If a parameter has multiple values, all are stored in the
     * resulting map.
     * 
     * @param objectModel the object model
     * @param set a collection of parameter names
     * @return HashMap
     */
    abstract protected HashMap createMapOfParameters(Map objectModel, Collection set);
17384#/**
     * Are parameters encoded as strings?
     */
    abstract boolean isStringEncoded();
17385#/*
     * main method
     */
    public Map act(Redirector redirector,
                   SourceResolver resolver,
                   Map objectModel,
                   String src,
                   Parameters parameters) throws Exception {

        Configuration conf = this.getDescriptor(resolver, objectModel, parameters);
        if (conf == null)
            return null;

        String valStr =
            parameters.getParameter("validate", (String)settings.get("validate", "")).trim();
        String valSetStr =
            parameters.getParameter("validate-set", (String)settings.get("validate-set", "")).trim();
        String constraintSetStr =
            parameters.getParameter("constraint-set", (String)settings.get("constraint-set", "")).trim();
        if (!"".equals(valSetStr)) {
            if (getLogger().isInfoEnabled()) {
                getLogger().info("Using sitemap parameter 'validate-set' for specifying "
                                 + "the constraint-set for the ValidatorActions is deprecated in "
                                 + "favor of 'constraint-set' due to consistency in the naming.");
            }
            if ("".equals(constraintSetStr)) {
                constraintSetStr = valSetStr;
            }
        }
        Map desc = this.indexConfiguration(conf.getChildren("parameter"));

        Map actionMap = new HashMap();
        Map resultMap = new HashMap();
        Collection params = null;
        boolean allOK = false;

        if (!"".equals(valStr)) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Validating parameters as specified via 'validate' parameter");
            }
            params = this.getSetOfParameterNamesFromSitemap(valStr, desc);
        } else if (!"".equals(constraintSetStr)) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Validating parameters from given constraint-set " + constraintSetStr);
            }
            Map csets = this.indexConfiguration(conf.getChildren("constraint-set"));
            params = this.resolveConstraints(constraintSetStr, csets);
        }
        
        if (params == null) {
            throw new ProcessingException("Neither a constraint-set nor parameters in the sitemap "
                                          + "were specified for validating at "
                                          + SitemapParameters.getLocation(parameters));
        }
        HashMap values = this.createMapOfParameters(objectModel, params);
        allOK = this.validateSetOfParameters(desc, actionMap, resultMap, params, values, this.isStringEncoded());

        return this.setResult(objectModel, actionMap, resultMap, allOK);
    }
17386#/**
     * Try to validate given parameter.
     * @param name The name of the parameter to validate.
     * @param constraints Configuration of all constraints for this
     * parameter as taken from the description XML file.
     * @param conf Configuration of all parameters as taken from the
     * description XML file.
     * @param params The map of parameters.
     * @param isString Indicates wheter given param to validate is
     * string (as taken from HTTP request for example) or wheteher it
     * should be regular instance of java.lang.Double, java.lang.Long,
     * etc.
     * @return The validated parameter.
     */
    public ValidatorActionHelper validateParameter(
        String name,
        Configuration constraints,
        Map conf,
        Map params,
        boolean isString) {

        return validateParameter(name, name, constraints, conf, params, isString);
    }
17387#/**
     * Try to validate given parameter.
     * @param name The actual name of the parameter to validate.
     * @param rule The name of the parameter element that contains the
     * rule that should be used for validation.
     * @param constraints Configuration of all constraints for this
     * parameter as taken from the description XML file.
     * @param conf Configuration of all parameters as taken from the
     * description XML file.
     * @param params The map of parameters.
     * @param isString Indicates wheter given param to validate is
     * string (as taken from HTTP request for example) or wheteher it
     * should be regular instance of java.lang.Double, java.lang.Long,
     * etc.
     * @return The validated parameter.
     */
    public ValidatorActionHelper validateParameter(
        String name,
        String rule,
        Configuration constraints,
        Map conf,
        Map params,
        boolean isString) {
        String type = null;

        if (getLogger().isDebugEnabled())
            getLogger().debug("Validating parameter: " + name + " using rule: " + rule);

        /* try to find matching param description in conf tree */
        try {
            Configuration theConf = (Configuration) conf.get(rule);
            type = theConf.getAttribute("type");

            return validateValue(name, constraints, theConf, params, isString, type);

        } catch (Exception e) {
            if (getLogger().isDebugEnabled())
                getLogger().debug("No type specified for parameter " + name);
            return null;
        }
    }
17388#/**
     * Validate a single parameter value.
     * 
     * @param name String holding the name of the parameter
     * @param constraints Configuration holding the constraint set configuration for the parameter
     * @param conf Configuration holding the parameter configuration
     * @param params Map of parameter values to be validated
     * @param isString boolean indicating if the value is string encoded
     * @param type string holding the name of the datatype to validate value
     * @return ValidatorActionHelper
     */
    protected ValidatorActionHelper validateValue(
        String name,
        Configuration constraints,
        Configuration conf,
        Map params,
        boolean isString,
        String type) {
        Object value = params.get(name);

        if (value != null && value.getClass().isArray()) {
            Object[] values = (Object[]) value;
            ValidatorActionHelper vaH = null;
            ValidatorActionResult vaR = ValidatorActionResult.OK;
            for (int j = 0; j < values.length; j++) {
                value = values[j];
                if ("string".equals(type)) {
                    vaH = validateString(name, constraints, conf, params, value);
                } else if ("long".equals(type)) {
                    vaH = validateLong(name, constraints, conf, params, isString, value);
                } else if ("double".equals(type)) {
                    vaH = validateDouble(name, constraints, conf, params, isString, value);
                } else {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug(
                            "Unknown type " + type + " specified for parameter " + name);
                    return null;
                }
                vaR = (vaR.getPos() < vaH.getResult().getPos() ? vaH.getResult() : vaR);
            }
            return new ValidatorActionHelper(vaH.getObject(), vaR);
        } else {
            if ("string".equals(type)) {
                return validateString(name, constraints, conf, params, value);
            } else if ("long".equals(type)) {
                return validateLong(name, constraints, conf, params, isString, value);
            } else if ("double".equals(type)) {
                return validateDouble(name, constraints, conf, params, isString, value);
            } else {
                if (getLogger().isDebugEnabled())
                    getLogger().debug("Unknown type " + type + " specified for parameter " + name);
            }
            return null;
        }
    }
17389#/**
     * Validates nullability and default value for given parameter. If given
     * constraints are not null they are validated as well.
     */
    private ValidatorActionHelper validateString(
        String name,
        Configuration constraints,
        Configuration conf,
        Map params,
        Object param) {

        String value = null;
        String dflt = getDefault(conf, constraints);
        boolean nullable = getNullable(conf, constraints);

        if (getLogger().isDebugEnabled())
            getLogger().debug("Validating string parameter " + name);
        try {
            value = getStringValue(param);
        } catch (Exception e) {
            // ClassCastException
            return new ValidatorActionHelper(value, ValidatorActionResult.ERROR);
        }
        if (value == null) {
            if (getLogger().isDebugEnabled())
                getLogger().debug("String parameter " + name + " is null");
            if (!nullable) {
                return new ValidatorActionHelper(value, ValidatorActionResult.ISNULL);
            } else {
                return new ValidatorActionHelper(dflt);
            }
        }
        if (constraints != null) {
            String eq = constraints.getAttribute("equals-to", "");
            eq = conf.getAttribute("equals-to", eq);

            String eqp = constraints.getAttribute("equals-to-param", "");
            eqp = conf.getAttribute("equals-to-param", eqp);

            String regex = conf.getAttribute("matches-regex", "");
            regex = constraints.getAttribute("matches-regex", regex);

            String oneOf = conf.getAttribute("one-of", "");
            oneOf = constraints.getAttribute("one-of", oneOf);

            Long minlen = getAttributeAsLong(conf, "min-len", null);
            minlen = getAttributeAsLong(constraints, "min-len", minlen);

            Long maxlen = getAttributeAsLong(conf, "max-len", null);
            maxlen = getAttributeAsLong(constraints, "max-len", maxlen);

            // Validate whether param is equal to constant
            if (!"".equals(eq)) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug("String parameter " + name + " should be equal to " + eq);
                if (!value.equals(eq)) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug("and it is not");
                    return new ValidatorActionHelper(value, ValidatorActionResult.NOMATCH);
                }
            }

            // Validate whether param is equal to another param
            // FIXME: take default value of param being compared with into
            // account?
            if (!"".equals(eqp)) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug(
                        "String parameter " + name + " should be equal to " + params.get(eqp));
                if (!value.equals(params.get(eqp))) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug("and it is not");
                    return new ValidatorActionHelper(value, ValidatorActionResult.NOMATCH);
                }
            }

            // Validate whether param length is at least of minimum length
            if (minlen != null) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug(
                        "String parameter "
                            + name
                            + " should be at least "
                            + minlen
                            + " characters long");
                if (value.length() < minlen.longValue()) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug("and it is shorter (" + value.length() + ")");
                    return new ValidatorActionHelper(value, ValidatorActionResult.TOOSMALL);
                }
            }

            // Validate whether param length is at most of maximum length
            if (maxlen != null) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug(
                        "String parameter "
                            + name
                            + " should be at most "
                            + maxlen
                            + " characters long");

                if (value.length() > maxlen.longValue()) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug("and it is longer (" + value.length() + ")");
                    return new ValidatorActionHelper(value, ValidatorActionResult.TOOLARGE);
                }
            }

            // Validate wheter param matches regular expression
            if (!"".equals(regex)) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug(
                        "String parameter " + name + " should match regexp \"" + regex + "\"");
                try {
                    RE r = new RE(regex);
                    if (!r.match(value)) {
                        if (getLogger().isDebugEnabled())
                            getLogger().debug("and it does not match");
                        return new ValidatorActionHelper(value, ValidatorActionResult.NOMATCH);
                    }
                } catch (RESyntaxException rese) {
                    if (getLogger().isDebugEnabled())
                        getLogger().error("String parameter " + name + " regex error ", rese);
                    return new ValidatorActionHelper(value, ValidatorActionResult.NOMATCH);
                }
            }

            // Validates against a set of possibilities
            if (!"".equals(oneOf)) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug(
                        "String parameter " + name + " should be one of \"" + oneOf + "\"");
                if (!oneOf.startsWith("|"))
                    oneOf = "|" + oneOf;
                if (!oneOf.endsWith("|"))
                    oneOf = oneOf + "|";
                if (value.indexOf("|") != -1) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug(
                            "String parameter " + name + "contains \"|\" - can't validate that.");
                    return new ValidatorActionHelper(value, ValidatorActionResult.ERROR);
                }
                if (oneOf.indexOf("|" + value + "|") == -1) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug("and it is not");
                    return new ValidatorActionHelper(value, ValidatorActionResult.NOMATCH);
                }
                return new ValidatorActionHelper(value, ValidatorActionResult.OK);

            }

        }
        return new ValidatorActionHelper(value);
    }
17390#/**
     * Validates nullability and default value for given parameter. If given
     * constraints are not null they are validated as well.
     */
    private ValidatorActionHelper validateLong(
        String name,
        Configuration constraints,
        Configuration conf,
        Map params,
        boolean is_string,
        Object param) {

        boolean nullable = getNullable(conf, constraints);
        Long value = null;
        Long dflt = getLongValue(getDefault(conf, constraints), true);

        if (getLogger().isDebugEnabled())
            getLogger().debug(
                "Validating long parameter " + name + " (encoded in a string: " + is_string + ")");
        try {
            value = getLongValue(param, is_string);
        } catch (Exception e) {
            // Unable to parse long
            return new ValidatorActionHelper(value, ValidatorActionResult.ERROR);
        }
        if (value == null) {
            if (getLogger().isDebugEnabled())
                getLogger().debug("Long parameter " + name + " is null");
            if (!nullable) {
                return new ValidatorActionHelper(value, ValidatorActionResult.ISNULL);
            } else {
                return new ValidatorActionHelper(dflt);
            }
        }
        if (constraints != null) {
            Long eq = getAttributeAsLong(constraints, "equals-to", null);
            String eqp = constraints.getAttribute("equals-to-param", "");

            Long min = getAttributeAsLong(conf, "min", null);
            min = getAttributeAsLong(constraints, "min", min);

            Long max = getAttributeAsLong(conf, "max", null);
            max = getAttributeAsLong(constraints, "max", max);

            // Validate whether param is equal to constant
            if (eq != null) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug("Long parameter " + name + " should be equal to " + eq);

                if (!value.equals(eq)) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug("and it is not");
                    return new ValidatorActionHelper(value, ValidatorActionResult.NOMATCH);
                }
            }

            // Validate whether param is equal to another param
            // FIXME: take default value of param being compared with into
            // account?
            if (!"".equals(eqp)) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug(
                        "Long parameter " + name + " should be equal to " + params.get(eqp));
                // Request parameter is stored as string.
                // Need to convert it beforehand.
                try {
                    Long _eqp = new Long(Long.parseLong((String) params.get(eqp)));
                    if (!value.equals(_eqp)) {
                        if (getLogger().isDebugEnabled())
                            getLogger().debug("and it is not");
                        return new ValidatorActionHelper(value, ValidatorActionResult.NOMATCH);
                    }
                } catch (NumberFormatException nfe) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug(
                            "Long parameter " + name + ": " + eqp + " is no long",
                            nfe);
                    return new ValidatorActionHelper(value, ValidatorActionResult.NOMATCH);
                }
            }

            // Validate wheter param is at least min
            if (min != null) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug("Long parameter " + name + " should be at least " + min);

                if (min.compareTo(value) > 0) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug("and it is not");
                    return new ValidatorActionHelper(value, ValidatorActionResult.TOOSMALL);
                }
            }

            // Validate wheter param is at most max
            if (max != null) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug("Long parameter " + name + " should be at most " + max);
                if (max.compareTo(value) < 0) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug("and it is not");
                    return new ValidatorActionHelper(value, ValidatorActionResult.TOOLARGE);
                }
            }
        }
        return new ValidatorActionHelper(value);
    }
17391#/**
     * Validates nullability and default value for given parameter. If given
     * constraints are not null they are validated as well.
     */
    private ValidatorActionHelper validateDouble(
        String name,
        Configuration constraints,
        Configuration conf,
        Map params,
        boolean is_string,
        Object param) {

        boolean nullable = getNullable(conf, constraints);
        Double value = null;
        Double dflt = getDoubleValue(getDefault(conf, constraints), true);

        if (getLogger().isDebugEnabled())
            getLogger().debug(
                "Validating double parameter "
                    + name
                    + " (encoded in a string: "
                    + is_string
                    + ")");
        try {
            value = getDoubleValue(param, is_string);
        } catch (Exception e) {
            // Unable to parse double
            return new ValidatorActionHelper(value, ValidatorActionResult.ERROR);
        }
        if (value == null) {
            if (getLogger().isDebugEnabled())
                getLogger().debug("double parameter " + name + " is null");
            if (!nullable) {
                return new ValidatorActionHelper(value, ValidatorActionResult.ISNULL);
            } else {
                return new ValidatorActionHelper(dflt);
            }
        }
        if (constraints != null) {
            Double eq = getAttributeAsDouble(constraints, "equals-to", null);
            String eqp = constraints.getAttribute("equals-to-param", "");

            Double min = getAttributeAsDouble(conf, "min", null);
            min = getAttributeAsDouble(constraints, "min", min);

            Double max = getAttributeAsDouble(conf, "max", null);
            max = getAttributeAsDouble(constraints, "max", max);

            // Validate whether param is equal to constant
            if (eq != null) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug("Double parameter " + name + " should be equal to " + eq);

                if (!value.equals(eq)) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug("and it is not");
                    return new ValidatorActionHelper(value, ValidatorActionResult.NOMATCH);
                }
            }

            // Validate whether param is equal to another param
            // FIXME: take default value of param being compared with into
            // account?
            if (!"".equals(eqp)) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug(
                        "Double parameter " + name + " should be equal to " + params.get(eqp));
                // Request parameter is stored as string.
                // Need to convert it beforehand.
                try {
                    Double _eqp = new Double(Double.parseDouble((String) params.get(eqp)));
                    if (!value.equals(_eqp)) {
                        if (getLogger().isDebugEnabled())
                            getLogger().debug("and it is not");
                        return new ValidatorActionHelper(value, ValidatorActionResult.NOMATCH);
                    }
                } catch (NumberFormatException nfe) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug(
                            "Double parameter " + name + ": " + eqp + " is no double",
                            nfe);
                    return new ValidatorActionHelper(value, ValidatorActionResult.NOMATCH);
                }
            }

            // Validate wheter param is at least min
            if (min != null) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug("Double parameter " + name + " should be at least " + min);
                if (0 > value.compareTo(min)) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug("and it is not");
                    return new ValidatorActionHelper(value, ValidatorActionResult.TOOSMALL);
                }
            }

            // Validate wheter param is at most max
            if (max != null) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug("Double parameter " + name + " should be at most " + max);
                if (0 < value.compareTo(max)) {
                    if (getLogger().isDebugEnabled())
                        getLogger().debug("and it is not");
                    return new ValidatorActionHelper(value, ValidatorActionResult.TOOLARGE);
                }
            }
        }
        return new ValidatorActionHelper(value);
    }
17392#/**
     * Returns the parsed Double value.
     */
    private Double getDoubleValue(Object param, boolean is_string)
        throws ClassCastException, NumberFormatException {

        /* convert param to double */
        if (is_string) {
            String tmp = getStringValue(param);
            if (tmp == null) {
                return null;
            }
            return new Double(tmp);
        } else {
            return (Double) param;
        }
    }
17393#/**
     * Returns the parsed Long value.
     */
    private Long getLongValue(Object param, boolean is_string)
        throws ClassCastException, NumberFormatException {

        /* convert param to long */
        if (is_string) {
            String tmp = getStringValue(param);
            if (tmp == null) {
                return null;
            }
            return Long.decode(tmp);
        } else {
            return (Long) param;
        }
    }
17394#/**
     * Returns string
     * @throws ClassCastException if param is not a String object
     */
    private String getStringValue(Object param) throws ClassCastException {

        /* convert param to string */
        String value = (String) param;
        if (value != null && "".equals(value.trim())) {
            value = null;
        }
        return value;
    }
17395#/**
     * Returns the value of 'nullable' attribute from given configuration or
     * from given constraints, value present in constraints takes precedence,
     * false when attribute is not present in either of them.
     */
    private boolean getNullable(Configuration conf, Configuration cons) {
        /* check nullability */
        try {
            String tmp = cons.getAttribute("nullable");
            return BooleanUtils.toBoolean(tmp);
        } catch (Exception e) {
            String tmp = "no";
            if (conf != null) {
                tmp = conf.getAttribute("nullable", "no");
            }
            return BooleanUtils.toBoolean(tmp);
        }
    }
17396#/**
     * Returns the default value from given configuration or constraints.
     * Value present in constraints takes precedence, null is returned when no
     * default attribute is present in eiher of them.
     */
    private String getDefault(Configuration conf, Configuration cons) {
        String dflt = "";
        try {
            dflt = cons.getAttribute("default");
        } catch (Exception e) {
            if (conf != null)
                dflt = conf.getAttribute("default", "");
        }
        if ("".equals(dflt.trim())) {
            dflt = null;
        }
        return dflt;
    }
17397#/**
     * Replacement for Avalon's Configuration.getAttributeAsLong
     * because that one doesn't take <code>Long</code> but long and
     * thus won't take <code>null</code> as parameter value for
     * default.
     *
     * @param conf Configuration
     * @param name Parameter's name
     * @param dflt Default value
     * @return Parameter's value in <code>configuration</code> or
     * <code>dflt</code> if parameter is not set or couldn't be
     * converted to a <code>Long</code>
     * @throws NumberFormatException if conversion fails
     */
    private Long getAttributeAsLong(Configuration conf, String name, Long dflt)
        throws NumberFormatException {
        try {
            return new Long(conf.getAttribute(name));
        } catch (ConfigurationException e) {
            return dflt;
        }
    }
17398#/**
     * Addition to Avalon's Configuration.getAttributeAsFloat
     * because that one does only deal with <code>float</code>.
     *
     * @param conf Configuration
     * @param name Parameter's name
     * @param dflt Default value
     * @return Parameter's value in <code>configuration</code> or
     * <code>dflt</code> if parameter is not set or couldn't be
     * converted to a <code>Double</code>
     * @throws NumberFormatException if conversion fails
     */
    private Double getAttributeAsDouble(Configuration conf, String name, Double dflt)
        throws NumberFormatException {
        try {
            return new Double(conf.getAttribute(name));
        } catch (ConfigurationException e) {
            return dflt;
        }
    }
17399#/**
     * Create an index map to an array of configurations by their name
     * attribute. An empty array results in an empty map.
     * 
     * @param descriptor
     * @return index map or empty map
     */
    protected Map indexConfiguration(Configuration[] descriptor) {
        if (descriptor == null)
            return new HashMap();
        Map result = new HashMap((descriptor.length > 0) ? descriptor.length * 2 : 5);
        for (int i = descriptor.length - 1; i >= 0; i--) {
            String name = descriptor[i].getAttribute("name", "");
            result.put(name, descriptor[i]);
        }
        return result;
    }
17400#/**
     * Recursively resolve constraint sets that may "include" other constraint
     * sets and return a collection of all parameters to validate.
     * 
     * @param valsetstr
     * @param consets
     * @return collection of all parameters to validate
     */
    protected Collection resolveConstraints(String valsetstr, Map consets) {
        /* get the list of params to be validated */
        Vector rules = new Vector();
        Configuration[] set = ((Configuration) consets.get(valsetstr)).getChildren("validate");
        for (int j = 0; j < set.length; j++) {
            rules.add(set[j]);
        }
        set = ((Configuration) consets.get(valsetstr)).getChildren("include");
        for (int j = 0; j < set.length; j++) {
            Collection tmp = resolveConstraints(set[j].getAttribute("name", ""), consets);
            rules.addAll(tmp);
        }
        return rules;
    }
17401#/**
     * Checks the default setting for reloading the descriptor file.
     * @return boolean
     */
    protected boolean isDescriptorReloadable() {
        // read global parameter settings
        boolean reloadable = DESCRIPTOR_RELOADABLE_DEFAULT;
        if (this.settings.containsKey("reloadable")) {
            reloadable = Boolean.valueOf((String) this.settings.get("reloadable")).booleanValue();
        }
        return reloadable;
    }
17402#/**
     * Get list of params to be validated from sitemap parameter and
     * isolates the parameter names from the comma separated list.
     * 
     */
    protected Collection getSetOfParameterNamesFromSitemap(String valstr, Map desc) {
        String[] rparams = null;
        Set set = new HashSet(20);
        if (!"*".equals(valstr.trim())) {
            rparams = StringUtils.split(valstr, ","); 
            if (rparams != null) {
                for (int i = rparams.length - 1; i >= 0; i--) {
                    set.add(desc.get(rparams[i]));
                }
            }
        } else {
            // validate _all_ parameters
            set = desc.entrySet();
        }
        return set;
    }
17403#/**
     * Validate all parameters in the set with the constraints contained in
     * desc and the values from params. Validation details are in resultMap and 
     * successful validated parameters in resultMap. 
     * 
     * @param desc
     * @param actionMap
     * @param resultMap
     * @param set
     * @param params
     * @param isString
     * @return boolean all parameters ok or not
     */
    protected boolean validateSetOfParameters(
        Map desc,
        Map actionMap,
        Map resultMap,
        Collection set,
        Map params,
        boolean isString) {

        boolean allOK = true;
        ValidatorActionHelper result;
        String name;
        String rule = null;
        for (Iterator i = set.iterator(); i.hasNext();) {
            Configuration constr = (Configuration) i.next();
            name = constr.getAttribute("name", null);
            rule = constr.getAttribute("rule", name);
            result = validateParameter(name, rule, constr, desc, params, isString);
            if (!result.isOK()) {
                if (getLogger().isDebugEnabled())
                    getLogger().debug("Validation failed for parameter " + name);
                allOK = false;
            }
            actionMap.put(name, result.getObject());
            resultMap.put(name, result.getResult());
        }
        return allOK;
    }
17404#/**
     * Add success indicator to resulting maps and clear actionMap if unsuccessful.
     * Results are stored as request attributes.
     * 
     * @param objectModel the object model
     * @param actionMap a Map containing validated parameters
     * @param resultMap a Map containing validation results
     * @param allOK a boolean indicating if all validations were successful
     * @return actionMap if allOK or null otherwise
     */
    protected Map setResult(Map objectModel, Map actionMap, Map resultMap, boolean allOK) {
        if (!allOK) {
            // if any validation failed return an empty map
            actionMap = null;
            resultMap.put("*", ValidatorActionResult.ERROR);
            if (getLogger().isDebugEnabled())
                getLogger().debug("All form params validated. An error occurred.");
        } else {
            resultMap.put("*", ValidatorActionResult.OK);
            if (getLogger().isDebugEnabled())
                getLogger().debug("All form params successfully validated");
        }
        // store validation results in request attribute
        ObjectModelHelper.getRequest(objectModel).setAttribute(
            FORMVALIDATOR_PATH,
            resultMap);
        //return Collections.unmodifiableMap (actionMap);
        return actionMap;
    }
17405#/**
     * Load the descriptor containing the constraints.
     * @param resolver
     * @param parameters
     * @return a Configuration containing the constraints or null if a problem occurred.
     */
    protected Configuration getDescriptor(
        SourceResolver resolver,
        Map objectModel,
        Parameters parameters) {
        Configuration conf = null;
        try {
            conf =
                this.getConfiguration(
                    parameters.getParameter("descriptor", (String) this.settings.get("descriptor")),
                    resolver,
                    parameters.getParameterAsBoolean("reloadable", isDescriptorReloadable()));
        } catch (ConfigurationException e) {
            if (this.getLogger().isWarnEnabled())
                this.getLogger().warn("Exception reading descriptor: ", e);
        }
        return conf;
    }
17406#/**
     * Set up the complementary configuration file.  Please note that
     * multiple Actions can share the same configurations.  By using
     * this approach, we can limit the number of config files.
     * Also note that the configuration file does not have to be a file.
     *
     * Defaults to reload configuration file it has changed.
     */
    protected Configuration getConfiguration(String descriptor) throws ConfigurationException {
        boolean reloadable = DESCRIPTOR_RELOADABLE_DEFAULT;
        if (this.settings.containsKey("reloadable"))
            reloadable = Boolean.valueOf((String) this.settings.get("reloadable")).booleanValue();
        return this.getConfiguration(descriptor, null, reloadable);
    }
17407#/**
     * Set up the complementary configuration file.  Please note that
     * multiple Actions can share the same configurations.  By using
     * this approach, we can limit the number of config files.
     * Also note that the configuration file does not have to be a file.
     */
    protected Configuration getConfiguration(String descriptor, SourceResolver resolver, boolean reloadable) throws ConfigurationException {
        ConfigurationHelper conf = null;

        if (descriptor == null) {
            throw new ConfigurationException("The form descriptor is not set!");
        }

        synchronized (AbstractComplementaryConfigurableAction.configurations) {
            Source resource = null;
            try {
                resource = resolver.resolveURI(descriptor);
                conf = (ConfigurationHelper) AbstractComplementaryConfigurableAction.configurations.get(resource.getURI());
                if (conf == null || (reloadable && conf.lastModified != resource.getLastModified())) {
                    getLogger().debug("(Re)Loading " + descriptor);

                    if (conf == null) {
                        conf = new ConfigurationHelper();
                    }

                    SAXConfigurationHandler builder = new SAXConfigurationHandler();
                    SourceUtil.parse(this.manager, resource, builder);

                    conf.lastModified = resource.getLastModified();
                    conf.configuration = builder.getConfiguration();

                    AbstractComplementaryConfigurableAction.configurations.put(resource.getURI(), conf);
                } else {
                    getLogger().debug("Using cached configuration for " + descriptor);
                }
            } catch (Exception e) {
                getLogger().error("Could not configure Database mapping environment", e);
                throw new ConfigurationException("Error trying to load configurations for resource: "
                    + (resource == null ? "null" : resource.getURI()));
            } finally {
                resolver.release(resource);
            }
        }

        return conf.configuration;
    }
17408#/**
     * Alternate constructor to define a parent and initial <code>URL</code>
     * s.
     */
    public DefaultClassLoader(URL[] urls, List includePatterns, List excludePatterns, final ClassLoader parent) {
        this(urls, includePatterns, excludePatterns, parent, null);
    }
17409#/**
     * Alternate constructor to define a parent, initial <code>URL</code>s,
     * and a default <code>URLStreamHandlerFactory</code>.
     */
    public DefaultClassLoader(final URL[] urls, List includePatterns, List excludePatterns, ClassLoader parent, URLStreamHandlerFactory factory) {
        super(urls, parent, factory);
        this.includes = includePatterns;
        this.excludes = excludePatterns;
    }
17410#protected boolean tryClassHere(String name) {
        // don't include classes in the java or javax.servlet package
        if ( name != null && (name.startsWith("java.") || name.startsWith("javax.servlet") ) ) {
            return false;
        }
        // Scan includes, then excludes
        boolean tryHere;
        
        // If no explicit includes, try here
        if (this.includes == null || this.includes.size() == 0) {
            tryHere = true;
        } else {
            // See if it matches include patterns
            tryHere = false;
            for (int i = 0; i < this.includes.size(); i++) {
                if (WildcardMatcherHelper.match((String)includes.get(i), name) != null) {
                    tryHere = true;
                    break;
                }
            }
        }
        
        // Go through the exclusion list
        if (tryHere && this.excludes != null && this.excludes.size() > 0) {
            for (int i = 0; i < this.excludes.size(); i++) {
                if (WildcardMatcherHelper.match((String)excludes.get(i), name) != null) {
                    tryHere = false;
                    break;
                }
            }
        }
        
        return tryHere;
    }
17411#protected Class getClass(String name)
    throws ClassNotFoundException {
        return findClass(name);
    }
17412#/**
     * Loads the class from this <code>ClassLoader</class>.  If the
     * class does not exist in this one, we check the parent.  Please
     * note that this is the exact opposite of the
     * <code>ClassLoader</code> spec.  We use it to work around
     * inconsistent class loaders from third party vendors.
     *
     * @param     name the name of the class
     * @param     resolve if <code>true</code> then resolve the class
     * @return    the resulting <code>Class</code> object
     * @exception ClassNotFoundException if the class could not be found
     */
    public final Class loadClass(String name, boolean resolve) throws ClassNotFoundException {
        // First check if it's already loaded
        Class clazz = findLoadedClass(name);

        if (clazz == null) {
            
            final ClassLoader parent = getParent();

            if (tryClassHere(name)) {
                try {
                    clazz = this.getClass(name);
                } catch (ClassNotFoundException cnfe) {
                    if (parent == null) {
                        // Propagate exception
                        throw cnfe;                        
                    }
                }
            }
            
            if (clazz == null) {
                if (parent == null) {
                    throw new ClassNotFoundException(name);
                } else {
                    // Will throw a CFNE if not found in parent
                    clazz = parent.loadClass(name);
                }
            }
        }

        if (resolve) {
            resolveClass(clazz);
        }

        return clazz;
    }
17413#/**
     * Gets a resource from this <code>ClassLoader</class>.  If the
     * resource does not exist in this one, we check the parent.
     * Please note that this is the exact opposite of the
     * <code>ClassLoader</code> spec.  We use it to work around
     * inconsistent class loaders from third party vendors.
     *
     * @param name of resource
     */
    public final URL getResource(final String name) {
        URL resource = findResource(name);
        ClassLoader parent = this.getParent();
        if (resource == null && parent != null) {
            resource = parent.getResource(name);
        }

        return resource;
    }
17414#/**
     * Adds a new directory of class files.
     * 
     * @param file
     *            for jar or directory
     * @throws IOException
     */
    public final void addDirectory(File file) throws IOException {
        this.addURL(file.getCanonicalFile().toURL());
    }
17415#/**
     * Adds a new URL
     */

    public void addURL(URL url) {
        super.addURL(url);
    }
17416#protected ClassLoader createClassLoader(URL[] urls, List includePatterns, List excludePatterns, ClassLoader parent) {
        return new DefaultClassLoader(urls, includePatterns, excludePatterns, parent);
    }
17417#protected URL getUrl(ServletContext servletContext, String path) 
    throws MalformedURLException {
        // check for files
        final File file = this.getFile(path);
        if ( file != null ) {
            return file.toURL();
        }
        // check for absolut url
        if ( path.indexOf(":/") > 0 ) {
            return new URL(path);
        }
        return servletContext.getResource(this.getContextPath(path));
    }
17418#protected File getFile(String path) 
    throws MalformedURLException {
        // check for file url
        if ( path.startsWith("file:") ) {
            return new File(path.substring(5));
        }
        // check for absolut files on unix/windows
        if ( path.startsWith("/") || (path.length() > 2 && path.charAt(1) == ':' )) {
            return new File(path);
        }
        return null;
    }
17419#protected String getContextPath(String path) {
        if ( path.startsWith("context://") ) {
            return path.substring(9);
        }
        return "/" + path;        
    }
17420#public ClassLoader createClassLoader(ClassLoader              parent,
                                         ClassLoaderConfiguration config,
                                         ServletContext           servletContext)
    throws Exception {
        final List urlList = new ArrayList();
        Iterator i;
        // process class directories
        i = config.getClassDirectories().iterator();
        while ( i.hasNext() ) {
            // A class dir: simply add its URL
            final String directory = (String)i.next();
            URL url = this.getUrl(servletContext, directory);
            if ( url == null ) {
                throw new Exception("Directory not found for classpath: " + directory);
            }
            // TODO Should we somehow check if this is a dir?
            if ( !url.toExternalForm().endsWith("/") ) {
                url = new URL(url.toExternalForm() + "/");
            }
            urlList.add(url);
        }

        // process lib directories
        i = config.getLibDirectories().iterator();
        while ( i.hasNext() ) {
            // A lib dir: scan for all jar and zip it contains
            final String directory = (String)i.next();
            // Test for file
            final File libDir = this.getFile(directory);
            if ( libDir != null ) {
                if ( !libDir.exists() ) {
                    throw new Exception("Directory for lib class path does not exists: " + libDir);
                }
                if ( !libDir.isDirectory() ) {
                    throw new Exception("Configuration for lib class path is not a directory: " + libDir);
                }
                File[] libraries = libDir.listFiles(new JarFileFilter());
                // sort the files to provide a consistent search order
                Arrays.sort(libraries);
                for (int m = 0; m < libraries.length; m++) {
                    final URL lib = libraries[m].toURL();
                    urlList.add(lib);
                }                
            } else {
                // if this is an absolut url we can't handle it!
                if ( directory.indexOf(":/") > 0 ) {
                    throw new Exception("Can't handle absolute url as lib class path: " + directory);
                }
                final String contextPath = this.getContextPath(directory);
                final Set resources = servletContext.getResourcePaths(contextPath + '/');
                if ( resources != null ) {
                    // we add all urls into a temporary list first to sort them
                    // before we add them
                    final List temporaryList = new ArrayList();
                    final Iterator iter = resources.iterator();
                    while ( iter.hasNext() ) {
                        final String path = (String)iter.next();
                        if (path.endsWith(".jar") || path.endsWith(".zip")) {
                            temporaryList.add(servletContext.getResource(path));
                        }
                    }
                    // let's sort before adding
                    Collections.sort(temporaryList, new UrlComparator());
                    urlList.addAll(temporaryList);
                }
            }
        }

        URL[] urls = (URL[])urlList.toArray(new URL[urlList.size()]);
        
        return this.createClassLoader(urls, config.getIncludes(), config.getExcludes(), parent);
    }
17421#protected abstract ClassLoader createClassLoader(URL[] urls, List includePatterns, List excludePatterns, ClassLoader parent);
17422#public boolean accept(File dir, String name) {
            return name.endsWith(".zip") || name.endsWith(".jar");
        }
17423#public int compare(Object o1, Object o2) {
            if ( o1 instanceof URL && o2 instanceof URL ) {
                return ((URL)o1).toExternalForm().compareTo(((URL)o2).toExternalForm());
            }
            return 0;
        }
17424#/**
     * Construct a new <code>LifecycleHelper</code> that can be used repeatedly to
     * setup several components. 
     * <p>
     * <b>Note</b> : if a parameter is <code>null</code>,
     * the corresponding method isn't called (e.g. if <code>configuration</code> is
     * <code>null</code>, <code>configure()</code> isn't called).
     *
     * @param logger the <code>Logger</code> to pass to <code>LogEnabled</code>s, unless there is
     *        a <code>LogKitManager</code> and the configuration specifies a logger name.
     * @param context the <code>Context</code> to pass to <code>Contexutalizable</code>s.
     * @param serviceManager the service manager to pass to <code>Serviceable</code>s.
     * @param configuration the <code>Configuration</code> object to pass to new instances.
     */
    public LifecycleHelper(final Logger logger,
                           final Context context,
                           final ServiceManager serviceManager,
                           final Configuration configuration) {
        this.logger = logger;
        this.context = context;
        this.serviceManager = serviceManager;
        this.configuration = configuration;
    }
17425#/**
     * Setup a component, including initialization and start.
     *
     * @param component the component to setup.
     * @return the component passed in, to allow function chaining.
     * @throws Exception if something went wrong.
     */
    public Object setupComponent(Object component) throws Exception {
        return setupComponent(component, true);
    }
17426#/**
     * Setup a component, and optionnaly initializes (if it's <code>Initializable</code>)
     * and starts it (if it's <code>Startable</code>).
     *
     * @param component the component to setup.
     * @param initializeAndStart if true, <code>intialize()</code> and <code>start()</code>
     *        will be called.
     * @return the component passed in, to allow function chaining.
     * @throws Exception if something went wrong.
     */
    public Object setupComponent(Object component, boolean initializeAndStart)
    throws Exception {
        return setupComponent(component,
                              this.logger,
                              this.context,
                              this.serviceManager,
                              this.configuration,
                              initializeAndStart);
    }
17427#// --------------------------------------------------------- static

    public static Object setupComponent(final Object component,
                                        final Logger logger,
                                        final Context context,
                                        final ServiceManager serviceManager,
                                        final Configuration configuration)
    throws Exception {
        return setupComponent(component,
                              logger,
                              context,
                              serviceManager,
                              configuration,
                              true);
    }
17428#/**
     * Alternative setupComponent method that uses Commons Logging logger.
     */
    public static Object setupComponent(final Object component,
                                        final Log logger,
                                        final Context context,
                                        final ServiceManager serviceManager,
                                        final Configuration configuration)
    throws Exception {
        return setupComponent(component,
                              logger,
                              context,
                              serviceManager,
                              configuration,
                              true);
    }
17429#public static Object setupComponent(final Object component,
                                        final Logger logger,
                                        final Context context,
                                        final ServiceManager serviceManager,
                                        final Configuration configuration,
                                        final boolean initializeAndStart)
    throws Exception {
        if (component instanceof LogEnabled) {
            ((LogEnabled) component).enableLogging(logger);
        }

        if (context != null && component instanceof Contextualizable) {
            ((Contextualizable) component).contextualize(context);
        }

        if (serviceManager != null && component instanceof Serviceable) {
            ((Serviceable) component).service(serviceManager);
        } 
        
        if (configuration != null && component instanceof Configurable) {
            ((Configurable) component).configure(configuration);
        }

        if (configuration != null && component instanceof Parameterizable) {
            ((Parameterizable) component).parameterize(
                Parameters.fromConfiguration(configuration));
        }

        if (initializeAndStart && component instanceof Initializable) {
            ((Initializable) component).initialize();
        }

        if (initializeAndStart && component instanceof Startable) {
            ((Startable) component).start();
        }

        return component;
    }
17430#/**
     * Alternative setupComponent method that uses Commons Logging logger.
     */
    public static Object setupComponent(final Object component,
                                        final Log logger,
                                        final Context context,
                                        final ServiceManager manager,
                                        final Configuration configuration,
                                        final boolean initializeAndStart)
    throws Exception {
        if (component instanceof LogEnabled) {
            ((LogEnabled) component).enableLogging(new CLLoggerWrapper(logger));
        }

        if (context != null && component instanceof Contextualizable) {
            ((Contextualizable) component).contextualize(context);
        }

        if (manager != null && component instanceof Serviceable) {
            ((Serviceable) component).service(manager);
        }

        if (configuration != null && component instanceof Configurable) {
            ((Configurable) component).configure(configuration);
        }

        if (configuration != null && component instanceof Parameterizable) {
            ((Parameterizable) component).parameterize(
                Parameters.fromConfiguration(configuration));
        }

        if (initializeAndStart && component instanceof Initializable) {
            ((Initializable) component).initialize();
        }

        if (initializeAndStart && component instanceof Startable) {
            ((Startable) component).start();
        }

        return component;
    }
17431#/**
     * Decomission a component, by stopping (if it's <code>Startable</code>) and
     * disposing (if it's <code>Disposable</code>) a component.
     */
    public static void decommission(final Object component)
    throws Exception {
        if (component instanceof Startable) {
            ((Startable) component).stop();
        }

        dispose(component);
    }
17432#/**
     * Dispose a component if it's <code>Disposable</code>. Otherwhise, do nothing.
     */
    public static void dispose(final Object component) {
        if (component instanceof Disposable) {
            ((Disposable) component).dispose();
        }
    }
17433#private ContextHelper() {
        // Forbid instantiation
    }
17434#/**
     * Return the current request
     * @param context The component context
     * @return The request object
     */
    public static final Request getRequest(Context context) {
        // the request object is always present
        try {
            return (Request)context.get(CONTEXT_REQUEST_OBJECT);
        } catch (ContextException ce) {
            throw new ContextResourceNotFoundException("Unable to get the request object from the context.", ce);
        }
    }
17435#/**
     * Return the current response
     * @param context The component context
     * @return The response
     */
    public static final Response getResponse(Context context) {
        // the response object is always present
        try {
            return (Response)context.get(CONTEXT_RESPONSE_OBJECT);
        } catch (ContextException ce) {
            throw new ContextResourceNotFoundException("Unable to get the response object from the context.", ce);
        }
    }
17436#/**
     * Return the current object model
     * @param context The component context
     * @return The object model
     */
    public static final Map getObjectModel(Context context) {
        // the object model is always present
        try {
            return (Map)context.get(CONTEXT_OBJECT_MODEL);
        } catch (ContextException ce) {
            throw new ContextResourceNotFoundException("Unable to get the object model from the context.", ce);
        }
    }
17437#public ContextResourceNotFoundException(String message)
    {
        super(message, null);
    }
17438#public ContextResourceNotFoundException(String message, Throwable cause)
    {
        super(message, cause);
    }
17439#/**
     * Construct a new <code>InvalidContinuationException</code> instance.
     */
    public InvalidContinuationException(String message) {
        super(message);
    }
17440#/**
     * Construct a new <code>InvalidContinuationException</code> that references
     * a parent Exception.
     */
    public InvalidContinuationException(String message, Throwable t) {
        super(message, t);
    }
17441#/**
     * Set the unique ID for this interpreter, which can be used to distinguish user value scopes
     * attached to the session.
     */
    public void setInterpreterID(String interpreterID) {
        this.instanceID = interpreterID;
    }
17442#/**
     * Get the unique ID for this interpreter, which can be used to distinguish user value scopes
     * attached to the session.
     *
     * @return a unique ID for this interpreter
     */
    public String getInterpreterID() {
        return this.instanceID;
    }
17443#/**
     * @see org.apache.avalon.framework.configuration.Configurable#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration config) throws ConfigurationException {
        this.reloadScripts = config.getChild("reload-scripts").getValueAsBoolean(this.settings.isReloadingEnabled("flow"));
        this.checkTime = config.getChild("check-time").getValueAsLong(this.settings.getReloadDelay("flow"));
    }
17444#/**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager sm) throws ServiceException {
        this.manager = sm;
        this.continuationsMgr = (ContinuationsManager)sm.lookup(ContinuationsManager.ROLE);
        this.settings = (Settings)this.manager.lookup(Settings.ROLE);
        this.processInfoProvider = (ProcessInfoProvider)this.manager.lookup(ProcessInfoProvider.ROLE);
        this.newObjectModel = (ObjectModel)this.manager.lookup(ObjectModel.ROLE);
    }
17445#/**
     * @see org.apache.avalon.framework.context.Contextualizable#contextualize(org.apache.avalon.framework.context.Context)
     */
    public void contextualize(org.apache.avalon.framework.context.Context aContext)
    throws ContextException{
        this.avalonContext = aContext;
    }
17446#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        if ( this.manager != null ) {
            this.manager.release( this.continuationsMgr );
            this.manager.release( this.settings );
            this.manager.release( this.processInfoProvider );
            this.manager.release(this.newObjectModel);
            this.continuationsMgr = null;
            this.settings = null;
            this.processInfoProvider = null;
            this.newObjectModel = null;
            this.manager = null;
        }
    }
17447#/**
     * Registers a source file with the interpreter. Using this method
     * an implementation keeps track of all the script files which are
     * compiled. This allows them to reload the script files which get
     * modified on the file system.
     *
     * <p>The parsing/compilation of a script file by an interpreter
     * happens in two phases. In the first phase the file's location is
     * registered in the <code>needResolve</code> array.
     *
     * <p>The second is possible only when a Cocoon
     * <code>Environment</code> is passed to the Interpreter. This
     * allows the file location to be resolved using Cocoon's
     * <code>SourceFactory</code> class.
     *
     * <p>Once a file's location can be resolved, it is removed from the
     * <code>needResolve</code> array and placed in the
     * <code>scripts</code> hash table. The key in this hash table is
     * the file location string, and the value is a
     * DelayedRefreshSourceWrapper instance which keeps track of when
     * the file needs to re-read.
     *
     * @param source the location of the script
     *
     * @see org.apache.cocoon.environment.Environment
     * @see org.apache.cocoon.components.source.impl.DelayedRefreshSourceWrapper
     */
    public void register(String source) {
        synchronized (this) {
            needResolve.add(source);
        }
    }
17448#/**
     * @see org.apache.cocoon.components.flow.Interpreter#forwardTo(java.lang.String, java.lang.Object, org.apache.cocoon.components.flow.WebContinuation, org.apache.cocoon.environment.Redirector)
     */
    public void forwardTo(String uri, Object bizData,
                          WebContinuation continuation,
                          Redirector redirector)
    throws Exception {
        if (SourceUtil.indexOfSchemeColon(uri) == -1) {
            uri = "cocoon:/" + uri;
            final Map objectModel = this.processInfoProvider.getObjectModel();
            FlowHelper.setWebContinuation(objectModel, newObjectModel, continuation);
            FlowHelper.setContextObject(objectModel, newObjectModel, bizData);
            if (redirector.hasRedirected()) {
                throw new IllegalStateException("Pipeline has already been processed for this request");
            }
            // this is a hint for the redirector
            objectModel.put("cocoon:forward", "true");
            redirector.redirect(false, uri);
        } else {
            throw new Exception("uri is not allowed to contain a scheme (cocoon:/ is always automatically used)");
        }
    }
17449#/**
     * @see org.apache.cocoon.components.flow.Interpreter#getScriptExtension()
     */
    public String getScriptExtension() {
        return null;
    }
17450#public WebContinuationDataBean(WebContinuation wc) {
        this.wc = wc;
        for (Iterator it = wc.getChildren().iterator(); it.hasNext();) {
            WebContinuationDataBean child = new WebContinuationDataBean(
                    (WebContinuation) it.next());
            this._children.add(child);
        }
    }
17451#public String getId() {
        return wc.getId();
    }
17452#public String getLastAccessTime() {
        return formatter.format(new Date(wc.getLastAccessTime()));
    }
17453#public String getInterpreterId() {
        return wc.getInterpreterId();
    }
17454#public String getTimeToLiveInMinutes() {
        return Long.toString(wc.getTimeToLive() / 1000 / 60);
    }
17455#public String getTimeToLive() {
        return Long.toString(wc.getTimeToLive());
    }
17456#public String getExpireTime() {
        return formatter.format(new Date(wc.getLastAccessTime()
                + wc.getTimeToLive()));
    }
17457#public String hasExpired() {
        if ((wc.getLastAccessTime() + wc.getTimeToLive()) < System
                .currentTimeMillis()) {
            return HAS_EXPIRED_YES;
        }
        return HAS_EXPIRED_NO;

    }
17458#public String getType() {
        if (wc.getUserObject().getClass().getName().indexOf(
                "FOM_WebContinuation") > -1) {
            return TYPE_FLOWSCRIPT;
        }
        return TYPE_JAVAFLOW;
    }
17459#public List get_children() {
        return this._children;
    }
17460#/**
     * Get the flow context object associated with the current request
     *
     * @param objectModel The Cocoon Environment's object model
     * @return The context object 
     */
    public final static Object getContextObject(Map objectModel) {
        return objectModel.get(CONTEXT_OBJECT);
    }
17461#/**
     * Get the web continuation associated with the current request
     *
     * @param objectModel The Cocoon Environment's object model
     * @return The web continuation
     */
    public final static WebContinuation getWebContinuation(Map objectModel) {
        return (WebContinuation)objectModel.get(CONTINUATION_OBJECT);
    }
17462#/**
     * Set the web continuation associated with the current request
     *
     * @param objectModel The Cocoon Environment's object model
     * @param newObjectModel TODO
     * @param kont The web continuation
     */
    public final static void setWebContinuation(Map objectModel,
                                          ObjectModel newObjectModel, WebContinuation kont) {
        objectModel.put(CONTINUATION_OBJECT, kont);
        newObjectModel.putAt("cocoon/continuation", kont);
    }
17463#/**
     * Set the flow context object associated with the current request
     *
     * @param objectModel The Cocoon Environment's object model
     * @param newObjectModel TODO
     * @param obj The context object 
     */
    public final static void setContextObject(Map objectModel, ObjectModel newObjectModel, Object obj) {
        objectModel.put(CONTEXT_OBJECT, obj);
        newObjectModel.put(ObjectModel.CONTEXTBEAN, obj);
        newObjectModel.fillContext();
    }
17464#public ContinuationsManagerImpl() throws Exception {
        try {
            random = SecureRandom.getInstance("SHA1PRNG");
        } catch(java.security.NoSuchAlgorithmException nsae) {
            // Maybe we are on IBM's SDK
            random = SecureRandom.getInstance("IBMSecureRandom");
        }
        random.setSeed(System.currentTimeMillis());
        bytes = new byte[CONTINUATION_ID_LENGTH];
    }
17465#public void service(ServiceManager manager) throws ServiceException {
        this.serviceManager = manager;
    }
17466#public void configure(Configuration config) {
        this.defaultTimeToLive = config.getAttributeAsInteger("time-to-live", (3600 * 1000));
        this.bindContinuationsToSession = config.getAttributeAsBoolean( "session-bound-continuations", false );
        // create a global ContinuationsHolder if this the "session-bound-continuations" parameter is set to false
        if (!this.bindContinuationsToSession) {
            this.continuationsHolder = new WebContinuationsHolder();
        }
        
        final Configuration expireConf = config.getChild("expirations-check");
        final long initialDelay = expireConf.getChild("offset", true).getValueAsLong(180000);
        this.expirationCheckInterval = expireConf.getChild("period", true).getValueAsLong(180000);
        try {
            final RunnableManager runnableManager = (RunnableManager)serviceManager.lookup(RunnableManager.ROLE);
            runnableManager.execute( new Runnable() {
                    public void run()
                    {
                        expireContinuations();
                    }
                }, initialDelay, expirationCheckInterval);
            serviceManager.release(runnableManager);
        } catch (Exception e) {
            getLogger().warn("Could not enqueue continuations expiration task. " +
                             "Continuations will not automatically expire.", e);
        }
    }
17467#public WebContinuation createWebContinuation(Object kont,
                                                 WebContinuation parent,
                                                 int timeToLive,
                                                 String interpreterId, 
                                                 ContinuationsDisposer disposer) {
        int ttl = (timeToLive == 0 ? defaultTimeToLive : timeToLive);

        WebContinuation wk = generateContinuation(kont, parent, ttl, interpreterId, disposer);

        if (parent == null) {
            forest.add(wk);
        } else {
            handleParentContinuationExpiration(parent);
        }

        handleLeafContinuationExpiration(wk);

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("WK: Created continuation " + wk.getId());
        }

        return wk;
    }
17468#/**
     * When a new continuation is created in @link #createWebContinuation(Object, WebContinuation, int, String, ContinuationsDisposer),
     * it is registered in the expiration set in order to be evaluated by the invalidation mechanism.
     */
    protected void handleLeafContinuationExpiration(WebContinuation wk) {
        expirations.add(wk);
    }
17469#/**
     * When a new continuation is created in @link #createWebContinuation(Object, WebContinuation, int, String, ContinuationsDisposer),
     * its parent continuation is removed from the expiration set. This way only leaf continuations are part of
     * the expiration set.
     */
    protected void handleParentContinuationExpiration(WebContinuation parent) {
        if (parent.getChildren().size() < 2) {
            expirations.remove(parent);
        }
    }
17470#/**
     * Get a list of all web continuations (data only)
     */
    public List getWebContinuationsDataBeanList() {
        List beanList = new ArrayList();
        for(Iterator it = this.forest.iterator(); it.hasNext();) {
            beanList.add(new WebContinuationDataBean((WebContinuation) it.next()));
        }
        return beanList;
    }
17471#public WebContinuation lookupWebContinuation(String id, String interpreterId) {
        // REVISIT: Is the following check needed to avoid threading issues:
        // return wk only if !(wk.hasExpired) ?
        WebContinuationsHolder continuationsHolder = lookupWebContinuationsHolder(false);
        if (continuationsHolder == null)
            return null;
        
        WebContinuation kont = continuationsHolder.get(id);
        if (kont == null)
            return null;
            
        if (!kont.interpreterMatches(interpreterId)) {
            getLogger().error(
                    "WK: Continuation (" + kont.getId()
                            + ") lookup for wrong interpreter. Bound to: "
                            + kont.getInterpreterId() + ", looked up for: "
                            + interpreterId);
            return null;
        }
        return kont;
    }
17472#/**
     * Create <code>WebContinuation</code> and generate unique identifier for
     * it. The identifier is generated using a cryptographically strong
     * algorithm to prevent people to generate their own identifiers.
     * 
     * <p>
     * It has the side effect of interning the continuation object in the
     * <code>idToWebCont</code> hash table.
     * 
     * @param kont
     *            an <code>Object</code> value representing continuation
     * @param parent
     *            value representing parent <code>WebContinuation</code>
     * @param ttl
     *            <code>WebContinuation</code> time to live
     * @param interpreterId
     *            id of interpreter invoking continuation creation
     * @param disposer
     *            <code>ContinuationsDisposer</code> instance to use for
     *            cleanup of the continuation.
     * @return the generated <code>WebContinuation</code> with unique
     *         identifier
     */
    protected WebContinuation generateContinuation(Object kont,
                                                 WebContinuation parent,
                                                 int ttl,
                                                 String interpreterId,
                                                 ContinuationsDisposer disposer) {

        char[] result = new char[bytes.length * 2];
        WebContinuation wk;
        WebContinuationsHolder continuationsHolder = lookupWebContinuationsHolder(true);
        while (true) {
            random.nextBytes(bytes);

            for (int i = 0; i < CONTINUATION_ID_LENGTH; i++) {
                byte ch = bytes[i];
                result[2 * i] = Character.forDigit(Math.abs(ch >> 4), 16);
                result[2 * i + 1] = Character.forDigit(Math.abs(ch & 0x0f), 16);
            }

            final String id = new String(result);
            synchronized (continuationsHolder) {
                if (!continuationsHolder.contains(id)) {
                    if (this.bindContinuationsToSession)
                        wk = new HolderAwareWebContinuation(id, kont, parent,
                                                            ttl, interpreterId, disposer,
                                                            continuationsHolder);
                    else
                        wk = new WebContinuation(id, kont, parent, ttl,
                                                 interpreterId, disposer);
                    continuationsHolder.addContinuation(wk);
                    break;
                }
            }
        }

        wk.setLogger(getLogger());
        return wk;
    }
17473#public void invalidateWebContinuation(WebContinuation wk) {
        WebContinuationsHolder continuationsHolder = lookupWebContinuationsHolder(false);
        if (!continuationsHolder.contains(wk)) {
            //TODO this looks like a security breach - should we throw?
            return;
        }
        _detach(wk);
        _invalidate(continuationsHolder, wk);
    }
17474#private void _invalidate(WebContinuationsHolder continuationsHolder, WebContinuation wk) {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("WK: Manual expire of continuation " + wk.getId());
        }
        disposeContinuation(continuationsHolder, wk);
        expirations.remove(wk);

        // Invalidate all the children continuations as well
        List children = wk.getChildren();
        int size = children.size();
        for (int i = 0; i < size; i++) {
            _invalidate(continuationsHolder, (WebContinuation) children.get(i));
        }
    }
17475#/**
     * Detach this continuation from parent. This method removes
     * continuation from {@link #forest} set, or, if it has parent,
     * from parent's children collection.
     *
     * @param wk Continuation to detach from parent.
     */
    protected void _detach(WebContinuation wk) {
        WebContinuation parent = wk.getParentContinuation();
        if (parent == null) {
            forest.remove(wk);
        } else 
            wk.detachFromParent();
    }
17476#/**
     * Makes the continuation inaccessible for lookup, and triggers possible needed
     * cleanup code through the ContinuationsDisposer interface.
     * @param continuationsHolder
     *
     * @param wk the continuation to dispose.
     */
    protected void disposeContinuation(WebContinuationsHolder continuationsHolder, WebContinuation wk) {
        continuationsHolder.removeContinuation(wk);
        wk.dispose();
    }
17477#/**
     * Removes an expired leaf <code>WebContinuation</code> node
     * from its continuation tree, and recursively removes its
     * parent(s) if it they have expired and have no (other) children.
     * @param continuationsHolder
     *
     * @param wk <code>WebContinuation</code> node
     */
    protected void removeContinuation(WebContinuationsHolder continuationsHolder,
            WebContinuation wk) {
        if (wk.getChildren().size() != 0) {
            return;
        }

        // remove access to this contination
        disposeContinuation(continuationsHolder, wk);
        _detach(wk);

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("WK: Deleted continuation: " + wk.getId());
        }

        // now check if parent needs to be removed.
        WebContinuation parent = wk.getParentContinuation();
        if (null != parent && parent.hasExpired()) {
            //parent must have the same continuations holder, lookup not needed
            removeContinuation(continuationsHolder, parent);
        }
    }
17478#/**
     * Dump to Log file the current contents of
     * the expirations <code>SortedSet</code>
     */
    protected void displayExpireSet() {
        StringBuffer wkSet = new StringBuffer("\nWK; Expire set size: " + expirations.size());
        Iterator i = expirations.iterator();
        while (i.hasNext()) {
            final WebContinuation wk = (WebContinuation) i.next();
            final long lat = wk.getLastAccessTime() + wk.getTimeToLive();
            wkSet.append("\nWK: ")
                    .append(wk.getId())
                    .append(" ExpireTime [");

            if (lat < System.currentTimeMillis()) {
                wkSet.append("Expired");
            } else {
                wkSet.append(lat);
            }
            wkSet.append("]");
        }

        getLogger().debug(wkSet.toString());
    }
17479#/**
     * Dump to Log file all <code>WebContinuation</code>s
     * in the system
     */
    public void displayAllContinuations() {
        final Iterator i = forest.iterator();
        while (i.hasNext()) {
            ((WebContinuation) i.next()).display();
        }
    }
17480#/**
     * Remove all continuations which have already expired.
     */
    protected void expireContinuations() {
        long now = 0;
        if (getLogger().isDebugEnabled()) {
            now = System.currentTimeMillis();

            /* Continuations before clean up:
            getLogger().debug("WK: Forest before cleanup: " + forest.size());
            displayAllContinuations();
            displayExpireSet();
            */
        }

        // Clean up expired continuations
        int count = 0;
        WebContinuation wk;
        Iterator i = expirations.iterator();
        while (i.hasNext() && ((wk = (WebContinuation) i.next()).hasExpired())) {
            i.remove();
            WebContinuationsHolder continuationsHolder;
            if (wk instanceof HolderAwareWebContinuation)
                continuationsHolder = ((HolderAwareWebContinuation) wk).getContinuationsHolder();
            else
                continuationsHolder = this.continuationsHolder;
            removeContinuation(continuationsHolder, wk);
            count++;
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("WK Cleaned up " + count + " continuations in " +
                              (System.currentTimeMillis() - now));

            /* Continuations after clean up:
            getLogger().debug("WK: Forest after cleanup: " + forest.size());
            displayAllContinuations();
            displayExpireSet();
            */
        }
    }
17481#/**
     * Method used by WebContinuationsHolder to notify the continuations manager
     * about session invalidation. Invalidates all continuations held by passed
     * continuationsHolder.
     */
    protected void invalidateContinuations(
            WebContinuationsHolder continuationsHolder) {
        // TODO: this avoids ConcurrentModificationException, still this is not
        // the best solution and should be changed
        Object[] continuationIds = continuationsHolder.getContinuationIds()
                .toArray();
        
        for (int i = 0; i < continuationIds.length; i++) {
            WebContinuation wk = continuationsHolder.get(continuationIds[i]);
            if (wk != null) {
                _detach(wk);
                _invalidate(continuationsHolder, wk);
            }
        }
    }
17482#/**
     * Lookup a proper web continuations holder. 
     * @param createNew
     *            should the manager create a continuations holder in session
     *            when none found?
     */
    public WebContinuationsHolder lookupWebContinuationsHolder(boolean createNew) {
        //there is only one holder if continuations are not bound to session
        if (!this.bindContinuationsToSession)
            return this.continuationsHolder;
        
        //if continuations bound to session lookup a proper holder in the session
        Map objectModel = ContextHelper.getObjectModel(this.context);
        Request request = ObjectModelHelper.getRequest(objectModel);

        if (!createNew && request.getSession(false) == null)
            return null;

        HttpSession session = request.getSession(true);
        WebContinuationsHolder holder = 
            (WebContinuationsHolder) session.getAttribute(
                    WebContinuationsHolder.CONTINUATIONS_HOLDER);
        if (!createNew)
            return holder;

        if (holder != null)
            return holder;

        holder = new WebContinuationsHolder();
        session.setAttribute(WebContinuationsHolder.CONTINUATIONS_HOLDER,
                holder);
        return holder;
    }
17483#public void contextualize(Context context) throws ContextException {
        this.context = context;        
    }
17484#public WebContinuation get(Object id) {
            return (WebContinuation) this.holder.get(id);
        }
17485#public void addContinuation(WebContinuation wk) {
            this.holder.put(wk.getId(), wk);
        }
17486#public void removeContinuation(WebContinuation wk) {
            this.holder.remove(wk.getId());
        }
17487#public Set getContinuationIds() {
            return holder.keySet();
        }
17488#public boolean contains(String continuationId) {
            return this.holder.containsKey(continuationId);
        }
17489#public boolean contains(WebContinuation wk) {
            return contains(wk.getId());
        }
17490#public void valueBound(HttpSessionBindingEvent event) {
        }
17491#public void valueUnbound(HttpSessionBindingEvent event) {
            invalidateContinuations(this);
        }
17492#public HolderAwareWebContinuation(String id,
                                          Object continuation,
                                          WebContinuation parentContinuation,
                                          int timeToLive,
                                          String interpreterId,
                                          ContinuationsDisposer disposer,
                                          WebContinuationsHolder continuationsHolder) {
            super(id, continuation, parentContinuation, timeToLive, interpreterId, disposer);
            this.continuationsHolder = continuationsHolder;
        }
17493#public WebContinuationsHolder getContinuationsHolder() {
            return continuationsHolder;
        }
17494#//retain comparation logic from parent
        public int compareTo(Object other) {
            return super.compareTo(other);
        }
17495#public InputModuleInitializationException(String message)
    {
        super(message, null);
    }
17496#public InputModuleInitializationException(String message, Throwable cause)
    {
        super(message, cause);
    }
17497#/**
     * Create empty jxpath configuration
     */
    public JXPathHelperConfiguration() {
        this.lenient = true;
    }
17498#/**
     * Create root jxpath configuration
     */
    public JXPathHelperConfiguration(Configuration config)
    throws ConfigurationException {
        this.lenient = config.getChild("lenient").getValueAsBoolean(true);
        this.library = new FunctionLibrary();
        setup(config);

        // the following is necessary to be able to use methods on objects without
        // explicitely registering extension functions (see PackageFunctions javadoc)
        this.library.addFunctions(new PackageFunctions("", null));
    }
17499#/**
     * Create child jxpath configuration
     */
    public JXPathHelperConfiguration(JXPathHelperConfiguration global, Configuration config)
    throws ConfigurationException {
        this.lenient = global.lenient;
        this.library = new FunctionLibrary();
        this.library.addFunctions(global.getLibrary());
        if (global.getNamespaces() != null) {
            this.namespaces = new HashMap(global.getNamespaces());
        }
        setup(config);
    }
17500#public boolean isLenient() {
        return this.lenient;
    }
17501#public FunctionLibrary getLibrary() {
        return this.library;
    }
17502#public Map getNamespaces() {
        return this.namespaces;
    }
17503#private void setup(Configuration config)
    throws ConfigurationException {
        getFunctions(config);
        getPackages(config);
        getNamespaces(config);
    }
17504#/**
     * Register all extension functions listed in the configuration
     * through <code>&lt;function name="fully.qualified.Class"
     * prefix="prefix"/&gt;</code> in the given FunctionLibrary.
     *
     * @param conf a <code>Configuration</code> value
     */
    private void getFunctions(Configuration conf) {

        Configuration[] children = conf.getChildren("function");
        int i = children.length;
        while (i-- > 0) {
            String clazzName = children[i].getAttribute("name", null);
            String prefix = children[i].getAttribute("prefix", null);
            if (clazzName != null && prefix != null) {
                try {
                    Class clazz = Class.forName(clazzName);
                    this.library.addFunctions(new ClassFunctions(clazz, prefix));
                } catch (ClassNotFoundException cnf) {
                    // ignore
                }
            }
        }
    }
17505#/**
     * Register all extension packages listed in the configuration
     * through <code>&lt;package name="fully.qualified.package"
     * prefix="prefix"/&gt;</code> in the given FunctionLibrary.
     *
     * @param conf a <code>Configuration</code> value
     */
    private void getPackages(Configuration conf) {

        Configuration[] children = conf.getChildren("package");
        int i = children.length;
        while (i-- > 0) {
            String packageName = children[i].getAttribute("name", null);
            String prefix = children[i].getAttribute("prefix", null);
            if (packageName != null && prefix != null) {
                this.library.addFunctions(new PackageFunctions(packageName, prefix));
            }
        }
    }
17506#/**
     * Register all namespaces listed in the configuration
     * through <code>&lt;namespace uri="uri:foo"
     * prefix="bar"/&gt;</code> in the configuration.
     *
     * @param conf a <code>Configuration</code> value
     */
    private void getNamespaces(Configuration conf)
    throws ConfigurationException {

        Configuration[] children = conf.getChildren("namespace");
        int i = children.length;
        if (i > 0) {
            this.namespaces = new HashMap(i + 2);
        }
        while (i-- > 0) {
            String uri = children[i].getAttribute("uri");
            String prefix = children[i].getAttribute("prefix");
            if (uri != null && prefix != null) {
                this.namespaces.put(prefix, uri);
            }
        }
    }
17507#public ModuleHolder() {
        super();
    }
17508#public ModuleHolder(String name, Configuration config) {
        this();
        this.name = name;
        this.config = config;
    }
17509#public ModuleHolder(String name, Configuration config, InputModule input) {
        this(name, config);
        this.input = input;
    }
17510#private JXPathHelper() {
        // no instances allowed
    }
17511#/**
     * Configure component. Preprocess list of packages, functions
     * and namespaces to add to the JXPath context later.
     *
     * This method used in both AbstractJXPathModule and JXPathMetaModule
     * to configure JXPath.
     *
     * @param config a <code>Configuration</code> value.
     * @return The JXPathHelperConfiguration.
     * @exception ConfigurationException if an error occurs
     */
    public static JXPathHelperConfiguration setup(Configuration config)
    throws ConfigurationException {

        return new JXPathHelperConfiguration(config);
    }
17512#/**
     * Actually add global functions and packages as well as those
     * listed in the configuration object.
     *
     * @param setup The JXPathHelperConfiguration.
     * @param context a <code>JXPathContext</code> value.
     * @param conf a <code>Configuration</code> value holding local.
     * packages and functions.
     */
    private static void setup(JXPathHelperConfiguration setup, JXPathContext context, Configuration conf)
    throws ConfigurationException {

        // Create local config (if necessary)
        JXPathHelperConfiguration local = conf == null ? setup : new JXPathHelperConfiguration(setup, conf);

        // Setup context with local config
        context.setLenient(setup.isLenient());
        context.setFunctions(local.getLibrary());
        if (local.getNamespaces() != null) {
            for (Iterator i = local.getNamespaces().entrySet().iterator(); i.hasNext();) {
                final Map.Entry entry = (Map.Entry) i.next();
                context.registerNamespace((String) entry.getKey(), (String) entry.getValue());
            }
        }
    }
17513#/**
     * Return the String value of the attribute or element identified in the XPath expression.
     * @param name The XPath expression
     * @param modeConf The Configuration.
     * @param setup The JXPathHelperConfiguration.
     * @param contextObj The root Element to search.
     * @return The String value of the attribute or element identified.
     * @throws ConfigurationException if an Exception occurs.
     */
    public static String getAttributeValue(String name,
                                           Configuration modeConf,
                                           JXPathHelperConfiguration setup,
                                           Object contextObj)
    throws ConfigurationException {

        if (contextObj == null) {
            return null;
        }

        try {
            JXPathContext jxContext = JXPathContext.newContext(contextObj);
            setup(setup, jxContext, modeConf);
            Object obj = jxContext.getValue(name);
            if (obj != null) {
                return obj.toString();
            }
            return null;
        } catch (Exception e) {
            throw new ConfigurationException("Module does not support <" + name + ">" + "attribute.", e);
        }
    }
17514#/**
     * Return the String value of the attribute or the Node found using the XPath expression.
     * @param name The XPath expression
     * @param modeConf The Configuration.
     * @param setup The JXPathHelperConfiguration.
     * @param contextObj The root Element to search.
     * @return The String value of the attribute or the Element located.
     * @throws ConfigurationException if an Exception occurs.
     */
    public static Object getAttribute(String name,
                                      Configuration modeConf,
                                      JXPathHelperConfiguration setup,
                                      Object contextObj)
    throws ConfigurationException {

        if (contextObj == null) {
            return null;
        }

        try {
            JXPathContext jxContext = JXPathContext.newContext(contextObj);
            setup(setup, jxContext, modeConf);
            return jxContext.selectSingleNode(name);
        } catch (Exception e) {
            throw new ConfigurationException("Module does not support <" + name + ">" + "attribute.", e);
        }
    }
17515#public static Object[] getAttributeValues(String name,
                                              Configuration modeConf,
                                              JXPathHelperConfiguration setup,
                                              Object contextObj)
    throws ConfigurationException {

        if (contextObj == null) {
            return null;
        }

        try {
            JXPathContext jxContext = JXPathContext.newContext(contextObj);
            setup(setup, jxContext, modeConf);

            List values = null;
            Iterator i = jxContext.iterate(name);
            if (i.hasNext()) {
                values = new LinkedList();
            }
            while (i.hasNext()) {
                values.add(i.next());
            }
            Object[] obj = null;
            if (values != null) {
                obj = values.toArray();
                if (obj.length == 0) {
                    obj = null;
                }
            }
            return obj;
        } catch (Exception e) {
            throw new ConfigurationException("Module does not support <" + name + ">" + "attribute.", e);
        }
    }
17516#public static Iterator getAttributeNames(JXPathHelperConfiguration setup, Object contextObj)
    throws ConfigurationException {

        if (contextObj == null) {
            return null;
        }

        try {
            JXPathBeanInfo info = JXPathIntrospector.getBeanInfo(contextObj.getClass());
            java.beans.PropertyDescriptor[] properties = info.getPropertyDescriptors();

            List names = new LinkedList();
            for (int i = 0; i < properties.length; i++) {
                names.add(properties[i].getName());
            }

            return names.listIterator();
        } catch (Exception e) {
            throw new ConfigurationException("Error retrieving attribute names for class: " + contextObj.getClass(), e);
        }
    }
17517#public IteratorHelper( Enumeration e ) { this.enumeration = e; }
17518#public boolean hasNext() { return this.enumeration.hasMoreElements(); }
17519#public Object next() { return this.enumeration.nextElement(); }
17520#/** ignored */
    public void remove() {}
17521#/**
     * Configures the database access helper.
     *
     * Takes all elements nested in component declaration and stores
     * them as key-value pairs in <code>settings</code>. Nested
     * configuration option are not catered for. This way global
     * configuration options can be used.
     *
     * For nested configurations override this function.
     * */
    public void configure(Configuration conf) throws ConfigurationException {
        Configuration[] parameters = conf.getChildren();
        this.settings = new HashMap(parameters.length);
        for (int i = 0; i < parameters.length; i++) {
            String key = parameters[i].getName();
            String val = parameters[i].getValue("");
            this.settings.put (key, val);
        }
    }
17522#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        // Purposely empty so that we don't need to implement it in every
        // class.
    }
17523#//
    // you need to implement at least one of the following two methods
    // since the ones below have a cyclic dependency!
    // 
    
    /**
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttribute(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object getAttribute(String name, Configuration modeConf, Map objectModel) throws ConfigurationException {
        Object[] result = this.getAttributeValues(name, modeConf, objectModel);
        return (result == null ? null : result[0]);
    }
17524#/**
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues(String name, Configuration modeConf, Map objectModel)
        throws ConfigurationException {
        Object result = this.getAttribute(name, modeConf, objectModel);
        return (result == null ? null : new Object[] {result});
    }
17525#/**
     * @see org.apache.cocoon.components.modules.input.InputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Iterator getAttributeNames(Configuration modeConf, Map objectModel) throws ConfigurationException {
        return EmptyIterator.INSTANCE;
    }
17526#public void service(ServiceManager manager) throws ServiceException {
        this.manager=manager;
    }
17527#/**
     * Initialize the meta module with exactly one other input
     * module. Since "meta" modules require references to components
     * of the same role, initialization cannot be done in initialize()
     * when also implementing ThreadSafe since at that point the
     * component selector is not yet initialized it would trigger the
     * creation of a new one resulting in an endless loop of
     * initializations. Therefore, every module needs to call this
     * method when it first requires access to another module if the
     * module itself has not been initialized. Override this method
     * and dispose() to keep references to more than one module.
     */
    public synchronized void lazy_initialize() {
        try {
            // obtain input modules
            if (!this.initialized) {
                this.inputSelector = (ServiceSelector)this.manager.lookup(INPUT_MODULE_SELECTOR); 
                if (this.defaultInput != null) {
                    this.input = obtainModule(this.defaultInput);
                }
                
                this.initialized = true;
            }
        } catch (Exception e) {
            if (getLogger().isWarnEnabled()) 
                getLogger().error("A problem occurred setting up input modules :'" + e.getMessage(), e);
        }
    }
17528#/**
     * Dispose exactly one cached InputModule. To work on more than
     * one, override this method and initialize().
     */
    public void dispose() {
        if (this.inputSelector != null) {
            this.inputSelector.release(this.input);
            this.input = null;
            this.manager.release(this.inputSelector);
            this.inputSelector = null;
        }
        this.manager = null;
    }
17529#/**
     * Obtain a permanent reference to an InputModule.
     */
    protected InputModule obtainModule(String type) {
        // check whether the input selector has been looked up yet
        // the contract of this class requries this, but we check anyway
        if ( this.inputSelector == null ) {
            if (getLogger().isWarnEnabled()) {
                getLogger().warn("A problem occurred setting up '" + type
                                 +"': Selector is null");
            }
            return null;
        }
        InputModule module = null;
        try {
            if ( this.inputSelector.isSelectable(type) ){
                
                module = (InputModule) inputSelector.select(type);
                
                if (!(module instanceof ThreadSafe) ) {
                    if (getLogger().isWarnEnabled()) {
                        getLogger().warn("A problem occurred setting up '" + type
                                        +"': Component is not thread safe.");
                    }
                    this.inputSelector.release(module);
                    module = null;
                }
            } else {
                if (getLogger().isWarnEnabled()) {
                    getLogger().warn("A problem occurred setting up '" + type
                                     +"': Component is unknown.");
                }
            }
            
        } catch (ServiceException ce) {
            if (getLogger().isWarnEnabled()) {
                getLogger().warn("Could not obtain InputModules: "+ce.getMessage(), ce);
            }
        }

        return module;
    }
17530#/**
     * release a permanent reference to an InputModule.
     */
    protected void releaseModule(InputModule module) {
        if (module != null) {
            this.inputSelector.release(module);
        }
    }
17531#/**
     * Get names of available attributes in the specified (usually statically
     * assigned) Input Module.
     * @see InputModule#getAttributeNames(Configuration, Map)
     */
    protected Iterator getNames(Map objectModel, 
                                InputModule staticMod, String staticModName, Configuration staticModConf) 
        throws ConfigurationException {

        return (Iterator) this.get(OP_NAMES, null, objectModel, staticMod, staticModName, staticModConf, null, null, null);
    }
17532#/**
     * Get names of available attributes in one of the specified Input Modules
     * (static or dynamic, dynamic preferred).  Dynamic IM may be
     * <code>null</code>.
     * @see InputModule#getAttributeNames(Configuration, Map)
     */
     protected Iterator getNames(Map objectModel, 
                                InputModule staticMod, String staticModName, Configuration staticModConf,
                                InputModule dynamicMod, String dynamicModName, Configuration dynamicModConf)
        throws ConfigurationException {

        return (Iterator) this.get(OP_NAMES, null, objectModel, staticMod, staticModName, staticModConf, dynamicMod, dynamicModName, dynamicModConf);
    }
17533#protected Object getValue(String attr, Map objectModel, ModuleHolder holder) throws ConfigurationException{
        return this.getValue(attr, objectModel, holder.input, holder.name, holder.config);
    }
17534#protected Object getValue(String attr, Map objectModel, ModuleHolder staticHolder, ModuleHolder dynamicHolder) throws ConfigurationException{
        return this.getValue(attr, objectModel, staticHolder.input, staticHolder.name, dynamicHolder.config);
    }
17535#protected Object[] getValues(String attr, Map objectModel, ModuleHolder holder) throws ConfigurationException{
        return this.getValues(attr, objectModel, holder.input, holder.name, holder.config);
    }
17536#protected Object[] getValues(String attr, Map objectModel, ModuleHolder staticHolder, ModuleHolder dynamicHolder) throws ConfigurationException{
        return this.getValues(attr, objectModel, staticHolder.input, staticHolder.name, dynamicHolder.config);
    }
17537#/**
     * Get an attribute's value from a (usually statically assigned) Input
     * Module.
     * @see InputModule#getAttribute(String, Configuration, Map)
     */
     protected Object getValue(String attr, Map objectModel, 
                              InputModule staticMod, String staticModName, Configuration staticModConf)
        throws ConfigurationException {

        return this.get(OP_GET, attr, objectModel, staticMod, staticModName, staticModConf, null, null, null);
    }
17538#/**
     * Get attribute's value in one of the specified Input Modules 
     * (static or dynamic, dynamic preferred).  Dynamic IM may be
     * <code>null</code>.
     * @see InputModule#getAttribute(String, Configuration, Map)
     */
     protected Object getValue(String attr, Map objectModel, 
                              InputModule staticMod, String staticModName, Configuration staticModConf,
                              InputModule dynamicMod, String dynamicModName, Configuration dynamicModConf)
        throws ConfigurationException {

        return this.get(OP_GET, attr, objectModel, staticMod, staticModName, staticModConf, dynamicMod, dynamicModName, dynamicModConf);
    }
17539#/**
     * Get an attribute's values from a (usually statically assigned) Input
     * Module.
     * @see InputModule#getAttributeValues(String, Configuration, Map)
     */
     protected Object[] getValues(String attr, Map objectModel, 
                                 InputModule staticMod, String staticModName, Configuration staticModConf)
        throws ConfigurationException {

        return (Object[]) this.get(OP_VALUES, attr, objectModel, staticMod, staticModName, staticModConf, null, null, null);
    }
17540#/**
     * Get attribute's values in one of the specified Input Modules 
     * (static or dynamic, dynamic preferred).  Dynamic IM may be
     * <code>null</code>.
     * @see InputModule#getAttributeValues(String, Configuration, Map)
     */
     protected Object[] getValues(String attr, Map objectModel, 
                                 InputModule staticMod, String staticModName, Configuration staticModConf,
                                 InputModule dynamicMod, String dynamicModName, Configuration dynamicModConf)
        throws ConfigurationException {

        return (Object[]) this.get(OP_VALUES, attr, objectModel, staticMod, staticModName, staticModConf, dynamicMod, dynamicModName, dynamicModConf);
    }
17541#/**
     * Encapsulates use of an InputModule. Does all the lookups and so on.  
     * The second module (dynamic) is preferred if it has an non null name. If
     * an exception is encountered, a warn message is printed and null is
     * returned.
     * @param op Operation to perform ({@link #OP_GET}, {@link #OP_NAMES}, {@link #OP_VALUES}).
     *
     * @return Either an Object, an Object[], or an Iterator, depending on <code>op</code> param.
     */ 
    private Object get(int op, String attr, Map objectModel,
                         InputModule staticMod, String staticModName, Configuration staticModConf,
                         InputModule dynamicMod, String dynamicModName, Configuration dynamicModConf)
    throws ConfigurationException {

        ServiceSelector cs = this.inputSelector;
        Object value = null;
        String name = null;
        InputModule input = null;
        Configuration conf = null;
        boolean release = false;

        try {
            if (cs == null) {
                try {
                cs = (ServiceSelector) this.manager.lookup(INPUT_MODULE_SELECTOR);
                } catch (ServiceException e) {
                    throw new ConfigurationException("Could not find MetaModule's module selector", e);
                }
            }

            boolean useDynamic;
            if (dynamicMod == null && dynamicModName == null) {
                useDynamic = false;
                input = staticMod;
                name = staticModName;
                conf = staticModConf;
            } else {
                useDynamic = true;
                input = dynamicMod;
                name = dynamicModName;
                conf = dynamicModConf;
            }
        
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("MetaModule performing op "+OPNAME[op]+" on " + 
                        (useDynamic?"dynamically":"statically") + " " +
                        (input==null?"created":"assigned") +
                        " module '"+name+"', using config "+dynamicModConf);
            }

            if (input == null) {
                if (cs.isSelectable(name)) {
                    release = true;
                    try {
                        input = (InputModule) cs.select(name);
                    } catch (ServiceException e) {
                        throw new ConfigurationException(
                                "MetaModule unable to create "+
                                (useDynamic ? "dynamically" : "statically")+
                                " specified internal module '"+name+"'", e);
                    }
                } else {
                    throw new ConfigurationException("MetaModule: No such InputModule: "+name);
                }
            }

            switch (op) {
            case OP_GET:    
                value = input.getAttribute(attr, conf, objectModel);
                break;
            case OP_VALUES:
                value = input.getAttributeValues(attr, conf, objectModel);
                break;
            case OP_NAMES:
                value = input.getAttributeNames(conf, objectModel);
                break;
            }

            if (getLogger().isDebugEnabled())
                getLogger().debug("using "+name+" as "+input+" for "+op+" ("+attr+") and "+conf+" gives "+value);
            
        } finally {         
            if (release)
                cs.release(input);

            if (this.inputSelector == null)
                this.manager.release(cs);
        }

        return value;
    }
17542#public InputModuleAttributeException(String message)
    {
        super(message, null);
    }
17543#public InputModuleAttributeException(String message, Throwable cause)
    {
        super(message, cause);
    }
17544#public InputModuleNotFoundException(String message)
    {
        super(message, null);
    }
17545#public InputModuleNotFoundException(String message, Throwable cause)
    {
        super(message, cause);
    }
17546#public InputModuleDestructionException(String message)
    {
        super(message, null);
    }
17547#public InputModuleDestructionException(String message, Throwable cause)
    {
        super(message, cause);
    }
17548#public InputModuleException(String message)
    {
        super(message, null);
    }
17549#public InputModuleException(String message, Throwable cause)
    {
        super(message, cause);
    }
17550#/**
     * Get the input module
     */
    private InputModule getInputModule(String name)
    throws InputModuleException {
        if ( this.inputModules == null ) {
            throw new InputModuleInitializationException("ModuleHelper is not setup correctly.");
        }
        InputModule module = (InputModule) this.inputModules.get(name);
        if ( module == null ) {
            final String role = InputModule.ROLE + '/' + name;
            try {
                if (this.serviceManager.hasService(role) ) {
                    module = (InputModule) this.serviceManager.lookup(role);
                }
            } catch (Exception e) {
                throw new InputModuleNotFoundException("Unable to lookup input module " + name, e);
            }
            if ( module == null ) {
                throw new InputModuleNotFoundException("No such InputModule: "+name);
            }
            this.inputModules.put(name, module);
        }
        return module;
    }
17551#/**
     * Capsules use of an InputModule. Does all the lookups and so
     * on. Returns either an Object, an Object[], or an Iterator,
     * depending on the method called i.e. the op specified. The
     * second module is preferred and has an non null name. If an
     * exception is encountered, a warn message is printed and null is
     * returned.
     * @param op an <code>int</code> value encoding the desired operation
     * @param name a <code>String</code> value holding the name of the
     * InputModule
     * @param attr a <code>String</code> value holding the name of the
     * attribute to return. Is disregarded when attribute names is
     * requested.
     * @param objectModel a <code>Map</code> value holding the current
     * ObjectModel
     * @return an <code>Object</code> value
     * @throws InputModuleException if an error occurs. The real
     * exception can be obtained with <code>getCause</code>.
     */
    private Object get(int op, String name, String attr, Map objectModel, Configuration conf) throws InputModuleException {

        Object value = null;
        final InputModule input = this.getInputModule(name);

        try {

            switch (op) {
            case OP_GET:    
                value = input.getAttribute(attr, conf, objectModel);
                break;
            case OP_VALUES:
                value = input.getAttributeValues(attr, conf, objectModel);
                break;
            case OP_NAMES:
                value = input.getAttributeNames(conf, objectModel);
                break;
            }

        } catch (Exception e) {
            throw new InputModuleAttributeException("Error accessing attribute '"+attr+"' from input module '"+name+"'. "+e.getMessage(), e);
        }

        return value;
    }
17552#private Object get(int op, String name, String attr, Map objectModel) throws InputModuleException {
        return get(op, name, attr, objectModel, null);
    }
17553#/**
     * Initializes the instance for first use. Stores references to
     * service manager and service selector in instance 
     * 
     * @param manager a <code>ServiceManager</code> value
     * @throws InputModuleException if an error occurs
     */
    public void setup(ServiceManager manager) throws InputModuleException {
        this.inputModules = new HashMap();
        this.serviceManager = manager;
    }
17554#/**
     * Get a single attribute value from a module. Uses cached
     * reference if existing.
     *
     * @param objectModel a <code>Map</code> value
     * @param conf a <code>Configuration</code> containing the module dynamic configuration (aka modeConf)
     * @param module a <code>String</code> value holding the module name
     * @param name a <code>String</code> value holding the attribute name
     * @param deflt an <code>Object</code> value holding a default value
     * @return an <code>Object</code> value
     * @throws InputModuleException if an error occurs
     */
    public Object getAttribute(Map objectModel, Configuration conf, String module, String name, Object deflt) throws InputModuleException {

        Object result = this.get(OP_GET, module, name, objectModel, conf);
        if (result == null) result = deflt;
        return result;
    }
17555#/**
     * Get a single attribute value from a module.  Same as {@link
     * #getAttribute(Map, Configuration, String, String, Object)} with a
     * <code>null</code> configuration.
     */
    public Object getAttribute(Map objectModel, String module, String name, Object deflt) throws InputModuleException {
        return getAttribute(objectModel, null, module, name, deflt);
    }
17556#/**
     * Get an array of values from a module. Uses cached reference if
     * existing.
     *
     * @param objectModel a <code>Map</code> value
     * @param conf a <code>Configuration</code> containing the module dynamic configuration (aka modeConf)
     * @param module a <code>String</code> value holding the module name
     * @param name a <code>String</code> value holding the attribute name
     * @param deflt an <code>Object[]</code> value holding a default value
     * @return an <code>Object[]</code> value
     * @throws InputModuleException if an error occurs
     */
    public Object[] getAttributeValues(Map objectModel, Configuration conf, String module, String name, Object[] deflt) throws InputModuleException {

        Object[] result = (Object[]) this.get(OP_VALUES, module, name, objectModel, conf);
        if (result == null) result = deflt;
        return result;
    }
17557#/**
     * Get an array of values from a module. Same as
     * {@link #getAttributeValues(Map, Configuration, String, String, Object[])}
     * with a <code>null</code> configuration.
     */
    public Object[] getAttributeValues(Map objectModel, String module, String name, Object[] deflt) throws InputModuleException {
        return getAttributeValues(objectModel, null, module, name, deflt);
    }
17558#/**
     * Get an iterator to a collection of attribute names from a
     * module.
     *
     * @param objectModel a <code>Map</code> value
     * @param module the module's name
     * @return an <code>Iterator</code> value
     * @throws InputModuleException if an error occurs
     */
    public Iterator getAttributeNames(Map objectModel, Configuration conf, String module) throws InputModuleException {

        return (Iterator) this.get(OP_NAMES, module, null, objectModel);
    }
17559#/**  Get an iterator to a collection of attribute names from a module. Same
     * as {@link #getAttributeNames(Map, Configuration, String)} with a
     * <code>null</code> configuration.
     */
    public Iterator getAttributeNames(Map objectModel, String module) throws InputModuleException {
        return getAttributeNames(objectModel, (Configuration)null, module);
    }
17560#/**
     * Releases all obtained module references.
     *
     * @throws InputModuleException if an error occurs
     */
    public void releaseAll() throws InputModuleException {
        if ( this.inputModules != null ) {
            if ( this.serviceManager != null ) {
                try {
                    final Iterator iter = this.inputModules.keySet().iterator();
                    while (iter.hasNext()) {
                        this.serviceManager.release(this.inputModules.get(iter.next()));
                    }
                    this.serviceManager = null;
                } catch (Exception e) {
                    throw new InputModuleDestructionException("Could not release InputModules.",e);
                }
                
            }
            this.inputModules = null;
        }
    }
17561#/**
     * Configure component. Preprocess list of packages and functions
     * to add to JXPath context later.
     *
     * @param config a <code>Configuration</code> value
     * @exception ConfigurationException if an error occurs
     */
    public void configure(Configuration config) throws ConfigurationException {
        this.configuration = JXPathHelper.setup(config);
    }
17562#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttribute(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object getAttribute(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        Object contextObj = getContextObject(modeConf, objectModel);
        if (modeConf != null) {
            name = modeConf.getChild("parameter").getValue(this.parameter != null ? this.parameter : name);
        }
        return JXPathHelper.getAttributeValue(name, modeConf, this.configuration, contextObj);
    }
17563#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeNames(org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Iterator getAttributeNames(Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        Object contextObj = getContextObject(modeConf, objectModel);
        return JXPathHelper.getAttributeNames(this.configuration, contextObj);
    }
17564#/**
     * @see org.apache.cocoon.components.modules.input.AbstractInputModule#getAttributeValues(java.lang.String, org.apache.avalon.framework.configuration.Configuration, java.util.Map)
     */
    public Object[] getAttributeValues(String name, Configuration modeConf, Map objectModel)
    throws ConfigurationException {
        Object contextObj = getContextObject(modeConf, objectModel);
        if (modeConf != null) {
            name = modeConf.getChild("parameter").getValue(this.parameter != null ? this.parameter : name);
        }
        return JXPathHelper.getAttributeValues(name, modeConf, this.configuration, contextObj);
    }
17565#/**
     * Returns the object which should be used as JXPath context.
     * Descendants should override this method to return a specific object
     * that is requried by the implementing class.
     * Examples are: request, session and application context objects.
     * @param modeConf The Configuration.
     * @param objectModel Cocoon's object model Map.
     * @return The context object.
     * @throws ConfigurationException when an error occurs.
     */
    protected abstract Object getContextObject(Configuration modeConf,
                                               Map objectModel)
    throws ConfigurationException;
17566#/**
     * Configures the module.
     *
     * <p>Takes all elements nested in component declaration and stores
     * them as key-value pairs in <code>settings</code>. Nested
     * configuration option are not catered for. This way global
     * configuration options can be used.</p>
     *
     * <p>For nested configurations override this function.</p>
     */
    public void configure(Configuration conf) throws ConfigurationException {
        Configuration[] parameters = conf.getChildren();
        // Ideally here should be length * 1.333(3) but simple +1 will do for lengths up to 3
        this.settings = new HashMap(parameters.length + 1);
        for (int i = 0; i < parameters.length; i++) {
            String key = parameters[i].getName();
            String val = parameters[i].getValue("");
            this.settings.put(key, val);
        }
    }
17567#/**
     * Dispose
     */
    public void dispose() {
        // Implemeted so that we don't need to implement it in every subclass
        this.settings = null;
    }
17568#/**
     * Utility method to store parameters in a map as request attribute until
     * either {@link #rollback(Map, String)} or {@link #prepareCommit(Map, String)}
     * is called.
     * @param objectModel - the objectModel
     * @param trans_place - request attribute name used for the transient data
     * @param name - name of the attribute to set
     * @param value - attribute value
     */
    protected void transientSetAttribute(Map objectModel, String trans_place, String name, Object value) {
        final Request request = ObjectModelHelper.getRequest(objectModel);

        Map map = (Map) request.getAttribute(trans_place);
        if (map == null) {
            // Need java.util.HashMap here since JXPath does not like the extended version...
            map = new java.util.HashMap();
        }

        map.put(name, value);
        request.setAttribute(trans_place, map);
    }
17569#/**
     * Clears all uncommitted transient attributes.
     *
     * @param objectModel - the objectModel
     * @param trans_place - request attribute name used for the transient data
     */
    protected void rollback(Map objectModel, String trans_place) {
        ObjectModelHelper.getRequest(objectModel).removeAttribute(trans_place);
    }
17570#/**
     * Returns a whether an transient attribute already exists.
     * {@link #transientSetAttribute(Map, String, String, Object)} since the last call to
     * {@link #rollback(Map, String)} or {@link #prepareCommit(Map, String)}
     *
     * @param objectModel - the objectModel
     * @param trans_place - request attribute name used for the transient data
     */
    protected boolean attributeExists(Map objectModel, String trans_place, String name) {
        final Request request = ObjectModelHelper.getRequest(objectModel);

        Map map = (Map) request.getAttribute(trans_place);
        return map != null && map.containsKey(name);

    }
17571#/**
     * Returns a map containing all transient attributes and remove them i.e. attributes set with
     * {@link #transientSetAttribute(Map, String, String, Object)} since the last call to
     * {@link #rollback(Map, String)} or {@link #prepareCommit(Map, String)}
     *
     * @param objectModel - the objectModel
     * @param trans_place - request attribute name used for the transient data
     */
    protected Map prepareCommit(Map objectModel, String trans_place) {
        final Request request = ObjectModelHelper.getRequest(objectModel);

        Map data = (Map) request.getAttribute(trans_place);
        request.removeAttribute(trans_place);
        return data;
    }
17572#public SimpleNotifyingBean() {
    }
17573#public SimpleNotifyingBean(Object sender) {
        this.sender = sender.getClass().getName();
    }
17574#/**
     * Sets the Type of the SimpleNotifyingBean object
     *
     * @param  type  The new Type value
     */
    public void setType(String type) {
        this.type = type;
    }
17575#/**
     * Sets the Title of the SimpleNotifyingBean object
     *
     * @param  title  The new Title value
     */
    public void setTitle(String title) {
        this.title = title;
    }
17576#/**
     * Sets the Source of the SimpleNotifyingBean object
     *
     * @param  source  The new Source value
     */
    public void setSource(String source) {
        this.source = source;
    }
17577#/**
     * Sets the Message of the SimpleNotifyingBean object
     *
     * @param  message  The new Message value
     */
    public void setMessage(String message) {
        this.message = message;
    }
17578#/**
     * Sets the Description of the SimpleNotifyingBean object
     *
     * @param  description  The new Description value
     */
    public void setDescription(String description) {
        this.description = description;
    }
17579#/**
     * Adds the ExtraDescription to the SimpleNotifyingBean object
     *
     * @param  extraDescriptionDescription  The additional ExtraDescription name
     * @param  extraDescription The additional ExtraDescription value
     */
    public void addExtraDescription(String extraDescriptionDescription,
                                    String extraDescription) {
        this.extraDescriptions.put(extraDescriptionDescription, extraDescription);
    }
17580#/**
     * Replaces the ExtraDescriptions of the SimpleNotifyingBean object
     */
    protected void replaceExtraDescriptions(Map extraDescriptions) {
        this.extraDescriptions = extraDescriptions;
    }
17581#/**
     * Adds the ExtraDescriptions to the SimpleNotifyingBean object
     */
    protected void addExtraDescriptions(Map extraDescriptions) {
        if (this.extraDescriptions == null) {
            replaceExtraDescriptions(extraDescriptions);
        } else {
            this.extraDescriptions.putAll(extraDescriptions);
        }
    }
17582#/**
     * Gets the Type of the SimpleNotifyingBean object
     */
    public String getType() {
        return type;
    }
17583#/**
     * Gets the Title of the SimpleNotifyingBean object
     */
    public String getTitle() {
        return title;
    }
17584#/**
     * Gets the Source of the SimpleNotifyingBean object
     */
    public String getSource() {
        return source;
    }
17585#/**
     * Gets the Sender of the SimpleNotifyingBean object
     */
    public String getSender() {
        return sender;
    }
17586#/**
     * Gets the Message of the SimpleNotifyingBean object
     */
    public String getMessage() {
        return message;
    }
17587#/**
     * Gets the Description of the SimpleNotifyingBean object
     */
    public String getDescription() {
        return description;
    }
17588#/**
     * Gets the ExtraDescriptions of the SimpleNotifyingBean object
     */
    public Map getExtraDescriptions() {
        return extraDescriptions;
    }
17589#/**
     * Builds a Notifying object (SimpleNotifyingBean in this case)
     * that tries to explain what the Object o can reveal.
     *
     * @param sender who sent this Object.
     * @param o the object to use when building the SimpleNotifyingBean
     * @return the  Notifying Object that was build
     * @see org.apache.cocoon.components.notification.Notifying
     */
    public Notifying build (Object sender, Object o) {
        if (o instanceof Notifying) {
            return (Notifying) o;
        } else if (o instanceof Throwable) {
            Throwable t = (Throwable) o;
            SimpleNotifyingBean n = new SimpleNotifyingBean(sender);
            n.setType(Notifying.ERROR_NOTIFICATION);
            n.setTitle("An Error Occurred");

            if (t != null) {
                Throwable rootCause = getRootCause(t);

                n.setSource(t.getClass().getName());

                // NullPointerException usually does not have a message
                if (rootCause.getMessage() != null) {
                    n.setMessage(rootCause.getMessage());
                } else {
                    n.setMessage(t.getMessage());
                }

                n.setDescription(t.toString());
                n.addExtraDescription(Notifying.EXTRA_CAUSE, rootCause.toString());

                if (rootCause instanceof SAXParseException) {
                    SAXParseException saxParseException = (SAXParseException) rootCause;

                    n.addExtraDescription(Notifying.EXTRA_LOCATION,
                                          String.valueOf(saxParseException.getSystemId()));
                    n.addExtraDescription(Notifying.EXTRA_LINE,
                                          String.valueOf(saxParseException.getLineNumber()));
                    n.addExtraDescription(Notifying.EXTRA_COLUMN,
                                          String.valueOf(saxParseException.getColumnNumber()));
                } else if (rootCause instanceof TransformerException) {
                    TransformerException transformerException = (TransformerException) rootCause;
                    SourceLocator sourceLocator = transformerException.getLocator();

                    if (null != sourceLocator) {
                        n.addExtraDescription(Notifying.EXTRA_LOCATION,
                                              String.valueOf(sourceLocator.getSystemId()));
                        n.addExtraDescription(Notifying.EXTRA_LINE,
                                              String.valueOf(sourceLocator.getLineNumber()));
                        n.addExtraDescription(Notifying.EXTRA_COLUMN,
                                              String.valueOf(sourceLocator.getColumnNumber()));
                    }
                }

                // Add root cause exception stacktrace
                StringWriter sw = new StringWriter();
                rootCause.printStackTrace(new PrintWriter(sw));
                n.addExtraDescription(Notifying.EXTRA_STACKTRACE, sw.toString());

                // Add full exception chain
                sw = new StringWriter();
                appendTraceChain(sw, t);
                n.addExtraDescription(Notifying.EXTRA_FULLTRACE, sw.toString());
            }

            return n;
        } else {
            SimpleNotifyingBean n = new SimpleNotifyingBean(sender);
            n.setType(Notifying.UNKNOWN_NOTIFICATION);
            n.setTitle("Object Notification");
            n.setMessage(String.valueOf(o));
            n.setDescription("No details available.");
            return n;
        }
    }
17590#/**
     * Builds a Notifying object (SimpleNotifyingBean in this case)
     * that explains a notification.
     *
     * @param sender who sent this Object.
     * @param o the object to use when building the SimpleNotifyingBean
     * @param type see the Notifying apidocs
     * @param title see the Notifying apidocs
     * @param source see the Notifying apidocs
     * @param message see the Notifying apidocs
     * @param description see the Notifying apidocs
     * @param extra see the Notifying apidocs
     * @return the  Notifying Object that was build
     * @see org.apache.cocoon.components.notification.Notifying
     */
    public Notifying build(Object sender, Object o, String type, String title,
                           String source, String message, String description, Map extra) {
        // NKB Cast here is secure, the method is of this class
        SimpleNotifyingBean n = (SimpleNotifyingBean) build (sender, o);

        if (type != null)
            n.setType(type);
        if (title != null)
            n.setTitle(title);
        if (source != null)
            n.setSource(source);
        if (message != null)
            n.setMessage(message);
        if (description != null)
            n.setDescription(description);
        if (extra != null)
            n.addExtraDescriptions(extra);

        return n;
    }
17591#/**
     * Print stacktrace of the Throwable and stacktraces of its all nested causes into a Writer.
     */
    private static void appendTraceChain(Writer out, Throwable t) {
        PrintWriter pw = new PrintWriter(out);
        if (SystemUtils.isJavaVersionAtLeast(140)) {
            t.printStackTrace(pw);
        } else {
            for (Throwable cause = t; cause != null; cause = ExceptionUtils.getCause(cause)) {
                if (cause != t) {
                    pw.println();
                }
                cause.printStackTrace(pw);
            }
        }
    }
17592#/**
     * Get root cause Throwable.
     */
    public static Throwable getRootCause (Throwable t) {
        Throwable rootCause = ExceptionUtils.getRootCause(t);
        return rootCause != null ? rootCause : t;
    }
17593#/**
     * Generate notification information as a response.
     * The notification is directly written to the OutputStream.
     * @param  n The <code>Notifying</code> object
     * @param outputStream The output stream the notification is written to
     *        This could be <code>null</code>.
     */
    public static void notify(Notifying n, OutputStream outputStream, String mimetype) throws IOException {
        //(NKB) FIXME should use error page templates, one per mime-type
        // currently uses hardcoded html, should be used only as last resort.
        notifyHTML(n, outputStream);
    }
17594#/**
     * Generate notification information as html.
     * The notification is directly written to the OutputStream.
     * @param  n The <code>Notifying</code> object
     * @param outputStream The output stream the notification is written to
     *        This could be <code>null</code>.
     */
    private static void notifyHTML(Notifying n, OutputStream outputStream) throws IOException {
        if (outputStream == null) {
            return;
        }

        StringBuffer sb = new StringBuffer();

        sb.append("<html><head><title>").append(n.getTitle()).append("</title>");
        sb.append("<style><!--");
        sb.append("body { background-color: white; color: black; font-family: verdana, helvetica, sanf serif;}");
        sb.append("h1 {color: #336699; margin: 0px 0px 20px 0px; border-width: 0px 0px 1px 0px; border-style: solid; border-color: #336699;}");
        sb.append("p.footer { color: #336699; border-width: 1px 0px 0px 0px; border-style: solid; border-color: #336699; }");
        sb.append("span {color: #336699;}");
        sb.append("pre {padding-left: 20px;}");
        sb.append("a:link {font-weight: bold; color: #336699;}");
        sb.append("a:visited {color: #336699; }");
        sb.append("a:hover {color: #800000; background-color: #ffff80;}");
        sb.append("a:active {color: #006666;}");
        sb.append("--></style>");
        sb.append("</head><body>");
        sb.append("<h1>")
          .append(StringEscapeUtils.escapeXml(n.getTitle())).append("</h1>");
        sb.append("<p><span>Message:</span> ")
          .append(StringEscapeUtils.escapeXml(n.getMessage())).append("</p>");
        sb.append("<p><span>Description:</span> ")
          .append(StringEscapeUtils.escapeXml(n.getDescription())).append("</p>");
        sb.append("<p><span>Sender:</span> ")
          .append(StringEscapeUtils.escapeXml(n.getSender())).append("</p>");
        sb.append("<p><span>Source:</span> ")
          .append(StringEscapeUtils.escapeXml(n.getSource())).append("</p>");

        Map extras = n.getExtraDescriptions();
        Iterator i = extras.keySet().iterator();
        while (i.hasNext()) {
            final String key = (String) i.next();

            sb.append("<p><span>")
              .append(key).append("</span><pre>")
              .append(StringEscapeUtils.escapeXml(String.valueOf(extras.get(key))))
              .append("</pre></p>");
        }

        sb.append("<p class='footer'><a href='http://cocoon.apache.org/'>").append(Constants.COMPLETE_NAME).append("</p>");
        sb.append("</body></html>");

        outputStream.write(sb.toString().getBytes());
    }
17595#/**
     * Generate notification information in XML format.
     */
    public static void notify(Notifying n, ContentHandler ch, String mimetype) throws SAXException {
        final String PREFIX = Constants.ERROR_NAMESPACE_PREFIX;
        final String URI = Constants.ERROR_NAMESPACE_URI;

        // Start the document
        ch.startDocument();
        ch.startPrefixMapping(PREFIX, URI);

        // Root element.
        AttributesImpl atts = new AttributesImpl();

        atts.addAttribute(URI, "type", PREFIX + ":type", "CDATA", n.getType());
        atts.addAttribute(URI, "sender", PREFIX + ":sender", "CDATA", n.getSender());
        ch.startElement(URI, "notify", PREFIX + ":notify", atts);
        ch.startElement(URI, "title", PREFIX + ":title", new AttributesImpl());
        ch.characters(n.getTitle().toCharArray(), 0, n.getTitle().length());
        ch.endElement(URI, "title", PREFIX + ":title");
        ch.startElement(URI, "source", PREFIX + ":source", new AttributesImpl());
        ch.characters(n.getSource().toCharArray(), 0, n.getSource().length());
        ch.endElement(URI, "source", PREFIX + ":source");
        ch.startElement(URI, "message", PREFIX + ":message", new AttributesImpl());

        if (n.getMessage() != null) {
            ch.characters(n.getMessage().toCharArray(), 0, n.getMessage().length());
        }

        ch.endElement(URI, "message", PREFIX + ":message");
        ch.startElement(URI, "description", PREFIX + ":description", XMLUtils.EMPTY_ATTRIBUTES);
        ch.characters(n.getDescription().toCharArray(), 0, n.getDescription().length());
        ch.endElement(URI, "description", PREFIX + ":description");

        Map extraDescriptions = n.getExtraDescriptions();
        for (Iterator i = extraDescriptions.entrySet().iterator(); i.hasNext(); ) {
            final Map.Entry me = (Map.Entry) i.next();
            String key = (String) me.getKey();
            String value = String.valueOf(me.getValue());
            atts = new AttributesImpl();

            atts.addAttribute(URI, "description", PREFIX + ":description", "CDATA", key);
            ch.startElement(URI, "extra", PREFIX + ":extra", atts);
            ch.characters(value.toCharArray(), 0, value.length());
            ch.endElement(URI, "extra", PREFIX + ":extra");
        }

        // End root element.
        ch.endElement(URI, "notify", PREFIX + ":notify");

        // End the document.
        ch.endPrefixMapping(PREFIX);
        ch.endDocument();
    }
17596#/**
   * Construct a new <code>NotifyingCascadingRuntimeException</code> instance.
   */
  public NotifyingCascadingRuntimeException(String message) {
    super(message, null);
    n = new DefaultNotifyingBuilder().build(this, message);
  }
17597#/**
   * Creates a new <code>ProcessingException</code> instance.
   *
   * @param ex an <code>Exception</code> value
   */
  public NotifyingCascadingRuntimeException(Exception ex) {
    super(ex.getMessage(), ex);
    n = new DefaultNotifyingBuilder().build(this, ex);
  }
17598#/**
   * Construct a new <code>ProcessingException</code> that references
   * a parent Exception.
   */
  public NotifyingCascadingRuntimeException(String message, Throwable t) {
    super(message, t);
    n = new DefaultNotifyingBuilder().build(this, t);
  }
17599#/**
   *  Gets the Type attribute of the Notifying object
   */
  public String getType() {
    return n.getType();
  }
17600#/**
   *  Gets the Title attribute of the Notifying object
   */
  public String getTitle() {
    return n.getTitle();
  }
17601#/**
   *  Gets the Source attribute of the Notifying object
   */
  public String getSource() {
    return n.getSource();
  }
17602#/**
   *  Gets the Sender attribute of the Notifying object
   */
  public String getSender() {
    return n.getSender();
  }
17603#/**
   *  Gets the Message attribute of the Notifying object
   */
  public String getMessage() {
    return n.getMessage();
  }
17604#/**
   *  Gets the Description attribute of the Notifying object
   */
  public String getDescription() {
    return n.getDescription();
  }
17605#/**
   *  Gets the ExtraDescriptions attribute of the Notifying object
   */
  public Map getExtraDescriptions() {
    return n.getExtraDescriptions();
  }
17606#public static SitemapSourceInfo parseURI(Environment env, String sitemapURI) 
    throws MalformedURLException {
        SitemapSourceInfo info = new SitemapSourceInfo();
        info.rawMode = false;

        // remove the protocol
        int position = sitemapURI.indexOf(':') + 1;
        if (position != 0) {
            info.protocol = sitemapURI.substring(0, position-1);
            // check for subprotocol
            if (sitemapURI.startsWith("raw:", position)) {
                position += 4;
                info.rawMode = true;
            }
        } else {
            throw new MalformedURLException("No protocol found for sitemap source in " + sitemapURI);
        }

        // does the uri point to this sitemap or to the root sitemap?
        if (sitemapURI.startsWith("//", position)) {
            position += 2;
            info.prefix = "";
            info.processFromRoot = true;
        } else if (sitemapURI.startsWith("/", position)) {
            position ++;
            info.prefix = env.getURIPrefix();
            info.processFromRoot = false;
        } else {
            throw new MalformedURLException("Malformed cocoon URI: " + sitemapURI);
        }

        // create the queryString (if available)
        int queryStringPos = sitemapURI.indexOf('?', position);
        if (queryStringPos != -1) {
            info.queryString = sitemapURI.substring(queryStringPos + 1);
            info.uri = sitemapURI.substring(position, queryStringPos);
        } else if (position > 0) {
            info.uri = sitemapURI.substring(position);
        }

        
        // determine if the queryString specifies a cocoon-view
        info.view = getView(info.queryString, env);

        // build the request uri which is relative to the context
        info.requestURI = info.prefix + info.uri;

        // create system ID
        final StringBuffer buffer = new StringBuffer(info.protocol);
        buffer.append("://").append(info.requestURI);
        if (info.queryString != null ) {
            buffer.append('?').append(info.queryString);
        }
        info.systemId = buffer.toString();

        return info;
    }
17607#public static String getView(String query, Environment env) {
        if (query != null) {
            int index = query.indexOf(Constants.VIEW_PARAM);
            if (index != -1 
                    && (index == 0 || query.charAt(index-1) == '&')
                    && query.length() > index + Constants.VIEW_PARAM.length() 
                    && query.charAt(index+Constants.VIEW_PARAM.length()) == '=') {
                
                String tmp = query.substring(index+Constants.VIEW_PARAM.length()+1);
                index = tmp.indexOf('&');
                if (index != -1) {
                    return tmp.substring(0,index);
                } else {
                    return tmp;
                }
            } else {
                return env.getView();
            }
        } else {
            return env.getView();
        }
    }
17608#/**
     * Creates a wrapper for a <code>Source</code> which ensures that
     * <code>Source.getLastModified()</code> won't be called more than once per
     * <code>delay</code> milliseconds period.
     *
     * @param source the wrapped <code>Source</code>
     * @param delay  the last-modified refresh delay, in milliseconds
     */
    public DelayedRefreshSourceWrapper(Source source, long delay) {
        this.source = source;
        this.delay = delay;
    }
17609#/**
     * Get the real source
     */
    public Source getSource() {
        return this.source;
    }
17610#/**
     * @see org.apache.excalibur.source.Source#getInputStream()
     */
    public final InputStream getInputStream()
    throws SourceException, IOException {
        return this.source.getInputStream();
    }
17611#/**
     * @see org.apache.excalibur.source.Source#getURI()
     */
    public final String getURI() {
        return this.source.getURI();
    }
17612#/**
     * @see org.apache.excalibur.source.Source#getValidity()
     */
    public SourceValidity getValidity() {
        return this.source.getValidity();
    }
17613#/**
     * @see org.apache.excalibur.source.Source#getScheme()
     */
    public String getScheme() {
        return this.source.getScheme();
    }
17614#/**
     * @see org.apache.excalibur.source.Source#exists()
     */
    public boolean exists() {
        return this.source.exists();
    }
17615#/**
     * Get the last modification time for the wrapped <code>Source</code>. The
     * age of the returned information is guaranteed to be lower than or equal to
     * the delay specified in the constructor.
     * <p>
     * This method is also thread-safe, even if the underlying Source is not.
     *
     * @return the last modification time.
     * @see org.apache.excalibur.source.Source#getLastModified()
     */
    public final long getLastModified() {

        // Do we have to refresh the source ?
        if (System.currentTimeMillis() >= nextCheckTime) {
            // Yes
            this.refresh();
        }
        return this.lastModified;
    }
17616#/**
     * Force the refresh of the wrapped <code>Source</code>, even if the refresh period
     * isn't over, and starts a new period.
     * <p>
     * This method is thread-safe, even if the underlying Source is not.
     * @see org.apache.excalibur.source.Source#refresh()
     */
    public synchronized final void refresh() {

        this.nextCheckTime = System.currentTimeMillis() + this.delay;
        // Refresh modifiable sources
        this.source.refresh();

        // Keep the last modified date
        this.lastModified = source.getLastModified();
    }
17617#/**
     * @see org.apache.excalibur.source.Source#getContentLength()
     */
    public final long getContentLength() {
        return this.source.getContentLength();
    }
17618#/**
     * @see org.apache.excalibur.source.Source#getMimeType()
     */
    public String getMimeType() {
        return this.source.getMimeType();
    }
17619#/**
     * @see org.apache.avalon.excalibur.pool.Recyclable#recycle()
     */
    public final void recycle() {
        if (this.source instanceof Recyclable) {
            ((Recyclable)this.source).recycle();
        }
    }
17620#/**
     * Construct error handler with everything needed to handle an error.
     */
    public TreeProcessorSitemapErrorHandler(ErrorHandlerHelper handler,
                                            Environment environment,
                                            InvokeContext context) {
        this.handler = handler;
        this.environment = environment;
        this.context = context;

        this.envPrefix = environment.getURIPrefix();
        this.envURI = environment.getURI();
    }
17621#/**
     * Handle an error.
     * @return true if error was handled.
     */
    public boolean handleError(Exception e) throws Exception {
        // Restore environment state
        this.environment.setURI(this.envPrefix, this.envURI);

        return this.handler.invokeErrorHandler(e, this.environment, this.context);
    }
17622#/**
     * Build error handling pipeline.
     * @return error handling pipeline, or null if error was not handled.
     */
    public ProcessingPipeline prepareErrorPipeline(Exception e) throws Exception {
        // Restore environment state
        this.environment.setURI(this.envPrefix, this.envURI);
        
        Processor.InternalPipelineDescription pipelineDescription = 
            this.handler.prepareErrorHandler(e, this.environment, this.context);

        return pipelineDescription != null ? pipelineDescription.processingPipeline : null; 
    }
17623#public void configure(Configuration config) throws ConfigurationException {
        super.configure(config);
        this.nameAttr = config.getChild("name-attribute").getValue("name");
    }
17624#public ProcessingNode buildNode(Configuration config) throws Exception {

        NamedContainerNode node = new NamedContainerNode(config.getAttribute(this.nameAttr));
        this.setupNode(node, config);
        return node;
    }
17625#/**
     * Process environment.
     */
    boolean invoke(Environment env, InvokeContext context) throws Exception;
17626#/**
     * Get the location of this node.
     */
    Location getLocation();
17627#public CategoryNode(String type) {
        super(type);
    }
17628#public void setCategory(String categoryName, Map nodes) {
        this.categoryName = categoryName;
        this.nodes = nodes != null ? nodes : new HashMap(0);
    }
17629#public boolean invoke(Environment env, InvokeContext context) throws Exception {
        throw new ProcessingException("Cannot invoke " + this.categoryName, getLocation());
    }
17630#public ProcessingNode getNodeByName(String name) throws Exception {
        ProcessingNode node = (ProcessingNode)nodes.get(name);
        if (node == null) {
            throw new ProcessingException("Unknown " + this.categoryName + " named '" + name + "'",
                                          getLocation());
        }

        return node;
    }
17631#public boolean invokeByName(String name, Environment env, InvokeContext context)
    throws Exception {

        return getNodeByName(name).invoke(env, context);
    }
17632#public AbstractProcessingNode() {
    }
17633#public AbstractProcessingNode(String type) {
        this.componentName = type;
    }
17634#/**
     * Get the location of this node.
     */
    public Location getLocation() {
        return this.location;
    }
17635#/**
     * Set the location of this node.
     */
    public void setLocation(Location location) {
        this.location = location;
    }
17636#/**
     * Set the sitemap executor
     */
    public void setSitemapExecutor(SitemapExecutor executor) {
        this.executor = executor;
    }
17637#/* (non-Javadoc)
     * @see org.apache.cocoon.sitemap.ExecutionContext#getType()
     */
    public String getType() {
        return this.componentName;
    }
17638#public NullNode() {
        super(null);
    }
17639#public final boolean invoke(Environment env, InvokeContext context) throws Exception {

        getLogger().warn("Invoke on NullNode at " + getLocation());
        return false;

    }
17640#/**
     * Set the builder for which we are building.
     */
    void setBuilder(TreeBuilder builder);
17641#/**
     * Build the {@link ProcessingNode} and its children from the given
     * <code>Configuration</code>, and optionnaly register it in the tree builder
     * for lookup by other <code>LinkedProcessingNodeBuilder</code>s.
     */
    ProcessingNode buildNode(Configuration config) throws Exception;
17642#public ProcessingNode buildNode(Configuration config) throws Exception {
        return this.treeBuilder.setupNode(new NullNode(), config);
    }
17643#public SimpleSelectorProcessingNode(String selectorRole, String componentType) {
        super(componentType);
        this.selectorRole = selectorRole;
    }
17644#public void service(ServiceManager avalonManager) throws ServiceException {
        this.manager = avalonManager;
        this.selector = (ServiceSelector)this.manager.lookup(selectorRole);
        
        // Pre-lookup the associated component, and cache it if it's threadsafe
        Object component = this.selector.select(this.getType());
        if (component instanceof ThreadSafe) {
            this.threadSafeComponent = component;
        } else {
            this.selector.release(component);
        }
    }
17645#/**
     * Get the component to be used by this node. That component may be cached for faster
     * execution if it's ThreadSafe. In any case, a call to {@link #releaseComponent(Object)} must
     * be done to release the component if needed.
     * 
     * @return the component to use
     * @throws ServiceException if component lookup fails
     */
    protected Object getComponent() throws ServiceException {
        if (this.threadSafeComponent != null) {
            return this.threadSafeComponent;
        }
        return this.selector.select(this.componentName);
    }
17646#/**
     * Release the component used by this node (does nothing if it's the cached
     * ThreadSafe component)
     * 
     * @param obj the component
     */
    protected void releaseComponent(Object obj) {
        if (obj != this.threadSafeComponent) {
            this.selector.release(obj);
        }
    }
17647#public void dispose() {
        this.selector.release(this.threadSafeComponent);
        this.manager.release(this.selector);
        this.selector = null;
        this.manager = null;
    }
17648#/**
     * Create a TreeProcessor.
     */
    public TreeProcessor() {
        this.checkReload = true;
        this.lastModifiedDelay = 1000;
        // create sitemap schema
        final SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI); 
        final StreamSource ss = new StreamSource(this.getClass().getResourceAsStream("/org/apache/cocoon/sitemap/schema/cocoon-sitemap-1.0.xsd"));
        try {
            this.sitemapSchema = factory.newSchema(ss);
        } catch (SAXException se) {
            throw new RuntimeException("Unable to parse sitemap schema.", se);
        }
    }
17649#/**
     * Create a child processor for a given language
     */
    protected TreeProcessor(TreeProcessor parent,
                            DelayedRefreshSourceWrapper sitemapSource,
                            boolean checkReload,
                            String prefix)
    throws Exception {
        this.parent = parent;

        // Copy all that can be copied from the parent
        this.source = sitemapSource;
        this.checkReload = checkReload;
        this.lastModifiedDelay = parent.lastModifiedDelay;

        this.manager = parent.concreteProcessor.getServiceManager();

        this.resolver = (SourceResolver) this.manager.lookup(SourceResolver.ROLE);
        this.settings = (Settings) this.manager.lookup(Settings.ROLE);
        this.environmentHelper = new EnvironmentHelper(parent.environmentHelper);
        // Setup environment helper
        ContainerUtil.service(this.environmentHelper, this.manager);
        this.environmentHelper.changeContext(sitemapSource, prefix);
        this.sitemapExecutor = parent.sitemapExecutor;
        this.sitemapSchema = parent.sitemapSchema;
    }
17650#/**
     * Create a new child of this processor (used for mounting submaps).
     *
     * @return a new child processor.
     */
    public TreeProcessor createChildProcessor(String  src,
                                              boolean configuredCheckReload,
                                              String  prefix)
    throws Exception {
        DelayedRefreshSourceWrapper delayedSource = new DelayedRefreshSourceWrapper(
                this.resolver.resolveURI(src), this.lastModifiedDelay);
        return new TreeProcessor(this, delayedSource, configuredCheckReload, prefix);
    }
17651#/**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager serviceManager) throws ServiceException {
        this.manager = serviceManager;
        this.resolver = (SourceResolver) this.manager.lookup(SourceResolver.ROLE);
        this.settings = (Settings) this.manager.lookup(Settings.ROLE);
    }
17652#/**
     * @see org.apache.avalon.framework.activity.Initializable#initialize()
     */
    public void initialize() throws Exception {
        // setup the environment helper
        if (this.environmentHelper == null) {
            // We already have resolved our sitemap, so our context is the
            // directory of this sitemap.
            int pos = this.source.getURI().lastIndexOf('/');
            this.environmentHelper = new EnvironmentHelper(new URL(this.source.getURI().substring(0, pos + 1)));
        }
        ContainerUtil.service(this.environmentHelper, this.manager);

        // Create sitemap executor
        if (this.parent == null) {
            if (this.manager.hasService(SitemapExecutor.ROLE)) {
                this.sitemapExecutor = (SitemapExecutor) this.manager.lookup(SitemapExecutor.ROLE);
                this.releaseSitemapExecutor = true;
            } else {
                this.sitemapExecutor = new DefaultExecutor();
            }
        } else {
            this.sitemapExecutor = this.parent.sitemapExecutor;
        }
    }
17653#/**
     * Configure the tree processor:
     * &lt;processor file="{Location of the sitemap}"
     *               check-reload="{true|false}"
     *               config="{Location of sitemap tree processor config}&gt;
     *   &lt;reload delay="10"/&gt;
     * &lt;/processor&gt;
     *
     * Only the file attribute is required; everything else is optional.
     *
     * @see org.apache.avalon.framework.configuration.Configurable#configure(org.apache.avalon.framework.configuration.Configuration)
     */
    public void configure(Configuration config)
    throws ConfigurationException {

        this.checkReload = config.getAttributeAsBoolean("check-reload",
                             this.settings.isReloadingEnabled("sitemap"));

        // Reload check delay. Default is 1 second.
        this.lastModifiedDelay = config.getChild("reload").getAttributeAsLong("delay", this.settings.getReloadDelay("sitemap"));

        String fileName = config.getAttribute("file", "sitemap.xmap");
        
        try {
            this.source = new DelayedRefreshSourceWrapper(this.resolver.resolveURI(fileName), lastModifiedDelay);
        } catch (Exception e) {
            throw new ConfigurationException("Cannot resolve " + fileName, e);
        }
    }
17654#/**
     * Process the given <code>Environment</code> producing the output.
     * @return If the processing is successfull <code>true</code> is returned.
     *         If not match is found in the sitemap <code>false</code>
     *         is returned.
     * @throws org.apache.cocoon.ResourceNotFoundException If a sitemap component tries
     *                                   to access a resource which can not
     *                                   be found, e.g. the generator
     *         ConnectionResetException  If the connection was reset
     */
    public boolean process(Environment environment) throws Exception {
        // Get the concrete processor and delegate it the job
        setupConcreteProcessor(environment);
        return this.concreteProcessor.process(environment);
    }
17655#/**
     * Process the given <code>Environment</code> to assemble
     * a <code>ProcessingPipeline</code>.
     * @since 2.1
     */
    public InternalPipelineDescription buildPipeline(Environment environment)
    throws Exception {
        // Get the concrete processor and delegate it the job
        setupConcreteProcessor(environment);
        return this.concreteProcessor.buildPipeline(environment);
    }
17656#/**
     * @see org.apache.cocoon.Processor#getRootProcessor()
     */
    public Processor getRootProcessor() {
        TreeProcessor result = this;
        while (result.parent != null) {
            result = result.parent;
        }

        return result;
    }
17657#/**
     * @see org.apache.cocoon.Processor#getContext()
     */
    public String getContext() {
        return this.environmentHelper.getContext();
    }
17658#/**
     * @see org.apache.cocoon.Processor#getSourceResolver()
     */
    public org.apache.cocoon.environment.SourceResolver getSourceResolver() {
        return this.environmentHelper;
    }
17659#/**
     * The current environment helper used by the MountNode
     * @return EnvironmentHelper
     */
    public EnvironmentHelper getEnvironmentHelper() {
        return this.environmentHelper;
    }
17660#/**
     * Get the tree builder role from the sitemap program (as a configuration object).
     * This method should report very any problem very clearly, as it is the entry point of any
     * Cocoon application.
     *
     * @param sitemapProgram the sitemap
     * @return the treebuilder role
     * @throws ConfigurationException if a suitable role could not be found
     */
    private TreeBuilder getTreeBuilder(Configuration sitemapProgram) throws ConfigurationException {
        String ns = sitemapProgram.getNamespace();

        RE re = new RE("http://apache.org/cocoon/sitemap/(\\d\\.\\d)");
        if (!re.match(ns)) {
            throw new ConfigurationException("Unknown sitemap namespace (" + ns + ") at " +
                    this.source.getURI());
        }

        String version = re.getParen(1);
        String result = TreeBuilder.ROLE + "/sitemap-" + version;

        try {
            return (TreeBuilder) this.manager.lookup(result);
        } catch (Exception e) {
            throw new ConfigurationException("This version of Cocoon does not handle sitemap version " +
                                             version + " at " + this.source.getURI(), e);
        }
    }
17661#/**
     * Sets up the concrete processor, building or rebuilding it if necessary.
     */
    private void setupConcreteProcessor(Environment env) throws Exception {

        if (this.parent == null) {
            // Ensure root sitemap uses the correct context, even if not located in the webapp context
            this.environmentHelper.changeContext(this.source, "");
        }

        if (this.concreteProcessor == null ||
                (this.checkReload && (this.classReload || (this.source.getLastModified() != this.lastModified)))) {
            buildConcreteProcessor(env);
            this.classReload = false;
        }
    }
17662#private Configuration createSitemapProgram(Source sitemapSource)
    throws ProcessingException, SAXException, IOException {
        // do we validate? Default is false
        final String value = this.settings.getProperty("org.apache.cocoon.sitemap.validating", "false");
        if ( Boolean.valueOf(value).booleanValue() ) {
            if ( this.getLogger().isDebugEnabled() ) {
                this.getLogger().debug("Validating sitemap " + sitemapSource.getURI());
            }
            final Validator validator = this.sitemapSchema.newValidator();
            validator.validate(new StreamSource(sitemapSource.getInputStream()));
        }
        NamespacedSAXConfigurationHandler handler = new NamespacedSAXConfigurationHandler();
        AnnotationsFilter annotationsFilter = new AnnotationsFilter(handler);
        SourceUtil.toSAX(this.manager, sitemapSource, null, annotationsFilter);
        return handler.getConfiguration();        
    }
17663#/**
     * Build the concrete processor (i.e. loads the sitemap). Should be called
     * only by setupProcessor();
     */
    private synchronized void buildConcreteProcessor(Environment env) throws Exception {

        // Now that we entered the synchronized area, recheck what's already
        // been checked in process().
        if (this.concreteProcessor != null && !this.classReload && source.getLastModified() == this.lastModified) {
            // Nothing changed
            return;
        }

        long startTime = System.currentTimeMillis();
        long newLastModified;
        ConcreteTreeProcessor newProcessor;
        ConcreteTreeProcessor oldProcessor = this.concreteProcessor;
                
        if (oldProcessor != null) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("found a previous ConcreteTreeProcessor");
            }            
        } else {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("first version of the ConcreteTreeProcessor");
            }            
        }
        
        // Dispose the old processor, if any
        if (oldProcessor != null) {
            oldProcessor.markForDisposal();
        }


        // We have to do a call to enterProcessor() here as during building
        // of the tree, components (e.g. actions) are already instantiated
        // (ThreadSafe ones mostly).
        // If these components try to access the current processor or the
        // current service manager they must get this one - which is currently
        // in the process of initialization.
        EnvironmentHelper.enterProcessor(this, env);

        try {

            Configuration sitemapProgram = createSitemapProgram(this.source);
            newLastModified = this.source.getLastModified();

            newProcessor = new ConcreteTreeProcessor(this, this.sitemapExecutor);

            // Get the treebuilder that can handle this version of the sitemap.
            TreeBuilder treeBuilder = getTreeBuilder(sitemapProgram);
            try {
                treeBuilder.setProcessor(newProcessor);
                ProcessingNode root = treeBuilder.build(sitemapProgram, this.source.getURI());
                newProcessor.setProcessorData(
                        treeBuilder.getWebApplicationContext(),
                        root,
                        treeBuilder.getDisposableNodes(),
                        treeBuilder.getEnterSitemapEventListeners(),
                        treeBuilder.getLeaveSitemapEventListeners());
                
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("ConcreteTreeProcessor ready");
                }

                // Get the actual interpreter
                FlowNode flowNode = (FlowNode)treeBuilder.getRegisteredNode("flow");
                if ( flowNode != null ) {
                    final Interpreter interpreter = flowNode.getInterpreter();
                    newProcessor.setAttribute(Interpreter.ROLE, interpreter);
                }
                
            } finally {
                this.manager.release(treeBuilder);
            }
        } finally {
            EnvironmentHelper.leaveProcessor();
        }

        if (getLogger().isDebugEnabled()) {
            double time = (System.currentTimeMillis() - startTime) / 1000.0;
            getLogger().debug("TreeProcessor built in " + time + " secs from " + source.getURI());
        }

        // Switch to the new processor (ensure it's never temporarily null)
        this.concreteProcessor = newProcessor;
        this.lastModified = newLastModified;
    }
17664#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        // Dispose the concrete processor. No need to check for existing requests, as there
        // are none when a TreeProcessor is disposed.
        ContainerUtil.dispose(this.concreteProcessor);
        this.concreteProcessor = null;

        if (this.releaseSitemapExecutor) {
            this.manager.release(this.sitemapExecutor);
            this.sitemapExecutor = null;
        }

        if (this.manager != null) {
            if (this.source != null) {
                this.resolver.release(this.source.getSource());
                this.source = null;
            }
            this.manager.release(this.resolver);
            this.manager.release(this.settings);
            this.resolver = null;
            this.manager = null;
            this.settings = null;
        }
    }
17665#/**
     * @see org.apache.cocoon.Processor#getAttribute(java.lang.String)
     */
    public Object getAttribute(String name) {
        return this.concreteProcessor.getAttribute(name);
    }
17666#/**
     * @see org.apache.cocoon.Processor#removeAttribute(java.lang.String)
     */
    public Object removeAttribute(String name) {
        return this.concreteProcessor.removeAttribute(name);
    }
17667#/**
     * @see org.apache.cocoon.Processor#setAttribute(java.lang.String, java.lang.Object)
     */
    public void setAttribute(String name, Object value) {
        this.concreteProcessor.setAttribute(name, value);
    }
17668#/**
     * @see org.apache.cocoon.Processor#getParent()
     */
    public Processor getParent() {
        return this.parent;
    }
17669#public void handleNotification() {
        this.classReload = true;
    }
17670#/**
     * Resolve the links needed by the node built by this builder.
     */
    void linkNode() throws Exception;
17671#/**
     * Builds a concrete processig, given the wrapping processor
     */
    public ConcreteTreeProcessor(TreeProcessor wrappingProcessor,
                                 SitemapExecutor sitemapExecutor) {
        // Store our wrapping processor
        this.wrappingProcessor = wrappingProcessor;

        // Get the sitemap executor - we use the same executor for each sitemap
        this.sitemapExecutor = sitemapExecutor;
    }
17672#/** Set the processor data, result of the treebuilder job */
    public void setProcessorData(WebApplicationContext webAppContext,
                                 ProcessingNode rootNode,
                                 List disposableNodes,
                                 List enterSitemapEventListeners,
                                 List leaveSitemapEventListeners) {
        if (this.rootNode != null) {
            throw new IllegalStateException("setProcessorData() can only be called once");
        }
        this.classLoader = webAppContext.getClassLoader();
        this.webAppContext = webAppContext;
        this.manager = (ServiceManager)this.webAppContext.getBean(AvalonUtils.SERVICE_MANAGER_ROLE);
        this.rootNode = rootNode;
        this.disposableNodes = disposableNodes;
        this.enterSitemapEventListeners = enterSitemapEventListeners;
        this.leaveSitemapEventListeners = leaveSitemapEventListeners;
    }
17673#/**
     * Mark this processor as needing to be disposed. Actual call to {@link #dispose()} will occur when
     * all request processings on this processor will be terminated.
     */
    public void markForDisposal() {
        // Decrement the request count (negative number means dispose)
        synchronized(this) {
            this.requestCount--;
        }

        if (this.requestCount < 0) {
            // No more users : dispose right now
            dispose();
        }
    }
17674#public TreeProcessor getWrappingProcessor() {
        return this.wrappingProcessor;
    }
17675#/**
     * @see org.apache.cocoon.Processor#getRootProcessor()
     */
    public Processor getRootProcessor() {
        return this.wrappingProcessor.getRootProcessor();
    }
17676#/**
     * Process the given <code>Environment</code> producing the output.
     * @return If the processing is successfull <code>true</code> is returned.
     *         If not match is found in the sitemap <code>false</code>
     *         is returned.
     * @throws org.apache.cocoon.ResourceNotFoundException If a sitemap component tries
     *                                   to access a resource which can not
     *                                   be found, e.g. the generator
     *         ConnectionResetException  If the connection was reset
     */
    public boolean process(Environment environment) throws Exception {
        InvokeContext context = new InvokeContext();
        try {
            return process(environment, context);
        } finally {
            context.dispose();
        }
    }
17677#/**
     * Process the given <code>Environment</code> to assemble
     * a <code>ProcessingPipeline</code>.
     * @since 2.1
     */
    public InternalPipelineDescription buildPipeline(Environment environment)
    throws Exception {
        InvokeContext context = new InvokeContext(true);
        try {
            if (process(environment, context)) {
                return context.getInternalPipelineDescription(environment);
            }

            return null;
        } finally {
            context.dispose();
        }
    }
17678#/**
     * Do the actual processing, be it producing the response or just building the pipeline
     * @param environment
     * @param context
     * @return true if the pipeline was successfully built, false otherwise.
     * @throws Exception
     */
    protected boolean process(Environment environment, InvokeContext context)
    throws Exception {

        // Increment the concurrent requests count
        synchronized (this) {
            requestCount++;
        }

        ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(this.classLoader);
        Object handle = null;
        try {
            handle = WebAppContextUtils.enteringContext(this.webAppContext);
            // invoke listeners
            // only invoke if pipeline is not internally
            if (!context.isBuildingPipelineOnly()) {
                final EnterSitemapEvent enterEvent = new EnterSitemapEvent(this, environment);
                final Iterator i = this.enterSitemapEventListeners.iterator();
                while (i.hasNext()) {
                    final EnterSitemapEventListener current = (EnterSitemapEventListener) i.next();
                    current.enteredSitemap(enterEvent);
                }
            }

            this.sitemapExecutor.enterSitemap(this, environment.getObjectModel(), this.wrappingProcessor.source.getURI());

            // and now process
            EnvironmentHelper.enterProcessor(this, environment);
            final Redirector oldRedirector = context.getRedirector();
            try {
                // Build a redirector
                TreeProcessorRedirector redirector = new TreeProcessorRedirector(environment, context);
                context.setRedirector(redirector);
                context.service(this.manager);
                context.setLastProcessor(this);

                return this.rootNode.invoke(environment, context);
            } finally {
                EnvironmentHelper.leaveProcessor();
                // Restore old redirector
                context.setRedirector(oldRedirector);
            }

        } finally {
            if (handle != null) {
                this.sitemapExecutor.leaveSitemap(this, environment.getObjectModel());
                // invoke listeners
                // only invoke if pipeline is not internally
                if (!context.isBuildingPipelineOnly()) {
                    final LeaveSitemapEvent leaveEvent = new LeaveSitemapEvent(this, environment);
                    final Iterator i = this.leaveSitemapEventListeners.iterator();
                    while (i.hasNext()) {
                        final LeaveSitemapEventListener current = (LeaveSitemapEventListener) i.next();
                        current.leftSitemap(leaveEvent);
                    }
                }
                WebAppContextUtils.leavingContext(this.webAppContext, handle);
            }

            // Decrement the concurrent request count
            synchronized (this) {
                requestCount--;
            }

            if (requestCount < 0) {
                // Marked for disposal and no more concurrent requests.
                dispose();
            }
            Thread.currentThread().setContextClassLoader(oldClassLoader);
        }
    }
17679#protected boolean handleCocoonRedirect(String uri, Environment env, InvokeContext context)
    throws Exception {
        Environment environment = env;
        // Build an environment wrapper
        // If the current env is a facade, change the delegate and continue processing the facade, since
        // we may have other redirects that will in turn also change the facade delegate

        MutableEnvironmentFacade facade = environment instanceof MutableEnvironmentFacade ?
            ((MutableEnvironmentFacade)environment) : null;

        if (facade != null) {
            // Consider the facade delegate (the real environment)
            environment = facade.getDelegate();
        }

        // test if this is a call from flow
        boolean isRedirect = (environment.getObjectModel().remove("cocoon:forward") == null);
        final SitemapSourceInfo info = SitemapSourceInfo.parseURI(environment, uri);
        Environment newEnv = new ForwardEnvironmentWrapper(environment, info);
        if (isRedirect) {
            ((ForwardEnvironmentWrapper) newEnv).setInternalRedirect(true);
        }

        if (facade != null) {
            // Change the facade delegate
            facade.setDelegate((ForwardEnvironmentWrapper)newEnv);
            newEnv = facade;
        }

        // Get the processor that should process this request
        ConcreteTreeProcessor processor;
        if (newEnv.getURIPrefix().equals("")) {
            processor = ((TreeProcessor)getRootProcessor()).concreteProcessor;
        } else {
            processor = this;
        }

        // Process the redirect
        // No more reset since with TreeProcessorRedirector, we need to pop values from the redirect location
        // context.reset();
        // The following is a fix for bug #26854 and #26571
        final boolean result = processor.process(newEnv, context);
        if (facade != null) {
            newEnv = facade.getDelegate();
        }
        if (((ForwardEnvironmentWrapper) newEnv).getRedirectURL() != null) {
            environment.redirect(((ForwardEnvironmentWrapper) newEnv).getRedirectURL(), false, false);
        }
        return result;
    }
17680#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        if (this.disposableNodes != null) {
            // we must dispose the nodes in reverse order
            // otherwise selector nodes are freed before the components node
            for (int i = this.disposableNodes.size() - 1; i > -1; i--) {
                ((Disposable) disposableNodes.get(i)).dispose();
            }
            this.disposableNodes = null;
        }

        // Ensure it won't be used anymore
        this.rootNode = null;
        this.sitemapExecutor = null;

        // clear listeners
        this.enterSitemapEventListeners.clear();
        this.leaveSitemapEventListeners.clear();
        if ( this.webAppContext != null ) {
            if ( webAppContext instanceof ConfigurableApplicationContext ) {
                ((ConfigurableApplicationContext)webAppContext).close();
            } else if ( webAppContext instanceof ConfigurableBeanFactory ) {
                ((ConfigurableBeanFactory)webAppContext).destroySingletons();
            }
            this.webAppContext = null;
        }
    }
17681#public SourceResolver getSourceResolver() {
        return wrappingProcessor.getSourceResolver();
    }
17682#public String getContext() {
        return wrappingProcessor.getContext();
    }
17683#/**
     * Return the sitemap executor
     */
    public SitemapExecutor getSitemapExecutor() {
        return this.sitemapExecutor;
    }
17684#public ServiceManager getServiceManager() {
        return this.manager;
    }
17685#/**
     * @see org.apache.cocoon.Processor#getAttribute(java.lang.String)
     */
    public Object getAttribute(String name) {
        return this.processorAttributes.get(name);
    }
17686#/**
     * @see org.apache.cocoon.Processor#removeAttribute(java.lang.String)
     */
    public Object removeAttribute(String name) {
        return this.processorAttributes.remove(name);
    }
17687#/**
     * @see org.apache.cocoon.Processor#setAttribute(java.lang.String, java.lang.Object)
     */
    public void setAttribute(String name, Object value) {
        this.processorAttributes.put(name, value);
    }
17688#/**
     * @see org.apache.cocoon.sitemap.ExecutionContext#getLocation()
     */
    public Location getLocation() {
        return new LocationImpl("[sitemap]", this.wrappingProcessor.source.getURI());
    }
17689#/**
     * @see org.apache.cocoon.sitemap.ExecutionContext#getType()
     */
    public String getType() {
        return "sitemap";
    }
17690#/**
     * @see org.apache.cocoon.Processor#getParent()
     */
    public Processor getParent() {
        return this.wrappingProcessor.getParent();
    }
17691#public TreeProcessorRedirector(Environment env, InvokeContext context) {
            super(env);
            this.context = context;
        }
17692#protected void cocoonRedirect(String uri) throws IOException, ProcessingException {
            try {
                ConcreteTreeProcessor.this.handleCocoonRedirect(uri, this.env, this.context);
            } catch (IOException e) {
                throw e;
            } catch (ProcessingException e) {
                throw e;
            } catch (RuntimeException e) {
                throw e;
            } catch (Exception e) {
                throw new ProcessingException(e);
            }
        }
17693#/**
     * @see ProcessingNodeBuilder#setBuilder(TreeBuilder)
     */
    public void setBuilder(TreeBuilder treeBuilder) {
        this.treeBuilder = treeBuilder;
        this.manager = (ServiceManager) treeBuilder.getWebApplicationContext().getBean(AvalonUtils.SERVICE_MANAGER_ROLE);
    }
17694#/**
     * Does this node accept parameters ? Default is true : if a builder that doesn't
     * have parameters doesn't override this method, erroneous parameters will be silently
     * ignored.
     */
    protected boolean hasParameters() {
        return true;
    }
17695#/**
     * Check if the namespace URI of the given configuraition is the same as the
     * one given by the builder.
     */
    protected void checkNamespace(Configuration config) throws ConfigurationException {
        if (!this.treeBuilder.getNamespace().equals(config.getNamespace())) {
            String msg = "Invalid namespace '" + config.getNamespace() + "' at " + config.getLocation();
            throw new ConfigurationException(msg);
        }
    }
17696#/**
     * Set the parameters of this node as a <code>Map</code> of <code>VariableResolver</code>s
     * that will be resolved at process-time.
     */
    void setParameters(Map parameterMap);
17697#/**
     * Configure the sets of allowed, forbidden and ignored children nodes.
     */
    public void configure(Configuration config) throws ConfigurationException {
        this.allowedChildren   = getStringCollection(config.getChild("allowed-children"));
        this.forbiddenChildren = getStringCollection(config.getChild("forbidden-children"));
        this.ignoredChildren   = getStringCollection(config.getChild("ignored-children"));
    }
17698#/**
     * Checks if a child element and is allowed, and if not throws a <code>ConfigurationException</code>.
     *
     * @param child the child configuration to check.
     * @return <code>true</code> if this child should be considered or <code>false</code>
     *         if it should be ignored.
     * @throws ConfigurationException if this child isn't allowed.
     */
    protected boolean isChild(Configuration child) throws ConfigurationException {

        checkNamespace(child);

        String name = child.getName();

        // Is this a parameter of a parameterizable node builder ?
        if (isParameter(child)) {
            return false;
        }

        // Is this element to be ignored ?
        if (ignoredChildren != null && ignoredChildren.contains(name)) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Element '" + name + "' is ignored for building children of element '" +
                                  child.getName() + "'");
            }

            return false;
        }

        // Is it allowed ?
        if ( (allowedChildren != null && !allowedChildren.contains(name)) ||
             (forbiddenChildren != null && forbiddenChildren.contains(name)) ) {
            String msg = "Element '" + name + "' is not allowed at " + child.getLocation();
            throw new ConfigurationException(msg);
        }

        return true;
    }
17699#protected boolean isParameter(Configuration config) throws ConfigurationException {
        final String name = config.getName();
        if (name.equals("parameter")) {
            if (this.hasParameters()) {
                return true;
            }
            String msg = "Element '" + name + "' has no parameters at " + config.getLocation();
            throw new ConfigurationException(msg);
        }
        return false;
    }
17700#/**
     * Create the <code>ProcessingNode</code>s for the children of a given node.
     * Child nodes are controlled to be actually allowed in this node.
     */
    protected List buildChildNodesList(Configuration config) throws Exception {

        Configuration[] children = config.getChildren();
        List result = new ArrayList();

        for (int i = 0; i < children.length; i++) {

            Configuration child = children[i];
            try {
                 if (isChild(child)) {
                    // OK : get a builder.
                    ProcessingNodeBuilder childBuilder = this.treeBuilder.createNodeBuilder(child);
                    result.add(childBuilder.buildNode(child));
                }

            } catch(ConfigurationException ce) {
                throw ce;
            } catch(Exception e) {
                String msg = "Error while creating node '" + child.getName() + "' at " + child.getLocation();
                throw new ConfigurationException(msg, e);
            }
        }

        return result;
    }
17701#protected ProcessingNode[] buildChildNodes(Configuration config) throws Exception {
        return toNodeArray(buildChildNodesList(config));
    }
17702#/**
     * Convenience function that converts a <code>List</code> of <code>ProcessingNode</code>s
     * to an array.
     */
    public static ProcessingNode[] toNodeArray(List list) {
        return (ProcessingNode[])list.toArray(new ProcessingNode[list.size()]);
    }
17703#/**
     * Splits the value of a Configuration in a Collection of Strings. Splitting
     * occurs at space characters (incl. line breaks) and comma.
     *
     * @return a collection of Strings, or null if <code>config</code> has no value.
     */
    private Collection getStringCollection(Configuration config) {
        String s = config.getValue(null);

        return (s == null) ? null : Arrays.asList(StringUtils.split(s, ", \t\n\r"));
    }
17704#private boolean isOutsideAnnotation()
    {
        return nestingLevel == 0;
    }
17705#public AnnotationsFilter(ContentHandler delegate) {
        this.delegate = delegate;
    }
17706#public void setDocumentLocator(Locator locator) {
        delegate.setDocumentLocator(locator);
    }
17707#public void startDocument() throws SAXException {
        delegate.startDocument();
    }
17708#public void endDocument() throws SAXException {
        delegate.endDocument();
    }
17709#public void startPrefixMapping(String prefix, String namespaceURI) throws SAXException {
        if (isOutsideAnnotation()) {
            delegate.startPrefixMapping(prefix, namespaceURI);
        }
    }
17710#public void endPrefixMapping(String prefix) throws SAXException {
        if (isOutsideAnnotation()) {
            delegate.endPrefixMapping(prefix);
        }
    }
17711#public void startElement(String namespaceURI, String localName, String qName, Attributes attributes) throws SAXException {
        if (namespaceURI !=  null && namespaceURI.equals(ANNOTATIONS_NAMESPACE)) {
            nestingLevel++;
        }
        if (isOutsideAnnotation()) {
            delegate.startElement(namespaceURI, localName, qName, attributes);
        }
    }
17712#public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
        if (isOutsideAnnotation()) {
            delegate.endElement(namespaceURI, localName, qName);
        }
        if (namespaceURI !=  null && namespaceURI.equals(ANNOTATIONS_NAMESPACE)) {
            nestingLevel--;
        }
    }
17713#public void characters(char[] ch, int start, int len) throws SAXException {
        if (isOutsideAnnotation()) {
            delegate.characters(ch, start, len);
        }
    }
17714#public void ignorableWhitespace(char[] ch, int start, int len) throws SAXException {
        if (isOutsideAnnotation()) {
            delegate.ignorableWhitespace(ch, start, len);
        }
    }
17715#public void processingInstruction(String target, String data) throws SAXException {
        if (isOutsideAnnotation()) {
            delegate.processingInstruction(target, data);
        }
    }
17716#public void skippedEntity(String name) throws SAXException {
        if (isOutsideAnnotation()) {
            delegate.skippedEntity(name);
        }
    }
17717#public SimpleParentProcessingNode(String type) {
        super(type);
    }
17718#public void setChildren(ProcessingNode[] children) {
        this.children = children;
    }
17719#/**
     * Boolean method with returns true if this Node has children
     * and false otherwise.
     *
     * @return boolean true if has children.
     */
    public boolean hasChildren() {
        return this.children != null && this.children.length > 0;
    }
17720#/**
     * Define common invoke behavior here
     */
    public boolean invoke(Environment env, InvokeContext context) throws Exception {
        // Inform the pipeline (if available) that we have come across
        // a possible branch point
        if (context.hasPipeline() && hasChildren()) {
            context.getProcessingPipeline().informBranchPoint();
        }

        // processing not yet complete, so return false
        return false;
    }
17721#/** This builder has no parameters -- return <code>false</code> */
    protected boolean hasParameters() {
        return false;
    }
17722#public ProcessingNode buildNode(Configuration config) throws Exception {

        ContainerNode node = new ContainerNode(null);
        setupNode(node, config);

        return node;
    }
17723#protected void setupNode(ContainerNode node, Configuration config)throws Exception {

        this.treeBuilder.setupNode(node, config);

        ProcessingNode[] children = buildChildNodes(config);
        if (children.length == 0) {
            String msg = "There must be at least one child at " + config.getLocation();
            throw new ConfigurationException(msg);
        }

        node.setChildren(children);
    }
17724#/**
     * Create an <code>InvokeContext</code> without existing pipelines. This also means
     * the current request is external.
     */
    public InvokeContext() {
        this.isBuildingPipelineOnly = false;
    }
17725#/**
     * Create an <code>InvokeContext</code>
     */
    public InvokeContext(boolean isBuildingPipelineOnly) {
        this.isBuildingPipelineOnly = isBuildingPipelineOnly;
    }
17726#/**
     * Create an <code>InvokeContext</code> based on existing context.
     */
    public InvokeContext(InvokeContext context, ServiceManager manager) throws ServiceException {
        this.isBuildingPipelineOnly = context.isBuildingPipelineOnly;
        this.redirector = context.redirector;
        this.lastProcessor = context.lastProcessor;
        service(manager);
        inform(context.processingPipelineType, context.processingPipelineParameters);
    }
17727#/**
     * Serviceable interface. InvokeContext receives manager from {@link ConcreteTreeProcessor}.
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.currentManager = manager;
        if (this.processingPipeline != null) {
            this.processingPipeline.setProcessorManager(manager);
        }
        this.newObjectModel = (ObjectModel) manager.lookup(ObjectModel.ROLE);
    }
17728#/**
     * Are we building a pipeline (and not executing it) ?
     */
    public final boolean isBuildingPipelineOnly() {
        return this.isBuildingPipelineOnly;
    }
17729#/**
     * Set the redirector to be used by nodes that need it.
     *
     * @param redirector the redirector
     */
    public void setRedirector(Redirector redirector) {
        this.redirector = redirector;
    }
17730#/**
     * Get the redirector to be used by nodes that need it.
     *
     * @return the redirector
     */
    public Redirector getRedirector() {
        return this.redirector;
    }
17731#/**
     * Set the last processor
     */
    public void setLastProcessor(Processor p) {
        this.lastProcessor = p;
    }
17732#/**
     * Informs the context about a new pipeline section
     */
    public void inform(String     pipelineType,
                       Parameters parameters) {
        this.processingPipelineType = pipelineType;
        this.processingPipelineParameters = parameters;
    }
17733#public String getPipelineType() {
        return this.processingPipelineType;
    }
17734#public Parameters getPipelineParameters() {
        return this.processingPipelineParameters;
    }
17735#/**
     * Set the error handler for the pipeline.
     */
    public void setErrorHandler(SitemapErrorHandler handler) {
        this.errorHandler = handler;
    }
17736#/**
     * Returns true if pipeline has been set for this context
     */
    public boolean hasPipeline() {
	    return this.processingPipeline != null;
    }
17737#/**
     * Get the current <code>ProcessingPipeline</code>
     */
    public ProcessingPipeline getProcessingPipeline()
    throws Exception {
        if (this.processingPipeline == null) {
            // Keep current manager for proper release
            this.pipelinesManager = this.currentManager;

            this.processingPipeline = (ProcessingPipeline) this.pipelinesManager.lookup(ProcessingPipeline.ROLE + '/' + this.processingPipelineType);
            this.processingPipeline.setProcessorManager(this.pipelinesManager);

            this.processingPipeline.setup(this.processingPipelineParameters);
            this.processingPipeline.setErrorHandler(this.errorHandler);
        }

        return this.processingPipeline;
    }
17738#/**
     * Set the processing pipeline for sub-sitemaps
     */
    public void setInternalPipelineDescription(Processor.InternalPipelineDescription desc) {
        this.processingPipeline = desc.processingPipeline;
        this.pipelinesManager = desc.pipelineManager;
        this.lastProcessor = desc.processor;
        this.internalPipelineDescription = new Processor.InternalPipelineDescription(this.lastProcessor, this.pipelinesManager, this.processingPipeline);
        this.internalPipelineDescription.prefix = desc.prefix;
        this.internalPipelineDescription.uri = desc.uri;
    }
17739#/**
     * Get the pipeline description
     */
    public Processor.InternalPipelineDescription getInternalPipelineDescription(Environment env) {
        if (this.internalPipelineDescription == null) {
            this.internalPipelineDescription = new Processor.InternalPipelineDescription(this.lastProcessor, this.pipelinesManager, this.processingPipeline);
            this.internalPipelineDescription.prefix = env.getURIPrefix();
            this.internalPipelineDescription.uri = env.getURI();
        }

        return this.internalPipelineDescription;
    }
17740#/**
     * Get the current Map stack used to resolve expressions.
     */
    public final List getMapStack() {
        return this.mapStack;
    }
17741#/**
     * Get the result Map by anchor name
     */
    public final Map getMapByAnchor(String anchor) {
        return (Map) this.nameToMap.get(anchor);
    }
17742#/**
     * Push a Map on top of the current Map stack.
     */
    public final void pushMap(String anchorName, Map map) {
        final String sitemapObjectModelPathPrefix = "sitemap";
        final String sitemapObjectModelNamedPathPrefix = sitemapObjectModelPathPrefix + "/$named$";
        
        //if cocoon: protocol is used the isBuildingPipelineOnly() is true that means pipeline going to be set up 
        //but not executed at the same time therefore it must be cocoon: protocol that takes responsibility for 
        //maintaining OM's cleaness 
        if (!isBuildingPipelineOnly())
        	newObjectModel.markLocalContext();
        
        this.mapStack.add(map);

        if (getLogger().isDebugEnabled()) {
            dumpParameters();
        }

        if (anchorName != null) {
            if (!this.nameToMap.containsKey(anchorName)) {
                this.nameToMap.put(anchorName,map);
                this.mapToName.put(map,anchorName);
            } else {
                if (getLogger().isErrorEnabled()) {
                    getLogger().error("name [" + anchorName + "] clashes");
                }
            }
            newObjectModel.putAt(sitemapObjectModelNamedPathPrefix + "/" + anchorName, map);
        } else {
            newObjectModel.putAt(sitemapObjectModelPathPrefix, map);
        }
    }
17743#/**
     * Pop the topmost element of the current Map stack.
     */
    public final void popMap() {
        Object map = this.mapStack.remove(this.mapStack.size() - 1);
        Object name = this.mapToName.get(map);
        this.mapToName.remove(map);
        this.nameToMap.remove(name);
        //if cocoon: protocol is used the isBuildingPipelineOnly() is true that means pipeline going to be set up
        //but not executed at the same time therefore it must be cocoon: protocol that takes responsibility for
        //maintaining OM's cleaness
        if (!isBuildingPipelineOnly()) {
        	this.newObjectModel.cleanupLocalContext();
        }
    }
17744#/**
     * Dumps all sitemap parameters to log
     */
    protected void dumpParameters() {
        if (!this.mapStack.isEmpty()) {
            StringBuffer sb = new StringBuffer();

            sb.append("\nCurrent Sitemap Parameters:\n");
            String path = "";

            for (int i = this.mapStack.size() - 1; i >= 0; i--) {
                Map map = (Map) this.mapStack.get(i);
                sb.append("LEVEL ").append(i+1);
                if (this.mapToName.containsKey(map)) {
                    sb.append(" is named '").append(String.valueOf(this.mapToName.get(map))).append("'");
                }
                sb.append("\n");

                for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
                    final Map.Entry me = (Map.Entry)iter.next();
                    final Object key = me.getKey();
                    sb.append("PARAM: '").append(path).append(key).append("' ");
                    sb.append("VALUE: '").append(map.get(key)).append("'\n");
                }

                path = "../" + path;
            }

            getLogger().debug(sb.toString());
        }
    }
17745#/**
     * Release the pipelines, if any, if they were looked up by this context.
     */
    public void dispose() {
        if (this.internalPipelineDescription == null && this.pipelinesManager != null) {
            if (this.processingPipeline != null) {
                this.pipelinesManager.release(this.processingPipeline);
                this.processingPipeline = null;
            }
            this.pipelinesManager = null;

            this.processingPipelineType = null;
            this.processingPipelineParameters = null;
        }

        if (this.newObjectModel != null) {
            this.currentManager.release(this.newObjectModel);
            this.newObjectModel = null;
        }

        this.currentManager = null;
    }
17746#public NamedContainerNode(String name) {
        super(name);
        this.name = name;
    }
17747#public String getName() {
        return this.name;
    }
17748#public ContainerNode(String type) {
        super(type);
    }
17749#/* (non-Javadoc)
     * @see ProcessingNode#invoke(Environment, InvokeContext)
     */
    public final boolean invoke(Environment env, InvokeContext context) throws Exception {

        return invokeNodes(this.children, env, context);
    }
17750#String getName();
17751#/**
     * The category name is the value of the "category-name" child, or if not
     * present, the name of the configuration element.
     */
    public void configure(Configuration config) throws ConfigurationException {
        super.configure(config);
        this.name = config.getChild("category-name").getValue(config.getAttribute("name"));
    }
17752#/** This builder has no parameters -- return <code>false</code> */
    protected boolean hasParameters() {
        return false;
    }
17753#public ProcessingNode buildNode(Configuration config) throws Exception {

        CategoryNode node = new CategoryNode(null);
        this.treeBuilder.setupNode(node, config);

        // Get all children and associate them to their name
        Map category = new HashMap();

        List children = buildChildNodesList(config);
        Iterator iter = children.iterator();
        while(iter.hasNext()) {
            NamedProcessingNode child = (NamedProcessingNode)iter.next();
            category.put(child.getName(), child);
        }

        node.setCategory(this.name, category);

        // Register node to allow lookup by other nodes
        if ( !this.treeBuilder.registerNode(PREFIX + this.name, node) ) {
            throw new ConfigurationException("Only one <map:" + this.name +
                    "> is allowed in a sitemap. Another one is declared at " +
                    config.getLocation());
        }

        return node;
    }
17754#public static CategoryNode getCategoryNode(TreeBuilder builder, String categoryName) {
        return (CategoryNode)builder.getRegisteredNode(PREFIX + categoryName);
    }
17755#public static ProcessingNode getNamedNode(TreeBuilder builder, String categoryName, String nodeName)
      throws Exception {
        CategoryNode category = getCategoryNode(builder, categoryName);

        return category.getNodeByName(nodeName);
    }
17756#public PipelineEventComponentProcessingNode() {
        super(null);
    }
17757#public void setViews(Map views) {
        this.views = views;
    }
17758#// Set any pipeline-hint parameters
    public void setPipelineHints(Map parameterMap) {
        this.pipelineHints = parameterMap;
    }
17759#public boolean hasViews() {
        return this.views != null;
    }
17760#WebApplicationContext getWebApplicationContext();
17761#ConcreteTreeProcessor getProcessor();
17762#void setProcessor(ConcreteTreeProcessor processor);
17763#/**
     * Register a <code>ProcessingNode</code> under a given name.
     * For example, <code>ResourceNodeBuilder</code> stores here the <code>ProcessingNode</code>s
     * it produces for use by sitemap pipelines. This allows to turn the tree into a graph.
     * If a node with the name is already registed, the process fails!
     * @return If the node could be registered, <code>true</code> is returned; otherwise false.
     */
    boolean registerNode(String name, ProcessingNode node);
17764#/**
     * @throws IllegalStateException
     */
    ProcessingNode getRegisteredNode(String name);
17765#ProcessingNodeBuilder createNodeBuilder(Configuration config) throws Exception;
17766#/**
     * Get the namespace URI that builders should use to find their nodes.
     */
    String getNamespace();
17767#/**
     * Build a processing tree from a <code>Configuration</code> object holding the sitemap program.
     */
    ProcessingNode build(Configuration config, String location) throws Exception;
17768#/**
     * Return the list of <code>ProcessingNodes</code> part of this tree that are
     * <code>Disposable</code>. Care should be taken to properly dispose them before
     * trashing the processing tree.
     */
    List getDisposableNodes();
17769#/**
     * Setup a <code>ProcessingNode</code> by setting its location, calling all
     * the lifecycle interfaces it implements and giving it the parameter map if
     * it's a <code>ParameterizableNode</code>.
     * <p>
     * As a convenience, the node is returned by this method to allow constructs
     * like <code>return treeBuilder.setupNode(new MyNode(), config)</code>.
     */
    ProcessingNode setupNode(ProcessingNode node, Configuration config) throws Exception;
17770#/**
     * Get the type for a statement : it returns the 'type' attribute if present,
     * and otherwhise the default hint for the <code>ServiceSelector</code> identified by
     * the role <code>role</code>.
     *
     * @param statement the statement
     * @param role the component's role (warn: not the selector's role)
     *
     * @throws ConfigurationException if the default type could not be found.
     */
    String getTypeForStatement(Configuration statement, String role) throws ConfigurationException;
17771#/**
     * Add an attribute. Useful to transmit information between distant (in the tree) node builders
     */
    void setAttribute(String name, Object value);
17772#/**
     * Get the value of an attribute.
     */
    Object getAttribute(String name);
17773#/**
     * Return all event listers that are registered for the
     * {@link org.apache.cocoon.sitemap.EnterSitemapEvent}.
     * @return A list of components.
     */
    List getEnterSitemapEventListeners();
17774#/**
     * Return all event listers that are registered for the
     * {@link org.apache.cocoon.sitemap.LeaveSitemapEvent}.
     * @return A list of components.
     */
    List getLeaveSitemapEventListeners();
17775#public AbstractParentProcessingNode(String type) {
        super(type);
    }
17776#public AbstractParentProcessingNode() {
        this(null);
    }
17777#/**
     * Invoke all nodes of a node array in order, until one succeeds.
     *
     * @param currentMap the <code>Map<code> of parameters produced by this node,
     *            which is added to <code>listOfMap</code>.
     */
    protected final boolean invokeNodes(ProcessingNode[] nodes,
                                        Environment env,
                                        InvokeContext context,
                                        String currentName,
                                        Map currentMap)
    throws Exception {

        currentMap = this.executor.pushVariables(this, env.getObjectModel(), currentName, currentMap);
        context.pushMap(currentName, currentMap);

        try {
            for (int i = 0; i < nodes.length; i++) {
                if (nodes[i].invoke(env, context)) {
                    // Success
                    return true;
                }
            }
        } finally {
            this.executor.popVariables(this, env.getObjectModel());
            context.popMap();
        }

        // No success
        return false;
    }
17778#/**
     * Invoke all nodes of a node array in order, until one succeeds.
     */
    protected final boolean invokeNodes(ProcessingNode[] nodes,
                                        Environment env,
                                        InvokeContext context)
    throws Exception {

        for (int i = 0; i < nodes.length; i++) {
            if (nodes[i].invoke(env, context)) {
                return true;
            }
        }

        return false;
    }
17779#/**
     * @see Contextualizable#contextualize(Context)
     */
    public void contextualize(final Context avalonContext) {
        this.context = avalonContext;
    }
17780#/**
     * @see Serviceable#service(ServiceManager)
     */
    public void service(final ServiceManager componentManager)
    throws ServiceException {
        this.serviceManager = componentManager;
    }
17781#/**
     * @see Configurable#configure(Configuration)
     */
    public void configure(final Configuration config)
    throws ConfigurationException {
        final Configuration[] instances = config.getChildren();
        for (int i = 0; i < instances.length; i++) {
            final Configuration instance = instances[i];
            final String name = instance.getAttribute("name").trim();
            final String className = instance.getAttribute("builder").trim();
            try {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Adding builder (" + name + " = " + className + ")");
                }

                final Class clazz = getClass().getClassLoader().loadClass(className);

                final BuilderInfo info = new BuilderInfo();
                info.builderClass = clazz;
                info.configuration = instance;

                this.componentInfos.put(name, info);

            } catch (final ClassNotFoundException cnfe) {
                final String message = "Could not get class (" + className + ") for builder " + name + " at " +
                                       instance.getLocation();
                throw new ConfigurationException(message, cnfe);
            } catch (final Exception e) {
                final String message = "Unexpected exception when setting up builder " + name + " at " + instance.getLocation();
                throw new ConfigurationException(message, e);
            }
        }
    }
17782#/**
     * @see Initializable#initialize()
     */
    public void initialize()
    throws Exception {
        final Iterator i = this.componentInfos.entrySet().iterator();
        while (i.hasNext()) {
            final Map.Entry entry = (Map.Entry) i.next();
            final BuilderInfo info = (BuilderInfo) entry.getValue();
            if (ThreadSafe.class.isAssignableFrom(info.builderClass)) {
                this.singletons.put(entry.getKey(), this.createComponent(info));
            }
        }
    }
17783#public Object getBuilder(String name)
    throws Exception {
        Object component = this.singletons.get(name);
        if (component == null) {
            final BuilderInfo info = (BuilderInfo) this.componentInfos.get(name);
            if (info == null) {
                throw new Exception("Node builder selector could not find builder for key [" + name + "]");
            }

            // Retrieve the instance of the requested component
            try {
                component = createComponent(info);
            } catch (Exception e) {
                throw new Exception("Unable to create new builder: " + name, e);
            }
        }

        return component;
    }
17784#/**
     * Create a new component.
     */
    protected Object createComponent(BuilderInfo info)
    throws Exception {
        final Object component = info.builderClass.newInstance();
        ContainerUtil.contextualize(component, this.context);
        ContainerUtil.service(component, this.serviceManager);
        ContainerUtil.configure(component, info.configuration);
        if (component instanceof Parameterizable) {
            ContainerUtil.parameterize(component, Parameters.fromConfiguration(info.configuration));
        }
        ContainerUtil.initialize(component);
        return component;
    }
17785#/**
     * A constructor to receive the optional expires parameter
     * and optional parameters for the processing pipeline
     */
    public PipelineNode(String name) {
        this.processingPipeline = name;
        this.errorHandlerHelper = new ErrorHandlerHelper();
    }
17786#/**
     * The component manager is used to create error pipelines
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.errorHandlerHelper.service(manager);
    }
17787#public void setChildren(ProcessingNode[] nodes) {
        this.children = nodes;
    }
17788#public void setParameters(Map parameterMap) {
        this.parameters = parameterMap;
    }
17789#public void setLast(boolean isLast) {
        this.isLast = isLast;
    }
17790#public void setErrorHandler(ProcessingNode node) {
        this.errorHandlerHelper.setErrorHandler(node);
    }
17791#public void setInternalOnly(boolean internalOnly) {
        this.internalOnly = internalOnly;
    }
17792#public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {

        boolean passThrough;
        Object passThroughRaw = env.getAttribute(MountNode.COCOON_PASS_THROUGH);
        if (passThroughRaw == null) {
            // Use default value
            passThrough = false;
        } else {
            passThrough = ((Boolean) passThroughRaw).booleanValue();
        }

        // Always fail on external request if pipeline is internal only.
        if (this.internalOnly && env.isExternal()) {
            if (!this.isLast || passThrough) {
                return false;
            }

            // Do not use internal-only pipeline error handler for external requests.
            throw new ResourceNotFoundException("No pipeline matched request: " +
                                                env.getURIPrefix() + env.getURI());
        }

        Parameters params = VariableResolver.buildParameters(this.parameters,
                                                             context,
                                                             env.getObjectModel());

        SitemapExecutor.PipelineComponentDescription desc = new SitemapExecutor.PipelineComponentDescription();
        desc.type = this.processingPipeline;
        desc.parameters = params;
        desc = this.executor.enteringPipeline(this, env.getObjectModel(), desc);

        context.inform(desc.type, desc.parameters);

        try {
            if (this.errorHandlerHelper.isInternal()) {
                // Set internal error handler in the pipeline
                context.setErrorHandler(
                        new TreeProcessorSitemapErrorHandler(this.errorHandlerHelper, env, context));
            } else {
                // Reset internal error handler (previous pipeline might had set it)
                context.setErrorHandler(null);
            }

            if (invokeNodes(children, env, context)) {
                return true;
            } else if (!this.isLast || passThrough) {
                return false;
            }

            throw new ResourceNotFoundException("No pipeline matched request: " +
                            env.getURIPrefix() + env.getURI());


        } catch (ConnectionResetException e) {
            // Will be reported by CocoonServlet, rethrowing
            throw e;
        } catch (Exception e) {
            // Invoke error handler
            return this.errorHandlerHelper.invokeErrorHandler(e, env, context);
        }

    }
17793#public SwitchSelectNode(String name) {
        super(Selector.ROLE + "Selector", name);
    }
17794#public void setParameters(Map parameterMap) {
        this.parameters = parameterMap;
    }
17795#public void setCases(ProcessingNode[][] whenNodes, VariableResolver[] whenTests, ProcessingNode[] otherwhiseNodes) {
        this.whenNodes = whenNodes;
        this.whenTests = whenTests;
        this.otherwhiseNodes = otherwhiseNodes;
    }
17796#public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {
	
      	// Perform any common invoke functionality 
        super.invoke(env, context);

        // Prepare data needed by the action
        final Map objectModel = env.getObjectModel();
        Parameters resolvedParams = VariableResolver.buildParameters(this.parameters, context, objectModel);

        SwitchSelector switchSelector = (SwitchSelector)getComponent();

        Object ctx = switchSelector.getSelectorContext(objectModel, resolvedParams);
       
        try {
            for (int i = 0; i < this.whenTests.length; i++) {
                if (this.executor.invokeSwitchSelector(this, 
                        objectModel, 
                        switchSelector, 
                        whenTests[i].resolve(context, objectModel), 
                        resolvedParams, 
                        ctx)) {
                    return invokeNodes(this.whenNodes[i], env, context);
                }
            }

            if (this.otherwhiseNodes != null) {
                return invokeNodes(this.otherwhiseNodes, env, context);
            }

            return false;
        } finally {
            releaseComponent(switchSelector);
        }
    }
17797#public ActSetNode() {
        super(null);
    }
17798#public void setParameters(Map parameterMap) {
        this.parameters = parameterMap;
    }
17799#public void setActionSet(ActionSetNode actionSet) {
        this.actionSet = actionSet;
    }
17800#public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {

        // Perform any common invoke functionality
        super.invoke(env, context);

        Parameters resolvedParams = VariableResolver.buildParameters(
            this.parameters,
            context,
            env.getObjectModel()
        );

        try {
            Map result = this.actionSet.call(env, context, resolvedParams);

            if (context.getRedirector().hasRedirected()) {
                return true;

            } else if (result == null) {
                return false;

            } else if (this.children == null) {
                return true;

            } else {
                return this.invokeNodes(this.children, env, context, null, result);
            }
        } catch (Exception e) {
            throw ProcessingException.throwLocated("Sitemap: error invoking action set", e, getLocation());
        }
    }
17801#/** This builder has no parameters -- return <code>false</code> */
    protected boolean hasParameters() {
        return false;
    }
17802#public ProcessingNode buildNode(Configuration config) throws Exception {
        // Handle the VPCs
/*
        for (int i = 0; i < VPCTypes.length; i++) {
            Configuration child = config.getChild(VPCTypes[i], false);
            if (child != null) {
                ProcessingNodeBuilder childBuilder =
                    this.treeBuilder.createNodeBuilder(child);
                childBuilder.buildNode(child);
            }
        }
*/
        return null;
    }
17803#public GenerateNode(String name, VariableResolver source) {
        this.generatorName = name;
        this.source = source;
    }
17804#public void setParameters(Map parameterMap) {
        this.parameters = parameterMap;
    }
17805#/* (non-Javadoc)
     * @see ProcessingNode#invoke(Environment, InvokeContext)
     */
    public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {

        final Map objectModel = env.getObjectModel();

        SitemapExecutor.PipelineComponentDescription desc = new SitemapExecutor.PipelineComponentDescription();
        desc.type = this.generatorName;
        desc.source = source.resolve(context, objectModel);
        desc.parameters = VariableResolver.buildParameters(this.parameters, context, objectModel);
        desc.hintParameters = this.pipelineHints == null
                ? Parameters.EMPTY_PARAMETERS
                : VariableResolver.buildParameters(this.pipelineHints, context, objectModel);

        desc = this.executor.addGenerator(this, objectModel, desc);

        context.getProcessingPipeline().setGenerator(desc.type,
                                                     desc.source,
                                                     desc.parameters,
                                                     desc.hintParameters);

        // Check view
        if (this.views != null) {
            //inform the pipeline that we have a branch point
            context.getProcessingPipeline().informBranchPoint();

            String cocoonView = env.getView();
            if (cocoonView != null) {

                // Get view node
                ProcessingNode viewNode = (ProcessingNode) this.views.get(cocoonView);

                if (viewNode != null) {
                    if (getLogger().isInfoEnabled()) {
                        getLogger().info("Jumping to view " + cocoonView + " from generator at " + this.getLocation());
                    }
                    return viewNode.invoke(env, context);
                }
            }
        }

        // Return false to continue sitemap invocation
        return false;
    }
17806#/**
     * @see org.apache.avalon.framework.context.Contextualizable#contextualize(org.apache.avalon.framework.context.Context)
     */
    public void contextualize(Context avalonContext) throws ContextException {
        this.context = avalonContext;
    }
17807#/**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager serviceManager) throws ServiceException {
        this.manager = serviceManager;
    }
17808#/**
     * Get the location of the treebuilder config file. Can be overridden for
     * other versions.
     *
     * @return The location of the treebuilder config file
     */
    protected String getBuilderConfigURL() {
        return "resource://org/apache/cocoon/components/treeprocessor/sitemap-language.xml";
    }
17809#/**
     * @see org.apache.cocoon.components.treeprocessor.TreeBuilder#setAttribute(java.lang.String,
     *      java.lang.Object)
     */
    public void setAttribute(String name, Object value) {
        this.attributes.put(name, value);
    }
17810#/**
     * @see org.apache.cocoon.components.treeprocessor.TreeBuilder#getAttribute(java.lang.String)
     */
    public Object getAttribute(String name) {
        return this.attributes.get(name);
    }
17811#/**
     * @see org.apache.cocoon.components.treeprocessor.TreeBuilder#setProcessor(ConcreteTreeProcessor)
     */
    public void setProcessor(ConcreteTreeProcessor processor) {
        this.processor = processor;
    }
17812#/**
     * @see org.apache.cocoon.components.treeprocessor.TreeBuilder#getProcessor()
     */
    public ConcreteTreeProcessor getProcessor() {
        return this.processor;
    }
17813#/**
     * @see org.apache.cocoon.components.treeprocessor.TreeBuilder#getWebApplicationContext()
     */
    public WebApplicationContext getWebApplicationContext() {
        return this.itsContainer;
    }
17814#/**
     * @see org.apache.cocoon.components.treeprocessor.TreeBuilder#getEnterSitemapEventListeners()
     */
    public List getEnterSitemapEventListeners() {
        // we make a copy here, so we can clear(recylce) the list after the
        // sitemap is build
        return (List) ((ArrayList) this.enterSitemapEventListeners).clone();
    }
17815#/**
     * @see org.apache.cocoon.components.treeprocessor.TreeBuilder#getLeaveSitemapEventListeners()
     */
    public List getLeaveSitemapEventListeners() {
        // we make a copy here, so we can clear(recylce) the list after the
        // sitemap is build
        return (List) ((ArrayList) this.leaveSitemapEventListeners).clone();
    }
17816#/**
     * @see org.apache.cocoon.components.treeprocessor.TreeBuilder#registerNode(java.lang.String,
     *      org.apache.cocoon.components.treeprocessor.ProcessingNode)
     */
    public boolean registerNode(String name, ProcessingNode node) {
        if (this.registeredNodes.containsKey(name)) {
            return false;
        }
        this.registeredNodes.put(name, node);
        return true;
    }
17817#/**
     * @see org.apache.cocoon.components.treeprocessor.TreeBuilder#getRegisteredNode(java.lang.String)
     */
    public ProcessingNode getRegisteredNode(String name) {
        if (this.canGetNode) {
            return (ProcessingNode) this.registeredNodes.get(name);
        }
        throw new IllegalArgumentException("Categories are only available during buildNode()");
    }
17818#/**
     * @see org.apache.cocoon.components.treeprocessor.TreeBuilder#createNodeBuilder(org.apache.avalon.framework.configuration.Configuration)
     */
    public ProcessingNodeBuilder createNodeBuilder(Configuration config) throws Exception {
        // FIXME : check namespace
        String nodeName = config.getName();

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Creating node builder for " + nodeName);
        }

        ProcessingNodeBuilder builder;
        builder = (ProcessingNodeBuilder) this.itsBuilders.getBuilder(nodeName);

        builder.setBuilder(this);

        if (builder instanceof LinkedProcessingNodeBuilder) {
            this.linkedBuilders.add(builder);
        }

        return builder;
    }
17819#/**
     * Create the tree once component manager and node builders have been set
     * up. Can be overriden by subclasses to perform pre/post tree creation
     * operations.
     */
    protected ProcessingNode createTree(Configuration tree) throws Exception {
        // Create a node builder from the top-level element
        ProcessingNodeBuilder rootBuilder = createNodeBuilder(tree);

        // Build the whole tree (with an empty buildModel)
        return rootBuilder.buildNode(tree);
    }
17820#/**
     * Resolve links : call <code>linkNode()</code> on all
     * <code>LinkedProcessingNodeBuilder</code>s. Can be overriden by
     * subclasses to perform pre/post resolution operations.
     *
     * Before linking nodes, lookup the view category node used in
     * {@link #getViewNodes(Collection)}.
     */
    protected void linkNodes() throws Exception {
        // Get the views category node
        this.viewsNode = CategoryNodeBuilder.getCategoryNode(this, "views");

        // Resolve links
        Iterator iter = this.linkedBuilders.iterator();
        while (iter.hasNext()) {
            ((LinkedProcessingNodeBuilder) iter.next()).linkNode();
        }
    }
17821#/**
     * Get the namespace URI that builders should use to find their nodes.
     */
    public String getNamespace() {
        return this.itsNamespace;
    }
17822#/**
     * Build a processing tree from a <code>Configuration</code>.
     */
    public ProcessingNode build(Configuration tree, String location) throws Exception {
// TODO rcl
//        final Monitor fam = (Monitor) this.manager.lookup(Monitor.ROLE);
//        fam.setSitemapNotifier(this.processor.getWrappingProcessor());
        final Monitor fam = null;
        this.itsContainer = SitemapHelper.createContainer(
                                               tree,
                                               location,
                                               fam,
                                               (ServletContext)this.context.get(Constants.CONTEXT_ENVIRONMENT_CONTEXT));
        final Context itsContext = (Context)this.itsContainer.getBean(AvalonUtils.CONTEXT_ROLE);
        // The namespace used in the whole sitemap is the one of the root
        // element
        this.itsNamespace = tree.getNamespace();

        // replace properties?
        if ( tree.getChild("components").getAttributeAsBoolean("replace-properties", true) ) {
            tree = AvalonUtils.replaceProperties(tree, (Settings)this.itsContainer.getBean(Settings.ROLE));
        }

        this.itsManager = (ServiceManager) this.itsContainer.getBean(AvalonUtils.SERVICE_MANAGER_ROLE);
        // register listeners
        this.registerListeners();

        this.itsComponentInfo = (PipelineComponentInfo) this.itsManager.lookup(PipelineComponentInfo.ROLE);
        // Create a helper object to setup components
        this.itsLifecycle = new LifecycleHelper(null /* logger */, itsContext, this.itsManager, null /* configuration */);

        // Create & initialize the NodeBuilder selector.
        {
            NodeBuilderSelector selector = new NodeBuilderSelector();

            // Load the builder config file
            SourceResolver resolver = (SourceResolver) this.manager.lookup(SourceResolver.ROLE);
            String url = getBuilderConfigURL();
            Configuration config;
            try {
                Source src = resolver.resolveURI(url);
                try {
                    SAXConfigurationHandler handler = new SAXConfigurationHandler();
                    SourceUtil.toSAX(this.manager, src, null, handler);
                    config = handler.getConfiguration();
                } finally {
                    resolver.release(src);
                }
            } catch (Exception e) {
                throw new ConfigurationException("Could not load TreeBuilder configuration from " +
                                                 url, e);
            } finally {
                this.manager.release(resolver);
            }

            // ContainerUtil.contextualize(selector, itsContext);
            // ContainerUtil.service(selector, this.itsManager);
            // ContainerUtil.configure(selector, config.getChild("nodes", false));
            // ContainerUtil.initialize(selector);
            LifecycleHelper.setupComponent(selector,
                                           getLogger(), itsContext, this.itsManager,
                                           config.getChild("nodes", false));
            
            this.itsBuilders = selector;
        }

        // Calls to getRegisteredNode() are forbidden
        this.canGetNode = false;

        // Collect all disposable variable resolvers
        VariableResolverFactory.setDisposableCollector(this.disposableNodes);

        ProcessingNode result = createTree(tree);

        // Calls to getRegisteredNode() are now allowed
        this.canGetNode = true;

        linkNodes();

        // Initialize all Initializable nodes
        Iterator iter = this.initializableNodes.iterator();
        while (iter.hasNext()) {
            ((Initializable) iter.next()).initialize();
        }

        // And that's all !
        return result;
    }
17823#/**
     * Return the list of <code>ProcessingNodes</code> part of this tree that
     * are <code>Disposable</code>. Care should be taken to properly dispose
     * them before trashing the processing tree.
     */
    public List getDisposableNodes() {
        return this.disposableNodes;
    }
17824#/**
     * Setup a <code>ProcessingNode</code> by setting its location, calling
     * all the lifecycle interfaces it implements and giving it the parameter
     * map if it's a <code>ParameterizableNode</code>.
     * <p>
     * As a convenience, the node is returned by this method to allow constructs
     * like <code>return treeBuilder.setupNode(new MyNode(), config)</code>.
     */
    public ProcessingNode setupNode(ProcessingNode node, Configuration config) throws Exception {
        Location location = getLocation(config);
        if (node instanceof AbstractProcessingNode) {
            ((AbstractProcessingNode) node).setLocation(location);
            ((AbstractProcessingNode) node).setSitemapExecutor(this.processor.getSitemapExecutor());
        }

        this.itsLifecycle.setupComponent(node, false);

        if (node instanceof ParameterizableProcessingNode) {
            Map params = getParameters(config, location);
            ((ParameterizableProcessingNode) node).setParameters(params);
        }

        if (node instanceof Initializable) {
            this.initializableNodes.add(node);
        }

        if (node instanceof Disposable) {
            this.disposableNodes.add(node);
        }

        return node;
    }
17825#protected LocationImpl getLocation(Configuration config) {
        String prefix = "";

        if (config instanceof AbstractConfiguration) {
            // FIXME: AbstractConfiguration has a _protected_ getPrefix()
            // method.
            // So make some reasonable guess on the prefix until it becomes
            // public
            String namespace = null;
            try {
                namespace = config.getNamespace();
            } catch (ConfigurationException e) {
                // ignore
            }
            if ("http://apache.org/cocoon/sitemap/1.0".equals(namespace)) {
                prefix = "map";
            }
        }

        StringBuffer desc = new StringBuffer().append('<');
        if (prefix.length() > 0) {
            desc.append(prefix).append(':').append(config.getName());
        } else {
            desc.append(config.getName());
        }

        String type = config.getAttribute("type", null);
        if (type != null) {
            desc.append(" type=\"").append(type).append('"');
        }
        desc.append('>');

        Location rawLoc = LocationUtils.getLocation(config);
        return new LocationImpl(desc.toString(),
                                rawLoc.getURI(),
                                rawLoc.getLineNumber(),
                                rawLoc.getColumnNumber());
    }
17826#/**
     * Get &lt;xxx:parameter&gt; elements as a <code>Map</code> of </code>ListOfMapResolver</code>s,
     * that can be turned into parameters using <code>ListOfMapResolver.buildParameters()</code>.
     *
     * @return the Map of ListOfMapResolver, or <code>null</code> if there are
     *         no parameters.
     */
    protected Map getParameters(Configuration config, Location location)
            throws ConfigurationException {

        Configuration[] children = config.getChildren("parameter");

        if (children.length == 0) {
            // Parameters are only the component's location
            // TODO Optimize this
            return new SitemapParameters.LocatedHashMap(location, 0);
        }

        Map params = new SitemapParameters.LocatedHashMap(location, children.length + 1);
        for (int i = 0; i < children.length; i++) {
            Configuration child = children[i];
            if (true) { // FIXME : check namespace
                String name = child.getAttribute("name");
                String value = child.getAttribute("value");
                try {
                    params.put(resolve(name), resolve(value));
                } catch (PatternException pe) {
                    String msg = "Invalid pattern '" + value + "' at " + child.getLocation();
                    throw new ConfigurationException(msg, pe);
                }
            }
        }

        return params;
    }
17827#/**
     * Get the type for a statement : it returns the 'type' attribute if
     * present, and otherwhise the default type defined for this role in the
     * components declarations.
     *
     * @throws ConfigurationException
     *             if the type could not be found.
     */
    public String getTypeForStatement(Configuration statement, String role)
            throws ConfigurationException {

        // Get the component type for the statement
        String type = statement.getAttribute("type", null);
        if (type == null) {
            type = this.itsComponentInfo.getDefaultType(role);
        }

        if (type == null) {
            throw new ConfigurationException("No default type exists for 'map:"
                    + statement.getName() + "' at " + statement.getLocation());
        }

        final String beanName = role + '/' + type;
        if ( !this.itsContainer.containsBean(beanName) ) {
            throw new ConfigurationException("Type '" + type + "' does not exist for 'map:"
                    + statement.getName() + "' at " + statement.getLocation());
        }

        return type;
    }
17828#/**
     * Resolve expression using its manager
     */
    protected VariableResolver resolve(String expression) throws PatternException {
        return VariableResolverFactory.getResolver(expression, this.itsManager);
    }
17829#public void recycle() {
        // Reset all data created during the build
        this.attributes.clear();
        this.canGetNode = false;
        this.disposableNodes = new ArrayList(); // Must not be cleared as it's
                                                // used for processor disposal
        this.initializableNodes.clear();
        this.linkedBuilders.clear();
        this.processor = null; // Set in setProcessor()

        this.itsNamespace = null; // Set in build()
        LifecycleHelper.dispose(this.itsBuilders);
        this.itsBuilders = null; // Set in build()
        this.itsLifecycle = null; // Set in build()
        this.itsManager = null; // Set in build()

        this.registeredNodes.clear();
        this.initializableNodes.clear();
        this.linkedBuilders.clear();
        this.canGetNode = false;
        this.registeredNodes.clear();

        VariableResolverFactory.setDisposableCollector(null);
        this.enterSitemapEventListeners.clear();
        this.leaveSitemapEventListeners.clear();

        // Go back to initial state
        this.labelViews.clear();
        this.viewsNode = null;
        this.isBuildingView = false;
        this.isBuildingErrorHandler = false;
    }
17830#/**
     * Register all registered sitemap listeners
     */
    protected void registerListeners() {
        final ListableBeanFactory listableFactory = this.itsContainer;
        Map beans = listableFactory.getBeansOfType(EnterSitemapEventListener.class);
        if ( beans != null ) {
            final Iterator i = beans.values().iterator();
            while ( i.hasNext() ) {
                this.enterSitemapEventListeners.add(i.next());
            }
        }
        beans = listableFactory.getBeansOfType(LeaveSitemapEventListener.class);
        if ( beans != null ) {
            final Iterator i = beans.values().iterator();
            while ( i.hasNext() ) {
                this.leaveSitemapEventListeners.add(i.next());
            }
        }
    }
17831#/**
     * Set to <code>true</code> while building the internals of a
     * &lt;map:view&gt;
     */
    public void setBuildingView(boolean building) {
        this.isBuildingView = building;
    }
17832#/**
     * Are we currently building a view ?
     */
    public boolean isBuildingView() {
        return this.isBuildingView;
    }
17833#/**
     * Set to <code>true</code> while building the internals of a
     * &lt;map:handle-errors&gt;
     */
    public void setBuildingErrorHandler(boolean building) {
        this.isBuildingErrorHandler = building;
    }
17834#/**
     * Are we currently building an error handler ?
     */
    public boolean isBuildingErrorHandler() {
        return this.isBuildingErrorHandler;
    }
17835#/**
     * Add a view for a label. This is used to register all views that start
     * from a given label.
     *
     * @param label
     *            the label (or pseudo-label) for the view
     * @param view
     *            the view name
     */
    public void addViewForLabel(String label, String view) {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("views:addViewForLabel(" + label + ", " + view + ")");
        }
        Set views = (Set) this.labelViews.get(label);
        if (views == null) {
            views = new HashSet();
            this.labelViews.put(label, views);
        }

        views.add(view);
    }
17836#/**
     * Get the names of views for a given statement. If the cocoon view exists
     * in the returned collection, the statement can directly branch to the
     * view-handling node.
     *
     * @param role
     *            the component role (e.g. <code>Generator.ROLE</code>)
     * @param hint
     *            the component hint, i.e. the 'type' attribute
     * @param statement
     *            the sitemap statement
     * @return the view names for this statement
     */
    public Collection getViewsForStatement(String role, String hint, Configuration statement)
            throws Exception {

        String statementLabels = statement.getAttribute("label", null);

        if (this.isBuildingView) {
            // Labels are forbidden inside view definition
            if (statementLabels != null) {
                String msg = "Cannot put a 'label' attribute inside view definition at "
                        + statement.getLocation();
                throw new ConfigurationException(msg);
            }

            // We are currently building a view. Don't recurse !
            return null;
        }

        // Compute the views attached to this component
        Set views;

        // Build the set for all labels for this statement
        Set labels = new HashSet();

        // 1 - labels defined on the component
        if (role != null && role.length() > 0) {
            String[] compLabels = this.itsComponentInfo.getLabels(role, hint);
            if (compLabels != null) {
                for (int i = 0; i < compLabels.length; i++) {
                    labels.add(compLabels[i]);
                }
            }
        }

        // 2 - labels defined on this statement
        if (statementLabels != null) {
            labels.addAll(splitLabels(statementLabels));
        }

        // 3 - pseudo-label depending on the role
        if (Generator.ROLE.equals(role)) {
            labels.add("!first!");
        } else if (Serializer.ROLE.equals(role)) {
            labels.add("!last!");
        }

        // Build the set of views attached to these labels
        views = new HashSet();

        // Iterate on all labels for this statement
        Iterator labelIter = labels.iterator();
        while (labelIter.hasNext()) {

            // Iterate on all views for this labek
            Collection coll = (Collection) this.labelViews.get(labelIter.next());
            if (coll != null) {
                Iterator viewIter = coll.iterator();
                while (viewIter.hasNext()) {
                    String viewName = (String) viewIter.next();

                    views.add(viewName);
                }
            }
        }

        // Don't keep empty result
        if (views.size() == 0) {
            views = null;

            if (getLogger().isDebugEnabled()) {
                getLogger().debug(
                        statement.getName() + " has no views at " + statement.getLocation());
            }
        } else {
            if (getLogger().isDebugEnabled()) {
                // Dump matching views
                StringBuffer buf = new StringBuffer(statement.getName() + " will match views [");
                Iterator iter = views.iterator();
                while (iter.hasNext()) {
                    buf.append(iter.next()).append(" ");
                }
                buf.append("] at ").append(statement.getLocation());

                getLogger().debug(buf.toString());
            }
        }

        return views;
    }
17837#/**
     * Get the {view name, view node} map for a collection of view names. This
     * allows to resolve view nodes at build time, thus avoiding runtime lookup.
     *
     * @param viewNames
     *            the view names
     * @return association of names to views
     */
    public Map getViewNodes(Collection viewNames) throws Exception {
        if (viewNames == null || viewNames.size() == 0) {
            return null;
        }

        if (this.viewsNode == null) {
            return null;
        }

        Map result = new HashMap();

        Iterator iter = viewNames.iterator();
        while (iter.hasNext()) {
            String viewName = (String) iter.next();
            result.put(viewName, viewsNode.getNodeByName(viewName));
        }

        return result;
    }
17838#/**
     * Extract pipeline-hints from the given statement (if any exist)
     *
     * @param role
     *            the component role (e.g. <code>Generator.ROLE</code>)
     * @param hint
     *            the component hint, i.e. the 'type' attribute
     * @param statement
     *            the sitemap statement
     * @return the hint params <code>Map</code> for this statement, or null if
     *         none exist
     */
    public Map getHintsForStatement(String role, String hint, Configuration statement)
            throws Exception {
        // This method implemets the hintParam Syntax as follows:
        // A hints attribute has one or more comma separated hints
        // hints-attr :: hint [ ',' hint ]*
        // A hint is a name and an optional (string) value
        // If there is no value, it is considered as boolean string "true"
        // hint :: literal [ '=' litteral ]
        // literal :: <a character string where the chars ',' and '=' are not
        // permitted>
        //
        // A ConfigurationException is thrown if there is a problem "parsing"
        // the hint.

        String statementHintParams = statement.getAttribute("pipeline-hints", null);

        // firstly, determine if any pipeline-hints are defined at the component
        // level
        // if so, inherit these pipeline-hints (these hints can be overriden by
        // local pipeline-hints)
        String componentHintParams = this.itsComponentInfo.getPipelineHint(role, hint);

        String hintParams;
        if (componentHintParams != null) {
            hintParams = componentHintParams;

            if (statementHintParams != null) {
                hintParams = hintParams + "," + statementHintParams;
            }
        } else {
            hintParams = statementHintParams;
        }

        // if there are no pipeline-hints defined then
        // it makes no sense to continue so, return null
        if (hintParams == null) {
            return null;
        }

        Map params = new HashMap();

        RE commaSplit = new RE(COMMA_SPLIT_REGEXP);
        RE equalsSplit = new RE(EQUALS_SPLIT_REGEXP);

        String[] expressions = commaSplit.split(hintParams.trim());

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("pipeline-hints: (aggregate-hint) " + hintParams);
        }

        for (int i = 0; i < expressions.length; i++) {
            String[] nameValuePair = equalsSplit.split(expressions[i]);

            try {
                if (nameValuePair.length < 2) {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug(
                                "pipeline-hints: (name) " + nameValuePair[0]
                                        + "\npipeline-hints: (value) [implicit] true");
                    }

                    params.put(resolve(nameValuePair[0]), resolve("true"));
                } else {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug(
                                "pipeline-hints: (name) " + nameValuePair[0]
                                        + "\npipeline-hints: (value) " + nameValuePair[1]);
                    }

                    params.put(resolve(nameValuePair[0]), resolve(nameValuePair[1]));
                }
            } catch (PatternException pe) {
                String msg = "Invalid pattern '" + hintParams + "' at " + statement.getLocation();
                getLogger().error(msg, pe);
                throw new ConfigurationException(msg, pe);
            }
        }

        return params;
    }
17839#/**
     * Get the mime-type for a component (either a serializer or a reader)
     *
     * @param role the component role (e.g. <code>Serializer.ROLE</code>)
     * @param hint the component hint, i.e. the 'type' attribute
     * @return the mime-type, or <code>null</code> if none was set
     */
    public String getMimeType(String role, String hint) {
        return this.itsComponentInfo.getMimeType(role, hint);
    }
17840#/**
     * Split a list of space/comma separated labels into a Collection
     *
     * @return the collection of labels (may be empty, nut never null)
     */
    private static Collection splitLabels(String labels) {
        if (labels == null) {
            return Collections.EMPTY_SET;
        }
        return Arrays.asList(StringUtils.split(labels, ", \t\n\r"));
    }
17841#/** This builder has no parameters -- return <code>false</code> */
    protected boolean hasParameters() {
        return false;
    }
17842#public ProcessingNode buildNode(Configuration config) throws Exception {
        
		if (((SitemapLanguage)this.treeBuilder).isBuildingErrorHandler()) {
			throw new ConfigurationException("'map:redirect' is forbidden inside a 'map:handle-errors', at "
			+ config.getLocation());
		}
		
        // Is it a redirect to resource ?
        this.resourceName = config.getAttribute("resource", null);
        if (this.resourceName != null) {
            
            getLogger().warn("Redirect to resource is deprecated. Use map:call instead at " +
                config.getLocation());

            this.callNode = new CallNode();
            this.treeBuilder.setupNode(this.callNode, config);

            String target = config.getAttribute("target", null);
            if (target != null) {
                Map params = new HashMap(1);
                params.put("target", VariableResolverFactory.getResolver(target, this.manager));
                this.callNode.setParameters(params);
            }
            return this.callNode;
            
        }
        ProcessingNode URINode = new RedirectToURINode(
            VariableResolverFactory.getResolver(config.getAttribute("uri"), this.manager),
            config.getAttributeAsBoolean("session", false),
            config.getAttributeAsBoolean("global", false),
            config.getAttributeAsBoolean("permanent", false)
        );
        return this.treeBuilder.setupNode(URINode, config);
    }
17843#public void linkNode() throws Exception {

        if (this.callNode != null) {
            CategoryNode resources = CategoryNodeBuilder.getCategoryNode(this.treeBuilder, "resources");

            if (resources == null) {
                String msg = "This sitemap contains no resources. Cannot redirect at " +
                    this.callNode.getLocation();
                throw new ConfigurationException(msg);
            }

            this.callNode.setResource(
                resources,
                VariableResolverFactory.getResolver(this.resourceName, this.manager)
            );
        }
    }
17844#public ProcessingNode buildNode(Configuration config)
    throws Exception {
        String source = config.getAttribute("src");

        this.node = new ScriptNode(source);
        this.treeBuilder.setupNode(this.node, config);

        return this.node;
    }
17845#/**
     * Call the built node to register the script it contains with the
     * flow interpreter.
     */
    public void linkNode()
    throws Exception {
        FlowNode flowNode = (FlowNode)this.treeBuilder.getRegisteredNode("flow");
        Interpreter interpreter = flowNode.getInterpreter();

        this.node.registerScriptWithInterpreter(interpreter);
    }
17846#public ActTypeNode(String type,
                       VariableResolver source,
                       String name,
                       boolean inActionSet)  {
        super(Action.ROLE + "Selector", type);
        this.source = source;
        this.name = name;
        this.inActionSet = inActionSet;
    }
17847#public void setParameters(Map parameterMap) {
        this.parameters = parameterMap;
    }
17848#public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {

        // Perform any common invoke functionality
        super.invoke(env, context);

        // Prepare data needed by the action
        Map objectModel = env.getObjectModel();
        String resolvedSource = source.resolve(context, objectModel);
        Parameters resolvedParams =
            VariableResolver.buildParameters(this.parameters, context, objectModel);

        // If in action set, merge parameters
        if (inActionSet) {
            Parameters callerParams =
                (Parameters) env.getAttribute(ActionSetNode.CALLER_PARAMETERS);
            if (resolvedParams == Parameters.EMPTY_PARAMETERS) {
                // Just swap
                resolvedParams = callerParams;
            } else if (callerParams != Parameters.EMPTY_PARAMETERS) {
                // Build new Parameters object, the both we hare are read-only!
                Parameters newParams = new Parameters();
                // And merge both
                newParams.merge(resolvedParams);
                newParams.merge(callerParams);
                resolvedParams = newParams;
            }
        }

        Redirector redirector = context.getRedirector();
        SourceResolver resolver = EnvironmentHelper.getCurrentProcessor().getSourceResolver();

        try {
            Action action = (Action) getComponent();
            Map actionResult;
            try {
                actionResult = this.executor.invokeAction(this,
                                                          objectModel,
                                                          action,
                                                          redirector,
                                                          resolver,
                                                          resolvedSource,
                                                          resolvedParams);
            } finally {
                releaseComponent(action);
            }

            if (redirector.hasRedirected()) {
                return true;
            }

            if (actionResult != null) {
                // Action succeeded : process children if there are some, with the action result
                if (this.children != null) {
                    boolean result = invokeNodes(this.children, env, context, name, actionResult);

                    if (inActionSet) {
                        // Merge child action results, if any
                        Map childMap = (Map) env.getAttribute(ActionSetNode.ACTION_RESULTS);
                        if (childMap != null) {
                            Map newResults = new HashMap(childMap);
                            newResults.putAll(actionResult);
                            env.setAttribute(ActionSetNode.ACTION_RESULTS, newResults);
                        } else {
                            // No previous results
                            env.setAttribute(ActionSetNode.ACTION_RESULTS, actionResult);
                        }
                    }
                    return result;
                }
            }
        } catch (Exception e) {
            throw ProcessingException.throwLocated("Sitemap: error invoking action", e, getLocation());
        }

        return false;   // Action failed
    }
17849#public ProcessingNode buildNode(Configuration config) throws Exception {

        String pattern = config.getAttribute("pattern", null);
        String name = config.getAttribute("name", null);

        String type = this.treeBuilder.getTypeForStatement(config, Matcher.ROLE);

        // Get the type and class for this matcher
        ServiceSelector selector = (ServiceSelector)this.manager.lookup(Matcher.ROLE + "Selector");

        Class clazz = null;
        try {
            // Find matcher class
            Matcher matcher = (Matcher)selector.select(type);
            clazz = matcher.getClass();
            selector.release(matcher);
        } finally {
            this.manager.release(selector);
        }

        // PreparableMatcher are only prepared if pattern doesn't need request-time resolution.
        boolean preparable =
            PreparableMatcher.class.isAssignableFrom(clazz) &&
            !VariableResolverFactory.needsResolve(pattern);

        // Instanciate appropriate node
        SimpleSelectorProcessingNode node;
        VariableResolver patternResolver = VariableResolverFactory.getResolver(pattern, this.manager);

        if (preparable) {
            node = new PreparableMatchNode(type, VariableResolverFactory.unescape(pattern),name);
        } else {
            node = new MatchNode(type, patternResolver,name);
        }

        this.treeBuilder.setupNode(node, config);

        // Get all children
        ProcessingNode[] children = buildChildNodes(config);

        node.setChildren(children);

        return node;
    }
17850#/**
     * @see org.apache.cocoon.components.treeprocessor.AbstractProcessingNodeBuilder#setBuilder(org.apache.cocoon.components.treeprocessor.TreeBuilder)
     */
    public void setBuilder(TreeBuilder treeBuilder) {
        super.setBuilder(treeBuilder);
        // check ssettings for ignoring of internal only pipeline flags
        this.ignoreInternalOnly = false;
        final Settings settings = (Settings)treeBuilder.getWebApplicationContext().getBean(Settings.ROLE);
        final String value = settings.getProperty(PipelineNodeBuilder.PROPERTY_SITEMAP_INTERNALONLY);
        if ( value != null ) {
            this.ignoreInternalOnly = Boolean.valueOf(value).booleanValue();
        }
    }
17851#/** This builder can have parameters -- return <code>true</code> */
    protected boolean hasParameters() {
        return true;
    }
17852#/**
     * @see org.apache.cocoon.components.treeprocessor.ProcessingNodeBuilder#buildNode(org.apache.avalon.framework.configuration.Configuration)
     */
    public ProcessingNode buildNode(Configuration config)
    throws Exception {
        String type = this.treeBuilder.getTypeForStatement(config, ProcessingPipeline.ROLE);
        PipelineNode node = new PipelineNode(type);

        this.treeBuilder.setupNode(node, config);
        // if internal only is ignore, all pipelines are directly accessible
        if ( this.ignoreInternalOnly ) {
            node.setInternalOnly(false);
        } else {
            node.setInternalOnly(config.getAttributeAsBoolean(PipelineNodeBuilder.ATTRIBUTE_INTERNAL_ONLY, false));
        }

        // Error handler node
        HandleErrorsNode handler = null;

        Configuration[] childConfigs = config.getChildren();
        List children = new ArrayList();
        for (int i = 0; i < childConfigs.length; i++) {
            Configuration childConfig = childConfigs[i];
            if (isChild(childConfig)) {

                ProcessingNodeBuilder builder = this.treeBuilder.createNodeBuilder(childConfig);
                if (builder instanceof HandleErrorsNodeBuilder) {
                    if (handler != null) {
                        throw new ConfigurationException("Duplicate <handle-errors> at " + handler.getLocation());
                    }

                    // Error handler : check type
                    handler = (HandleErrorsNode) builder.buildNode(childConfig);
                } else {
                    // Regular builder
                    children.add(builder.buildNode(childConfig));
                }
            }
        }

        node.setChildren(toNodeArray(children));
        node.setErrorHandler(handler);

        return node;
    }
17853#/**
     * @see org.apache.cocoon.components.treeprocessor.ProcessingNodeBuilder#buildNode(org.apache.avalon.framework.configuration.Configuration)
     */
    public ProcessingNode buildNode(Configuration config)
    throws Exception {
        final String language = config.getAttribute("language", "javascript");
        final FlowNode node = new FlowNode(language);

        if ( !this.treeBuilder.registerNode("flow", node) ) {
            throw new ConfigurationException("Only one <map:flow> is allowed in a sitemap. Another one is declared at " +
                    config.getLocation());
        }
        this.treeBuilder.setupNode(node, config);

        // since 2.2 we add by default all flow scripts located in the ./flow directory
        // The default location can be overwritten by specifying the location attribute.
        final BeanFactory beanFactory = this.treeBuilder.getWebApplicationContext();
        if ( beanFactory instanceof ApplicationContext && node.getInterpreter().getScriptExtension() != null ) {
            final ResourceLoader resourceLoader = (ApplicationContext)beanFactory;
            final String scriptLocation = config.getAttribute("location", DEFAULT_FLOW_SCRIPT_LOCATION);
            if ( resourceLoader.getResource(scriptLocation).exists() ) {
                final ServletContextResourcePatternResolver resolver = new ServletContextResourcePatternResolver(resourceLoader);
                final Resource[] resources = resolver.getResources(scriptLocation + "/*" + node.getInterpreter().getScriptExtension());
                if ( resources != null ) {
                    for(int i=0; i < resources.length; i++) {
                        node.getInterpreter().register(ResourceUtils.getUri(resources[i]));
                    }
                }
            }
        }

        // now process child nodes
        buildChildNodesList(config);

        return node;
    }
17854#public SelectNode(String name) {
        super(Selector.ROLE + "Selector", name);
    }
17855#public void setParameters(Map parameterMap) {
        this.parameters = parameterMap;
    }
17856#public void setCases(ProcessingNode[][] whenNodes, VariableResolver[] whenTests, ProcessingNode[] otherwhiseNodes) {
        this.whenNodes = whenNodes;
        this.whenTests = whenTests;
        this.otherwhiseNodes = otherwhiseNodes;
    }
17857#/* (non-Javadoc)
     * @see org.apache.cocoon.components.treeprocessor.ProcessingNode#invoke(Environment, InvokeContext)
     */
    public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {

          // Perform any common invoke functionality
        super.invoke(env, context);

        // Prepare data needed by the action
        final Map objectModel = env.getObjectModel();
        final Parameters resolvedParams = VariableResolver.buildParameters(this.parameters, context, objectModel);

        final Selector selector = (Selector)getComponent();
        try {
            for (int i = 0; i < this.whenTests.length; i++) {
                if (this.executor.invokeSelector(this, objectModel,
                        selector,
                        whenTests[i].resolve(context, objectModel),
                        resolvedParams)) {
                    return invokeNodes(this.whenNodes[i], env, context);
                }
            }

            if (this.otherwhiseNodes != null) {
                return invokeNodes(this.otherwhiseNodes, env, context);
            }

            return false;
        } catch (Exception e) {
            throw ProcessingException.throwLocated("Sitemap: error processing select", e, getLocation());
        } finally {
            releaseComponent(selector);
        }
    }
17858#public AggregateNode(VariableResolver element, VariableResolver nsURI, VariableResolver nsPrefix) {
        super(null);
        this.element = element;
        this.nsURI = nsURI;
        this.nsPrefix = nsPrefix;
    }
17859#public void setParts(Part[] allParts, Map viewParts) {
        this.allParts = allParts;
        this.viewParts = viewParts;
    }
17860#public void setViewNodes(Map viewNodes) {
        this.viewNodes = viewNodes;
    }
17861#public boolean invoke(Environment env, InvokeContext context)
    throws Exception {
        final boolean infoEnabled = getLogger().isInfoEnabled();

        Map objectModel = env.getObjectModel();

        // Setup aggregator
        ProcessingPipeline processingPipeline = context.getProcessingPipeline();
        processingPipeline.setGenerator("<aggregator>", null, Parameters.EMPTY_PARAMETERS, Parameters.EMPTY_PARAMETERS);

        ContentAggregator aggregator = (ContentAggregator) processingPipeline.getGenerator();
        aggregator.setRootElement(this.element.resolve(context, objectModel),
                                  this.nsURI.resolve(context, objectModel),
                                  this.nsPrefix.resolve(context, objectModel));

        // Get actual parts, potentially filtered by the view
        Part[] actualParts;

        String cocoonView = env.getView();
        if (cocoonView == null) {
            // Keep all parts
            actualParts = this.allParts;

        } else {
            // Are there some parts that match this view ?
            actualParts = (Part[]) this.viewParts.get(cocoonView);

            // If not, keep all parts
            if (actualParts == null) {
                actualParts = this.allParts;
            }
        }

        // Add parts
        for (int i = 0; i < actualParts.length; i++) {
            Part part = actualParts[i];
            if (part != null) {
                aggregator.addPart(
                    part.source.resolve(context, objectModel),
                    part.element.resolve(context, objectModel),
                    part.nsURI.resolve(context, objectModel),
                    part.stripRoot.resolve(context, objectModel),
                    part.nsPrefix.resolve(context, objectModel)
                );
            }
        }

        // Bug #7196 : Some parts matched the view: jump to that view
        if (actualParts != this.allParts) {
            ProcessingNode viewNode = (ProcessingNode)this.viewNodes.get(cocoonView);
            if (viewNode != null) {
                if (infoEnabled) {
                    getLogger().info("Jumping to view '" + cocoonView + "' from aggregate part at " + this.getLocation());
                }
                return viewNode.invoke(env, context);
            }
        }

        // Check aggregate-level view
        if (cocoonView != null && this.viewNodes != null) {
            ProcessingNode viewNode = (ProcessingNode) this.viewNodes.get(cocoonView);
            if (viewNode != null) {
                if (infoEnabled) {
                    getLogger().info("Jumping to view '" + cocoonView + "' from aggregate at " + this.getLocation());
                }
                return viewNode.invoke(env, context);
            }
        }

        // Return false to continue sitemap invocation
        return false;
    }
17862#public Part(VariableResolver source,
                    VariableResolver element,
                    VariableResolver nsURI,
                    VariableResolver nsPrefix,
                    VariableResolver stripRoot) {
            this.source = source;
            this.element = element;
            this.nsURI = nsURI;
            this.nsPrefix = nsPrefix;
            this.stripRoot = stripRoot;
        }
17863#/**
     * @see org.apache.cocoon.components.treeprocessor.ProcessingNodeBuilder#buildNode(org.apache.avalon.framework.configuration.Configuration)
     */
    public ProcessingNode buildNode(Configuration config) throws Exception {
        
        boolean inActionSet = this.treeBuilder.getAttribute(ActionSetNodeBuilder.IN_ACTION_SET) != null;

        // Is it an action-set call ?
        this.actSetName = config.getAttribute("set", null);
        if (actSetName == null) {
            
            if (inActionSet) {
                // Check that children are only parameters or actions
                Configuration children[] = config.getChildren();
                for (int i = 0; i < children.length; i++) {
                    String name = children[i].getName();
                    if (!"act".equals(name) && !"parameter".equals(name)) {
                        throw new ConfigurationException("An action set can only contain actions and not '" 
                            + name + "' at " + children[i].getLocation());
                    }
                }
            }

            String name = config.getAttribute("name", null);
            String source = config.getAttribute("src", null);
            String type = this.treeBuilder.getTypeForStatement(config, Action.ROLE);

            ActTypeNode actTypeNode = new ActTypeNode(
                type,
                VariableResolverFactory.getResolver(source, this.manager),
                name,
                inActionSet
            );
            this.treeBuilder.setupNode(actTypeNode, config);

            actTypeNode.setChildren(buildChildNodes(config));

            return actTypeNode;

        }

        if (inActionSet) {
            throw new ConfigurationException("Cannot call an action set from an action set at " + config.getLocation());
        }

        // Action set call
        if (config.getAttribute("src", null) != null) {
            getLogger().warn("The 'src' attribute is ignored for action-set call at " + config.getLocation());
        }
        this.actSetNode = new ActSetNode();
        this.treeBuilder.setupNode(this.actSetNode, config);

        this.actSetNode.setChildren(buildChildNodes(config));

        return this.actSetNode;
    }
17864#/**
     * @see org.apache.cocoon.components.treeprocessor.LinkedProcessingNodeBuilder#linkNode()
     */
    public void linkNode() throws Exception {

        if (this.actSetNode != null) {
            // Link action-set call to the action set
            CategoryNode actionSets = CategoryNodeBuilder.getCategoryNode(this.treeBuilder, "action-sets");

            if (actionSets == null)
                throw new ConfigurationException("This sitemap contains no action sets. Cannot call at " + actSetNode.getLocation());

            ActionSetNode actionSetNode = (ActionSetNode)actionSets.getNodeByName(this.actSetName);

            this.actSetNode.setActionSet(actionSetNode);
        }
    }
17865#/**
     * @see org.apache.cocoon.components.treeprocessor.ProcessingNodeBuilder#buildNode(org.apache.avalon.framework.configuration.Configuration)
     */
    public ProcessingNode buildNode(Configuration config)
    throws Exception {
        resourceName = config.getAttribute("resource", null);
        functionName = config.getAttribute("function", null);
        continuationId = config.getAttribute("continuation", null);

        if (resourceName == null) {
            // Building a CallFunction node
            if (functionName == null && continuationId == null) {
                throw new ConfigurationException(
                    "<map:call> must have either a 'resource', 'function' or 'continuation' attribute, at "
                    + config.getLocation()
                );
            }

            // Build the ordered list of parameter names
            // FIXME(SW): remove this in the future (see comment in FlowNode)
            List argumentNames = new ArrayList();
            Configuration[] params = config.getChildren("parameter");
            for (int i = 0; i < params.length; i++) {
                argumentNames.add(params[i].getAttribute("name"));
            }

            node = new CallFunctionNode(VariableResolverFactory.getResolver(
                functionName, this.manager),
                VariableResolverFactory.getResolver(continuationId, this.manager),
                (String[]) argumentNames.toArray(new String[argumentNames.size()])
            );

        } else {
            // Building a Call(Resource)Node
            if (functionName != null || continuationId != null) {
                throw new ConfigurationException(
                    "<map:call> cannot have both a 'resource' and a 'function' or 'continuation' attribute, at "
                    + config.getLocation());
            }
            node = new CallNode();
        }

        this.treeBuilder.setupNode(this.node, config);
        if (node instanceof Configurable) {
            ((Configurable) this.node).configure(config);
        }

        return this.node;
    }
17866#/**
     * @see org.apache.cocoon.components.treeprocessor.LinkedProcessingNodeBuilder#linkNode()
     */
    public void linkNode() throws Exception {
        if (resourceName != null) {
            // We have a <map:call resource="..."/>
            CategoryNode resources = CategoryNodeBuilder.getCategoryNode(treeBuilder, "resources");

            if (resources == null)
                throw new ConfigurationException(
                    "This sitemap contains no resources. Cannot call at " + node.getLocation());

            ((CallNode) this.node).setResource(
                resources,
                VariableResolverFactory.getResolver(this.resourceName, this.manager)
            );
        } else {
            // We have a <map:call> with either "function" or
            // "continuation", or both specified

            // Check to see if a flow has been defined in this sitemap
            FlowNode flow = (FlowNode) treeBuilder.getRegisteredNode("flow");
            if (flow == null) {
                throw new ConfigurationException(
                    "This sitemap contains no control flows defined, cannot call at "
                    + node.getLocation()
                    + ". Define a control flow using <map:flow>, with embedded <map:script> elements.");
            }

            // Get the Interpreter instance and set it up in the
            // CallFunctionNode function
            Interpreter interpreter = flow.getInterpreter();
            ((CallFunctionNode) node).setInterpreter(interpreter);
        }
    }
17867#public RedirectToURINode(VariableResolver uri,
                             boolean createSession,
                             boolean global,
                             boolean permanent ) {
        this.global = global;
        this.uri = uri;
        this.createSession = createSession;
        this.permanent = permanent;
    }
17868#public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {
        String resolvedURI = uri.resolve(context, env.getObjectModel());

        if (getLogger().isInfoEnabled()) {
            getLogger().info("Redirecting to '" + resolvedURI + "' at " + this.getLocation());
        }

        resolvedURI = this.executor.redirectTo(this,
                                               env.getObjectModel(),
                                               resolvedURI,
                                               this.createSession,
                                               this.global,
                                               this.permanent);
        final Redirector redirector = context.getRedirector();

        if (this.global) {
            redirector.globalRedirect(this.createSession, resolvedURI);
        } else if (this.permanent && redirector instanceof PermanentRedirector) {
            ((PermanentRedirector) redirector).permanentRedirect(this.createSession, resolvedURI);
        } else {
            redirector.redirect(this.createSession, resolvedURI);
        }

        return true;
    }
17869#/**
     * @see org.apache.cocoon.components.treeprocessor.ProcessingNodeBuilder#buildNode(org.apache.avalon.framework.configuration.Configuration)
     */
    public ProcessingNode buildNode(Configuration config) throws Exception {

        String type = this.treeBuilder.getTypeForStatement(config, Transformer.ROLE);

        this.views = ((SitemapLanguage)this.treeBuilder).getViewsForStatement(Transformer.ROLE, type, config);
        this.pipelineHints = ((SitemapLanguage)this.treeBuilder).getHintsForStatement(Transformer.ROLE, type, config);

        this.node = new TransformNode(
            type,
            VariableResolverFactory.getResolver(config.getAttribute("src", null), this.manager)
        );

        this.node.setPipelineHints(this.pipelineHints);
        return this.treeBuilder.setupNode(node, config);
    }
17870#/**
     * @see org.apache.cocoon.components.treeprocessor.LinkedProcessingNodeBuilder#linkNode()
     */
    public void linkNode() throws Exception {
        this.node.setViews(
            ((SitemapLanguage)this.treeBuilder).getViewNodes(this.views)
        );
    }
17871#public CallNode() {
        super(null);
    }
17872#/* (non-Javadoc)
    * @see ParameterizableProcessingNode#setParameters(java.util.Map)
    */
    public void setParameters(Map parameterMap) {
        this.parameters = parameterMap;
    }
17873#public void setResource(CategoryNode resources, VariableResolver resourceName) throws Exception {
        this.resourceName = resourceName;
        this.resources = resources;
    }
17874#/* (non-Javadoc)
     * @see ProcessingNode#invoke(Environment, InvokeContext)
     */
    public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {

        Map objectModel = env.getObjectModel();

        // Resolved resource name
        String name = this.resourceName.resolve(context, objectModel);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Calling resource '" + name + "'");
        }

        // Resolve and push parameters after resource name has been
        // resolved, otherwise it adds an unwanted nesting level
        Map params = VariableResolver.buildMap(this.parameters, context, objectModel);
        params = this.executor.pushVariables(this, objectModel, null, params);
        context.pushMap(null, params);

        try {
            return this.resources.invokeByName(name, env, context);
        } catch (Exception e) {
            throw ProcessingException.throwLocated("Sitemap: error calling resource '" + name + "'", e, getLocation());
        } finally {
            this.executor.popVariables(this, objectModel);
            context.popMap();
        }
    }
17875#public ProcessingNode buildNode(Configuration config) throws Exception {

        String actionSetName = config.getAttribute("name");

        Configuration[] childrenConfig = config.getChildren();
        // Inform other builders that we're in an action-set
        this.treeBuilder.setAttribute(IN_ACTION_SET, Boolean.TRUE);
        
        // Get the child actions
        ProcessingNode[] nodes = this.buildChildNodes(config);
        
        // And get their names
        String[] actions = new String[nodes.length];
        for (int i = 0; i < childrenConfig.length; i++) {
            Configuration childConfig = childrenConfig[i];
            String name = childConfig.getName();

            if ("act".equals(name)) {
                actions[i] = childConfig.getAttribute("action", null);
            } else {
                // Unknown element
                String msg = "Unknown element " + name + " in action-set at " + childConfig.getLocation();
                throw new ConfigurationException(msg);
            }            
        }

        ActionSetNode node = new ActionSetNode(actionSetName, nodes, actions);
        this.treeBuilder.setupNode(node, config);

        // Inform other builders that we're no more in an action-set
        this.treeBuilder.setAttribute(IN_ACTION_SET, null);

        return node;
    }
17876#/**
     * @param scope Value of the error handler scope attribute: external, internal, always.
     */
    public HandleErrorsNode(String scope)
    throws ConfigurationException {
        if ("internal".equals(scope)) {
            this.internal = true;
        } else if ("external".equals(scope)) {
            this.external = true;
        } else if ("always".equals(scope)) {
            this.internal = true;
            this.external = true;
        } else {
            throw new ConfigurationException("Unrecognized value of when attribute on <handle-errors> at " +
                                             getLocation());
        }
    }
17877#public boolean isInternal() {
        return this.internal;
    }
17878#public boolean isExternal() {
        return this.external;
    }
17879#public void setChildren(ProcessingNode[] nodes) {
        this.children = nodes;
    }
17880#public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {

        if (getLogger().isInfoEnabled()) {
            getLogger().info("Processing handle-errors at " + getLocation());
        }

        // No 'type' attribute : new Cocoon 2.1 behaviour, no implicit generator
        try {
            return invokeNodes(this.children, env, context);

        } catch (ProcessingException e) {
            // Handle the transition from implicit generators in handle-errors to
            // explicit ones, in order to provide meaningful messages that will ease the migration
            if (e.getMessage().indexOf("Must set a generator before adding") != -1) {

                env.getObjectModel().remove(ObjectModelHelper.THROWABLE_OBJECT);
                throw new ProcessingException("Incomplete pipeline: 'handle-error' must include a generator.",
                                              getLocation());
            }

            // Rethrow the exception
            throw e;
        }
    }
17881#/** This builder has no parameters -- return <code>false</code> */
    protected boolean hasParameters() {
        return false;
    }
17882#public ProcessingNode buildNode(Configuration config) throws Exception {

        HandleErrorsNode node = new HandleErrorsNode(config.getAttribute("when", "external"));
        this.treeBuilder.setupNode(node, config);

        // Set a flag that will prevent redirects
        ((SitemapLanguage) this.treeBuilder).setBuildingErrorHandler(true);
        try {
            // Get all children
            node.setChildren(buildChildNodes(config));
        } finally {
            // And clear the flag
            ((SitemapLanguage) this.treeBuilder).setBuildingErrorHandler(false);
        }

        return node;
    }
17883#public ProcessingNode buildNode(Configuration config) throws Exception {

        // Get root node data
        this.node = new AggregateNode(
            VariableResolverFactory.getResolver(config.getAttribute("element"), this.manager),
            VariableResolverFactory.getResolver(config.getAttribute("ns", ""), this.manager),
            VariableResolverFactory.getResolver(config.getAttribute("prefix", ""), this.manager)
        );
        this.treeBuilder.setupNode(this.node, config);

        this.views = ((SitemapLanguage)this.treeBuilder).getViewsForStatement("", "", config);

        // Bug #7196 : ensure this.views is never null (see continuation of fix below)
        if (this.views == null) {
            this.views = new HashSet();
        }

        // The sitemap builder
        SitemapLanguage sitemap = (SitemapLanguage)this.treeBuilder;

        // All parts of the aggregate
        List allParts = new ArrayList();

        // For each view that a part matches, the list of all parts that match it
        Map viewParts = new HashMap();

        Configuration[] childConfigs = config.getChildren();
        for (int i = 0; i < childConfigs.length; i++) {
            Configuration childConfig = childConfigs[i];

            if (!"part".equals(childConfig.getName())) {
                String msg = "Unknown element '" + childConfig.getName() + " in aggregate ' at " +
                    childConfig.getLocation();
                throw new ConfigurationException(msg);
            }

            checkNamespace(childConfig);

            AggregateNode.Part currentPart = new AggregateNode.Part(
                VariableResolverFactory.getResolver(childConfig.getAttribute("src"), this.manager),
                VariableResolverFactory.getResolver(childConfig.getAttribute("element", ""), this.manager),
                VariableResolverFactory.getResolver(childConfig.getAttribute("ns", ""), this.manager),
                VariableResolverFactory.getResolver(childConfig.getAttribute("prefix", ""), this.manager),
                VariableResolverFactory.getResolver(childConfig.getAttribute("strip-root", "false"), this.manager)
            );

            allParts.add(currentPart);

            // Get the views for this part
            Collection viewsForPart = sitemap.getViewsForStatement("", "", childConfig);

            // Associate this part to all the views it belongs to
            if (viewsForPart != null) {

                // Bug #7196 : add part view to aggregate views
                this.views.addAll(viewsForPart);

                Iterator iter = viewsForPart.iterator();
                while(iter.hasNext()) {
                    String currentView = (String)iter.next();

                    // Get collection of parts for current view
                    Collection currentViewParts = (Collection)viewParts.get(currentView);
                    if (currentViewParts == null) {
                        // None for now : create the collection
                        currentViewParts = new ArrayList();
                        viewParts.put(currentView, currentViewParts);
                    }

                    // Add the current part to the parts list of the view
                    currentViewParts.add(currentPart);
                }
            }
        }

        if (allParts.size() == 0) {
            String msg = "There must be at least one part in map:aggregate at " + config.getLocation();
            throw new ConfigurationException(msg);
        }

        // Now convert all Collections to Array for faster traversal
        AggregateNode.Part[] allPartsArray = (AggregateNode.Part[])allParts.toArray(
            new AggregateNode.Part[allParts.size()]);

        Iterator iter = viewParts.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();

            // Get collection of parts for this entry
            Collection coll = (Collection)entry.getValue();

            // Convert to array and replace the entry value
            entry.setValue(
                coll.toArray(new AggregateNode.Part[coll.size()])
            );
        }

        node.setParts(allPartsArray, viewParts);

        return node;

    }
17884#public void linkNode() throws Exception {

        // Give the AggregateNode a Node for each view
        SitemapLanguage sitemap = (SitemapLanguage)this.treeBuilder;

        this.node.setViewNodes(sitemap.getViewNodes(this.views));
    }
17885#public ProcessingNode buildNode(Configuration config) throws Exception {

        String type = this.treeBuilder.getTypeForStatement(config, Generator.ROLE);

        this.views = ((SitemapLanguage)this.treeBuilder).getViewsForStatement(Generator.ROLE, type, config);
        this.pipelineHints = ((SitemapLanguage)this.treeBuilder).getHintsForStatement(Generator.ROLE, type, config);

        this.node = new GenerateNode(
            type,
            VariableResolverFactory.getResolver(config.getAttribute("src", null), this.manager)
        );
        this.node.setPipelineHints(this.pipelineHints);
        return this.treeBuilder.setupNode(this.node, config);
    }
17886#public void linkNode() throws Exception {
        this.node.setViews(
            ((SitemapLanguage)this.treeBuilder).getViewNodes(this.views)
        );
    }
17887#public FlowNode(String language) {
        this.language = language;
    }
17888#/**
     * Lookup an flow {@link org.apache.cocoon.components.flow.Interpreter}
     * instance to hold the scripts defined within the <code>&lt;map:flow&gt;</code>
     * in the sitemap.
     *
     * @param manager a <code>ServiceManager</code> value
     * @exception ServiceException if no flow interpreter could be obtained
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;

        try {
            // Obtain the Interpreter instance for this language
            this.interpreter = (Interpreter) this.manager.lookup(Interpreter.ROLE + '/' + language);
            // Set interpreter ID as URI of the flow node (full sitemap file path)
            this.interpreter.setInterpreterID(this.location.getURI());
        } catch (ServiceException e) {
            throw e;
        } catch (Exception e) {
            throw new ServiceException(language,
                                       "FlowNode: Couldn't obtain a flow interpreter for '" + language +
                                       "' at " + getLocation(), e);
        }
    }
17889#/**
     * This method should never be called by the TreeProcessor, since a
     * <code>&lt;map:flow&gt;</code> element should not be in an
     * "executable" sitemap node.
     *
     * @param env an <code>Environment</code> value
     * @param context an <code>InvokeContext</code> value
     * @return a <code>boolean</code> value
     * @exception Exception if an error occurs
     */
    public boolean invoke(Environment env, InvokeContext context) throws Exception {
        return true;
    }
17890#public Interpreter getInterpreter() {
        return interpreter;
    }
17891#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        if (this.manager != null) {
            this.manager.release(this.interpreter);
            this.interpreter = null;
            this.manager = null;
        }
    }
17892#public ProcessingNode buildNode(Configuration config) throws Exception {

        String type = this.treeBuilder.getTypeForStatement(config, Selector.ROLE);

        // Lists of ProcessingNode[] and test resolvers for each "when"
        List whenChildren = new ArrayList();
        List whenTests = new ArrayList();

        // Nodes for otherwise (if any)
        ProcessingNode[] otherwiseNodes = null;

        Configuration[] childrenConfig = config.getChildren();
        for (int i = 0; i < childrenConfig.length; i++) {

            Configuration childConfig = childrenConfig[i];
            String name = childConfig.getName();

            if ("when".equals(name)) {

                checkNamespace(childConfig);
                whenTests.add(
                    VariableResolverFactory.getResolver(childConfig.getAttribute("test"), this.manager)
                );
                whenChildren.add(buildChildNodes(childConfig));

            } else if ("otherwise".equals(name)) {

                checkNamespace(childConfig);
                if (otherwiseNodes != null) {
                    String msg = "Duplicate " + name + " (only one is allowed) at " + childConfig.getLocation();
                    getLogger().error(msg);
                    throw new ConfigurationException(msg);
                }

                otherwiseNodes = buildChildNodes(childConfig);

            } else if (isParameter(childConfig)) {
                // ignore it. It is handled automatically in setupNode()

            } else {
                // Unknown element
                String msg = "Unknown element '" + name + "' in select at " + childConfig.getLocation();
                throw new ConfigurationException(msg);
            }
        }

        ProcessingNode[][] whenChildrenNodes = (ProcessingNode[][])whenChildren.toArray(new ProcessingNode[0][0]);
        VariableResolver[] whenResolvers = (VariableResolver[])whenTests.toArray(new VariableResolver[whenTests.size()]);

        // Get the type and class for this selector
        ServiceSelector compSelector = (ServiceSelector)this.manager.lookup(Selector.ROLE + "Selector");

        Class clazz = null;
        try {
            // Find selector class
            Selector selector = (Selector)compSelector.select(type);
            try {
                clazz = selector.getClass();
            } finally {
                compSelector.release(selector);
            }
        } finally {
            this.manager.release(compSelector);
        }

        if (SwitchSelector.class.isAssignableFrom(clazz)) {
            SwitchSelectNode node = new SwitchSelectNode(type);
            this.treeBuilder.setupNode(node, config);
            node.setCases(whenChildrenNodes, whenResolvers, otherwiseNodes);
            return node;
        }
        SelectNode node = new SelectNode(type);
        this.treeBuilder.setupNode(node, config);
        node.setCases(whenChildrenNodes, whenResolvers, otherwiseNodes);
        return node;
    }
17893#public ScriptNode(String source) {
        this.source = source;
    }
17894#/**
     * This method should never be called by the TreeProcessor, since a
     * <map:script> element should not be in an "executable" sitemap
     * node.
     *
     * @param env an <code>Environment</code> value
     * @param context an <code>InvokeContext</code> value
     * @return a <code>boolean</code> value
     * @exception Exception if an error occurs
     */
    public boolean invoke(Environment env, InvokeContext context)
    throws Exception {
        return true;
    }
17895#public void registerScriptWithInterpreter(Interpreter interpreter) {
        interpreter.register(this.source);
    }
17896#/**
     * Build a <code>SerializerNode</code> having a name, a mime-type and a status code (HTTP codes).
     *
     * @param name the name of the serializer to use.
     * @param mimeType the mime-type, or <code>null</code> not specified.
     * @param statusCode the HTTP response status code, or <code>-1</code> if not specified.
     */
    public ReadNode(String name, VariableResolver source, VariableResolver mimeType, int statusCode) {
        this.readerName = name;
        this.source = source;
        this.mimeType = mimeType;
        this.statusCode = statusCode;
    }
17897#public void setParameters(Map parameterMap) {
        this.parameters = parameterMap;
    }
17898#/* (non-Javadoc)
     * @see org.apache.cocoon.components.treeprocessor.ProcessingNode#invoke(Environment, InvokeContext)
     */
    public final boolean invoke(Environment env,  InvokeContext context)
    throws Exception {

        final Map objectModel = env.getObjectModel();

        final ProcessingPipeline pipeline = context.getProcessingPipeline();

        SitemapExecutor.PipelineComponentDescription desc = new SitemapExecutor.PipelineComponentDescription();
        desc.type = this.readerName;
        desc.source = source.resolve(context, objectModel);
        desc.parameters = VariableResolver.buildParameters(this.parameters, context, objectModel);
        desc.mimeType = this.mimeType.resolve(context, objectModel);

        desc = this.executor.addReader(this, objectModel, desc);

        pipeline.setReader(desc.type,
                           desc.source,
                           desc.parameters,
                           desc.mimeType);

        // Set status code if there is one
        if (this.statusCode >= 0) {
            env.setStatus(this.statusCode);
        }

        if (!context.isBuildingPipelineOnly()) {
            // Process pipeline
            return pipeline.process(env);
        }

        // Return true : pipeline is finished.
        return true;
    }
17899#public ActionSetNode(String name, ProcessingNode[] nodes, String[] actionNames) {
        super(name);
        this.nodes = nodes;
        this.actionNames = actionNames;
    }
17900#public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {
        throw new ProcessingException("An action-set cannot be invoked", getLocation());
    }
17901#/**
     * Call the actions composing the action-set and return the combined result of
     * these actions.
     */
    public final Map call(Environment env, InvokeContext context, Parameters params)
    throws Exception {

        String cocoonAction = env.getAction();

        // Store the parameters from the caller into the environment so that they can be merged with
        // each action's parameters.
        env.setAttribute(CALLER_PARAMETERS, params);

        Map result = null;

        try {
            // Call each action that either has no cocoonAction, or whose cocoonAction equals
            // the one from the environment.
            for (int i = 0; i < nodes.length; i++) {

                String actionName = actionNames[i];
                if (actionName == null || actionName.equals(cocoonAction)) {

                    this.nodes[i].invoke(env, context);

                    // Get action results. They're passed back through the environment since action-sets
                    // "violate" the tree hierarchy (the returned Map is visible outside of the node)
                    Map actionResult = (Map) env.getAttribute(ACTION_RESULTS);
                    // Don't forget to clear it
                    env.removeAttribute(ACTION_RESULTS);

                    if (actionResult != null) {
                        // Merge the result in the global result, creating it if necessary.
                        if (result == null) {
                            result = new HashMap(actionResult);
                        } else {
                            result.putAll(actionResult);
                        }
                    }
                }
            }
        } catch (Exception e) {
            throw ProcessingException.throwLocated("Sitemap: error invoking action set", e, getLocation());
        }

        return result;
    }
17902#/**
     * Implementation of <code>NamedProcessingNode</code>.
     */
    public String getName() {
        return this.componentName;
    }
17903#public PreparableMatchNode(String type, String pattern, String name) {
        super(Matcher.ROLE + "Selector", type);
        this.pattern = pattern;
        this.name = name;
    }
17904#/* (non-Javadoc)
     * @see ParameterizableProcessingNode#setParameters(java.util.Map)
     */
    public void setParameters(Map parameterMap) {
        this.parameters = parameterMap;
    }
17905#/* (non-Javadoc)
     * @see org.apache.avalon.framework.activity.Initializable#initialize()
     */
    public void initialize() throws Exception {

        // Prepare the pattern
        PreparableMatcher matcher = (PreparableMatcher)getComponent();

        try {
            this.preparedPattern = matcher.preparePattern(this.pattern);
        } catch(PatternException pe) {
            String msg = "Invalid pattern '" + this.pattern + "' for matcher at " + getLocation();
            throw new ConfigurationException(msg, pe);
        } finally {
            releaseComponent(matcher);
        }
    }
17906#/* (non-Javadoc)
     * @see org.apache.cocoon.components.treeprocessor.ProcessingNode#invoke(org.apache.cocoon.environment.Environment, org.apache.cocoon.components.treeprocessor.InvokeContext)
     */
    public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {

          // Perform any common invoke functionality
          super.invoke(env, context);

        Map objectModel = env.getObjectModel();
        Parameters resolvedParams = VariableResolver.buildParameters(
            this.parameters, context, objectModel
        );

        Map result = null;

        try {
            PreparableMatcher matcher = (PreparableMatcher)getComponent();
            try {
                result = this.executor.invokePreparableMatcher(this,
                                                               objectModel,
                                                               matcher,
                                                               this.pattern,
                                                               preparedPattern,
                                                               resolvedParams);
            } finally {
                releaseComponent(matcher);
            }

            if (result != null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Matcher '" + this.componentName + "' matched prepared pattern '" +
                                      this.pattern + "' at " + this.getLocation());
                }

                // Invoke children with the matcher results
                return this.invokeNodes(children, env, context, name, result);

            }
        } catch (Exception e) {
            throw ProcessingException.throwLocated("Sitemap: error invoking matcher", e, getLocation());
        }

        // Matcher failed
        return false;
    }
17907#public ProcessingNode buildNode(Configuration config) throws Exception {

        // Get the label or position (pseudo-label) of this view.
        String label = config.getAttribute("from-label", null);

        if (label == null) {
            String position = config.getAttribute("from-position");
            if ("first".equals(position)) {
                label = SitemapLanguage.FIRST_POS_LABEL;
            } else if ("last".equals(position)) {
                label = SitemapLanguage.LAST_POS_LABEL;
            } else {
                String msg = "Bad value for 'from-position' at " + config.getLocation();
                throw new ConfigurationException(msg);
            }
        }

        SitemapLanguage sitemapBuilder = (SitemapLanguage)this.treeBuilder;

        // Indicate to child builders that we're in a view (they won't perform view branching)
        sitemapBuilder.setBuildingView(true);

        // Build children
        NamedProcessingNode result = (NamedProcessingNode)super.buildNode(config);

        sitemapBuilder.addViewForLabel(label, result.getName());

        // Clear the flag
        sitemapBuilder.setBuildingView(false);

        return result;
    }
17908#/**
     * @see org.apache.cocoon.components.treeprocessor.ContainerNodeBuilder#buildNode(org.apache.avalon.framework.configuration.Configuration)
     */
    public ProcessingNode buildNode(Configuration config)
    throws Exception {
        final PipelinesNode node = new PipelinesNode();
        this.treeBuilder.setupNode(node, config);

        Configuration[] childConfigs = config.getChildren();
        List children = new ArrayList();
        HandleErrorsNode handler = null;

        for (int i = 0; i < childConfigs.length; i++) {
            Configuration childConfig = childConfigs[i];
            if (isChild(childConfig)) {

                ProcessingNodeBuilder builder = this.treeBuilder.createNodeBuilder(childConfig);
                if (builder instanceof HandleErrorsNodeBuilder) {
                    handler = (HandleErrorsNode)builder.buildNode(childConfig);
                } else {
                    // Regular builder
                    children.add(builder.buildNode(childConfig));
                }
            }
        }

        if (children.size() == 0) {
            String msg = "There must be at least one pipeline at " + config.getLocation();
            throw new ConfigurationException(msg);
        }

        node.setChildren(toNodeArray(children));
        node.setErrorHandler(handler);

        return node;
    }
17909#public TransformNode(String name, VariableResolver source) {
        this.transformerName = name;
        this.source = source;
    }
17910#public void setParameters(Map parameterMap) {
        this.parameters = parameterMap;
    }
17911#/* (non-Javadoc)
     * @see org.apache.cocoon.components.treeprocessor.ProcessingNode#invoke(Environment, InvokeContext)
     */
    public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {

        final Map objectModel = env.getObjectModel();

        final ProcessingPipeline pipeline = context.getProcessingPipeline();

        SitemapExecutor.PipelineComponentDescription desc = new SitemapExecutor.PipelineComponentDescription();
        desc.type = this.transformerName;
        desc.source = source.resolve(context, objectModel);
        desc.parameters = VariableResolver.buildParameters(this.parameters, context, objectModel);
        desc.hintParameters = this.pipelineHints == null
                ? Parameters.EMPTY_PARAMETERS
                : VariableResolver.buildParameters(this.pipelineHints, context, objectModel);

        // inform executor
        desc = this.executor.addTransformer(this, objectModel, desc);

        pipeline.addTransformer(desc.type,
                                desc.source,
                                desc.parameters,
                                desc.hintParameters);

        // Check view
        if (this.views != null) {

            //inform the pipeline that we have a branch point
            pipeline.informBranchPoint();

            String cocoonView = env.getView();
            if (cocoonView != null) {

                // Get view node
                ProcessingNode viewNode = (ProcessingNode)this.views.get(cocoonView);

                if (viewNode != null) {
                    if (getLogger().isInfoEnabled()) {
                        getLogger().info("Jumping to view " + cocoonView + " from transformer at " + this.getLocation());
                    }
                    return viewNode.invoke(env, context);
                }
            }
        }

        // Return false to contine sitemap invocation
        return false;
    }
17912#public CallFunctionNode(VariableResolver functionName, VariableResolver continuationId, String[] argumentNames) {
        super(null);
        this.functionName = functionName;
        this.continuationId = continuationId;
        this.argumentNames = argumentNames;
    }
17913#/* (non-Javadoc)
     * @see org.apache.cocoon.components.treeprocessor.ParameterizableProcessingNode#setParameters(java.util.Map)
     */
    public void setParameters(Map parameterMap) {
        this.parameters = parameterMap;
    }
17914#public void setInterpreter(Interpreter interp) throws Exception {
        this.interpreter = interp;
    }
17915#public boolean invoke(Environment env, InvokeContext context) throws Exception {

        Map objectModel = env.getObjectModel();

        // Build the list of arguments
        List args;
        if (argumentNames.length != 0) {
            // Resolve parameters
            Parameters params = VariableResolver.buildParameters(this.parameters, context, objectModel);

            args = new ArrayList(argumentNames.length);
            for (int i = 0; i < argumentNames.length; i++) {
                String name = argumentNames[i];
                args.add(new Interpreter.Argument(name, params.getParameter(name)));
            }
        } else {
            args = Collections.EMPTY_LIST;
        }

        // Need redirector in any case
        Redirector redirector = context.getRedirector();

        // If the continuation id is not null, it takes precedence over
        // the function call, so we invoke it here.
        String continuation = continuationId.resolve(context, env.getObjectModel());
        if (continuation != null && continuation.length() > 0) {
            try {
                interpreter.handleContinuation(continuation, args, redirector);
            } catch (Exception e) {
                throw ProcessingException.throwLocated("Sitemap: error calling continuation", e, getLocation());
            }
            if (!redirector.hasRedirected()) {
                throw new ProcessingException("Sitemap: continuation did not send a response", getLocation());
            }
            return true;
        }

        // We don't have a continuation id passed in <map:call>, so invoke
        // the specified function
        String name = functionName.resolve(context, objectModel);
        if (name != null && name.length() > 0) {
            try {
                interpreter.callFunction(name, args, redirector);
            } catch (Exception e) {
                throw ProcessingException.throwLocated("Sitemap: error calling function '" + name + "'", e, getLocation());
            }
            if (!redirector.hasRedirected()) {
                throw new ProcessingException("Sitemap: function '" + name + "' did not send a response", getLocation());
            }
            return true;
        }

        // Found neither continuation nor function to call
        throw new ProcessingException("Sitemap: no function nor continuation given in <map:call function>", getLocation());
    }
17916#public MatchNode(String type, VariableResolver pattern, String name) {
        super(Matcher.ROLE + "Selector", type);
        this.pattern = pattern;
        this.name = name;
    }
17917#public void setParameters(Map parameterMap) {
        this.parameters = parameterMap;
    }
17918#public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {

        // Perform any common invoke functionality
        super.invoke(env, context);

        Map objectModel = env.getObjectModel();

        String resolvedPattern = pattern.resolve(context, objectModel);
        Parameters resolvedParams = VariableResolver.buildParameters(this.parameters, context, objectModel);

        try {
            Map result = null;
            Matcher matcher = (Matcher) getComponent();
            try {
                result = this.executor.invokeMatcher(this,
                                                     objectModel,
                                                     matcher,
                                                     resolvedPattern,
                                                     resolvedParams);
            } finally {
                releaseComponent(matcher);
            }

            if (result != null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Matcher '" + this.componentName + "' matched pattern '" + this.pattern +
                                      "' at " + getLocation());
                }

                // Invoke children with the matcher results
                return invokeNodes(children, env, context, name, result);
            }
        } catch (Exception e) {
            throw ProcessingException.throwLocated("Sitemap: error invoking matcher", e, getLocation());
        }

        // Matcher failed
        return false;
    }
17919#/** Serializers can have parameters -- return <code>true</code> */
    protected boolean hasParameters() {
        return true;
    }
17920#public ProcessingNode buildNode(Configuration config) throws Exception {

        String type = this.treeBuilder.getTypeForStatement(config, Serializer.ROLE);
        
        SitemapLanguage sitemapBuilder = (SitemapLanguage)this.treeBuilder;

        String mimeType = config.getAttribute("mime-type", null);
        if (mimeType == null) {
            mimeType = sitemapBuilder.getMimeType(Serializer.ROLE, type);
        }

        this.views = sitemapBuilder.getViewsForStatement(Serializer.ROLE, type, config);
        this.pipelineHints = sitemapBuilder.getHintsForStatement(Serializer.ROLE, type, config);

        this.node = new SerializeNode(
            type,
            VariableResolverFactory.getResolver(config.getAttribute("src", null), this.manager),
            VariableResolverFactory.getResolver(mimeType, this.manager),
            VariableResolverFactory.getResolver(config.getAttribute("status-code", null), this.manager)
        );
        this.node.setPipelineHints(this.pipelineHints);
        return this.treeBuilder.setupNode(node, config);
    }
17921#public void linkNode() throws Exception {
        this.node.setViews(
            ((SitemapLanguage)this.treeBuilder).getViewNodes(this.views)
        );
    }
17922#public ProcessingNode buildNode(Configuration config) throws Exception {

        String type = this.treeBuilder.getTypeForStatement(config, Reader.ROLE);
        
        String mimeType = config.getAttribute("mime-type", null);
        if (mimeType == null) {
            mimeType = ((SitemapLanguage)this.treeBuilder).getMimeType(Reader.ROLE, type);
        }

        ReadNode node = new ReadNode(
            type,
            VariableResolverFactory.getResolver(config.getAttribute("src", null), this.manager),
            VariableResolverFactory.getResolver(mimeType, this.manager),
            config.getAttributeAsInteger("status-code", -1)
        );

        return this.treeBuilder.setupNode(node, config);
    }
17923#public ProcessingNode buildNode(Configuration config) throws Exception {
        
        // Start by explicitely ordered children
        for (int i = 0; i < orderedNames.length; i++) {
            Configuration childConfig = config.getChild(orderedNames[i], false);
            if (childConfig != null) {
                ProcessingNodeBuilder builder = this.treeBuilder.createNodeBuilder(childConfig);
                // Don't build them since "pipelines" is not present in this list
                builder.buildNode(childConfig);
            }
        }
        
        ProcessingNode pipelines = null;

        // Now build all those that have no particular order
        Configuration[] childConfigs = config.getChildren();
        
        loop: for (int i = 0; i < childConfigs.length; i++) {
            
            Configuration childConfig = childConfigs[i];
            if (isChild(childConfig)) {
                // Is it in the ordered list ?
                for (int j = 0; j < orderedNames.length; j++) {
                    if (orderedNames[j].equals(childConfig.getName())) {
                        // yep : already built above
                        continue loop;
                    }
                }
                
                ProcessingNodeBuilder builder = this.treeBuilder.createNodeBuilder(childConfig);
                ProcessingNode node = builder.buildNode(childConfig);
                if (node instanceof PipelinesNode) {
                    if (pipelines != null) {
                        String msg = "Only one 'pipelines' is allowed, at " + childConfig.getLocation();
                        throw new ConfigurationException(msg);
                    }
                    pipelines = node;
                }
            }
        }

        if (pipelines == null) {
            String msg = "Invalid sitemap : there must be a 'pipelines' at " + config.getLocation();
            throw new ConfigurationException(msg);
        }

        return pipelines;
    }
17924#/**
     * Constructor
     */
    public PipelinesNode() {
        super(null);
        this.errorHandlerHelper = new ErrorHandlerHelper();
    }
17925#/**
     * Pass manager to {@link ErrorHandlerHelper}.
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.errorHandlerHelper.service(manager);
    }
17926#public void setErrorHandler(ProcessingNode node) {
        this.errorHandlerHelper.setErrorHandler(node);
    }
17927#public void setChildren(ProcessingNode[] nodes) {
        // Mark the last pipeline so that it can throw a ResourceNotFoundException
        ((PipelineNode) nodes[nodes.length - 1]).setLast(true);
        super.setChildren(nodes);
    }
17928#/**
     * Process the environment. Also adds a <code>SourceResolver</code>
     * and a <code>Redirector</code> in the object model. The previous resolver and
     * redirector, if any, are restored before return.
     */
    public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {

        // Perform any common invoke functionality
        super.invoke(env, context);

        try {
            // FIXME: Is there any useful information that can be passed as top-level parameters,
            //        such as the URI of the mount point ?

            return invokeNodes(this.children, env, context);

        } catch (ConnectionResetException e) {
            // Will be reported by CocoonServlet, rethrowing
            throw e;

        } catch (Exception ex) {
            // Invoke pipelines handler
            return this.errorHandlerHelper.invokeErrorHandler(ex, env, context);
        }
    }
17929#public void dispose() {
        this.errorHandlerHelper = null;
    }
17930#/** This builder has no parameters -- return <code>false</code> */
    protected boolean hasParameters() {
        return false;
    }
17931#public ProcessingNode buildNode(Configuration config) throws Exception {
        final Settings settings = (Settings)manager.lookup(Settings.ROLE);
        MountNode node = new MountNode(
            VariableResolverFactory.getResolver(config.getAttribute("uri-prefix"), manager),
            VariableResolverFactory.getResolver(config.getAttribute("src"), manager),
            this.treeBuilder.getProcessor().getWrappingProcessor(),
            config.getAttributeAsBoolean("check-reload", settings.isReloadingEnabled("sitemap")),
            config.getAttributeAsBoolean("pass-through", false)
        );
  
        return (this.treeBuilder.setupNode(node, config));
    }
17932#/**
     * The component manager is used to create notifying builders.
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
        this.handledErrorsLogger = LoggerUtils.getChildLogger(this.manager, "handled");
    }
17933#void setErrorHandler(ProcessingNode node) {
        this.error = (HandleErrorsNode) node;
    }
17934#/**
     * @return true if has no error handler nodes set
     */
    public boolean isEmpty() {
        return this.error == null;
    }
17935#public boolean isInternal() {
        return this.error != null && this.error.isInternal();
    }
17936#public boolean isExternal() {
        return this.error != null && this.error.isExternal();
    }
17937#/**
     * Handle error.
     */
    public boolean invokeErrorHandler(Exception ex,
                                      Environment env,
                                      InvokeContext context)
    throws Exception {
        final Processor.InternalPipelineDescription desc = prepareErrorHandler(ex, env, context);
        if (desc != null) {
            context.setInternalPipelineDescription(desc);
            return true;
        }

        return false;
    }
17938#/**
     * Prepare error handler for the internal pipeline error handling.
     *
     * <p>If building pipeline only, error handling pipeline will be
     * built and returned. If building and executing pipeline,
     * error handling pipeline will be built and executed.</p>
     */
    public Processor.InternalPipelineDescription prepareErrorHandler(Exception ex,
                                                                     Environment env,
                                                                     InvokeContext context)
    throws Exception {
        boolean internal = !env.isExternal() && !env.isInternalRedirect();

        if (internal && !isInternal()) {
            // Propagate exception on internal request: No internal handler.
            throw ex;
        } else if (!internal && !isExternal()) {
            // Propagate exception on external request: No external handler.
            throw ex;
        } else if (error != null) {
            // Invoke error handler
            return prepareErrorHandler(error, ex, env, context);
        }

        // Exception was not handled by this error handler, propagate.
        throw ex;
    }
17939#/**
     * Prepare (or execute) error handler using specified error handler
     * processing node.
     *
     * <p>If building pipeline only, error handling pipeline will be
     * built and returned. If building and executing pipeline,
     * error handling pipeline will be built and executed.</p>
     */
    private Processor.InternalPipelineDescription prepareErrorHandler(ProcessingNode node,
                                                                      Exception ex,
                                                                      Environment env,
                                                                      InvokeContext context)
    throws Exception {
        if (ex instanceof ResourceNotFoundException) {
            this.handledErrorsLogger.error(ex.getMessage());
        } else {
            this.handledErrorsLogger.error(ex.getMessage(), ex);
        }

        try {
            prepare(context, env, ex);

            // Create error context
            InvokeContext errorContext = new InvokeContext(context, this.manager);
            try {
                // Process error handling node
                if (node.invoke(env, errorContext)) {
                    // Exception was handled.
                    return errorContext.getInternalPipelineDescription(env);
                }
            } finally {
                errorContext.dispose();
            }
        } catch (Exception e) {
            getLogger().error("An exception occured while handling errors at " + node.getLocation(), e);
            // Rethrow it: It will either be handled by the parent sitemap or by the environment (e.g. Cocoon servlet)
            throw e;
        }

        // Exception was not handled in this error handler, propagate.
        throw ex;
    }
17940#/**
     * Build notifying object
     */
    private void prepare(InvokeContext context, Environment env, Exception ex)
    throws IOException, ServiceException {
        Map objectModel = env.getObjectModel();
        if (objectModel.get(ObjectModelHelper.THROWABLE_OBJECT) == null) {
            // error has not been processed by another handler before

            // Try to reset the response to avoid mixing already produced output
            // and error page.
            if (!context.isBuildingPipelineOnly()) {
                env.tryResetResponse();
            }

            // Create a Notifying (deprecated)
            NotifyingBuilder notifyingBuilder = (NotifyingBuilder) this.manager.lookup(NotifyingBuilder.ROLE);
            Notifying currentNotifying = null;
            try {
                currentNotifying = notifyingBuilder.build(this, ex);
            } finally {
                this.manager.release(notifyingBuilder);
            }
            objectModel.put(Constants.NOTIFYING_OBJECT, currentNotifying);

            // Add it to the object model
            objectModel.put(ObjectModelHelper.THROWABLE_OBJECT, ex);
        }
    }
17941#public MountNode(VariableResolver prefix,
                     VariableResolver source,
                     TreeProcessor parentProcessor,
                     boolean checkReload,
                     boolean passThrough) {
        this.prefix = prefix;
        this.source = source;
        this.parentProcessor = parentProcessor;
        this.checkReload = checkReload;
        this.passThrough = BooleanUtils.toBooleanObject(passThrough);
    }
17942#/**
     * @see org.apache.cocoon.components.treeprocessor.ProcessingNode#invoke(Environment, InvokeContext)
     */
    public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {
        final Map objectModel = env.getObjectModel();

        String resolvedSource = this.source.resolve(context, objectModel);
        String resolvedPrefix = this.prefix.resolve(context, objectModel);

        if (resolvedSource.length() == 0) {
            throw new ProcessingException("Source of mount statement is empty");
        }

        // Handle directory mounts
        if (resolvedSource.charAt(resolvedSource.length() - 1) == '/') {
            resolvedSource = resolvedSource + "sitemap.xmap";
        }

        TreeProcessor processor = getProcessor(resolvedSource, resolvedPrefix);

        // Save context
        String oldPrefix = env.getURIPrefix();
        String oldURI    = env.getURI();
        Object oldPassThrough = env.getAttribute(COCOON_PASS_THROUGH);
        env.setAttribute(COCOON_PASS_THROUGH, this.passThrough);

        try {
            processor.getEnvironmentHelper().changeContext(env);

            if (context.isBuildingPipelineOnly()) {
                // Propagate pipelines
                Processor.InternalPipelineDescription pp = processor.buildPipeline(env);
                if (pp != null) {
                    context.setInternalPipelineDescription(pp);
                    return true;
                }

                return false;
            }

            // Processor will create its own pipelines
            return processor.process(env);
        } catch(Exception e) {
            // Wrap with our location
            throw ProcessingException.throwLocated("Sitemap: error when calling sub-sitemap", e, getLocation());

        } finally {
            // Restore context
            env.setURI(oldPrefix, oldURI);
            if (oldPassThrough != null) {
                env.setAttribute(COCOON_PASS_THROUGH, oldPassThrough);
            } else {
                env.removeAttribute(COCOON_PASS_THROUGH);
            }
        }
    }
17943#private synchronized TreeProcessor getProcessor(String source, String prefix)
    throws Exception {

        TreeProcessor processor = (TreeProcessor) processors.get(source);
        if (processor == null) {
            processor = this.parentProcessor.createChildProcessor(source, this.checkReload, prefix);

            // Associate to the original source
            processors.put(source, processor);
        }

        return processor;
    }
17944#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        Iterator i = this.processors.values().iterator();
        while (i.hasNext()) {
            ContainerUtil.dispose(i.next());
        }
        this.processors.clear();
    }
17945#/**
     * Build a <code>SerializerNode</code> having a name, a mime-type and a status code (HTTP codes).
     *
     * @param name the name of the serializer to use.
     * @param mimeType the mime-type, or <code>null</code> not specified.
     * @param statusCode the HTTP response status code, or <code>-1</code> if not specified.
     */
    public SerializeNode(String name,
                         VariableResolver source,
                         VariableResolver mimeType,
                         VariableResolver statusCode) {
        this.serializerName = name;
        this.source = source;
        this.mimeType = mimeType;
        this.statusCode = statusCode;
    }
17946#public void setParameters(Map parameterMap) {
        this.parameters = parameterMap;
    }
17947#/* (non-Javadoc)
     * @see org.apache.cocoon.components.treeprocessor.ProcessingNode#invoke(org.apache.cocoon.environment.Environment, org.apache.cocoon.components.treeprocessor.InvokeContext)
     */
    public final boolean invoke(Environment env, InvokeContext context)
    throws Exception {

        // Check view
        if (this.views != null) {

            //inform the pipeline that we have a branch point
            context.getProcessingPipeline().informBranchPoint();

            String cocoonView = env.getView();
            if (cocoonView != null) {

                // Get view node
                ProcessingNode viewNode = (ProcessingNode)this.views.get(cocoonView);

                if (viewNode != null) {
                    if (getLogger().isInfoEnabled()) {
                        getLogger().info("Jumping to view " + cocoonView + " from serializer at " + this.getLocation());
                    }
                    return viewNode.invoke(env, context);
                }
            }
        }

        final Map objectModel = env.getObjectModel();
        final ProcessingPipeline pipeline = context.getProcessingPipeline();

        // Perform link translation if requested
        if (objectModel.containsKey(Constants.LINK_OBJECT)) {
            pipeline.addTransformer("<translator>", null, Parameters.EMPTY_PARAMETERS, Parameters.EMPTY_PARAMETERS);
        }

        if (objectModel.containsKey(Constants.LINK_COLLECTION_OBJECT) && env.isExternal()) {
            pipeline.addTransformer("<gatherer>", null, Parameters.EMPTY_PARAMETERS, Parameters.EMPTY_PARAMETERS);
        }

        SitemapExecutor.PipelineComponentDescription desc = new SitemapExecutor.PipelineComponentDescription();
        desc.type = this.serializerName;
        desc.source = source.resolve(context, objectModel);
        desc.parameters = VariableResolver.buildParameters(this.parameters, context, objectModel);
        desc.hintParameters = this.pipelineHints == null
                ? Parameters.EMPTY_PARAMETERS
                : VariableResolver.buildParameters(this.pipelineHints, context, objectModel);
        desc.mimeType = this.mimeType.resolve(context, objectModel);

        // inform executor
        desc = this.executor.addSerializer(this, objectModel, desc);

        pipeline.setSerializer(desc.type,
                               desc.source,
                               desc.parameters,
                               desc.hintParameters,
                               desc.mimeType);

        // Set status code *only* if there is one - do not override status
        // code if it was set elsewhere.
        String statusCodeString = this.statusCode.resolve(context, objectModel);
        if (statusCodeString != null) {
            int statusCodeInt = DEFAULT_STATUS_CODE;
            try {
                statusCodeInt = Integer.parseInt(statusCodeString);
            } catch (NumberFormatException e) {
                getLogger().warn("Status code value '" + statusCodeString + "' is not an integer. " +
                                 "Using " + DEFAULT_STATUS_CODE + " instead.", e);
            }
            if (statusCodeInt >= 0) {
                env.setStatus(statusCodeInt);
            }
        }

        if (!context.isBuildingPipelineOnly()) {
            // Process pipeline
            return pipeline.process(env);
        }
        // Return true : pipeline is finished.
        return true;
    }
17948#protected VariableResolver() {
    }
17949#protected VariableResolver(String expr) {
        this.originalExpr = expr;
    }
17950#public abstract void setExpression(String expression) throws PatternException;
17951#public final String toString() {
        return this.originalExpr;
    }
17952#/**
     * Compare two VariableResolvers
     */
    public boolean equals(Object object) {
        //noinspection SimplifiableIfStatement
        if (!(object instanceof VariableResolver)) {
            return false;
        }

        return ObjectUtils.equals(this.originalExpr, ((VariableResolver) object).originalExpr);
    }
17953#/**
     * generate HashCode
     * needed to determine uniqueness within hashtables
     */
    public int hashCode() {
        return this.originalExpr == null ? 0 : this.originalExpr.hashCode();
    }
17954#/**
     * Resolve all {...} patterns using the values given in the object model.
     */
    public String resolve(Map objectModel) throws PatternException {
        return resolve(null, objectModel);
    }
17955#/**
     * Resolve all {...} patterns using the values given in the list of maps and the object model.
     */
    public abstract String resolve(InvokeContext context, Map objectModel) throws PatternException;
17956#/**
     * Build a <code>Parameters</code> object from a Map of named <code>VariableResolver</code>s and
     * a list of Maps used for resolution.
     *
     * @return a fully resolved <code>Parameters</code>.
     */
    public static Parameters buildParameters(Map expressions, InvokeContext context, Map objectModel) throws PatternException {
        Location location;
        if (expressions instanceof Locatable) {
            location = ((Locatable) expressions).getLocation();
        } else {
            location = Location.UNKNOWN;
        }
        if (expressions == null || expressions.size() == 0 && location.equals(Location.UNKNOWN)) {
            return Parameters.EMPTY_PARAMETERS;
        }

        SitemapParameters result = new SitemapParameters(location);

        Iterator iter = expressions.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry entry = (Map.Entry) iter.next();
            result.setParameter(
                    ((VariableResolver) entry.getKey()).resolve(context, objectModel),
                    ((VariableResolver) entry.getValue()).resolve(context, objectModel)
            );
        }

        return result;
    }
17957#/**
     * Build a <code>Map</code> from a Map of named <code>ListOfMapResolver</code>s and
     * a list of Maps used for resolution.
     *
     * @return a fully resolved <code>Map</code>.
     */
    public static Map buildMap(Map expressions, InvokeContext context, Map objectModel) throws PatternException {
        int size;
        if (expressions == null || (size = expressions.size()) == 0) {
            return Collections.EMPTY_MAP;
        }

        Map result;
        if (expressions instanceof Locatable) {
            result = new SitemapParameters.LocatedHashMap(((Locatable) expressions).getLocation(), size);
        } else {
            result = new HashMap(size);
        }

        Iterator iter = expressions.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();
            result.put(
                    ((VariableResolver) entry.getKey()).resolve(context, objectModel),
                    ((VariableResolver) entry.getValue()).resolve(context, objectModel)
            );
        }

        return result;
    }
17958#/**
     * Set the thread-local list where all created resolvers that need to be
     * disposed will be collected.
     * <p>
     * The purpose of collecting resolvers is to avoid manual release (or lack thereof)
     * that requires most <code>ProcessingNodes</code> to implement <code>Disposable</code>.
     */
    public static void setDisposableCollector(List collector) {
        disposableCollector.set(collector);
    }
17959#/**
     * Does an expression need resolving (i.e. contain {...} patterns) ?
     */
    public static boolean needsResolve(String expression) {
        if (expression == null || expression.length() == 0) {
            return false;
        }

        // Is the first char a '{' ?
        if (expression.charAt(0) == '{') {
            return true;
        }

        if (expression.length() < 2) {
            return false;
        }

        // Is there any unescaped '{' ?
        int pos = 1;
        while ( (pos = expression.indexOf('{', pos)) != -1) {
            // Found a '{' : is it escaped ?
            if (expression.charAt(pos - 1) != '\\') {
                // No : need to resolve
                return true;
            }
            pos++;
        }
        // Nothing found...
        return false;
    }
17960#/**
     * Unescape an expression that doesn't need to be resolved, but may contain
     * escaped '{' characters.
     *
     * @param expression the expression to unescape.
     * @return the unescaped result, or <code>expression</code> if unescaping isn't necessary.
     */
    public static String unescape(String expression) {
        // Does it need escaping ?
        if (expression == null || expression.indexOf("\\{") == -1) {
            return expression;
        }

        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < expression.length(); i++) {
            char ch = expression.charAt(i);
            if (ch != '\\' || i >= (expression.length() - 1) || expression.charAt(i+1) != '{') {
                buf.append(ch);
            }
        }

        return buf.toString();
    }
17961#/**
     * Get a resolver for a given expression. Chooses the most efficient implementation
     * depending on <code>expression</code>.
     */
    public static VariableResolver getResolver(String expression, ServiceManager manager) throws PatternException {
        if (needsResolve(expression)) {
            VariableResolver resolver;
            try {
                resolver = (VariableResolver) manager.lookup(VariableResolver.ROLE);
                resolver.setExpression(expression);
            } catch (ServiceException e) {
                throw new PatternException("Couldn't obtain VariableResolver.", e);
            }

            return resolver;
        }

        return new NOPVariableResolver(expression);
    }
17962#public NOPVariableResolver() {
        super();
    }
17963#public NOPVariableResolver(String expression) {
        super();
        setExpression(expression);
    }
17964#public void setExpression(String expression) {
        this.originalExpr = expression;
        if (expression != null) {
            this.expression = VariableResolverFactory.unescape(expression);
        }
    }
17965#public final String resolve(InvokeContext context, Map objectModel) {
        return this.expression;
    }
17966#/**
     * Tokenizes specified expression. Passes tokens to the
     * reciever.
     *
     * @throws PatternException if expression is not valid
     */
    public static void tokenize(String expression, TokenReciever reciever) throws PatternException {

        int lastTokenType = 0;

        int openCount = 0;
        int closeCount = 0;

        int pos = 0;
        int i;
        boolean escape = false;

        for (i = 0; i < expression.length(); i++) {
            final char c = expression.charAt(i);

            if (escape) {
                escape = false;
            } else if (c == '\\' && i < expression.length()) {
                char nextChar = expression.charAt(i + 1);
                if (nextChar == '{' || nextChar == '}' || nextChar == '$') {
                    expression = expression.substring(0, i) + expression.substring(i + 1);
                    escape = true;
                    i--;
                }
            } else if (c == '$') {
                if (expression.charAt(i+1) != '{')
                    //it's not an expression like ${cocoon.request}, skipping
                    continue;
                
                if (i > pos) {
                    reciever.addToken(lastTokenType = TokenReciever.TEXT, expression.substring(pos, i));
                }
                
                i++;
                openCount++;
                reciever.addToken(lastTokenType = TokenReciever.OPEN, null);
                
                int closePos = indexOf(expression, '}', i);

                //expression conforming cocoon-expression-language
                String newExpression = expression.substring(i+1, closePos);
                reciever.addToken(lastTokenType = TokenReciever.NEW_EXPRESSION, newExpression);
                i = closePos - 1;
                
            } else if (c == '{') {
                if (i > pos) {
                    reciever.addToken(lastTokenType = TokenReciever.TEXT, expression.substring(pos, i));
                }

                openCount++;
                reciever.addToken(lastTokenType = TokenReciever.OPEN, null);

                int colonPos = indexOf(expression, ':', i);
                int closePos = indexOf(expression, '}', i);
                int openPos = indexOf(expression, '{', i);

                if (openPos < colonPos && openPos < closePos) {
                    throw new PatternException("Invalid '{' at position " + i +
                                               " in expression \"" + expression + "\"");
                }

                if (colonPos < closePos) {
                    // we've found a module
                    String module = expression.substring(i + 1, colonPos);
                    reciever.addToken(lastTokenType = TokenReciever.MODULE, module);
                    i = colonPos - 1;
                } else {
                    // Unprefixed name: variable
                    reciever.addToken(lastTokenType = TokenReciever.VARIABLE, expression.substring(i + 1, closePos));
                    i = closePos - 1;
                }

                pos = i + 1;
            } else if (c == '}') {
                if (i > 0 && expression.charAt(i - 1) == '\\') {
                    continue;
                }
                if (i > pos) {
                    reciever.addToken(lastTokenType = TokenReciever.TEXT, expression.substring(pos, i));
                }

                closeCount++;
                reciever.addToken(lastTokenType = TokenReciever.CLOSE, null);

                pos = i + 1;
            } else if (c == ':') {
                if (lastTokenType != TokenReciever.MODULE || i != pos) {
                    // this colon isn't part of a module reference
                    continue;
                }

                reciever.addToken(lastTokenType = TokenReciever.COLON, null);
                pos = i + 1;
            }
        }

        if (i > pos) {
            reciever.addToken(lastTokenType = TokenReciever.TEXT, expression.substring(pos, i));
        }

        if (openCount != closeCount) {
            throw new PatternException("Mismatching braces in expression \"" + expression + "\"");
        }
    }
17967#private static int indexOf(String expression, char chr, int pos) {
        int location;
        return (location = expression.indexOf(chr, pos + 1)) != -1? location : expression.length();
    }
17968#/**
         * Reports parsed tokens.
         */
        void addToken(int type, String value) throws PatternException;
17969#public LegacySubstitutions(LegacySitemapStringTemplateParser stringTemplateParser, Locator location, String stringTemplate) throws SAXException {
        super(stringTemplateParser, location, stringTemplate);
    }
17970#public String toString(Locator location, ObjectModel objectModel) throws SAXException {
        throw new UnsupportedOperationException();
    }
17971#public String toString(Locator location, ObjectModel objectModel, InvokeContext context, Map oldObjectModel) throws SAXParseException {
        StringBuffer buf = new StringBuffer();

        Iterator i = iterator();
        while (i.hasNext()) {
            Subst subst = (Subst) i.next();

            Object val;
            try {
                if (subst instanceof LegacySitemapStringTemplateParser.SitemapExpressionSubstitution)
                    val = ((LegacySitemapStringTemplateParser.SitemapExpressionSubstitution) subst).getStringValue(context, oldObjectModel);
                else
                    val = subst.getValue(objectModel);
            } catch (Exception e) {
                throw new SAXParseException(e.getMessage(), location, e);
            }

            if (val != null) {
                buf.append(val.toString());
            }
        }
        
        return buf.toString();
    }
17972#public ServiceManager getServiceManager() {
        return serviceManager;
    }
17973#public void setServiceManager(ServiceManager serviceManager) {
        this.serviceManager = serviceManager;
    }
17974#protected List parseSubstitutions(Reader in) throws Exception {
        LinkedList substitutions = new LinkedList();
        StringWriter writer = new StringWriter();
        IOUtils.copy(in, writer);
        String expression = writer.toString();
        substitutions.add(new SitemapExpressionSubstitution(expression, serviceManager));
        return substitutions;
    }
17975#private SitemapExpressionSubstitution(String expression, ServiceManager manager) throws PatternException {
            this.resolver = new PreparedVariableResolver(expression, manager);
        }
17976#public Boolean getBooleanValue(ObjectModel objectModel) throws Exception {
            throw new UnsupportedOperationException();
        }
17977#public Object getCompiledExpression() {
            throw new UnsupportedOperationException();
        }
17978#public int getIntValue(ObjectModel objectModel) throws Exception {
            throw new UnsupportedOperationException();
        }
17979#public Iterator getIterator(ObjectModel objectModel) throws Exception {
            throw new UnsupportedOperationException();
        }
17980#public Object getNode(ObjectModel objectModel) throws Exception {
            throw new UnsupportedOperationException();
        }
17981#public Number getNumberValue(ObjectModel objectModel) throws Exception {
            throw new UnsupportedOperationException();
        }
17982#public String getRaw() {
            throw new UnsupportedOperationException();
        }
17983#public String getStringValue(ObjectModel objectModel) throws Exception {
            throw new UnsupportedOperationException();
        }
17984#public String getStringValue(InvokeContext context, Map oldObjectModel) throws PatternException {
            return resolver.resolve(context, oldObjectModel);
        }
17985#public Object getValue(ObjectModel objectModel) throws Exception {
            throw new UnsupportedOperationException();
        }
17986#public void setLenient(Boolean lenient) {
            //ignore
        }
17987#public StringTemplateParserVariableResolver() {
        super();
    }
17988#public StringTemplateParser getStringTemplateParser() {
        return stringTemplateParser;
    }
17989#public void setStringTemplateParser(StringTemplateParser stringTemplateParser) {
        this.stringTemplateParser = stringTemplateParser;
    }
17990#public ObjectModel getObjectModel() {
        return objectModel;
    }
17991#public void setObjectModel(ObjectModel objectModel) {
        this.objectModel = objectModel;
    }
17992#public void setExpression(String expression) throws PatternException {
        this.originalExpr = expression;
        try {
            if (stringTemplateParser instanceof LegacySitemapStringTemplateParser)
                this.substitutions = new LegacySubstitutions((LegacySitemapStringTemplateParser) stringTemplateParser, null, expression);
            else
                this.substitutions = new Substitutions(stringTemplateParser, null, expression);
        } catch (Exception e) {
            throw new PatternException(e);
        }
    }
17993#public String resolve(InvokeContext context, Map objectModel) throws PatternException {
        try {
            if (this.substitutions instanceof LegacySubstitutions)
                return ((LegacySubstitutions) substitutions).toString(null, this.objectModel, context, objectModel);
            else
                return substitutions.toString(null, this.objectModel);
        } catch (Exception e) {
            throw new PatternException(e);
        }
    }
17994#public PreparedVariableResolver() {
        super();
    }
17995#public PreparedVariableResolver(String expression, ServiceManager manager) throws PatternException {
        setManager(manager);
        setExpression(expression);
    }
17996#public ServiceManager getManager() {
        return manager;
    }
17997#public void setManager(ServiceManager manager) {
        this.manager = manager;
    }
17998#public void setExpression(String expr) throws PatternException {
        this.originalExpr = expr;
        this.tokens = new ArrayList();

        VariableExpressionTokenizer.tokenize(expr, new VariableExpressionTokenizer.TokenReciever() {
            public void addToken(int type, String value) throws PatternException {
                switch (type) {
                    case VariableExpressionTokenizer.TokenReciever.COLON:
                        tokens.add(COLON_TOKEN);
                        break;
                    case VariableExpressionTokenizer.TokenReciever.OPEN:
                        tokens.add(OPEN_TOKEN);
                        break;
                    case VariableExpressionTokenizer.TokenReciever.CLOSE:
                        tokens.add(CLOSE_TOKEN);
                        break;
                    case VariableExpressionTokenizer.TokenReciever.TEXT:
                        tokens.add(new Token(value));
                        break;
                    case VariableExpressionTokenizer.TokenReciever.NEW_EXPRESSION:
                        tokens.add(new Token(NEW_EXPRESSION, value));
                        break;
                    case VariableExpressionTokenizer.TokenReciever.MODULE:
                        Token token;
                        if (value.equals("sitemap")) {
                            // Explicit prefix for sitemap variable
                            needsMapStack = true;
                            token = new Token(SITEMAP_VAR);
                        } else if (value.startsWith("#")) {
                            // anchor syntax refering to a name result level
                            needsMapStack = true;
                            token = new Token(ANCHOR_VAR, value.substring(1));
                        } else {
                            // Module used
                            token = getNewModuleToken(value);
                        }
                        tokens.add(token);
                        break;
                    case VariableExpressionTokenizer.TokenReciever.VARIABLE:
                        needsMapStack = true;
                        tokens.add(getNewVariableToken(value));
                        break;
                    default:
                        throw new IllegalArgumentException("Unknown token type: " + type);
                }
            }
        });
    }
17999#protected Token getNewVariableToken(String variable) {
        if (variable.startsWith("/")) {
            return new Token(ROOT_SITEMAP_VARIABLE, variable.substring(1));
        }
        // Find level
        int level = 1; // Start at 1 since it will be substracted from list.size()
        int pos = 0;
        while (variable.startsWith("../", pos)) {
            level++;
            pos += "../".length();
        }
        return new Token(level, variable.substring(pos));
    }
18000#protected Token getNewModuleToken(String moduleName) throws PatternException {
        // Get the module
        InputModule module;
        try {
            module = (InputModule) this.manager.lookup(InputModule.ROLE + '/' + moduleName);
        } catch (ServiceException e) {
            throw new PatternException("Cannot get module named '" + moduleName +
                                       "' in expression '" + this.originalExpr + "'", e);
        }

        Token token;
        // Is this module threadsafe ?
        if (module instanceof ThreadSafe) {
            token = new Token(THREADSAFE_MODULE, module);
        } else {
            // Stateful module : release it and get a new one each time
            this.manager.release(module);
            token = new Token(STATEFUL_MODULE, moduleName);
        }
        return token;
    }
18001#public final String resolve(InvokeContext context, Map objectModel) throws PatternException {
        List mapStack = null; // get the stack only when necessary - lazy inside the loop
        int stackSize = 0;

        if (needsMapStack) {
            if (context == null) {
                throw new PatternException("Need an invoke context to resolve " + this);
            }
            mapStack = context.getMapStack();
            stackSize = mapStack.size();
        }

        Stack stack = new Stack();

        for (Iterator i = tokens.iterator(); i.hasNext();) {
            Token token = (Token) i.next();
            Token last;
            switch (token.getType()){
                case TEXT:
                    if (stack.empty()) {
                        stack.push(new Token(EXPR, token.getStringValue()));
                    } else {
                        last = (Token)stack.peek();
                        if (last.hasType(EXPR)) {
                            last.merge(token);
                        } else {
                            stack.push(new Token(EXPR, token.getStringValue()));
                        }
                    }
                    break;
                case CLOSE:
                    Token expr = (Token)stack.pop();
                    Token lastButOne = (Token)stack.pop();
                    Token result;
                    if (expr.hasType(COLON)) { // i.e. nothing was specified after the colon
                        stack.pop(); // Pop the OPEN
                        result = processModule(lastButOne, EMPTY_TOKEN, objectModel, context, mapStack, stackSize);
                    } else if (lastButOne.hasType(COLON)) {
                        Token module = (Token)stack.pop();
                        stack.pop(); // Pop the OPEN
                        result = processModule(module, expr, objectModel, context, mapStack, stackSize);
                    } else if (lastButOne.hasType(VariableExpressionTokenizer.TokenReciever.NEW_EXPRESSION)) {
                        stack.pop(); // Pop the OPEN
                        ExpressionFactory expressionFactory = null;
                        ObjectModel newObjectModel = null;
                        try {
                            expressionFactory = (ExpressionFactory)manager.lookup(ExpressionFactory.ROLE);
                            newObjectModel = (ObjectModel)manager.lookup(ObjectModel.ROLE);
                            result = processNewExpression(lastButOne, expressionFactory, newObjectModel);
                        } catch (ServiceException e) {
                            throw new PatternException("Cannot obtain necessary components to evaluate new expression '"
                                    + lastButOne.getStringValue() + "' in expression '" + this.originalExpr + "'", e);
                        } finally {
                            if (expressionFactory != null)
                                manager.release(expressionFactory);
                            if (newObjectModel != null)
                                manager.release(newObjectModel);
                        }
                    } else {
                        result = processVariable(expr, mapStack, stackSize);
                    }
                    if (stack.empty()) {
                        stack.push(result);
                    } else {
                        last = (Token)stack.peek();
                        if (last.hasType(EXPR)) {
                            last.merge(result);
                        } else {
                            stack.push(result);
                        }
                    }
                    break;
                case OPEN:
                case COLON:
                case ANCHOR_VAR:
                case THREADSAFE_MODULE:
                case STATEFUL_MODULE:
                case ROOT_SITEMAP_VARIABLE:
                default: {
                    stack.push(token);
                    break;
                }
            }
        }
        if (stack.size() !=1) {
            throw new PatternException("Evaluation error in expression: " + originalExpr);
        }
        return ((Token)stack.pop()).getStringValue();
    }
18002#private Token processModule(Token module, Token expr, Map objectModel, InvokeContext context, List mapStack, int stackSize) throws PatternException {
        int type = module.getType();

        if (type == ANCHOR_VAR) {
            Map levelResult = context.getMapByAnchor(module.getStringValue());

            if (levelResult == null) {
              throw new PatternException("Error while evaluating '" + this.originalExpr +
                "' : no anchor '" + String.valueOf(module.getStringValue()) + "' found in context");
            }

            Object result = levelResult.get(expr.getStringValue());
            return new Token(EXPR, result==null ? "" : result.toString());
        } else if (type == THREADSAFE_MODULE) {
            try {
                InputModule im = module.getModule();
                Object result = im.getAttribute(expr.getStringValue(), null, objectModel);
                return new Token(EXPR, result==null ? "" : result.toString());

            } catch(ConfigurationException confEx) {
                throw new PatternException("Cannot get variable '" + expr.getStringValue() +
                    "' in expression '" + this.originalExpr + "'", confEx);
            }

        } else if (type == STATEFUL_MODULE) {
            InputModule im = null;
            String moduleName = module.getStringValue();
            try {
                im = (InputModule) this.manager.lookup(InputModule.ROLE + '/' + moduleName);

                Object result = im.getAttribute(expr.getStringValue(), null, objectModel);
                return new Token(EXPR, result==null ? "" : result.toString());

            } catch(ServiceException e) {
                throw new PatternException("Cannot get module '" + moduleName +
                                           "' in expression '" + this.originalExpr + "'", e);

            } catch(ConfigurationException confEx) {
                throw new PatternException("Cannot get variable '" + expr.getStringValue() +
                    "' in expression '" + this.originalExpr + "'", confEx);

            } finally {
                this.manager.release(im);
            }
        } else if (type == SITEMAP_VAR) {
            // Prefixed sitemap variable must be parsed at runtime
            String variable = expr.getStringValue();
            Token token;
            if (variable.startsWith("/")) {
                token = new Token(ROOT_SITEMAP_VARIABLE, variable.substring(1));
            } else {
                // Find level
                int level = 1; // Start at 1 since it will be substracted from list.size()
                int pos = 0;
                while (variable.startsWith("../", pos)) {
                    level++;
                    pos += "../".length();
                }
                token = new Token(level, variable.substring(pos));
            }
            return processVariable(token, mapStack, stackSize);
        } else {
            throw new PatternException("Unknown token type: " + expr.getType());
        }
    }
18003#private Token processVariable(Token expr, List mapStack, int stackSize) throws PatternException {
        int type = expr.getType();
        String value = expr.getStringValue();
        if (type == ROOT_SITEMAP_VARIABLE) {
            Object result = ((Map)mapStack.get(0)).get(value);
            return new Token(EXPR, result==null ? "" : result.toString());
        }
        // relative sitemap variable
        if (type > stackSize) {
            throw new PatternException("Error while evaluating '" + this.originalExpr +
                "' : not so many levels");
        }

        Object result = ((Map)mapStack.get(stackSize - type)).get(value);
        return new Token(EXPR, result==null ? "" : result.toString());
    }
18004#private Token processNewExpression(Token expr, ExpressionFactory expressionFactory, ObjectModel newObjectModel) throws PatternException {
        Object result;
        try {
            Expression newExpression = expressionFactory.getExpression(expr.getStringValue());
            result = newExpression.evaluate(newObjectModel);
        } catch (ExpressionException e) {
            throw new PatternException("Cannot evaluate new expression '" + expr.getStringValue() + "' in expression "
                                       + "'" + this.originalExpr + "'", e);
        }
        return new Token(EXPR, result == null ? "" : result.toString());
    }
18005#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public final void dispose() {
        if (this.manager != null) {
            for (Iterator i = tokens.iterator(); i.hasNext();) {
                Token token = (Token)i.next();
                if (token.hasType(THREADSAFE_MODULE)) {
                    InputModule im = token.getModule();
                    this.manager.release(im);
                }
            }
            this.tokens.clear();
            this.manager = null;
        }
    }
18006#public Token(int type) {
            if (type==EXPR) {
                this.value="";
            } else {
                this.value = null;
            }
            this.type = type;
        }
18007#public Token(int type, String value) {
            this.value = value;
            this.type = type;
        }
18008#public Token(int type, InputModule module) {
            this.value = module;
            this.type = type;
        }
18009#public Token(String value) {
            this.type = TEXT;
            this.value = value;
        }
18010#public int getType() {
          return type;
        }
18011#public String getStringValue() {
            if (value instanceof String) {
                return (String) this.value;
            }
            return null;
        }
18012#public boolean hasType(int type){
            return this.type == type;
        }
18013#public boolean equals(Object o) {
            if (o instanceof Token) {
                return ((Token) o).hasType(this.type);
            }
            return false;
        }
18014#public void merge(Token newToken) {
            this.value = this.value + newToken.getStringValue();
        }
18015#public InputModule getModule() {
            if (value instanceof InputModule) {
                return (InputModule) value;
            }
            return null;
        }
18016#public CoreInitializationException(String message) {
        super(message, null);
    }
18017#public CoreInitializationException(String message, Throwable cause) {
        super(message, cause);
    }
18018#public CoreException(String message) {
        super(message, null);
    }
18019#public CoreException(String message, Throwable cause) {
        super(message, cause);
    }
18020#public CoreResourceNotFoundException(String message) {
        super(message, null);
    }
18021#public CoreResourceNotFoundException(String message, Throwable cause){
        super(message, cause);
    }
18022#public CoreFatalException(String message) {
        super(message, null);
    }
18023#public CoreFatalException(String message, Throwable cause) {
        super(message, cause);
    }
18024#public WiringNotFoundException(String message) {
        super(message);
    }
18025#protected static String createDefinition(String     uriPrefix,
                                             String     sitemapLocation,
                                             List       beanIncludes,
                                             List       propertyIncludes,
                                             Properties props) {
        final StringBuffer buffer = new StringBuffer();
        addHeader(buffer);
        // Child settings for sitemap
        buffer.append("  <configurator:child-settings");
        addAttribute(buffer, "name", sitemapLocation);
        buffer.append(">\n");
        if ( beanIncludes != null ) {
            final Iterator i = beanIncludes.iterator();
            while ( i.hasNext() ) {
                final String dir = (String)i.next();
                buffer.append("    <configurator:include-beans");
                addAttribute(buffer, "dir", dir);
                buffer.append("/>\n");
            }
        }
        if ( propertyIncludes != null ) {
            final Iterator i = propertyIncludes.iterator();
            while ( i.hasNext() ) {
                final String dir = (String)i.next();
                buffer.append("    <configurator:include-properties");
                addAttribute(buffer, "dir", dir);
                buffer.append("/>\n");
            }
        }
        if ( props != null ) {
            final Iterator kI = props.keySet().iterator();
            while ( kI.hasNext() ) {
                final String key = (String)kI.next();
                buffer.append("    <configurator:property");
                addAttribute(buffer, "name", key);
                addAttribute(buffer, "value", props.getProperty(key));
                buffer.append("/>\n");
            }
        }
        buffer.append("  </configurator:child-settings>\n");
        // Avalon
        buffer.append("  <avalon:sitemap");
        addAttribute(buffer, "location", sitemapLocation);
        addAttribute(buffer, "uriPrefix", uriPrefix);
        buffer.append("/>\n");
        addFooter(buffer);

        return buffer.toString();
    }
18026#/**
     * Add the header for the xml configuration file.
     */
    protected static void addHeader(StringBuffer buffer) {
        buffer.append("<beans xmlns=\"http://www.springframework.org/schema/beans\"");
        buffer.append(" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"");
        buffer.append(" xmlns:util=\"http://www.springframework.org/schema/util\"");
        buffer.append(" xmlns:configurator=\"http://cocoon.apache.org/schema/configurator\"");
        buffer.append(" xmlns:avalon=\"http://cocoon.apache.org/schema/avalon\"");
        buffer.append(" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd");
        buffer.append(" http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd");
        buffer.append(" http://cocoon.apache.org/schema/configurator http://cocoon.apache.org/schema/configurator/cocoon-configurator-1.0.xsd");
        buffer.append(" http://cocoon.apache.org/schema/avalon http://cocoon.apache.org/schema/avalon/cocoon-avalon-1.0.xsd\">\n");
    }
18027#/**
     * Add the footer for the xml configuration file.
     */
    protected static void addFooter(StringBuffer buffer) {
        buffer.append("</beans>\n");
    }
18028#/**
     * Append an attribute to the xml stream if it has a value.
     */
    protected static void addAttribute(StringBuffer buffer, String name, String value) {
        if ( value != null ) {
            buffer.append(' ');
            buffer.append(name);
            buffer.append("=\"");
            buffer.append(value);
            buffer.append("\"");
        }
    }
18029#/**
     * Should the default includes be read for this sitemap?
     */
    protected static boolean isUsingDefaultIncludes(Configuration config) {
        return config.getChild("components").getAttributeAsBoolean("use-default-includes", true);
    }
18030#/**
     * Get all includes for bean configurations from the sitemap.
     * @param sitemap
     * @return
     */
    protected static List getBeanIncludes(WebApplicationContext webAppContext,
                                          String                contextUrl,
                                          Configuration         sitemap)
    throws ConfigurationException {
        final List includes = new ArrayList();
        if ( isUsingDefaultIncludes(sitemap) ) {
            final Resource rsrc = webAppContext.getResource(contextUrl + DEFAULT_CHILD_SPRING_CONFIGURATION_LOCATION);
            if ( rsrc.exists() ) {
                includes.add(DEFAULT_CHILD_SPRING_CONFIGURATION_LOCATION);
            }
        }
        final Configuration[] includeConfigs = sitemap.getChild("components").getChildren("include-beans");
        for(int i = 0 ; i < includeConfigs.length; i++ ) {
            final String dir = includeConfigs[i].getAttribute("dir");

            includes.add(dir);
        }
        return includes;
    }
18031#/**
     * Get all includes for properties from the sitemap.
     * @param sitemap
     * @return
     */
    protected static List getPropertiesIncludes(WebApplicationContext webAppContext,
                                                String                contextUrl,
                                                Configuration         sitemap)
    throws ConfigurationException {
        final List includes = new ArrayList();
        if ( isUsingDefaultIncludes(sitemap) ) {
            final Resource rsrc = webAppContext.getResource(contextUrl + DEFAULT_CHILD_PROPERTIES_LOCATION);
            if ( rsrc.exists() ) {
                includes.add(DEFAULT_CHILD_PROPERTIES_LOCATION);
            }
        }
        final Configuration[] includeConfigs = sitemap.getChild("components").getChildren("include-properties");
        for(int i = 0 ; i < includeConfigs.length; i++ ) {
            final String dir = includeConfigs[i].getAttribute("dir");

            includes.add(dir);
        }
        return includes;
    }
18032#/**
     * compatibility with 2.1.x - check for global variables in sitemap
     * TODO - This will be removed in later versions!
     */
    protected static Properties getGlobalSitemapVariables(Configuration sitemap)
    throws ConfigurationException {
        Properties variables = null;
        final Configuration varConfig = sitemap.getChild("pipelines").getChild("component-configurations").getChild("global-variables", false);
        if ( varConfig != null ) {
            Deprecation.logger.warn("The 'component-configurations' section in the sitemap is deprecated. Please check for alternatives.");
            variables = new Properties();
            final Configuration[] variableElements = varConfig.getChildren();
            for(int v=0; v<variableElements.length; v++) {
                variables.setProperty(variableElements[v].getName(), variableElements[v].getValue());
            }
        }
        return variables;
    }
18033#public static Configuration createSitemapConfiguration(Configuration config)
    throws ConfigurationException {
        Configuration componentConfig = config.getChild("components", false);
        Configuration classPathConfig;

        // by default we include configuration files and properties from
        // predefined locations
        final boolean useDefaultIncludes = isUsingDefaultIncludes(config);

        // if we want to add the default includes and have no component section
        // we have to create one!
        if ( componentConfig == null && useDefaultIncludes ) {
            componentConfig = new DefaultConfiguration("components",
                                                       config.getLocation(),
                                                       config.getNamespace(),
                                                       "");
        }

        if ( componentConfig != null ) {
            // before we pass the configuration we have to strip the
            // additional configuration parts, like classpath as these
            // are not configurations for the component container
            final DefaultConfiguration c = new DefaultConfiguration(componentConfig.getName(), 
                                                                    componentConfig.getLocation(),
                                                                    componentConfig.getNamespace(),
                                                                    "");
            c.addAll(componentConfig);
            classPathConfig = c.getChild(CLASSLOADER_CONFIG_NAME, false);
            if ( classPathConfig != null ) {
                c.removeChild(classPathConfig);
            }
            // and now add default includes
            if ( useDefaultIncludes ) {
                DefaultConfiguration includeElement;
                includeElement = new DefaultConfiguration("include", 
                                                          c.getLocation(),
                                                          c.getNamespace(),
                                                          "");
                includeElement.setAttribute("dir", DEFAULT_CONFIG_XCONF);
                includeElement.setAttribute("pattern", "*.xconf");
                includeElement.setAttribute("optional", "true");
                c.addChild(includeElement);
            }
            componentConfig = c;
        }
        return componentConfig;
    }
18034#/**
     * Create the per sitemap container.
     *
     * @param config          The sitemap as a configuration object.
     * @param sitemapLocation The uri of the sitemap
     * @param fam
     * @param servletContext  The servlet context
     * @return
     * @throws Exception
     */
    public static WebApplicationContext createContainer(Configuration  config,
                                                        String         sitemapLocation,
                                                        Monitor        fam,
                                                        ServletContext servletContext)
    throws Exception {
        // let's get the parent container first
        final WebApplicationContext parentContext = WebAppContextUtils.getCurrentWebApplicationContext();
        final ProcessInfoProvider infoProvider = (ProcessInfoProvider) parentContext.getBean(ProcessInfoProvider.ROLE);
        final Request request = ObjectModelHelper.getRequest(infoProvider.getObjectModel());
        // let's determine our context url
        int pos = sitemapLocation.lastIndexOf('/');
        if ( sitemapLocation.lastIndexOf(File.separatorChar) > pos ) {
            pos = sitemapLocation.lastIndexOf(File.separatorChar);
        }
        final String contextUrl = sitemapLocation.substring(0, pos + 1);


        // get classloader
//      TODO rcl            
//        final ClassLoader classloader = createClassLoader(parentContext, config, fam, servletContext, sitemapResolver);
        final ClassLoader classloader = Thread.currentThread().getContextClassLoader();
        
        // create root bean definition
        final String definition = createDefinition(request.getSitemapURIPrefix(),
                                                   sitemapLocation.substring(pos+1),
                                                   getBeanIncludes(parentContext, contextUrl, config),
                                                   getPropertiesIncludes(parentContext, contextUrl, config),
                                                   getGlobalSitemapVariables(config));
        final ChildXmlWebApplicationContext context = new ChildXmlWebApplicationContext(contextUrl,
                                                                                    definition);
        context.setServletContext(servletContext);
        context.setParent(parentContext);
        if ( classloader != null ) {
            context.setClassLoader(classloader);
        }
        context.refresh();
        return context;
    }
18035#/**
     * Replace all properties in the configuration object.
     * @param tree     The configuration.
     * @param settings The settings object to resolve the properties.
     */
    public static Configuration replaceProperties(Configuration tree, Settings settings)
    throws ConfigurationException {
        if (tree == null || settings == null) {
            return tree;
        }

        // first clone the tree
        final DefaultConfiguration root = new DefaultConfiguration(tree, true);
        // now replace properties
        _replaceProperties(root, settings);
        return root;
    }
18036#/**
     * Recursivly replace the properties of a configuration object.
     * @param config   The configuration.
     * @param settings The settings object to resolve the properties.
     * @throws ConfigurationException
     */
    protected static void _replaceProperties(DefaultConfiguration config, Settings settings)
    throws ConfigurationException {
        final String[] names = config.getAttributeNames();
        for (int i = 0; i < names.length; i++) {
            final String value = config.getAttribute(names[i]);
            config.setAttribute(names[i], PropertyHelper.replace(value, settings));
        }

        final String value = config.getValue(null);
        if (value != null) {
            config.setValue(PropertyHelper.replace(value, settings));
        }

        final Configuration[] children = config.getChildren();
        for (int m = 0; m < children.length; m++) {
            _replaceProperties((DefaultConfiguration) children[m], settings);
        }
    }
18037#public void setUriPrefix(String uriPrefix) {
        this.uriPrefix = uriPrefix;
    }
18038#/**
     * @see org.springframework.beans.factory.BeanFactoryAware#setBeanFactory(org.springframework.beans.factory.BeanFactory)
     */
    public void setBeanFactory(BeanFactory factory) throws BeansException {
        this.beanFactory = factory;
    }
18039#/**
     * Create the Avalon context object.
     * @throws Exception
     */
    protected void init()
    throws Exception {
        final BeanFactory parentBeanFactory = ((HierarchicalBeanFactory)this.beanFactory).getParentBeanFactory();
        // create new Avalon context
        final DefaultContext appContext = new DefaultContext((Context)parentBeanFactory.getBean(AvalonUtils.CONTEXT_ROLE));
        appContext.put(Constants.CONTEXT_ENV_PREFIX, this.uriPrefix);

        this.context = appContext;
    }
18040#/**
     * @see org.springframework.beans.factory.FactoryBean#getObject()
     */
    public Object getObject() throws Exception {
        return this.context;
    }
18041#/**
     * @see org.springframework.beans.factory.FactoryBean#getObjectType()
     */
    public Class getObjectType() {
        return Context.class;
    }
18042#/**
     * @see org.springframework.beans.factory.FactoryBean#isSingleton()
     */
    public boolean isSingleton() {
        return true;
    }
18043#/**
     * @see org.springframework.beans.factory.FactoryBean#getObject()
     */
    public Object getObject() throws Exception {
        return this.info;
    }
18044#/**
     * @see org.springframework.beans.factory.FactoryBean#getObjectType()
     */
    public Class getObjectType() {
        return ConfigurationInfo.class;
    }
18045#/**
     * @see org.springframework.beans.factory.FactoryBean#isSingleton()
     */
    public boolean isSingleton() {
        return true;
    }
18046#public ConfigurationInfo getConfigurationInfo() {
        return info;
    }
18047#public void setConfigurationInfo(ConfigurationInfo info) {
        this.info = info;
    }
18048#/**
     * @see org.apache.cocoon.core.container.spring.avalon.BridgeElementParser#createComponents(org.w3c.dom.Element, org.apache.cocoon.core.container.spring.avalon.ConfigurationInfo, org.springframework.beans.factory.support.BeanDefinitionRegistry, org.springframework.beans.factory.support.BeanDefinitionReader, org.springframework.core.io.ResourceLoader)
     */
    public void createComponents(Element element, ConfigurationInfo info,
            BeanDefinitionRegistry registry, BeanDefinitionReader reader,
            ResourceLoader resourceLoader) throws Exception {
        super.createComponents(element, info, registry, reader, resourceLoader);
        // add string template parser for sitemap variable substitution
        final ChildBeanDefinition beanDef = new ChildBeanDefinition("org.apache.cocoon.template.expression.AbstractStringTemplateParser");
        beanDef.setBeanClassName("org.apache.cocoon.components.treeprocessor.variables.LegacySitemapStringTemplateParser");
        beanDef.setSingleton(true);
        beanDef.setLazyInit(false);
        beanDef.getPropertyValues().addPropertyValue("serviceManager", new RuntimeBeanReference("org.apache.avalon.framework.service.ServiceManager"));
        this.register(beanDef, "org.apache.cocoon.el.parsing.StringTemplateParser/legacySitemap", null, registry);

        final RootBeanDefinition resolverDef = new RootBeanDefinition();
        resolverDef.setBeanClassName("org.apache.cocoon.components.treeprocessor.variables.StringTemplateParserVariableResolver");
        resolverDef.setLazyInit(false);
        resolverDef.setScope("prototype");
        resolverDef.getPropertyValues().addPropertyValue("stringTemplateParser", new RuntimeBeanReference("org.apache.cocoon.el.parsing.StringTemplateParser/legacySitemap"));
        resolverDef.getPropertyValues().addPropertyValue("objectModel", new RuntimeBeanReference("org.apache.cocoon.el.objectmodel.ObjectModel"));
        this.register(resolverDef, "org.apache.cocoon.components.treeprocessor.variables.VariableResolver", null, registry);
    }
18049#/**
     * @see BridgeElementParser#addContext(Element, BeanDefinitionRegistry)
     */
    protected void addContext(Element element, BeanDefinitionRegistry registry) {
        // we get the uriPrefix from the configuration
        final String uriPrefix = element.getAttribute("uriPrefix");
        RootBeanDefinition beanDefinition = createBeanDefinition(AvalonSitemapContextFactoryBean.class,
                                                                 "init",
                                                                 false);
        beanDefinition.getPropertyValues().addPropertyValue("uriPrefix", uriPrefix);
        register(beanDefinition, AvalonUtils.CONTEXT_ROLE, registry);
    }
18050#/**
     * Add the logger bean.
     *
     * @param registry       The bean registry.
     * @param loggerCategory The optional category for the logger.
     */
    protected void addLogger(BeanDefinitionRegistry registry,
                             String                 loggerCategory) {
        final RootBeanDefinition beanDef = createBeanDefinition(ChildLoggerFactoryBean.class, "init", false);
        if (loggerCategory != null) {
            beanDef.getPropertyValues().addPropertyValue("category", loggerCategory);
        }
        register(beanDef, LoggerUtils.LOGGER_ROLE, registry);
    }
18051#/**
     * @see BridgeElementParser#readConfiguration(String, ResourceLoader)
     */
    protected ConfigurationInfo readConfiguration(String location, ResourceLoader resourceLoader)
    throws Exception {
        WebApplicationContext parentContext = WebAppContextUtils.getCurrentWebApplicationContext();
        return ConfigurationReader.readSitemap((ConfigurationInfo) parentContext.getBean(ConfigurationInfo.class.getName()),
                                               location,
                                               new SourceResourceLoader(resourceLoader, (SourceResolver) parentContext.getBean(SourceResolver.ROLE)));
    }
18052#protected String getConfigurationLocation() {
        return "config/avalon";
    }
18053#/**
     * @see org.springframework.web.context.ServletContextAware#setServletContext(javax.servlet.ServletContext)
     */
    public void setServletContext(ServletContext sContext) {
        this.servletContext = sContext;
    }
18054#/**
     * Create the Avalon context object.
     * @throws Exception
     */
    protected void init()
    throws Exception {
        if ( this.settings == null ) {
            throw new IllegalArgumentException("Settings object is missing.");
        }
        // create new Avalon context
        final DefaultContext appContext = new ComponentContext();

        // add environment context and config
        appContext.put(Constants.CONTEXT_ENVIRONMENT_CONTEXT, new HttpContext(this.servletContext));

        // add the Avalon context attributes that are contained in the settings
        appContext.put(Constants.CONTEXT_WORK_DIR, new File(this.settings.getWorkDirectory()));
        appContext.put(Constants.CONTEXT_CACHE_DIR, new File(this.settings.getCacheDirectory()));
        appContext.put(Constants.CONTEXT_DEFAULT_ENCODING, this.settings.getFormEncoding());

        this.context = appContext;
    }
18055#/**
     * @see org.springframework.beans.factory.FactoryBean#getObject()
     */
    public Object getObject() throws Exception {
        return this.context;
    }
18056#/**
     * @see org.springframework.beans.factory.FactoryBean#getObjectType()
     */
    public Class getObjectType() {
        return Context.class;
    }
18057#/**
     * @see org.springframework.beans.factory.FactoryBean#isSingleton()
     */
    public boolean isSingleton() {
        return true;
    }
18058#/**
     * Inject the settings object.
     * @param settings The settings.
     */
    public void setSettings(Settings settings) {
        this.settings = settings;
    }
18059#void putBackIntoAvalonPool();
18060#/**
     * This method reads in an Avalon style configuration.
     *
     * @param source         The location of the configuration.
     * @param resourceLoader The resource loader to load included configs.
     * @return               A configuration containing all defined objects.
     * @throws Exception
     */
    public static ConfigurationInfo readConfiguration(String         source,
                                                      ResourceLoader resourceLoader)
    throws Exception {
        final ConfigurationReader converter = new ConfigurationReader(null, resourceLoader);
        converter.convert(source);
        return converter.configInfo;
    }
18061#/**
     * This method reads in an Avalon style sitemap.
     *
     * @param src         The location of the sitemap.
     * @param resourceLoader The resource loader to load included configs.
     * @return               A configuration containing all defined objects.
     * @throws Exception
     */
    public static ConfigurationInfo readSitemap(ConfigurationInfo parentInfo,
                                                String            src,
                                                ResourceLoader    resourceLoader)
    throws Exception {
        String source = src;
        if (source == null || source.trim().length() == 0) {
            source = "sitemap.xmap";
        }

        final ConfigurationReader converter = new ConfigurationReader(parentInfo, resourceLoader);
        converter.convertSitemap(source);
        return converter.configInfo;
    }
18062#public static ConfigurationInfo readConfiguration(Configuration     rolesConfig,
                                                      Configuration     componentConfig)
    throws Exception {
        final ConfigurationReader converter = new ConfigurationReader(null, new DefaultResourceLoader());
        converter.convert(rolesConfig, componentConfig, null);
        return converter.configInfo;
    }
18063#private ConfigurationReader(ConfigurationInfo parentInfo,
                                ResourceLoader    resourceLoader)
    throws Exception {
        if (resourceLoader == null) {
            throw new IllegalArgumentException("ResourceLoader not set!");
        }
        this.isRootContext = parentInfo == null;
        this.resolver = new ServletContextResourcePatternResolver(resourceLoader);

        // now add selectors from parent
        if (parentInfo != null) {
            this.configInfo = new ConfigurationInfo(parentInfo);

            final Iterator i = parentInfo.getComponents().values().iterator();
            while (i.hasNext()) {
                final ComponentInfo current = (ComponentInfo) i.next();
                if (current.isSelector()) {
                    this.configInfo.addRole(current.getRole(), current.copy());
                }
            }

            /* TODO - we should add the processor to each container
                      This would avoid the hacky getting of the current container in the tree processor
            ComponentInfo processorInfo = (ComponentInfo) parentInfo.getComponents().get(Processor.ROLE);
            if (processorInfo != null) {
                this.configInfo.getComponents().put(Processor.ROLE, processorInfo.copy());
            }
            */
        } else {
            this.configInfo = new ConfigurationInfo();
        }
    }
18064#/**
     * Convert an avalon url (with possible cocoon protocols) to a spring url.
     *
     * @param url The avalon url.
     * @return The spring url.
     */
    protected String convertUrl(String url) {
        if (url == null) {
            return null;
        }
        if (url.startsWith("context:")) {
            return url.substring(10);
        }
        if (url.startsWith("resource:")) {
            return "classpath:" + url.substring(10);
        }
        //if (url.indexOf(':') == -1 && !url.startsWith("/")) {
        //    return '/' + url;
        //}
        return url;
    }
18065#/**
     * Copied from {@link ResourceUtils#correctUri(String)}. Comment says:
     * <br><blockquote>
     * If it is a file we have to recreate the url, otherwise we get problems
     * under windows with some file references starting with "/DRIVELETTER" and
     * some just with "DRIVELETTER".
     * </blockquote>
     * @param url to correct
     * @return corrected (or same) url
     */
    protected String correctUrl(String url) {
        if (url.startsWith("file:")) {
            final File f = new File(url.substring(5));
            return "file://" + f.getAbsolutePath();
        }

        return url;
    }
18066#protected String getUrl(Resource rsrc)
    throws IOException {
        if (rsrc instanceof SourceResource) {
            return ((SourceResource) rsrc).getUrlString();
        } else {
            return rsrc.getURL().toExternalForm();
        }
    }
18067#protected String getUrl(String url, String base) {
        if (url == null || base == null) {
            return convertUrl(url);
        }

        if (url.indexOf(":/") < 2) {
            int posSeparator = base.lastIndexOf('/');
            int posFileSeparator = base.lastIndexOf(File.separatorChar);
            if (posFileSeparator > posSeparator) {
                posSeparator = posFileSeparator;
            }
            return convertUrl(base.substring(0, posSeparator + 1) + url);
        }

        return convertUrl(url);
    }
18068#/**
     * Construct input source from given Resource, initialize system Id.
     *
     * @param rsrc Resource for the input source
     * @return Input source
     * @throws Exception if resource URL is not valid or input stream is not available
     */
    protected InputSource getInputSource(Resource rsrc)
    throws IOException {
        final InputSource is = new InputSource(rsrc.getInputStream());
        is.setSystemId(getUrl(rsrc));
        return is;
    }
18069#protected void convert(String relativePath)
    throws Exception {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug("Reading Avalon configuration from " + relativePath);
        }
        Resource root = this.resolver.getResource(getUrl(relativePath, null));
        final DefaultConfigurationBuilder b = new DefaultConfigurationBuilder(true);

        final Configuration config = b.build(this.getInputSource(root));
        // validate cocoon.xconf
        if (!"cocoon".equals(config.getName())) {
            throw new ConfigurationException("Invalid configuration file\n" +
                                             config);
        }

        if (this.logger.isDebugEnabled()) {
            this.logger.debug("Configuration version: " + config.getAttribute("version"));
        }
        if (!Constants.CONF_VERSION.equals(config.getAttribute("version"))) {
            throw new ConfigurationException("Invalid configuration schema version. Must be '" +
                                             Constants.CONF_VERSION + "'.");
        }

        convert(config, null, getUrl(root));
    }
18070#protected void convertSitemap(String sitemapLocation)
    throws Exception {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug("Reading sitemap from " + sitemapLocation);
        }
        final Resource root = this.resolver.getResource(getUrl(sitemapLocation, null));
        if (this.logger.isDebugEnabled()) {
            this.logger.debug("Resolved sitemap: " + root.getURL());
        }
        final DefaultConfigurationBuilder b = new DefaultConfigurationBuilder(true);

        final Configuration config = b.build(getInputSource(root));
        // validate sitemap.xmap
        if (!"sitemap".equals(config.getName())) {
            throw new ConfigurationException("Invalid sitemap\n" +
                                             config);
        }

        final Configuration completeConfig = SitemapHelper.createSitemapConfiguration(config);
        if (completeConfig != null) {
            convert(completeConfig, null, getUrl(root));
        }
    }
18071#protected void convert(Configuration config, Configuration additionalConfig, String rootUri)
    throws Exception {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug("Converting Avalon configuration from configuration object: " + config);
        }

        // It's possible to define a logger on a per sitemap/service manager base.
        // This is the default logger for all components defined with this sitemap/manager.
        this.configInfo.setRootLogger(config.getAttribute("logger", null));

        // and load configuration with a empty list of loaded configurations
        final Set loadedConfigs = new HashSet();
        // what is it?
        if ("role-list".equals(config.getName()) || "roles".equals(config.getName())) {
            configureRoles(config);
        } else {
            parseConfiguration(config, null, loadedConfigs);
        }

        // test for optional user-roles attribute
        if (rootUri != null) {
            final String userRoles = config.getAttribute("user-roles", null);
            if (userRoles != null) {
                if (this.logger.isDebugEnabled()) {
                    this.logger.debug("Reading additional user roles: " + userRoles);
                }
                final Resource userRolesSource = this.resolver.getResource(this.getUrl(userRoles, rootUri));
                final DefaultConfigurationBuilder b = new DefaultConfigurationBuilder(true);
                final Configuration userRolesConfig = b.build(this.getInputSource(userRolesSource));
                parseConfiguration(userRolesConfig, getUrl(userRolesSource), loadedConfigs);
            }
        }
        if (additionalConfig != null) {
            if ("role-list".equals(additionalConfig.getName()) || "roles".equals(additionalConfig.getName())) {
                configureRoles(additionalConfig);
            } else {
                parseConfiguration(additionalConfig, null, loadedConfigs);
            }
        }

        // now process all component configurations
        processComponents();

        // add roles as components
        final Iterator i = this.configInfo.getRoles().iterator();
        while (i.hasNext()) {
            final ComponentInfo current = (ComponentInfo) i.next();
            if (!current.hasConfiguredLazyInit()) {
                current.setLazyInit(true);
            }
            this.configInfo.addComponent(current);
        }
        this.configInfo.clearRoles();
    }
18072#protected void parseConfiguration(final Configuration configuration,
                                      String              contextURI,
                                      Set                 loadedURIs)
    throws ConfigurationException {
        final Configuration[] configurations = configuration.getChildren();

        for( int i = 0; i < configurations.length; i++ ) {
            final Configuration componentConfig = configurations[i];

            final String componentName = componentConfig.getName();

            if ("include".equals(componentName)) {
                handleInclude(contextURI, loadedURIs, componentConfig);
            } else if ("include-beans".equals(componentName)) {
                // we ignore include-beans if this is a child context as this has already been
                // processed by the sitemap element
                if (this.isRootContext) {
                    handleBeanInclude(contextURI, componentConfig);
                }
                // we ignore include-properties if this is a child context
            } else if (this.isRootContext || !"include-properties".equals(componentName)) {
                // Component declaration, add it to list
                componentConfigs.add(componentConfig);
            }
        }
    }
18073#protected void processComponents()
    throws ConfigurationException {
        final Iterator i = this.componentConfigs.iterator();
        while (i.hasNext()) {
            final Configuration componentConfig = (Configuration) i.next();
            final String componentName = componentConfig.getName();

            // Find the role
            String role = componentConfig.getAttribute("role", null);
            String alias = null;
            if (role == null) {
                // Get the role from the role manager if not explicitely specified
                role = (String) this.configInfo.getShorthands().get(componentName);
                alias = componentName;
                if (role == null) {
                    // Unknown role
                    throw new ConfigurationException("Unknown component type '" + componentName +
                                                     "' at " + componentConfig.getLocation());
                }
            }

            // Find the className
            String className = componentConfig.getAttribute("class", null);
            // If it has a "name" attribute, add it to the role (similar to the
            // declaration within a service selector)
            // Note: this has to be done *after* finding the className above as we change the role
            String name = componentConfig.getAttribute("name", null);
            ComponentInfo info;
            if (className == null) {
                // Get the default class name for this role
                info = this.configInfo.getRole(role);
                if (info == null) {
                    if (this.configInfo.getComponents().get(role) != null) {
                        throw new ConfigurationException("Duplicate component definition for role " + role + " at " + componentConfig.getLocation());
                    }
                    throw new ConfigurationException("Cannot find a class for role " + role + " at " + componentConfig.getLocation());
                }

                className = info.getComponentClassName();
                if (name != null) {
                    info = info.copy();
                } else if (!className.endsWith("Selector")) {
                    this.configInfo.removeRole(role);
                }
            } else {
                info = new ComponentInfo();
                if (!className.endsWith("Selector")) {
                    this.configInfo.removeRole(role);
                }
            }

            // check for name attribute
            // Note: this has to be done *after* finding the className above as we change the role
            if (name != null) {
                role = role + "/" + name;
                if (alias != null) {
                    alias = alias + '-' + name;
                }
            }

            info.fill(componentConfig);
            info.setComponentClassName(className);
            info.setRole(role);
            if (alias != null) {
                info.setAlias(alias);
            }
            info.setConfiguration(componentConfig);

            final boolean isSelector = className.endsWith("Selector");
            if (!isSelector && this.configInfo.getComponents().get(role) != null) {
                // we now have a duplicate definition which we explictly allow to make
                // overriding of pre defined components possible
                if (this.logger.isDebugEnabled()) {
                    this.logger.debug("Duplicate component definition for role " + role +
                                      " at " + componentConfig.getLocation() + ". Component " +
                                      "has already been defined at " + ((ComponentInfo) this.configInfo.getComponents().get(role)).getConfiguration().getLocation());
                }
            }

            this.configInfo.addComponent(info);

            // now if this is a selector, then we have to register the single components
            if (info.getConfiguration() != null && className.endsWith("Selector")) {
                String classAttribute = null;
                if (className.equals("org.apache.cocoon.core.container.DefaultServiceSelector")) {
                    classAttribute = "class";
                } else if (className.equals("org.apache.cocoon.components.treeprocessor.sitemap.ComponentsSelector")) {
                    classAttribute = "src";
                }

                if (classAttribute == null) {
                    this.logger.warn("Found unknown selector type (continuing anyway: " + className);
                } else {
                    String componentRole = role;
                    if (componentRole.endsWith("Selector")) {
                        componentRole = componentRole.substring(0, componentRole.length() - 8);
                    }
                    componentRole += '/';
                    Configuration[] children = info.getConfiguration().getChildren();
                    final Map hintConfigs = (Map) this.configInfo.getKeyClassNames().get(role);
                    for (int j = 0; j < children.length; j++) {
                        final Configuration current = children[j];
                        final ComponentInfo childInfo = new ComponentInfo();
                        childInfo.fill(current);
                        childInfo.setConfiguration(current);
                        final ComponentInfo hintInfo = hintConfigs == null ? null
                                                                           : (ComponentInfo) hintConfigs.get(current.getName());
                        if (current.getAttribute(classAttribute, null) != null || hintInfo == null) {
                            childInfo.setComponentClassName(current.getAttribute(classAttribute));
                        } else {
                            childInfo.setComponentClassName(hintInfo.getComponentClassName());
                        }
                        childInfo.setRole(componentRole + current.getAttribute("name"));
                        this.configInfo.addComponent(childInfo);
                    }
                }
            }
        }
    }
18074#/**
     * Handle includes of avalon configurations.
     *
     * @param contextURI
     * @param loadedURIs
     * @param includeStatement
     * @throws ConfigurationException
     */
    protected void handleInclude(final String        contextURI,
                                 final Set           loadedURIs,
                                 final Configuration includeStatement)
    throws ConfigurationException {
        final String includeURI = includeStatement.getAttribute("src", null);
        String directoryURI = null;
        if (includeURI == null) {
            // check for directories
            directoryURI = includeStatement.getAttribute("dir", null);
        }
        if (includeURI == null && directoryURI == null) {
            throw new ConfigurationException("Include statement must either have a 'src' or 'dir' attribute, at " +
                                             includeStatement.getLocation());
        }

        if (includeURI != null) {
            try {
                Resource src = this.resolver.getResource(getUrl(includeURI, contextURI));
                loadURI(src, loadedURIs, includeStatement);
            } catch (Exception e) {
                throw new ConfigurationException("Cannot load '" + includeURI + "' at " +
                                                 includeStatement.getLocation(), e);
            }

        } else {
            boolean load = true;
            // test if directory exists (only if not classpath protocol is used)
            if (!ResourceUtils.isClasspathUri(directoryURI)) {
                Resource dirResource = this.resolver.getResource(this.getUrl(directoryURI, contextURI));
                if (!dirResource.exists()) {
                    if (!includeStatement.getAttributeAsBoolean("optional", false)) {
                        throw new ConfigurationException("Directory '" + directoryURI + "' does not exist (" + includeStatement.getLocation() + ").");
                    }
                    load = false;
                }
            }
            if (load) {
                final String pattern = includeStatement.getAttribute("pattern", null);
                try {
                    Resource[] resources = this.resolver.getResources(this.getUrl(directoryURI + '/' + pattern, contextURI));
                    if (resources != null) {
                        Arrays.sort(resources, ResourceUtils.getResourceComparator());
                        for (int i = 0; i < resources.length; i++) {
                            loadURI(resources[i], loadedURIs, includeStatement);
                        }
                    }
                } catch (Exception e) {
                    throw new ConfigurationException("Cannot load from directory '" + directoryURI + "' at " + includeStatement.getLocation(), e);
                }
            }
        }
    }
18075#protected void loadURI(final Resource      src,
                           final Set           loadedURIs,
                           final Configuration includeStatement)
    throws ConfigurationException, IOException {
        // If already loaded: do nothing
        final String uri = correctUrl(getUrl(src));
        if (!loadedURIs.contains(uri)) {
            if (this.logger.isDebugEnabled()) {
                this.logger.debug("Loading configuration: " + uri);
            }
            // load it and store it in the read set
            Configuration includeConfig;
            try {
                DefaultConfigurationBuilder builder = new DefaultConfigurationBuilder(true);
                includeConfig = builder.build(src.getInputStream(), uri);
            } catch (Exception e) {
                throw new ConfigurationException("Cannot load '" + uri + "' at " + includeStatement.getLocation(), e);
            }
            loadedURIs.add(uri);

            // what is it?
            final String includeKind = includeConfig.getName();
            if (includeKind.equals("components") || includeKind.equals("cocoon")) {
                // more components
                this.parseConfiguration(includeConfig, uri, loadedURIs);
            } else if (includeKind.equals("role-list")) {
                // more roles
                this.configureRoles(includeConfig);
            } else {
                throw new ConfigurationException("Unknow document '" + includeKind + "' included at " +
                                                 includeStatement.getLocation());
            }
        }
    }
18076#/**
     * Handle include for spring bean configurations.
     *
     * @param contextURI
     * @param includeStatement
     * @throws ConfigurationException
     */
    protected void handleBeanInclude(final String contextURI,
                                     final Configuration includeStatement)
    throws ConfigurationException {
        final String includeURI = includeStatement.getAttribute("src", null);
        String directoryURI = null;
        if (includeURI == null) {
            // check for directories
            directoryURI = includeStatement.getAttribute("dir", null);
        }
        if (includeURI == null && directoryURI == null) {
            throw new ConfigurationException(
                    "Include statement must either have a 'src' or 'dir' attribute, at "
                            + includeStatement.getLocation());
        }

        if (includeURI != null) {
            try {
                Resource src = this.resolver.getResource(getUrl(includeURI, contextURI));
                this.configInfo.addImport(getUrl(src));
            } catch (Exception e) {
                throw new ConfigurationException("Cannot load '" + includeURI + "' at " +
                                                 includeStatement.getLocation(), e);
            }

        } else {
            // test if directory exists
            Resource dirResource = this.resolver.getResource(this.getUrl(directoryURI, contextURI));
            if ( dirResource.exists() ) {
                final String pattern = includeStatement.getAttribute("pattern", null);
                try {
                    Resource[] resources = this.resolver.getResources(this.getUrl(directoryURI + '/' + pattern, contextURI));
                    if ( resources != null ) {
                        Arrays.sort(resources, ResourceUtils.getResourceComparator());
                        for(int i=0; i < resources.length; i++) {
                           this.configInfo.addImport(getUrl(resources[i]));
                        }
                    }
                } catch (IOException ioe) {
                    throw new ConfigurationException("Unable to read configurations from "
                            + directoryURI);
                }
            } else {
                if (!includeStatement.getAttributeAsBoolean("optional", false)) {
                    throw new ConfigurationException("Directory '" + directoryURI + "' does not exist (" +
                                                     includeStatement.getLocation() + ").");
                }
            }
        }
    }
18077#/**
     * Reads a configuration object and creates the role, shorthand,
     * and class name mapping.
     *
     * @param configuration  The configuration object.
     * @throws ConfigurationException if the configuration is malformed
     */
    protected final void configureRoles( final Configuration configuration )
    throws ConfigurationException {
        final Configuration[] roles = configuration.getChildren();
        for (int i = 0; i < roles.length; i++) {
            final Configuration role = roles[i];

            if ("alias".equals(role.getName())) {
                final String roleName = role.getAttribute("role");
                final String shorthand = role.getAttribute("shorthand");
                this.configInfo.getShorthands().put(shorthand, roleName);
                continue;
            }
            if (!"role".equals(role.getName())) {
                throw new ConfigurationException("Unexpected '" + role.getName() + "' element at " + role.getLocation());
            }

            final String roleName = role.getAttribute("name");
            final String shorthand = role.getAttribute("shorthand", null);
            final String defaultClassName = role.getAttribute("default-class", null);

            if (shorthand != null) {
                // Store the shorthand and check that its consistent with any previous one
                Object previous = this.configInfo.getShorthands().put(shorthand, roleName);
                if (previous != null && !previous.equals(roleName)) {
                    throw new ConfigurationException("Shorthand '" + shorthand + "' already used for role " +
                                                     previous + ": inconsistent declaration at " + role.getLocation());
                }
            }

            if (defaultClassName != null) {
                ComponentInfo info = this.configInfo.getRole(roleName);
                if (info == null) {
                    // Create a new info and store it
                    info = new ComponentInfo();
                    info.setComponentClassName(defaultClassName);
                    info.fill(role);
                    info.setRole(roleName);
                    info.setConfiguration(role);
                    info.setAlias(shorthand);
                    this.configInfo.addRole(roleName, info);
                } else {
                    // Check that it's consistent with the existing info
                    if (!defaultClassName.equals(info.getComponentClassName())) {
                        throw new ConfigurationException("Invalid redeclaration: default class already set to " + info.getComponentClassName() +
                                                         " for role " + roleName + " at " + role.getLocation());
                    }
                    //FIXME: should check also other ServiceInfo members
                }
            }

            final Configuration[] keys = role.getChildren("hint");
            if (keys.length > 0) {
                Map keyMap = (Map) this.configInfo.getKeyClassNames().get(roleName);
                if (keyMap == null) {
                    keyMap = new HashMap();
                    this.configInfo.getKeyClassNames().put(roleName, keyMap);
                }

                for (int j = 0; j < keys.length; j++) {
                    Configuration key = keys[j];

                    final String shortHand = key.getAttribute("shorthand").trim();
                    final String className = key.getAttribute("class").trim();

                    ComponentInfo info = (ComponentInfo) keyMap.get(shortHand);
                    if (info == null) {
                        info = new ComponentInfo();
                        info.setComponentClassName(className);
                        info.fill(key);
                        info.setConfiguration(key);
                        info.setAlias(shortHand);
                        keyMap.put(shortHand, info);
                    } else {
                        // Check that it's consistent with the existing info
                        if (!className.equals(info.getComponentClassName())) {
                            throw new ConfigurationException("Invalid redeclaration: class already set to " + info.getComponentClassName() +
                                                             " for hint " + shortHand + " at " + key.getLocation());
                        }
                        //FIXME: should check also other ServiceInfo members
                    }
                }
            }
        }
    }
18078#public SourceResourceLoader(ResourceLoader delegate, SourceResolver resolver) {
        this.delegate = delegate;
        this.resolver = resolver;
    }
18079#/**
     * @see org.springframework.core.io.ResourceLoader#getClassLoader()
     */
    public ClassLoader getClassLoader() {
        return this.delegate.getClassLoader();
    }
18080#/**
     * @see org.springframework.core.io.ResourceLoader#getResource(java.lang.String)
     */
    public Resource getResource(String location) {
        if (location != null) {
            // If this is Spring 'classpath:' resource, call delegate before
            // source resolver - it can not handle 'classpath:'.
            if (ResourceUtils.isClasspathUri(location)) {
                return this.delegate.getResource(location);
            }

            // If this is absolute URL with protocol, try source resolver
            if (location.indexOf(':') > 0 || !location.startsWith("/")) {
                try {
                    return new SourceResource(this.resolver.resolveURI(location), this.resolver);
                } catch (IOException e) {
                    // we ignore it and leave it up to the wrapped loader
                }
            }
        }

        // Fallback to delegate
        return this.delegate.getResource(location);
    }
18081#public SourceResource(Source s, SourceResolver r) {
        this.source = s;
        this.resolver =r;
    }
18082#/**
     * @see org.springframework.core.io.InputStreamSource#getInputStream()
     */
    public InputStream getInputStream() throws IOException {
        this.open = true;
        return new SourceIOInputStream(this.resolver, this.source);
    }
18083#/**
     * @see org.springframework.core.io.Resource#createRelative(java.lang.String)
     */
    public Resource createRelative(String uri) throws IOException {
        int pos = this.source.getURI().lastIndexOf('/');
        return new SourceResource(this.resolver.resolveURI(uri, this.source.getURI().substring(0, pos), null), this.resolver);
    }
18084#/**
     * @see org.springframework.core.io.Resource#exists()
     */
    public boolean exists() {
        return this.source.exists();
    }
18085#/**
     * @see org.springframework.core.io.Resource#getDescription()
     */
    public String getDescription() {
        return "Source: " + this.source;
    }
18086#/**
     * @see org.springframework.core.io.Resource#getFile()
     */
    public File getFile() throws IOException {
        return SourceUtil.getFile(this.source);
    }
18087#/**
     * @see org.springframework.core.io.Resource#getFilename()
     */
    public String getFilename() {
        int pos = this.source.getURI().lastIndexOf('/');
        return this.source.getURI().substring(pos + 1);
    }
18088#/**
     * @see org.springframework.core.io.Resource#getURL()
     */
    public URL getURL() throws IOException {
        return new URL(this.source.getURI());
    }
18089#public String getUrlString() {
        return this.source.getURI();
    }
18090#/**
     * @see org.springframework.core.io.Resource#isOpen()
     */
    public boolean isOpen() {
        return this.open;
    }
18091#public URI getURI() throws IOException {
        try {
            return new URI(this.source.getURI());
        } catch (URISyntaxException e) {
            IOException ioe = new IOException("Exception because of the URI syntax.");
            ioe.initCause(e);
            throw ioe;
        }
    }
18092#public SettingsContext(Context parentContext, Settings s) {
        super(parentContext);
        this.settings = s;
    }
18093#public SettingsContext(Settings s) {
        super();
        this.settings = s;
    }
18094#/**
     * @see org.apache.avalon.framework.context.Context#get(java.lang.Object)
     */
    public Object get(Object name) throws ContextException {
        if ( name != null && this.settings != null ) {
            if ( this.settings.getProperty(name.toString()) != null ) {
                return this.settings.getProperty(name.toString());
            }
        }
        return super.get(name);
    }
18095#public PoolableProxyHandler(PoolableFactoryBean handler) {
        this.handler = handler;
        this.attributeName = PoolableProxyHandler.class.getName() + '/' + this.handler.hashCode();
    }
18096#/**
     * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
     */
    public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable {
        if ( method.getName().equals("putBackIntoAvalonPool") ) {
            this.run();
            // attributes might already been destroyed, because this handler might be run
            // for a component that is released by another component insided recycle()
            // which got called by PoolableFactoryBean.enteringPool() <- putIntoPool() <- run() (below),
            // which is registered as destruction callback on the request attributes -
            // such a destruction callback is called *after* the request attributes
            // are set back to null
            final RequestAttributes attributes = RequestContextHolder.getRequestAttributes();
            if (attributes != null) {
                // removing the attribute removes the call back handler!
                attributes.removeAttribute(this.attributeName, RequestAttributes.SCOPE_REQUEST);
            }
            return null;
        }
        if ( method.getName().equals("hashCode") && args == null ) {
            return new Integer(this.hashCode());
        }
        if ( this.componentHolder.get() == null ) {
            this.componentHolder.set(this.handler.getFromPool());
            RequestContextHolder.currentRequestAttributes().registerDestructionCallback(this.attributeName, this, RequestAttributes.SCOPE_REQUEST);
        }
        try {
            return method.invoke(this.componentHolder.get(), args);
        } catch (InvocationTargetException ite) {
            throw ite.getTargetException();
        }
    }
18097#/**
     * @see java.lang.Runnable#run()
     */
    public void run() {
        final Object o = this.componentHolder.get();
        if ( o != null ) {
            this.handler.putIntoPool(o);
        }
        this.componentHolder.set(null);
    }
18098#/**
     * Create a Context with specified parent.
     *
     * @param parent the parent Context (may be null)
     */
    public ComponentContext(final Context parent) {
        super( parent );
    }
18099#/**
     * Create a Context with no parent.
     *
     */
    public ComponentContext() {
        super();
    }
18100#/**
     * Retrieve an item from the Context.
     *
     * @param key the key of item
     * @return the item stored in context
     * @throws ContextException if item not present
     */
    public Object get( final Object key )
    throws ContextException {
        if ( ContextHelper.CONTEXT_OBJECT_MODEL.equals(key)) {
            final Environment env = EnvironmentHelper.getCurrentEnvironment();
            if ( env == null ) {
                throw new ContextException("Unable to locate " + key + " (No environment available)");
            }
            return env.getObjectModel();
        } else if ( ContextHelper.CONTEXT_SITEMAP_SERVICE_MANAGER.equals(key)) {
            final ServiceManager manager = EnvironmentHelper.getSitemapServiceManager();
            if ( manager == null ) {
                throw new ContextException("Unable to locate " + key + " (No environment available)");
            }
            return manager;
        }
        if ( key instanceof String ) {
            String stringKey = (String)key;
            if ( stringKey.startsWith(OBJECT_MODEL_KEY_PREFIX) ) {
                final Environment env = EnvironmentHelper.getCurrentEnvironment();
                if ( env == null ) {
                    throw new ContextException("Unable to locate " + key + " (No environment available)");
                }
                final Map objectModel = env.getObjectModel();
                String objectKey = stringKey.substring(OBJECT_MODEL_KEY_PREFIX.length());

                Object o = objectModel.get( objectKey );
                if ( o == null ) {
                    final String message = "Unable to locate " + key;
                    throw new ContextException( message );
                }
                return o;
            }
        }
        return super.get( key );
    }
18101#/**
     * Create a new info.
     */
    public ComponentInfo() {
        this.model = MODEL_UNKNOWN;
    }
18102#/**
     * @return Returns the model.
     */
    public int getModel() {
        return model;
    }
18103#/**
     * @param model The model to set.
     */
    public void setModel(int model) {
        this.model = model;
    }
18104#/**
     * @return Returns the destroyMethod.
     */
    public String getDestroyMethodName() {
        return destroyMethodName;
    }
18105#/**
     * @param destroyMethod The destroyMethod to set.
     */
    public void setDestroyMethodName(String destroyMethod) {
        this.destroyMethodName = destroyMethod;
    }
18106#/**
     * @return Returns the initMethod.
     */
    public String getInitMethodName() {
        return initMethodName;
    }
18107#/**
     * @param initMethod The initMethod to set.
     */
    public void setInitMethodName(String initMethod) {
        this.initMethodName = initMethod;
    }
18108#/**
     * @return Returns the poolInMethodName
     */
    public String getPoolInMethodName() {
        return this.poolInMethodName;
    }
18109#/**
     * @param poolMethod The poolInMethod name to set.
     */
    public void setPoolInMethodName(String poolMethod) {
        this.poolInMethodName = poolMethod;
    }
18110#/**
     * @return Returns the poolOutMethodName
     */
    public String getPoolOutMethodName() {
        return this.poolOutMethodName;
    }
18111#/**
     * @param poolMethod The poolOutMethod name to set.
     */
    public void setPoolOutMethodName(String poolMethod) {
        this.poolOutMethodName = poolMethod;
    }
18112#/**
     * @return Returns the serviceClassName.
     */
    public String getComponentClassName() {
        return componentClassName;
    }
18113#/**
     * @param serviceClassName The serviceClassName to set.
     */
    public void setComponentClassName(String serviceClassName) {
        this.componentClassName = serviceClassName;
    }
18114#/**
     * @return Returns the configuration.
     */
    public Configuration getConfiguration() {
        return configuration;
    }
18115#/**
     * @param configuration The configuration to set.
     */
    public void setConfiguration(Configuration configuration) {
        this.configuration = configuration;
    }
18116#public String getLocation() {
        return this.configuration.getLocation();
    }
18117#/**
     * @see java.lang.Object#toString()
     */
    public String toString() {
        return "ServiceInfo: {class=" + this.getComponentClassName()+"}";
    }
18118#public void fill(Configuration config) {
        // test model
        final String componentModel = config.getAttribute("model", null);
        if ( TYPE_POOLED.equals(componentModel) ) {
            this.setModel(ComponentInfo.MODEL_POOLED);
            this.setPoolInMethodName(config.getAttribute("pool-in", null));
            this.setPoolOutMethodName(config.getAttribute("pool-out", null));
        } else if (TYPE_NON_THREAD_SAFE_POOLED.equals(componentModel)) {
            this.setModel(ComponentInfo.MODEL_POOLED);
            this.setPoolInMethodName(config.getAttribute("pool-in", null));
            this.setPoolOutMethodName(config.getAttribute("pool-out", null));
        } else if ( TYPE_SINGLETON.equals(componentModel) ) {
            this.setModel(ComponentInfo.MODEL_SINGLETON);
        }
        // init/destroy methods
        this.setInitMethodName(config.getAttribute("init", null));
        this.setDestroyMethodName(config.getAttribute("destroy", null));
        // logging
        this.setLoggerCategory(config.getAttribute("logger", null));
        this.setRole(config.getAttribute("role", null));
        // default value
        final String newDefaultValue = config.getAttribute("default", null);
        if ( newDefaultValue != null ) {
            this.defaultValue = newDefaultValue;
        }
        this.lazyInit = config.getAttributeAsBoolean("lazy-init", this.lazyInit);
    }
18119#/**
     * @return Returns the loggerCategory.
     */
    public String getLoggerCategory() {
        return this.loggerCategory;
    }
18120#/**
     * @param loggerCategory The loggerCategory to set.
     */
    public void setLoggerCategory(String loggerCategory) {
        this.loggerCategory = loggerCategory;
    }
18121#/**
     * @param role The role to set.
     */
    public void setRole( String role ) {
        this.role = role;
    }
18122#/**
     * @return Returns the role.
     */
    public String getRole() {
        return role;
    }
18123#public Parameters getParameters() {
        return parameters;
    }
18124#public void setParameters(Parameters parameters) {
        this.parameters = parameters;
    }
18125#public String getAlias() {
        return alias;
    }
18126#public void setAlias(String alias) {
        this.alias = alias;
    }
18127#/**
     * Is this a selector?
     */
    public boolean isSelector() {
        return this.componentClassName.equals("org.apache.cocoon.core.container.DefaultServiceSelector") ||
               this.componentClassName.equals("org.apache.cocoon.components.treeprocessor.sitemap.ComponentsSelector");
    }
18128#public String getDefaultValue() {
        return defaultValue;
    }
18129#public void setDefaultValue(String defaultValue) {
        this.defaultValue = defaultValue;
    }
18130#/**
     * Create a new component info with the same configuration
     * as the current one.
     * @return An identical component info.
     */
    public ComponentInfo copy() {
        final ComponentInfo info = new ComponentInfo();
        info.model = this.model;
        info.initMethodName = this.initMethodName;
        info.destroyMethodName = this.destroyMethodName;
        info.poolInMethodName = this.poolInMethodName;
        info.poolOutMethodName = this.poolOutMethodName;
        info.componentClassName = this.componentClassName;
        info.configuration = this.configuration;
        info.parameters = this.parameters;
        info.loggerCategory = this.loggerCategory;
        info.role = this.role;
        info.alias = this.alias;
        info.defaultValue = this.defaultValue;
        info.lazyInit = this.lazyInit;
        return info;
    }
18131#public boolean isLazyInit() {
        return lazyInit;
    }
18132#public void setLazyInit(boolean lazyInit) {
        this.lazyInit = lazyInit;
    }
18133#public Configuration getProcessedConfiguration() {
        return processedConfiguration;
    }
18134#public void setProcessedConfiguration(Configuration processedConfiguration) {
        this.processedConfiguration = processedConfiguration;
    }
18135#public boolean hasConfiguredLazyInit() {
        return this.configuration != null && this.configuration.getAttribute("lazy-init", null) != null;
    }
18136#/**
     * Create a PoolableComponentHandler which manages a pool of Components
     * created by the specified factory object.
     *
     * @param name The name of the bean which should be pooled.
     */
    public PoolableFactoryBean( String name, String className )
    throws Exception {
        this(name, className, DEFAULT_MAX_POOL_SIZE, null);
    }
18137#/**
     * Create a PoolableComponentHandler which manages a pool of Components
     * created by the specified factory object.
     *
     * @param name The name of the bean which should be pooled.
     */
    public PoolableFactoryBean( String name, String className, String poolMaxString, Settings settings )
    throws Exception {
        String value = poolMaxString;
        if ( settings != null ) {
            value = PropertyHelper.replace(poolMaxString, settings);
        }
        int poolMax = Integer.valueOf(value).intValue();
        this.name = name;
        this.max = ( poolMax <= 0 ? Integer.MAX_VALUE : poolMax );
        this.beanClass = Class.forName(className);
        final HashSet workInterfaces = new HashSet();

        // Get *all* interfaces
        this.guessWorkInterfaces( this.beanClass, workInterfaces );
        // Add AvalonPoolable
        workInterfaces.add(AvalonPoolable.class);

        this.interfaces = (Class[]) workInterfaces.toArray( new Class[workInterfaces.size()] );

        // Create the pool lists.
        this.ready = new LinkedList();
    }
18138#public void setPoolInMethodName(String poolInMethodName) {
        this.poolInMethodName = poolInMethodName;
    }
18139#public void setPoolOutMethodName(String poolOutMethodName) {
        this.poolOutMethodName = poolOutMethodName;
    }
18140#public void initialize() throws Exception {
        if ( this.poolInMethodName != null ) {
            this.poolInMethod = this.beanClass.getMethod(this.poolInMethodName, null);
        } else {
            this.poolInMethod = null;
        }
        if ( this.poolOutMethodName != null ) {
            this.poolOutMethod = this.beanClass.getMethod(this.poolOutMethodName, null);
        } else {
            this.poolOutMethod = null;
        }
    }
18141#/**
     * Dispose of associated Pools and Factories.
     */
    public void dispose() {
        // Any Poolables in the ready list need to be disposed of
        synchronized( this.semaphore ) {
            // Remove objects in the ready list.
            for( Iterator iter = this.ready.iterator(); iter.hasNext(); ) {
                Object poolable = iter.next();
                iter.remove();
                this.readySize--;
                this.permanentlyRemovePoolable( poolable );
            }
        }
    }
18142#/**
     * Permanently removes a poolable from the pool's active list and
     *  destroys it so that it will not ever be reused.
     * <p>
     * This method is only called by threads that have m_semaphore locked.
     */
    protected void permanentlyRemovePoolable( Object poolable ) {
        this.size--;
    }
18143#/**
     * Gets a Poolable from the pool.  If there is room in the pool, a new Poolable will be
     *  created.  Depending on the parameters to the constructor, the method may block or throw
     *  an exception if a Poolable is not available on the pool.
     *
     * @return Always returns a Poolable.  Contract requires that put must always be called with
     *  the Poolable returned.
     * @throws Exception An exception may be thrown as described above or if there is an exception
     *  thrown by the ObjectFactory's newInstance() method.
     */
    public Object getFromPool() throws Exception {
        Object poolable;
        synchronized( this.semaphore ) {
            // Look for a Poolable at the end of the m_ready list
            if ( this.readySize > 0 ){
                // A poolable is ready and waiting in the pool
                poolable = this.ready.removeLast();
                this.readySize--;
            } else {
                // Create a new poolable.  May throw an exception if the poolable can not be
                //  instantiated.
                poolable = this.beanFactory.getBean(this.name);
                this.size++;
                this.highWaterMark = (this.highWaterMark < this.size ? this.size : this.highWaterMark);
            }
        }

        this.exitingPool(poolable);

        return poolable;
    }
18144#/**
     * Returns a poolable to the pool
     *
     * @param poolable Poolable to return to the pool.
     */
    public void putIntoPool( final Object poolable ) {
        this.enteringPool(poolable);

        synchronized( this.semaphore ) {
            if( this.size <= this.max ) {
                this.ready.addLast( poolable );
                this.readySize++;
            } else {
                // More Poolables were created than can be held in the pool, so remove.
                this.permanentlyRemovePoolable( poolable );
            }
        }
    }
18145#/**
     * Handle service specific methods for getting it out of the pool
     */
    protected void exitingPool( final Object component )
    throws Exception {
        if ( this.poolOutMethod != null ) {
            this.poolOutMethod.invoke(component, null);
        }
    }
18146#/**
     * Handle service specific methods for putting it into the pool
     */
    protected void enteringPool( final Object component ) {
        try {
            // Handle Recyclable objects
            if( component instanceof Recyclable ) {
                ( (Recyclable)component ).recycle();
            }
            if ( this.poolInMethod != null ) {
                this.poolInMethod.invoke(component, null);
            }
        } catch (Exception ignore) {
            // we ignore exceptions during putting the component back
            // into the pool, as this should not bring the system
            // down - this is for compatibility with the original
            // Avalon implementation
            this.log.error("Exception while putting component '" + component + "' back into the pool.", ignore);
        }
    }
18147#/**
     * @see org.springframework.beans.factory.BeanFactoryAware#setBeanFactory(org.springframework.beans.factory.BeanFactory)
     */
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
    }
18148#/**
     * @see org.springframework.beans.factory.FactoryBean#getObject()
     */
    public Object getObject() throws Exception {
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),
                                      this.interfaces,
                                      new PoolableProxyHandler(this));
    }
18149#/**
     * @see org.springframework.beans.factory.FactoryBean#getObjectType()
     */
    public Class getObjectType() {
        return this.beanClass;
    }
18150#/**
     * @see org.springframework.beans.factory.FactoryBean#isSingleton()
     */
    public boolean isSingleton() {
        return false;
    }
18151#/**
     * Get a list of interfaces to proxy by scanning through
     * all interfaces a class implements.
     *
     * @param clazz           the class
     * @param workInterfaces  the set of current work interfaces
     */
    private void guessWorkInterfaces( final Class clazz,
                                      final Set workInterfaces ) {
        if ( null != clazz ) {
            this.addInterfaces( clazz.getInterfaces(), workInterfaces );

            this.guessWorkInterfaces( clazz.getSuperclass(), workInterfaces );
        }
    }
18152#/**
     * Get a list of interfaces to proxy by scanning through
     * all interfaces a class implements.
     *
     * @param classInterfaces      the array of interfaces
     * @param workInterfaces  the set of current work interfaces
     */
    private void addInterfaces( final Class[] classInterfaces,
                                final Set workInterfaces ) {
        for ( int i = 0; i < classInterfaces.length; i++ ) {
            workInterfaces.add( classInterfaces[i] );
            this.addInterfaces(classInterfaces[i].getInterfaces(), workInterfaces);
        }
    }
18153#/**
     * @see org.springframework.beans.factory.BeanFactoryAware#setBeanFactory(org.springframework.beans.factory.BeanFactory)
     */
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
    }
18154#/**
     * @see org.apache.avalon.framework.service.ServiceManager#hasService(java.lang.String)
     */
    public boolean hasService(String role) {
        return this.beanFactory.containsBean(role);
    }
18155#/**
     * @see org.apache.avalon.framework.service.ServiceManager#lookup(java.lang.String)
     */
    public Object lookup(String role) throws ServiceException {
        if ( !this.hasService(role) ) {
            throw new ServiceException("AvalonServiceManager",
                                       "Component with '" + role + "' is not defined in this service manager.");
        }
        try {
            return this.beanFactory.getBean(role);
        } catch (BeansException be) {
            throw new ServiceException("AvalonServiceManager",
                                       "Exception during lookup of component with '" + role + "'.", be);
        }
    }
18156#/**
     * @see org.apache.avalon.framework.service.ServiceManager#release(java.lang.Object)
     */
    public void release(Object component) {
        if ( component instanceof AvalonPoolable ) {
            ((AvalonPoolable)component).putBackIntoAvalonPool();
        }
    }
18157#public AvalonServiceSelector(String r) {
        this.role = r + '/';
    }
18158#/**
     * @see org.springframework.beans.factory.BeanFactoryAware#setBeanFactory(org.springframework.beans.factory.BeanFactory)
     */
    public void setBeanFactory(BeanFactory factory) throws BeansException {
        this.beanFactory = factory;
    }
18159#public void setDefault(String value) {
        this.defaultKey = value;
    }
18160#/**
     * @see org.apache.avalon.framework.service.ServiceSelector#select(java.lang.Object)
     */
    public Object select(Object hint) throws ServiceException {
        Object key = hint;
        if ( key == null || key.toString().length() == 0 ) {
            key = this.defaultKey;
        }
        if ( !this.isSelectable(key) ) {
            throw new ServiceException("AvalonServiceSelector",
                                       "Component with role '" + this.role + "' and key '" + key + "' is not defined in this service selector.");
        }
        try {
            return this.beanFactory.getBean(this.role + key);
        } catch (BeansException be) {
            throw new ServiceException("AvalonServiceSelector",
                                       "Exception during lookup of component with role '" + this.role + "' and key '" + key + "'.", be);
        }
    }
18161#/**
     * @see org.apache.avalon.framework.service.ServiceSelector#isSelectable(java.lang.Object)
     */
    public boolean isSelectable(Object key) {
        return this.beanFactory.containsBean(this.role + key);
    }
18162#/**
     * @see org.apache.avalon.framework.service.ServiceSelector#release(java.lang.Object)
     */
    public void release(Object component) {
        if ( component instanceof AvalonPoolable ) {
            ((AvalonPoolable)component).putBackIntoAvalonPool();
        }
    }
18163#/**
     * @see java.lang.Object#toString()
     */
    public String toString() {
        return "AvalonServiceSelector[" + super.toString() + "]: role=" + this.role + ", factory=" + this.beanFactory;
    }
18164#/**
     * @see org.springframework.beans.factory.xml.NamespaceHandler#init()
     */
    public void init() {
        registerBeanDefinitionParser("bridge", new BridgeElementParser());
        registerBeanDefinitionParser("sitemap", new SitemapElementParser());
    }
18165#/**
     * @see org.springframework.beans.factory.xml.BeanDefinitionParser#parse(Element, ParserContext)
     */
    public BeanDefinition parse(Element element, ParserContext parserContext) {
        final ResourceLoader resourceLoader = parserContext.getReaderContext().getReader().getResourceLoader();

        // read avalon style configuration - it's optional for this element.
        // the schema for the sitemap element ensures that location is never null.
        final String location = getAttributeValue(element, "location", DEFAULT_COCOON_XCONF_LOCATION);
        try {
            final ConfigurationInfo info = readConfiguration(location, resourceLoader);

            createComponents(element,
                             info,
                             parserContext.getRegistry(),
                             parserContext.getDelegate().getReaderContext().getReader(),
                             resourceLoader);
        } catch (Exception e) {
            throw new BeanDefinitionStoreException("Unable to read Avalon configuration from '" + location + "'.",e);
        }

        return null;
    }
18166#/**
     * 
     * @param element        Can be null.
     * @param info           ConfigurationInfo.
     * @param registry       BeanDefinitionRegistry.
     * @param reader         Can be null.
     * @param resourceLoader ResourceLoader.
     * @throws Exception from called components.
     */
    public void createComponents(Element                element,
                                 ConfigurationInfo      info,
                                 BeanDefinitionRegistry registry,
                                 BeanDefinitionReader   reader,
                                 ResourceLoader         resourceLoader)
    throws Exception {
        // add context
        addContext(element, registry);

        // add service manager
        addComponent(AvalonServiceManager.class,
                     AvalonUtils.SERVICE_MANAGER_ROLE,
                     null,
                     false,
                     registry);

        // add logger
        addLogger(registry, info.getRootLogger());

        // handle includes of spring configurations
        final Iterator includeIter = info.getImports().iterator();
        while ( includeIter.hasNext() ) {
            if ( reader == null ) {
                throw new Exception("Import of spring configuration files not supported. (Reader is null)");
            }
            final String uri = (String)includeIter.next();
            reader.loadBeanDefinitions(resourceLoader.getResource(uri));
        }

        // then create components
        this.createConfig(info, registry);

        // register component infos for child factories
        this.registerComponentInfo(info, registry);

        // and finally add avalon bean post processor
        final RootBeanDefinition beanDef = createBeanDefinition(AvalonBeanPostProcessor.class, "init", true);
        beanDef.getPropertyValues().addPropertyValue("context", new RuntimeBeanReference(AvalonUtils.CONTEXT_ROLE));
        beanDef.getPropertyValues().addPropertyValue("configurationInfo", new RuntimeBeanReference(ConfigurationInfo.class.getName()));
        beanDef.getPropertyValues().addPropertyValue("resourceLoader", resourceLoader);
        beanDef.getPropertyValues().addPropertyValue("location", this.getConfigurationLocation());
        this.register(beanDef, AvalonBeanPostProcessor.class.getName(), registry);

        final RootBeanDefinition resolverDef = new RootBeanDefinition();
        resolverDef.setBeanClassName("org.apache.cocoon.components.treeprocessor.variables.PreparedVariableResolver");
        resolverDef.setLazyInit(false);
        resolverDef.setScope("prototype");
        resolverDef.getPropertyValues().addPropertyValue("manager", new RuntimeBeanReference("org.apache.avalon.framework.service.ServiceManager"));
        this.register(resolverDef, "org.apache.cocoon.components.treeprocessor.variables.VariableResolver", null, registry);
    }
18167#protected ConfigurationInfo readConfiguration(String location, ResourceLoader resourceLoader)
    throws Exception {
        return ConfigurationReader.readConfiguration(location, resourceLoader);
    }
18168#protected void addContext(Element element, BeanDefinitionRegistry registry) {
        this.addComponent(AvalonContextFactoryBean.class,
                AvalonUtils.CONTEXT_ROLE,
                "init",
                true,
                registry);        
    }
18169#/**
     * Add the logger bean.
     *
     * @param registry       The bean registry.
     * @param loggerCategory The optional category for the logger.
     */
    protected void addLogger(BeanDefinitionRegistry registry,
                             String                 loggerCategory) {
        final RootBeanDefinition beanDef = createBeanDefinition(LoggerFactoryBean.class, "init", false);
        if (loggerCategory != null) {
            beanDef.getPropertyValues().addPropertyValue("category", loggerCategory);
        }

        register(beanDef, LoggerUtils.LOGGER_ROLE, registry);
    }
18170#public void createConfig(ConfigurationInfo      info,
                             BeanDefinitionRegistry registry) 
    throws Exception {
        final Map components = info.getComponents();
        final List pooledRoles = new ArrayList();

        // Iterate over all definitions
        final Iterator i = components.entrySet().iterator();
        while ( i.hasNext() ) {
            final Map.Entry entry = (Map.Entry)i.next();
            final ComponentInfo current = (ComponentInfo)entry.getValue();
            final String role = current.getRole();
    
            String className = current.getComponentClassName();
            boolean isSelector = false;
            boolean singleton = true;
            boolean poolable = false;
            // Test for Selector - we just create a wrapper for them to flatten the hierarchy
            if ( current.isSelector() ) {
                // Add selector
                className = AvalonServiceSelector.class.getName();
                isSelector = true;
            } else {
                // test for unknown model
                if ( current.getModel() == ComponentInfo.MODEL_UNKNOWN ) {
                    try {
                        final Class serviceClass = Class.forName(className);
                        if ( ThreadSafe.class.isAssignableFrom(serviceClass) ) {
                            current.setModel(ComponentInfo.MODEL_SINGLETON);
                        } else if ( Poolable.class.isAssignableFrom(serviceClass) ) {
                            current.setModel(ComponentInfo.MODEL_POOLED);
                        } else {
                            current.setModel(ComponentInfo.MODEL_PRIMITIVE);
                        }
                    } catch (NoClassDefFoundError ncdfe) {
                        throw new ConfigurationException("Unable to create class for component with role " + current.getRole() + " with class: " + className, ncdfe);
                    } catch (ClassNotFoundException cnfe) {
                        throw new ConfigurationException("Unable to create class for component with role " + current.getRole() + " with class: " + className, cnfe);
                    }
                }
                if ( current.getModel() == ComponentInfo.MODEL_POOLED ) {
                    poolable = true;
                    singleton = false;
                } else if ( current.getModel() != ComponentInfo.MODEL_SINGLETON ) {
                    singleton = false;
                }
            }
            final String beanName;
            if ( !poolable ) {
                beanName = role;
            } else {
                beanName = role + "Pooled";                
            }
            final RootBeanDefinition beanDef = new RootBeanDefinition();
            beanDef.setBeanClassName(className);      
            if ( current.getInitMethodName() != null ) {
                beanDef.setInitMethodName(current.getInitMethodName());
            }
            if ( current.getDestroyMethodName() != null ) {
                beanDef.setDestroyMethodName(current.getDestroyMethodName());
            }
            beanDef.setSingleton(singleton);
            beanDef.setLazyInit(singleton && current.isLazyInit());
            if ( isSelector ) {
                beanDef.getConstructorArgumentValues().addGenericArgumentValue(role.substring(0, role.length()-8), "java.lang.String");
                if ( current.getDefaultValue() != null ) {
                    beanDef.getPropertyValues().addPropertyValue("default", current.getDefaultValue());
                }
            }
            this.register(beanDef, beanName, current.getAlias(), registry);

            if ( poolable ) {
                // add the factory for poolables
                final RootBeanDefinition poolableBeanDef = new RootBeanDefinition();
                poolableBeanDef.setBeanClass(PoolableFactoryBean.class);
                poolableBeanDef.setSingleton(true);
                poolableBeanDef.setLazyInit(false);
                poolableBeanDef.setInitMethodName("initialize");
                poolableBeanDef.setDestroyMethodName("dispose");
                poolableBeanDef.getConstructorArgumentValues().addIndexedArgumentValue(0, beanName, "java.lang.String");
                poolableBeanDef.getConstructorArgumentValues().addIndexedArgumentValue(1, className, "java.lang.String");
                if ( current.getConfiguration() != null ) {
                    // we treat poolMax as a string to allow property replacements
                    final String poolMax = current.getConfiguration().getAttribute("pool-max", null);
                    if ( poolMax != null ) {
                        poolableBeanDef.getConstructorArgumentValues().addIndexedArgumentValue(2, poolMax);
                        poolableBeanDef.getConstructorArgumentValues().addIndexedArgumentValue(3, new RuntimeBeanReference(Settings.ROLE));
                    }
                }
                if ( current.getPoolInMethodName() != null ) {
                    poolableBeanDef.getPropertyValues().addPropertyValue("poolInMethodName", current.getPoolInMethodName());
                }
                if ( current.getPoolOutMethodName() != null ) {
                    poolableBeanDef.getPropertyValues().addPropertyValue("poolOutMethodName", current.getPoolOutMethodName());
                }
                this.register(poolableBeanDef, role, registry);
                pooledRoles.add(role);
            }
        }

        // now change roles for pooled components (from {role} to {role}Pooled
        final Iterator prI = pooledRoles.iterator();
        while ( prI.hasNext() ) {
            final String role = (String)prI.next();
            final Object pooledInfo = components.remove(role);
            components.put(role + "Pooled", pooledInfo);
        }
    }
18171#protected void registerComponentInfo(ConfigurationInfo      configInfo,
                                         BeanDefinitionRegistry registry) {
        PipelineComponentInfo info = new PipelineComponentInfo(null);
        final Iterator i = configInfo.getComponents().values().iterator();
        while (i.hasNext()) {
            final ComponentInfo current = (ComponentInfo) i.next();
            info.componentAdded(current.getRole(), current.getComponentClassName(), current.getConfiguration());
        }
        prepareSelector(info, configInfo, Generator.ROLE);
        prepareSelector(info, configInfo, Transformer.ROLE);
        prepareSelector(info, configInfo, Serializer.ROLE);
        prepareSelector(info, configInfo, ProcessingPipeline.ROLE);
        prepareSelector(info, configInfo, Action.ROLE);
        prepareSelector(info, configInfo, Selector.ROLE);
        prepareSelector(info, configInfo, Matcher.ROLE);
        prepareSelector(info, configInfo, Reader.ROLE);
        info.lock();
        if (!registry.containsBeanDefinition(PipelineComponentInfo.ROLE)) {
            final RootBeanDefinition beanDef = new RootBeanDefinition();
            beanDef.setBeanClass(PipelineComponentInfoFactoryBean.class);
            beanDef.setSingleton(true);
            beanDef.setLazyInit(false);
            beanDef.setInitMethodName("init");
            this.register(beanDef, PipelineComponentInfo.ROLE, registry);
        }
        BeanDefinitionBuilder initDefBuilder =
            BeanDefinitionBuilder.rootBeanDefinition(PipelineComponentInfoInitializer.class);
        initDefBuilder.addPropertyReference("info", PipelineComponentInfo.ROLE);
        initDefBuilder.setSingleton(true);
        initDefBuilder.setLazyInit(false);
        initDefBuilder.setInitMethodName("init");
        initDefBuilder.addPropertyValue("data", info.getData());
        final String beanName = this.getClass().getName() + "/init";
        this.register(initDefBuilder.getBeanDefinition(), beanName, registry);

        final RootBeanDefinition ciBeanDef = new RootBeanDefinition();
        ciBeanDef.setBeanClass(ConfigurationInfoFactoryBean.class);
        ciBeanDef.setSingleton(true);
        ciBeanDef.setLazyInit(false);
        ciBeanDef.getPropertyValues().addPropertyValue("configurationInfo", configInfo);
        this.register(ciBeanDef, ConfigurationInfo.class.getName(), registry);
    }
18172#protected static void prepareSelector(PipelineComponentInfo info,
                                          ConfigurationInfo configInfo,
                                          String category) {
        final ComponentInfo component = (ComponentInfo) configInfo.getComponents().get(category + "Selector");
        if (component != null) {
            info.setDefaultType(category, component.getDefaultValue());
        }
    }
18173#protected String getConfigurationLocation() {
        return "WEB-INF/cocoon/xconf";
    }
18174#public void setSettings(Settings settings) {
        this.settings = settings;
    }
18175#public void setResourceLoader(final ResourceLoader loader) {
        this.resourceLoader = loader;
    }
18176#public void setLocation(final String value) {
        this.location = value;
    }
18177#/**
     * @see org.springframework.beans.factory.BeanFactoryAware#setBeanFactory(org.springframework.beans.factory.BeanFactory)
     */
    public void setBeanFactory(BeanFactory factory) throws BeansException {
        this.beanFactory = factory;
    }
18178#public void setConfigurationInfo(ConfigurationInfo configurationInfo) {
        this.configurationInfo = configurationInfo;
    }
18179#public void setContext(Context context) {
        this.context = context;
    }
18180#public void init() {
        if (true) {
            return;
        }

        // replace properties in configuration objects
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Processing component configurations.");
            getLogger().debug("Trying to read properties from directory: " + this.location);
        }
        final Properties mergedProps = new Properties();
        final ServletContextResourcePatternResolver resolver = new ServletContextResourcePatternResolver(resourceLoader);
        // final Resource dirResource = resourceLoader.getResource(this.location);

        try {
            Resource[] resources = resolver.getResources(this.location + "/*.properties");
            if (resources != null) {
                Arrays.sort(resources, ResourceUtils.getResourceComparator());
                for (int i = 0; i < resources.length; i++) {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("Reading property file: " + resources[i]);
                    }
                    final Properties p = new Properties();
                    p.load(resources[i].getInputStream());
                    mergedProps.putAll(p);
                }
            }
        } catch (IOException ioe) {
            throw new BeanDefinitionStoreException("Unable to read property configurations from " + this.location, ioe);
        }
        
        if (mergedProps.size() > 0) {
            final Iterator i = this.configurationInfo.getComponents().values().iterator();
            while (i.hasNext()) {
                final ComponentInfo info = (ComponentInfo) i.next();
                if (info.getConfiguration() != null) {
                    final List names = this.getKeys(mergedProps, info.getRole());
                    if (info.getAlias() != null) {
                        names.addAll(this.getKeys(mergedProps, info.getAlias()));
                    }
                    final Iterator namesIter = names.iterator();
                    while (namesIter.hasNext()) {
                        final String name = (String) namesIter.next();
                        final String value = mergedProps.getProperty(name);
                        String propName;
                        if (name.startsWith(info.getRole())) {
                            propName = name.substring(info.getRole().length() + 1);
                        } else {
                            propName = name.substring(info.getAlias().length() + 1);
                        }
                        Configuration config = info.getConfiguration();
                        int pos;
                        do {
                            pos = propName.indexOf('.');
                            if (pos != -1) {
                                config = this.getAndCreateConfiguration(config, propName.substring(0, pos));
                                propName = propName.substring(pos + 1);
                            }
                        } while (pos != -1);
                        if (propName.startsWith("@")) {
                            ((DefaultConfiguration) config).setAttribute(propName.substring(1), value);
                        } else {
                            config = this.getAndCreateConfiguration(config, propName);
                            ((DefaultConfiguration) config).setValue(value);
                        }
                    }
                }
            }
        }
    }
18181#protected List getKeys(Properties mergedProps, String role) {
        final String prefix = role + '/';
        final List l = new ArrayList();
        final Iterator i = mergedProps.keySet().iterator();
        while (i.hasNext()) {
            final String key = (String) i.next();
            if (key.startsWith(prefix)) {
                l.add(key);
            }
        }
        return l;
    }
18182#protected Configuration getAndCreateConfiguration(Configuration config, String name) {
        if (config.getChild(name, false) == null) {
            final DefaultConfiguration newConfig = new DefaultConfiguration(name, config.getLocation());
            ((DefaultConfiguration) config).addChild(newConfig);
        }
        return config.getChild(name, false);
    }
18183#/**
     * @see org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization(Object, String)
     */
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        try {
            ContainerUtil.start(bean);
        } catch (Exception e) {
            throw new BeanInitializationException("Unable to start bean " + beanName, e);
        }
        return bean;
    }
18184#/**
     * @see org.springframework.beans.factory.config.BeanPostProcessor#postProcessBeforeInitialization(Object, String)
     */
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        final ComponentInfo info = (ComponentInfo) this.configurationInfo.getComponents().get(beanName);
        try {
            if (info == null) {
                // no info so we just return the bean and don't apply any
                // lifecycle interfaces
                return bean;
            }

            if (bean instanceof LogEnabled) {
                ContainerUtil.enableLogging(bean,
                                            new CLLoggerWrapper(LoggerUtils.getChildLogger(beanFactory, info.getLoggerCategory())));
            } else if (bean instanceof AbstractLogEnabled && info.getLoggerCategory() != null) {
                ((AbstractLogEnabled) bean).setLogger(LoggerUtils.getChildLogger(beanFactory, info.getLoggerCategory()));
            }

            ContainerUtil.contextualize(bean, this.context);
            ContainerUtil.service(bean, (ServiceManager) this.beanFactory.getBean(ServiceManager.class.getName()));

            Configuration config = info.getProcessedConfiguration();
            if (config == null) {
                config = info.getConfiguration();
                if (config == null) {
                    config = EMPTY_CONFIG;
                } else {
                    config = AvalonUtils.replaceProperties(config, this.settings);
                }
                info.setProcessedConfiguration(config);
            }

            if (bean instanceof Configurable) {
                ContainerUtil.configure(bean, config);
            } else if (bean instanceof Parameterizable) {
                Parameters p = info.getParameters();
                if (p == null) {
                    p = Parameters.fromConfiguration(config);
                    info.setParameters(p);
                }
                ContainerUtil.parameterize(bean, p);
            }

            ContainerUtil.initialize(bean);
        } catch (Exception e) {
            throw new BeanCreationException("Unable to initialize Avalon component with role " + beanName, e);
        }

        return bean;
    }
18185#/**
     * @see DestructionAwareBeanPostProcessor#postProcessBeforeDestruction(Object, String)
     */
    public void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {
        try {
            ContainerUtil.stop(bean);
        } catch (Exception e) {
            throw new BeanInitializationException("Unable to stop bean " + beanName, e);
        }
        ContainerUtil.dispose(bean);
    }
18186#public SourceIOInputStream(SourceResolver resolver, Source source) throws IOException {
        this.source = source;
        this.delegate = source.getInputStream();
        this.resolver = resolver;
    }
18187#/**
     * @see java.io.InputStream#available()
     */
    public int available() throws IOException {
        this.check();
        return this.delegate.available();
    }
18188#/**
     * @see java.io.InputStream#close()
     */
    public void close() throws IOException {
        if ( !this.closed ) {
            this.closed = true;
            IOException e = null;
            try {
                this.delegate.close();
            } catch (IOException i) {
                e = i;
            } finally {
                this.resolver.release(this.source);
            }
            if ( e != null ) {
                throw e;
            }
        }
    }
18189#/**
     * @see java.io.InputStream#mark(int)
     */
    public void mark(int arg0) {
        this.delegate.mark(arg0);
    }
18190#/**
     * @see java.io.InputStream#markSupported()
     */
    public boolean markSupported() {
        return this.delegate.markSupported();
    }
18191#/**
     * @see java.io.InputStream#read()
     */
    public int read() throws IOException {
        this.check();
        return this.delegate.read();
    }
18192#/**
     * @see java.io.InputStream#read(byte[], int, int)
     */
    public int read(byte[] arg0, int arg1, int arg2) throws IOException {
        this.check();
        return this.delegate.read(arg0, arg1, arg2);
    }
18193#/**
     * @see java.io.InputStream#read(byte[])
     */
    public int read(byte[] arg0) throws IOException {
        this.check();
        return this.delegate.read(arg0);
    }
18194#/**
     * @see java.io.InputStream#reset()
     */
    public void reset() throws IOException {
        this.check();
        this.delegate.reset();
    }
18195#/**
     * @see java.io.InputStream#skip(long)
     */
    public long skip(long arg0) throws IOException {
        this.check();
        return this.delegate.skip(arg0);
    }
18196#protected void check() throws IOException {
        if ( this.closed ) {
            throw new IOException("Input stream has already been closed.");
        }
    }
18197#public ConfigurationInfo() {
        this.shorthands = new HashMap();
        this.currentRoles = new HashMap();
        this.keyClassNames = new HashMap();
        this.allRoles = new HashMap();
    }
18198#public ConfigurationInfo(ConfigurationInfo parent) {
        this.shorthands = new HashMap(parent.shorthands);
        this.currentRoles = new HashMap();
        this.keyClassNames = new HashMap(parent.keyClassNames);
        this.allRoles = new HashMap(parent.allRoles);
    }
18199#public Map getComponents() {
        return components;
    }
18200#public String getRootLogger() {
        return rootLogger;
    }
18201#public void setRootLogger(String rootLogger) {
        this.rootLogger = rootLogger;
    }
18202#public void addComponent(ComponentInfo info) {
        this.components.put(info.getRole(), info);
    }
18203#public Collection getRoles() {
        return this.currentRoles.values();
    }
18204#public void addRole(String role, ComponentInfo info) {
        this.currentRoles.put(role, info);
        this.allRoles.put(role, info);
    }
18205#public ComponentInfo getRole(String role) {
        ComponentInfo info = (ComponentInfo) this.currentRoles.get(role);
        if (info == null ) {
            info = (ComponentInfo) this.allRoles.get(role);
        }
        return info;
    }
18206#public void removeRole(String role) {
        this.currentRoles.remove(role);
    }
18207#public void clearRoles() {
        this.currentRoles.clear();
    }
18208#public Map getShorthands() {
        return this.shorthands;
    }
18209#public Map getKeyClassNames() {
        return this.keyClassNames;
    }
18210#public void addImport(String uri) {
        this.imports.add(uri);
    }
18211#public List getImports() {
        return this.imports;
    }
18212#public String getRoleForName(String alias) {
        final String value = (String) this.shorthands.get(alias);
        if (value != null) {
            return value;
        }
        return alias;
    }
18213#public ChildLoggerFactoryBean() {
        // Child logger has no default category: uses parent's category.
        setCategory(null);
    }
18214#/**
     * @see BeanFactoryAware#setBeanFactory(BeanFactory)
     */
    public void setBeanFactory(BeanFactory factory) throws BeansException {
        this.factory = factory;
    }
18215#public void init() {
        final BeanFactory parent = ((HierarchicalBeanFactory) this.factory).getParentBeanFactory();

        // Construct full category
        final LoggerFactoryBean bean = (LoggerFactoryBean) parent.getBean("&" + LoggerUtils.LOGGER_ROLE);
        setCategory(LoggerUtils.getChildCategory(bean, getCategory()));

        // Initialize logger
        setLogger(LogFactory.getLog(getCategory()));
    }
18216#/**
     * @see FactoryBean#getObject()
     */
    public Object getObject() throws Exception {
        final BeanFactory parent = ((HierarchicalBeanFactory) this.factory).getParentBeanFactory();
        return LoggerUtils.getChildLogger(parent, getCategory());
    }
18217#/**
     * @see org.springframework.beans.factory.FactoryBean#getObjectType()
     */
    public Class getObjectType() {
        return Log.class;
    }
18218#/**
     * @see org.springframework.beans.factory.FactoryBean#isSingleton()
     */
    public boolean isSingleton() {
        return true;
    }
18219#/**
     * Create a child logger based on the logger configured in the Spring bean factory.
     *
     * @param factory Current Spring bean factory
     * @param category Desired logger sub category
     * @return Logger for the child category of current bean factory configured logger.
     */
    public static Log getChildLogger(BeanFactory factory, String category) {
        LoggerFactoryBean parent = (LoggerFactoryBean) factory.getBean("&" + LoggerUtils.LOGGER_ROLE);
        return getChildLogger(parent, category);
    }
18220#/**
     * @deprecated 
     */
    public static Log getChildLogger(ServiceManager manager, String category) throws ServiceException {
        LoggerFactoryBean parent = (LoggerFactoryBean) manager.lookup("&" + LoggerUtils.LOGGER_ROLE);
        return getChildLogger(parent, category);
    }
18221#private static Log getChildLogger(LoggerFactoryBean parent, String category) {
        return LogFactory.getLog(getChildCategory(parent, category));
    }
18222#static String getChildCategory(LoggerFactoryBean parent, String category) {
        if (category != null && category.length() > 0) {
            return parent.getCategory() + "." + category;
        }

        return parent.getCategory();
    }
18223#public String getCategory() {
        return this.category;
    }
18224#public void setCategory(String category) {
        this.category = category;
    }
18225#protected void setLogger(Log logger) {
        this.logger = logger;
    }
18226#public void init() {
        setLogger(LogFactory.getLog(this.category));
    }
18227#/**
     * @see FactoryBean#getObject()
     */
    public Object getObject() throws Exception {
        return this.logger;
    }
18228#/**
     * @see FactoryBean#getObjectType()
     */
    public Class getObjectType() {
        return Log.class;
    }
18229#/**
     * @see FactoryBean#isSingleton()
     */
    public boolean isSingleton() {
        return true;
    }
18230#public void setResolver(org.xml.sax.EntityResolver resolver) {
        this.resolver = resolver;
    }
18231#public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {
        return this.resolver.resolveEntity(publicId, systemId);
    }
18232#public void setParser(org.apache.cocoon.core.xml.DOMParser parser) {
        this.parser = parser;
    }
18233#/**
     * @see org.apache.excalibur.xml.dom.DOMParser#createDocument()
     */
    public Document createDocument() throws SAXException {
        return this.parser.createDocument();
    }
18234#/**
     * @see org.apache.excalibur.xml.dom.DOMParser#parseDocument(org.xml.sax.InputSource)
     */
    public Document parseDocument(InputSource arg0) throws SAXException, IOException {
        return this.parser.parseDocument(arg0);
    }
18235#public void setParser(org.apache.cocoon.core.xml.SAXParser parser) {
        this.parser = parser;
    }
18236#/**
     * @see org.apache.excalibur.xml.sax.SAXParser#parse(org.xml.sax.InputSource, org.xml.sax.ContentHandler, org.xml.sax.ext.LexicalHandler)
     */
    public void parse(InputSource arg0, ContentHandler arg1, LexicalHandler arg2) throws SAXException, IOException {
        this.parser.parse(arg0, arg1, arg2);
    }
18237#/**
     * @see org.apache.excalibur.xml.sax.SAXParser#parse(org.xml.sax.InputSource, org.xml.sax.ContentHandler)
     */
    public void parse(InputSource arg0, ContentHandler arg1) throws SAXException, IOException {
        this.parser.parse(arg0, arg1);
    }
18238#public UnableToPushEnvironmentException(String message) {
        super(message, null);
    }
18239#public UnableToPushEnvironmentException(String message, Throwable cause) {
        super(message, cause);
    }
18240#EnvironmentInfo getCurrentInfo() {
        return (EnvironmentInfo)this.get(offset);
    }
18241#void pushInfo(EnvironmentInfo info) {
        this.push(info);
    }
18242#EnvironmentInfo popInfo() {
        return (EnvironmentInfo)this.pop();
    }
18243#EnvironmentInfo peekInfo() {
        return (EnvironmentInfo)this.peek();
    }
18244#int getOffset() {
        return this.offset;
    }
18245#void setOffset(int value) {
        this.offset = value;  
    }
18246#public Object clone() {
        EnvironmentStack old = (EnvironmentStack) super.clone();
        old.offset = offset;
        return old;
    }
18247#XMLConsumer getEnvironmentAwareConsumerWrapper(XMLConsumer consumer, 
                                                   int oldOffset) {
        return new EnvironmentChanger(consumer, this, oldOffset, this.offset);
    }
18248#EnvironmentChanger(XMLConsumer consumer, EnvironmentStack es,
                       int oldOffset, int newOffset) {
        this.consumer = consumer;
        this.stack = es;
        this.oldOffset = oldOffset;
        this.newOffset = newOffset;
    }
18249#public void setDocumentLocator(Locator locator) {
        this.stack.setOffset(this.oldOffset);
        this.consumer.setDocumentLocator(locator);
        this.stack.setOffset(this.newOffset);
    }
18250#public void startDocument()
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.startDocument();
        this.stack.setOffset(this.newOffset);
    }
18251#public void endDocument()
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.endDocument();
        this.stack.setOffset(this.newOffset);
    }
18252#public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.startPrefixMapping(prefix, uri);
        this.stack.setOffset(this.newOffset);
    }
18253#public void endPrefixMapping(String prefix)
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.endPrefixMapping(prefix);
        this.stack.setOffset(this.newOffset);
    }
18254#public void startElement(String uri, String loc, String raw, Attributes a)
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.startElement(uri, loc, raw, a);
        this.stack.setOffset(this.newOffset);
    }
18255#public void endElement(String uri, String loc, String raw)
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.endElement(uri, loc, raw);
        this.stack.setOffset(this.newOffset);
    }
18256#public void characters(char c[], int start, int len)
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.characters(c, start, len);
        this.stack.setOffset(this.newOffset);
    }
18257#public void ignorableWhitespace(char c[], int start, int len)
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.ignorableWhitespace(c, start, len);
        this.stack.setOffset(this.newOffset);
    }
18258#public void processingInstruction(String target, String data)
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.processingInstruction(target, data);
        this.stack.setOffset(this.newOffset);
    }
18259#public void skippedEntity(String name)
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.skippedEntity(name);
        this.stack.setOffset(this.newOffset);
    }
18260#public void startDTD(String name, String publicId, String systemId)
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.startDTD(name, publicId, systemId);
        this.stack.setOffset(this.newOffset);
    }
18261#public void endDTD()
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.endDTD();
        this.stack.setOffset(this.newOffset);
    }
18262#public void startEntity(String name)
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.startEntity(name);
        this.stack.setOffset(this.newOffset);
    }
18263#public void endEntity(String name)
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.endEntity(name);
        this.stack.setOffset(this.newOffset);
    }
18264#public void startCDATA()
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.startCDATA();
        this.stack.setOffset(this.newOffset);
    }
18265#public void endCDATA()
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.endCDATA();
        this.stack.setOffset(this.newOffset);
    }
18266#public void comment(char ch[], int start, int len)
    throws SAXException {
        this.stack.setOffset(this.oldOffset);
        this.consumer.comment(ch, start, len);
        this.stack.setOffset(this.newOffset);
    }
18267#PushEnvironmentChanger(XMLConsumer consumer, Environment environment) {
        this.consumer = consumer;
        this.environment = environment;
    }
18268#private void enterEnvironment() throws SAXException {
        try {
            EnvironmentHelper.enterEnvironment(this.environment);
        } catch (ProcessingException e) {
            throw new SAXException("PushEnvironmentChanger: ", e);
        }
    }
18269#private void leaveEnvironment() {
        EnvironmentHelper.leaveEnvironment();
    }
18270#public void setDocumentLocator(Locator locator) {
        try {
            enterEnvironment();
        } catch (SAXException e) {
            throw new UnableToPushEnvironmentException("Unable to push the environment", e);
        }
        this.consumer.setDocumentLocator(locator);
        leaveEnvironment();
    }
18271#public void startDocument()
    throws SAXException {
        enterEnvironment();
        this.consumer.startDocument();
        leaveEnvironment();
    }
18272#public void endDocument()
    throws SAXException {
        enterEnvironment();
        this.consumer.endDocument();
        leaveEnvironment();
    }
18273#public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
        enterEnvironment();
        this.consumer.startPrefixMapping(prefix, uri);
        leaveEnvironment();
    }
18274#public void endPrefixMapping(String prefix)
    throws SAXException {
        enterEnvironment();
        this.consumer.endPrefixMapping(prefix);
        leaveEnvironment();
    }
18275#public void startElement(String uri, String loc, String raw, Attributes a)
    throws SAXException {
        enterEnvironment();
        this.consumer.startElement(uri, loc, raw, a);
        leaveEnvironment();
    }
18276#public void endElement(String uri, String loc, String raw)
    throws SAXException {
        enterEnvironment();
        this.consumer.endElement(uri, loc, raw);
        leaveEnvironment();
    }
18277#public void characters(char c[], int start, int len)
    throws SAXException {
        enterEnvironment();
        this.consumer.characters(c, start, len);
        leaveEnvironment();
    }
18278#public void ignorableWhitespace(char c[], int start, int len)
    throws SAXException {
        enterEnvironment();
        this.consumer.ignorableWhitespace(c, start, len);
        leaveEnvironment();
    }
18279#public void processingInstruction(String target, String data)
    throws SAXException {
        enterEnvironment();
        this.consumer.processingInstruction(target, data);
        leaveEnvironment();
    }
18280#public void skippedEntity(String name)
    throws SAXException {
        enterEnvironment();
        this.consumer.skippedEntity(name);
        leaveEnvironment();
    }
18281#public void startDTD(String name, String publicId, String systemId)
    throws SAXException {
        enterEnvironment();
        this.consumer.startDTD(name, publicId, systemId);
        leaveEnvironment();
    }
18282#public void endDTD()
    throws SAXException {
        enterEnvironment();
        this.consumer.endDTD();
        leaveEnvironment();
    }
18283#public void startEntity(String name)
    throws SAXException {
        enterEnvironment();
        this.consumer.startEntity(name);
        leaveEnvironment();
    }
18284#public void endEntity(String name)
    throws SAXException {
        enterEnvironment();
        this.consumer.endEntity(name);
        leaveEnvironment();
    }
18285#public void startCDATA()
    throws SAXException {
        enterEnvironment();
        this.consumer.startCDATA();
        leaveEnvironment();
    }
18286#public void endCDATA()
    throws SAXException {
        enterEnvironment();
        this.consumer.endCDATA();
        leaveEnvironment();
    }
18287#public void comment(char ch[], int start, int len)
    throws SAXException {
        enterEnvironment();
        this.consumer.comment(ch, start, len);
        leaveEnvironment();
    }
18288#public EnvironmentInfo(Processor   processor, 
                           int         oldStackCount,
                           Environment environment) {
        this.processor = processor;
        this.oldStackCount = oldStackCount;
        this.environment = environment;
    }
18289#public ForwardEnvironmentWrapper(Environment env,
                                     SitemapSourceInfo info) {
        super(env, info, false);
    }
18290#/**
     * @see org.apache.cocoon.environment.Environment#setStatus(int)
     */
    public void setStatus(int statusCode) {
        environment.setStatus(statusCode);
    }
18291#/**
     * @see org.apache.cocoon.environment.Environment#setContentLength(int)
     */
    public void setContentLength(int length) {
        environment.setContentLength(length);
    }
18292#/**
     * @see org.apache.cocoon.environment.Environment#setContentType(java.lang.String)
     */
    public void setContentType(String contentType) {
        environment.setContentType(contentType);
    }
18293#/**
     * @see org.apache.cocoon.environment.Environment#getContentType()
     */
    public String getContentType() {
        return environment.getContentType();
    }
18294#/**
     * @see org.apache.cocoon.environment.Environment#isResponseModified(long)
     */
    public boolean isResponseModified(long lastModified) {
        return environment.isResponseModified(lastModified);
    }
18295#/**
     * @see org.apache.cocoon.environment.Environment#setResponseIsNotModified()
     */
    public void setResponseIsNotModified() {
        environment.setResponseIsNotModified();
    }
18296#/**
     * Constructor
     *
     */
    public EnvironmentHelper(URL context) {
        if (context != null) {
            this.context = context.toExternalForm();
        }
    }
18297#/**
     * Constructor
     *
     */
    public EnvironmentHelper(EnvironmentHelper parent) {
        this.context = parent.context;
        this.lastPrefix = parent.lastPrefix;
        this.prefix = parent.prefix;
    }
18298#/**
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager avalonManager) throws ServiceException {
        this.manager = avalonManager;
        this.resolver = (org.apache.excalibur.source.SourceResolver)
                          this.manager.lookup(org.apache.excalibur.source.SourceResolver.ROLE);
        Source source = null;
        try {
            source = this.resolver.resolveURI(this.context);
            this.context = source.getURI();

        } catch (IOException ioe) {
            throw new ServiceException("EnvironmentHelper", "Unable to resolve environment context. ", ioe);
        } finally {
            this.resolver.release(source);
        }
    }
18299#/**
     * @see org.apache.avalon.framework.activity.Disposable#dispose()
     */
    public void dispose() {
        if ( this.manager != null ) {
            this.manager.release( this.resolver );
            this.resolver = null;
            this.manager = null;
        }
    }
18300#/**
     * @see org.apache.excalibur.source.SourceResolver#release(org.apache.excalibur.source.Source)
     */
    public void release(Source source) {
        this.resolver.release(source);
    }
18301#/**
     * @see SourceResolver#resolveURI(java.lang.String, java.lang.String, java.util.Map)
     */
    public Source resolveURI(final String location,
                             String baseURI,
                             final Map    parameters)
    throws IOException {
        return this.resolver.resolveURI(location,
                                        (baseURI == null ? this.context : baseURI),
                                        parameters);
    }
18302#/**
     * @see org.apache.excalibur.source.SourceResolver#resolveURI(java.lang.String)
     */
    public Source resolveURI(final String location) throws IOException {
        return this.resolveURI(location, null, null);
    }
18303#/**
     * Return the current context URI
     */
    public String getContext() {
        return this.context;
    }
18304#/**
     * Return the prefix
     */
    public String getPrefix() {
        return this.prefix;
    }
18305#/**
     * Change the context of the environment.
     * @param env The environment to change
     * @throws ProcessingException
     */
    public void changeContext(Environment env)
    throws ProcessingException {
        if (this.lastPrefix != null) {
            final String uri = env.getURI();
            if (!uri.startsWith(this.lastPrefix)) {
                throw new ProcessingException("The current URI (" + uri +
                                              ") doesn't start with given prefix (" + this.lastPrefix + ")");
            }
            // we don't need to check for slash at the beginning
            // of uri - the prefix always ends with a slash!
            final int l = this.lastPrefix.length();
            env.setURI(this.prefix, uri.substring(l));
        }
    }
18306#/**
     * Adds an prefix to the overall stripped off prefix from the request uri
     */
    public void changeContext(Source newSource, String newPrefix)
    throws IOException {
        final String newContext = newSource.getURI();
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Changing Cocoon context");
            getLogger().debug("  from context(" + this.context + ") and prefix(" + this.prefix + ")");
            getLogger().debug("  to context(" + newContext + ") and prefix(" + newPrefix + ")");
        }
        int l = newPrefix.length();
        if (l >= 1) {
            this.lastPrefix = newPrefix;
            if ( this.prefix == null ) {
                this.prefix = "";
            }
            final StringBuffer buffer = new StringBuffer(this.prefix);
            buffer.append(newPrefix);
            // check for a slash at the beginning to avoid problems with subsitemaps
            if ( buffer.charAt(buffer.length()-1) != '/') {
                buffer.append('/');
                this.lastPrefix = this.lastPrefix + '/';
            }
            this.prefix = buffer.toString();
        } else {
            this.lastPrefix = null;
        }

        if (SourceUtil.getScheme(this.context).equals("zip")) {
            // if the resource is zipped into a war file (e.g. Weblogic temp deployment)
            // FIXME (VG): Is this still required? Better to unify both cases.
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Base context is zip: " + this.context);
            }

            org.apache.excalibur.source.Source source = null;
            try {
                source = this.resolver.resolveURI(this.context + newContext);
                this.context = source.getURI();
            } finally {
                this.resolver.release(source);
            }
        } else {
            String sContext;
            // if we got a absolute context or one with a protocol resolve it
            if (newContext.charAt(0) == '/') {
                // context starts with the '/' - absolute file URL
                sContext = "file:" + newContext;
            } else if (newContext.indexOf(':') > 1) {
                // context have ':' - absolute URL
                sContext = newContext;
            } else {
                // context is relative to old one
                sContext = this.context + '/' + newContext;
            }

            // Cut the file name part from context (if present)
            int i = sContext.lastIndexOf('/');
            if (i != -1 && i + 1 < sContext.length()) {
                sContext = sContext.substring(0, i + 1);
            }

            Source source = null;
            try {
                source = this.resolver.resolveURI(sContext);
                this.context = source.getURI();
            } finally {
                this.resolver.release(source);
            }
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("New context is " + this.context);
        }
    }
18307#/**
     * This hook must be called by the sitemap each time a sitemap is entered.
     *
     * <p>This method should never raise an exception, except when the
     * parameters are not set!</p>
     *
     * @throws ProcessingException if processor is null
     */
    public static void enterProcessor(Processor   processor,
                                      Environment env)
    throws ProcessingException {
        if (null == processor) {
            throw new ProcessingException("Processor is not set.");
        }
        EnvironmentStack stack = (EnvironmentStack) environmentStack.get();
        if (stack == null) {
            stack = new EnvironmentStack();
            environmentStack.set(stack);
        }
        stack.pushInfo(new EnvironmentInfo(processor, stack.getOffset(), env));
        stack.setOffset(stack.size() - 1);
    }
18308#/**
     * This hook must be called by the sitemap each time a sitemap is left.
     *
     * <p>It's the counterpart to the {@link #enterProcessor(Processor, Environment)}
     * method.</p>
     */
    public static void leaveProcessor() {
        final EnvironmentStack stack = (EnvironmentStack) environmentStack.get();
        final EnvironmentInfo info = (EnvironmentInfo) stack.pop();
        stack.setOffset(info.oldStackCount);
    }
18309#/**
     * This method is used for entering a new environment.
     *
     * @throws ProcessingException if there is no current processing environment
     */
    public static void enterEnvironment(Environment env)
    throws ProcessingException {
        final EnvironmentStack stack = (EnvironmentStack) environmentStack.get();
        EnvironmentInfo info;
        if (stack != null && !stack.isEmpty()) {
            info = stack.getCurrentInfo();
        } else {
            throw new ProcessingException("There must be a current processing environment.");
        }

        stack.pushInfo(new EnvironmentInfo(info.processor, stack.getOffset(), env));
        stack.setOffset(stack.size() - 1);
    }
18310#/**
     * This method is used for leaving the current environment.
     * 
     * <p>It's the counterpart to the {@link #enterEnvironment(Environment)} method.</p>
     */
    public static Environment leaveEnvironment() {
        final EnvironmentStack stack = (EnvironmentStack) environmentStack.get();
        final EnvironmentInfo info = (EnvironmentInfo) stack.pop();
        stack.setOffset(info.oldStackCount);
        return info.environment;
    }
18311#/**
     * INTERNAL METHOD. Do not use, can be removed without warning or deprecation cycle.
     */
    public static int markEnvironment() {
        // TODO (CZ): This is only for testing - remove it later on. See also Cocoon.java.
        final EnvironmentStack stack = (EnvironmentStack) environmentStack.get();
        if (stack != null) {
            return stack.size();
        }

        return 0;
    }
18312#/**
     * INTERNAL METHOD. Do not use this, can be removed without warning or deprecation cycle.
     */
    public static void checkEnvironment(int depth)
    throws Exception {
        // TODO (CZ): This is only for testing - remove it later on. See also Cocoon.java.
        final EnvironmentStack stack = (EnvironmentStack) environmentStack.get();
        int currentDepth = stack != null ? stack.size() : 0;
        if (currentDepth != depth) {
            logger.error("ENVIRONMENT STACK HAS NOT BEEN CLEANED PROPERLY!");
            throw new ProcessingException("Environment stack has not been cleaned up properly. " +
                                          "Please report this (and if possible, together with a test case) " +
                                          "to the Cocoon developers.");
        }
    }
18313#/**
     * Return the environment.
     * INTERNAL METHOD. Do not use this, can be removed without warning or deprecation cycle.
     */
    public static Environment getCurrentEnvironment() {
        final EnvironmentStack stack = (EnvironmentStack) environmentStack.get();
        if (stack != null && !stack.empty()) {
            final EnvironmentInfo info = stack.getCurrentInfo();
            return info.environment;
        }
        return null;
    }
18314#/**
     * Return the current processor
     * INTERNAL METHOD. Do not use this, can be removed without warning or deprecation cycle.
     */
    public static Processor getCurrentProcessor() {
        final EnvironmentStack stack = (EnvironmentStack) environmentStack.get();
        if (stack != null && !stack.isEmpty()) {
            final EnvironmentInfo info = stack.getCurrentInfo();
            return info.processor;
        }
        return null;
    }
18315#/**
     * Get the current sitemap component manager.
     * This method return the current sitemap component manager. This
     * is the manager that holds all the components of the currently
     * processed (sub)sitemap.
     * INTERNAL METHOD. Do not use this, can be removed without warning or deprecation cycle.
     */
    static public ServiceManager getSitemapServiceManager() {
        final EnvironmentStack stack = (EnvironmentStack) environmentStack.get();
        if (stack != null && !stack.isEmpty()) {
            return (ServiceManager) WebAppContextUtils.getCurrentWebApplicationContext().getBean(AvalonUtils.SERVICE_MANAGER_ROLE);
        }
        return null;
    }
18316#/**
     * Create an environment aware xml consumer for the cocoon
     * protocol.
     * INTERNAL METHOD. Do not use this, can be removed without warning or deprecation cycle.
     */
    public static XMLConsumer createEnvironmentAwareConsumer(XMLConsumer consumer) {
        final EnvironmentStack stack = (EnvironmentStack)environmentStack.get();
        final EnvironmentInfo info = stack.getCurrentInfo();
        return stack.getEnvironmentAwareConsumerWrapper(consumer, info.oldStackCount);
    }
18317#/**
     * Create an environment aware xml consumer that push an
     * environment before calling the consumer.
     */
    public static XMLConsumer createPushEnvironmentConsumer(XMLConsumer consumer, Environment environment) {
        return new PushEnvironmentChanger(consumer, environment);
    }
18318#/**
     * Create an environment aware xml consumer that pop and save the
     * current environment before calling the consumer.
     */
    public static XMLConsumer createPopEnvironmentConsumer(XMLConsumer consumer) {
        return new PopEnvironmentChanger(consumer);
    }
18319#public AbstractCocoonRunnable() {
            // Clone the environment stack of the calling thread.
            // We'll use it in run() below
            Object stack = EnvironmentHelper.environmentStack.get();
            if (stack != null) {
                this.parentStack = ((EnvironmentStack)stack).clone();
            }
        }
18320#/**
         * Calls {@link #doRun()} within the environment context of the creating thread.
         */
        public final void run() {
            // Install the stack from the parent thread and run the Runnable
            Object oldStack = environmentStack.get();
            EnvironmentHelper.environmentStack.set(this.parentStack);
            try {
                doRun();
            } finally {
                // Restore the previous stack
                EnvironmentHelper.environmentStack.set(oldStack);
            }
            // FIXME: Check the lifetime of this run compared to the parent thread.
            // A CocoonThread is meant to start and die within the execution period of the parent request,
            // and it is an error if it lives longer as the parent environment is no more valid.
        }
18321#abstract protected void doRun();
18322#public UnableToPopEnvironmentException(String message) {
        super(message, null);
    }
18323#public UnableToPopEnvironmentException(String message, Throwable cause) {
        super(message, cause);
    }
18324#PopEnvironmentChanger(XMLConsumer consumer) {
        this.consumer = consumer;
    }
18325#private Environment leaveEnvironment() {
        return EnvironmentHelper.leaveEnvironment();
    }
18326#private void enterEnvironment(Environment environment) throws SAXException {
        try {
            EnvironmentHelper.enterEnvironment(environment);
        } catch (ProcessingException e) {
            throw new SAXException("Unable to enter the environment: " + environment, e);
        }
    }
18327#public void setDocumentLocator(Locator locator) {
        Environment environment = leaveEnvironment();
        this.consumer.setDocumentLocator(locator);
        try {
            enterEnvironment(environment);
        } catch (SAXException e) {
            throw new UnableToPopEnvironmentException("Unable to re-enter the environment: " + environment, e);
        }
    }
18328#public void startDocument()
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.startDocument();
        enterEnvironment(environment);
    }
18329#public void endDocument()
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.endDocument();
        enterEnvironment(environment);
    }
18330#public void startPrefixMapping(String prefix, String uri)
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.startPrefixMapping(prefix, uri);
        enterEnvironment(environment);
    }
18331#public void endPrefixMapping(String prefix)
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.endPrefixMapping(prefix);
        enterEnvironment(environment);
    }
18332#public void startElement(String uri, String loc, String raw, Attributes a)
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.startElement(uri, loc, raw, a);
        enterEnvironment(environment);
    }
18333#public void endElement(String uri, String loc, String raw)
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.endElement(uri, loc, raw);
        enterEnvironment(environment);
    }
18334#public void characters(char c[], int start, int len)
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.characters(c, start, len);
        enterEnvironment(environment);
    }
18335#public void ignorableWhitespace(char c[], int start, int len)
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.ignorableWhitespace(c, start, len);
        enterEnvironment(environment);
    }
18336#public void processingInstruction(String target, String data)
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.processingInstruction(target, data);
        enterEnvironment(environment);
    }
18337#public void skippedEntity(String name)
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.skippedEntity(name);
        enterEnvironment(environment);
    }
18338#public void startDTD(String name, String publicId, String systemId)
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.startDTD(name, publicId, systemId);
        enterEnvironment(environment);
    }
18339#public void endDTD()
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.endDTD();
        enterEnvironment(environment);
    }
18340#public void startEntity(String name)
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.startEntity(name);
        enterEnvironment(environment);
    }
18341#public void endEntity(String name)
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.endEntity(name);
        enterEnvironment(environment);
    }
18342#public void startCDATA()
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.startCDATA();
        enterEnvironment(environment);
    }
18343#public void endCDATA()
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.endCDATA();
        enterEnvironment(environment);
    }
18344#public void comment(char ch[], int start, int len)
    throws SAXException {
        Environment environment = leaveEnvironment();
        this.consumer.comment(ch, start, len);
        enterEnvironment(environment);
    }
18345#public EnvironmentHelperException(String message) {
        super(message, null);
    }
18346#public EnvironmentHelperException(String message, Throwable cause) {
        super(message, cause);
    }
18347#public MutableEnvironmentFacade(EnvironmentWrapper env) {
        this.env = env;
        // Ensure we start with a false passthrough flag.
        // FIXME: this should really be part of the Processor contract rather
        // than an environment attribute
        env.setAttribute(MountNode.COCOON_PASS_THROUGH, Boolean.FALSE);
    }
18348#public EnvironmentWrapper getDelegate() {
        return this.env;
    }
18349#public void setDelegate(EnvironmentWrapper env) {
        this.env = env;
    }
18350#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#setURI(java.lang.String, java.lang.String)
     */
    public void setURI(String prefix, String uri) {
        this.env.setURI(prefix, uri);
    }
18351#public void setOutputStream(OutputStream os) {
        this.env.setOutputStream(os);
    }
18352#// Move this to the Environment interface ?
    public String getRedirectURL() {
        return this.env.getRedirectURL();
    }
18353#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getURI()
     */
    public String getURI() {
        return env.getURI();
    }
18354#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getURIPrefix()
     */
    public String getURIPrefix() {
        return env.getURIPrefix();
    }
18355#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getView()
     */
    public String getView() {
        return env.getView();
    }
18356#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getAction()
     */
    public String getAction() {
        return env.getAction();
    }
18357#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#redirect(String, boolean, boolean)
     */
    public void redirect(String url,
                         boolean global,
                         boolean permanent) throws IOException {
        env.redirect(url, global, permanent);
    }
18358#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#setContentType(String)
     */
    public void setContentType(String mimeType) {
        env.setContentType(mimeType);
    }
18359#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getContentType()
     */
    public String getContentType() {
        return env.getContentType();
    }
18360#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#setContentLength(int)
     */
    public void setContentLength(int length) {
        env.setContentLength(length);
    }
18361#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#setStatus(int)
     */
    public void setStatus(int statusCode) {
        env.setStatus(statusCode);
    }
18362#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getOutputStream(int)
     */
    public OutputStream getOutputStream(int bufferSize) throws IOException {
        return env.getOutputStream(bufferSize);
    }
18363#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getObjectModel()
     */
    public Map getObjectModel() {
        return env.getObjectModel();
    }
18364#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#isResponseModified(long)
     */
    public boolean isResponseModified(long lastModified) {
        return env.isResponseModified(lastModified);
    }
18365#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#setResponseIsNotModified()
     */
    public void setResponseIsNotModified() {
        env.setResponseIsNotModified();
    }
18366#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#setAttribute(String, Object)
     */
    public void setAttribute(String name, Object value) {
        env.setAttribute(name, value);
    }
18367#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getAttribute(java.lang.String)
     */
    public Object getAttribute(String name) {
        return env.getAttribute(name);
    }
18368#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#removeAttribute(java.lang.String)
     */
    public void removeAttribute(String name) {
        env.removeAttribute(name);
    }
18369#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#getAttributeNames()
     */
    public Enumeration getAttributeNames() {
        return env.getAttributeNames();
    }
18370#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#tryResetResponse()
     */
    public boolean tryResetResponse() throws IOException {
        return env.tryResetResponse();
    }
18371#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#commitResponse()
     */
    public void commitResponse() throws IOException {
        env.commitResponse();
    }
18372#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#startingProcessing()
     */
    public void startingProcessing() {
        env.startingProcessing();
    }
18373#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#finishingProcessing()
     */
    public void finishingProcessing() {
        env.finishingProcessing();
    }
18374#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#isExternal()
     */
    public boolean isExternal() {
        return env.isExternal();
    }
18375#public void reset() {
        this.env.reset();
    }
18376#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Environment#isInternRedirect()
     */
    public boolean isInternalRedirect() {
        return env.isInternalRedirect();
    }
18377#/**
     * Constructor
     * @param request The Request being wrapped.
     */
    public AbstractRequestWrapper(Request request) {
        this.req = request;
    }
18378#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#get(java.lang.String)
     */
    public Object get(String name) {
        return this.req.get(name);
    }
18379#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getAttribute(java.lang.String)
     */
    public Object getAttribute(String name) {
        return this.req.getAttribute(name);
    }
18380#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getAttributeNames()
     */
    public Enumeration getAttributeNames() {
        return this.req.getAttributeNames();
    }
18381#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getLocalAttribute(java.lang.String)
     */
    public Object getLocalAttribute(String name) {
        return this.requestAttributes.get( name );
    }
18382#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getLocalAttributeNames()
     */
    public Enumeration getLocalAttributeNames() {
        return IteratorUtils.asEnumeration(this.requestAttributes.keySet().iterator());
    }
18383#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#removeLocalAttribute(java.lang.String)
     */
    public void removeLocalAttribute(String name) {
        this.requestAttributes.remove( name );
    }
18384#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#setLocalAttribute(java.lang.String, java.lang.Object)
     */
    public void setLocalAttribute(String name, Object o) {
        this.requestAttributes.put( name, o );
    }
18385#/**
     * @see org.apache.cocoon.environment.Request#searchAttribute(java.lang.String)
     */
    public Object searchAttribute(String name) {
        Object result = this.getLocalAttribute(name);
        if ( result == null ) {
            result = this.getAttribute(name);
            if ( result == null ) {
                result = this.req.getLocalAttribute(name);
            }
        }
        return result;
    }
18386#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getCharacterEncoding()
     */
    public String getCharacterEncoding() {
        return this.req.getCharacterEncoding();
    }
18387#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#setCharacterEncoding(java.lang.String)
     */
    public void setCharacterEncoding(String enc)
    throws java.io.UnsupportedEncodingException {
        this.req.setCharacterEncoding(enc);
    }
18388#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getContentLength()
     */
    public int getContentLength() {
        return this.req.getContentLength();
    }
18389#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getContentType()
     */
    public String getContentType() {
        return this.req.getContentType();
    }
18390#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getParameter(java.lang.String)
     */
    public String getParameter(String name) {
        return this.req.getParameter(name);
    }
18391#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getParameterNames()
     */
    public Enumeration getParameterNames() {
        return this.req.getParameterNames();
    }
18392#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getParameterValues(java.lang.String)
     */
    public String[] getParameterValues(String name) {
        return this.req.getParameterValues(name);
    }
18393#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getProtocol()
     */
    public String getProtocol() {
        return this.req.getProtocol();
    }
18394#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getScheme()
     */
    public String getScheme() {
        return this.req.getScheme();
    }
18395#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getServerName()
     */
    public String getServerName() {
        return this.req.getServerName();
    }
18396#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getServerPort()
     */
    public int getServerPort() {
        return this.req.getServerPort();
    }
18397#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getRemoteAddr()
     */
    public String getRemoteAddr() {
        return this.req.getRemoteAddr();
    }
18398#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getRemoteHost()
     */
    public String getRemoteHost() {
        return this.req.getRemoteHost();
    }
18399#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#setAttribute(java.lang.String, java.lang.Object)
     */
    public void setAttribute(String name, Object o) {
        this.req.setAttribute(name, o);
    }
18400#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#removeAttribute(java.lang.String)
     */
    public void removeAttribute(String name) {
        this.req.removeAttribute(name);
    }
18401#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getLocale()
     */
    public Locale getLocale() {
        return this.req.getLocale();
    }
18402#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getLocales()
     */
    public Enumeration getLocales() {
        return this.req.getLocales();
    }
18403#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#isSecure()
     */
    public boolean isSecure() {
        return this.req.isSecure();
    }
18404#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getCookies()
     */
    public javax.servlet.http.Cookie[] getCookies() {
        return this.req.getCookies();
    }
18405#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getCookieMap()
     */
    public Map getCookieMap() {
        return this.req.getCookieMap();
    }
18406#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getDateHeader(java.lang.String)
     */
    public long getDateHeader(String name) {
        return this.req.getDateHeader(name);
    }
18407#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getHeader(java.lang.String)
     */
    public String getHeader(String name) {
        return this.req.getHeader(name);
    }
18408#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getHeaders(java.lang.String)
     */
    public Enumeration getHeaders(String name) {
        return this.req.getHeaders(name);
    }
18409#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getHeaderNames()
     */
    public Enumeration getHeaderNames() {
        return this.req.getHeaderNames();
    }
18410#/* (non-Javadoc)
	 * @see org.apache.cocoon.environment.Request#getInputStream()
	 */
	public ServletInputStream getInputStream() throws IOException, UnsupportedOperationException {
		return this.req.getInputStream();
	}
18411#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getMethod()
     */
    public String getMethod() {
        return this.req.getMethod();
    }
18412#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getPathInfo()
     */
    public String getPathInfo() {
        return this.req.getPathInfo();
    }
18413#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getPathTranslated()
     */
    public String getPathTranslated() {
        return this.req.getPathTranslated();
    }
18414#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getContextPath()
     */
    public String getContextPath() {
        return this.req.getContextPath();
    }
18415#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getQueryString()
     */
    public String getQueryString() {
        return this.req.getQueryString();
    }
18416#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getRemoteUser()
     */
    public String getRemoteUser() {
        return this.req.getRemoteUser();
    }
18417#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getRequestedSessionId()
     */
    public String getRequestedSessionId() {
        return this.req.getRequestedSessionId();
    }
18418#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getRequestURI()
     */
    public String getRequestURI() {
        return this.req.getRequestURI();
    }
18419#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getSitemapURI()
     */
    public String getSitemapURI() {
        return this.req.getSitemapURI();
    }
18420#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getSitemapPath()
     */
    public String getSitemapPath() {
        return this.req.getSitemapPath();
    }
18421#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getServletPath()
     */
    public String getServletPath() {
        return this.req.getServletPath();
    }
18422#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getSession(boolean)
     */
    public HttpSession getSession(boolean create) {
        return this.req.getSession(create);
    }
18423#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getSession()
     */
    public HttpSession getSession() {
        return this.req.getSession();
    }
18424#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#isRequestedSessionIdValid()
     */
    public boolean isRequestedSessionIdValid() {
        return this.req.isRequestedSessionIdValid();
    }
18425#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#isRequestedSessionIdFromCookie()
     */
    public boolean isRequestedSessionIdFromCookie()  {
        return this.req.isRequestedSessionIdFromCookie();
    }
18426#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#isRequestedSessionIdFromURL()
     */
    public boolean isRequestedSessionIdFromURL() {
        return this.req.isRequestedSessionIdFromURL();
    }
18427#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getUserPrincipal()
     */
    public Principal getUserPrincipal() {
        return this.req.getUserPrincipal();
    }
18428#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#isUserInRole(java.lang.String)
     */
    public boolean isUserInRole(String role) {
        return this.req.isUserInRole(role);
    }
18429#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getAuthType()
     */
    public String getAuthType() {
        return this.req.getAuthType();
    }
18430#/**
     * @see org.apache.cocoon.environment.Request#getSitemapURIPrefix()
     */
    public String getSitemapURIPrefix() {
        return this.req.getSitemapURIPrefix();
    }
18431#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getCocoonCookieMap()
     */
    public Map getCocoonCookieMap() {
        return this.req.getCocoonCookieMap();
    }
18432#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getCocoonCookies()
     */
    public Cookie[] getCocoonCookies() {
        return this.req.getCocoonCookies();
    }
18433#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getCocoonSession(boolean)
     */
    public Session getCocoonSession(boolean create) {
        return this.req.getCocoonSession(create);
    }
18434#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getCocoonSession()
     */
    public Session getCocoonSession() {
        return this.req.getCocoonSession();
    }
18435#/* (non-Javadoc)
     * @see javax.servlet.http.HttpServletRequest#getIntHeader(java.lang.String)
     */
    public int getIntHeader(String name) {
        return this.req.getIntHeader(name);
    }
18436#/* (non-Javadoc)
     * @see javax.servlet.http.HttpServletRequest#getRequestURL()
     */
    public StringBuffer getRequestURL() {
        return this.req.getRequestURL();
    }
18437#/* (non-Javadoc)
     * @see javax.servlet.http.HttpServletRequest#isRequestedSessionIdFromUrl()
     */
    public boolean isRequestedSessionIdFromUrl() {
        return this.req.isRequestedSessionIdFromUrl();
    }
18438#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getLocalAddr()
     */
    public String getLocalAddr() {
        return this.req.getLocalAddr();
    }
18439#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getLocalName()
     */
    public String getLocalName() {
        return this.req.getLocalName();
    }
18440#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getLocalPort()
     */
    public int getLocalPort() {
        return this.req.getLocalPort();
    }
18441#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getParameterMap()
     */
    public Map getParameterMap() {
        return this.req.getParameterMap();
    }
18442#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getReader()
     */
    public BufferedReader getReader() throws IOException {
        return this.req.getReader();
    }
18443#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getRealPath(java.lang.String)
     */
    public String getRealPath(String path) {
        return this.req.getRealPath(path);
    }
18444#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getRemotePort()
     */
    public int getRemotePort() {
        return this.req.getRemotePort();
    }
18445#/* (non-Javadoc)
     * @see javax.servlet.ServletRequest#getRequestDispatcher(java.lang.String)
     */
    public RequestDispatcher getRequestDispatcher(String path) {
        return this.req.getRequestDispatcher(path);
    }
18446#/**
     * Constructor
     * @param request The Request to be wrapped.
     * @param requestURI The URI.
     * @param queryString The query String.
     * @param env The current Environment.
     */
    public RequestWrapper(Request request,
                          String  requestURI,
                          String  queryString,
                          Environment env) {
        this(request, requestURI, queryString, env, false);
    }
18447#/**
     * Constructor
     * @param request The Request to be wrapped.
     * @param requestURI The URI.
     * @param queryString The query String.
     * @param env The current Environment.
     * @param rawMode If true only parameters from the wrapper will be returned.
     */
    public RequestWrapper(Request request,
                          String  requestURI,
                          String  queryString,
                          Environment env,
                          boolean rawMode) {
        super(request);
        this.environment = env;
        this.queryString = queryString;
        this.parameters = new RequestParameters(queryString);
        this.rawMode = rawMode;
        if (this.req.getQueryString() != null && !this.rawMode) {
            if (this.queryString == null)
                this.queryString = this.req.getQueryString();
            else
                this.queryString += '&' + this.req.getQueryString();
        }
        this.requestURI = this.req.getRequestURI();
    }
18448#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getParameter(java.lang.String)
     */
    public String getParameter(String name) {
        String value = this.parameters.getParameter(name);
        if (value == null && !this.rawMode) {
            return this.req.getParameter(name);
        }
        return value;
    }
18449#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getParameterNames()
     */
    public Enumeration getParameterNames() {
        if ( !this.rawMode ) {
            // put all parameter names into a set
            Set parameterNames = new HashSet();
            Enumeration names = this.parameters.getParameterNames();
            while (names.hasMoreElements()) {
                parameterNames.add(names.nextElement());
            }
            names = this.req.getParameterNames();
            while (names.hasMoreElements()) {
                parameterNames.add(names.nextElement());
            }
            return new IteratorEnumeration(parameterNames.iterator());
        }
        return this.parameters.getParameterNames();
    }
18450#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getParameterValues(java.lang.String)
     */
    public String[] getParameterValues(String name) {
        if ( !this.rawMode ) {
            String[] values = this.parameters.getParameterValues(name);
            String[] inherited = this.req.getParameterValues(name);
            if (inherited == null) return values;
            if (values == null) return inherited;
            String[] allValues = new String[values.length + inherited.length];
            System.arraycopy(values, 0, allValues, 0, values.length);
            System.arraycopy(inherited, 0, allValues, values.length, inherited.length);
            return allValues;
        }
        return this.parameters.getParameterValues(name);
    }
18451#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getQueryString()
     */
    public String getQueryString() {
        return this.queryString;
    }
18452#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getRequestURI()
     */
    public String getRequestURI() {
        return this.requestURI;
    }
18453#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getSitemapURI()
     */
    public String getSitemapURI() {
        return this.environment.getURI();
    }
18454#public String getSitemapURIPrefix() {
        return this.environment.getURIPrefix();
    }
18455#/* (non-Javadoc)
     * @see org.apache.cocoon.environment.Request#getSitemapPath()
     */
    public String getSitemapPath() {
        return this.environment.getURIPrefix();
    }
18456#public void setRequestURI(String prefix, String uri) {
        StringBuffer buffer = new StringBuffer(this.getContextPath());
        buffer.append('/');
        buffer.append(prefix);
        buffer.append(uri);
        this.requestURI = buffer.toString();
    }
18457#/**
     * Construct a new environment.
     * 
     * @param env    The origial Environment
     * @param info   A description of the uri for the new environment
     */
    public EnvironmentWrapper(Environment       env,
                              SitemapSourceInfo info) {
        this(env, info, true);
    }
18458#/**
     * Construct a new environment.
     * 
     * @param env    The origial Environment
     * @param info   A description of the uri for the new environment
     * @param wrapResponse  Whether or not to wrap the Response object
     */
    public EnvironmentWrapper(Environment       env,
                              SitemapSourceInfo info,
                              boolean           wrapResponse) {
        super(env.getURI(), info.view, env.getAction());
        this.environment = env;

        // create new object model
        Map oldObjectModel = env.getObjectModel();
        this.objectModel = new HashMap(oldObjectModel);

        // replace the request object
        this.request = new RequestWrapper(ObjectModelHelper.getRequest(oldObjectModel),
                                          info.requestURI,
                                          info.queryString,
                                          this,
                                          info.rawMode);
        this.objectModel.put(ObjectModelHelper.REQUEST_OBJECT, this.request);

        if (wrapResponse) {
            Response response = new ResponseWrapper(ObjectModelHelper.getResponse(oldObjectModel));
            this.objectModel.put(ObjectModelHelper.RESPONSE_OBJECT, response);
        }

        setURI(info.prefix, info.uri);        
    }
18459#/**
     * @see org.apache.cocoon.environment.Environment#redirect(String, boolean, boolean)
     */
    public void redirect(String newURL, boolean global, boolean permanent)
    throws IOException {
        if (!global && !this.internalRedirect) {
            this.redirectURL = newURL;
        } else {
            this.environment.redirect(newURL, global, permanent);
        }
    }
18460#/**
     * @see org.apache.cocoon.environment.Environment#getOutputStream(int)
     */
    public OutputStream getOutputStream(int bufferSize)
    throws IOException {
        return this.outputStream == null
                ? this.environment.getOutputStream(bufferSize)
                : this.outputStream;
    }
18461#/**
     * Set the output stream for this environment. It hides the one of the
     * wrapped environment.
     */
    public void setOutputStream(OutputStream stream) {
        this.outputStream = stream;
    }
18462#/**
     * @see org.apache.cocoon.environment.Environment#tryResetResponse()
     */
    public boolean tryResetResponse()
    throws IOException {
        final OutputStream os = getOutputStream(-1);
        if (os instanceof BufferedOutputStream) {
            ((BufferedOutputStream) os).clearBuffer();
            return true;
        }

        return super.tryResetResponse();
    }
18463#/**
     * @see org.apache.cocoon.environment.Environment#commitResponse()
     */
    public void commitResponse() 
    throws IOException {
        final OutputStream os = getOutputStream(-1);
        if (os instanceof BufferedOutputStream) {
            ((BufferedOutputStream) os).realFlush();
        } else {
            super.commitResponse();
        }
    }
18464#/**
     * if a redirect should happen this returns the url,
     * otherwise <code>null</code> is returned
     */
    public String getRedirectURL() {
        return this.redirectURL;
    }
18465#public void reset() {
        this.redirectURL = null;
    }
18466#/**
     * Set the StatusCode
     */
    public void setStatus(int statusCode) {
        // ignore this
    }
18467#public void setContentLength(int length) {
        // ignore this
    }
18468#/**
     * Set the ContentType
     */
    public void setContentType(String contentType) {
        this.contentType = contentType;
    }
18469#/**
     * Get the ContentType
     */
    public String getContentType() {
        return this.contentType;
    }
18470#/**
     * Lookup an attribute in this instance, and if not found search it
     * in the wrapped environment.
     *
     * @param name a <code>String</code>, the name of the attribute to
     * look for
     * @return an <code>Object</code>, the value of the attribute or
     * null if no such attribute was found.
     */
    public Object getAttribute(String name) {
        Object value = super.getAttribute(name);
        if (value == null)
            value = this.environment.getAttribute(name);

        return value;
    }
18471#/**
     * Remove attribute from the current instance, as well as from the
     * wrapped environment.
     *
     * @param name a <code>String</code> value
     */
    public void removeAttribute(String name) {
        super.removeAttribute(name);
        this.environment.removeAttribute(name);
    }
18472#/**
     * Always return <code>false</code>.
     */
    public boolean isExternal() {
        return false;
    }
18473#public void setInternalRedirect(boolean flag) {
        this.internalRedirect = flag;
        if ( flag ) {
            ((RequestWrapper)this.request).setRequestURI(this.prefix, this.uri);
        }
    }
18474#/**
     * @see org.apache.cocoon.environment.Environment#isInternalRedirect()
     */
    public boolean isInternalRedirect() {
        return this.internalRedirect;
    }
18475#/**
     * Decode the string
     */
    private String parseName(String s) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            switch (c) {
                case '+':
                    sb.append(' ');
                    break;
                case '%':
                    try {
                        sb.append((char) Integer.parseInt(s.substring(i+1, i+3),
                              16));
                        i += 2;
                    } catch (NumberFormatException e) {
                        throw new IllegalArgumentException();
                    } catch (StringIndexOutOfBoundsException e) {
                        String rest  = s.substring(i);
                        sb.append(rest);
                        if (rest.length()==2)
                            i++;
                    }

                    break;
                default:
                    sb.append(c);
                    break;
            }
        }
        return sb.toString();
    }
18476#/**
     * Construct a new object from a queryString
     */
    public RequestParameters(String queryString) {
        this.names = new HashMap(5);
        if (queryString != null) {
            StringTokenizer st = new StringTokenizer(queryString, "&");
            while (st.hasMoreTokens()) {
                String pair = st.nextToken();
                int pos = pair.indexOf('=');
                if (pos != -1) {
                    this.setParameter(this.parseName(pair.substring(0, pos)),
                                      this.parseName(pair.substring(pos+1, pair.length())));
                }
            }
        }
    }
18477#/**
     * Add a parameter.
     * The parameter is added with the given value.
     * @param name   The name of the parameter.
     * @param value  The value of the parameter.
     */
    private void setParameter(String name, String value) {
        ArrayList list;
        if (names.containsKey(name)) {
            list = (ArrayList)names.get(name);
        } else {
            list = new ArrayList(3);
            names.put(name, list);
        }
        list.add(value);
    }
18478#/**
     * Get the value of a parameter.
     * @param name   The name of the parameter.
     * @return       The value of the first parameter with the name
     *               or <CODE>null</CODE>
     */
    public String getParameter(String name) {
        if (names.containsKey(name)) {
            return (String)((ArrayList)names.get(name)).get(0);
        }
        return null;
    }
18479#/**
     * Get the value of a parameter.
     * @param name   The name of the parameter.
     * @param defaultValue The default value if the parameter does not exist.
     * @return       The value of the first parameter with the name
     *               or <CODE>defaultValue</CODE>
     */
    public String getParameter(String name, String defaultValue) {
        if (names.containsKey(name)) {
            return (String)((ArrayList)names.get(name)).get(0);
        }
        return defaultValue;
    }
18480#/**
     * Get all values of a parameter.
     * @param name   The name of the parameter.
     * @return       Array of the (String) values or null if the parameter
     *               is not defined.
     */
    public String[] getParameterValues(String name) {
        if (names.containsKey(name)) {
            String values[] = null;
            ArrayList list = (ArrayList)names.get(name);
            Iterator iter = list.iterator();
            while (iter.hasNext()) {
                if (values == null) {
                    values = new String[1];
                } else {
                    String[] copy = new String[values.length+1];
                    System.arraycopy(values, 0, copy, 0, values.length);
                    values = copy;
                }
                values[values.length-1] = (String)iter.next();
            }
            return values;
        }
        return null;
    }
18481#/**
     * Get all parameter names.
     * @return  Enumeration for the (String) parameter names.
     */
    public Enumeration getParameterNames() {
        return new EnumerationFromIterator(names.keySet().iterator());
    }
18482#EnumerationFromIterator(Iterator iter) {
            this.iter = iter;
        }
18483#public boolean hasMoreElements() {
            return iter.hasNext();
        }
18484#public Object nextElement() { return iter.next(); }
18485#public ResponseWrapper(Response response) {
        this.res = response;
    }
18486#public String getCharacterEncoding() {
        return res.getCharacterEncoding();
    }
18487#public void setLocale(Locale loc) {
        res.setLocale(loc);
    }
18488#public Locale getLocale() {
        return res.getLocale();
    }
18489#public javax.servlet.http.Cookie createCookie(String name, String value) {
        return res.createCookie(name, value);
    }
18490#public void addCookie(javax.servlet.http.Cookie cookie) {
        res.addCookie(cookie);
    }
18491#public Cookie createCocoonCookie(String name, String value) {
        return res.createCocoonCookie(name, value);
    }
18492#public void addCookie(Cookie cookie) {
        res.addCookie(cookie);
    }
18493#public String encodeURL(String url) {
        return res.encodeURL(url);
    }
18494#public boolean containsHeader(String name) {
        return res.containsHeader(name);
    }
18495#public void setDateHeader(String name, long date) {
    }
18496#public void addDateHeader(String name, long date) {
    }
18497#public void setHeader(String name, String value) {
    }
18498#public void addHeader(String name, String value) {
    }
18499#public void setIntHeader(String name, int value) {
    }
18500#public void addIntHeader(String name, int value) {
    }
18501#/**
     * Match the pattern by preparing it and matching the prepared pattern.
     */
    public Map match (String pattern, Map objectModel, Parameters parameters)
    throws PatternException {
        return preparedMatch(preparePattern(pattern), objectModel, parameters);
    }
18502#/**
     * Match the prepared pattern against the result of {@link #getMatchString(Map, Parameters)}.
     *
     * @see AbstractPreparableMatcher#match(String, Map, Parameters)
     */
    public Map match(String pattern, Map objectModel, Parameters parameters) throws PatternException {
        if (pattern == null) {
            throw new PatternException("A pattern is needed at " +
                                       SitemapParameters.getLocation(parameters));
        }

        final String match = getMatchString(objectModel, parameters);
        if (match == null) {
            return null;
        }

        return WildcardMatcherHelper.match(pattern, match);
    }
18503#/**
     * Get the string to test against the wildcard expression. To be defined
     * by concrete subclasses.
     */
    protected abstract String getMatchString(Map objectModel, Parameters parameters);
18504#/**
     * Compile the pattern in a <code>org.apache.regexp.REProgram</code>.
     */
    public Object preparePattern(String pattern) throws PatternException {
        // if pattern is null, return null to allow throwing a located exception in preparedMatch()
        if (pattern == null) {
            return null;
        }

        if (pattern.length() == 0) {
            pattern = "^$";
            if (getLogger().isWarnEnabled()) {
                getLogger().warn("The empty pattern string was rewritten to '^$'"
                                 + " to match for empty strings.  If you intended"
                                 + " to match all strings, please change your"
                                 + " pattern to '.*'");
            }
        }

        try {
            RECompiler compiler = new RECompiler();
            REProgram program = compiler.compile(pattern);
            return program;

        } catch (RESyntaxException rse) {
            getLogger().debug("Failed to compile the pattern '" + pattern + "'", rse);
            throw new PatternException(rse.getMessage(), rse);
        }
    }
18505#/**
     * Match the prepared pattern against the value returned by {@link #getMatchString(Map, Parameters)}.
     */
    public Map preparedMatch(Object preparedPattern, Map objectModel, Parameters parameters) throws PatternException {

        if(preparedPattern == null) {
            throw new PatternException("A pattern is needed at " + SitemapParameters.getLocation(parameters));
        }

        RE re = new RE((REProgram)preparedPattern);
        String match = getMatchString(objectModel, parameters);

        if (match == null)
            return null;

        if(re.match(match)) {
            /* Handle parenthesised subexpressions. XXX: could be faster if we count
             * parens *outside* the generated code.
             * Note: *ONE* based, not zero, zero contains complete match
             */
            int parenCount = re.getParenCount();
            Map map = new HashMap();
            for (int paren = 0; paren <= parenCount; paren++) {
                map.put(Integer.toString(paren), re.getParen(paren));
            }

            return map;
        }

        return null;
    }
18506#/**
     * Get the string to test against the regular expression. To be defined
     * by concrete subclasses.
     */
    protected abstract String getMatchString(Map objectModel, Parameters parameters);
18507#public ParametersMap(Parameters wrapped) {
        wrappedParameters = wrapped;
    }
18508#public boolean equals(Object arg0) {
        return wrappedParameters.equals(arg0);
    }
18509#public String[] getNames() {
        return wrappedParameters.getNames();
    }
18510#public String getParameter(String arg0, String arg1) {
        return wrappedParameters.getParameter(arg0, arg1);
    }
18511#public String getParameter(String arg0) throws ParameterException {
        return wrappedParameters.getParameter(arg0);
    }
18512#public boolean getParameterAsBoolean(String arg0, boolean arg1) {
        return wrappedParameters.getParameterAsBoolean(arg0, arg1);
    }
18513#public boolean getParameterAsBoolean(String arg0) throws ParameterException {
        return wrappedParameters.getParameterAsBoolean(arg0);
    }
18514#public float getParameterAsFloat(String arg0, float arg1) {
        return wrappedParameters.getParameterAsFloat(arg0, arg1);
    }
18515#public float getParameterAsFloat(String arg0) throws ParameterException {
        return wrappedParameters.getParameterAsFloat(arg0);
    }
18516#public int getParameterAsInteger(String arg0, int arg1) {
        return wrappedParameters.getParameterAsInteger(arg0, arg1);
    }
18517#public int getParameterAsInteger(String arg0) throws ParameterException {
        return wrappedParameters.getParameterAsInteger(arg0);
    }
18518#public long getParameterAsLong(String arg0, long arg1) {
        return wrappedParameters.getParameterAsLong(arg0, arg1);
    }
18519#public long getParameterAsLong(String arg0) throws ParameterException {
        return wrappedParameters.getParameterAsLong(arg0);
    }
18520#public Iterator getParameterNames() {
        return wrappedParameters.getParameterNames();
    }
18521#public int hashCode() {
        return wrappedParameters.hashCode();
    }
18522#public boolean isParameter(String arg0) {
        return wrappedParameters.isParameter(arg0);
    }
18523#public void makeReadOnly() {
        wrappedParameters.makeReadOnly();
    }
18524#public Parameters merge(Parameters arg0) {
        return wrappedParameters.merge(arg0);
    }
18525#public void removeParameter(String arg0) {
        wrappedParameters.removeParameter(arg0);
    }
18526#public String setParameter(String arg0, String arg1) throws IllegalStateException {
        return wrappedParameters.setParameter(arg0, arg1);
    }
18527#public void clear() {
        this.checkWriteable();
    }
18528#protected Map getMap() {
        if ( this.map == null ) {
            this.map = new HashMap();
            String[] names = this.getNames();
            for(int i=0; i<names.length;i++) {
                map.put(names[i], this.getParameter(names[i], null));
            }
        }
        return this.map;
    }
18529#public boolean containsKey(Object arg0) {
        if ( arg0 == null ) {
            return false;
        }
        return this.getParameter(arg0.toString(), null) != null;
    }
18530#public boolean containsValue(Object arg0) {
        return this.getMap().containsValue(arg0);
    }
18531#public Set entrySet() {
        return this.getMap().entrySet();
    }
18532#public Object get(Object arg0) {
        if ( arg0 == null ) {
            return null;
        }
        return this.getParameter(arg0.toString(), null);
    }
18533#public boolean isEmpty() {
        return this.getNames().length == 0;
    }
18534#public Set keySet() {
        return this.getMap().keySet();
    }
18535#public Object put(Object arg0, Object arg1) {
        this.checkWriteable();
        return null;
    }
18536#public void putAll(Map arg0) {
        this.checkWriteable();
    }
18537#public Object remove(Object arg0) {
        this.checkWriteable();
        return null;
    }
18538#public int size() {
        return this.getNames().length;
    }
18539#public Collection values() {
        return this.getMap().values();
    }
18540#public Settings getSettings() {
        return settings;
    }
18541#public void setSettings(Settings settings) {
        this.settings = settings;
    }
18542#public ProcessInfoProvider getProcessInfoProvider() {
        return processInfoProvider;
    }
18543#public void setProcessInfoProvider(ProcessInfoProvider processInfoProvider) {
        this.processInfoProvider = processInfoProvider;
    }
18544#public Object getObject() {
        Map objectModel = processInfoProvider.getObjectModel();
        
        Map cocoonMap = new HashMap();
        
        //cocoon.request
        Request request = ObjectModelHelper.getRequest(objectModel);
        cocoonMap.put("request", request);
        
        //cocoon.session
        HttpSession session = request.getSession(false);
        if (session != null) {
            cocoonMap.put("session", session);
        }
        
        // cocoon.context
        org.apache.cocoon.environment.Context context = ObjectModelHelper.getContext(objectModel);
        cocoonMap.put("context", context);
        
        cocoonMap.put("settings", this.settings);
        
        return cocoonMap;
    }
18545#public Map getObjectModel() {
        return objectModel;
    }
18546#public void setObjectModel(Map objectModel) {
        this.objectModel = objectModel;
    }
18547#public HttpServletRequest getRequest() {
        return request;
    }
18548#public void setRequest(HttpServletRequest request) {
        this.request = request;
    }
18549#public HttpServletResponse getResponse() {
        return response;
    }
18550#public void setResponse(HttpServletResponse response) {
        this.response = response;
    }
18551#public ServletContext getServletContext() {
        return servletContext;
    }
18552#public void setServletContext(ServletContext servletContext) {
        this.servletContext = servletContext;
    }
18553#public StubRequest(Request request) {
            this.request = request;
        }
18554#public Object get(String name) {
            return request.get(name);
        }
18555#public Object getLocalAttribute(String name) {
            return request.getLocalAttribute(name);
        }
18556#public Object getAttribute(String name) {
            return request.getAttribute(name);
        }
18557#public Enumeration getAttributeNames() {
            return request.getAttributeNames();
        }
18558#public Enumeration getLocalAttributeNames() {
            return request.getLocalAttributeNames();
        }
18559#public Map getAttributes() {
            return request.getAttributes();
        }
18560#public String getAuthType() {
            return request.getAuthType();
        }
18561#public String getCharacterEncoding() {
            return request.getCharacterEncoding();
        }
18562#public int getContentLength() {
            return request.getContentLength();
        }
18563#public String getContentType() {
            return request.getContentType();
        }
18564#public String getContextPath() {
            return request.getContextPath();
        }
18565#public Map getCookieMap() {
            return request.getCookieMap();
        }
18566#public javax.servlet.http.Cookie[] getCookies() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18567#public long getDateHeader(String name) {
            return request.getDateHeader(name);
        }
18568#public String getHeader(String name) {
            return request.getHeader(name);
        }
18569#public Enumeration getHeaderNames() {
            return request.getHeaderNames();
        }
18570#public Map getHeaders() {
            return request.getHeaders();
        }
18571#public Enumeration getHeaders(String name) {
            return request.getHeaders(name);
        }
18572#public ServletInputStream getInputStream() throws IOException, UnsupportedOperationException {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18573#public Locale getLocale() {
            return request.getLocale();
        }
18574#public Enumeration getLocales() {
            return request.getLocales();
        }
18575#public String getMethod() {
            return request.getMethod();
        }
18576#public String getParameter(String name) {
            return request.getParameter(name);
        }
18577#public Enumeration getParameterNames() {
            return request.getParameterNames();
        }
18578#public Map getParameters() {
            return request.getParameters();
        }
18579#public String[] getParameterValues(String name) {
            return request.getParameterValues(name);
        }
18580#public String getPathInfo() {
            return request.getPathInfo();
        }
18581#public String getPathTranslated() {
            return request.getPathTranslated();
        }
18582#public String getProtocol() {
            return request.getProtocol();
        }
18583#public String getQueryString() {
            return request.getQueryString();
        }
18584#public String getRemoteAddr() {
            return request.getRemoteAddr();
        }
18585#public String getRemoteHost() {
            return request.getRemoteHost();
        }
18586#public String getRemoteUser() {
            return request.getRemoteUser();
        }
18587#public String getRequestedSessionId() {
            return request.getRequestedSessionId();
        }
18588#public String getRequestURI() {
            return request.getRequestURI();
        }
18589#public String getScheme() {
            return request.getScheme();
        }
18590#public String getServerName() {
            return request.getServerName();
        }
18591#public int getServerPort() {
            return request.getServerPort();
        }
18592#public String getServletPath() {
            return request.getServletPath();
        }
18593#public HttpSession getSession() {
            return getSession(true);
        }
18594#public HttpSession getSession(boolean create) {
            return new StubSession((Session) request.getSession(create));
        }
18595#public String getSitemapPath() {
            return request.getSitemapPath();
        }
18596#public String getSitemapURI() {
            return request.getSitemapURI();
        }
18597#public String getSitemapURIPrefix() {
            return request.getSitemapURIPrefix();
        }
18598#public Principal getUserPrincipal() {
            return request.getUserPrincipal();
        }
18599#public boolean isRequestedSessionIdFromCookie() {
            return request.isRequestedSessionIdFromCookie();
        }
18600#public boolean isRequestedSessionIdFromURL() {
            return request.isRequestedSessionIdFromURL();
        }
18601#public boolean isRequestedSessionIdValid() {
            return request.isRequestedSessionIdValid();
        }
18602#public boolean isSecure() {
            return request.isSecure();
        }
18603#public boolean isUserInRole(String role) {
            return request.isUserInRole(role);
        }
18604#public void removeLocalAttribute(String name) {
            request.removeAttribute(name);
        }
18605#public void removeAttribute(String name) {
            request.removeAttribute(name);
        }
18606#public Object searchAttribute(String name) {
            return request.searchAttribute(name);
        }
18607#public void setLocalAttribute(String name, Object o) {
            request.setLocalAttribute(name, o);
        }
18608#public void setAttribute(String name, Object o) {
            request.setAttribute(name, o);
        }
18609#public void setCharacterEncoding(String enc) throws UnsupportedEncodingException {
            request.setCharacterEncoding(enc);
        }
18610#public int getIntHeader(String name) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18611#public StringBuffer getRequestURL() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18612#public boolean isRequestedSessionIdFromUrl() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18613#public String getLocalAddr() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18614#public String getLocalName() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18615#public int getLocalPort() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18616#public Map getParameterMap() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18617#public BufferedReader getReader() throws IOException {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18618#public String getRealPath(String path) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18619#public int getRemotePort() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18620#public RequestDispatcher getRequestDispatcher(String path) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18621#public StubResponse(Response response) {
            this.response = response;
        }
18622#public void addCookie(Cookie cookie) {
            response.addCookie(cookie);
        }
18623#public void addDateHeader(String name, long date) {
            response.addDateHeader(name, date);
        }
18624#public void addHeader(String name, String value) {
            response.addHeader(name, value);
        }
18625#public void addIntHeader(String name, int value) {
            response.addIntHeader(name, value);
        }
18626#public boolean containsHeader(String name) {
            return response.containsHeader(name);
        }
18627#public javax.servlet.http.Cookie createCookie(String name, String value) {
            return response.createCookie(name, value);
        }
18628#public String encodeURL(String url) {
            return response.encodeURL(url);
        }
18629#public String getCharacterEncoding() {
            return response.getCharacterEncoding();
        }
18630#public Locale getLocale() {
            return response.getLocale();
        }
18631#public void setDateHeader(String name, long date) {
            response.setDateHeader(name, date);
        }
18632#public void setHeader(String name, String value) {
            response.setHeader(name, value);
        }
18633#public void setIntHeader(String name, int value) {
            response.setIntHeader(name, value);
        }
18634#public void setLocale(Locale loc) {
            response.setLocale(loc);
        }
18635#public void addCookie(javax.servlet.http.Cookie cookie) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18636#public String encodeRedirectURL(String url) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18637#public String encodeRedirectUrl(String url) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18638#public String encodeUrl(String url) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18639#public void sendError(int sc) throws IOException {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18640#public void sendError(int sc, String msg) throws IOException {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18641#public void sendRedirect(String location) throws IOException {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18642#public void setStatus(int sc) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18643#public void setStatus(int sc, String sm) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18644#public void flushBuffer() throws IOException {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18645#public int getBufferSize() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18646#public String getContentType() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18647#public ServletOutputStream getOutputStream() throws IOException {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18648#public PrintWriter getWriter() throws IOException {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18649#public boolean isCommitted() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18650#public void reset() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18651#public void resetBuffer() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18652#public void setBufferSize(int size) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18653#public void setCharacterEncoding(String charset) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18654#public void setContentLength(int len) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18655#public void setContentType(String type) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18656#public StubSession(Session session) {
            this.session = session;
        }
18657#public Object getAttribute(String name) {
            return session.getAttribute(name);
        }
18658#public Enumeration getAttributeNames() {
            return session.getAttributeNames();
        }
18659#public Map getAttributes() {
            return session.getAttributes();
        }
18660#public long getCreationTime() {
            return session.getCreationTime();
        }
18661#public String getId() {
            return session.getId();
        }
18662#public long getLastAccessedTime() {
            return session.getLastAccessedTime();
        }
18663#public int getMaxInactiveInterval() {
            return session.getMaxInactiveInterval();
        }
18664#public void invalidate() {
            session.invalidate();
        }
18665#public boolean isNew() {
            return session.isNew();
        }
18666#public void removeAttribute(String name) {
            session.removeAttribute(name);
        }
18667#public void setAttribute(String name, Object value) {
            session.setAttribute(name, value);
        }
18668#public void setMaxInactiveInterval(int interval) {
            session.setMaxInactiveInterval(interval);
        }
18669#public ServletContext getServletContext() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18670#public HttpSessionContext getSessionContext() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18671#public Object getValue(String name) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18672#public String[] getValueNames() {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18673#public void putValue(String name, Object value) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18674#public void removeValue(String name) {
            //FIXME: Implement this method if needed
            throw new UnsupportedOperationException();
        }
18675#protected Map getCurrentObjectModel() {
        final Environment env = EnvironmentHelper.getCurrentEnvironment();
        if ( env == null ) {
            throw new IllegalStateException("Unable to locate current environment.");
        }
        return env.getObjectModel();
    }
18676#/**
     * Set the dependency to the servlet context.
     * @param context The servlet context.
     */
    public void setServletContext(ServletContext context) {
        this.servletContext = context;
    }
18677#/**
     * @see org.apache.cocoon.processing.ProcessInfoProvider#getRequest()
     */
    public HttpServletRequest getRequest() {
        return (HttpServletRequest) this.getCurrentObjectModel().get(HttpEnvironment.HTTP_REQUEST_OBJECT);
    }
18678#/**
     * @see org.apache.cocoon.processing.ProcessInfoProvider#getResponse()
     */
    public HttpServletResponse getResponse() {
        return (HttpServletResponse) this.getCurrentObjectModel().get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
    }
18679#/**
     * @see org.apache.cocoon.processing.ProcessInfoProvider#getServletContext()
     */
    public ServletContext getServletContext() {
        return this.servletContext;
    }
18680#/**
     * @see org.apache.cocoon.processing.ProcessInfoProvider#getObjectModel()
     */
    public Map getObjectModel() {
        return this.getCurrentObjectModel();
    }
18681#/**
     * Setup the association from expressions to a list of patterns. The configuration
     * should look like :
     * &lt;pre&gt;
     *  &lt;map:selector name="foo" src="..."&gt;
     *    &lt;confName nameAttr="expression" valueAttr="pattern"/&gt;
     *    ... others (expression, pattern) associations ...
     *  &lt;/map:selector&gt;
     * &lt;/pre&gt;
     *
     * @param conf the configuration
     * @param confName the name of children of <code>conf</code> that will be used to
     *            build associations
     * @param nameAttr the name of the attribute that holds the expression
     * @param valueAttr the name of the attribute that holds the pattern
     */
    protected void configure(Configuration conf, String confName, String nameAttr, String valueAttr)
      throws ConfigurationException {
        Configuration confs[] = conf.getChildren(confName);
        Map configMap = new HashMap();

        // Build a list of strings for each name
        for (int i = 0; i < confs.length; i++) {
            String name = confs[i].getAttribute(nameAttr);
            String value = confs[i].getAttribute(valueAttr);

            // Get value list for this name
            List nameList = (List)configMap.get(name);
            if (nameList == null) {
                nameList = new ArrayList();
                configMap.put(name, nameList);
            }

            // Add the current value
            nameList.add(value);
        }

        // Convert lists to arrays for faster lookup
        Iterator entries = configMap.entrySet().iterator();
        while(entries.hasNext()) {
            Map.Entry entry = (Map.Entry)entries.next();
            List nameList = (List)entry.getValue();
            entry.setValue(nameList.toArray(new String[nameList.size()]));
        }

        this.strings = configMap;
    }
18682#/**
     * Checks if <code>value</code> is a substring of one of the patterns associated
     * to <code>expression</code>
     *
     * @param expression the expression that is selected
     * @param value the value to check
     * @return true if <code>value</code> matches one of the patterns
     */
    protected boolean checkPatterns(String expression, String value) {
        if (value == null) {
            getLogger().debug("No value given -- failing.");
            return false;
        }
        // Get patterns for 'expression'
        String[] patterns = (String[])this.strings.get(expression);
        if (patterns == null) {
            getLogger().warn("No configuration for expression '" + expression + "' -- failing.");
            return false;
        }

        // Does a pattern match 'value' ?
        for (int i = 0; i < patterns.length; i++) {
            if (value.indexOf(patterns[i]) != -1) {
                getLogger().debug(expression + " selected value " + value);
                return true;
            }
        }

        // No match
        return false;
    }
18683#/**
     * <p>Create a new {@link AbstractRegexpSelector} instance.</p>
     */
    protected AbstractRegexpSelector() {
        super();
    }
18684#/**
     * <p>Select a pipeline fragment based on a previously configured pattern.</p>
     * 
     * @param patternName the name of the configured pattern.
     * @param selectorContext the string to be matched by the named pattern.
     * @return <b>true</b> if the contexts is matched by the configured pattern.
     */
    public boolean select(String patternName, Object selectorContext) {

        /* Check that the context selection returned something */
        if (selectorContext == null) return(false);

        /* Check that we actually have a configured pattern */
        REProgram pattern = (REProgram) this.patterns.get(patternName);
        if (pattern == null) {
            if (this.getLogger().isWarnEnabled()) {
                this.getLogger().warn("The specified pattern name \"" + patternName
                                      + "\" was not configured in this instance");
            }
            return(false);
        }

        /* Pattern matching */
        return(new RE(pattern).match(selectorContext.toString()));
    }
18685#/**
     * <p>Configure this instance parsing all regular expression patterns.</p>
     * 
     * @param configuration the {@link Configuration} instance where configured
     *                      patterns are defined.
     * @throws ConfigurationException if one of the regular-expression to configure
     *                                could not be compiled.
     */
    public void configure(Configuration configuration)
    throws ConfigurationException {
        Configuration patterns[] = configuration.getChildren("pattern");
        for (int x = 0; x < patterns.length; x++) {
            String name = patterns[x].getAttribute("name");
            String pattern = patterns[x].getValue();
            this.patterns.put(name, this.compile(pattern));
        }
    }
18686#/**
     * <p>Compile the pattern in a {@link REProgram}.</p>
     * 
     * @param pattern the regular expression pattern in a textual format.
     * @return a compiled regular expression pattern.
     * @throws ConfigurationException in the pattern could not be compiled. 
     */
    protected REProgram compile(String pattern)
    throws ConfigurationException {
        if (pattern == null) {
            throw new ConfigurationException("Null pattern");
        }

        if (pattern.length() == 0) {
            pattern = "^$";
            if (this.getLogger().isWarnEnabled()) {
                this.getLogger().warn("The empty pattern string was rewritten to "
                                      + "'^$' to match for empty strings.  If you "
                                      + "intended to match all strings, please "
                                      + "change your pattern to '.*'");
            }
        }

        try {
            RECompiler compiler = new RECompiler();
            REProgram program = compiler.compile(pattern);
            return program;
        } catch (RESyntaxException rse) {
            getLogger().debug("Failed to compile the pattern '" + pattern + "'", rse);
            throw new ConfigurationException(rse.getMessage(), rse);
        }
    }
18687#/**
     * Selectors test pattern against some objects in a <code>Map</code>
     * model and signals success with the returned boolean value.
     *
     * @param expr The expression to test.
     * @return Signals successful test.
     */
    public boolean select(String expr, Map objectModel, Parameters params) {
        return select(expr, getSelectorContext(objectModel, params));
    }
18688#/**
     * Generates the content
     */
    public void generate()
    throws IOException, SAXException, ProcessingException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Generating aggregated content");
        }
        this.contentHandler.startDocument();
        startElem(this.rootElement);

        for (int i = 0; i < this.parts.size(); i++) {
            final Part part = (Part) this.parts.get(i);
            this.rootElementIndex = part.stripRootElement ? -1 : 0;
            if (part.element != null) {
                this.currentElement = part.element;
                startElem(part.element);
            } else {
                this.currentElement = this.rootElement;
            }

            SourceUtil.parse(this.manager, part.source, this);
            
            if (part.element != null) {
                endElem(part.element);
            }
        }

        endElem(this.rootElement);
        this.contentHandler.endDocument();
            
        getLogger().debug("Finished aggregating content");
    }
18689#/**
     * Generate the unique key.
     * This key must be unique inside the space of this component.
     *
     * @return The generated key hashes the src
     */
    public Serializable getKey() {
        try {
            StringBuffer buffer = new StringBuffer(64);
            buffer.append("CA(")
                    .append(this.rootElement.prefix).append(':')
                    .append(this.rootElement.name).append('<')
                    .append(this.rootElement.namespace).append(">)");

            for (int i = 0; i < this.parts.size(); i++) {
                final Part part = (Part) this.parts.get(i);
                final Source source = part.source;

                if (part.element == null) {
                    buffer.append("P=")
                            .append(part.stripRootElement).append(':')
                            .append(source.getURI()).append(';');
                } else {
                    buffer.append("P=")
                            .append(part.element.prefix).append(':')
                            .append(part.element.name)
                            .append('<').append(part.element.namespace).append(">:")
                            .append(part.stripRootElement).append(':')
                            .append(source.getURI()).append(';');
                }
            }

            return buffer.toString();
        } catch (Exception e) {
            getLogger().error("Could not generateKey", e);
            return null;
        }
    }
18690#/**
     * Generate the validity object.
     *
     * @return The generated validity object or <code>null</code> if the
     *         component is currently not cacheable.
     */
    public SourceValidity getValidity() {
        try {
            AggregatedValidity v = new AggregatedValidity();
            for (int i = 0; i < this.parts.size(); i++) {
                final Source current = ((Part) this.parts.get(i)).source;
                final SourceValidity sv = current.getValidity();

                if (sv == null) {
                    return null;
                } else {
                    v.add(sv);
                }
            }

            return v;
        } catch (Exception e) {
            getLogger().error("Could not getValidity", e);
            return null;
        }
    }
18691#/**
     * Set the root element. Please make sure that the parameters are not null!
     */
    public void setRootElement(String element, String namespace, String prefix) {
        this.rootElement = new Element(element,
                                       namespace,
                                       prefix);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Root element='" + element +
                              "' ns='" + namespace + "' prefix='" + prefix + "'");
        }
    }
18692#/**
     * Add a part. Please make sure that the parameters are not null!
     */
    public void addPart(String uri,
                        String element,
                        String namespace,
                        String stripRootElement,
                        String prefix) {
        Element elem = null;
        if (!element.equals("")) {
            if (namespace.equals("")) {
                elem = new Element(element,
                                   this.rootElement.namespace,
                                   this.rootElement.prefix);
            } else {
                elem = new Element(element,
                                   namespace,
                                   prefix);
            }
        }
        this.parts.add(new Part(uri,
                                elem,
                                stripRootElement));
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Part uri='" + uri +
                              "' element='" + element + "' ns='" + namespace +
                              "' stripRootElement='" + stripRootElement + "' prefix='" + prefix + "'");
        }
    }
18693#/**
     * Set the <code>XMLConsumer</code> that will receive XML data.
     *
     * <br>
     * This method will simply call <code>setContentHandler(consumer)</code>
     * and <code>setLexicalHandler(consumer)</code>.
     */
    public void setConsumer(XMLConsumer consumer) {
        setContentHandler(consumer);
        setLexicalHandler(consumer);
    }
18694#/**
     * Recycle the producer by removing references
     */
    public void recycle() {
        super.recycle();

        this.rootElement = null;
        for (int i = 0; i < this.parts.size(); i++) {
            final Part current = (Part) this.parts.get(i);
            if (current.source != null) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Releasing " + current.source);
                }
                this.resolver.release(current.source);
            }
        }
        this.parts.clear();
        this.currentElement = null;
        this.resolver = null;
    }
18695#/**
     * Set the <code>SourceResolver</code>, object model <code>Map</code>,
     * the source and sitemap <code>Parameters</code> used to process the request.
     */
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)
    throws ProcessingException, SAXException, IOException {
        this.resolver = resolver;
        // get the Source for each part
        try {
            for (int i = 0; i < this.parts.size(); i++) {
                final Part current = (Part) this.parts.get(i);
                current.source = resolver.resolveURI(current.uri);
            }
        } catch (SourceException se) {
            throw SourceUtil.handle("Unable to resolve source.", se);
        }
    }
18696#/**
     * Private method generating startElement event for the aggregated parts
     * and the root element
     */
    private void startElem(Element element)
    throws SAXException {
        final String qname = (element.prefix.equals("")) ? element.name : element.prefix + ':' + element.name;
        if (!element.namespace.equals("")) {
            this.contentHandler.startPrefixMapping(element.prefix, element.namespace);
        }
        this.contentHandler.startElement(element.namespace, element.name, qname, XMLUtils.EMPTY_ATTRIBUTES);
    }
18697#/**
     * Private method generating endElement event for the aggregated parts
     * and the root element
     */
    private void endElem(Element element) throws SAXException {
        final String qname = (element.prefix.equals("")) ? element.name : element.prefix + ':' + element.name;
        this.contentHandler.endElement(element.namespace, element.name, qname);
        if (!element.namespace.equals("")) {
            this.contentHandler.endPrefixMapping(element.prefix);
        }
    }
18698#/**
     * Ignore start and end document events
     */
    public void startDocument() throws SAXException {
    }
18699#/**
     * Ignore start and end document events
     */
    public void endDocument() throws SAXException {
    }
18700#/**
     * Override startElement() event to add namespace and prefix
     */
    public void startElement(String namespaceURI, String localName, String raw, Attributes atts)
    throws SAXException {
        this.rootElementIndex++;
        if (this.rootElementIndex == 0) {
            getLogger().debug("Skipping root element start event.");
            return;
        }
        if (namespaceURI == null || namespaceURI.equals("")) {
            final String qname = this.currentElement.prefix.equals("") ? localName : this.currentElement.prefix + ':' + localName;
            this.contentHandler.startElement(this.currentElement.namespace, localName, qname, atts);
        } else {
            this.contentHandler.startElement(namespaceURI, localName, raw, atts);
        }
    }
18701#/**
     * Override startElement() event to add namespace and prefix
     */
    public void endElement(String namespaceURI, String localName, String raw) throws SAXException {
        this.rootElementIndex--;
        if (this.rootElementIndex == -1) {
            getLogger().debug("Skipping root element end event.");
            return;
        }
        if (namespaceURI == null || namespaceURI.equals("")) {
            final String qname = this.currentElement.prefix.equals("") ? localName : this.currentElement.prefix + ':' + localName;
            this.contentHandler.endElement(this.currentElement.namespace, localName, qname);
        } else {
            this.contentHandler.endElement(namespaceURI, localName, raw);
        }
    }
18702#/* (non-Javadoc)
     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)
     */
    public void service(ServiceManager manager) throws ServiceException {
        this.manager = manager;
    }
18703#public Part(String uri, Element element, String stripRoot) {
            this.uri = uri;
            this.element = element;
            this.stripRootElement = BooleanUtils.toBoolean(stripRoot);
        }
18704#public Element(String name, String namespace, String prefix) {
            this.namespace = namespace;
            this.prefix = prefix;
            this.name = name;
        }
18705#public SitemapParameters(Location location) {
        this.location = location;
    }
18706#/**
     * Get the location of the statement defining these parameters.
     * 
     * @since 2.1.8
     * @see org.apache.cocoon.util.location.Locatable#getLocation()
     */
    public Location getLocation() {
        return this.location;
    }
18707#/**
     * Get the location of a <code>Parameters</code> object, returning
     * {@link Location#UNKNOWN} if no location could be found.
     * 
     * @param param
     * @return the location
     * @since 2.1.8
     */
    public static Location getLocation(Parameters param) {
        Location loc = null;
        if (param instanceof Locatable) {
            loc = ((Locatable)param).getLocation();
        }
        return loc == null ? Location.UNKNOWN : loc;
    }
18708#/**
     * @deprecated use {@link #getLocation(Parameters)}
     */
    public static String getStatementLocation(Parameters param) {
        return getLocation(param).toString();
    }
18709#public Location getLocation() {
            return this.loc;
        }
18710#public LocatedHashMap(Location loc) {
            this.loc = loc;
        }
18711#public LocatedHashMap(Location loc, int size) {
            super(size);
            this.loc = loc;
        }
18712#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#invokeAction(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map, org.apache.cocoon.acting.Action, org.apache.cocoon.environment.Redirector, org.apache.cocoon.environment.SourceResolver, java.lang.String, org.apache.avalon.framework.parameters.Parameters)
     */
    public Map invokeAction(final ExecutionContext context,
                            final Map              objectModel, 
                            final Action           action, 
                            final Redirector       redirector, 
                            final SourceResolver   resolver, 
                            final String           resolvedSource, 
                            final Parameters       resolvedParams )
    throws Exception {
        return action.act(redirector, resolver, objectModel, 
                resolvedSource, resolvedParams);        
    }
18713#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#invokeMatcher(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map, org.apache.cocoon.matching.Matcher, java.lang.String, org.apache.avalon.framework.parameters.Parameters)
     */
    public Map invokeMatcher(ExecutionContext context, 
                             Map objectModel,
                             Matcher matcher, 
                             String pattern, 
                             Parameters resolvedParams)
    throws PatternException {
        return matcher.match(pattern, objectModel, resolvedParams);
    }
18714#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#invokePreparableMatcher(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map, org.apache.cocoon.matching.PreparableMatcher, java.lang.String, java.lang.Object, org.apache.avalon.framework.parameters.Parameters)
     */
    public Map invokePreparableMatcher(ExecutionContext  context,
                                       Map               objectModel,
                                       PreparableMatcher matcher,
                                       String            pattern,
                                       Object            preparedPattern,
                                       Parameters        resolvedParams )
    throws PatternException {
        return matcher.preparedMatch(preparedPattern, objectModel, resolvedParams);
    }
18715#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#invokeSelector(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map, org.apache.cocoon.selection.Selector, java.lang.String, org.apache.avalon.framework.parameters.Parameters)
     */
    public boolean invokeSelector(ExecutionContext context, Map objectModel,
            Selector selector, String expression, Parameters parameters) {
        return selector.select(expression, objectModel, parameters);
    }
18716#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#invokeSwitchSelector(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map, org.apache.cocoon.selection.SwitchSelector, java.lang.String, org.apache.avalon.framework.parameters.Parameters, Object)
     */
    public boolean invokeSwitchSelector(ExecutionContext context,
            Map objectModel, SwitchSelector selector, String expression,
            Parameters parameters, Object selectorContext) {
        return selector.select(expression, selectorContext);
    }
18717#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#popVariables(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map)
     */
    public void popVariables(ExecutionContext context,
                             Map              objectModel) {
        // nothing to do
    }
18718#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#pushVariables(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map, java.lang.String, java.util.Map)
     */
    public Map pushVariables(ExecutionContext context, 
                             Map              objectModel,
                             String key, Map variables) {
        return variables;
    }
18719#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#enterSitemap(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map, java.lang.String)
     */
    public void enterSitemap(ExecutionContext context, Map objectModel, String source) {
        // nothing to do
    }
18720#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#addGenerator(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map, org.apache.cocoon.sitemap.SitemapExecutor.PipelineComponentDescription)
     */
    public PipelineComponentDescription addGenerator(ExecutionContext context,
            Map objectModel, PipelineComponentDescription desc) {
        return desc;
    }
18721#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#addReader(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map, org.apache.cocoon.sitemap.SitemapExecutor.PipelineComponentDescription)
     */
    public PipelineComponentDescription addReader(ExecutionContext context,
            Map objectModel, PipelineComponentDescription desc) {
        return desc;
    }
18722#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#addSerializer(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map, org.apache.cocoon.sitemap.SitemapExecutor.PipelineComponentDescription)
     */
    public PipelineComponentDescription addSerializer(ExecutionContext context,
            Map objectModel, PipelineComponentDescription desc) {
        return desc;
    }
18723#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#addTransformer(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map, org.apache.cocoon.sitemap.SitemapExecutor.PipelineComponentDescription)
     */
    public PipelineComponentDescription addTransformer(
            ExecutionContext context, Map objectModel,
            PipelineComponentDescription desc) {
        return desc;
    }
18724#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#leaveSitemap(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map)
     */
    public void leaveSitemap(ExecutionContext context, Map objectModel) {
        // nothing to do
    }
18725#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#redirectTo(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map, java.lang.String, boolean, boolean, boolean)
     */
    public String redirectTo(ExecutionContext context, Map objectModel, String uri, boolean createSession, boolean global, boolean permanent) {
        return uri;
    }
18726#/**
     * @see org.apache.cocoon.sitemap.SitemapExecutor#enteringPipeline(org.apache.cocoon.sitemap.ExecutionContext, java.util.Map, org.apache.cocoon.sitemap.SitemapExecutor.PipelineComponentDescription)
     */
    public PipelineComponentDescription enteringPipeline(ExecutionContext context, Map objectModel, PipelineComponentDescription desc) {
        return desc;
    }
18727#/**
     * Return <b>false</b> if this factory cannot create the requested object.
     */
    public boolean createObject(
        JXPathContext context,
        Pointer pointer,
        Object parent,
        String name,
        int index) 
    {
         //FIXME: JXPath automatically creates attributes if the element already exists,
         //but does not call this method if the element does not exit 

        addDOMElement((Node) parent, index, name);
        
        return true;
    }
18728#private void addDOMElement(Node parent, int index, String tag) {
        int pos = tag.indexOf(':');
        String prefix = null;
        if (pos != -1) {
            prefix = tag.substring(0, pos);
        }
        String uri = null;
        
        Node child = parent.getFirstChild();
        int count = 0;
        while (child != null) {
            if (child.getNodeName().equals(tag)) {
                count++;
            }
            child = child.getNextSibling();
        }

        Document doc = parent.getOwnerDocument();
        
        if (doc != null) {
            uri = getNamespaceURI((Element)parent, prefix);
        } else {
            if (parent instanceof Document) {
                doc = (Document)parent;
                if (prefix != null) {
                    throw new RuntimeException("Cannot map non-null prefix " +
                        "when creating a document element");    
                }
            } else { // Shouldn't happen (must be a DocumentType object)
                throw new RuntimeException("Node of class " +
                    parent.getClass().getName() + " has null owner document " +
                    "but is not a Document"); 
            }

        }

        // Keep inserting new elements until we have index + 1 of them
        while (count <= index) {
            Node newElement = doc.createElementNS(uri, tag);
            parent.appendChild(newElement);
            count++;
        }
    }
18729#public String getNamespaceURI(Element element, String prefix) {
        Node tmp = element;
        String nsAttr = prefix == null ? "xmlns" : "xmlns:" + prefix;
        
        while (tmp != null && tmp.getNodeType() == Node.ELEMENT_NODE) {
            element = (Element)tmp;
            
            // First test element prefixes
            if (prefix == null) {
                if (element.getPrefix() == null) {
                    return element.getNamespaceURI();
                }
            } else if(prefix.equals(element.getPrefix())) {
                return element.getNamespaceURI();
            }
            
            // Note: stupid DOM api returns "" when an attribute doesn't exist, so we use the Attr node.
            Attr nsAttrNode = ((Element)tmp).getAttributeNode(nsAttr);
            if (nsAttrNode != null) {
                return nsAttrNode.getValue();
            }
            tmp = tmp.getParentNode();
        }
        return null;
    }
18730#public boolean declareVariable(JXPathContext context, String name) {
        return false;
    }
18731#/**
     * @param settings
     */
    public void setSettings(Settings settings) {
        this.settings = settings;
    }
18732#/**
     * @param useCacheDirectory
     */
    public void setUseCacheDirectory(boolean useCacheDirectory) {
        this.useCacheDirectory = useCacheDirectory;
    }
18733#/**
     * @param useWorkDirectory
     */
    public void setUseWorkDirectory(boolean useWorkDirectory) {
        this.useWorkDirectory = useWorkDirectory;
    }
18734#public void init() throws Exception {
        enableLogging(new CLLoggerWrapper(this.logger));
        this.workDir = new File(settings.getWorkDirectory());
        this.cacheDir = new File(settings.getCacheDirectory());
        
        try {
            if (this.useCacheDirectory) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Using cache directory: " + cacheDir);
                }
                setDirectory(cacheDir);
            } else if (this.useWorkDirectory) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Using work directory: " + workDir);
                }
                setDirectory(workDir);
            } else if (this.directory != null) {
                this.directory = IOUtils.getContextFilePath(workDir.getPath(), this.directory);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Using directory: " + this.directory);
                }
                setDirectory(new File(this.directory));
            } else {
                try {
                    // Legacy: use working directory by default
                    setDirectory(workDir);
                } catch (IOException e) {
                    // Legacy: Always was ignored
                }
            }
        } catch (IOException e) {
            throw new Exception("Unable to set directory", e);
        }
    }
18735#//~ Methods ----------------------------------------------------------------

    /**
     * Name of the thread pool to use.
     * If not specified, defaults to 'daemon'.
     *
     * @param threadPool
     */
    public void setThreadPool(String threadPool) {
        this.threadPool = threadPool;
    }
18736#/**
     * Set the <code>RunnableManager</code>
     *
     * @param runnableManager
     */
    public void setRunnableManager(RunnableManager runnableManager) {
        this.runnableManager = runnableManager;
    }
18737#/**
     * The "checker" thread checks if memory is running low in the jvm.
     */
    public void run() {
        // Ignoring memory bursts in the first two invokations
        if (m_firstRun || m_secondRun) {
            super.inUse = super.memoryInUse();
            m_secondRun = m_firstRun;
            m_firstRun = false;
        }

        super.checkMemory();

        // Relaunch
        relaunch(super.interval);
    }
18738#/**
     * Start this instance using a default thread from the
     * <code>RunnableManager</code>
     */
    public void start() {
        relaunch(0);
    }
18739#/**
     * Does a delayed (re-)start of this instance using a default thread from
     * the<code>RunnableManager</code> with a delay
     *
     * @param delay the delay to apply before next run
     */
    private void relaunch(final long delay) {
        getLogger().debug("(Re-)Start CocoonStoreJanitor");
        this.runnableManager.execute(this.threadPool, this, delay, 0);
    }
18740#public Log getLogger() {
        return this.logger;
    }
18741#public void setLogger(Log l) {
        this.logger = l;
    }
18742#/**
     * Indicates how many objects will be held in the cache. When the number of
     * maxobjects has been reached. The last object in the cache will be thrown
     * out. (Default: 100 objects)
     * 
     * @param maxobjects
     */
    public void setMaxObjects(int maxobjects) {
        this.maxObjects = maxobjects;
    }
18743#/**
     * @param persistent
     */
    public void setUsePersistentStore(boolean persistent) {
        this.persistent = persistent;
    }
18744#/**
     * Set to keep objects persisted after container shutdown
     * 
     * @param persistentStore
     */
    public void setPersistentStore(Store persistentStore) {
        this.persistentStore = persistentStore;
    }
18745#/**
     * @param storeJanitor
     */
    public void setStoreJanitor(StoreJanitor storeJanitor) {
        this.storeJanitor = storeJanitor;
    }
18746#/**
     * Initialize the MRUMemoryStore.
     * 
     * @throws Exception
     * @exception ParameterException
     */
    public void init() throws Exception {
        if (this.maxObjects < 1) {
            throw new Exception("MRUMemoryStore maxobjects must be at least 1!");
        }

        if (this.persistent && this.persistentStore == null) {
            throw new Exception("The persistent store must be set if usePersistentStore is required");
        }

        this.persistent = this.persistentStore != null;

        this.cache = new Hashtable((int) (this.maxObjects * 1.2));
        this.mrulist = new LinkedList();
        if (this.storeJanitor != null) {
            this.storeJanitor.register(this);
        }
    }
18747#/**
     * Dispose the component
     */
    public void destroy() {
        getLogger().debug("Destroying component!");

        if (this.storeJanitor != null) {
            this.storeJanitor.unregister(this);
        }

        // save all cache entries to filesystem
        if (this.persistent) {
            getLogger().debug("Final cache size: " + this.cache.size());
            Enumeration enumer = this.cache.keys();
            while (enumer.hasMoreElements()) {
                Object key = enumer.nextElement();
                if (key == null) {
                    continue;
                }
                try {
                    Object value = this.cache.remove(key);
                    if (checkSerializable(value)) {
                        this.persistentStore.store(key, value);
                    }
                } catch (IOException ioe) {
                    getLogger().error("Error in dispose()", ioe);
                }
            }
        }
    }
18748#/**
     * Store the given object in a persistent state. It is up to the caller to
     * ensure that the key has a persistent state across different JVM
     * executions.
     * 
     * @param key
     *            The key for the object to store
     * @param value
     *            The object to store
     */
    public synchronized void store(Object key, Object value) {
        hold(key, value);
    }
18749#/**
     * This method holds the requested object in a HashMap combined with a
     * LinkedList to create the MRU. It also stores objects onto the filesystem
     * if configured.
     * 
     * @param key
     *            The key of the object to be stored
     * @param value
     *            The object to be stored
     */
    public synchronized void hold(Object key, Object value) {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Holding object in memory:");
            getLogger().debug("  key: " + key);
            getLogger().debug("  value: " + value);
        }
        /** ...first test if the max. objects in cache is reached... */
        while (this.mrulist.size() >= this.maxObjects) {
            /** ...ok, heapsize is reached, remove the last element... */
            free();
        }
        /** ..put the new object in the cache, on the top of course ... */
        this.cache.put(key, value);
        this.mrulist.remove(key);
        this.mrulist.addFirst(key);
    }
18750#/**
     * Get the object associated to the given unique key.
     * 
     * @param key
     *            The key of the requested object
     * @return the requested object
     */
    public synchronized Object get(Object key) {
        Object value = this.cache.get(key);
        if (value != null) {
            /** put the accessed key on top of the linked list */
            this.mrulist.remove(key);
            this.mrulist.addFirst(key);
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Found key: " + key.toString());
            }
            return value;
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("NOT Found key: " + key.toString());
        }

        /** try to fetch from filesystem */
        if (this.persistent) {
            value = this.persistentStore.get(key);
            if (value != null) {
                try {
                    if (!this.cache.containsKey(key)) {
                        hold(key, value);
                    }
                    return value;
                } catch (Exception e) {
                    getLogger().error("Error in get()!", e);
                }
            }
        }
        return null;
    }
18751#/**
     * Remove the object associated to the given key.
     * 
     * @param key
     *            The key of to be removed object
     */
    public synchronized void remove(Object key) {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Removing object from store");
            getLogger().debug("  key: " + key);
        }
        this.cache.remove(key);
        this.mrulist.remove(key);

        if (this.persistent && key != null) {
            this.persistentStore.remove(key);
        }
    }
18752#/**
     * Clear the Store of all elements
     */
    public synchronized void clear() {
        Enumeration enumer = this.cache.keys();
        while (enumer.hasMoreElements()) {
            Object key = enumer.nextElement();
            if (key == null) {
                continue;
            }
            remove(key);
        }
    }
18753#/**
     * Indicates if the given key is associated to a contained object.
     * 
     * @param key
     *            The key of the object
     * @return true if the key exists
     */
    public synchronized boolean containsKey(Object key) {
        if (this.persistent) {
            return this.cache.containsKey(key) || this.persistentStore.containsKey(key);
        } else {
            return this.cache.containsKey(key);
        }
    }
18754#/**
     * Returns the list of used keys as an Enumeration.
     * 
     * @return the enumeration of the cache
     */
    public synchronized Enumeration keys() {
        return this.cache.keys();
    }
18755#/**
     * Returns count of the objects in the store, or -1 if could not be
     * obtained.
     */
    public synchronized int size() {
        return this.cache.size();
    }
18756#/**
     * Frees some of the fast memory used by this store. It removes the last
     * element in the store.
     */
    public synchronized void free() {
        try {
            if (this.cache.size() > 0) {
                // This can throw NoSuchElementException
                Object key = this.mrulist.removeLast();
                Object value = this.cache.remove(key);
                if (value == null) {
                    getLogger().warn("Concurrency condition in free()");
                }

                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Freeing cache.");
                    getLogger().debug("  key: " + key);
                    getLogger().debug("  value: " + value);
                }

                if (this.persistent) {
                    // Swap object on fs.
                    if (checkSerializable(value)) {
                        try {
                            this.persistentStore.store(key, value);
                        } catch (Exception e) {
                            getLogger().error("Error storing object on fs", e);
                        }
                    }
                }
            }
        } catch (NoSuchElementException e) {
            getLogger().warn("Concurrency error in free()", e);
        } catch (Exception e) {
            getLogger().error("Error in free()", e);
        }
    }
18757#/**
     * This method checks if an object is serializable.
     * 
     * @param object
     *            The object to be checked
     * @return true if the object is storeable
     */
    private boolean checkSerializable(Object object) {
        return object instanceof java.io.Serializable;
    }
18758#/* (non-Javadoc)
     * @see org.apache.cocoon.components.store.impl.MRUMemoryStore#init()
     */
    public void init() throws Exception {
        super.init();
        if (this.persistent) {
            throw new Exception("A transient store cannot be backed by a persistent store.");
        }
    }
18759#/**
     * <li><code>directory</code> Specify an alternative location of the disk store.
     * @param directory Specify an alternative location of the disk store.
     */
    public void setDirectory(String directory) {
        this.directory = directory;
    }
18760#/**
     * <code>disk-persistent</code> Whether the disk store persists between restarts of
     * the Virtual Machine. The default value is true.
     * @param diskPersistent
     */
    public void setDiskPersistent(boolean diskPersistent) {
        this.diskPersistent = diskPersistent;
    }
18761#/**
     * <li><code>eternal</code> (true) - whether or not entries expire. When set to
     * <code>false</code> the <code>timeToLiveSeconds</code> and
     * <code>timeToIdleSeconds</code> parameters are used to determine when an
     * item expires.</li>
     * @param eternal
     */
    public void setEternal(boolean eternal) {
        this.eternal = eternal;
    }
18762#/**
     * <code>maxMemobjects</code> (10000) - The maximum number of in-memory objects.
     * @param maxMemObjects
     */
    public void setMaxMemObjects(int maxMemObjects) {
        this.maxMemObjects = maxMemObjects;
    }
18763#/**
     * <code>maxDiskObjects</code> (50000) - The maximum number of disc objects.
     * @param maxDiskObjects
     */
    public void setMaxDiskObjects(int maxDiskObjects) {
        this.maxDiskObjects = maxDiskObjects;
    }
18764#/**
     *  <li><code>overflow-to-disk</code> (true) - Whether to spool elements to disk after
     *   maxobjects has been exceeded.</li>
     * @param overflowToDisk
     */
    public void setOverflowToDisk(boolean overflowToDisk) {
        this.overflowToDisk = overflowToDisk;
    }
18765#/**
     * <li><code>timeToIdleSeconds</code> (0) - the maximum time between retrievals
     * of an entry. If the entry is not retrieved for this period, it is removed from the
     * cache.</li>
     * @param timeToIdleSeconds
     */
    public void setTimeToIdleSeconds(long timeToIdleSeconds) {
        this.timeToIdleSeconds = timeToIdleSeconds;
    }
18766#/**
     * <li><code>timeToLiveSeconds</code> (0) - how long an entry may live in the cache
     * before it is removed. The entry will be removed no matter how frequently it is retrieved.</li>
     * @param timeToLiveSeconds
     */
    public void setTimeToLiveSeconds(long timeToLiveSeconds) {
        this.timeToLiveSeconds = timeToLiveSeconds;
    }
18767#/**
     * <li><code>diskExpiryThreadIntervalSeconds</code> (120) - The number of seconds 
     * between runs of the disk expiry thread.</li>
     * @param diskExpiryThreadIntervalSeconds
     */
    public void setDiskExpiryThreadIntervalSeconds(int diskExpiryThreadIntervalSeconds) {
        this.diskExpiryThreadIntervalSeconds = diskExpiryThreadIntervalSeconds;
    }
18768#/**
     * <li><code>memoryStoreEvictionPolicy</code> (null) - Tone of LRU, LFU and FIFO. If 
     * null, it will be set to LRU.</li>
     * @param memoryStoreEvictionPolicy
     */    
    public void setMemoryStoreEvictionPolicy(MemoryStoreEvictionPolicy memoryStoreEvictionPolicy) {
        this.memoryStoreEvictionPolicy = memoryStoreEvictionPolicy;
    }
18769#/**
     * A notification service. Optionally null, in which case a new one with no registered listeners will be created.
     * @param registeredEventListeners
     */
    public void setRegisteredEventListeners(RegisteredEventListeners registeredEventListeners) {
        this.registeredEventListeners = registeredEventListeners;
    }
18770#/**
     * The BootstrapCacheLoader to use to populate the cache when it is first initialised. Null if none is required.
     * @param bootstrapCacheLoader
     */
    public void setBootstrapCacheLoader(BootstrapCacheLoader bootstrapCacheLoader) {
        this.bootstrapCacheLoader = bootstrapCacheLoader;
    }
18771#/**
     *  <li><code>use-cache-directory</code> (false) - If true the <i>cache-directory</i>
     *   context entry will be used as the location of the disk store. 
     *   Within the servlet environment this is set in web.xml.</li>
     * @param useCacheDirectory
     */
    public void setUseCacheDirectory(boolean useCacheDirectory) {
        this.useCacheDirectory = useCacheDirectory;
    }
18772#/**
     *  <li><code>use-work-directory</code> (false) - If true the <i>work-directory</i>
     *   context entry will be used as the location of the disk store.
     *   Within the servlet environment this is set in web.xml.</li>
     * @param useWorkDirectory
     */
    public void setUseWorkDirectory(boolean useWorkDirectory) {
        this.useWorkDirectory = useWorkDirectory;
    }
18773#/**
     * @param settings the settings to set
     */
    public void setSettings(Settings settings) {
        this.settings = settings;
    }
18774#/**
     * Use the {@link StoreJanitor} to take care of freeing memory.
     * @param storeJanitor
     */
    public void setStoreJanitor(StoreJanitor storeJanitor) {
        this.storeJanitor = storeJanitor;
    }
18775#public Log getLogger() {
        return this.logger;
    }
18776#public void setLogger(Log l) {
        this.logger = l;
    }
18777#/**
     * Sets the cache directory
     */
    private void setDirectory(final File directory) throws IOException  {
        // Save directory path prefix
        String directoryPath = getFullFilename(directory);
        directoryPath += File.separator;

        // If directory doesn't exist, create it anew
        if (!directory.exists()) {
            if (!directory.mkdir()) {
                throw new IOException("Error creating store directory '" + directoryPath + "': ");
            }
        }

        // Is given file actually a directory?
        if (!directory.isDirectory()) {
            throw new IOException("'" + directoryPath + "' is not a directory");
        }

        // Is directory readable and writable?
        if (!(directory.canRead() && directory.canWrite())) {
            throw new IOException("Directory '" + directoryPath + "' is not readable/writable");
        }
        this.diskStorePath = directoryPath;
    }
18778#/**
     * Get the complete filename corresponding to a (typically relative)
     * <code>File</code>.
     * This method accounts for the possibility of an error in getting
     * the filename's <i>canonical</i> path, returning the io/error-safe
     * <i>absolute</i> form instead
     *
     * @param file The file
     * @return The file's absolute filename
     */
    private static String getFullFilename(File file) {
        try {
            return file.getCanonicalPath();
        } catch (Exception e) {
            return file.getAbsolutePath();
        }
    }
18779#/**
     * Initialize the CacheManager and created the Cache.
     */
    public void init() throws Exception {
        this.workDir = new File(settings.getWorkDirectory());
        this.cacheDir = new File(settings.getCacheDirectory());

        try {
            if (this.useCacheDirectory) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Using cache directory: " + cacheDir);
                }
                setDirectory(cacheDir);
            } else if (this.useWorkDirectory) {
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Using work directory: " + workDir);
                }
                setDirectory(workDir);
            } else if (this.directory != null) {
                this.directory = IOUtils.getContextFilePath(workDir.getPath(), this.directory);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Using directory: " + this.directory);
                }
                setDirectory(new File(this.directory));
            } else {
                try {
                    // Legacy: use working directory by default
                    setDirectory(this.workDir);
                } catch (IOException e) {
                    // EMPTY
                }
            }
        } catch (IOException e) {
            throw new Exception("Unable to set directory", e);
        }
        
        String config = org.apache.commons.io.IOUtils.toString(Thread.currentThread().getContextClassLoader().getResourceAsStream(CONFIG_FILE));
        config = StringUtils.replace(config, "${diskstorepath}", this.diskStorePath);        
        this.cacheManager = CacheManager.create(new ByteArrayInputStream(config.getBytes("utf-8")));        
        if (this.cacheManager.getCache(DEFAULT_CACHE_NAME) != null) {
            instanceCount++;
            this.cacheName = DEFAULT_CACHE_NAME + "-" + instanceCount;
        } else {
            this.cacheName = DEFAULT_CACHE_NAME;
        }          
                
        // read configuration - we have to replace the diskstorepath in the configuration
        // as the diskStorePath argument of the Cache constructor is ignored and set by the
        // CacheManager! (see bug COCOON-1927)
        this.cache = new Cache(
                        this.cacheName,
                        this.maxMemObjects,
                        this.memoryStoreEvictionPolicy,
                        this.overflowToDisk,
                        this.diskStorePath,
                        this.eternal,
                        this.timeToLiveSeconds,
                        this.timeToIdleSeconds,
                        this.diskPersistent,
                        this.diskExpiryThreadIntervalSeconds,
                        this.registeredEventListeners,
                        this.bootstrapCacheLoader,
                        this.maxDiskObjects);
        
        this.cacheManager.addCache(this.cache);
        if (this.storeJanitor != null) {
            storeJanitor.register(this);
        }
        getLogger().info("EHCache cache '" + this.cacheName + "' initialized");
    }
18780#/**
     * Shutdown the CacheManager.
     */
    public void destroy() {
        if (this.storeJanitor != null) {
            storeJanitor.unregister(this);
        }        
        /*
         * EHCache can be a bitch when shutting down. Basically every cache registers
         * a hook in the Runtime for every persistent cache, that will be executed when
         * the JVM exit. It might happen (though) that we are shutting down Cocoon
         * because of the same event (someone sending a TERM signal to the VM).
         * So what we need to do here is to check if the cache itself is still alive,
         * then we're going to shutdown EHCache entirely (if there are other caches open
         * they will be shut down as well), if the cache is not alive, either another
         * instance of this called the shutdown method on the CacheManager (thanks) or
         * otherwise the hook had time to run before we got here.
         */
        synchronized (this.cache) {
            if (Status.STATUS_ALIVE == this.cache.getStatus()) {
                try {
                    getLogger().info("Disposing EHCache cache '" + this.cacheName + "'.");
                    this.cacheManager.shutdown();
                } catch (IllegalStateException e) {
                    getLogger().error("Error disposing EHCache cache '" + this.cacheName + "'.", e);
                }
            } else {
                getLogger().info("EHCache cache '" + this.cacheName + "' already disposed.");
            }
        }
    }
18781#// ---------------------------------------------------- Store implementation

    /**
     * @see org.apache.excalibur.store.Store#free()
     */
    public Object get(Object key) {
        Object value = null;
        try {
            final Element element = this.cache.get((Serializable) key);
            if (element != null) {
                value = element.getValue();
            }
        } catch (CacheException e) {
            getLogger().error("Failure retrieving object from store", e);
        }
        if (getLogger().isDebugEnabled()) {
            if (value != null) {
                getLogger().debug("Found key: " + key);
            } else {
                getLogger().debug("NOT Found key: " + key);
            }
        }
        return value;
    }
18782#/**
     * @see org.apache.excalibur.store.Store#free()
     */
    public void store(Object key, Object value) throws IOException {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Store object " + value + " with key "+ key);
        }

        // without these checks we get cryptic "ClassCastException" messages
        if (!(key instanceof Serializable)) {
            throw new IOException("Key of class " + key.getClass().getName() + " is not Serializable");
        }
        if (!(value instanceof Serializable)) {
            throw new IOException("Value of class " + value.getClass().getName() + " is not Serializable");            
        }

        final Element element = new Element((Serializable) key, (Serializable) value);
        this.cache.put(element);
    }
18783#/**
     * @see org.apache.excalibur.store.Store#free()
     */
    public void free() {
        try {
            final List keys = this.cache.getKeysNoDuplicateCheck();
            if (!keys.isEmpty()) {
                // TODO find a way to get to the LRU one.
                final Serializable key = (Serializable) keys.get(0);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Freeing cache");
                    getLogger().debug("key: " + key);
                    getLogger().debug("value: " + this.cache.get(key));
                }
                if (!this.cache.remove(key)) {
                    if (getLogger().isInfoEnabled()) {
                        getLogger().info("Concurrency condition in free()");
                    }
                }
            }
        } catch (CacheException e) {
            if (getLogger().isWarnEnabled()) {
                getLogger().warn("Error in free()", e);
            }
        }
    }
18784#/**
     * @see org.apache.excalibur.store.Store#remove(java.lang.Object)
     */
    public void remove(Object key) {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Removing item " + key);
        }
        this.cache.remove((Serializable) key);
    }
18785#/**
     * @see org.apache.excalibur.store.Store#clear()
     */
    public void clear() {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Clearing the store");
        }
        this.cache.removeAll();
    }
18786#/**
     * @see org.apache.excalibur.store.Store#containsKey(java.lang.Object)
     */
    public boolean containsKey(Object key) {
        try {
            return this.cache.get((Serializable) key) != null;
        } catch (CacheException e) {
            getLogger().error("Failure retrieving object from store",e);
        }
        return false;
    }
18787#/**
     * @see org.apache.excalibur.store.Store#keys()
     */
    public Enumeration keys() {
        List keys;
        try {
            keys = this.cache.getKeys();
        } catch (CacheException e) {
            if (getLogger().isWarnEnabled()) {
                getLogger().warn("Error while getting cache keys", e);
            }
            keys = Collections.EMPTY_LIST;
        }
        return Collections.enumeration(keys);
    }
18788#/**
     * @see org.apache.excalibur.store.Store#size()
     */
    public int size() {
        try {
            // cast to int due ehcache implementation returns a long instead of int.
            // See: http://ehcache.sourceforge.net/javadoc/net/sf/ehcache/Cache.html#getMemoryStoreSize()
            return (int)this.cache.getMemoryStoreSize();
        } catch (IllegalStateException e) {
            if (getLogger().isWarnEnabled()) {
                getLogger().warn("Error while getting cache size", e);
            }
            return 0;
        }
    }
18789#/* (non-Javadoc)
     * @see org.apache.cocoon.components.store.impl.MRUMemoryStore#init()
     */
    public void init() throws Exception {
        super.init();
        if (!this.persistent) {
            throw new Exception("A persistent store must be backed by a persistent store.");
        }
    }
18790#/**
     * How much free memory shall be available in the jvm?
     * If not specified, defaults to 1Mb.
     * 
     * @param freeMemory
     */
    public void setFreeMemory(int freeMemory) {
        this.minFreeMemory = freeMemory;
    }
18791#/**
     * How much memory at max jvm can consume?
     * The default max heapsize for Sun's JVM is (almost) 64Mb,
     * can be increased by specifying -Xmx command line parameter.
     * If not specified, defaults to 66600000 bytes.
     *
     * @param heapSize
     */
    public void setHeapSize(int heapSize) {
        this.maxHeapSize = heapSize;
    }
18792#/**
     * How often shall the cleanup thread check memory?
     * If not specified, defaults to 10 seconds.
     * 
     * @param cleanupThreadInterval
     */
    public void setCleanupThreadInterval(int cleanupThreadInterval) {
        this.threadInterval = cleanupThreadInterval * 1000;
    }
18793#/**
     * Experimental adaptive algorithm for cleanup interval
     *
     * @param adaptiveThreadInterval
     */
    public void setAdaptiveThreadInterval(boolean adaptiveThreadInterval) {
        this.adaptiveThreadInterval = adaptiveThreadInterval;
    }
18794#/**
     * What percent of the store elements shall be dropped on low memory?
     * If not specified, defaults to 10%
     * 
     * @param percentToFree
     */
    public void setPercentToFree(double percentToFree) {
        this.fraction = percentToFree / 100.0D;
    }
18795#/**
     * Shall garbage collector be invoked on low memory?
     * If not specified, defaults to false.
     * 
     * @param invokeGC
     */
    public void setInvokeGC(boolean invokeGC) {
        this.invokeGC = invokeGC;
    }
18796#/**
     * What should be the priority of the cleanup thread?
     * This property is used only by older implementation of the janitor.
     * New implementation uses centrally configured thread pool (see
     * thread-pools element below).
     * 
     * @param threadPriority
     */
    public void setThreadPriority(int threadPriority) {
        this.priority = threadPriority;
    }
18797#public void setFreeingAlgorithm(String algorithm) {
        this.freeingAlgorithm = algorithm;
    }
18798#public Log getLogger() {
        return this.logger;
    }
18799#public void setLogger(Log l) {
        this.logger = l;
    }
18800#/**
     * Initialize the StoreJanitorImpl.
     * @throws Exception 
     */
    public void init() throws Exception {
        this.jvm = Runtime.getRuntime();
        if (this.priority == -1) {
            this.priority = Thread.currentThread().getPriority();
        }

        if (getMinFreeMemory() < 1) {
            throw new Exception("StoreJanitorImpl freememory parameter has to be greater then 1");
        }
        if (getMaxHeapSize() < 1) {
            throw new Exception("StoreJanitorImpl heapsize parameter has to be greater then 1");
        }
        if (getThreadInterval() < 1) {
            throw new Exception("StoreJanitorImpl cleanupthreadinterval parameter has to be greater then 1");
        }
        if (getPriority() < 1 || getPriority() > 10) {
            throw new Exception("StoreJanitorImpl threadpriority has to be between 1 and 10");
        }
        if (fraction > 1 && fraction < 0.01) {
            throw new Exception("StoreJanitorImpl percentToFree, has to be between 1 and 100");
        }
        if (!(this.freeingAlgorithm.equals(ALG_ROUND_ROBIN) || this.freeingAlgorithm.equals(ALG_ALL_STORES))) {
            throw new Exception("StoreJanitorImpl freeingAlgorithm, has to be 'round-robin' or 'all-stores'. '" 
                    + this.freeingAlgorithm + "' is not supported.");
        }

        this.storelist = new ArrayList();

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("minimum free memory=" + getMinFreeMemory());
            getLogger().debug("heapsize=" + getMaxHeapSize());
            getLogger().debug("thread interval=" + getThreadInterval());
            getLogger().debug("adaptivethreadinterval=" + getAdaptiveThreadInterval());
            getLogger().debug("priority=" + getPriority());
            getLogger().debug("percent=" + fraction * 100);
            getLogger().debug("invoke gc=" + this.invokeGC);
        }

        doStart();
    }
18801#private void doStart() throws Exception {
        this.doRun = true;
        Thread checker = new Thread(this);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Intializing checker thread");
        }
        checker.setPriority(getPriority());
        checker.setDaemon(true);
        checker.setName("checker");
        checker.start();
    }
18802#private void doStop() {
        this.doRun = false;
    }
18803#public void destroy() {
        doStop();
    }
18804#/**
     * The "checker" thread loop.
     */
    public void run() {
        this.inUse = memoryInUse();
        while (this.doRun) {
            checkMemory();

            // Sleep
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Sleeping for " + this.interval + "ms");
            }
            try {
                Thread.sleep(this.interval);
            } catch (InterruptedException ignore) {
                /* ignored */
            }

            // Ignore change in memory during the first run (startup)
            if (this.firstRun) {
                this.firstRun = false;
                this.inUse = memoryInUse();
            }
        }
    }
18805#/**
     * The "checker" thread checks if memory is running low in the jvm.
     */
    protected void checkMemory() {
        if (getAdaptiveThreadInterval()) {
            // Monitor the rate of change of heap in use.
            long change = memoryInUse() - inUse;
            long rateOfChange = longDiv(change * 1000, interval); // bps.
            if (maxRateOfChange < rateOfChange) {
                maxRateOfChange = (maxRateOfChange + rateOfChange) / 2;
            }
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Waking after " + interval + "ms, in use change "
                                  + change + "b to " + memoryInUse() + "b, rate "
                                  + rateOfChange + "b/sec, max rate " + maxRateOfChange + "b/sec");
            }
        }

        // Amount of memory used is greater than heapsize
        if (memoryLow()) {
            if (this.invokeGC) {
                freePhysicalMemory();
            }

            synchronized (this) {
                if (!this.invokeGC
                        || (memoryLow() && getStoreList().size() > 0)) {

                    freeMemory();
                    setIndex(getIndex() + 1);
                }
            }
        }

        if (getAdaptiveThreadInterval()) {
            // Calculate sleep interval based on the change rate and free memory left
            interval = minTimeToFill(maxRateOfChange) * 1000 / 2;
            if (interval > this.threadInterval) {
                interval = this.threadInterval;
            } else if (interval < this.minThreadInterval) {
                interval = this.minThreadInterval;
            }
            inUse = memoryInUse();
        } else {
            interval = this.threadInterval;
        }
    }
18806#/**
     * Method to check if memory is running low in the JVM.
     *
     * @return true if memory is low
     */
    private boolean memoryLow() {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("JVM Memory total: " + getJVM().totalMemory()
                              + ", free: " + getJVM().freeMemory());
        }

        if ((getJVM().totalMemory() >= getMaxHeapSize())
                && (getJVM().freeMemory() < getMinFreeMemory())) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Memory is low!");
            }
            return true;
        } else {
            return false;
        }
    }
18807#/**
     * Calculate the JVM memory in use now.
     *
     * @return memory in use.
     */
    protected long memoryInUse() {
        return jvm.totalMemory() - jvm.freeMemory();
    }
18808#/**
     * Calculate amount of time needed to fill all free memory with given
     * fill rate.
     *
     * @param rate memory fill rate in time per bytes
     * @return amount of time to fill all the memory with given fill rate
     */
    private long minTimeToFill(long rate) {
        return longDiv(jvm.freeMemory(), rate);
    }
18809#private long longDiv(long top, long bottom) {
        try {
            return top / bottom;
        } catch (Exception e) {
            return top > 0 ? Long.MAX_VALUE : Long.MIN_VALUE;
        }
    }
18810#/**
     * This method register the stores
     *
     * @param store the store to be registered
     */
    public synchronized void register(Store store) {
        getStoreList().add(store);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Registered store instance " + store + ". Stores now: "
                              + getStoreList().size());
        }
    }
18811#/**
     * This method unregister the stores
     *
     * @param store the store to be unregistered
     */
    public synchronized void unregister(Store store) {
        getStoreList().remove(store);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Unregistered store instance " + store + ". Stores now: "
                              + getStoreList().size());
        }
    }
18812#/**
     * This method return a java.util.Iterator of every registered stores
     *
     * <i>The iterators returned is fail-fast: if list is structurally
     * modified at any time after the iterator is created, in any way, the
     * iterator will throw a ConcurrentModificationException.  Thus, in the
     * face of concurrent modification, the iterator fails quickly and
     * cleanly, rather than risking arbitrary, non-deterministic behavior at
     * an undetermined time in the future.</i>
     *
     * @return a java.util.Iterator
     */
    public Iterator iterator() {
        return getStoreList().iterator();
    }
18813#/**
     * Free configured percentage of objects from stores
     * based on selected algorithm.
     */
    private void freeMemory() {
        try {
            // What algorithm was selected?

            // Option 1: Downsize all registered stores
            if (this.freeingAlgorithm.equals(ALG_ALL_STORES)) {
                for (Iterator i = iterator(); i.hasNext(); ) {
                    removeStoreObjects((Store) i.next());
                }

                return;
            }

            // Option 2: Default to Round Robin
            // Determine the store to clear this time around.
            if (getIndex() < getStoreList().size()) {
                if (getIndex() == -1) {
                    setIndex(0);
                }
            } else {
                // Store list changed (one or more store has been removed).
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Restarting from the beginning");
                }
                setIndex(0);
            }

            // Remove the objects from this store
            removeStoreObjects((Store) getStoreList().get(getIndex()));

        } catch (Exception e) {
            getLogger().error("Error in freeMemory()", e);
        } catch (OutOfMemoryError e) {
            getLogger().error("OutOfMemoryError in freeMemory()");
        }
    }
18814#/**
     * This method clears the configured amount of objects from
     * the provided store
     *
     * @param store the Store from which to release the objects
     */
    private void removeStoreObjects(Store store) {
        // Calculate how many objects to release from the store
        int limit = calcToFree(store);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Freeing " + limit + " items from store " + store + " with "
                              + store.size() + " items.");
        }

        // Remove the calculated number of objects from the current store
        for (int i = 0; i < limit; i++) {
            try {
                store.free();
            } catch (OutOfMemoryError e) {
                getLogger().error("OutOfMemoryError while releasing an object from the store.");
            }
        }
    }
18815#/**
     * This method calculates the number of items to free
     * from the store.
     *
     * @param store the Store which was selected as a victim
     * @return number of items to be removed
     */
    private int calcToFree(Store store) {
        int cnt = store.size();
        if (cnt < 0) {
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Unknown size of the store: " + store);
            }
            return 0;
        }

        final int res = (int) (cnt * fraction);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Calculating size for store " + store + " with size " + cnt + ": " + res);
        }

        return res;
    }
18816#/**
     * This method forces the garbage collector
     */
    private void freePhysicalMemory() {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Invoking GC. Memory total: "
                              + getJVM().totalMemory() + ", free: "
                              + getJVM().freeMemory());
        }

        getJVM().runFinalization();
        getJVM().gc();

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("GC complete. Memory total: "
                              + getJVM().totalMemory() + ", free: "
                              + getJVM().freeMemory());
        }
    }
18817#private int getMinFreeMemory() {
        return this.minFreeMemory;
    }
18818#private int getMaxHeapSize() {
        return this.maxHeapSize;
    }
18819#private int getPriority() {
        return this.priority;
    }
18820#private int getThreadInterval() {
        return this.threadInterval;
    }
18821#private boolean getAdaptiveThreadInterval() {
        return this.adaptiveThreadInterval;
    }
18822#private Runtime getJVM() {
        return this.jvm;
    }
18823#private ArrayList getStoreList() {
        return this.storelist;
    }
18824#private int getIndex() {
        return this.index;
    }
18825#private void setIndex(int _index) {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Setting index=" + _index);
        }
        this.index = _index;
    }
18826#/**
     * Set the daemon mode of created <code>Thread</code>s should have
     *
     * @param isDaemon Whether new {@link Thread}s should run as daemons.
     */
    void setDaemon( boolean isDaemon );
18827#/**
     * Get the daemon mode created <code>Thread</code>s will have
     *
     * @return Whether new {@link Thread}s should run as daemons.
     */
    boolean isDaemon();
18828#/**
     * Set the priority newly created <code>Thread</code>s should have
     *
     * @param priority One of {@link Thread#MIN_PRIORITY}, {@link
     *        Thread#NORM_PRIORITY}, {@link Thread#MAX_PRIORITY}
     */
    void setPriority( int priority );
18829#/**
     * Get the priority newly created <code>Thread</code>s will have
     *
     * @return One of {@link Thread#MIN_PRIORITY}, {@link
     *         Thread#NORM_PRIORITY}, {@link Thread#MAX_PRIORITY}
     */
    int getPriority();
18830#/**
     * Create a new Thread for a {@link Runnable} command
     *
     * @param command The <code>Runnable</code>
     *
     * @return new <code>Thread</code>
     */
    Thread newThread( Runnable command );
18831#// ~ Methods
    // ----------------------------------------------------------------

    /**
     * Gets the block policy
     *
     * @return Returns the blockPolicy.
     */
    String getBlockPolicy();
18832#/**
     * Gets the maximum queue size
     *
     * @return maximum size of the queue (0 if isQueued() == false)
     */
    int getMaxQueueSize();
18833#/**
     * Gets the name of the thread pool
     *
     * @return name of the thread pool
     */
    String getName();
18834#/**
     * Gets the priority used to create Threads
     *
     * @return {@link Thread#MIN_PRIORITY}, {@link Thread#NORM_PRIORITY},
     *         or {@link Thread#MAX_PRIORITY}
     */
    int getPriority();
18835#/**
     * Gets the queue size of the thread pool
     *
     * @return current size of the queue (0 if isQueued() == false)
     */
    int getQueueSize();
18836#/**
     * Whether this DefaultThreadPool has a queue
     *
     * @return Returns the m_isQueued.
     */
    boolean isQueued();
18837#/**
     * Execute a command
     *
     * @param command
     *                The {@link Runnable} to execute
     *
     * @throws InterruptedException
     *                 In case of interruption
     */
    void execute(Runnable command) throws InterruptedException;
18838#/**
     * Returns true if shutdown is graceful
     *
     * @return Returns the shutdownGraceful.
     */
    boolean isShutdownGraceful();
18839#/**
     * Gets the shutdownWaitTime in milliseconds
     *
     * @return Returns the shutdownWaitTimeMs.
     */
    int getShutdownWaitTimeMs();
18840#/**
     * Gets the keepAliveTime in milliseconds
     *
     * @return the keepAliveTime
     */
    long getKeepAliveTime();
18841#/**
     * Gets the maximum pool size
     *
     * @return the maxPoolSize
     */
    int getMaxPoolSize();
18842#/**
     * Gets the minimum pool size
     *
     * @return the minPoolSize
     */
    int getMinPoolSize();
18843#/**
     * Returns true if thread runs as daemon
     *
     * @return the daemon
     */
    boolean isDaemon();
18844#/**
     * Returns true if a shutDown method has succeeded in terminating all
     * threads
     *
     * @return Whether a shutDown method has succeeded in terminating all
     *         threads
     */
    boolean isTerminatedAfterShutdown();
18845#/**
     * Create a shared ThreadPool with a specific {@link ThreadFactory}
     *
     * @param name The name of the thread pool
     * @param queueSize The size of the queue
     * @param maxPoolSize The maximum number of threads
     * @param minPoolSize The maximum number of threads
     * @param priority The priority of threads created by this pool. This is
     *        one of {@link Thread#MIN_PRIORITY}, {@link
     *        Thread#NORM_PRIORITY}, or {@link Thread#MAX_PRIORITY}
     * @param isDaemon Whether or not thread from the pool should run in daemon
     *        mode
     * @param keepAliveTime How long should a thread be alive for new work to
     *        be done before it is GCed
     * @param blockPolicy What's the blocking policy is resources are exhausted
     * @param shutdownGraceful Should we wait for the queue to finish all
     *        pending commands?
     * @param shutdownWaitTime After what time a normal shutdown should take
     *        into account if a graceful shutdown has not come to an end
     */
    ThreadPool createPool( String name,
                     int queueSize,
                     int maxPoolSize,
                     int minPoolSize,
                     int priority,
                     final boolean isDaemon,
                     long keepAliveTime,
                     String blockPolicy,
                     boolean shutdownGraceful,
                     int shutdownWaitTime );
18846#/**
     * Create a private ThreadPool with a specific {@link ThreadFactory}
     *
     * @param queueSize The size of the queue
     * @param maxPoolSize The maximum number of threads
     * @param minPoolSize The maximum number of threads
     * @param priority The priority of threads created by this pool. This is
     *        one of {@link Thread#MIN_PRIORITY}, {@link
     *        Thread#NORM_PRIORITY}, or {@link Thread#MAX_PRIORITY}
     * @param isDaemon Whether or not thread from the pool should run in daemon
     *        mode
     * @param keepAliveTime How long should a thread be alive for new work to
     *        be done before it is GCed
     * @param blockPolicy What's the blocking policy is resources are exhausted
     * @param shutdownGraceful Should we wait for the queue to finish all
     *        pending commands?
     * @param shutdownWaitTime After what time a normal shutdown should take
     *        into account if a graceful shutdown has not come to an end
     *
     * @return The newly created <code>ThreadPool</code>
     */
    ThreadPool createPool( int queueSize,
                           int maxPoolSize,
                           int minPoolSize,
                           int priority,
                           final boolean isDaemon,
                           long keepAliveTime,
                           String blockPolicy,
                           boolean shutdownGraceful,
                           int shutdownWaitTime );
18847#/**
     * Get a thread pool
     * @param name The name of the thread pool or null for the default pool.
     */
    ThreadPool getPool( String name);
18848#/**
     * Immediate Execution of a runnable in the background
     *
     * @param command The command to execute
     */
    void execute( Runnable command );
18849#/**
     * Immediate Execution of a runnable in the background
     *
     * @param command The command to execute
     * @param delay The delay before first run
     */
    void execute( Runnable command,
                  long delay );
18850#/**
     * Immediate Execution of a runnable in the background
     *
     * @param command The command to execute
     * @param delay The delay before first run
     * @param interval The interval of repeated runs
     */
    void execute( Runnable command,
                  long delay,
                  long interval );
18851#/**
     * Immediate Execution of a runnable in the background
     *
     * @param threadPoolName The thread pool to use
     * @param command The command to execute
     */
    void execute( String threadPoolName,
                  Runnable command );
18852#/**
     * Immediate Execution of a runnable in the background
     *
     * @param threadPoolName The thread pool to use
     * @param command The command to execute
     * @param delay The delay before first run
     */
    void execute( String threadPoolName,
                  Runnable command,
                  long delay );
18853#/**
     * Delayed and repeated Execution of a runnable in the background
     *
     * @param threadPoolName The thread pool to use
     * @param command The command to execute
     * @param delay The delay before first run
     * @param interval The interval of repeated runs
     */
    void execute( String threadPoolName,
                  Runnable command,
                  long delay,
                  long interval );
18854#/**
     * Remove a {@link Runnable} from the execution stack
     *
     * @param command The command to be removed
     */
    void remove( Runnable command );
18855#//~ Methods ----------------------------------------------------------------

    /**
     * Set the isDaemon property
     *
     * @param isDaemon Whether or not new <code>Thread</code> should run as
     *        daemons.
     */
    public void setDaemon( boolean isDaemon ) {
        m_isDaemon = isDaemon;
    }
18856#/**
     * Get the isDaemon property
     *
     * @return Whether or not new <code>Thread</code> will run as daemons.
     */
    public boolean isDaemon() {
        return m_isDaemon;
    }
18857#/**
     * Set the priority newly created <code>Thread</code>s should have
     *
     * @param priority One of {@link Thread#MIN_PRIORITY}, {@link
     *        Thread#NORM_PRIORITY}, {@link Thread#MAX_PRIORITY}
     */
    public void setPriority( final int priority ) {
        if( ( Thread.MAX_PRIORITY == priority ) ||
            ( Thread.MIN_PRIORITY == priority ) ||
            ( Thread.NORM_PRIORITY == priority ) ) {
            m_priority = priority;
        }
    }
18858#/**
     * Get the priority newly created <code>Thread</code>s will have
     *
     * @return One of {@link Thread#MIN_PRIORITY}, {@link
     *         Thread#NORM_PRIORITY}, {@link Thread#MAX_PRIORITY}
     */
    public int getPriority() {
        return m_priority;
    }
18859#/**
     * Create a new Thread for Runnable
     *
     * @param command The {@link Runnable}
     *
     * @return A new Thread instance
     */
    public Thread newThread( final Runnable command ) {
        final Thread thread = new Thread( command );
        thread.setPriority( m_priority );
        thread.setDaemon( m_isDaemon );

        return thread;
    }
18860#//~ Constructors -----------------------------------------------------------

    /**
     * Create a buffer with the current default capacity.
     */
    public BoundedQueue() {
        super();
    }
18861#/**
     * Create a BoundedQueue with the given capacity.
     *
     * @param capacity The capacity
     *
     * @exception IllegalArgumentException if capacity less or equal to zero
     */
    public BoundedQueue( int capacity )
    throws IllegalArgumentException {
        super( capacity );
    }
18862#//~ Methods ----------------------------------------------------------------

    /**
     * DOCUMENT ME!
     *
     * @return current size of queue.
     */
    public int getQueueSize() {
        return usedSlots_;
    }
18863#// ~ Methods
    // ----------------------------------------------------------------

    public Log getLogger() {
        return this.logger;
    }
18864#public void setLogger(Log l) {
        this.logger = l;
    }
18865#/**
     * Initialize
     */
    public void init() throws Exception {
        if (workerThreadPools != null) {
            final Iterator iter = workerThreadPools.keySet().iterator();
            while (iter.hasNext()) {
                final String key = (String) iter.next();
                final ThreadPool pool = (ThreadPool) workerThreadPools.get(key);
                synchronized (pools) {
                    pools.put(pool.getName(), pool);
                }
            }
        }

        // Check if a "default" pool has been created
        final ThreadPool defaultThreadPool = (ThreadPool) pools.get(ThreadPool.DEFAULT_THREADPOOL_NAME);

        if (null == defaultThreadPool) {
            createPool(ThreadPool.DEFAULT_THREADPOOL_NAME, ThreadPool.DEFAULT_QUEUE_SIZE,
                            ThreadPool.DEFAULT_MAX_POOL_SIZE, ThreadPool.DEFAULT_MIN_POOL_SIZE,
                            convertPriority(ThreadPool.DEFAULT_THREAD_PRIORITY), ThreadPool.DEFAULT_DAEMON_MODE,
                            ThreadPool.DEFAULT_KEEP_ALIVE_TIME, ThreadPool.DEFAULT_BLOCK_POLICY,
                            ThreadPool.DEFAULT_SHUTDOWN_GRACEFUL, ThreadPool.DEFAULT_SHUTDOWN_WAIT_TIME);
        }
        // now start
        this.start();
    }
18866#/**
     * Create a shared ThreadPool
     *
     * @param name
     *            The name of the thread pool
     * @param queueSize
     *            The size of the queue
     * @param maxPoolSize
     *            The maximum number of threads
     * @param minPoolSize
     *            The maximum number of threads
     * @param priority
     *            The priority of threads created by this pool. This is one of
     *            {@link Thread#MIN_PRIORITY}, {@link Thread#NORM_PRIORITY},
     *            or {@link Thread#MAX_PRIORITY}
     * @param isDaemon
     *            Whether or not thread from the pool should run in daemon mode
     * @param keepAliveTime
     *            How long should a thread be alive for new work to be done
     *            before it is GCed
     * @param blockPolicy
     *            What's the blocking policy is resources are exhausted
     * @param shutdownGraceful
     *            Should we wait for the queue to finish all pending commands?
     * @param shutdownWaitTime
     *            After what time a normal shutdown should take into account if
     *            a graceful shutdown has not come to an end
     *
     * @throws IllegalArgumentException
     *             If the pool already exists
     */
    public ThreadPool createPool(final String name, final int queueSize, final int maxPoolSize, final int minPoolSize,
                    final int priority, final boolean isDaemon, final long keepAliveTime, final String blockPolicy,
                    final boolean shutdownGraceful, final int shutdownWaitTimeMs) {
        if (null != pools.get(name)) {
            throw new IllegalArgumentException("ThreadPool \"" + name + "\" already exists");
        }

        final DefaultThreadPool pool = new DefaultThreadPool();
        pool.setName(name);
        pool.setQueueSize(queueSize);
        pool.setMaxPoolSize(maxPoolSize);
        pool.setMinPoolSize(minPoolSize);
        pool.setPriority(priority);
        pool.setDaemon(isDaemon);
        pool.setBlockPolicy(blockPolicy);
        pool.setShutdownGraceful(shutdownGraceful);
        pool.setShutdownWaitTimeMs(shutdownWaitTimeMs);
        synchronized (pools) {
            pools.put(pool.getName(), pool);
        }
        return pool;
    }
18867#/**
     * Create a private ThreadPool
     *
     * @param queueSize
     *            The size of the queue
     * @param maxPoolSize
     *            The maximum number of threads
     * @param minPoolSize
     *            The maximum number of threads
     * @param priority
     *            The priority of threads created by this pool. This is one of
     *            {@link Thread#MIN_PRIORITY}, {@link Thread#NORM_PRIORITY},
     *            or {@link Thread#MAX_PRIORITY}
     * @param isDaemon
     *            Whether or not thread from the pool should run in daemon mode
     * @param keepAliveTime
     *            How long should a thread be alive for new work to be done
     *            before it is GCed
     * @param blockPolicy
     *            What's the blocking policy is resources are exhausted
     * @param shutdownGraceful
     *            Should we wait for the queue to finish all pending commands?
     * @param shutdownWaitTime
     *            After what time a normal shutdown should take into account if
     *            a graceful shutdown has not come to an end
     *
     * @return A newly created <code>ThreadPool</code>
     */
    public ThreadPool createPool(final int queueSize, final int maxPoolSize, final int minPoolSize, final int priority,
                    final boolean isDaemon, final long keepAliveTime, final String blockPolicy,
                    final boolean shutdownGraceful, final int shutdownWaitTime) {
        final DefaultThreadPool pool = new DefaultThreadPool();
        final String name = "anon-" + pool.hashCode();
        pool.setName(name);
        pool.setQueueSize(queueSize);
        pool.setMaxPoolSize(maxPoolSize);
        pool.setMinPoolSize(minPoolSize);
        pool.setPriority(priority);
        pool.setDaemon(isDaemon);
        pool.setKeepAliveTime(keepAliveTime);
        pool.setBlockPolicy(blockPolicy);
        pool.setShutdownGraceful(shutdownGraceful);
        synchronized (pools) {
            pools.put(pool.getName(), pool);
        }

        return pool;
    }
18868#/**
     * @see org.apache.cocoon.thread.RunnableManager#getPool(java.lang.String)
     */
    public ThreadPool getPool(String name) {
        if ( name == null ) {
            name = ThreadPool.DEFAULT_THREADPOOL_NAME;
        }
        synchronized (pools) {
            return (ThreadPool)pools.get(name);
        }
    }
18869#/**
     * Destroy
     */
    public void destroy() throws Exception {
        this.stop();
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Disposing all thread pools");
        }

        for (final Iterator i = pools.keySet().iterator(); i.hasNext();) {
            final String poolName = (String) i.next();
            final DefaultThreadPool pool = (DefaultThreadPool) pools.get(poolName);

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Disposing thread pool " + pool.getName());
            }

            pool.shutdown();

            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Thread pool " + pool.getName() + " disposed");
            }
        }

        try {
            pools.clear();
        } catch (final Throwable t) {
            getLogger().error("Cannot dispose", t);
        }
    }
18870#/**
     * Run a {@link Runnable} in the background using a {@link ThreadPool}
     *
     * @param threadPoolName
     *            The thread pool name to be used
     * @param command
     *            The {@link Runnable} to execute
     * @param delay
     *            the delay befor first run
     * @param interval
     *            The interval for repeated runs
     *
     * @throws IllegalArgumentException
     *             DOCUMENT ME!
     */
    public void execute(final String threadPoolName, final Runnable command, final long delay, long interval) {
        if (delay < 0) {
            throw new IllegalArgumentException("delay < 0");
        }

        if (interval < 0) {
            throw new IllegalArgumentException("interval < 0");
        }

        ThreadPool pool = (ThreadPool) pools.get(threadPoolName);

        if (null == pool) {
            getLogger().warn(
                            "ThreadPool \"" + threadPoolName + "\" is not known. Will use ThreadPool \""
                                            + ThreadPool.DEFAULT_THREADPOOL_NAME + "\"");
            pool = (ThreadPool) pools.get(ThreadPool.DEFAULT_THREADPOOL_NAME);
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug(
                            "Command entered: " + command + ", pool=" + (null == pool ? "null" : pool.getName())
                                            + ", delay=" + delay + ", interval=" + interval);
        }

        new ExecutionInfo(pool, command, delay, interval, getLogger());
    }
18871#/**
     * Run a {@link Runnable} in the background using a {@link ThreadPool}
     *
     * @param command
     *            The {@link Runnable} to execute
     * @param delay
     *            the delay befor first run
     * @param interval
     *            The interval for repeated runs
     */
    public void execute(final Runnable command, final long delay, final long interval) {
        execute(ThreadPool.DEFAULT_THREADPOOL_NAME, command, delay, interval);
    }
18872#/**
     * Run a {@link Runnable} in the background using a {@link ThreadPool}
     *
     * @param command
     *            The {@link Runnable} to execute
     * @param delay
     *            the delay befor first run
     */
    public void execute(final Runnable command, final long delay) {
        execute(ThreadPool.DEFAULT_THREADPOOL_NAME, command, delay, 0);
    }
18873#/**
     * Run a {@link Runnable} in the background using a {@link ThreadPool}
     *
     * @param command
     *            The {@link Runnable} to execute
     */
    public void execute(final Runnable command) {
        execute(ThreadPool.DEFAULT_THREADPOOL_NAME, command, 0, 0);
    }
18874#/**
     * Run a {@link Runnable} in the background using a {@link ThreadPool}
     *
     * @param threadPoolName
     *            The thread pool name to be used
     * @param command
     *            The {@link Runnable} to execute
     * @param delay
     *            the delay befor first run
     */
    public void execute(final String threadPoolName, final Runnable command, final long delay) {
        execute(threadPoolName, command, delay, 0);
    }
18875#/**
     * Run a {@link Runnable} in the background using a {@link ThreadPool}
     *
     * @param threadPoolName
     *            The thread pool name to be used
     * @param command
     *            The {@link Runnable} to execute
     */
    public void execute(final String threadPoolName, final Runnable command) {
        execute(threadPoolName, command, 0, 0);
    }
18876#/**
     * Remove a <code>Runnable</code> from the command stack
     *
     * @param command
     *            The <code>Runnable</code> to be removed
     */
    public void remove(Runnable command) {
        synchronized (commandStack) {
            for (final Iterator i = commandStack.iterator(); i.hasNext();) {
                final ExecutionInfo info = (ExecutionInfo) i.next();

                if (info.m_command == command) {
                    i.remove();
                    commandStack.notifyAll();

                    return;
                }
            }
        }

        getLogger().warn("Could not find command " + command + " for removal");
    }
18877#/**
     * The heart of the command manager
     */
    public void run() {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Entering loop");
        }

        while (keepRunning) {
            synchronized (commandStack) {
                try {
                    if (commandStack.size() > 0) {
                        final ExecutionInfo info = (ExecutionInfo) commandStack.first();
                        final long delay = info.m_nextRun - System.currentTimeMillis();

                        if (delay > 0) {
                            commandStack.wait(delay);
                        }
                    } else {
                        if (getLogger().isDebugEnabled()) {
                            getLogger().debug("No commands available. Will just wait for one");
                        }

                        commandStack.wait();
                    }
                } catch (final InterruptedException ie) {
                    if (getLogger().isDebugEnabled()) {
                        getLogger().debug("I've been interrupted");
                    }
                }

                if (keepRunning) {
                    if (commandStack.size() > 0) {
                        final ExecutionInfo info = (ExecutionInfo) commandStack.first();
                        final long delay = info.m_nextRun - System.currentTimeMillis();

                        if (delay < 0) {
                            info.execute();
                        }
                    }
                }
            }
        }

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Exiting loop");
        }
    }
18878#/**
     * Start the managing thread
     *
     * @throws Exception
     *             DOCUMENT ME!
     */
    protected void start() throws Exception {
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Starting the heart");
        }

        keepRunning = true;
        ((ThreadPool) pools.get(ThreadPool.DEFAULT_THREADPOOL_NAME)).execute(this);
    }
18879#/**
     * Stop the managing thread
     */
    protected void stop() {
        keepRunning = false;

        synchronized (commandStack) {
            commandStack.notifyAll();
        }
    }
18880#/**
     * DOCUMENT ME!
     *
     * @param priority
     *            The priority to set as string value.
     *
     * @return The priority as int value.
     */
    private int convertPriority(final String priority) {
        if ("MIN".equalsIgnoreCase(priority)) {
            return Thread.MIN_PRIORITY;
        } else if ("NORM".equalsIgnoreCase(priority)) {
            return Thread.NORM_PRIORITY;
        } else if ("MAX".equalsIgnoreCase(priority)) {
            return Thread.MAX_PRIORITY;
        } else {
            getLogger().warn("Unknown thread priority \"" + priority + "\". Set to \"NORM\".");

            return Thread.NORM_PRIORITY;
        }
    }
18881#/**
     * @param workerThreadPools
     *            the workerThreadPools to set
     */
    public void setWorkerThreadPools(Map workerThreadPools) {
        this.workerThreadPools = workerThreadPools;
    }
18882#// ~ Constructors
        // -------------------------------------------------------

        /**
         * Creates a new ExecutionInfo object.
         *
         * @param pool
         *            DOCUMENT ME!
         * @param command
         *            DOCUMENT ME!
         * @param delay
         *            DOCUMENT ME!
         * @param interval
         *            DOCUMENT ME!
         * @param logger
         *            DOCUMENT ME!
         */
        ExecutionInfo(final ThreadPool pool, final Runnable command, final long delay, final long interval,
                        final Log logger) {
            m_pool = pool;
            m_command = command;
            m_delay = delay;
            m_interval = interval;
            m_logger = logger;
            m_nextRun = System.currentTimeMillis() + delay;

            synchronized (commandStack) {
                commandStack.add(this);
                commandStack.notifyAll();
            }
            Thread.yield(); // Give others a chance to run
        }
18883#// ~ Methods
        // ------------------------------------------------------------

        /**
         * DOCUMENT ME!
         *
         * @param other
         *            DOCUMENT ME!
         *
         * @return DOCUMENT ME!
         */
        public int compareTo(final Object other) {
            final ExecutionInfo otherInfo = (ExecutionInfo) other;
            int diff = (int) (m_nextRun - otherInfo.m_nextRun);
            if (diff == 0) {
                if (this == other) {
                    // Same object, return 0.
                    return 0;
                } else {
                    // NOT the same object, MUST return non-0 value.
                    return System.identityHashCode(this) - System.identityHashCode(other);
                }
            }
            return diff;
        }
18884#/**
         * DOCUMENT ME!
         */
        void execute() {
            if (m_logger.isDebugEnabled()) {
                m_logger.debug("Executing command " + m_command + " in pool \"" + m_pool.getName()
                                + "\", schedule with interval=" + m_interval);
            }

            synchronized (commandStack) {
                commandStack.remove(this);
                if (m_interval > 0) {
                    m_nextRun = System.currentTimeMillis() + m_interval;
                    commandStack.add(this);
                }
            }

            try {
                m_pool.execute(m_command);
            } catch (final InterruptedException ie) {
                if (m_logger.isDebugEnabled()) {
                    m_logger.debug("Interrupted executing command + " + m_command);
                }
            } catch (final Throwable t) {
                m_logger.error("Exception executing command " + m_command, t);
            }
        }
18885#//~ Methods ----------------------------------------------------------------

    /**
     * @see org.apache.cocoon.thread.impl.Queue#getQueueSize()
     */
    public int getQueueSize(){
        return 0;
    }
18886#//~ Methods ----------------------------------------------------------------

    /**
     * @see org.apache.cocoon.thread.impl.Queue#getQueueSize()
     */
    public int getQueueSize() {
        return -1;
    }
18887#//~ Methods ----------------------------------------------------------------

    /**
     * DOCUMENT ME!
     *
     * @param channel DOCUMENT ME!
     */
    public void setChannel( final Channel channel ) {
        this.channel = channel;
    }
18888#/**
     * @see EDU.oswego.cs.dl.util.concurrent.Puttable#offer(java.lang.Object,
     *      long)
     */
    public boolean offer( final Object obj,
                          final long timeout )
    throws InterruptedException {
        return channel.offer( obj, timeout );
    }
18889#/**
     * @see EDU.oswego.cs.dl.util.concurrent.Channel#peek()
     */
    public Object peek() {
        return channel.peek();
    }
18890#/**
     * @see EDU.oswego.cs.dl.util.concurrent.Takable#poll(long)
     */
    public Object poll( final long timeout )
    throws InterruptedException {
        return channel.poll( timeout );
    }
18891#/**
     * @see EDU.oswego.cs.dl.util.concurrent.Puttable#put(java.lang.Object)
     */
    public void put( final Object obj )
    throws InterruptedException {
        channel.put( obj );
    }
18892#/**
     * @see EDU.oswego.cs.dl.util.concurrent.Takable#take()
     */
    public Object take()  throws InterruptedException {
        return channel.take();
    }
18893#// ~ Constructors
    // -----------------------------------------------------------

    /**
     * Create a new pool.
     *
     * @param channel
     *                DOCUMENT ME!
     */
    private DefaultThreadPool(final ChannelWrapper channel) {
   	    super(channel);
	    channelWrapper = channel;
    }
18894#/**
     * Create a new pool.
     */
    DefaultThreadPool() {
  	    this(new ChannelWrapper());
    }
18895#// ~ Methods
    // ----------------------------------------------------------------

    /** Initialize the bean after properties set */
    public void init() throws IllegalArgumentException {
        if (logger.isInfoEnabled()) {
            logger.info("ThreadPool [" + name + "] initializing ...");
        }

	    initFactory();
	    this.setThreadFactory(factory);
        initMinPoolSize();
        initPriority();
        initDaemon();
        initQueueSize();
        initMaxPoolSize();
        initKeepAliveTime();

        if (logger.isInfoEnabled()) {
            logger.info(this.toString());
            logger.info("ThreadPool [" + name + "] initialized");
        }
    }
18896#/**
     * Get the block policy
     *
     * @return Returns the blockPolicy.
     */
    public String getBlockPolicy() {
        return blockPolicy;
    }
18897#/**
     * DOCUMENT ME!
     *
     * @return maximum size of the queue (0 if isQueued() == false)
     *
     * @see org.apache.cocoon.thread.ThreadPool#getQueueSize()
     */
    public int getMaxQueueSize() {
        return ((queueSize < 0) ? Integer.MAX_VALUE : queueSize);
    }
18898#/**
         * @see org.apache.cocoon.thread.ThreadPool#getName()
         */
    public String getName() {
	return name;
    }
18899#/**
         * Get hte priority used to create Threads
         *
         * @return {@link Thread#MIN_PRIORITY}, {@link Thread#NORM_PRIORITY},
         *         or {@link Thread#MAX_PRIORITY}
         */
    public int getPriority() {
	return ((ThreadFactory) super.getThreadFactory()).getPriority();
    }
18900#/**
         * DOCUMENT ME!
         *
         * @return current size of the queue (0 if isQueued() == false)
         *
         * @see org.apache.cocoon.thread.ThreadPool#getQueueSize()
         */
    public int getQueueSize() {
	return queue.getQueueSize();
    }
18901#/**
         * Whether this DefaultThreadPool has a queue
         *
         * @return Returns the m_isQueued.
         *
         * @see org.apache.cocoon.thread.ThreadPool#isQueued()
         */
    public boolean isQueued() {
	return queueSize != 0;
    }
18902#/**
         * Execute a command
         *
         * @param command
         *                The {@link Runnable} to execute
         *
         * @throws InterruptedException
         *                 In case of interruption
         */
    public void execute(Runnable command) throws InterruptedException {
	if (logger.isDebugEnabled()) {
	    logger.debug("Executing Command: " + command.toString() + ",pool="
		    + getName());
	}

	super.execute(command);
    }
18903#/**
         * @see org.apache.cocoon.thread.ThreadPool#shutdown()
         */
    public void shutdown() {
	if (shutdownGraceful) {
	    shutdownAfterProcessingCurrentlyQueuedTasks();
	} else {
	    shutdownNow();
	}

	try {
	    if (getShutdownWaitTimeMs() > 0) {
		if (!awaitTerminationAfterShutdown(getShutdownWaitTimeMs())) {
		    logger.warn("running commands have not terminated within "
			    + getShutdownWaitTimeMs()
			    + "ms. Will shut them down by interruption");
		    interruptAll();
		    shutdownNow();
		}
	    }

	    awaitTerminationAfterShutdown();
	} catch (final InterruptedException ie) {
	    logger.error("cannot shutdown ThreadPool", ie);
	}
    }
18904#/**
         * Set the blocking policy
         *
         * @param blockPolicy
         *                The blocking policy value
         */
    public void setBlockPolicy(final String blockPolicy) {
	this.blockPolicy = blockPolicy;

	if (POLICY_ABORT.equalsIgnoreCase(blockPolicy)) {
	    abortWhenBlocked();
	} else if (POLICY_DISCARD.equalsIgnoreCase(blockPolicy)) {
	    discardWhenBlocked();
	} else if (POLICY_DISCARD_OLDEST.equalsIgnoreCase(blockPolicy)) {
	    discardOldestWhenBlocked();
	} else if (POLICY_RUN.equalsIgnoreCase(blockPolicy)) {
	    runWhenBlocked();
	} else if (POLICY_WAIT.equalsIgnoreCase(blockPolicy)) {
	    waitWhenBlocked();
	} else {
	    final StringBuffer msg = new StringBuffer();
	    msg.append("WARNING: Unknown block-policy configuration \"")
		    .append(blockPolicy);
	    msg.append("\". Should be one of \"").append(POLICY_ABORT);
	    msg.append("\",\"").append(POLICY_DISCARD);
	    msg.append("\",\"").append(POLICY_DISCARD_OLDEST);
	    msg.append("\",\"").append(POLICY_RUN);
	    msg.append("\",\"").append(POLICY_WAIT);
	    msg.append("\". Will use \"").append(POLICY_DEFAULT).append("\"");
	    logger.warn(msg.toString());
	    setBlockPolicy(POLICY_DEFAULT);
	}
    }
18905#/**
         * DOCUMENT ME!
         *
         * @param name
         *                The name to set.
         */
    public void setName(String name) {
	this.name = name;
    }
18906#/**
         * DOCUMENT ME!
         *
         * @param shutdownGraceful
         *                The shutdownGraceful to set.
         */
    public void setShutdownGraceful(boolean shutdownGraceful) {
	this.shutdownGraceful = shutdownGraceful;
    }
18907#/**
         * DOCUMENT ME!
         *
         * @return Returns the shutdownGraceful.
         */
    public boolean isShutdownGraceful() {
	return shutdownGraceful;
    }
18908#/**
         * DOCUMENT ME!
         *
         * @param shutdownWaitTimeMs
         *                The shutdownWaitTimeMs to set.
         */
    public void setShutdownWaitTimeMs(int shutdownWaitTimeMs) {
	this.shutdownWaitTimeMs = shutdownWaitTimeMs;
    }
18909#/**
         * DOCUMENT ME!
         *
         * @return Returns the shutdownWaitTimeMs.
         */
    public int getShutdownWaitTimeMs() {
	return shutdownWaitTimeMs;
    }
18910#/**
         * @return the keepAliveTime
         */
    public long getKeepAliveTime() {
	return keepAliveTime;
    }
18911#/**
         * @param keepAliveTime
         *                the keepAliveTime to set
         */
    public void setKeepAliveTime(long keepAliveTime) {
	this.keepAliveTime = keepAliveTime;
    }
18912#/**
         * @return the maxPoolSize
         */
    public int getMaxPoolSize() {
	return maxPoolSize;
    }
18913#/**
         * @param maxPoolSize
         *                the maxPoolSize to set
         */
    public void setMaxPoolSize(int maxPoolSize) {
	this.maxPoolSize = maxPoolSize;
    }
18914#/**
         * @return the minPoolSize
         */
    public int getMinPoolSize() {
	return minPoolSize;
    }
18915#/**
         * @param minPoolSize
         *                the minPoolSize to set
         */
    public void setMinPoolSize(int minPoolSize) {
	this.minPoolSize = minPoolSize;
    }
18916#/**
         * @return the threadFactory
         */
    public ThreadFactory getFactory() {
	return factory;
    }
18917#/**
         * @param priority
         *                the priority to set
         */
    public void setPriority(int priority) {
	this.priority = priority;
    }
18918#/**
         * @param pool
         *                priority the priority to set
         */
    public void setPoolPriority(String poolPriority) {
	setPriority(convertPriority(poolPriority));
    }
18919#/**
         * Sets the queue size of the thread pool
         *
         * @param queueSize
         *                the queueSize to set
         */
    public void setQueueSize(int queueSize) {
	this.queueSize = queueSize;
    }
18920#/**
         * Returns true if thread runs as daemon
         *
         * @return the daemon
         */
    public boolean isDaemon() {
	return daemon;
    }
18921#/**
         * Set to true if thread shall run as daemon
         *
         * @param daemon
         *                the daemon to set
         */
    public void setDaemon(boolean daemon) {
	this.daemon = daemon;
    }
18922#/**
         * Overwrite the toString method
         */
    public String toString() {
	if (this.isQueued()) {
	    final StringBuffer msg = new StringBuffer();
	    msg.append("ThreadPool named \"").append(name);
	    msg.append("\" created with maximum queue-size=").append(queueSize);
	    msg.append(",max-pool-size=").append(maximumPoolSize_);
	    msg.append(",min-pool-size=").append(minimumPoolSize_);
	    msg.append(",priority=").append(priority);
	    msg.append(",isDaemon=").append(
		    ((ThreadFactory) this.getThreadFactory()).isDaemon());
	    msg.append(",keep-alive-time-ms=").append(keepAliveTime_);
	    msg.append(",block-policy=\"").append(blockPolicy);
	    msg.append("\",shutdown-wait-time-ms=").append(shutdownWaitTimeMs);
	    return msg.toString();
	} else {
	    final StringBuffer msg = new StringBuffer();
	    msg.append("ThreadPool named \"").append(name);
	    msg.append("\" created with no queue,max-pool-size=").append(
		    maximumPoolSize_);
	    msg.append(",min-pool-size=").append(minimumPoolSize_);
	    msg.append(",priority=").append(priority);
	    msg.append(",isDaemon=").append(
		    ((ThreadFactory) this.getThreadFactory()).isDaemon());
	    msg.append(",keep-alive-time-ms=").append(keepAliveTime_);
	    msg.append(",block-policy=\"").append(blockPolicy);
	    msg.append("\",shutdown-wait-time-ms=").append(shutdownWaitTimeMs);
	    return msg.toString();
	}
    }
18923#/**
         * DOCUMENT ME!
         *
         * @param priority
         *                The priority to set as string value.
         *
         * @return The priority as int value.
         */
    private int convertPriority(final String priority) {
	if ("MIN".equalsIgnoreCase(priority)) {
	    return Thread.MIN_PRIORITY;
	} else if ("NORM".equalsIgnoreCase(priority)) {
	    return Thread.NORM_PRIORITY;
	} else if ("MAX".equalsIgnoreCase(priority)) {
	    return Thread.MAX_PRIORITY;
	} else {
	    logger.warn("Unknown thread priority \"" + priority
		    + "\". Set to \"NORM\".");

	    return Thread.NORM_PRIORITY;
	}
    }
18924#/**
         * @param factory
         *                the factory to set
         */
    public void setFactory(ThreadFactory factory) {
	this.factory = factory;
    }
18925#private void initFactory() {
	if (factory == null) {
	    logger.warn("No ThreadFactory is configured. Will use a "
		    + DefaultThreadFactory.class.getName());
	    factory = new org.apache.cocoon.thread.impl.DefaultThreadFactory();
	}
    }
18926#private void initMinPoolSize() {
	// Min pool size
	// make sure we have enough threads for the default thread pool as we
	// need one for ourself
	if (ThreadPool.DEFAULT_THREADPOOL_NAME.equals(name)
		&& ((minPoolSize > 0) && (minPoolSize < ThreadPool.DEFAULT_MIN_POOL_SIZE))) {
	    minPoolSize = ThreadPool.DEFAULT_MIN_POOL_SIZE;
	}
	if (minPoolSize < 1) {
	    minPoolSize = (minPoolSize < 1) ? 1 : minPoolSize;
	    logger
		    .warn("min-pool-size < 1 for pool \"" + name
			    + "\". Set to 1");
	}
	super.setMinimumPoolSize(minPoolSize);
    }
18927#private void initPriority() {
	// Use priority from factory when changed
	priority = (factory.getPriority() != Thread.NORM_PRIORITY ? factory
		.getPriority() : priority);
	factory.setPriority(priority);
    }
18928#private void initDaemon() {
	// Use daemon from factory when changed
	daemon = (factory.isDaemon() != false ? factory.isDaemon() : daemon);
	factory.setDaemon(daemon);
    }
18929#private void initMaxPoolSize() {
	// Max pool size
	maxPoolSize = (maxPoolSize < 0) ? Integer.MAX_VALUE : maxPoolSize;
	super.setMaximumPoolSize(maxPoolSize);
    }
18930#private void initKeepAliveTime() {
	// Keep alive time
	if (keepAliveTime < 0) {
	    keepAliveTime = 1000;
	    logger.warn("keep-alive-time-ms < 0 for pool \"" + name
		    + "\". Set to 1000");
	}
	super.setKeepAliveTime(keepAliveTime);
    }
18931#private void initQueueSize() {
	if (queueSize != 0) {
	    if (queueSize > 0) {
		queue = new BoundedQueue(queueSize);
	    } else {
		queue = new LinkedQueue();
	    }
	} else {
	    queue = new SynchronousChannel();
	}
	channelWrapper.setChannel(queue);
    }
18932#//~ Methods ----------------------------------------------------------------

    /**
     * get the current queue size
     *
     * @return current size of queue. If the size of the queue is not
     *         maintained by an implementation -1 should be returned.
     */
    int getQueueSize();
18933#/**
     * Return the MIME type for a given file.
     *
     * @param file File.
     * @return MIME type.
     */
    public static String getMIMEType(final File file)
            throws FileNotFoundException, IOException {
        BufferedInputStream in = null;

        try {
            in = new BufferedInputStream(new FileInputStream(file));
            byte[] buf = new byte[3];
            int count = in.read(buf, 0, 3);

            if (count < 3) {
                return (null);
            }

            if ((buf[0]) == (byte)'G' && (buf[1]) == (byte)'I' && (buf[2]) == (byte)'F') {
                return ("image/gif");
            }

            if ((buf[0]) == (byte)0xFF && (buf[1]) == (byte)0xD8) {
                return ("image/jpeg");
            }

        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                }
            }
        }
        final String name = file.getName();
        int index = name.lastIndexOf(".");
        String fileExt = ".";
        if (index != -1) {
            fileExt = name.substring(index);
        }
        return getMIMEType(fileExt);
    }
18934#/**
     * Return the MIME type for a given filename extension.
     *
     * @param ext Filename extension.
     *
     * @return MIME type.
     */
    public static String getMIMEType(final String ext) {
        return (String)mimeMap.get(ext);
    }
18935#/**
     * Return the default filename extension for a given MIME type.
     *
     * @param type MIME type.
     *
     * @return Filename extension.
     */
    public static String getDefaultExtension(final String type) {
        return (String)extMap.get(type);
    }
18936#/**
     * Parses a <code>mime.types</code> file, and generates mappings between
     * MIME types and extensions.
     * For example, if a line contains:
     * <pre>text/html   html htm</pre>
     * Then 'html' will be the default extension for text/html, and both 'html'
     * and 'htm' will have MIME type 'text/html'.
     * Lines starting with '#' are treated as comments and ignored.  If an
     * extension is listed for two MIME types, the first will be chosen.
     *
     * @param in Reader of bytes from <code>mime.types</code> file content
     * @param extMap Empty map of default extensions, keyed by MIME type. Will
     * be filled in by this method.
     * @param mimeMap Empty map of MIME types, keyed by extension.  Will be
     * filled in by this method.
     */
    public static void loadMimeTypes(Reader in, Map extMap, Map mimeMap) throws IOException {
        BufferedReader br = new BufferedReader(in);
        String line;
        while ((line = br.readLine()) != null) {
            if (line.startsWith("#")) {
                continue;
            }
            if (line.trim().length() == 0) {
                continue;
            }
            StringTokenizer tok = new StringTokenizer(line, " \t");
            String mimeType = tok.nextToken();
            if (tok.hasMoreTokens()) {
                String defaultExt = tok.nextToken();
                if (!extMap.containsKey(mimeType)) {
                    extMap.put(mimeType, "." + defaultExt);
                }
                if (!mimeMap.containsKey("." + defaultExt)) {
                    mimeMap.put("." + defaultExt, mimeType);
                }
                while (tok.hasMoreTokens()) {
                    String ext = tok.nextToken();
                    if (!mimeMap.containsKey("." + ext)) {
                        mimeMap.put("." + ext, mimeType);
                    }
                }
            }
        }
    }
18937#public HashMap () {
        super();
    }
18938#public HashMap ( int initialCapacity ) {
        super(initialCapacity);
    }
18939#public HashMap ( int initialCapacity, float loadFactor ) {
        super(initialCapacity, loadFactor);
    }
18940#public HashMap ( Map t) {
        super(t);
    }
18941#/**
     * Get method extended by default object to be returned when key
     * is not found.
     *
     * @param key key to look up
     * @param _default default value to return if key is not found
     * @return value that is associated with key
     */
    public Object get( Object key, Object _default ) {
        if (this.containsKey(key)) {
            return this.get(key);
        }
        return _default;
    }
18942#/**
     * Constructors with and without a string representation (image).
     * Make constructors private upon derivation.
     * Be careful: No check is made that the image string is unique!
     * @param image
     */
    public EnumerationFactory(String image) {
        this.pos = allObjects.size();
        this.image = image;
        allObjects.addElement(this);
    }
18943#public EnumerationFactory() {
        this ("");
    }
18944#//--------------------------------------------------------------------------
    // Order relations:

    /**
     * Order relations Object.op (OtherObject) representing the relation
     * Object op OtherObject.
     * @param e the right operand
     */
    public boolean lt(EnumerationFactory e) {                   // "<"
        return this.getPos() < e.getPos();
    }
18945#public boolean le(EnumerationFactory e) {                   // "<="
        return this.getPos() <= e.getPos();
    }
18946#public boolean gt(EnumerationFactory e) {                   // ">"
        return this.getPos() > e.getPos();
    }
18947#public boolean ge(EnumerationFactory e) {                   // ">="
        return this.getPos() >= e.getPos ();
    }
18948#// "==" and "equals" are inherited.

    //--------------------------------------------------------------------------
    // Numeric representation:

    public int getPos() {                                          // Ada'Pos
        return pos;
    }
18949#/**
     * Access to the numeric representation.
     * @param value the numeric value
     */
    public static EnumerationFactory getVal(int value) {           // Ada'Val
        return (EnumerationFactory)allObjects.elementAt(value);
    }
18950#//--------------------------------------------------------------------------
    // Iterator:

    public static EnumerationFactory getFirst() {                  // Ada'First
        return getVal(0);
    }
18951#public static EnumerationFactory getLast() {                   // Ada'Last
        return getVal(allObjects.size() - 1);
    }
18952#public EnumerationFactory getNext () {                          // Ada'Succ
        return getVal(this.getPos() + 1);
    }
18953#public EnumerationFactory getPrev () {                          // Ada'Pred
        return getVal(this.getPos() - 1);
    }
18954#//--------------------------------------------------------------------------
    // String representation:

    public String toString() {                                     // Ada'Image
        return image;
    }
18955#public static EnumerationFactory getObject(String image) {     // Ada'Value
        EnumerationFactory found;
        // Linear search seems good enough because there presumably
        // will not be too many literals.
        for (int i = 0 ; i < allObjects.size() ; i++) {
            found = (EnumerationFactory) allObjects.elementAt(i);
            if (found.toString().equals(image)) {
                return found;
            }
        }
        return null;
    }
18956#private static Log getLog() {
        SimpleLog log = new SimpleLog("cocoon.deprecation");
        log.setLevel(SimpleLog.LOG_LEVEL_ALL);
        return log;
    }
18957#public static void setLogger(Log newLogger) {
        // Note: the "logger" attribute is not of type LoggerWrapper so that it appears
        // as a standard Logger in the javadocs.
        ((LoggerWrapper) logger).setLogger(newLogger);
    }
18958#public static void setForbiddenLevel(LogLevel level) {
        // If null, reset to the default level
        if (level == null) {
            level = ERROR;
        }
        ((LoggerWrapper) logger).setForbiddenLevel(level);
    }
18959#private LogLevel(String text, int value) {
            super(text, value);
        }
18960#public static LogLevel getLevel(String level) {
            return (LogLevel)ValuedEnum.getEnum(LogLevel.class, level);
        }
18961#private LoggerWrapper(Log logger) {
            this.delegate = logger;
        }
18962#private void setLogger(Log logger) {
            // Unwrap a wrapped logger
            while (logger instanceof LoggerWrapper) {
                logger = ((LoggerWrapper) logger).delegate;
            }
            this.delegate = logger;
        }
18963#private void setForbiddenLevel(LogLevel level) {
            this.forbiddenLevel = level.getValue();
        }
18964#private void throwException(int level, Object message) {
            if (level >= this.forbiddenLevel) {
                throw new DeprecationException(String.valueOf(message));
            }
        }
18965#private boolean isThrowingException(int level) {
            return level >= this.forbiddenLevel;
        }
18966#public void trace(Object message) {
            delegate.trace(message);
            throwException(DEBUG_VALUE, message);
        }
18967#public void trace(Object message, Throwable thr) {
            delegate.trace(message, thr);
            throwException(DEBUG_VALUE, message);
        }
18968#public void debug(Object message) {
            delegate.debug(message);
            throwException(DEBUG_VALUE, message);
        }
18969#public void debug(Object message, Throwable thr) {
            delegate.debug(message, thr);
            throwException(DEBUG_VALUE, message);
        }
18970#public void info(Object message) {
            delegate.info(message);
            throwException(INFO_VALUE, message);
        }
18971#public void info(Object message, Throwable thr) {
            delegate.info(message, thr);
            throwException(INFO_VALUE, message);
        }
18972#public void warn(Object message) {
            delegate.warn(message);
            throwException(WARN_VALUE, message);
        }
18973#public void warn(Object message, Throwable thr) {
            delegate.warn(message, thr);
            throwException(WARN_VALUE, message);
        }
18974#public void error(Object message) {
            delegate.error(message);
            throwException(ERROR_VALUE, message);
        }
18975#public void error(Object message, Throwable thr) {
            delegate.error(message, thr);
            throwException(ERROR_VALUE, message);
        }
18976#public void fatal(Object message) {
            delegate.fatal(message);
            throwException(FATAL_VALUE, message);
        }
18977#public void fatal(Object message, Throwable thr) {
            delegate.fatal(message, thr);
            throwException(FATAL_VALUE, message);
        }
18978#public boolean isTraceEnabled() {
            return isThrowingException(DEBUG_VALUE) || delegate.isTraceEnabled();
        }
18979#public boolean isDebugEnabled() {
            // Enable level also if it is set to throw an exception, so that
            // logging the message occurs, and then throws it.
            return isThrowingException(DEBUG_VALUE) || delegate.isDebugEnabled();
        }
18980#public boolean isInfoEnabled() {
            return isThrowingException(INFO_VALUE) || delegate.isInfoEnabled();
        }
18981#public boolean isWarnEnabled() {
            return isThrowingException(WARN_VALUE) || delegate.isWarnEnabled();
        }
18982#public boolean isErrorEnabled() {
            return isThrowingException(ERROR_VALUE) || delegate.isErrorEnabled();
        }
18983#public boolean isFatalEnabled() {
            return true;
        }
18984#/**
     * Decode a path.
     *
     * <p>Interprets %XX (where XX is hexadecimal number) as UTF-8 encoded bytes.
     * <p>The validity of the input path is not checked (i.e. characters that were not encoded will
     * not be reported as errors).
     * <p>This method differs from URLDecoder.decode in that it always uses UTF-8 (while URLDecoder
     * uses the platform default encoding, often ISO-8859-1), and doesn't translate + characters to spaces.
     *
     * @param path the path to decode
     * @return the decoded path
     */
    public static String decodePath(String path) {
        StringBuffer translatedPath = new StringBuffer(path.length());
        byte[] encodedchars = new byte[path.length() / 3];
        int i = 0;
        int length = path.length();
        int encodedcharsLength = 0;
        while (i < length) {
            if (path.charAt(i) == '%') {
                // we must process all consecutive %-encoded characters in one go, because they represent
                // an UTF-8 encoded string, and in UTF-8 one character can be encoded as multiple bytes
                while (i < length && path.charAt(i) == '%') {
                    if (i + 2 < length) {
                        try {
                            byte x = (byte)Integer.parseInt(path.substring(i + 1, i + 3), 16);
                            encodedchars[encodedcharsLength] = x;
                        } catch (NumberFormatException e) {
                            throw new IllegalArgumentException("NetUtils.decodePath: " +
                                                               "Illegal hex characters in pattern %" + path.substring(i + 1, i + 3));
                        }
                        encodedcharsLength++;
                        i += 3;
                    } else {
                        throw new IllegalArgumentException("NetUtils.decodePath: " +
                                                           "% character should be followed by 2 hexadecimal characters.");
                    }
                }
                try {
                    String translatedPart = new String(encodedchars, 0, encodedcharsLength, "UTF-8");
                    translatedPath.append(translatedPart);
                } catch (UnsupportedEncodingException e) {
                    // the situation that UTF-8 is not supported is quite theoretical, so throw a runtime exception
                    throw new RuntimeException("Problem in decodePath: UTF-8 encoding not supported.");
                }
                encodedcharsLength = 0;
            } else {
                // a normal character
                translatedPath.append(path.charAt(i));
                i++;
            }
        }
        return translatedPath.toString();
    }
18985#/**
     * Encode a path as required by the URL specification (<a href="http://www.ietf.org/rfc/rfc1738.txt">
     * RFC 1738</a>). This differs from <code>java.net.URLEncoder.encode()</code> which encodes according
     * to the <code>x-www-form-urlencoded</code> MIME format.
     *
     * @param path the path to encode
     * @return the encoded path
     */
    public static String encodePath(String path) {
       // stolen from org.apache.catalina.servlets.DefaultServlet ;)

        /**
         * Note: This code portion is very similar to URLEncoder.encode.
         * Unfortunately, there is no way to specify to the URLEncoder which
         * characters should be encoded. Here, ' ' should be encoded as "%20"
         * and '/' shouldn't be encoded.
         */

        int maxBytesPerChar = 10;
        StringBuffer rewrittenPath = new StringBuffer(path.length());
        ByteArrayOutputStream buf = new ByteArrayOutputStream(maxBytesPerChar);
        OutputStreamWriter writer;
        try {
            writer = new OutputStreamWriter(buf, "UTF8");
        } catch (Exception e) {
            e.printStackTrace();
            writer = new OutputStreamWriter(buf);
        }

        for (int i = 0; i < path.length(); i++) {
            int c = path.charAt(i);
            if (safeCharacters.get(c)) {
                rewrittenPath.append((char)c);
            } else {
                // convert to external encoding before hex conversion
                try {
                    writer.write(c);
                    writer.flush();
                } catch(IOException e) {
                    buf.reset();
                    continue;
                }
                byte[] ba = buf.toByteArray();
                for (int j = 0; j < ba.length; j++) {
                    // Converting each byte in the buffer
                    byte toEncode = ba[j];
                    rewrittenPath.append('%');
                    int low = (toEncode & 0x0f);
                    int high = ((toEncode & 0xf0) >> 4);
                    rewrittenPath.append(hexadecimal[high]);
                    rewrittenPath.append(hexadecimal[low]);
                }
                buf.reset();
            }
        }
        return rewrittenPath.toString();
    }
18986#/**
     * Returns the path of the given resource.
     *
     * @param uri The URI of the resource
     * @return the resource path
     */
    public static String getPath(String uri) {
        int i = uri.lastIndexOf('/');
        if (i > -1) {
            return uri.substring(0, i);
        }
        i = uri.indexOf(':');
        return (i > -1) ? uri.substring(i + 1, uri.length()) : "";
    }
18987#/**
     * Remove path and file information from a filename returning only its
     * extension  component
     *
     * @param uri The filename
     * @return The filename extension (with starting dot!) or null if filename extension is not found
     */
    public static String getExtension(String uri) {
        int dot = uri.lastIndexOf('.');
        if (dot > -1) {
            uri = uri.substring(dot);
            int slash = uri.lastIndexOf('/');
            if (slash > -1) {
                return null;
            } else {
                int sharp = uri.lastIndexOf('#');
                if (sharp > -1) {
                    // uri starts with dot already
                    return uri.substring(0, sharp);
                } else {
                    int mark = uri.lastIndexOf('?');
                    if (mark > -1) {
                        // uri starts with dot already
                        return uri.substring(0, mark);
                    } else {
                        return uri;
                    }
                }
            }
        } else {
            return null;
        }
    }
18988#/**
     * Absolutize a relative resource path on the given absolute base path.
     *
     * @param path The absolute base path
     * @param resource The relative resource path
     * @return The absolutized resource path
     */
    public static String absolutize(String path, String resource) {
        if (StringUtils.isEmpty(path)) {
            return resource;
        } else if (StringUtils.isEmpty(resource)) {
            return path;
        } else if (resource.charAt(0) == '/') {
            // Resource path is already absolute
            return resource;
        }

        boolean slash = (path.charAt(path.length() - 1) == '/');
        
        StringBuffer b = new StringBuffer(path.length() + 1 + resource.length());
        b.append(path);
        if (!slash) {
            b.append('/');
        } 
        b.append(resource);
        return b.toString();
    }
18989#/**
     * Relativize an absolute resource on a given absolute path.
     *
     * @param path The absolute path
     * @param absoluteResource The absolute resource
     * @return the resource relative to the given path
     */
    public static String relativize(String path, String absoluteResource) {
        if (StringUtils.isEmpty(path)) {
            return absoluteResource;
        }

        if (path.charAt(path.length() - 1) != '/') {
            path += "/";
        }

        if (absoluteResource.startsWith(path)) {
            // resource is direct descentant
            return absoluteResource.substring(path.length());
        } else {
            // resource is not direct descendant
            int index = StringUtils.indexOfDifference(path, absoluteResource);
            if (index > 0 && path.charAt(index-1) != '/') {
                index = path.substring(0, index).lastIndexOf('/');
                index++;
            }
            String pathDiff = path.substring(index);
            String resource = absoluteResource.substring(index);
            int levels = StringUtils.countMatches(pathDiff, "/");
            StringBuffer b = new StringBuffer(levels * 3 + resource.length());
            for (int i = 0; i < levels; i++) {
                b.append("../");
            }
            b.append(resource);
            return b.toString();
        }
    }
18990#/**
     * Normalize a uri containing ../ and ./ paths.
     *
     * @param uri The uri path to normalize
     * @return The normalized uri
     */
    public static String normalize(String uri) {
        if ("".equals(uri)) {
            return uri;
        }
        int leadingSlashes;
        for (leadingSlashes = 0 ; leadingSlashes < uri.length()
                && uri.charAt(leadingSlashes) == '/' ; ++leadingSlashes) {}
        boolean isDir = (uri.charAt(uri.length() - 1) == '/');
        StringTokenizer st = new StringTokenizer(uri, "/");
        LinkedList clean = new LinkedList();
        while (st.hasMoreTokens()) {
            String token = st.nextToken();
            if ("..".equals(token)) {
                if (! clean.isEmpty() && ! "..".equals(clean.getLast())) {
                    clean.removeLast();
                    if (! st.hasMoreTokens()) {
                        isDir = true;
                    }
                } else {
                    clean.add("..");
                }
            } else if (! ".".equals(token) && ! "".equals(token)) {
                clean.add(token);
            }
        }
        StringBuffer sb = new StringBuffer();
        while (leadingSlashes-- > 0) {
            sb.append('/');
        }
        for (Iterator it = clean.iterator() ; it.hasNext() ; ) {
            sb.append(it.next());
            if (it.hasNext()) {
                sb.append('/');
            }
        }
        if (isDir && sb.length() > 0 && sb.charAt(sb.length() - 1) != '/') {
            sb.append('/');
        }
        return sb.toString();
    }
18991#/**
     * Remove parameters from a uri.
     * Passed in parameters map will be populated with parameter names as keys and
     * parameter values as map values. Values are of type String array
     * (similarly to {@link javax.servlet.ServletRequest#getParameterMap()}).
     * 
     * @param uri The uri path to deparameterize.
     * @param parameters The map that collects parameters.
     * @return The cleaned uri
     */
    public static String deparameterize(String uri, Map parameters) {
        int i = uri.lastIndexOf('?');
        if (i == -1) {
            return uri;
        }

        parameters.clear();
        String[] params = StringUtils.split(uri.substring(i + 1), '&');
        for (int j = 0; j < params.length; j++) {
            String p = params[j];
            int k = p.indexOf('=');
            if (k == -1) {
                break;
            }
            String name = p.substring(0, k);
            String value = p.substring(k + 1);
            Object values = parameters.get(name);
            if (values == null) {
                parameters.put(name, new String[]{value});
            } else {
                String[] v1 = (String[])values;
                String[] v2 = new String[v1.length + 1];
                System.arraycopy(v1, 0, v2, 0, v1.length);
                v2[v1.length] = value;
                parameters.put(name, v2);
            }
        }

        return uri.substring(0, i);
    }
18992#/**
     * Add parameters stored in the Map to the uri string.
     * Map can contain Object values which will be converted to the string,
     * or Object arrays, which will be treated as multivalue attributes.
     * 
     * @param uri The uri to add parameters into
     * @param parameters The map containing parameters to be added
     * @return The uri with added parameters
     */
    public static String parameterize(String uri, Map parameters) {
        if (parameters.size() == 0) {
            return uri;
        }
        
        StringBuffer buffer = new StringBuffer(uri);
        if (uri.indexOf('?') == -1) {
            buffer.append('?');
        } else {
            buffer.append('&');
        }
        
        for (Iterator i = parameters.entrySet().iterator(); i.hasNext();) {
            Map.Entry entry = (Map.Entry)i.next();
            if (entry.getValue().getClass().isArray()) {
                Object[] value = (Object[])entry.getValue();
                for (int j = 0; j < value.length; j++) {
                    if (j > 0) {
                        buffer.append('&');
                    }
                    buffer.append(entry.getKey());
                    buffer.append('=');
                    buffer.append(value[j]);
                }
            } else {
                buffer.append(entry.getKey());
                buffer.append('=');
                buffer.append(entry.getValue());
            }
            if (i.hasNext()) {
                buffer.append('&');
            }
        }
        return buffer.toString();
    }
18993#/**
     * Remove any authorisation details from a URI
     */
    public static String removeAuthorisation(String uri) {
        if (uri.indexOf("@") != -1 && (uri.startsWith("ftp://") || uri.startsWith("http://"))) {
            return uri.substring(0, uri.indexOf(":") + 2) + uri.substring(uri.indexOf("@") + 1);
        }

        return uri;
    }
18994#/**
     * Pass through to the {@link java.net.URLEncoder}. If running under JDK &lt; 1.4,
     * default encoding will always be used.
     */
    public static String encode(String s, String enc) throws UnsupportedEncodingException {
        return URLEncoder.encode(s, enc);
    }
18995#/**
     * Pass through to the {@link java.net.URLDecoder}. If running under JDK &lt; 1.4,
     * default encoding will always be used.
     */
    public static String decode(String s, String enc) throws UnsupportedEncodingException {
        return URLDecoder.decode(s, enc);
    }
18996#/**
     * Create a new instance given a class name
     *
     * @param className A class name
     * @return A new instance
     * @exception Exception If an instantiation error occurs
     */
    public static Object newInstance(String className) throws Exception {
        return ClassUtils.loadClass(className).newInstance();
    }
18997#/**
     * Load a class given its name.
     * BL: We wan't to use a known ClassLoader--hopefully the heirarchy
     *     is set correctly.
     *
     * @param className A class name
     * @return The class pointed to by <code>className</code>
     * @exception ClassNotFoundException If a loading error occurs
     */
    public static Class loadClass(String className) throws ClassNotFoundException {
        return ClassUtils.getClassLoader().loadClass(className);
    }
18998#/**
     * Return a resource URL.
     * BL: if this is command line operation, the classloading issues
     *     are more sane.  During servlet execution, we explicitly set
     *     the ClassLoader.
     *
     * @return The context classloader.
     * @exception MalformedURLException If a loading error occurs
     */
    public static URL getResource(String resource) throws MalformedURLException {
        return ClassUtils.getClassLoader().getResource(resource);
    }
18999#/**
     * Return the context classloader.
     * BL: if this is command line operation, the classloading issues
     *     are more sane.  During servlet execution, we explicitly set
     *     the ClassLoader.
     *
     * @return The context classloader.
     */
    public static ClassLoader getClassLoader() {
        return Thread.currentThread().getContextClassLoader();
    }
19000#public void write(byte b[]) {
    }
19001#public void write(byte b[], int off, int len) {
    }
19002#public void write(int b) {
    }
19003#public Log getLogger() {
        return this.logger;
    }
19004#public void setLogger(Log l) {
        this.logger = l;
    }
19005#/**
     * Private constructor to block instantiation.
     */
    private ConfigurationUtil() {
    }
19006#/**
     * Convert a DOM Element tree into a configuration tree.
     *
     * @param element the DOM Element
     * @return the configuration object
     */
    public static Configuration toConfiguration( final Element element ) {
        final DefaultConfiguration configuration =
            new DefaultConfiguration( element.getLocalName(), element.getPrefix(), element.getNamespaceURI(), element.getPrefix() );
        final NamedNodeMap attributes = element.getAttributes();
        final int length = attributes.getLength();
        for( int i = 0; i < length; i++ ) {
            final Node node = attributes.item( i );
            final String name = node.getNodeName();
            final String value = node.getNodeValue();
            configuration.setAttribute( name, value );
        }

        boolean flag = false;
        String content = "";
        final NodeList nodes = element.getChildNodes();
        final int count = nodes.getLength();
        for( int i = 0; i < count; i++ ) {
            final Node node = nodes.item( i );
            if( node instanceof Element ) {
                final Configuration child = toConfiguration( (Element)node );
                configuration.addChild( child );
            } else if( node instanceof CharacterData ) {
                final CharacterData data = (CharacterData)node;
                content += data.getData();
                flag = true;
            }
        }

        if( flag ) {
            configuration.setValue( content );
        }

        return configuration;
    }
19007#/**
     * Convert a configuration tree into a DOM Element tree.
     *
     * @param configuration the configuration object
     * @return the DOM Element
     */
    public static Element toElement( final Configuration configuration )
    throws ConfigurationException {
        try {
            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            final DocumentBuilder builder = factory.newDocumentBuilder();
            final Document document = builder.newDocument();

            return createElement( document, configuration );
        } catch( final ParserConfigurationException pce ) {
            throw new IllegalStateException( pce.toString() );
        }
    }
19008#/**
     * Create an DOM {@link Element} from a {@link Configuration}
     * object.
     *
     * @param document the DOM document
     * @param configuration the configuration to convert
     * @return the DOM Element
     */
    private static Element createElement( final Document document,
                                          final Configuration configuration )
    throws ConfigurationException {
        final Element element = document.createElementNS( configuration.getNamespace(), configuration.getName() );
        element.setPrefix( configuration.getLocation() );
        final String content = configuration.getValue( null );
        if( null != content )
        {
            final Text child = document.createTextNode( content );
            element.appendChild( child );
        }

        final String[] names = configuration.getAttributeNames();
        for( int i = 0; i < names.length; i++ )
        {
            final String name = names[ i ];
            final String value = configuration.getAttribute( name, null );
            element.setAttribute( name, value );
        }
        final Configuration[] children = configuration.getChildren();
        for( int i = 0; i < children.length; i++ )
        {
            final Element child = createElement( document, children[ i ] );
            element.appendChild( child );
        }
        return element;
    }
19009#// **********************
    // Serialize Methods
    // **********************

    /**
     * Dump a <code>String</code> to a text file.
     *
     * @param file The output file
     * @param string The string to be dumped
     * @exception IOException IO Error
     * @deprecated To be removed in cocoon 2.3
     */
    public static void serializeString(File file, String string)
    throws IOException {
        serializeString(file, string, null);
    }
19010#/**
     * Dump a <code>String</code> to a text file.
     *
     * @param file The output file
     * @param string The string to be dumped
     * @param encoding The encoding for the output file or null for default platform encoding
     * @exception IOException IO Error
     * @deprecated To be removed in cocoon 2.3
     */
    public static void serializeString(File file, String string, String encoding)
    throws IOException {
        final Writer fw =
                (encoding == null)?
                new FileWriter(file):
                new OutputStreamWriter(new FileOutputStream(file), encoding);
        try {
            fw.write(string);
            fw.flush();
        } finally {
            fw.close();
        }
    }
19011#/**
     * Load a text file contents as a <code>String<code>.
     * This method does not perform enconding conversions
     *
     * @param file The input file
     * @return The file contents as a <code>String</code>
     * @exception IOException IO Error
     */
    public static String deserializeString(File file)
    throws IOException {
        int len;
        char[] chr = new char[4096];
        final StringBuffer buffer = new StringBuffer();
        final FileReader reader = new FileReader(file);
        try {
            while ((len = reader.read(chr)) > 0) {
                buffer.append(chr, 0, len);
            }
        } finally {
            reader.close();
        }
        return buffer.toString();
    }
19012#/**
     * This method serializes an object to an output stream.
     *
     * @param file The output file
     * @param object The object to be serialized
     * @exception IOException IOError
     * @deprecated To be removed in cocoon 2.3
     */
    public static void serializeObject(File file, Object object)
    throws IOException {
        FileOutputStream fos = new FileOutputStream(file);
        try {
            ObjectOutputStream oos = new ObjectOutputStream(new BufferedOutputStream(fos));
            oos.writeObject(object);
            oos.flush();
        } finally {
            fos.close();
        }
    }
19013#/**
     * This method deserializes an object from an input stream.
     *
     * @param file The input file
     * @return The deserialized object
     * @exception IOException IOError
     * @deprecated To be removed in cocoon 2.3
     */
    public static Object deserializeObject(File file)
    throws IOException, ClassNotFoundException {
        FileInputStream fis = new FileInputStream(file);
        Object object = null;
        try {
            ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(fis));
            object = ois.readObject();
        } finally {
            fis.close();
        }
        return object;
    }
19014#/**
     * checks if the input string is a valid java keyword.
     * @return boolean true/false
     */
    private static boolean isJavaKeyword(String keyword) {
        return (Arrays.binarySearch(keywords, keyword, englishCollator) >= 0);
    }
19015#// **********************
    // File Methods
    // **********************

    /**
     * Return a modified filename suitable for replicating directory structures
     * below the store's base directory. The following conversions are
     * performed:
     * <ul>
     * <li>Path separators are converted to regular directory names</li>
     * <li>File path components are transliterated to make them valid (?)
     * programming language identifiers. This transformation may well generate
     * collisions for unusual filenames.</li>
     * </ul>
     * 
     * @return The transformed filename
     */
    public static String normalizedFilename(String filename) {
        if ("".equals(filename)) {
            return "";
        }
        filename = (File.separatorChar == '\\') ? filename.replace('/', '\\') : filename.replace(
                '\\', '/');
        String[] path = StringUtils.split(filename, File.separator);
        int start = (path[0].length() == 0) ? 1 : 0;

        StringBuffer buffer = new StringBuffer();
        for (int i = start; i < path.length; i++) {

            if (i > start) {
                buffer.append(File.separator);
            }

            if (path[i].equals("..")) {
                int lio;
                for (lio = buffer.length() - 2; lio >= 0; lio--) {
                    if (buffer.substring(lio).startsWith(File.separator)) {
                        break;
                    }
                }
                if (lio >= 0) {
                    buffer.setLength(lio);
                }
            } else {
                char[] chars = path[i].toCharArray();

                if (chars.length < 1 || !Character.isLetter(chars[0])) {
                    buffer.append('_');
                }

                for (int j = 0; j < chars.length; j++) {
                    if (org.apache.cocoon.util.StringUtils.isAlphaNumeric(chars[j])) {
                        buffer.append(chars[j]);
                    } else {
                        buffer.append('_');
                    }
                }

                // Append the suffix if necessary.
                if (isJavaKeyword(path[i]))
                    buffer.append(keywordSuffix);
            }

        }
        return buffer.toString();
    }
19016#/**
     * Remove file information from a filename returning only its path component
     * 
     * @param filename
     *            The filename
     * @return The path information
     * @deprecated To be removed in cocoon 2.3
     */
    public static String pathComponent(String filename) {
        int i = filename.lastIndexOf(File.separator);
        return (i > -1) ? filename.substring(0, i) : filename;
    }
19017#/**
     * Remove path information from a filename returning only its file component
     * 
     * @param filename
     *            The filename
     * @return The filename sans path information
     * @deprecated To be removed in cocoon 2.3
     */
    public static String fileComponent(String filename) {
        int i = filename.lastIndexOf(File.separator);
        return (i > -1) ? filename.substring(i + 1) : filename;
    }
19018#/**
     * Strip a filename of its <i>last</i> extension (the portion immediately
     * following the last dot character, if any)
     * 
     * @param filename
     *            The filename
     * @return The filename sans extension
     * @deprecated To be removed in cocoon 2.3
     */
    public static String baseName(String filename) {
        int i = filename.lastIndexOf('.');
        return (i > -1) ? filename.substring(0, i) : filename;
    }
19019#/**
     * Get the complete filename corresponding to a (typically relative)
     * <code>File</code>. This method accounts for the possibility of an
     * error in getting the filename's <i>canonical</i> path, returning the
     * io/error-safe <i>absolute</i> form instead
     * 
     * @param file
     *            The file
     * @return The file's absolute filename
     */
    public static String getFullFilename(File file) {
        try {
            return file.getCanonicalPath();
        } catch (Exception e) {
            return file.getAbsolutePath();
        }
    }
19020#/**
     * Return the path within a base directory
     */
    public static String getContextFilePath(String directoryPath, String filePath) {
        try {
            File directory = new File(directoryPath);
            File file = new File(filePath);

            directoryPath = directory.getCanonicalPath();
            filePath = file.getCanonicalPath();

            // If the context directory does not have a File.separator
            // at the end then add one explicitly
            if(!directoryPath.endsWith(File.separator)){
                directoryPath += File.separator;
            }

            // If the context dir contains both kinds of separator
            // then standardize on using the File.separator
            if ((directoryPath.indexOf('/') !=-1) && (directoryPath.indexOf('\\') !=-1)) {
                directoryPath = directoryPath.replace('\\', File.separator.charAt(0));
                directoryPath = directoryPath.replace('/', File.separator.charAt(0));
            }

            // If the file path contains both kinds of separator
            // then standardize on using the File.separator
            if ((filePath.indexOf('/') !=-1) && (filePath.indexOf('\\') !=-1)) {
                filePath = filePath.replace('\\', File.separator.charAt(0));
                filePath = filePath.replace('/', File.separator.charAt(0));
            }

            if (filePath.startsWith(directoryPath)) {
                filePath = filePath.substring(directoryPath.length());
            }
        } catch (Exception e){
            // ignore
        }

        return filePath;
    }
19021#/**
     * Return a file with the given filename creating the necessary directories
     * if not present.
     * 
     * @param filename
     *            The file
     * @return The created File instance
     */
    public static File createFile(File destDir, String filename) {
        File file = new File(destDir, filename);
        File parent = file.getParentFile();
        if (parent != null)
            parent.mkdirs();
        return file;
    }
19022#/**
     * Returns a byte array from the given object.
     * 
     * @param object
     *            to convert
     * @return byte array from the object
     * @deprecated To be removed in cocoon 2.3
     */
    public static byte[] objectToBytes(Object object) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream os = new ObjectOutputStream(baos);
        os.writeObject(object);
        return baos.toByteArray();
    }
19023#/**
     * Returns a object from the given byte array.
     * 
     * @param bytes
     *            array to convert
     * @return object
     * @deprecated To be removed in cocoon 2.3
     */
    public static Object bytesToObject(byte[] bytes) throws IOException, ClassNotFoundException {
        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
        ObjectInputStream is = new ObjectInputStream(bais);
        return is.readObject();
    }
19024#public ResizableContainer(int initialCapacity){
        this.container = new Object[initialCapacity];
    }
19025#public void add(Object o) {
        set(++pointer,o);
    }
19026#public void set(int index, Object o) {
        adjustPointer(index);
        ensureCapacity(index+1);
        container[index] = o;
        size++;
    }
19027#public Object get(int index) {
        return (index < container.length) ? container[index] : null; 
    }
19028#public int size() {
        return size;
    }
19029#private void adjustPointer(int newPointer) {
        this.pointer = Math.max(this.pointer, newPointer);
    }
19030#private void ensureCapacity(int minCapacity) {
        int oldCapacity = container.length;
        if (oldCapacity < minCapacity) {
            Object[] oldContainer = container;
            int newCapacity = (oldCapacity * 3)/2 + 1;
            if (newCapacity < minCapacity) {
                newCapacity = minCapacity;
            }
            container = new Object[newCapacity];
            System.arraycopy(oldContainer, 0, container, 0, oldContainer.length);
        }
    }
19031#/**
     * Split a string as an array using whitespace as separator
     *
     * @param line The string to be split
     * @return An array of whitespace-separated tokens
     */
    public static String[] split(String line) {
        return split(line, " \t\n\r");
    }
19032#/**
     * Split a string as an array using a given set of separators
     *
     * @param line The string to be split
     * @param delimiter A string containing token separators
     * @return An array of token
     * @deprecated Use commons lang instead.
     */
    public static String[] split(String line, String delimiter) {
        return org.apache.commons.lang.StringUtils.split(line, delimiter);
    }
19033#/**
     * Tests whether a given character is alphabetic, numeric or
     * underscore
     *
     * @param c The character to be tested
     * @return whether the given character is alphameric or not
     */
    public static boolean isAlphaNumeric(char c) {
        return c == '_' ||
            (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z') ||
            (c >= '0' && c <= '9');
    }
19034#/**
     * Replaces tokens in input with Value present in System.getProperty
     */
    public static String replaceToken(String s) {
        int startToken = s.indexOf("${");
        int endToken = s.indexOf("}",startToken);
        String token = s.substring(startToken+2,endToken);
        StringBuffer value = new StringBuffer();
        value.append(s.substring(0,startToken));
        value.append(System.getProperty(token));
        value.append(s.substring(endToken+1));
        return value.toString();
    }
19035#public ImageProperties(int width, int height, char[] comment, String type) {
        this.width = width;
        this.height = height;
        this.comment = comment;
        this.type = type;
    }
19036#public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append(type).append(" ").append(width).append("x").append(height);
        if (comment != null) {
            sb.append(" (").append(comment).append(")");
        }
        return (sb.toString());
    }
19037#/**
     * Creates a new buffered output stream to write data to the 
     * specified underlying output stream with a default 8192-byte
     * buffer size.
     *
     * @param   out   the underlying output stream.
     */
    public BufferedOutputStream(OutputStream out) {
        this(out, 8192);
    }
19038#/**
     * Creates a new buffered output stream to write data to the 
     * specified underlying output stream with the specified buffer 
     * size. 
     *
     * @param   out    the underlying output stream.
     * @param   size   the buffer size.
     * @exception IllegalArgumentException if size <= 0.
     */
    public BufferedOutputStream(OutputStream out, int size) {
        super(out);
        if (size <= 0) {
            throw new IllegalArgumentException("Buffer size <= 0");
        }
        this.buf = new byte[size];
    }
19039#/**
     * Writes the specified byte to this buffered output stream. 
     *
     * @param      b   the byte to be written.
     * @exception  IOException  if an I/O error occurs.
     */
    public void write(int b) throws IOException {
        if (this.count >= this.buf.length) {
            this.incBuffer();
        }
        this.buf[count++] = (byte)b;
    }
19040#/**
     * Writes <code>len</code> bytes from the specified byte array 
     * starting at offset <code>off</code> to this buffered output stream.
     *
     * <p> Ordinarily this method stores bytes from the given array into this
     * stream's buffer, flushing the buffer to the underlying output stream as
     * needed.  If the requested length is at least as large as this stream's
     * buffer, however, then this method will flush the buffer and write the
     * bytes directly to the underlying output stream.  Thus redundant
     * <code>BufferedOutputStream</code>s will not copy data unnecessarily.
     *
     * @param      b     the data.
     * @param      off   the start offset in the data.
     * @param      len   the number of bytes to write.
     * @exception  IOException  if an I/O error occurs.
     */
    public void write(byte b[], int off, int len) throws IOException {
        while (len > buf.length - count) {
            this.incBuffer();
        }
        System.arraycopy(b, off, buf, count, len);
        count += len;
    }
19041#/**
     * Flushes this buffered output stream. 
     * We don't flush here, flushing is done during closing.
     *
     * @exception  IOException  if an I/O error occurs.
     */
    public void flush() throws IOException {
        // nothing
    }
19042#/**
     * Closes this buffered output stream.
     * Flush before closing.
     *
     * @exception  IOException  if an I/O error occurs.
     */
    public void close() throws IOException {
        realFlush();
        super.close ();
    }
19043#/**
     * Flushes this buffered output stream. 
     */
    public void realFlush() throws IOException {
        this.writeBuffer();
        this.out.flush();
    }
19044#/**
     * Write the buffer
     */
    private void writeBuffer() 
    throws IOException {
        if (this.count > 0) {
            this.out.write(this.buf, 0, this.count);
            this.clearBuffer();
        }
    }
19045#/**
     * Increment the buffer
     */
    private void incBuffer() {
        // currently we double the buffer size
        // this is not so fast but is a very simple logic
        byte[] newBuf = new byte[this.buf.length * 2];
        System.arraycopy(this.buf, 0, newBuf, 0, this.buf.length);
        this.buf = newBuf;
    }
19046#/**
     * Clear/reset the buffer
     */
    public void clearBuffer() {
        this.count = 0;
    }
19047#/**
     * Return the size of the current buffer
     */
    public int getCount() {
        return this.count;
    }
19048#/**
    * Creates a PostInputStream
    */
    public PostInputStream() {
        super();
    }
19049#/**
    * Creates a <code>PostInputStream</code> based on a real InputStream object with the specified
    * post message body length. Saves its  argument, the input stream
    * <code>m_inputStream</code>, for later use.
    *
    * @param   input     the underlying input stream.
    * @param   len   the post message body length.
    * @exception IllegalArgumentException  len <= 0.
    */

    public PostInputStream(final InputStream input, final int len) throws IllegalArgumentException {
        super();
        init(input, len );
    }
19050#/**
    * Sets the underlying input stream and contentLen value .
    *
    * @param input the input stream; can not be null.
    * @param len the post message body length.
    *
    * @throws IllegalArgumentException
    */
    protected void init(final InputStream input, final int len) throws IllegalArgumentException {
        if (len <= 0) {
            throw new IllegalArgumentException("contentLen <= 0 ");
        }
        this.m_inputStream = input;
        this.m_contentLen = len;
    }
19051#/**
    * Sets the underlying input stream and contentLen value .
    *
    * @param input the input stream; can not be null.
    * @param len the post message body length.
    *
    * @throws IOException
    */
    public synchronized void setInputStream(final InputStream input, final int len) throws IOException {
        if (m_inputStream != null) {
            close();
        }
        init(input, len);
    }
19052#/**
    * Returns the underlying input stream.
    *
    * @return inputStream the underlying InputStream.
    */
    public InputStream getInputStream() {
        return m_inputStream;
    }
19053#/**
    * Returns the post message body length.
    *
    * @return m_contentLen;
    */

    public int getContentLen() {
        return( m_contentLen );
    }
19054#/**
    * Reads the next byte from the input stream.  If the end of the stream has been reached, this method returns -1.
    *
    * @return the next byte or -1 if at the end of the stream.
    *
    * @throws IOException
    */
    public synchronized int read() throws IOException {

        checkOpen();
        if (m_bytesRead == m_contentLen) {
            return -1;
        }
        int byt =  m_inputStream.read();
        if (byt != -1) {
           m_bytesRead++;
        }
        return byt;
    }
19055#/**
    * Reads bytes from this byte-input stream into the specified byte array,
    * starting at the given offset.
    *
    * <p> This method implements the general contract of the corresponding
    * <code>{@link InputStream#read(byte[], int, int) read}</code> method of
    * the <code>{@link InputStream}</code> class.
    * This method delegetes the read operation to the underlying InputStream implementation class but it
    * controlls the number of bytes read from the stream. In the remote situation the underlying InputStream has no knowledge of
    * the length of the stream and the notion of the "end" is undefined. This wrapper class has a knowledge of the
    * length of data send by the requestor by the means of contentLength. This method returns the number of bytes read and
    * accumulates the total number of bytes read in m_bytesRead. When the m_bytesRead is equal to the specified contentLength
    * value the method returns returns -1 to signal the end of data.
    *
    * @param buffer the byte array to read into; can not be null.
    * @param offset the starting offset in the byte array.
    * @param len the maximum number of bytes to read.
    *
    * @return     the number of bytes read, or <code>-1</code> if the end of
    *             the stream has been reached.
    * @exception  IOException  if an I/O error occurs.
    */

    public synchronized int read(byte[] buffer, int offset, int len) throws IOException {
        checkOpen();
        if (m_bytesRead == m_contentLen) {
            return -1;
        }
        int available = Math.min( available(), len );
        int num = m_inputStream.read( buffer, offset, available );
        if (num > 0) {
            m_bytesRead += num;
        }
        return num;
    }
19056#public synchronized int read(byte[] buffer) throws IOException {

        return read( buffer, 0, buffer.length);
    }
19057#/**
    * Checks to see if this stream is closed; if it is, an IOException is thrown.
    *
    * @throws IOException
    */
    protected void checkOpen() throws IOException {
        if (m_inputStream == null) {
            throw new IOException("InputStream closed");
        }
    }
19058#/**
         * See the general contract of the <code>skip</code>
     * method of <code>InputStream</code>.
     * Delegates execution to the underlying InputStream implementation class.
     * Checks to see if this stream is closed; if it is, an IOException is thrown.
     * @param      n   the number of bytes to be skipped.
     * @return     the actual number of bytes skipped.
     * @exception  IOException  if an I/O error occurs.
     */
    public synchronized long skip(long n) throws IOException {
        checkOpen();
        if ( m_bytesRead == m_contentLen )
        {
            return ( 0 );
        }
        else
        {
            return ( m_inputStream.skip( n ) );
        }

    }
19059#/**
    * Returns the number of bytes available from this input stream that can be read without the stream blocking.
    * Delegates execution to the underlying InputStream implementation class.
    * @return available the number of available bytes.
    *
    * @throws IOException
    */
    public synchronized int available() throws IOException {
        checkOpen();
        int avail = m_inputStream.available();
        return (avail == 0 ? (m_contentLen - m_bytesRead) : avail);
    }
19060#/**
    * Tests if this input stream supports the <code>mark</code>
    * and <code>reset</code> methods. The <code>markSupported</code>
    * method of <code>BufferedInputStream</code> returns
    * <code>false</code>.
    *
    * @return  a <code>boolean</code> indicating if this stream type supports
    *          the <code>mark</code> and <code>reset</code> methods.
    * @see     java.io.InputStream#mark(int)
    * @see     java.io.InputStream#reset()
    */
    public boolean markSupported() {
        return false;
    }
19061#/**
    * Closes this input stream by closing the underlying stream and marking this one as closed.
    *
    * @throws IOException
    */
    public synchronized void close() throws IOException {
        if (m_inputStream == null) {
            return;
        }
        m_inputStream.close();
        m_inputStream = null;
        m_contentLen = 0;
        m_bytesRead = 0;
    }
19062#/**
    * Returns a String representation of this.
    *
    * @return string the String representation of this.
    */
    public String toString() {
        return new StringBuffer(getClass().getName())
                .append("[inputStream=").append(m_inputStream)
                .append(",  contentLen=").append(m_contentLen)
                .append("bytesRead=").append(m_bytesRead)
                .append("]").toString();
    }
19063#final public static ImageProperties getImageProperties(File file) throws FileNotFoundException, IOException, FileFormatException {
        String type = MIMEUtils.getMIMEType(file);

        if ("image/gif".equals(type)) {
             return (getGifProperties(file));
        }
        else if ("image/jpeg".equals(type)) {
            return (getJpegProperties(file));
        }
        else {
            return (null);
        }
    }
19064#final public static ImageProperties getJpegProperties(File file) throws FileNotFoundException, IOException, FileFormatException {
        BufferedInputStream in = null;
        try {
            in = new BufferedInputStream(new FileInputStream(file));

            // check for "magic" header
            byte[] buf = new byte[2];
            int count = in.read(buf, 0, 2);
            if (count < 2) {
                throw new FileFormatException("Not a valid Jpeg file!");
            }
            if ((buf[0]) != (byte) 0xFF || (buf[1]) != (byte) 0xD8) {
                throw new FileFormatException("Not a valid Jpeg file!");
            }

            int width = 0;
            int height = 0;
            char[] comment = null;

            boolean hasDims = false;
            boolean hasComment = false;
            int ch = 0;

            while (ch != 0xDA && !(hasDims && hasComment)) {
                /* Find next marker (JPEG markers begin with 0xFF) */
                while (ch != 0xFF) {
                    ch = in.read();
                }
                /* JPEG markers can be padded with unlimited 0xFF's */
                while (ch == 0xFF) {
                    ch = in.read();
                }
                /* Now, ch contains the value of the marker. */

                int length = 256 * in.read();
                length += in.read();
                if (length < 2) {
                    throw new FileFormatException("Not a valid Jpeg file!");
                }
                /* Now, length contains the length of the marker. */

                if (ch >= 0xC0 && ch <= 0xC3) {
                    in.read();
                    height = 256 * in.read();
                    height += in.read();
                    width = 256 * in.read();
                    width += in.read();
                    for (int foo = 0; foo < length - 2 - 5; foo++) {
                        in.read();
                    }
                    hasDims = true;
                }
                else if (ch == 0xFE) {
                    // that's the comment marker
                    comment = new char[length-2];
                    for (int foo = 0; foo < length - 2; foo++)
                        comment[foo] = (char) in.read();
                    hasComment = true;
                }
                else {
                    // just skip marker
                    for (int foo = 0; foo < length - 2; foo++) {
                        in.read();
                    }
                }
            }
            return (new ImageProperties(width, height, comment, "jpeg"));

        }
        finally {
            if (in != null) {
                try {
                    in.close();
                }
                catch (IOException e) {
                }
            }
        }
    }
19065#final public static ImageProperties getGifProperties(File file) throws FileNotFoundException, IOException, FileFormatException {
        BufferedInputStream in = null;
        try {
            in = new BufferedInputStream(new FileInputStream(file));
            byte[] buf = new byte[10];
            int count = in.read(buf, 0, 10);
            if (count < 10) {
                throw new FileFormatException("Not a valid Gif file!");
            }
            if ((buf[0]) != (byte) 'G' || (buf[1]) != (byte) 'I' || (buf[2]) != (byte) 'F') {
                throw new FileFormatException("Not a valid Gif file!");
            }

            int w1 = (buf[6] & 0xff) | (buf[6] & 0x80);
            int w2 = (buf[7] & 0xff) | (buf[7] & 0x80);
            int h1 = (buf[8] & 0xff) | (buf[8] & 0x80);
            int h2 = (buf[9] & 0xff) | (buf[9] & 0x80);

            int width = w1 + (w2 << 8);
            int height = h1 + (h2 << 8);

            return (new ImageProperties(width, height, null,"gif"));

        }
        finally {
            if (in != null) {
                try {
                    in.close();
                }
                catch (IOException e) {
                }
            }
        }
    }
19066#public FileFormatException(String s) {
        super(s);
    }
19067#public FileFormatException(String s, Throwable throwable) {
        super(s, throwable);
    }
19068#public TraxErrorHandler() {
        this.logger = LogFactory.getLog(getClass());
    }
19069#public TraxErrorHandler(Log logger) {
        this.logger = logger;
    }
19070#/** @deprecated Use {@link #TraxErrorHandler(Log)}. } */
    public TraxErrorHandler(Logger logger) {
        this.logger = new AvalonLogger(logger);
    }
19071#public void warning(TransformerException exception)
    throws TransformerException {
        final String message = getMessage(exception);
        if (this.logger != null) {
            this.logger.warn(message);
        } else {
            System.out.println("WARNING: " + message);
        }
        warnings.append("Warning: ");
        warnings.append(message);
        warnings.append("\n");
    }
19072#public void error(TransformerException exception)
    throws TransformerException {
        final String message = getMessage(exception);
        if (this.logger != null) {
            this.logger.error(message, exception);
        } else {
            System.out.println("ERROR: " + message);
        }
        warnings.append("Error: ");
        warnings.append(message);
        warnings.append("\n");
    }
19073#public void fatalError(TransformerException exception)
    throws TransformerException {
        final String message = getMessage(exception);
        if (this.logger != null) {
            this.logger.fatal(message, exception);
        } else {
            System.out.println("FATAL-ERROR: " + message);
        }
        warnings.append("Fatal: ");
        warnings.append(message);
        warnings.append("\n");

        try {
            throw new TransformerException(warnings.toString());
        } finally {
            warnings = new StringBuffer();
        }
    }
19074#private String getMessage(TransformerException exception) {
        SourceLocator locator = exception.getLocator();
        if (locator != null) {
            String id = (!locator.getPublicId().equals(locator.getPublicId()))
                    ? locator.getPublicId()
                    : (null != locator.getSystemId())
                    ? locator.getSystemId() : "SystemId Unknown";
            return "File " + id
                   + "; Line " + locator.getLineNumber()
                   + "; Column " + locator.getColumnNumber()
                   + "; " + exception.getMessage();
        }
        return exception.getMessage();
    }
19075#public static Map discoverFields(
            final Class pClazz,
            final Matcher pMatcher
            ) {
        
        return discoverFields(pClazz, pMatcher, defaultIndexer);
    }
19076#public static Map discoverFields(
            final Class pClazz
            ) {
        
        return discoverFields(pClazz, defaultMatcher, defaultIndexer);
    }
19077#public static Map discoverFields(
            final Class pClazz,
            final Matcher pMatcher,
            final Indexer pIndexer
            ) {
        
        System.out.println("discovering fields on " + pClazz.getName());
        
        final Map result = new HashMap();

        Class current = pClazz;
        do {
            final Field[] fields = current.getDeclaredFields();
            for (int i = 0; i < fields.length; i++) {
                final String fname = fields[i].getName();
                if (pMatcher.matches(fname)) {
                    pIndexer.put(result, fname, fields[i]);
                }
            }
            current = current.getSuperclass();
        } while(current != null);
     
        return result;
    }
19078#public static Map discoverMethods(
            final Class pClazz,
            final Matcher pMatcher
            ) {
        
        return discoverMethods(pClazz, pMatcher, defaultIndexer);
    }
19079#public static Map discoverMethods(
            final Class pClazz
            ) {
        
        return discoverMethods(pClazz, defaultMatcher, defaultIndexer);
    }
19080#public static Map discoverMethods(
            final Class pClazz,
            final Matcher pMatcher,
            final Indexer pIndexer
            ) {
        
        System.out.println("discovering methods on " + pClazz.getName());
        
        final Map result = new HashMap();

        Class current = pClazz;
        do {
            final Method[] methods = current.getDeclaredMethods();
            for (int i = 0; i < methods.length; i++) {
                final String mname = methods[i].getName();
                if (pMatcher.matches(mname)) {
                    pIndexer.put(result, mname, methods[i]);
                }
            }
            current = current.getSuperclass();
        } while(current != null);
     
        return result;
    }
19081#boolean matches(final String pName);
19082#void put(final Map pMap, final String pKey, final Object pObject);
19083#public boolean matches(final String pName) {
            return pName.startsWith("do");
        }
19084#public void put(final Map pMap, final String pKey, final Object pObject) {

            // doAction -> action
            final String name = Character.toLowerCase(pKey.charAt(2)) + pKey.substring(3);

            System.out.println("reflecting " + name);
            pMap.put(name, pObject);
        }
19085#//~ Methods ------------------------------------------------------------------------------------

    /**
     * Match a pattern agains a string and isolates wildcard replacement into a <code>Map</code>.
     * <br>
     * Here is how the matching algorithm works:
     *
     * <ul>
     *   <li>
     *     The '*' character, meaning that zero or more characters (excluding the path separator '/')
     *     are to be matched.
     *   </li>
     *   <li>
     *     The '**' sequence, meaning that zero or more characters (including the path separator '/')
     *     are to be matched.
     *   </li>
     *   <li>
     *     The '\*' sequence is honored as a litteral '*' character, not a wildcard
     *   </li>
     * </ul>
     * <br>
     * When more than two '*' characters, not separated by another character, are found their value is
     * considered as '**' and immediate succeeding '*' are skipped.
     * <br>
     * The '**' wildcard is greedy and thus the following sample matches as {"foo/bar","baz","bug"}:
     * <dl>
     *   <dt>pattern</dt>
     *   <dd>STAR,STAR,PATHSEP,STAR,PATHSEP,STAR,STAR (why can't I express it litterally?)</dt>
     *   <dt>string</dt>
     *   <dd>foo/bar/baz/bug</dt>
     * </dl>
     * The first '**' in the pattern will suck up as much as possible without making the match fail.
     * 
     * @param pat The pattern string.
     * @param str The string to math agains the pattern
     *
     * @return a <code>Map</code> containing the representation of the extracted pattern. The extracted patterns are
     *         keys in the <code>Map</code> from left to right beginning with "1" for te left most, "2" for the next,
     *         a.s.o. The key "0" is the string itself. If the return value is null, string does not match to the
     *         pattern .
     */
    public static Map match(final String pat,
                            final String str) {
        Matcher matcher;
        synchronized (cache) {
            matcher = (Matcher) cache.get(pat);
            if ( matcher == null ) {
                matcher = new Matcher(pat);
                cache.put(pat, matcher);
            }
        }

        String[] list = matcher.getMatches(str);
        if ( list == null )
            return null;

        int n = list.length;
        Map map = new HashMap(n * 2 + 1);
        for ( int i = 0; i < n; i++ ) {
            map.put(String.valueOf(i), list[i]);
        }

        return map;
    }
19086#/**
     * Compile wildcard pattern into regexp pattern.
     * 
     * @param pat The wildcard pattern
     * @return compiled regexp program.
     */
    private static REProgram compileRegexp(String pat) {
        StringBuffer repat = new StringBuffer(pat.length() * 6);
        repat.append('^');

        // Add an extra character to allow unchecked wcpat[i+1] accesses.
        // Unterminated ESC sequences are silently handled as '\\'.
        char[] wcpat = (pat + ESC).toCharArray();
        for ( int i = 0, n = pat.length(); i < n; i++ ) {
            char ch = wcpat[i];

            if ( ch == STAR ) {
                if ( wcpat[i + 1] != STAR ) {
                    repat.append("([^/]*)");
                    continue;
                }

                // Handle two and more '*' as single '**'.
                while ( wcpat[i + 1] == STAR )
                    i++;
                repat.append("(.*)");
                continue;
            }

            // Match ESC+ESC and ESC+STAR as literal ESC and STAR which needs to be escaped
            // in regexp. Match ESC+other as two characters ESC+other where other may also
            // need to be escaped in regexp.
            if ( ch == ESC ) {
                ch = wcpat[++i];
                if ( ch != ESC && ch != STAR )
                    repat.append("\\\\");
            }

            if ( ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9'
                 || ch == '/' ) {
                repat.append(ch);
                continue;
            }

            repat.append('\\');
            repat.append(ch);
        }
        repat.append('$');

        return new RECompiler().compile(repat.toString());
    }
19087#//~ Constructors ---------------------------------------------------------------------------

        /**
         * Creates a new Matcher object.
         *
         * @param pat The pattern
         * @param str The string
         */
        Matcher(final String pat) {
            RE re = new RE(splitter);

            if ( re.match(pat) ) {

                // Split pattern into (foo/)(*)(/bar).

                prefix = re.getParen(1);
                String wildcard = re.getParen(2);
                String tail = re.getParen(3);

                // If wildcard ends with \ then add the first char of postfix to wildcard.
                if ( tail.length() != 0 && wildcard.charAt(wildcard.length() - 1) == ESC ) {
                    wildcard = wildcard + tail.substring(0, 1);
                    suffix = tail.substring(1);
                }
                else {
                    suffix = tail;
                }

                // Use short-cuts for single * or ** wildcards

                if ( wildcard.equals("*") ) {
                    wctype = WC_STAR;
                    regexp = null;
                }
                else if ( wildcard.equals("**") ) {
                    wctype = WC_STARSTAR;
                    regexp = null;
                }
                else {
                    wctype = WC_REGEXP;
                    regexp = compileRegexp(wildcard);
                }
            }
            else {
                // Pattern is a constant without '*' or '\'.
                prefix = pat;
                suffix = "";
                wctype = WC_CONST;
                regexp = null;
            }

            fixlen = prefix.length() + suffix.length();
        }
19088#//~ Methods --------------------------------------------------------------------------------

        /**
         * Match string against pattern.
         * 
         * @param str The string
         * @return list of wildcard matches, null if match failed
         */
        String[] getMatches(final String str) {

            // Protect against 'foo' matching 'foo*foo'.
            if ( str.length() < fixlen )
                return null;

            if ( !str.startsWith(prefix) )
                return null;

            if ( !str.endsWith(suffix) )
                return null;

            String infix = str.substring(prefix.length(), str.length() - suffix.length());

            if ( wctype == WC_REGEXP ) {
                RE re = new RE(regexp);
                if ( !re.match(infix) )
                    return null;

                int n = re.getParenCount();
                String[] list = new String[n];
                list[0] = str;
                for ( int i = 1; i < n; i++ )
                    list[i] = re.getParen(i);
                return list;
            }

            if ( wctype == WC_CONST ) {
                if ( infix.length() != 0 )
                    return null;
                return new String[] {
                    str
                };
            }

            if ( wctype == WC_STAR ) {
                if ( infix.indexOf(PATHSEP) != -1 )
                    return null;
            }

            return new String[] {
                str, infix
            };
        }
19089#public ByteRange(long start, long end) {
        this.start = start;
        this.end = end;
    }
19090#public ByteRange(String string) throws NumberFormatException {
        string = string.trim();
        int dashPos = string.indexOf('-');
        int length = string.length();
        if (string.indexOf(',') != -1) {
            throw new NumberFormatException("Simple ByteRange String contains a comma.");
        }
        if (dashPos > 0) {
            this.start = Integer.parseInt(string.substring(0, dashPos));
        } else {
            this.start = Long.MIN_VALUE;
        }
        if (dashPos < length - 1) {
            this.end = Integer.parseInt(string.substring(dashPos + 1, length));
        } else {
            this.end = Long.MAX_VALUE;
        }
        if (this.start > this.end) {
            throw new NumberFormatException("Start value is greater than end value.");
        }
    }
19091#public long getStart() {
        return this.start;
    }
19092#public long getEnd() {
        return this.end;
    }
19093#public long length() {
        return this.end - this.start + 1;
    }
19094#public ByteRange intersection(ByteRange range) {
        if (range.end < this.start || this.end < range.start) {
            return null;
        } else {
            long start = (this.start > range.start) ? this.start : range.start;
            long end = (this.end < range.end) ? this.end : range.end;
            return new ByteRange(start, end);
        }
    }
19095#public String toString() {
        return this.start + "-" + this.end;
    }
19096#public DeprecationException(String message) {
        super(message);
    }
19097#/**
     * This is buzhash the hash function on which most other Hash methods
     * are built.
     */
    private static long buzhash (StringBuffer arg) {
        /* Hash StringBuffer */
        long h = initial_hash;
        for ( int i=0; i<arg.length(); ++i )
            h = (h<<1) ^ (h>>>63) ^
                mix_master[ ( arg.charAt(i) ^ (arg.charAt(i)>>>8) ) & 0xff ];
        return h;
    }
19098#/**
     * This is buzhash the hash function on which most other Hash methods
     * are built.
     */
    private static long buzhash (String arg) {
        /* Hash StringBuffer */
        long h = initial_hash;
        for ( int i=0; i<arg.length(); ++i )
            h = (h<<1) ^ (h>>>63) ^
                mix_master[ ( arg.charAt(i) ^ (arg.charAt(i)>>>8) ) & 0xff ];
        return h;
    }
19099#/**
     * Hash a String.
     *
     * @param arg The String to be hashed
     * @return The hash for the input.
     */
    public static long hash(String arg) {
        // Make Hash from String
        return buzhash( arg );
    }
19100#/**
     * Hash a String.
     *
     * @param arg The String represented by the StringBuffer to be hashed
     * @return The hash for the input.
     */
    public static long hash(StringBuffer arg) {
        // Make Hash from StringBuffer
        return buzhash( arg );
    }
19101#public CLLoggerWrapper(Log l) {
        this.log = l;
    }
19102#/**
     * @see org.apache.avalon.framework.logger.Logger#debug(java.lang.String, java.lang.Throwable)
     */
    public void debug(String arg0, Throwable arg1) {
        log.debug(arg0, arg1);
    }
19103#/**
     * @see org.apache.avalon.framework.logger.Logger#debug(java.lang.String)
     */
    public void debug(String arg0) {
        log.debug(arg0);
    }
19104#/**
     * @see org.apache.avalon.framework.logger.Logger#error(java.lang.String, java.lang.Throwable)
     */
    public void error(String arg0, Throwable arg1) {
        log.error(arg0, arg1);
    }
19105#/**
     * @see org.apache.avalon.framework.logger.Logger#error(java.lang.String)
     */
    public void error(String arg0) {
        log.error(arg0);
    }
19106#/**
     * @see org.apache.avalon.framework.logger.Logger#fatalError(java.lang.String, java.lang.Throwable)
     */
    public void fatalError(String arg0, Throwable arg1) {
        log.fatal(arg0, arg1);
    }
19107#/**
     * @see org.apache.avalon.framework.logger.Logger#fatalError(java.lang.String)
     */
    public void fatalError(String arg0) {
        log.fatal(arg0);
    }
19108#/**
     * @see org.apache.avalon.framework.logger.Logger#info(java.lang.String, java.lang.Throwable)
     */
    public void info(String arg0, Throwable arg1) {
        log.info(arg0, arg1);
    }
19109#/**
     * @see org.apache.avalon.framework.logger.Logger#info(java.lang.String)
     */
    public void info(String arg0) {
        log.info(arg0);
    }
19110#/**
     * @see org.apache.avalon.framework.logger.Logger#isDebugEnabled()
     */
    public boolean isDebugEnabled() {
        return log.isDebugEnabled();
    }
19111#/**
     * @see org.apache.avalon.framework.logger.Logger#isErrorEnabled()
     */
    public boolean isErrorEnabled() {
        return log.isErrorEnabled();
    }
19112#/**
     * @see org.apache.avalon.framework.logger.Logger#isInfoEnabled()
     */
    public boolean isInfoEnabled() {
        return log.isInfoEnabled();
    }
19113#/**
     * @see org.apache.avalon.framework.logger.Logger#isWarnEnabled()
     */
    public boolean isWarnEnabled() {
        return log.isWarnEnabled();
    }
19114#/**
     * @see org.apache.avalon.framework.logger.Logger#warn(java.lang.String, java.lang.Throwable)
     */
    public void warn(String arg0, Throwable arg1) {
        log.warn(arg0, arg1);
    }
19115#/**
     * @see org.apache.avalon.framework.logger.Logger#warn(java.lang.String)
     */
    public void warn(String arg0) {
        log.warn(arg0);
    }
19116#/**
     * @see org.apache.avalon.framework.logger.Logger#getChildLogger(java.lang.String)
     */
    public Logger getChildLogger(String arg0) {
        return this;
    }
19117#/**
     * @see org.apache.avalon.framework.logger.Logger#isFatalErrorEnabled()
     */
    public boolean isFatalErrorEnabled() {
        return this.log.isFatalEnabled();
    }
19118#/**
     * Parse the {@link InputSource} and send
     * SAX events to the consumer.
     * Attention: the consumer can  implement the
     * {@link LexicalHandler} as well.
     * The parse should take care of this.
     */
    void parse( InputSource in, ContentHandler consumer )
    throws SAXException, IOException;
19119#/**
     * Parse the {@link InputSource} and send
     * SAX events to the content handler and
     * the lexical handler.
     */
    void parse( InputSource in,
                ContentHandler contentHandler,
                LexicalHandler lexicalHandler )
    throws SAXException, IOException;
19120#/**
     * Parse the {@link InputSource} and create
     * a DOM out of it.
     */
    Document parseDocument( InputSource in )
        throws SAXException, IOException;
19121#/**
     * Return a new {@link Document}.
     */
    Document createDocument() throws SAXException;
19122#/**
     * @see #setDropDtdComments(boolean)
     */
    public boolean isDropDtdComments() {
        return dropDtdComments;
    }
19123#/**
     * Should comment() events from DTD's be dropped? (Default is false.) Since this implementation
     * does not support the DeclHandler interface anyway, it is quite useless to only have the comments
     * from DTD. And the comment events from the internal DTD subset would appear in the serialized output
     * again.
     */
    public void setDropDtdComments(boolean dropDtdComments) {
        this.dropDtdComments = dropDtdComments;
    }
19124#/**
     * @see #setNsPrefixes(boolean)
     */
    public boolean isNsPrefixes() {
        return nsPrefixes;
    }
19125#/**
     * Do we want namespaces declarations also as 'xmlns:' attributes ?
     * Default is false.
     * <i>Note</i> : setting this to <code>true</code> confuses some XSL
     * processors (e.g. Saxon).
     */
    public void setNsPrefixes(boolean nsPrefixes) {
        this.nsPrefixes = nsPrefixes;
    }
19126#/**
     * @see #setStopOnRecoverableError(boolean)
     */
    public boolean isStopOnRecoverableError() {
        return stopOnRecoverableError;
    }
19127#/**
     * Should the parser stop parsing if a recoverable error occurs ?
     * Default is true.
     */
    public void setStopOnRecoverableError(boolean stopOnRecoverableError) {
        this.stopOnRecoverableError = stopOnRecoverableError;
    }
19128#/**
     * @see #setStopOnWarning(boolean)
     */
    public boolean isStopOnWarning() {
        return stopOnWarning;
    }
19129#/**
     * Should the parser stop parsing if a warning occurs ?
     * Default is true.
     */
    public void setStopOnWarning(boolean stopOnWarning) {
        this.stopOnWarning = stopOnWarning;
    }
19130#/**
     * Return the name of the sax parser factory.
     * @return the name of the sax parser factory.
     * @see #setSaxParserFactoryName(String)
     */
    public String getSaxParserFactoryName() {
        return this.saxParserFactoryName;
    }
19131#/** 
     * Set the name of the <code>SAXParserFactory</code>
     * implementation class to be used instead of using the standard JAXP mechanism
     * (<code>SAXParserFactory.newInstance()</code>). This allows to choose
     * unambiguously the JAXP implementation to be used when several of them are
     * available in the classpath.
     */
    public void setSaxParserFactoryName(String saxParserFactoryName) {
        this.saxParserFactoryName = saxParserFactoryName;
    }
19132#/**
     * Initialize the sax parser factory.
     */
    protected synchronized void initSaxParserFactory()
    throws Exception {
        if ( this.factory == null ) {
            if( "javax.xml.parsers.SAXParserFactory".equals( this.saxParserFactoryName ) ) {
                this.factory = SAXParserFactory.newInstance();
            } else {
                final Class factoryClass = loadClass( this.saxParserFactoryName );
                this.factory = (SAXParserFactory)factoryClass.newInstance();
            }
            this.factory.setNamespaceAware( true );
            this.factory.setValidating( this.validate );
        }
    }
19133#/**
     * @see org.apache.cocoon.core.xml.SAXParser#parse(org.xml.sax.InputSource, org.xml.sax.ContentHandler, org.xml.sax.ext.LexicalHandler)
     */
    public void parse( final InputSource in,
                       final ContentHandler contentHandler,
                       final LexicalHandler lexicalHandler )
    throws SAXException, IOException {
        final XMLReader tmpReader = this.setupXMLReader();

        try {
            LexicalHandler theLexicalHandler = null;
            if ( null == lexicalHandler 
                 && contentHandler instanceof LexicalHandler) {
                theLexicalHandler = (LexicalHandler)contentHandler;
            }   
            if( null != lexicalHandler ) {
                theLexicalHandler = lexicalHandler;
            }
            if (theLexicalHandler != null) {
                if (this.dropDtdComments) {
                    theLexicalHandler = new DtdCommentEater(theLexicalHandler);
                }
                tmpReader.setProperty( "http://xml.org/sax/properties/lexical-handler",
                                       theLexicalHandler );
            }
        } catch( final SAXException e ) {
            final String message =
                "SAX2 driver does not support property: " +
                "'http://xml.org/sax/properties/lexical-handler'";
            this.getLogger().warn( message );
        }
        tmpReader.setContentHandler( contentHandler );

        tmpReader.parse( in );
    }
19134#/**
     * @see org.apache.cocoon.core.xml.SAXParser#parse(org.xml.sax.InputSource, org.xml.sax.ContentHandler)
     */
    public void parse( InputSource in, ContentHandler consumer )
    throws SAXException, IOException {
        this.parse( in, consumer, 
                    (consumer instanceof LexicalHandler ? (LexicalHandler)consumer : null));
    }
19135#/**
     * Creates a new {@link XMLReader} if needed.
     */
    protected XMLReader setupXMLReader()
    throws SAXException {
        if ( this.factory == null ) {
            try {
                this.initSaxParserFactory();
            } catch (Exception e) {
                final String message = "Cannot initialize sax parser factory";
                throw new SAXException( message, e );
            }
        }
        XMLReader reader;
        // Create the XMLReader
        try {
            reader = this.factory.newSAXParser().getXMLReader();
        } catch( final ParserConfigurationException pce ) {
            final String message = "Cannot produce a valid parser";
            throw new SAXException( message, pce );
        }

        reader.setFeature( "http://xml.org/sax/features/namespaces", true );

        if( this.nsPrefixes ) {
            try {
                reader.setFeature("http://xml.org/sax/features/namespace-prefixes",
                                  this.nsPrefixes );
            } catch( final SAXException se ) {
                final String message =
                    "SAX2 XMLReader does not support setting feature: " +
                    "'http://xml.org/sax/features/namespace-prefixes'";
                this.getLogger().warn( message );
            }
        }
        reader.setErrorHandler( this );
        if( this.resolver != null  ) {
            reader.setEntityResolver( this.resolver );
        }

        return reader;
    }
19136#/**
     * Receive notification of a recoverable error.
     */
    public void error( final SAXParseException spe )
    throws SAXException {
        final String message =
            "Error parsing " + spe.getSystemId() + " (line " +
            spe.getLineNumber() + " col. " + spe.getColumnNumber() +
            "): " + spe.getMessage();
        if( this.stopOnRecoverableError ) {
            throw new SAXException( message, spe );
        }
        this.getLogger().error( message, spe );
    }
19137#/**
     * Receive notification of a fatal error.
     */
    public void fatalError( final SAXParseException spe )
    throws SAXException {
        final String message =
            "Fatal error parsing " + spe.getSystemId() + " (line " +
            spe.getLineNumber() + " col. " + spe.getColumnNumber() +
            "): " + spe.getMessage();
        throw new SAXException( message, spe );
    }
19138#/**
     * Receive notification of a warning.
     */
    public void warning( final SAXParseException spe )
    throws SAXException {
        final String message =
            "Warning parsing " + spe.getSystemId() + " (line " +
            spe.getLineNumber() + " col. " + spe.getColumnNumber() +
            "): " + spe.getMessage();

        if( this.stopOnWarning ) {
            throw new SAXException( message, spe );
        }
        this.getLogger().warn( message, spe );
    }
19139#public DtdCommentEater(LexicalHandler nextHandler) {
            this.next = nextHandler;
        }
19140#public void startDTD (String name, String publicId, String systemId)
        throws SAXException {
            inDTD = true;
            next.startDTD(name, publicId, systemId);
        }
19141#public void endDTD ()
        throws SAXException {
            inDTD = false;
            next.endDTD();
        }
19142#public void startEntity (String name)
        throws SAXException {
            next.startEntity(name);
        }
19143#public void endEntity (String name)
        throws SAXException {
            next.endEntity(name);
        }
19144#public void startCDATA ()
        throws SAXException {
            next.startCDATA();
        }
19145#public void endCDATA ()
        throws SAXException {
            next.endCDATA();
        }
19146#public void comment (char ch[], int start, int length)
        throws SAXException {
            if (!inDTD) {
                next.comment(ch, start, length);
            }
        }
19147#public String getDocumentBuilderFactoryName() {
        return documentBuilderFactoryName;
    }
19148#public void setDocumentBuilderFactoryName(String documentBuilderFactoryName) {
        this.documentBuilderFactoryName = documentBuilderFactoryName;
    }
19149#/**
     * Initialize the dom builder factory.
     */
    protected synchronized void initDomBuilderFactory()
    throws Exception {
        if ( this.factory == null ) {
            if( "javax.xml.parsers.DocumentBuilderFactory".equals( this.documentBuilderFactoryName ) ) {
                this.factory = DocumentBuilderFactory.newInstance();
            } else {
                final Class factoryClass = loadClass( this.documentBuilderFactoryName );
                this.factory = (DocumentBuilderFactory)factoryClass.newInstance();
            }
            this.factory.setNamespaceAware( true );
            this.factory.setValidating( this.validate );
        }
    }
19150#/**
     * @see org.apache.cocoon.core.xml.DOMParser#parseDocument(org.xml.sax.InputSource)
     */
    public Document parseDocument( final InputSource input )
    throws SAXException, IOException {
        final DocumentBuilder tmpBuilder = this.setupDocumentBuilder();

        final Document result = tmpBuilder.parse( input );

        return result;
    }
19151#/**
     * Creates a new {@link DocumentBuilder} if needed.
     */
    protected DocumentBuilder setupDocumentBuilder()
    throws SAXException {
        if ( this.factory == null ) {
            try {
                this.initDomBuilderFactory();
            } catch (Exception e) {
                final String message = "Cannot initialize dom builder factory";
                throw new SAXException( message, e );
            }
        }
        DocumentBuilder docBuilder;
        try {
            docBuilder = this.factory.newDocumentBuilder();
        } catch( final ParserConfigurationException pce ) {
            final String message = "Could not create DocumentBuilder";
            throw new SAXException( message, pce );
        }
        if( this.resolver != null ) {
            docBuilder.setEntityResolver( this.resolver );
        }

        return docBuilder;
    }
19152#/**
     * @see org.apache.cocoon.core.xml.DOMParser#createDocument()
     */
    public Document createDocument()
    throws SAXException {
        return this.setupDocumentBuilder().newDocument();
    }
19153#public Log getLogger() {
        return this.logger;
    }
19154#public void setLogger(Log l) {
        this.logger = l;
    }
19155#/**
     * Correct resource uris.
     */
    protected String correctUri(String uri) throws IOException {
        // if it is a file we have to recreate the url,
        // otherwise we get problems under windows with some file
        // references starting with "/DRIVELETTER" and some
        // just with "DRIVELETTER"
        if (uri.startsWith("file:")) {
            final File f = new File(uri.substring(5));
            return f.toURL().toExternalForm();
        }
        return uri;
    }
19156#public Integer getVerbosity() {
        return verbosity;
    }
19157#public void setVerbosity(Integer verbosity) {
        this.verbosity = verbosity;
    }
19158#public String getCatalog() {
        return catalog;
    }
19159#public void setCatalog(String catalog) {
        this.catalog = catalog;
    }
19160#public String getLocalCatalog() {
        return localCatalog;
    }
19161#public void setLocalCatalog(String localCatalog) {
        this.localCatalog = localCatalog;
    }
19162#public void setResourceLoader(ResourceLoader loader) {
        this.resourceLoader = loader;
    }
19163#public ResourceLoader getResourceLoader() {
        return resourceLoader;
    }
19164#/**
     * Set the configuration. Load the system catalog and apply any
     * parameters that may have been set using the public setter methods.
     */
    public void init()
    throws Exception { 
        // Over-ride debug level that is set by CatalogManager.properties
        if ( this.verbosity != null ) {
            if (this.getLogger().isDebugEnabled()) {
                this.getLogger().debug("Setting Catalog resolver verbosity level to " + this.verbosity);
            }
            this.catalogManager.setVerbosity(this.verbosity.intValue());
        }

        // Load the built-in catalog
        if ( this.catalog == null ) {
            this.getLogger().warn("No default catalog defined.");
        } else {
            this.parseCatalog(this.catalog);
        }

        // Load a single additional local catalog 
        if ( this.localCatalog != null ) {
            this.parseCatalog( this.localCatalog );
        }
    }
19165#/**
     * Parse a catalog
     */
    protected void parseCatalog(String uri) {
        if (this.getLogger().isDebugEnabled()) {
            this.getLogger().debug("Additional Catalog is " + uri);
        }

        final Resource resource = this.resourceLoader.getResource(uri);
        try {
            this.catalogResolver.getCatalog().parseCatalog(this.correctUri(resource.getURL().toExternalForm()));
        } catch (Exception e) {   
            this.getLogger().warn("Could not get Catalog file. Trying again: " + uri, e);
                        
            // try it again
            try {
                this.catalogResolver.getCatalog().parseCatalog("text/plain", resource.getInputStream());
            } catch (Exception ex) {
                this.getLogger().warn("Could not get Catalog file: " + uri, ex);
            }
        }
    }
19166#/**
     * Allow the application to resolve external entities.
     *
     * <p>The Parser will call this method before opening any external
     * entity except the top-level document entity (including the
     * external DTD subset, external entities referenced within the
     * DTD, and external entities referenced within the document
     * element): the application may request that the parser resolve
     * the entity itself, that it use an alternative URI, or that it
     * use an entirely different input source.</p>
     *
     * <p>Application writers can use this method to redirect external
     * system identifiers to secure and/or local URIs, to look up
     * public identifiers in a catalogue, or to read an entity from a
     * database or other input source (including, for example, a dialog
     * box).</p>
     *
     * <p>If the system identifier is a URL, the SAX parser must
     * resolve it fully before reporting it to the application.</p>
     *
     * @param publicId The public identifier of the external entity
     *        being referenced, or null if none was supplied.
     * @param systemId The system identifier of the external entity
     *        being referenced.
     * @return An InputSource object describing the new input source,
     *         or null to request that the parser open a regular
     *         URI connection to the system identifier.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @exception java.io.IOException A Java-specific IO exception,
     *            possibly the result of creating a new InputStream
     *            or Reader for the InputSource.
     * @see org.xml.sax.InputSource
     */
    public InputSource resolveEntity(String publicId, String systemId)
    throws SAXException, IOException {
        InputSource altInputSource = this.catalogResolver.resolveEntity(publicId, systemId);
        if (altInputSource != null) {
            if (this.getLogger().isDebugEnabled()) {
                this.getLogger().debug("Resolved catalog entity: "
                    + publicId + " " + altInputSource.getSystemId());
            }
        }

        return altInputSource;
    }
19167#protected Log getLogger() {
        return this.logger;
    }
19168#public void setLogger(Log l) {
        this.logger = l;
    }
19169#public void setEntityResolver(EntityResolver r) {
        this.resolver = r;
    }
19170#public EntityResolver getEntityResolver() {
        return this.resolver;
    }
19171#/**
     * @see #setValidate(boolean)
     */
    public boolean isValidate() {
        return validate;
    }
19172#/**
     * should the parser validate parsed documents ?
     * Default is false.
     */
    public void setValidate(boolean validate) {
        this.validate = validate;
    }
19173#public boolean isSearchResolver() {
        return searchResolver;
    }
19174#public void setSearchResolver(boolean searchResolver) {
        this.searchResolver = searchResolver;
    }
19175#/**
     * Load a class
     */
    protected Class loadClass( String name ) throws Exception {
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        if( loader == null ) {
            loader = getClass().getClassLoader();
        }
        return loader.loadClass( name );
    }
19176#/**
     * @see org.springframework.beans.factory.BeanFactoryAware#setBeanFactory(org.springframework.beans.factory.BeanFactory)
     */
    public void setBeanFactory(BeanFactory factory) throws BeansException {
        // we search for a resolver if we don't have one already 
        if ( this.resolver == null && this.searchResolver ) {
            if ( this.getLogger().isDebugEnabled() ) {
                this.getLogger().debug("Searching for entity resolver in factory: " + factory);
            }
            if ( factory.containsBean(EntityResolver.class.getName()) ) {
                this.resolver = (EntityResolver) factory.getBean(EntityResolver.class.getName());
                if ( this.getLogger().isDebugEnabled() ) {
                    this.getLogger().debug("Set resolver to: " + this.resolver);
                }
            }
        }
    }
19177#public void setSettings(Settings settings) {
        this.settings = settings;
    }
19178#/**
     * @see org.apache.cocoon.core.xml.impl.DefaultEntityResolver#init()
     */
    public void init()
    throws Exception {
        // create temporary directory for our entities
        final File workDirectory = new File(settings.getWorkDirectory());
        final File entitiesDirectory = new File(workDirectory, "cocoon_xml_resolver_entities");
        entitiesDirectory.mkdir();
        // deploy resources
        DeploymentUtil.deployJarResources("META-INF/cocoon/entities", entitiesDirectory.getAbsolutePath());
        // set catalog
        this.setCatalog(entitiesDirectory.toURL().toExternalForm() + "/catalog");
        // now initialize
        super.init();
    }
19179#/**
     * Construct a new <code>NamespacesTable</code> instance.
     */
    public NamespacesTable() {
        clear();
    }
19180#/**
     * Clear and reinitialize this namespace table before reuse.
     *
     * @since 2.1.8
     */
    public void clear() {
        this.lastEntry = Entry.create("","");
        this.addDeclaration("xml", "http://www.w3.org/XML/1998/namespace");
        // Lock this scope
        this.lastEntry.closedScopes = 1;
    }
19181#/**
     * Declare a new namespace prefix-uri mapping.
     *
     * @return The newly added <code>Declaration</code>.
     */
    public Declaration addDeclaration(String prefix, String uri) {
        // Find a previous declaration of the same prefix
        Entry dup = this.lastEntry;
        while (dup != null && !dup.prefix.equals(prefix)) {
            dup = dup.previous;
        }

        if (dup != null) {
            if (usesScopes && dup.uri.equals(uri)) {
                return dup;
            }
            dup.overriden = true;
        }

        Entry e = Entry.create(prefix, uri);
        e.previous = this.lastEntry;
        e.overrides = dup;
        this.lastEntry = e;
        // this always starts the declared prefix chain
        this.lastDeclaredEntry = e;
        return e;
    }
19182#/**
     * Undeclare a namespace prefix-uri mapping. If the prefix was previously declared
     * mapping another URI, its value is restored.
     * <p>
     * When using {@link #enterScope()}/{@link #leaveScope()}, this method does nothing and always
     * returns <code>null</code>, as declaration removal is handled in {@link #leaveScope()}.
     *
     * @return the removed <code>Declaration</code> or <b>null</b>.
     */
    public Declaration removeDeclaration(String prefix) {
        if (usesScopes) {
            // Automatically handled in leaveScope
            return null; // or throw and IllegalStateException if enterScope(handler) was used?
        }

        Entry current = this.lastEntry;
        Entry afterCurrent = null;
        while(current != null) {
            if (current.closedScopes > 0) {
                // Don't undeclare mappings not declared in this scope
                return null;
            }

            if (current.prefix.equals(prefix)) {
                // Got it
                // Remove it from the chain
                if (afterCurrent != null) {
                    afterCurrent.previous = current.previous;
                }
                // And report closed scopes on the previous entry
                current.previous.closedScopes += current.closedScopes;
                Entry overrides = current.overrides;
                if (overrides != null) {
                    // No more overriden
                    overrides.overriden = false;
                }

                if (this.lastDeclaredEntry == current) {
                    if (current.previous.closedScopes == 0) {
                        this.lastDeclaredEntry = current.previous;
                    } else {
                        this.lastDeclaredEntry = null;
                    }
                }

                if (this.lastEntry == current) {
                    this.lastEntry = current.previous;
                }

                return current;
            }

            afterCurrent = current;
            current = current.previous;
        }

        // Not found
        return null;
    }
19183#/**
     * Enter a new scope. This starts a new, empty list of declarations for the new scope.
     * <p>
     * Typically called in a SAX handler <em>before</em> sending a <code>startElement()</code>
     * event.
     *
     * @since 2.1.8
     */
    public void enterScope() {
        this.usesScopes = true;
        this.lastEntry.closedScopes++;
        this.lastDeclaredEntry = null;
    }
19184#/**
     * Start all declared mappings of the current scope and enter a new scope.  This starts a new,
     * empty list of declarations for the new scope.
     * <p>
     * Typically called in a SAX handler <em>before</em> sending a <code>startElement()</code>
     * event.
     *
     * @param handler the handler that will receive startPrefixMapping events.
     * @throws SAXException
     * @since 2.1.8
     */
    public void enterScope(ContentHandler handler) throws SAXException {
        this.usesScopes = true;
        Entry current = this.lastEntry;
        while (current != null && current.closedScopes == 0) {
            handler.startPrefixMapping(current.prefix, current.uri);
            current = current.previous;
        }
        this.lastEntry.closedScopes++;
        this.lastDeclaredEntry = null;
    }
19185#/**
     * Leave a scope. The namespace declarations that occured before the corresponding
     * <code>enterScope()</code> are no more visible using the resolution methods, but
     * still available using {@link #getCurrentScopeDeclarations()} until the next call
     * to {@link #addDeclaration(String, String)} or {@link #enterScope()}.
     * <p>
     * Typically called in a SAX handler <em>after</em> sending a <code>endElement()</code>
     * event.
     *
     * @since 2.1.8
     */
    public void leaveScope() {
        Entry current = this.lastEntry;

        // Purge declarations that were added but not included in a scope
        while (current.closedScopes == 0) {
            current = current.previous;
        }

        current.closedScopes--;

        if (current.closedScopes == 0) {
            this.lastDeclaredEntry = current;
        } else {
            // More than one scope closed here: no local declarations
            this.lastDeclaredEntry = null;
        }

        while (current != null && current.closedScopes == 0) {
            Entry overrides = current.overrides;
            if (overrides != null) {
                // No more overriden
                overrides.overriden = false;
            }
            current = current.previous;
        }
        this.lastEntry = current;
    }
19186#/**
     * Leave a scope. The namespace declarations that occured before the corresponding
     * <code>enterScope()</code> are no more visible using the resolution methods, but
     * still available using {@link #getCurrentScopeDeclarations()} until the next call
     * to {@link #addDeclaration(String, String)} or {@link #enterScope()}.
     * <p>
     * Typically called in a SAX handler <em>after</em> sending a <code>endElement()</code>
     * event.
     *
     * @param handler the handler that will receive endPrefixMapping events.
     * @throws SAXException
     * @since 2.1.8
     */
    public void leaveScope(ContentHandler handler) throws SAXException {
        Entry current = this.lastEntry;
        
        // Purge declarations that were added but not included in a scope
        while (current.closedScopes == 0) {
            current = current.previous;
        }

        current.closedScopes--;

        if (current.closedScopes == 0) {
            this.lastDeclaredEntry = current;
        } else {
            // More than one scope closed here: no local declarations
            this.lastDeclaredEntry = null;
        }

        while (current != null && current.closedScopes == 0) {
            handler.endPrefixMapping(current.prefix);
            Entry overrides = current.overrides;
            if (overrides != null) {
                // No more overriden
                overrides.overriden = false;
            }
            current = current.previous;
        }

        this.lastEntry = current;
    }
19187#/**
     * Get the declarations that were declared within the current scope.
     *
     * @return the declarations (possibly empty, but never null)
     * @since 2.1.8
     */
    public Declaration[] getCurrentScopeDeclarations() {
        int count = 0;
        Entry current = this.lastDeclaredEntry;
        while (current != null && current.closedScopes == 0) {
            count++;
            current = current.previous;
        }

        if (count == 0) return NO_DECLS;

        Declaration[] decls = new Declaration[count];
        count = 0;
        current = this.lastDeclaredEntry;
        while (current != null && current.closedScopes == 0) {
            decls[count++] = current;
            current = current.previous;
        }
        return decls;
    }
19188#/**
     * Return the URI associated with the given prefix or <b>null</b> if the
     * prefix was not mapped.
     */
    public String getUri(String prefix) {
        Entry current = this.lastEntry;
        while (current != null) {
            if (current.prefix.equals(prefix)) {
                return current.uri;
            }
            current = current.previous;
        }

        // Not found
        return null;
    }
19189#/**
     * Return an array with all prefixes currently mapped to the specified URI.
     * <br>
     * The array length might be <b>zero</b> if no prefixes are associated with
     * the specified uri.
     *
     * @return A <b>non-null</b> <code>String</code> array.
     */
    public String[] getPrefixes(String uri) {

        Entry current=this.lastEntry;
        int count=0;
        while (current!=null) {
            if(!current.overriden && current.uri.equals(uri))
                count++;
            current=current.previous;
        }
        if (count==0) return(new String[0]);

        String prefixes[]=new String[count];
        count=0;
        current = this.lastEntry;
        while (current!=null) {
            if(!current.overriden && current.uri.equals(uri))
                prefixes[count++] = current.prefix;
            current = current.previous;
        }
        return prefixes;
    }
19190#/**
     * Return one of the prefixes currently mapped to the specified URI or
     * <b>null</b>.
     */
    public String getPrefix(String uri) {
        Entry current = this.lastEntry;
        while (current != null) {
            if(!current.overriden && current.uri.equals(uri))
                return current.prefix;
            current = current.previous;
        }
        return null;
    }
19191#/**
     * Resolve a namespace-aware name against the current namespaces
     * declarations.
     *
     * @param uri The namespace URI or <b>null</b> if not known.
     * @param raw The raw (complete) name or <b>null</b> if not known.
     * @param prefix The namespace prefix or <b>null</b> if not known.
     * @param local The local name or <b>null</b> if not known.
     * @return A <b>non-null</b> <code>Name</code>.
     * @exception SAXException If the name cannot be resolved.
     */
    public Name resolve(String uri, String raw, String prefix, String local)
    throws SAXException {
        if (uri==null) uri="";
        if (raw==null) raw="";
        if (prefix==null) prefix="";
        if (local==null) local="";
        // Start examining the URI
        if (raw.length()>0) {
            // The raw name was specified
            int pos=raw.indexOf(':');
            if (pos>0) {
                // We have a namespace prefix:local separator
                String pre=raw.substring(0,pos);
                String loc=raw.substring(pos+1);
                if (prefix.length()==0) prefix=pre;
                else if (!prefix.equals(pre))
                    throw new SAXException("Raw/Prefix mismatch");
                if (local.length()==0) local=loc;
                else if (!local.equals(loc))
                    throw new SAXException("Raw/Local Name mismatch");
            } else {
                // We don't have a prefix:local separator
                if (prefix.length()>0)
                    throw new SAXException("Raw Name/Prefix mismatch");
                if (local.length()==0) local=raw;
                else if (!local.equals(raw))
                    throw new SAXException("Raw Name/Local Name mismatch");
            }
        } else {
            // The raw name was not specified
            if (local.length()==0) throw new SAXException("No Raw/Local Name");
            if (prefix.length()==0) raw=local;
            else raw=prefix+':'+local;
        }
        // We have resolved and checked data between the raw, local, and
        // prefix... We have to doublecheck the namespaces.
        if (uri.length()>0) {
            // We have a URI and a prefix, check them
            if ((prefix.length()>0) &&  (!uri.equals(this.getUri(prefix)))) {
                throw new SAXException("URI/Prefix mismatch [" + prefix + "," + uri + "]");
            } else {
                String temp=this.getPrefix(uri);
                if (temp==null) throw new SAXException("URI not declared");
                else if (temp.length()>0) {
                    prefix=temp;
                    raw=prefix+':'+local;
                }
            }
        } else {
            // We don't have a URI, check if we can find one from the prefix.
            String temp=this.getUri(prefix);
            if (temp==null) throw new SAXException("Prefix not declared");
            else uri=temp;
        }
        NameImpl name=new NameImpl();
        if (uri.length() > 0) name.uri=uri;
        else name.uri=null;
        name.raw=raw;
        name.prefix=prefix;
        name.local=local;
        return(name);
    }
19192#/** Create a new namespace declaration. */
        protected static Entry create(String prefix, String uri) {
            // Create a new entry
            Entry e = new Entry();
            // Set the prefix string.
            if (prefix != null) e.prefix=prefix;
            // Set the uri string.
            if (uri != null) e.uri=uri;
            // Return the entry
            return e;
        }
19193#/** Return the namespace URI. */
        public String getUri() { return this.uri; }
19194#/** Return the namespace prefix. */
        public String getPrefix() { return this.prefix; }
19195#/** Return the namespace URI. */
        public String getUri() { return this.uri; }
19196#/** Return the namespace prefix. */
        public String getPrefix() { return this.prefix; }
19197#/** Return the namespace local name. */
        public String getLocalName() { return this.local; }
19198#/** Return the namespace raw name. */
        public String getQName() { return this.raw; }
19199#/** Return the namespace URI. */
        String getUri();
19200#/** Return the namespace prefix. */
        String getPrefix();
19201#/** Return the namespace local name. */
        String getLocalName();
19202#/** Return the namespace raw name. */
        String getQName();
19203#/** Return the namespace URI. */
        String getUri();
19204#/** Return the namespace prefix. */
        String getPrefix();
